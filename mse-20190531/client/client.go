// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type GatewayDomain struct {
	CertIdentifier  *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	GatewayId       *int64  `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	GatewayName     *string `json:"GatewayName,omitempty" xml:"GatewayName,omitempty"`
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	GmtCreate       *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified     *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Id              *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	MustHttps       *string `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Protocol        *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s GatewayDomain) String() string {
	return tea.Prettify(s)
}

func (s GatewayDomain) GoString() string {
	return s.String()
}

func (s *GatewayDomain) SetCertIdentifier(v string) *GatewayDomain {
	s.CertIdentifier = &v
	return s
}

func (s *GatewayDomain) SetGatewayId(v int64) *GatewayDomain {
	s.GatewayId = &v
	return s
}

func (s *GatewayDomain) SetGatewayName(v string) *GatewayDomain {
	s.GatewayName = &v
	return s
}

func (s *GatewayDomain) SetGatewayUniqueId(v string) *GatewayDomain {
	s.GatewayUniqueId = &v
	return s
}

func (s *GatewayDomain) SetGmtCreate(v string) *GatewayDomain {
	s.GmtCreate = &v
	return s
}

func (s *GatewayDomain) SetGmtModified(v string) *GatewayDomain {
	s.GmtModified = &v
	return s
}

func (s *GatewayDomain) SetId(v int64) *GatewayDomain {
	s.Id = &v
	return s
}

func (s *GatewayDomain) SetMustHttps(v string) *GatewayDomain {
	s.MustHttps = &v
	return s
}

func (s *GatewayDomain) SetName(v string) *GatewayDomain {
	s.Name = &v
	return s
}

func (s *GatewayDomain) SetProtocol(v string) *GatewayDomain {
	s.Protocol = &v
	return s
}

type GatewayOption struct {
	DisableHttp2Alpn           *bool                          `json:"DisableHttp2Alpn,omitempty" xml:"DisableHttp2Alpn,omitempty"`
	EnableHardwareAcceleration *bool                          `json:"EnableHardwareAcceleration,omitempty" xml:"EnableHardwareAcceleration,omitempty"`
	EnableWaf                  *bool                          `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	LogConfigDetails           *GatewayOptionLogConfigDetails `json:"LogConfigDetails,omitempty" xml:"LogConfigDetails,omitempty" type:"Struct"`
	TraceDetails               *GatewayOptionTraceDetails     `json:"TraceDetails,omitempty" xml:"TraceDetails,omitempty" type:"Struct"`
}

func (s GatewayOption) String() string {
	return tea.Prettify(s)
}

func (s GatewayOption) GoString() string {
	return s.String()
}

func (s *GatewayOption) SetDisableHttp2Alpn(v bool) *GatewayOption {
	s.DisableHttp2Alpn = &v
	return s
}

func (s *GatewayOption) SetEnableHardwareAcceleration(v bool) *GatewayOption {
	s.EnableHardwareAcceleration = &v
	return s
}

func (s *GatewayOption) SetEnableWaf(v bool) *GatewayOption {
	s.EnableWaf = &v
	return s
}

func (s *GatewayOption) SetLogConfigDetails(v *GatewayOptionLogConfigDetails) *GatewayOption {
	s.LogConfigDetails = v
	return s
}

func (s *GatewayOption) SetTraceDetails(v *GatewayOptionTraceDetails) *GatewayOption {
	s.TraceDetails = v
	return s
}

type GatewayOptionLogConfigDetails struct {
	LogEnabled   *bool   `json:"LogEnabled,omitempty" xml:"LogEnabled,omitempty"`
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	ProjectName  *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s GatewayOptionLogConfigDetails) String() string {
	return tea.Prettify(s)
}

func (s GatewayOptionLogConfigDetails) GoString() string {
	return s.String()
}

func (s *GatewayOptionLogConfigDetails) SetLogEnabled(v bool) *GatewayOptionLogConfigDetails {
	s.LogEnabled = &v
	return s
}

func (s *GatewayOptionLogConfigDetails) SetLogStoreName(v string) *GatewayOptionLogConfigDetails {
	s.LogStoreName = &v
	return s
}

func (s *GatewayOptionLogConfigDetails) SetProjectName(v string) *GatewayOptionLogConfigDetails {
	s.ProjectName = &v
	return s
}

type GatewayOptionTraceDetails struct {
	Sample       *int64  `json:"Sample,omitempty" xml:"Sample,omitempty"`
	ServiceId    *int64  `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	ServicePort  *string `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	TraceEnabled *bool   `json:"TraceEnabled,omitempty" xml:"TraceEnabled,omitempty"`
	TraceType    *string `json:"TraceType,omitempty" xml:"TraceType,omitempty"`
}

func (s GatewayOptionTraceDetails) String() string {
	return tea.Prettify(s)
}

func (s GatewayOptionTraceDetails) GoString() string {
	return s.String()
}

func (s *GatewayOptionTraceDetails) SetSample(v int64) *GatewayOptionTraceDetails {
	s.Sample = &v
	return s
}

func (s *GatewayOptionTraceDetails) SetServiceId(v int64) *GatewayOptionTraceDetails {
	s.ServiceId = &v
	return s
}

func (s *GatewayOptionTraceDetails) SetServicePort(v string) *GatewayOptionTraceDetails {
	s.ServicePort = &v
	return s
}

func (s *GatewayOptionTraceDetails) SetTraceEnabled(v bool) *GatewayOptionTraceDetails {
	s.TraceEnabled = &v
	return s
}

func (s *GatewayOptionTraceDetails) SetTraceType(v string) *GatewayOptionTraceDetails {
	s.TraceType = &v
	return s
}

type GatewayService struct {
	GatewayTrafficPolicy *TrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	GatewayUniqueId      *string        `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	GroupName            *string        `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	Id                   *int64         `json:"Id,omitempty" xml:"Id,omitempty"`
	MetaInfo             *string        `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	Name                 *string        `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace            *string        `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	SourceType           *string        `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s GatewayService) String() string {
	return tea.Prettify(s)
}

func (s GatewayService) GoString() string {
	return s.String()
}

func (s *GatewayService) SetGatewayTrafficPolicy(v *TrafficPolicy) *GatewayService {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *GatewayService) SetGatewayUniqueId(v string) *GatewayService {
	s.GatewayUniqueId = &v
	return s
}

func (s *GatewayService) SetGroupName(v string) *GatewayService {
	s.GroupName = &v
	return s
}

func (s *GatewayService) SetId(v int64) *GatewayService {
	s.Id = &v
	return s
}

func (s *GatewayService) SetMetaInfo(v string) *GatewayService {
	s.MetaInfo = &v
	return s
}

func (s *GatewayService) SetName(v string) *GatewayService {
	s.Name = &v
	return s
}

func (s *GatewayService) SetNamespace(v string) *GatewayService {
	s.Namespace = &v
	return s
}

func (s *GatewayService) SetSourceType(v string) *GatewayService {
	s.SourceType = &v
	return s
}

type TrafficPolicy struct {
	LoadBalancerSettings *TrafficPolicyLoadBalancerSettings `json:"LoadBalancerSettings,omitempty" xml:"LoadBalancerSettings,omitempty" type:"Struct"`
	TlsSetting           *TrafficPolicyTlsSetting           `json:"TlsSetting,omitempty" xml:"TlsSetting,omitempty" type:"Struct"`
}

func (s TrafficPolicy) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicy) GoString() string {
	return s.String()
}

func (s *TrafficPolicy) SetLoadBalancerSettings(v *TrafficPolicyLoadBalancerSettings) *TrafficPolicy {
	s.LoadBalancerSettings = v
	return s
}

func (s *TrafficPolicy) SetTlsSetting(v *TrafficPolicyTlsSetting) *TrafficPolicy {
	s.TlsSetting = v
	return s
}

type TrafficPolicyLoadBalancerSettings struct {
	ConsistentHashLBConfig *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig `json:"ConsistentHashLBConfig,omitempty" xml:"ConsistentHashLBConfig,omitempty" type:"Struct"`
	LoadbalancerType       *string                                                  `json:"LoadbalancerType,omitempty" xml:"LoadbalancerType,omitempty"`
	WarmupDuration         *int64                                                   `json:"WarmupDuration,omitempty" xml:"WarmupDuration,omitempty"`
}

func (s TrafficPolicyLoadBalancerSettings) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyLoadBalancerSettings) GoString() string {
	return s.String()
}

func (s *TrafficPolicyLoadBalancerSettings) SetConsistentHashLBConfig(v *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) *TrafficPolicyLoadBalancerSettings {
	s.ConsistentHashLBConfig = v
	return s
}

func (s *TrafficPolicyLoadBalancerSettings) SetLoadbalancerType(v string) *TrafficPolicyLoadBalancerSettings {
	s.LoadbalancerType = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettings) SetWarmupDuration(v int64) *TrafficPolicyLoadBalancerSettings {
	s.WarmupDuration = &v
	return s
}

type TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig struct {
	ConsistentHashLBType *string                                                            `json:"ConsistentHashLBType,omitempty" xml:"ConsistentHashLBType,omitempty"`
	HttpCookie           *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie `json:"HttpCookie,omitempty" xml:"HttpCookie,omitempty" type:"Struct"`
	ParameterName        *string                                                            `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) GoString() string {
	return s.String()
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetConsistentHashLBType(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ConsistentHashLBType = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetHttpCookie(v *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.HttpCookie = v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetParameterName(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ParameterName = &v
	return s
}

type TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie struct {
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	TTL  *string `json:"TTL,omitempty" xml:"TTL,omitempty"`
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) GoString() string {
	return s.String()
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetName(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Name = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetPath(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Path = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetTTL(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.TTL = &v
	return s
}

type TrafficPolicyTlsSetting struct {
	CaCertContent *string `json:"CaCertContent,omitempty" xml:"CaCertContent,omitempty"`
	CertId        *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	Sni           *string `json:"Sni,omitempty" xml:"Sni,omitempty"`
	TlsMode       *string `json:"TlsMode,omitempty" xml:"TlsMode,omitempty"`
}

func (s TrafficPolicyTlsSetting) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyTlsSetting) GoString() string {
	return s.String()
}

func (s *TrafficPolicyTlsSetting) SetCaCertContent(v string) *TrafficPolicyTlsSetting {
	s.CaCertContent = &v
	return s
}

func (s *TrafficPolicyTlsSetting) SetCertId(v string) *TrafficPolicyTlsSetting {
	s.CertId = &v
	return s
}

func (s *TrafficPolicyTlsSetting) SetSni(v string) *TrafficPolicyTlsSetting {
	s.Sni = &v
	return s
}

func (s *TrafficPolicyTlsSetting) SetTlsMode(v string) *TrafficPolicyTlsSetting {
	s.TlsMode = &v
	return s
}

type RulesValue struct {
	Status      *int32           `json:"Status,omitempty" xml:"Status,omitempty"`
	Rate        *int32           `json:"Rate,omitempty" xml:"Rate,omitempty"`
	Enable      *bool            `json:"Enable,omitempty" xml:"Enable,omitempty"`
	Tag         *string          `json:"Tag,omitempty" xml:"Tag,omitempty"`
	Name        *string          `json:"Name,omitempty" xml:"Name,omitempty"`
	Id          *int64           `json:"Id,omitempty" xml:"Id,omitempty"`
	InstanceNum *int32           `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	Rules       *RulesValueRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
}

func (s RulesValue) String() string {
	return tea.Prettify(s)
}

func (s RulesValue) GoString() string {
	return s.String()
}

func (s *RulesValue) SetStatus(v int32) *RulesValue {
	s.Status = &v
	return s
}

func (s *RulesValue) SetRate(v int32) *RulesValue {
	s.Rate = &v
	return s
}

func (s *RulesValue) SetEnable(v bool) *RulesValue {
	s.Enable = &v
	return s
}

func (s *RulesValue) SetTag(v string) *RulesValue {
	s.Tag = &v
	return s
}

func (s *RulesValue) SetName(v string) *RulesValue {
	s.Name = &v
	return s
}

func (s *RulesValue) SetId(v int64) *RulesValue {
	s.Id = &v
	return s
}

func (s *RulesValue) SetInstanceNum(v int32) *RulesValue {
	s.InstanceNum = &v
	return s
}

func (s *RulesValue) SetRules(v *RulesValueRules) *RulesValue {
	s.Rules = v
	return s
}

type RulesValueRules struct {
	Springcloud []*RulesValueRulesSpringcloud `json:"springcloud,omitempty" xml:"springcloud,omitempty" type:"Repeated"`
	Dubbo       []*RulesValueRulesDubbo       `json:"dubbo,omitempty" xml:"dubbo,omitempty" type:"Repeated"`
}

func (s RulesValueRules) String() string {
	return tea.Prettify(s)
}

func (s RulesValueRules) GoString() string {
	return s.String()
}

func (s *RulesValueRules) SetSpringcloud(v []*RulesValueRulesSpringcloud) *RulesValueRules {
	s.Springcloud = v
	return s
}

func (s *RulesValueRules) SetDubbo(v []*RulesValueRulesDubbo) *RulesValueRules {
	s.Dubbo = v
	return s
}

type RulesValueRulesSpringcloud struct {
	Condition     *string                                `json:"condition,omitempty" xml:"condition,omitempty"`
	RestItems     []*RulesValueRulesSpringcloudRestItems `json:"restItems,omitempty" xml:"restItems,omitempty" type:"Repeated"`
	TriggerPolicy *string                                `json:"triggerPolicy,omitempty" xml:"triggerPolicy,omitempty"`
	Enable        *bool                                  `json:"enable,omitempty" xml:"enable,omitempty"`
	AppId         *string                                `json:"appId,omitempty" xml:"appId,omitempty"`
	Priority      *int32                                 `json:"priority,omitempty" xml:"priority,omitempty"`
	Tags          []*string                              `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	Paths         []*string                              `json:"paths,omitempty" xml:"paths,omitempty" type:"Repeated"`
	Path          *string                                `json:"path,omitempty" xml:"path,omitempty"`
}

func (s RulesValueRulesSpringcloud) String() string {
	return tea.Prettify(s)
}

func (s RulesValueRulesSpringcloud) GoString() string {
	return s.String()
}

func (s *RulesValueRulesSpringcloud) SetCondition(v string) *RulesValueRulesSpringcloud {
	s.Condition = &v
	return s
}

func (s *RulesValueRulesSpringcloud) SetRestItems(v []*RulesValueRulesSpringcloudRestItems) *RulesValueRulesSpringcloud {
	s.RestItems = v
	return s
}

func (s *RulesValueRulesSpringcloud) SetTriggerPolicy(v string) *RulesValueRulesSpringcloud {
	s.TriggerPolicy = &v
	return s
}

func (s *RulesValueRulesSpringcloud) SetEnable(v bool) *RulesValueRulesSpringcloud {
	s.Enable = &v
	return s
}

func (s *RulesValueRulesSpringcloud) SetAppId(v string) *RulesValueRulesSpringcloud {
	s.AppId = &v
	return s
}

func (s *RulesValueRulesSpringcloud) SetPriority(v int32) *RulesValueRulesSpringcloud {
	s.Priority = &v
	return s
}

func (s *RulesValueRulesSpringcloud) SetTags(v []*string) *RulesValueRulesSpringcloud {
	s.Tags = v
	return s
}

func (s *RulesValueRulesSpringcloud) SetPaths(v []*string) *RulesValueRulesSpringcloud {
	s.Paths = v
	return s
}

func (s *RulesValueRulesSpringcloud) SetPath(v string) *RulesValueRulesSpringcloud {
	s.Path = &v
	return s
}

type RulesValueRulesSpringcloudRestItems struct {
	Datum     *string     `json:"datum,omitempty" xml:"datum,omitempty"`
	Operator  *string     `json:"operator,omitempty" xml:"operator,omitempty"`
	NameList  []*string   `json:"nameList,omitempty" xml:"nameList,omitempty" type:"Repeated"`
	Cond      *string     `json:"cond,omitempty" xml:"cond,omitempty"`
	Divisor   *int32      `json:"divisor,omitempty" xml:"divisor,omitempty"`
	Remainder *int32      `json:"remainder,omitempty" xml:"remainder,omitempty"`
	Rate      *int32      `json:"rate,omitempty" xml:"rate,omitempty"`
	Type      *string     `json:"type,omitempty" xml:"type,omitempty"`
	Name      *string     `json:"name,omitempty" xml:"name,omitempty"`
	Value     interface{} `json:"value,omitempty" xml:"value,omitempty"`
}

func (s RulesValueRulesSpringcloudRestItems) String() string {
	return tea.Prettify(s)
}

func (s RulesValueRulesSpringcloudRestItems) GoString() string {
	return s.String()
}

func (s *RulesValueRulesSpringcloudRestItems) SetDatum(v string) *RulesValueRulesSpringcloudRestItems {
	s.Datum = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetOperator(v string) *RulesValueRulesSpringcloudRestItems {
	s.Operator = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetNameList(v []*string) *RulesValueRulesSpringcloudRestItems {
	s.NameList = v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetCond(v string) *RulesValueRulesSpringcloudRestItems {
	s.Cond = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetDivisor(v int32) *RulesValueRulesSpringcloudRestItems {
	s.Divisor = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetRemainder(v int32) *RulesValueRulesSpringcloudRestItems {
	s.Remainder = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetRate(v int32) *RulesValueRulesSpringcloudRestItems {
	s.Rate = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetType(v string) *RulesValueRulesSpringcloudRestItems {
	s.Type = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetName(v string) *RulesValueRulesSpringcloudRestItems {
	s.Name = &v
	return s
}

func (s *RulesValueRulesSpringcloudRestItems) SetValue(v interface{}) *RulesValueRulesSpringcloudRestItems {
	s.Value = v
	return s
}

type RulesValueRulesDubbo struct {
	AppId         *string                              `json:"appId,omitempty" xml:"appId,omitempty"`
	Tags          []*string                            `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	TriggerPolicy *string                              `json:"triggerPolicy,omitempty" xml:"triggerPolicy,omitempty"`
	ServiceName   *string                              `json:"serviceName,omitempty" xml:"serviceName,omitempty"`
	Group         *string                              `json:"group,omitempty" xml:"group,omitempty"`
	Version       *string                              `json:"version,omitempty" xml:"version,omitempty"`
	MethodName    *string                              `json:"methodName,omitempty" xml:"methodName,omitempty"`
	ParamTypes    []*string                            `json:"paramTypes,omitempty" xml:"paramTypes,omitempty" type:"Repeated"`
	Condition     *string                              `json:"condition,omitempty" xml:"condition,omitempty"`
	ArgumentItems []*RulesValueRulesDubboArgumentItems `json:"argumentItems,omitempty" xml:"argumentItems,omitempty" type:"Repeated"`
}

func (s RulesValueRulesDubbo) String() string {
	return tea.Prettify(s)
}

func (s RulesValueRulesDubbo) GoString() string {
	return s.String()
}

func (s *RulesValueRulesDubbo) SetAppId(v string) *RulesValueRulesDubbo {
	s.AppId = &v
	return s
}

func (s *RulesValueRulesDubbo) SetTags(v []*string) *RulesValueRulesDubbo {
	s.Tags = v
	return s
}

func (s *RulesValueRulesDubbo) SetTriggerPolicy(v string) *RulesValueRulesDubbo {
	s.TriggerPolicy = &v
	return s
}

func (s *RulesValueRulesDubbo) SetServiceName(v string) *RulesValueRulesDubbo {
	s.ServiceName = &v
	return s
}

func (s *RulesValueRulesDubbo) SetGroup(v string) *RulesValueRulesDubbo {
	s.Group = &v
	return s
}

func (s *RulesValueRulesDubbo) SetVersion(v string) *RulesValueRulesDubbo {
	s.Version = &v
	return s
}

func (s *RulesValueRulesDubbo) SetMethodName(v string) *RulesValueRulesDubbo {
	s.MethodName = &v
	return s
}

func (s *RulesValueRulesDubbo) SetParamTypes(v []*string) *RulesValueRulesDubbo {
	s.ParamTypes = v
	return s
}

func (s *RulesValueRulesDubbo) SetCondition(v string) *RulesValueRulesDubbo {
	s.Condition = &v
	return s
}

func (s *RulesValueRulesDubbo) SetArgumentItems(v []*RulesValueRulesDubboArgumentItems) *RulesValueRulesDubbo {
	s.ArgumentItems = v
	return s
}

type RulesValueRulesDubboArgumentItems struct {
	Operator  *string     `json:"operator,omitempty" xml:"operator,omitempty"`
	NameList  []*string   `json:"nameList,omitempty" xml:"nameList,omitempty" type:"Repeated"`
	Datum     *string     `json:"datum,omitempty" xml:"datum,omitempty"`
	Cond      *string     `json:"cond,omitempty" xml:"cond,omitempty"`
	Divisor   *int32      `json:"divisor,omitempty" xml:"divisor,omitempty"`
	Remainder *int32      `json:"remainder,omitempty" xml:"remainder,omitempty"`
	Rate      *int32      `json:"rate,omitempty" xml:"rate,omitempty"`
	Index     *int32      `json:"index,omitempty" xml:"index,omitempty"`
	Expr      *string     `json:"expr,omitempty" xml:"expr,omitempty"`
	Value     interface{} `json:"value,omitempty" xml:"value,omitempty"`
}

func (s RulesValueRulesDubboArgumentItems) String() string {
	return tea.Prettify(s)
}

func (s RulesValueRulesDubboArgumentItems) GoString() string {
	return s.String()
}

func (s *RulesValueRulesDubboArgumentItems) SetOperator(v string) *RulesValueRulesDubboArgumentItems {
	s.Operator = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetNameList(v []*string) *RulesValueRulesDubboArgumentItems {
	s.NameList = v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetDatum(v string) *RulesValueRulesDubboArgumentItems {
	s.Datum = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetCond(v string) *RulesValueRulesDubboArgumentItems {
	s.Cond = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetDivisor(v int32) *RulesValueRulesDubboArgumentItems {
	s.Divisor = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetRemainder(v int32) *RulesValueRulesDubboArgumentItems {
	s.Remainder = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetRate(v int32) *RulesValueRulesDubboArgumentItems {
	s.Rate = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetIndex(v int32) *RulesValueRulesDubboArgumentItems {
	s.Index = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetExpr(v string) *RulesValueRulesDubboArgumentItems {
	s.Expr = &v
	return s
}

func (s *RulesValueRulesDubboArgumentItems) SetValue(v interface{}) *RulesValueRulesDubboArgumentItems {
	s.Value = v
	return s
}

type DataValue struct {
	// The ID of the user to which the application belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The region where the application resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The microservice namespace where the application resides.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s DataValue) String() string {
	return tea.Prettify(s)
}

func (s DataValue) GoString() string {
	return s.String()
}

func (s *DataValue) SetUserId(v string) *DataValue {
	s.UserId = &v
	return s
}

func (s *DataValue) SetRegionId(v string) *DataValue {
	s.RegionId = &v
	return s
}

func (s *DataValue) SetNamespace(v string) *DataValue {
	s.Namespace = &v
	return s
}

func (s *DataValue) SetAppName(v string) *DataValue {
	s.AppName = &v
	return s
}

func (s *DataValue) SetAppId(v string) *DataValue {
	s.AppId = &v
	return s
}

type AddAuthPolicyRequest struct {
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	AppId          *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AuthRule       *string `json:"AuthRule,omitempty" xml:"AuthRule,omitempty"`
	AuthType       *int32  `json:"AuthType,omitempty" xml:"AuthType,omitempty"`
	Enable         *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	K8sNamespace   *string `json:"K8sNamespace,omitempty" xml:"K8sNamespace,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace      *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	Protocol       *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	Region         *string `json:"Region,omitempty" xml:"Region,omitempty"`
	Source         *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s AddAuthPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAuthPolicyRequest) GoString() string {
	return s.String()
}

func (s *AddAuthPolicyRequest) SetAcceptLanguage(v string) *AddAuthPolicyRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddAuthPolicyRequest) SetAppId(v string) *AddAuthPolicyRequest {
	s.AppId = &v
	return s
}

func (s *AddAuthPolicyRequest) SetAuthRule(v string) *AddAuthPolicyRequest {
	s.AuthRule = &v
	return s
}

func (s *AddAuthPolicyRequest) SetAuthType(v int32) *AddAuthPolicyRequest {
	s.AuthType = &v
	return s
}

func (s *AddAuthPolicyRequest) SetEnable(v string) *AddAuthPolicyRequest {
	s.Enable = &v
	return s
}

func (s *AddAuthPolicyRequest) SetK8sNamespace(v string) *AddAuthPolicyRequest {
	s.K8sNamespace = &v
	return s
}

func (s *AddAuthPolicyRequest) SetName(v string) *AddAuthPolicyRequest {
	s.Name = &v
	return s
}

func (s *AddAuthPolicyRequest) SetNamespace(v string) *AddAuthPolicyRequest {
	s.Namespace = &v
	return s
}

func (s *AddAuthPolicyRequest) SetProtocol(v string) *AddAuthPolicyRequest {
	s.Protocol = &v
	return s
}

func (s *AddAuthPolicyRequest) SetRegion(v string) *AddAuthPolicyRequest {
	s.Region = &v
	return s
}

func (s *AddAuthPolicyRequest) SetSource(v string) *AddAuthPolicyRequest {
	s.Source = &v
	return s
}

type AddAuthPolicyResponseBody struct {
	Code           *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data           *string `json:"Data,omitempty" xml:"Data,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	Message        *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddAuthPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAuthPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *AddAuthPolicyResponseBody) SetCode(v int32) *AddAuthPolicyResponseBody {
	s.Code = &v
	return s
}

func (s *AddAuthPolicyResponseBody) SetData(v string) *AddAuthPolicyResponseBody {
	s.Data = &v
	return s
}

func (s *AddAuthPolicyResponseBody) SetHttpStatusCode(v int32) *AddAuthPolicyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddAuthPolicyResponseBody) SetMessage(v string) *AddAuthPolicyResponseBody {
	s.Message = &v
	return s
}

func (s *AddAuthPolicyResponseBody) SetRequestId(v string) *AddAuthPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddAuthPolicyResponseBody) SetSuccess(v bool) *AddAuthPolicyResponseBody {
	s.Success = &v
	return s
}

type AddAuthPolicyResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddAuthPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddAuthPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAuthPolicyResponse) GoString() string {
	return s.String()
}

func (s *AddAuthPolicyResponse) SetHeaders(v map[string]*string) *AddAuthPolicyResponse {
	s.Headers = v
	return s
}

func (s *AddAuthPolicyResponse) SetStatusCode(v int32) *AddAuthPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAuthPolicyResponse) SetBody(v *AddAuthPolicyResponseBody) *AddAuthPolicyResponse {
	s.Body = v
	return s
}

type AddAuthResourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the authorization record.
	AuthId *int64 `json:"AuthId,omitempty" xml:"AuthId,omitempty"`
	// The authentication resource headers.
	AuthResourceHeaderList []*AddAuthResourceRequestAuthResourceHeaderList `json:"AuthResourceHeaderList,omitempty" xml:"AuthResourceHeaderList,omitempty" type:"Repeated"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether the matching is not case-sensitive. Default value: true.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The matching type. Valid values:
	//
	// *   EQUAL
	// *   PRE
	// *   ERGULAR
	MatchType *string `json:"MatchType,omitempty" xml:"MatchType,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AddAuthResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceRequest) GoString() string {
	return s.String()
}

func (s *AddAuthResourceRequest) SetAcceptLanguage(v string) *AddAuthResourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddAuthResourceRequest) SetAuthId(v int64) *AddAuthResourceRequest {
	s.AuthId = &v
	return s
}

func (s *AddAuthResourceRequest) SetAuthResourceHeaderList(v []*AddAuthResourceRequestAuthResourceHeaderList) *AddAuthResourceRequest {
	s.AuthResourceHeaderList = v
	return s
}

func (s *AddAuthResourceRequest) SetDomainId(v int64) *AddAuthResourceRequest {
	s.DomainId = &v
	return s
}

func (s *AddAuthResourceRequest) SetGatewayUniqueId(v string) *AddAuthResourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddAuthResourceRequest) SetIgnoreCase(v bool) *AddAuthResourceRequest {
	s.IgnoreCase = &v
	return s
}

func (s *AddAuthResourceRequest) SetMatchType(v string) *AddAuthResourceRequest {
	s.MatchType = &v
	return s
}

func (s *AddAuthResourceRequest) SetPath(v string) *AddAuthResourceRequest {
	s.Path = &v
	return s
}

type AddAuthResourceRequestAuthResourceHeaderList struct {
	// The parameter of the HTTP header.
	HeaderKey *string `json:"HeaderKey,omitempty" xml:"HeaderKey,omitempty"`
	// The header matching mode.
	//
	// Valid values:
	//
	// *   SUFFIX
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   EXIST
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   PREFIX
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   EQUAL
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   EXCLUDE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NOT_EQUAL
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NOT_EXIST
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   REGREX
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   INCLUDE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	HeaderMethod *string `json:"HeaderMethod,omitempty" xml:"HeaderMethod,omitempty"`
	// The parameter value of the HTTP header.
	HeaderValue *string `json:"HeaderValue,omitempty" xml:"HeaderValue,omitempty"`
}

func (s AddAuthResourceRequestAuthResourceHeaderList) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceRequestAuthResourceHeaderList) GoString() string {
	return s.String()
}

func (s *AddAuthResourceRequestAuthResourceHeaderList) SetHeaderKey(v string) *AddAuthResourceRequestAuthResourceHeaderList {
	s.HeaderKey = &v
	return s
}

func (s *AddAuthResourceRequestAuthResourceHeaderList) SetHeaderMethod(v string) *AddAuthResourceRequestAuthResourceHeaderList {
	s.HeaderMethod = &v
	return s
}

func (s *AddAuthResourceRequestAuthResourceHeaderList) SetHeaderValue(v string) *AddAuthResourceRequestAuthResourceHeaderList {
	s.HeaderValue = &v
	return s
}

type AddAuthResourceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the authorization record.
	AuthId *int64 `json:"AuthId,omitempty" xml:"AuthId,omitempty"`
	// The authentication resource headers.
	AuthResourceHeaderListShrink *string `json:"AuthResourceHeaderList,omitempty" xml:"AuthResourceHeaderList,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether the matching is not case-sensitive. Default value: true.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The matching type. Valid values:
	//
	// *   EQUAL
	// *   PRE
	// *   ERGULAR
	MatchType *string `json:"MatchType,omitempty" xml:"MatchType,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AddAuthResourceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddAuthResourceShrinkRequest) SetAcceptLanguage(v string) *AddAuthResourceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetAuthId(v int64) *AddAuthResourceShrinkRequest {
	s.AuthId = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetAuthResourceHeaderListShrink(v string) *AddAuthResourceShrinkRequest {
	s.AuthResourceHeaderListShrink = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetDomainId(v int64) *AddAuthResourceShrinkRequest {
	s.DomainId = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetGatewayUniqueId(v string) *AddAuthResourceShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetIgnoreCase(v bool) *AddAuthResourceShrinkRequest {
	s.IgnoreCase = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetMatchType(v string) *AddAuthResourceShrinkRequest {
	s.MatchType = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetPath(v string) *AddAuthResourceShrinkRequest {
	s.Path = &v
	return s
}

type AddAuthResourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddAuthResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceResponseBody) GoString() string {
	return s.String()
}

func (s *AddAuthResourceResponseBody) SetCode(v int32) *AddAuthResourceResponseBody {
	s.Code = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetData(v int64) *AddAuthResourceResponseBody {
	s.Data = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetHttpStatusCode(v int32) *AddAuthResourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetMessage(v string) *AddAuthResourceResponseBody {
	s.Message = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetRequestId(v string) *AddAuthResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetSuccess(v bool) *AddAuthResourceResponseBody {
	s.Success = &v
	return s
}

type AddAuthResourceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddAuthResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddAuthResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceResponse) GoString() string {
	return s.String()
}

func (s *AddAuthResourceResponse) SetHeaders(v map[string]*string) *AddAuthResourceResponse {
	s.Headers = v
	return s
}

func (s *AddAuthResourceResponse) SetStatusCode(v int32) *AddAuthResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAuthResourceResponse) SetBody(v *AddAuthResourceResponseBody) *AddAuthResourceResponse {
	s.Body = v
	return s
}

type AddBlackWhiteListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The content of the blacklist.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The whitelist. Default value: No.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The description.
	Note *string `json:"Note,omitempty" xml:"Note,omitempty"`
	// The resource IDs in the JSON format.
	ResourceIdJsonList *string `json:"ResourceIdJsonList,omitempty" xml:"ResourceIdJsonList,omitempty"`
	// The effective scope of the blacklist or whitelist. Valid values:
	//
	// *   GATEWAY
	// *   DOMAIN
	// *   ROUTE
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the blacklist.
	//
	// *   on: enabled
	// *   off: disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of object in the blacklist or whitelist.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddBlackWhiteListRequest) String() string {
	return tea.Prettify(s)
}

func (s AddBlackWhiteListRequest) GoString() string {
	return s.String()
}

func (s *AddBlackWhiteListRequest) SetAcceptLanguage(v string) *AddBlackWhiteListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetContent(v string) *AddBlackWhiteListRequest {
	s.Content = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetGatewayUniqueId(v string) *AddBlackWhiteListRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetIsWhite(v bool) *AddBlackWhiteListRequest {
	s.IsWhite = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetName(v string) *AddBlackWhiteListRequest {
	s.Name = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetNote(v string) *AddBlackWhiteListRequest {
	s.Note = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetResourceIdJsonList(v string) *AddBlackWhiteListRequest {
	s.ResourceIdJsonList = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetResourceType(v string) *AddBlackWhiteListRequest {
	s.ResourceType = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetStatus(v string) *AddBlackWhiteListRequest {
	s.Status = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetType(v string) *AddBlackWhiteListRequest {
	s.Type = &v
	return s
}

type AddBlackWhiteListResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the record.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddBlackWhiteListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddBlackWhiteListResponseBody) GoString() string {
	return s.String()
}

func (s *AddBlackWhiteListResponseBody) SetCode(v int32) *AddBlackWhiteListResponseBody {
	s.Code = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetData(v int64) *AddBlackWhiteListResponseBody {
	s.Data = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetHttpStatusCode(v int32) *AddBlackWhiteListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetMessage(v string) *AddBlackWhiteListResponseBody {
	s.Message = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetRequestId(v string) *AddBlackWhiteListResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetSuccess(v bool) *AddBlackWhiteListResponseBody {
	s.Success = &v
	return s
}

type AddBlackWhiteListResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddBlackWhiteListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddBlackWhiteListResponse) String() string {
	return tea.Prettify(s)
}

func (s AddBlackWhiteListResponse) GoString() string {
	return s.String()
}

func (s *AddBlackWhiteListResponse) SetHeaders(v map[string]*string) *AddBlackWhiteListResponse {
	s.Headers = v
	return s
}

func (s *AddBlackWhiteListResponse) SetStatusCode(v int32) *AddBlackWhiteListResponse {
	s.StatusCode = &v
	return s
}

func (s *AddBlackWhiteListResponse) SetBody(v *AddBlackWhiteListResponseBody) *AddBlackWhiteListResponse {
	s.Body = v
	return s
}

type AddGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The billing method.
	//
	// Valid values:
	//
	// *   PREPAY
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the subscription billing method
	//
	//     <!-- -->
	//
	// *   POSTPAY
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the pay-as-you-go billing method
	//
	//     <!-- -->
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// Specifies whether to activate Tracing Analysis.
	EnableHardwareAcceleration *bool `json:"EnableHardwareAcceleration,omitempty" xml:"EnableHardwareAcceleration,omitempty"`
	// The tag of the gateway.
	EnableSls *bool `json:"EnableSls,omitempty" xml:"EnableSls,omitempty"`
	// The sampling rate of Tracing Analysis. Valid values: \[1,100].
	EnableXtrace *bool `json:"EnableXtrace,omitempty" xml:"EnableXtrace,omitempty"`
	// Specifies whether to enable hardware acceleration.
	EnterpriseSecurityGroup *bool `json:"EnterpriseSecurityGroup,omitempty" xml:"EnterpriseSecurityGroup,omitempty"`
	// The ID of the secondary vSwitch.
	InternetSlbSpec *string `json:"InternetSlbSpec,omitempty" xml:"InternetSlbSpec,omitempty"`
	// The MSE instance type. Valid values:
	//
	// *   mse_pro: ordinary instance.
	// *   mse_serverless: serverless instance.
	MserVersion *string `json:"MserVersion,omitempty" xml:"MserVersion,omitempty"`
	// The ID of the region.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the Network Load Balancer (NLB) instance when the serverless NLB instance is purchased. Valid values:
	//
	// *   pubnet
	// *   privatenet
	// *   privatepubnet
	NlbNetworkType *string `json:"NlbNetworkType,omitempty" xml:"NlbNetworkType,omitempty"`
	// The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of nodes.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The extended field.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	SlbSpec *string `json:"SlbSpec,omitempty" xml:"SlbSpec,omitempty"`
	// The node specifications. Valid values:
	//
	// *   MSE_GTW\_16\_32\_200\_c(16C32G)
	// *   MSE_GTW\_2\_4\_200\_c(2C4G)
	// *   MSE_GTW\_4\_8\_200\_c(4C8G)
	// *   MSE_GTW\_8\_16\_200\_c(8C16G)
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The tag object.
	Tag []*AddGatewayRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the primary vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// Specifies whether to use an advanced security group.
	VSwitchId2 *string `json:"VSwitchId2,omitempty" xml:"VSwitchId2,omitempty"`
	// The ID of the primary vSwitch.
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
	// Specifies whether to activate Log Service.
	XtraceRatio *string `json:"XtraceRatio,omitempty" xml:"XtraceRatio,omitempty"`
	// The details of the zone.
	ZoneInfo []*AddGatewayRequestZoneInfo `json:"ZoneInfo,omitempty" xml:"ZoneInfo,omitempty" type:"Repeated"`
}

func (s AddGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayRequest) SetAcceptLanguage(v string) *AddGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayRequest) SetChargeType(v string) *AddGatewayRequest {
	s.ChargeType = &v
	return s
}

func (s *AddGatewayRequest) SetEnableHardwareAcceleration(v bool) *AddGatewayRequest {
	s.EnableHardwareAcceleration = &v
	return s
}

func (s *AddGatewayRequest) SetEnableSls(v bool) *AddGatewayRequest {
	s.EnableSls = &v
	return s
}

func (s *AddGatewayRequest) SetEnableXtrace(v bool) *AddGatewayRequest {
	s.EnableXtrace = &v
	return s
}

func (s *AddGatewayRequest) SetEnterpriseSecurityGroup(v bool) *AddGatewayRequest {
	s.EnterpriseSecurityGroup = &v
	return s
}

func (s *AddGatewayRequest) SetInternetSlbSpec(v string) *AddGatewayRequest {
	s.InternetSlbSpec = &v
	return s
}

func (s *AddGatewayRequest) SetMserVersion(v string) *AddGatewayRequest {
	s.MserVersion = &v
	return s
}

func (s *AddGatewayRequest) SetName(v string) *AddGatewayRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayRequest) SetNlbNetworkType(v string) *AddGatewayRequest {
	s.NlbNetworkType = &v
	return s
}

func (s *AddGatewayRequest) SetRegion(v string) *AddGatewayRequest {
	s.Region = &v
	return s
}

func (s *AddGatewayRequest) SetReplica(v int32) *AddGatewayRequest {
	s.Replica = &v
	return s
}

func (s *AddGatewayRequest) SetRequestPars(v string) *AddGatewayRequest {
	s.RequestPars = &v
	return s
}

func (s *AddGatewayRequest) SetResourceGroupId(v string) *AddGatewayRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddGatewayRequest) SetSlbSpec(v string) *AddGatewayRequest {
	s.SlbSpec = &v
	return s
}

func (s *AddGatewayRequest) SetSpec(v string) *AddGatewayRequest {
	s.Spec = &v
	return s
}

func (s *AddGatewayRequest) SetTag(v []*AddGatewayRequestTag) *AddGatewayRequest {
	s.Tag = v
	return s
}

func (s *AddGatewayRequest) SetVSwitchId(v string) *AddGatewayRequest {
	s.VSwitchId = &v
	return s
}

func (s *AddGatewayRequest) SetVSwitchId2(v string) *AddGatewayRequest {
	s.VSwitchId2 = &v
	return s
}

func (s *AddGatewayRequest) SetVpc(v string) *AddGatewayRequest {
	s.Vpc = &v
	return s
}

func (s *AddGatewayRequest) SetXtraceRatio(v string) *AddGatewayRequest {
	s.XtraceRatio = &v
	return s
}

func (s *AddGatewayRequest) SetZoneInfo(v []*AddGatewayRequestZoneInfo) *AddGatewayRequest {
	s.ZoneInfo = v
	return s
}

type AddGatewayRequestTag struct {
	// The value of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the resource group.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGatewayRequestTag) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRequestTag) GoString() string {
	return s.String()
}

func (s *AddGatewayRequestTag) SetKey(v string) *AddGatewayRequestTag {
	s.Key = &v
	return s
}

func (s *AddGatewayRequestTag) SetValue(v string) *AddGatewayRequestTag {
	s.Value = &v
	return s
}

type AddGatewayRequestZoneInfo struct {
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s AddGatewayRequestZoneInfo) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRequestZoneInfo) GoString() string {
	return s.String()
}

func (s *AddGatewayRequestZoneInfo) SetVSwitchId(v string) *AddGatewayRequestZoneInfo {
	s.VSwitchId = &v
	return s
}

func (s *AddGatewayRequestZoneInfo) SetZoneId(v string) *AddGatewayRequestZoneInfo {
	s.ZoneId = &v
	return s
}

type AddGatewayShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The billing method.
	//
	// Valid values:
	//
	// *   PREPAY
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the subscription billing method
	//
	//     <!-- -->
	//
	// *   POSTPAY
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the pay-as-you-go billing method
	//
	//     <!-- -->
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// Specifies whether to activate Tracing Analysis.
	EnableHardwareAcceleration *bool `json:"EnableHardwareAcceleration,omitempty" xml:"EnableHardwareAcceleration,omitempty"`
	// The tag of the gateway.
	EnableSls *bool `json:"EnableSls,omitempty" xml:"EnableSls,omitempty"`
	// The sampling rate of Tracing Analysis. Valid values: \[1,100].
	EnableXtrace *bool `json:"EnableXtrace,omitempty" xml:"EnableXtrace,omitempty"`
	// Specifies whether to enable hardware acceleration.
	EnterpriseSecurityGroup *bool `json:"EnterpriseSecurityGroup,omitempty" xml:"EnterpriseSecurityGroup,omitempty"`
	// The ID of the secondary vSwitch.
	InternetSlbSpec *string `json:"InternetSlbSpec,omitempty" xml:"InternetSlbSpec,omitempty"`
	// The MSE instance type. Valid values:
	//
	// *   mse_pro: ordinary instance.
	// *   mse_serverless: serverless instance.
	MserVersion *string `json:"MserVersion,omitempty" xml:"MserVersion,omitempty"`
	// The ID of the region.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network type of the Network Load Balancer (NLB) instance when the serverless NLB instance is purchased. Valid values:
	//
	// *   pubnet
	// *   privatenet
	// *   privatepubnet
	NlbNetworkType *string `json:"NlbNetworkType,omitempty" xml:"NlbNetworkType,omitempty"`
	// The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of nodes.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The extended field.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	SlbSpec *string `json:"SlbSpec,omitempty" xml:"SlbSpec,omitempty"`
	// The node specifications. Valid values:
	//
	// *   MSE_GTW\_16\_32\_200\_c(16C32G)
	// *   MSE_GTW\_2\_4\_200\_c(2C4G)
	// *   MSE_GTW\_4\_8\_200\_c(4C8G)
	// *   MSE_GTW\_8\_16\_200\_c(8C16G)
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The tag object.
	Tag []*AddGatewayShrinkRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the primary vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// Specifies whether to use an advanced security group.
	VSwitchId2 *string `json:"VSwitchId2,omitempty" xml:"VSwitchId2,omitempty"`
	// The ID of the primary vSwitch.
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
	// Specifies whether to activate Log Service.
	XtraceRatio *string `json:"XtraceRatio,omitempty" xml:"XtraceRatio,omitempty"`
	// The details of the zone.
	ZoneInfoShrink *string `json:"ZoneInfo,omitempty" xml:"ZoneInfo,omitempty"`
}

func (s AddGatewayShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayShrinkRequest) SetAcceptLanguage(v string) *AddGatewayShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetChargeType(v string) *AddGatewayShrinkRequest {
	s.ChargeType = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetEnableHardwareAcceleration(v bool) *AddGatewayShrinkRequest {
	s.EnableHardwareAcceleration = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetEnableSls(v bool) *AddGatewayShrinkRequest {
	s.EnableSls = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetEnableXtrace(v bool) *AddGatewayShrinkRequest {
	s.EnableXtrace = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetEnterpriseSecurityGroup(v bool) *AddGatewayShrinkRequest {
	s.EnterpriseSecurityGroup = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetInternetSlbSpec(v string) *AddGatewayShrinkRequest {
	s.InternetSlbSpec = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetMserVersion(v string) *AddGatewayShrinkRequest {
	s.MserVersion = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetName(v string) *AddGatewayShrinkRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetNlbNetworkType(v string) *AddGatewayShrinkRequest {
	s.NlbNetworkType = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetRegion(v string) *AddGatewayShrinkRequest {
	s.Region = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetReplica(v int32) *AddGatewayShrinkRequest {
	s.Replica = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetRequestPars(v string) *AddGatewayShrinkRequest {
	s.RequestPars = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetResourceGroupId(v string) *AddGatewayShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetSlbSpec(v string) *AddGatewayShrinkRequest {
	s.SlbSpec = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetSpec(v string) *AddGatewayShrinkRequest {
	s.Spec = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetTag(v []*AddGatewayShrinkRequestTag) *AddGatewayShrinkRequest {
	s.Tag = v
	return s
}

func (s *AddGatewayShrinkRequest) SetVSwitchId(v string) *AddGatewayShrinkRequest {
	s.VSwitchId = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetVSwitchId2(v string) *AddGatewayShrinkRequest {
	s.VSwitchId2 = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetVpc(v string) *AddGatewayShrinkRequest {
	s.Vpc = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetXtraceRatio(v string) *AddGatewayShrinkRequest {
	s.XtraceRatio = &v
	return s
}

func (s *AddGatewayShrinkRequest) SetZoneInfoShrink(v string) *AddGatewayShrinkRequest {
	s.ZoneInfoShrink = &v
	return s
}

type AddGatewayShrinkRequestTag struct {
	// The value of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the resource group.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGatewayShrinkRequestTag) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayShrinkRequestTag) GoString() string {
	return s.String()
}

func (s *AddGatewayShrinkRequestTag) SetKey(v string) *AddGatewayShrinkRequestTag {
	s.Key = &v
	return s
}

func (s *AddGatewayShrinkRequestTag) SetValue(v string) *AddGatewayShrinkRequestTag {
	s.Value = &v
	return s
}

type AddGatewayResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The unique ID of the gateway.
	Data *AddGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The request is successfully processed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The HTTP status code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned data.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayResponseBody) SetCode(v int32) *AddGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayResponseBody) SetData(v *AddGatewayResponseBodyData) *AddGatewayResponseBody {
	s.Data = v
	return s
}

func (s *AddGatewayResponseBody) SetHttpStatusCode(v int32) *AddGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayResponseBody) SetMessage(v string) *AddGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayResponseBody) SetRequestId(v string) *AddGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayResponseBody) SetSuccess(v bool) *AddGatewayResponseBody {
	s.Success = &v
	return s
}

type AddGatewayResponseBodyData struct {
	// code
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s AddGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddGatewayResponseBodyData) SetGatewayUniqueId(v string) *AddGatewayResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

type AddGatewayResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayResponse) SetHeaders(v map[string]*string) *AddGatewayResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayResponse) SetStatusCode(v int32) *AddGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayResponse) SetBody(v *AddGatewayResponseBody) *AddGatewayResponse {
	s.Body = v
	return s
}

type AddGatewayAuthConsumerRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The description of the consumer.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The encryption type. Valid values:
	//
	// *   RSA
	// *   OCT
	EncodeType *string `json:"EncodeType,omitempty" xml:"EncodeType,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The JWT public key. The JSON format is supported.
	Jwks *string `json:"Jwks,omitempty" xml:"Jwks,omitempty"`
	// The name of the key used for JWT-based identity authentication.
	KeyName *string `json:"KeyName,omitempty" xml:"KeyName,omitempty"`
	// The value of the key used for JWT-based identity authentication.
	KeyValue *string `json:"KeyValue,omitempty" xml:"KeyValue,omitempty"`
	// The name of the consumer.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The names of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenName *string `json:"TokenName,omitempty" xml:"TokenName,omitempty"`
	// Specifies whether to enable pass-through.
	TokenPass *bool `json:"TokenPass,omitempty" xml:"TokenPass,omitempty"`
	// The positions of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenPosition *string `json:"TokenPosition,omitempty" xml:"TokenPosition,omitempty"`
	// The prefixes of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenPrefix *string `json:"TokenPrefix,omitempty" xml:"TokenPrefix,omitempty"`
	// The authentication type. Valid values:
	//
	// *   JWT
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddGatewayAuthConsumerRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayAuthConsumerRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayAuthConsumerRequest) SetAcceptLanguage(v string) *AddGatewayAuthConsumerRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetDescription(v string) *AddGatewayAuthConsumerRequest {
	s.Description = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetEncodeType(v string) *AddGatewayAuthConsumerRequest {
	s.EncodeType = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetGatewayUniqueId(v string) *AddGatewayAuthConsumerRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetJwks(v string) *AddGatewayAuthConsumerRequest {
	s.Jwks = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetKeyName(v string) *AddGatewayAuthConsumerRequest {
	s.KeyName = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetKeyValue(v string) *AddGatewayAuthConsumerRequest {
	s.KeyValue = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetName(v string) *AddGatewayAuthConsumerRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetTokenName(v string) *AddGatewayAuthConsumerRequest {
	s.TokenName = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetTokenPass(v bool) *AddGatewayAuthConsumerRequest {
	s.TokenPass = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetTokenPosition(v string) *AddGatewayAuthConsumerRequest {
	s.TokenPosition = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetTokenPrefix(v string) *AddGatewayAuthConsumerRequest {
	s.TokenPrefix = &v
	return s
}

func (s *AddGatewayAuthConsumerRequest) SetType(v string) *AddGatewayAuthConsumerRequest {
	s.Type = &v
	return s
}

type AddGatewayAuthConsumerResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the consumer.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the `%s` variable in the `ErrMessage` parameter.
	//
	// >  If the return value of the `ErrMessage` parameter is `The Value of Input Parameter %s is not valid` and the return value of the `DynamicMessage` parameter is `DtsJobId`, the specified `DtsJobId` parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayAuthConsumerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayAuthConsumerResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayAuthConsumerResponseBody) SetCode(v int32) *AddGatewayAuthConsumerResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetData(v int64) *AddGatewayAuthConsumerResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetDynamicCode(v string) *AddGatewayAuthConsumerResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetDynamicMessage(v string) *AddGatewayAuthConsumerResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetErrorCode(v string) *AddGatewayAuthConsumerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetHttpStatusCode(v int32) *AddGatewayAuthConsumerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetMessage(v string) *AddGatewayAuthConsumerResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetRequestId(v string) *AddGatewayAuthConsumerResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayAuthConsumerResponseBody) SetSuccess(v bool) *AddGatewayAuthConsumerResponseBody {
	s.Success = &v
	return s
}

type AddGatewayAuthConsumerResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayAuthConsumerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayAuthConsumerResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayAuthConsumerResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayAuthConsumerResponse) SetHeaders(v map[string]*string) *AddGatewayAuthConsumerResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayAuthConsumerResponse) SetStatusCode(v int32) *AddGatewayAuthConsumerResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayAuthConsumerResponse) SetBody(v *AddGatewayAuthConsumerResponseBody) *AddGatewayAuthConsumerResponse {
	s.Body = v
	return s
}

type AddGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to enable `HTTP/2`.
	//
	// *   `open`: enables `HTTP/2`
	// *   `close`: disables `HTTP/2`
	// *   `globalConfig`: uses global configurations
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// Specifies whether to enable HTTPS.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The domain name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   `HTTP`
	// *   `HTTPS`
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
}

func (s AddGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayDomainRequest) SetAcceptLanguage(v string) *AddGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayDomainRequest) SetCertIdentifier(v string) *AddGatewayDomainRequest {
	s.CertIdentifier = &v
	return s
}

func (s *AddGatewayDomainRequest) SetGatewayUniqueId(v string) *AddGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayDomainRequest) SetHttp2(v string) *AddGatewayDomainRequest {
	s.Http2 = &v
	return s
}

func (s *AddGatewayDomainRequest) SetMustHttps(v bool) *AddGatewayDomainRequest {
	s.MustHttps = &v
	return s
}

func (s *AddGatewayDomainRequest) SetName(v string) *AddGatewayDomainRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayDomainRequest) SetProtocol(v string) *AddGatewayDomainRequest {
	s.Protocol = &v
	return s
}

func (s *AddGatewayDomainRequest) SetTlsMax(v string) *AddGatewayDomainRequest {
	s.TlsMax = &v
	return s
}

func (s *AddGatewayDomainRequest) SetTlsMin(v string) *AddGatewayDomainRequest {
	s.TlsMin = &v
	return s
}

type AddGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayDomainResponseBody) SetCode(v int32) *AddGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetData(v int64) *AddGatewayDomainResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetHttpStatusCode(v int32) *AddGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetMessage(v string) *AddGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetRequestId(v string) *AddGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetSuccess(v bool) *AddGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type AddGatewayDomainResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayDomainResponse) SetHeaders(v map[string]*string) *AddGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayDomainResponse) SetStatusCode(v int32) *AddGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayDomainResponse) SetBody(v *AddGatewayDomainResponseBody) *AddGatewayDomainResponse {
	s.Body = v
	return s
}

type AddGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the destination service. Valid values:
	//
	// *   Single
	// *   Multiple
	// *   VersionOriented
	// *   Mock
	// *   Redirect
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The mock response configuration.
	DirectResponseJSON *AddGatewayRouteRequestDirectResponseJSON `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain IDs.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to activate Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServices []*AddGatewayRouteRequestFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The routing policy in a JSON string.
	Policies *string `json:"Policies,omitempty" xml:"Policies,omitempty"`
	// The matching rule.
	Predicates *AddGatewayRouteRequestPredicates `json:"Predicates,omitempty" xml:"Predicates,omitempty" type:"Struct"`
	// The configuration of the redirection.
	RedirectJSON *AddGatewayRouteRequestRedirectJSON `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty" type:"Struct"`
	// The sequence number of the route. (A small value indicates a high priority.)
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The route type. Valid values:
	//
	// Op: Manage routes.
	RouteType *string `json:"RouteType,omitempty" xml:"RouteType,omitempty"`
	// The list of services.
	Services []*AddGatewayRouteRequestServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequest) SetAcceptLanguage(v string) *AddGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayRouteRequest) SetDestinationType(v string) *AddGatewayRouteRequest {
	s.DestinationType = &v
	return s
}

func (s *AddGatewayRouteRequest) SetDirectResponseJSON(v *AddGatewayRouteRequestDirectResponseJSON) *AddGatewayRouteRequest {
	s.DirectResponseJSON = v
	return s
}

func (s *AddGatewayRouteRequest) SetDomainId(v int64) *AddGatewayRouteRequest {
	s.DomainId = &v
	return s
}

func (s *AddGatewayRouteRequest) SetDomainIdListJSON(v string) *AddGatewayRouteRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *AddGatewayRouteRequest) SetEnableWaf(v bool) *AddGatewayRouteRequest {
	s.EnableWaf = &v
	return s
}

func (s *AddGatewayRouteRequest) SetFallback(v bool) *AddGatewayRouteRequest {
	s.Fallback = &v
	return s
}

func (s *AddGatewayRouteRequest) SetFallbackServices(v []*AddGatewayRouteRequestFallbackServices) *AddGatewayRouteRequest {
	s.FallbackServices = v
	return s
}

func (s *AddGatewayRouteRequest) SetGatewayId(v int64) *AddGatewayRouteRequest {
	s.GatewayId = &v
	return s
}

func (s *AddGatewayRouteRequest) SetGatewayUniqueId(v string) *AddGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayRouteRequest) SetName(v string) *AddGatewayRouteRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteRequest) SetPolicies(v string) *AddGatewayRouteRequest {
	s.Policies = &v
	return s
}

func (s *AddGatewayRouteRequest) SetPredicates(v *AddGatewayRouteRequestPredicates) *AddGatewayRouteRequest {
	s.Predicates = v
	return s
}

func (s *AddGatewayRouteRequest) SetRedirectJSON(v *AddGatewayRouteRequestRedirectJSON) *AddGatewayRouteRequest {
	s.RedirectJSON = v
	return s
}

func (s *AddGatewayRouteRequest) SetRouteOrder(v int32) *AddGatewayRouteRequest {
	s.RouteOrder = &v
	return s
}

func (s *AddGatewayRouteRequest) SetRouteType(v string) *AddGatewayRouteRequest {
	s.RouteType = &v
	return s
}

func (s *AddGatewayRouteRequest) SetServices(v []*AddGatewayRouteRequestServices) *AddGatewayRouteRequest {
	s.Services = v
	return s
}

type AddGatewayRouteRequestDirectResponseJSON struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The mock return code.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s AddGatewayRouteRequestDirectResponseJSON) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestDirectResponseJSON) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestDirectResponseJSON) SetBody(v string) *AddGatewayRouteRequestDirectResponseJSON {
	s.Body = &v
	return s
}

func (s *AddGatewayRouteRequestDirectResponseJSON) SetCode(v int64) *AddGatewayRouteRequestDirectResponseJSON {
	s.Code = &v
	return s
}

type AddGatewayRouteRequestFallbackServices struct {
	// The type of the protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the service belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s AddGatewayRouteRequestFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestFallbackServices) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestFallbackServices) SetAgreementType(v string) *AddGatewayRouteRequestFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetGroupName(v string) *AddGatewayRouteRequestFallbackServices {
	s.GroupName = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetName(v string) *AddGatewayRouteRequestFallbackServices {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetNamespace(v string) *AddGatewayRouteRequestFallbackServices {
	s.Namespace = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetPercent(v int32) *AddGatewayRouteRequestFallbackServices {
	s.Percent = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetServiceId(v int64) *AddGatewayRouteRequestFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetServicePort(v int32) *AddGatewayRouteRequestFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetSourceType(v string) *AddGatewayRouteRequestFallbackServices {
	s.SourceType = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetVersion(v string) *AddGatewayRouteRequestFallbackServices {
	s.Version = &v
	return s
}

type AddGatewayRouteRequestPredicates struct {
	// The information about header matching.
	HeaderPredicates []*AddGatewayRouteRequestPredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about route matching.
	PathPredicates *AddGatewayRouteRequestPredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The information about URL parameter matching.
	QueryPredicates []*AddGatewayRouteRequestPredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequestPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicates) SetHeaderPredicates(v []*AddGatewayRouteRequestPredicatesHeaderPredicates) *AddGatewayRouteRequestPredicates {
	s.HeaderPredicates = v
	return s
}

func (s *AddGatewayRouteRequestPredicates) SetMethodPredicates(v []*string) *AddGatewayRouteRequestPredicates {
	s.MethodPredicates = v
	return s
}

func (s *AddGatewayRouteRequestPredicates) SetPathPredicates(v *AddGatewayRouteRequestPredicatesPathPredicates) *AddGatewayRouteRequestPredicates {
	s.PathPredicates = v
	return s
}

func (s *AddGatewayRouteRequestPredicates) SetQueryPredicates(v []*AddGatewayRouteRequestPredicatesQueryPredicates) *AddGatewayRouteRequestPredicates {
	s.QueryPredicates = v
	return s
}

type AddGatewayRouteRequestPredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGatewayRouteRequestPredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicatesHeaderPredicates) SetKey(v string) *AddGatewayRouteRequestPredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesHeaderPredicates) SetType(v string) *AddGatewayRouteRequestPredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesHeaderPredicates) SetValue(v string) *AddGatewayRouteRequestPredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type AddGatewayRouteRequestPredicatesPathPredicates struct {
	// Specifies whether to ignore case sensitivity.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The route matching type. Valid values:
	//
	// *   PRE: prefix matching
	// *   EQUAL: exact matching
	// *   ERGULAR: regular expression matching
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddGatewayRouteRequestPredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicatesPathPredicates) SetIgnoreCase(v bool) *AddGatewayRouteRequestPredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesPathPredicates) SetPath(v string) *AddGatewayRouteRequestPredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesPathPredicates) SetType(v string) *AddGatewayRouteRequestPredicatesPathPredicates {
	s.Type = &v
	return s
}

type AddGatewayRouteRequestPredicatesQueryPredicates struct {
	// The name of the parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGatewayRouteRequestPredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicatesQueryPredicates) SetKey(v string) *AddGatewayRouteRequestPredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesQueryPredicates) SetType(v string) *AddGatewayRouteRequestPredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesQueryPredicates) SetValue(v string) *AddGatewayRouteRequestPredicatesQueryPredicates {
	s.Value = &v
	return s
}

type AddGatewayRouteRequestRedirectJSON struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname to be redirected to.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path to be redirected to.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AddGatewayRouteRequestRedirectJSON) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestRedirectJSON) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestRedirectJSON) SetCode(v int32) *AddGatewayRouteRequestRedirectJSON {
	s.Code = &v
	return s
}

func (s *AddGatewayRouteRequestRedirectJSON) SetHost(v string) *AddGatewayRouteRequestRedirectJSON {
	s.Host = &v
	return s
}

func (s *AddGatewayRouteRequestRedirectJSON) SetPath(v string) *AddGatewayRouteRequestRedirectJSON {
	s.Path = &v
	return s
}

type AddGatewayRouteRequestServices struct {
	// The type of the protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The transcoder of the Dubbo protocol.
	HttpDubboTranscoder *AddGatewayRouteRequestServicesHttpDubboTranscoder `json:"HttpDubboTranscoder,omitempty" xml:"HttpDubboTranscoder,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the service belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s AddGatewayRouteRequestServices) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServices) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServices) SetAgreementType(v string) *AddGatewayRouteRequestServices {
	s.AgreementType = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetGroupName(v string) *AddGatewayRouteRequestServices {
	s.GroupName = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetHttpDubboTranscoder(v *AddGatewayRouteRequestServicesHttpDubboTranscoder) *AddGatewayRouteRequestServices {
	s.HttpDubboTranscoder = v
	return s
}

func (s *AddGatewayRouteRequestServices) SetName(v string) *AddGatewayRouteRequestServices {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetNamespace(v string) *AddGatewayRouteRequestServices {
	s.Namespace = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetPercent(v int32) *AddGatewayRouteRequestServices {
	s.Percent = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetServiceId(v int64) *AddGatewayRouteRequestServices {
	s.ServiceId = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetServicePort(v int32) *AddGatewayRouteRequestServices {
	s.ServicePort = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetSourceType(v string) *AddGatewayRouteRequestServices {
	s.SourceType = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetVersion(v string) *AddGatewayRouteRequestServices {
	s.Version = &v
	return s
}

type AddGatewayRouteRequestServicesHttpDubboTranscoder struct {
	// The name of the service group.
	DubboServiceGroup *string `json:"DubboServiceGroup,omitempty" xml:"DubboServiceGroup,omitempty"`
	// The name of the Dubbo service.
	DubboServiceName *string `json:"DubboServiceName,omitempty" xml:"DubboServiceName,omitempty"`
	// The version of the Dubbo service.
	DubboServiceVersion *string `json:"DubboServiceVersion,omitempty" xml:"DubboServiceVersion,omitempty"`
	// The forwarding rules of the Dubbo service.
	MothedMapList []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList `json:"MothedMapList,omitempty" xml:"MothedMapList,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoder) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoder) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceGroup(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceGroup = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceName(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceName = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceVersion(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceVersion = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetMothedMapList(v []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.MothedMapList = v
	return s
}

type AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList struct {
	// The method name of the Dubbo service.
	DubboMothedName *string `json:"DubboMothedName,omitempty" xml:"DubboMothedName,omitempty"`
	// The HTTP method.
	//
	// > Valid values:
	//
	// *   ALL_GET
	//
	// *   ALL_POST
	//
	// *   ALL_PUT
	//
	// *   ALL_DELETE
	//
	// *   ALL_PATCH
	HttpMothed *string `json:"HttpMothed,omitempty" xml:"HttpMothed,omitempty"`
	// The path used for method matching.
	Mothedpath *string `json:"Mothedpath,omitempty" xml:"Mothedpath,omitempty"`
	// The information about parameter mappings.
	ParamMapsList []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList `json:"ParamMapsList,omitempty" xml:"ParamMapsList,omitempty" type:"Repeated"`
	// The pass-through type of the header.
	//
	// > Valid values:
	//
	// *   PASS_ALL: All headers are passed through.
	//
	// *   PASS_NOT: All headers are not passed through.
	//
	// *   PASS_ASSIGN: Specified headers are passed through.
	PassThroughAllHeaders *string `json:"PassThroughAllHeaders,omitempty" xml:"PassThroughAllHeaders,omitempty"`
	// The list of headers to be passed through.
	PassThroughList []*string `json:"PassThroughList,omitempty" xml:"PassThroughList,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetDubboMothedName(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.DubboMothedName = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetHttpMothed(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.HttpMothed = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetMothedpath(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.Mothedpath = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetParamMapsList(v []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.ParamMapsList = v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughAllHeaders(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughAllHeaders = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughList(v []*string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughList = v
	return s
}

type AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList struct {
	// The key extracted from the input parameter.
	ExtractKey *string `json:"ExtractKey,omitempty" xml:"ExtractKey,omitempty"`
	// The position of the input parameter.
	//
	// > Valid values:
	//
	// *   `ALL_QUERY_PARAMETER`: request parameter
	//
	// *   `ALL_HEADER`: request header
	// *   `ALL_PATH`: request path
	// *   `ALL_BODY`: request body
	ExtractKeySpec *string `json:"ExtractKeySpec,omitempty" xml:"ExtractKeySpec,omitempty"`
	// The type of the backend service parameter.
	MappingType *string `json:"MappingType,omitempty" xml:"MappingType,omitempty"`
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKey(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKey = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKeySpec(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKeySpec = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetMappingType(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.MappingType = &v
	return s
}

type AddGatewayRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the destination service. Valid values:
	//
	// *   Single
	// *   Multiple
	// *   VersionOriented
	// *   Mock
	// *   Redirect
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The mock response configuration.
	DirectResponseJSONShrink *string `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain IDs.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to activate Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServicesShrink *string `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The routing policy in a JSON string.
	Policies *string `json:"Policies,omitempty" xml:"Policies,omitempty"`
	// The matching rule.
	PredicatesShrink *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The configuration of the redirection.
	RedirectJSONShrink *string `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty"`
	// The sequence number of the route. (A small value indicates a high priority.)
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The route type. Valid values:
	//
	// Op: Manage routes.
	RouteType *string `json:"RouteType,omitempty" xml:"RouteType,omitempty"`
	// The list of services.
	ServicesShrink *string `json:"Services,omitempty" xml:"Services,omitempty"`
}

func (s AddGatewayRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteShrinkRequest) SetAcceptLanguage(v string) *AddGatewayRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDestinationType(v string) *AddGatewayRouteShrinkRequest {
	s.DestinationType = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDirectResponseJSONShrink(v string) *AddGatewayRouteShrinkRequest {
	s.DirectResponseJSONShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDomainId(v int64) *AddGatewayRouteShrinkRequest {
	s.DomainId = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDomainIdListJSON(v string) *AddGatewayRouteShrinkRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetEnableWaf(v bool) *AddGatewayRouteShrinkRequest {
	s.EnableWaf = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetFallback(v bool) *AddGatewayRouteShrinkRequest {
	s.Fallback = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetFallbackServicesShrink(v string) *AddGatewayRouteShrinkRequest {
	s.FallbackServicesShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetGatewayId(v int64) *AddGatewayRouteShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetGatewayUniqueId(v string) *AddGatewayRouteShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetName(v string) *AddGatewayRouteShrinkRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetPolicies(v string) *AddGatewayRouteShrinkRequest {
	s.Policies = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetPredicatesShrink(v string) *AddGatewayRouteShrinkRequest {
	s.PredicatesShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetRedirectJSONShrink(v string) *AddGatewayRouteShrinkRequest {
	s.RedirectJSONShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetRouteOrder(v int32) *AddGatewayRouteShrinkRequest {
	s.RouteOrder = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetRouteType(v string) *AddGatewayRouteShrinkRequest {
	s.RouteType = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetServicesShrink(v string) *AddGatewayRouteShrinkRequest {
	s.ServicesShrink = &v
	return s
}

type AddGatewayRouteResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the created route.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code that is returned.
	//
	// *   InvalidParameter: The parameter is invalid. For example, the parameter is incomplete or the parameter format is invalid.
	// *   IllegalRequest: The request is invalid. Unauthorized access to data initiated by parameters is identified.
	// *   NoPermission: You are not authorized to perform this operation.
	// *   NotFound: The resource does not exist and error 404 is returned.
	// *   InternalError: An internal error occurred.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteResponseBody) SetCode(v int32) *AddGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetData(v int64) *AddGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetErrorCode(v string) *AddGatewayRouteResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetHttpStatusCode(v int32) *AddGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetMessage(v string) *AddGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetRequestId(v string) *AddGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetSuccess(v bool) *AddGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type AddGatewayRouteResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteResponse) SetHeaders(v map[string]*string) *AddGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayRouteResponse) SetStatusCode(v int32) *AddGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayRouteResponse) SetBody(v *AddGatewayRouteResponseBody) *AddGatewayRouteResponse {
	s.Body = v
	return s
}

type AddGatewayServiceVersionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty"`
}

func (s AddGatewayServiceVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayServiceVersionRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayServiceVersionRequest) SetAcceptLanguage(v string) *AddGatewayServiceVersionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayServiceVersionRequest) SetGatewayUniqueId(v string) *AddGatewayServiceVersionRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayServiceVersionRequest) SetServiceId(v int64) *AddGatewayServiceVersionRequest {
	s.ServiceId = &v
	return s
}

func (s *AddGatewayServiceVersionRequest) SetServiceVersion(v string) *AddGatewayServiceVersionRequest {
	s.ServiceVersion = &v
	return s
}

type AddGatewayServiceVersionResponseBody struct {
	// The status code returned. The value 200 indicates that the request is successfully processed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the gateway service.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayServiceVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayServiceVersionResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayServiceVersionResponseBody) SetCode(v int32) *AddGatewayServiceVersionResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetData(v int64) *AddGatewayServiceVersionResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetHttpStatusCode(v int32) *AddGatewayServiceVersionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetMessage(v string) *AddGatewayServiceVersionResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetRequestId(v string) *AddGatewayServiceVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetSuccess(v bool) *AddGatewayServiceVersionResponseBody {
	s.Success = &v
	return s
}

type AddGatewayServiceVersionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayServiceVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayServiceVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayServiceVersionResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayServiceVersionResponse) SetHeaders(v map[string]*string) *AddGatewayServiceVersionResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayServiceVersionResponse) SetStatusCode(v int32) *AddGatewayServiceVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayServiceVersionResponse) SetBody(v *AddGatewayServiceVersionResponseBody) *AddGatewayServiceVersionResponse {
	s.Body = v
	return s
}

type AddGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The HTTP port number (virtual service group).
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The HTTPS port number (virtual service group).
	HttpsPort *int32 `json:"HttpsPort,omitempty" xml:"HttpsPort,omitempty"`
	// The ID of the HTTPS virtual service group.
	HttpsVServerGroupId *string `json:"HttpsVServerGroupId,omitempty" xml:"HttpsVServerGroupId,omitempty"`
	// The service weight.
	ServiceWeight *int32 `json:"ServiceWeight,omitempty" xml:"ServiceWeight,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   PUB_NET: Internet
	// *   PRIVATE_NET: VPC
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the HTTP virtual service group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The SLB monitoring information.
	VServiceList []*AddGatewaySlbRequestVServiceList `json:"VServiceList,omitempty" xml:"VServiceList,omitempty" type:"Repeated"`
}

func (s AddGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbRequest) SetAcceptLanguage(v string) *AddGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewaySlbRequest) SetGatewayUniqueId(v string) *AddGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewaySlbRequest) SetHttpPort(v int32) *AddGatewaySlbRequest {
	s.HttpPort = &v
	return s
}

func (s *AddGatewaySlbRequest) SetHttpsPort(v int32) *AddGatewaySlbRequest {
	s.HttpsPort = &v
	return s
}

func (s *AddGatewaySlbRequest) SetHttpsVServerGroupId(v string) *AddGatewaySlbRequest {
	s.HttpsVServerGroupId = &v
	return s
}

func (s *AddGatewaySlbRequest) SetServiceWeight(v int32) *AddGatewaySlbRequest {
	s.ServiceWeight = &v
	return s
}

func (s *AddGatewaySlbRequest) SetSlbId(v string) *AddGatewaySlbRequest {
	s.SlbId = &v
	return s
}

func (s *AddGatewaySlbRequest) SetType(v string) *AddGatewaySlbRequest {
	s.Type = &v
	return s
}

func (s *AddGatewaySlbRequest) SetVServerGroupId(v string) *AddGatewaySlbRequest {
	s.VServerGroupId = &v
	return s
}

func (s *AddGatewaySlbRequest) SetVServiceList(v []*AddGatewaySlbRequestVServiceList) *AddGatewaySlbRequest {
	s.VServiceList = v
	return s
}

type AddGatewaySlbRequestVServiceList struct {
	// The port number.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol type. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The ID of the virtual server group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The name of the virtual server group.
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s AddGatewaySlbRequestVServiceList) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbRequestVServiceList) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbRequestVServiceList) SetPort(v int32) *AddGatewaySlbRequestVServiceList {
	s.Port = &v
	return s
}

func (s *AddGatewaySlbRequestVServiceList) SetProtocol(v string) *AddGatewaySlbRequestVServiceList {
	s.Protocol = &v
	return s
}

func (s *AddGatewaySlbRequestVServiceList) SetVServerGroupId(v string) *AddGatewaySlbRequestVServiceList {
	s.VServerGroupId = &v
	return s
}

func (s *AddGatewaySlbRequestVServiceList) SetVServerGroupName(v string) *AddGatewaySlbRequestVServiceList {
	s.VServerGroupName = &v
	return s
}

type AddGatewaySlbShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The HTTP port number (virtual service group).
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The HTTPS port number (virtual service group).
	HttpsPort *int32 `json:"HttpsPort,omitempty" xml:"HttpsPort,omitempty"`
	// The ID of the HTTPS virtual service group.
	HttpsVServerGroupId *string `json:"HttpsVServerGroupId,omitempty" xml:"HttpsVServerGroupId,omitempty"`
	// The service weight.
	ServiceWeight *int32 `json:"ServiceWeight,omitempty" xml:"ServiceWeight,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   PUB_NET: Internet
	// *   PRIVATE_NET: VPC
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the HTTP virtual service group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The SLB monitoring information.
	VServiceListShrink *string `json:"VServiceList,omitempty" xml:"VServiceList,omitempty"`
}

func (s AddGatewaySlbShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbShrinkRequest) SetAcceptLanguage(v string) *AddGatewaySlbShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetGatewayUniqueId(v string) *AddGatewaySlbShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetHttpPort(v int32) *AddGatewaySlbShrinkRequest {
	s.HttpPort = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetHttpsPort(v int32) *AddGatewaySlbShrinkRequest {
	s.HttpsPort = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetHttpsVServerGroupId(v string) *AddGatewaySlbShrinkRequest {
	s.HttpsVServerGroupId = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetServiceWeight(v int32) *AddGatewaySlbShrinkRequest {
	s.ServiceWeight = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetSlbId(v string) *AddGatewaySlbShrinkRequest {
	s.SlbId = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetType(v string) *AddGatewaySlbShrinkRequest {
	s.Type = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetVServerGroupId(v string) *AddGatewaySlbShrinkRequest {
	s.VServerGroupId = &v
	return s
}

func (s *AddGatewaySlbShrinkRequest) SetVServiceListShrink(v string) *AddGatewaySlbShrinkRequest {
	s.VServiceListShrink = &v
	return s
}

type AddGatewaySlbResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbResponseBody) SetCode(v int32) *AddGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetData(v string) *AddGatewaySlbResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetHttpStatusCode(v int32) *AddGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetMessage(v string) *AddGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetRequestId(v string) *AddGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetSuccess(v bool) *AddGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type AddGatewaySlbResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbResponse) SetHeaders(v map[string]*string) *AddGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *AddGatewaySlbResponse) SetStatusCode(v int32) *AddGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewaySlbResponse) SetBody(v *AddGatewaySlbResponseBody) *AddGatewaySlbResponse {
	s.Body = v
	return s
}

type AddMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values:
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The endpoint of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if you want to migrate applications from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
}

func (s AddMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskRequest) SetAcceptLanguage(v string) *AddMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddMigrationTaskRequest) SetClusterType(v string) *AddMigrationTaskRequest {
	s.ClusterType = &v
	return s
}

func (s *AddMigrationTaskRequest) SetOriginInstanceAddress(v string) *AddMigrationTaskRequest {
	s.OriginInstanceAddress = &v
	return s
}

func (s *AddMigrationTaskRequest) SetOriginInstanceName(v string) *AddMigrationTaskRequest {
	s.OriginInstanceName = &v
	return s
}

func (s *AddMigrationTaskRequest) SetOriginInstanceNamespace(v string) *AddMigrationTaskRequest {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *AddMigrationTaskRequest) SetProjectDesc(v string) *AddMigrationTaskRequest {
	s.ProjectDesc = &v
	return s
}

func (s *AddMigrationTaskRequest) SetRequestPars(v string) *AddMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

func (s *AddMigrationTaskRequest) SetTargetClusterName(v string) *AddMigrationTaskRequest {
	s.TargetClusterName = &v
	return s
}

func (s *AddMigrationTaskRequest) SetTargetClusterUrl(v string) *AddMigrationTaskRequest {
	s.TargetClusterUrl = &v
	return s
}

func (s *AddMigrationTaskRequest) SetTargetInstanceId(v string) *AddMigrationTaskRequest {
	s.TargetInstanceId = &v
	return s
}

type AddMigrationTaskResponseBody struct {
	// The data structure.
	Data *AddMigrationTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskResponseBody) SetData(v *AddMigrationTaskResponseBodyData) *AddMigrationTaskResponseBody {
	s.Data = v
	return s
}

func (s *AddMigrationTaskResponseBody) SetErrorCode(v string) *AddMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddMigrationTaskResponseBody) SetMessage(v string) *AddMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *AddMigrationTaskResponseBody) SetRequestId(v string) *AddMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddMigrationTaskResponseBody) SetSuccess(v bool) *AddMigrationTaskResponseBody {
	s.Success = &v
	return s
}

type AddMigrationTaskResponseBodyData struct {
	// The type of the instance. Valid values:
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The endpoint of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s AddMigrationTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskResponseBodyData) SetClusterType(v string) *AddMigrationTaskResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetId(v string) *AddMigrationTaskResponseBodyData {
	s.Id = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetOriginInstanceAddress(v string) *AddMigrationTaskResponseBodyData {
	s.OriginInstanceAddress = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetOriginInstanceName(v string) *AddMigrationTaskResponseBodyData {
	s.OriginInstanceName = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetOriginInstanceNamespace(v string) *AddMigrationTaskResponseBodyData {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetProjectDesc(v string) *AddMigrationTaskResponseBodyData {
	s.ProjectDesc = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetTargetClusterName(v string) *AddMigrationTaskResponseBodyData {
	s.TargetClusterName = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetTargetClusterUrl(v string) *AddMigrationTaskResponseBodyData {
	s.TargetClusterUrl = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetTargetInstanceId(v string) *AddMigrationTaskResponseBodyData {
	s.TargetInstanceId = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetUserId(v string) *AddMigrationTaskResponseBodyData {
	s.UserId = &v
	return s
}

type AddMigrationTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskResponse) SetHeaders(v map[string]*string) *AddMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *AddMigrationTaskResponse) SetStatusCode(v int32) *AddMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *AddMigrationTaskResponse) SetBody(v *AddMigrationTaskResponseBody) *AddMigrationTaskResponse {
	s.Body = v
	return s
}

type AddMockRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the custom application.
	ConsumerAppIds *string `json:"ConsumerAppIds,omitempty" xml:"ConsumerAppIds,omitempty"`
	// The items in the recycle bin.
	DubboMockItems *string `json:"DubboMockItems,omitempty" xml:"DubboMockItems,omitempty"`
	// Specifies whether to enable the alert rule. Valid values:
	//
	// *   `true`: enables the alert rule.
	// *   `false`: disables the alert rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The description.
	ExtraJson *string `json:"ExtraJson,omitempty" xml:"ExtraJson,omitempty"`
	// The response time (RT) threshold of slow calls. Valid values:
	//
	// *   \- 15: 15 ms
	// *   \- 30: 30 ms
	// *   \- 60: 60 ms
	// *   \- 120: 120 ms
	MockType *int64 `json:"MockType,omitempty" xml:"MockType,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the service provider application.
	ProviderAppId *string `json:"ProviderAppId,omitempty" xml:"ProviderAppId,omitempty"`
	// The name of the service provider application.
	ProviderAppName *string `json:"ProviderAppName,omitempty" xml:"ProviderAppName,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The input parameters. The JSON format is supported.
	ScMockItems *string `json:"ScMockItems,omitempty" xml:"ScMockItems,omitempty"`
	// The rule source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s AddMockRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleRequest) GoString() string {
	return s.String()
}

func (s *AddMockRuleRequest) SetAcceptLanguage(v string) *AddMockRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddMockRuleRequest) SetConsumerAppIds(v string) *AddMockRuleRequest {
	s.ConsumerAppIds = &v
	return s
}

func (s *AddMockRuleRequest) SetDubboMockItems(v string) *AddMockRuleRequest {
	s.DubboMockItems = &v
	return s
}

func (s *AddMockRuleRequest) SetEnable(v bool) *AddMockRuleRequest {
	s.Enable = &v
	return s
}

func (s *AddMockRuleRequest) SetExtraJson(v string) *AddMockRuleRequest {
	s.ExtraJson = &v
	return s
}

func (s *AddMockRuleRequest) SetMockType(v int64) *AddMockRuleRequest {
	s.MockType = &v
	return s
}

func (s *AddMockRuleRequest) SetName(v string) *AddMockRuleRequest {
	s.Name = &v
	return s
}

func (s *AddMockRuleRequest) SetProviderAppId(v string) *AddMockRuleRequest {
	s.ProviderAppId = &v
	return s
}

func (s *AddMockRuleRequest) SetProviderAppName(v string) *AddMockRuleRequest {
	s.ProviderAppName = &v
	return s
}

func (s *AddMockRuleRequest) SetRegion(v string) *AddMockRuleRequest {
	s.Region = &v
	return s
}

func (s *AddMockRuleRequest) SetScMockItems(v string) *AddMockRuleRequest {
	s.ScMockItems = &v
	return s
}

func (s *AddMockRuleRequest) SetSource(v string) *AddMockRuleRequest {
	s.Source = &v
	return s
}

type AddMockRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *AddMockRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddMockRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleResponseBody) GoString() string {
	return s.String()
}

func (s *AddMockRuleResponseBody) SetCode(v int32) *AddMockRuleResponseBody {
	s.Code = &v
	return s
}

func (s *AddMockRuleResponseBody) SetData(v *AddMockRuleResponseBodyData) *AddMockRuleResponseBody {
	s.Data = v
	return s
}

func (s *AddMockRuleResponseBody) SetHttpStatusCode(v int32) *AddMockRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddMockRuleResponseBody) SetMessage(v string) *AddMockRuleResponseBody {
	s.Message = &v
	return s
}

func (s *AddMockRuleResponseBody) SetRequestId(v string) *AddMockRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddMockRuleResponseBody) SetSuccess(v bool) *AddMockRuleResponseBody {
	s.Success = &v
	return s
}

type AddMockRuleResponseBodyData struct {
	// The ID of the Alibaba Cloud account.
	AccountId *string `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the consumer application.
	ConsumerAppId *string `json:"ConsumerAppId,omitempty" xml:"ConsumerAppId,omitempty"`
	// The name of the consumer application.
	ConsumerAppName *string `json:"ConsumerAppName,omitempty" xml:"ConsumerAppName,omitempty"`
	// Indicates whether the mock rule is enabled.
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The description.
	ExtraJson *string `json:"ExtraJson,omitempty" xml:"ExtraJson,omitempty"`
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The mock type. Valid values:
	//
	// *   \- `[unk]0[unk]`: desktop client
	// *   \- `[unk]1[unk]`: mobile client
	MockType *int64 `json:"MockType,omitempty" xml:"MockType,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The ID of the service provider application.
	ProviderAppId *string `json:"ProviderAppId,omitempty" xml:"ProviderAppId,omitempty"`
	// The name of the service provider application.
	ProviderAppName *string `json:"ProviderAppName,omitempty" xml:"ProviderAppName,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The HTTP mock rule.
	ScMockItemJson *string `json:"ScMockItemJson,omitempty" xml:"ScMockItemJson,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s AddMockRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddMockRuleResponseBodyData) SetAccountId(v string) *AddMockRuleResponseBodyData {
	s.AccountId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetConsumerAppId(v string) *AddMockRuleResponseBodyData {
	s.ConsumerAppId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetConsumerAppName(v string) *AddMockRuleResponseBodyData {
	s.ConsumerAppName = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetEnable(v bool) *AddMockRuleResponseBodyData {
	s.Enable = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetExtraJson(v string) *AddMockRuleResponseBodyData {
	s.ExtraJson = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetId(v int64) *AddMockRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetMockType(v int64) *AddMockRuleResponseBodyData {
	s.MockType = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetName(v string) *AddMockRuleResponseBodyData {
	s.Name = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetNamespaceId(v string) *AddMockRuleResponseBodyData {
	s.NamespaceId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetProviderAppId(v string) *AddMockRuleResponseBodyData {
	s.ProviderAppId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetProviderAppName(v string) *AddMockRuleResponseBodyData {
	s.ProviderAppName = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetRegion(v string) *AddMockRuleResponseBodyData {
	s.Region = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetScMockItemJson(v string) *AddMockRuleResponseBodyData {
	s.ScMockItemJson = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetSource(v string) *AddMockRuleResponseBodyData {
	s.Source = &v
	return s
}

type AddMockRuleResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddMockRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddMockRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleResponse) GoString() string {
	return s.String()
}

func (s *AddMockRuleResponse) SetHeaders(v map[string]*string) *AddMockRuleResponse {
	s.Headers = v
	return s
}

func (s *AddMockRuleResponse) SetStatusCode(v int32) *AddMockRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddMockRuleResponse) SetBody(v *AddMockRuleResponseBody) *AddMockRuleResponse {
	s.Body = v
	return s
}

type AddSSLCertRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s AddSSLCertRequest) String() string {
	return tea.Prettify(s)
}

func (s AddSSLCertRequest) GoString() string {
	return s.String()
}

func (s *AddSSLCertRequest) SetAcceptLanguage(v string) *AddSSLCertRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddSSLCertRequest) SetCertIdentifier(v string) *AddSSLCertRequest {
	s.CertIdentifier = &v
	return s
}

func (s *AddSSLCertRequest) SetDomainId(v int64) *AddSSLCertRequest {
	s.DomainId = &v
	return s
}

func (s *AddSSLCertRequest) SetGatewayUniqueId(v string) *AddSSLCertRequest {
	s.GatewayUniqueId = &v
	return s
}

type AddSSLCertResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the association is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddSSLCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddSSLCertResponseBody) GoString() string {
	return s.String()
}

func (s *AddSSLCertResponseBody) SetCode(v int32) *AddSSLCertResponseBody {
	s.Code = &v
	return s
}

func (s *AddSSLCertResponseBody) SetData(v bool) *AddSSLCertResponseBody {
	s.Data = &v
	return s
}

func (s *AddSSLCertResponseBody) SetHttpStatusCode(v int32) *AddSSLCertResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddSSLCertResponseBody) SetMessage(v string) *AddSSLCertResponseBody {
	s.Message = &v
	return s
}

func (s *AddSSLCertResponseBody) SetRequestId(v string) *AddSSLCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddSSLCertResponseBody) SetSuccess(v bool) *AddSSLCertResponseBody {
	s.Success = &v
	return s
}

type AddSSLCertResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddSSLCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddSSLCertResponse) String() string {
	return tea.Prettify(s)
}

func (s AddSSLCertResponse) GoString() string {
	return s.String()
}

func (s *AddSSLCertResponse) SetHeaders(v map[string]*string) *AddSSLCertResponse {
	s.Headers = v
	return s
}

func (s *AddSSLCertResponse) SetStatusCode(v int32) *AddSSLCertResponse {
	s.StatusCode = &v
	return s
}

func (s *AddSSLCertResponse) SetBody(v *AddSSLCertResponseBody) *AddSSLCertResponse {
	s.Body = v
	return s
}

type AddSecurityGroupRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The range of port numbers.
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s AddSecurityGroupRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddSecurityGroupRuleRequest) GoString() string {
	return s.String()
}

func (s *AddSecurityGroupRuleRequest) SetAcceptLanguage(v string) *AddSecurityGroupRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetDescription(v string) *AddSecurityGroupRuleRequest {
	s.Description = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetGatewayUniqueId(v string) *AddSecurityGroupRuleRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetPortRange(v string) *AddSecurityGroupRuleRequest {
	s.PortRange = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetSecurityGroupId(v string) *AddSecurityGroupRuleRequest {
	s.SecurityGroupId = &v
	return s
}

type AddSecurityGroupRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddSecurityGroupRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddSecurityGroupRuleResponseBody) GoString() string {
	return s.String()
}

func (s *AddSecurityGroupRuleResponseBody) SetCode(v int32) *AddSecurityGroupRuleResponseBody {
	s.Code = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetData(v string) *AddSecurityGroupRuleResponseBody {
	s.Data = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetHttpStatusCode(v int32) *AddSecurityGroupRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetMessage(v string) *AddSecurityGroupRuleResponseBody {
	s.Message = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetRequestId(v string) *AddSecurityGroupRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetSuccess(v bool) *AddSecurityGroupRuleResponseBody {
	s.Success = &v
	return s
}

type AddSecurityGroupRuleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddSecurityGroupRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddSecurityGroupRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddSecurityGroupRuleResponse) GoString() string {
	return s.String()
}

func (s *AddSecurityGroupRuleResponse) SetHeaders(v map[string]*string) *AddSecurityGroupRuleResponse {
	s.Headers = v
	return s
}

func (s *AddSecurityGroupRuleResponse) SetStatusCode(v int32) *AddSecurityGroupRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddSecurityGroupRuleResponse) SetBody(v *AddSecurityGroupRuleResponseBody) *AddSecurityGroupRuleResponse {
	s.Body = v
	return s
}

type AddServiceSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh-CN (default): Chinese
	// *   en-US: English
	// *   ja: Japanese
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to monitor Ingress classes.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// Specifies whether to update the Ingress status.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The data structure.
	GroupList []*string `json:"GroupList,omitempty" xml:"GroupList,omitempty" type:"Repeated"`
	// The list of service groups.
	IngressOptionsRequest *AddServiceSourceRequestIngressOptionsRequest `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty" type:"Struct"`
	// The namespace whose resources you want to monitor.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The HTTP status code returned.
	PathList []*string `json:"PathList,omitempty" xml:"PathList,omitempty" type:"Repeated"`
	// The service source.
	//
	// *   K8s: ACK cluster
	// *   NACOS: MSE Nacos instance
	Source                    *string                                             `json:"Source,omitempty" xml:"Source,omitempty"`
	ToAuthorizeSecurityGroups []*AddServiceSourceRequestToAuthorizeSecurityGroups `json:"ToAuthorizeSecurityGroups,omitempty" xml:"ToAuthorizeSecurityGroups,omitempty" type:"Repeated"`
	// The type of the service source.
	//
	// *   K8s: Container Service for Kubernetes (ACK) cluster
	// *   NACOS: Nacos instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *AddServiceSourceRequest) SetAcceptLanguage(v string) *AddServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddServiceSourceRequest) SetAddress(v string) *AddServiceSourceRequest {
	s.Address = &v
	return s
}

func (s *AddServiceSourceRequest) SetGatewayUniqueId(v string) *AddServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddServiceSourceRequest) SetGroupList(v []*string) *AddServiceSourceRequest {
	s.GroupList = v
	return s
}

func (s *AddServiceSourceRequest) SetIngressOptionsRequest(v *AddServiceSourceRequestIngressOptionsRequest) *AddServiceSourceRequest {
	s.IngressOptionsRequest = v
	return s
}

func (s *AddServiceSourceRequest) SetName(v string) *AddServiceSourceRequest {
	s.Name = &v
	return s
}

func (s *AddServiceSourceRequest) SetPathList(v []*string) *AddServiceSourceRequest {
	s.PathList = v
	return s
}

func (s *AddServiceSourceRequest) SetSource(v string) *AddServiceSourceRequest {
	s.Source = &v
	return s
}

func (s *AddServiceSourceRequest) SetToAuthorizeSecurityGroups(v []*AddServiceSourceRequestToAuthorizeSecurityGroups) *AddServiceSourceRequest {
	s.ToAuthorizeSecurityGroups = v
	return s
}

func (s *AddServiceSourceRequest) SetType(v string) *AddServiceSourceRequest {
	s.Type = &v
	return s
}

type AddServiceSourceRequestIngressOptionsRequest struct {
	// The group to which the service belongs.
	EnableIngress *bool `json:"EnableIngress,omitempty" xml:"EnableIngress,omitempty"`
	// The language of the response. Valid values:
	//
	// *   zh-CN: Chinese. This is the default value.
	// *   en-US: English.
	// *   ja: Japanese.
	EnableStatus *bool `json:"EnableStatus,omitempty" xml:"EnableStatus,omitempty"`
	// An array of service root paths.
	IngressClass *string `json:"IngressClass,omitempty" xml:"IngressClass,omitempty"`
	// The root path of the service.
	WatchNamespace *string `json:"WatchNamespace,omitempty" xml:"WatchNamespace,omitempty"`
}

func (s AddServiceSourceRequestIngressOptionsRequest) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceRequestIngressOptionsRequest) GoString() string {
	return s.String()
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetEnableIngress(v bool) *AddServiceSourceRequestIngressOptionsRequest {
	s.EnableIngress = &v
	return s
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetEnableStatus(v bool) *AddServiceSourceRequestIngressOptionsRequest {
	s.EnableStatus = &v
	return s
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetIngressClass(v string) *AddServiceSourceRequestIngressOptionsRequest {
	s.IngressClass = &v
	return s
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetWatchNamespace(v string) *AddServiceSourceRequestIngressOptionsRequest {
	s.WatchNamespace = &v
	return s
}

type AddServiceSourceRequestToAuthorizeSecurityGroups struct {
	Description     *string `json:"Description,omitempty" xml:"Description,omitempty"`
	PortRange       *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s AddServiceSourceRequestToAuthorizeSecurityGroups) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceRequestToAuthorizeSecurityGroups) GoString() string {
	return s.String()
}

func (s *AddServiceSourceRequestToAuthorizeSecurityGroups) SetDescription(v string) *AddServiceSourceRequestToAuthorizeSecurityGroups {
	s.Description = &v
	return s
}

func (s *AddServiceSourceRequestToAuthorizeSecurityGroups) SetPortRange(v string) *AddServiceSourceRequestToAuthorizeSecurityGroups {
	s.PortRange = &v
	return s
}

func (s *AddServiceSourceRequestToAuthorizeSecurityGroups) SetSecurityGroupId(v string) *AddServiceSourceRequestToAuthorizeSecurityGroups {
	s.SecurityGroupId = &v
	return s
}

type AddServiceSourceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh-CN (default): Chinese
	// *   en-US: English
	// *   ja: Japanese
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to monitor Ingress classes.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// Specifies whether to update the Ingress status.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The data structure.
	GroupListShrink *string `json:"GroupList,omitempty" xml:"GroupList,omitempty"`
	// The list of service groups.
	IngressOptionsRequestShrink *string `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty"`
	// The namespace whose resources you want to monitor.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The HTTP status code returned.
	PathListShrink *string `json:"PathList,omitempty" xml:"PathList,omitempty"`
	// The service source.
	//
	// *   K8s: ACK cluster
	// *   NACOS: MSE Nacos instance
	Source                          *string `json:"Source,omitempty" xml:"Source,omitempty"`
	ToAuthorizeSecurityGroupsShrink *string `json:"ToAuthorizeSecurityGroups,omitempty" xml:"ToAuthorizeSecurityGroups,omitempty"`
	// The type of the service source.
	//
	// *   K8s: Container Service for Kubernetes (ACK) cluster
	// *   NACOS: Nacos instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddServiceSourceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddServiceSourceShrinkRequest) SetAcceptLanguage(v string) *AddServiceSourceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetAddress(v string) *AddServiceSourceShrinkRequest {
	s.Address = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetGatewayUniqueId(v string) *AddServiceSourceShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetGroupListShrink(v string) *AddServiceSourceShrinkRequest {
	s.GroupListShrink = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetIngressOptionsRequestShrink(v string) *AddServiceSourceShrinkRequest {
	s.IngressOptionsRequestShrink = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetName(v string) *AddServiceSourceShrinkRequest {
	s.Name = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetPathListShrink(v string) *AddServiceSourceShrinkRequest {
	s.PathListShrink = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetSource(v string) *AddServiceSourceShrinkRequest {
	s.Source = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetToAuthorizeSecurityGroupsShrink(v string) *AddServiceSourceShrinkRequest {
	s.ToAuthorizeSecurityGroupsShrink = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetType(v string) *AddServiceSourceShrinkRequest {
	s.Type = &v
	return s
}

type AddServiceSourceResponseBody struct {
	// duplicatedClusterAliasName
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// mse-100-007
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// code
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// mse-200-105
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The response data.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// duplicated cluster alias name
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *AddServiceSourceResponseBody) SetCode(v int32) *AddServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetData(v int64) *AddServiceSourceResponseBody {
	s.Data = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetHttpStatusCode(v int32) *AddServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetMessage(v string) *AddServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetRequestId(v string) *AddServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetSuccess(v bool) *AddServiceSourceResponseBody {
	s.Success = &v
	return s
}

type AddServiceSourceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *AddServiceSourceResponse) SetHeaders(v map[string]*string) *AddServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *AddServiceSourceResponse) SetStatusCode(v int32) *AddServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddServiceSourceResponse) SetBody(v *AddServiceSourceResponseBody) *AddServiceSourceResponse {
	s.Body = v
	return s
}

type ApplyGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *string `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s ApplyGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *ApplyGatewayRouteRequest) SetAcceptLanguage(v string) *ApplyGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ApplyGatewayRouteRequest) SetGatewayUniqueId(v string) *ApplyGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ApplyGatewayRouteRequest) SetRouteId(v string) *ApplyGatewayRouteRequest {
	s.RouteId = &v
	return s
}

type ApplyGatewayRouteResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ApplyGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyGatewayRouteResponseBody) SetCode(v int32) *ApplyGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetData(v bool) *ApplyGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetHttpStatusCode(v int32) *ApplyGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetMessage(v string) *ApplyGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetRequestId(v string) *ApplyGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetSuccess(v bool) *ApplyGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type ApplyGatewayRouteResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *ApplyGatewayRouteResponse) SetHeaders(v map[string]*string) *ApplyGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *ApplyGatewayRouteResponse) SetStatusCode(v int32) *ApplyGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyGatewayRouteResponse) SetBody(v *ApplyGatewayRouteResponseBody) *ApplyGatewayRouteResponse {
	s.Body = v
	return s
}

type ApplyTagPoliciesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Deprecated
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether to enable the routing rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The Microservices Engine (MSE) namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Optional. The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The details of the routing rule.
	Rules map[string]*RulesValue `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s ApplyTagPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesRequest) SetAcceptLanguage(v string) *ApplyTagPoliciesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetAppId(v string) *ApplyTagPoliciesRequest {
	s.AppId = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetAppName(v string) *ApplyTagPoliciesRequest {
	s.AppName = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetEnable(v bool) *ApplyTagPoliciesRequest {
	s.Enable = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetNamespace(v string) *ApplyTagPoliciesRequest {
	s.Namespace = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetNamespaceId(v string) *ApplyTagPoliciesRequest {
	s.NamespaceId = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetRegion(v string) *ApplyTagPoliciesRequest {
	s.Region = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetRules(v map[string]*RulesValue) *ApplyTagPoliciesRequest {
	s.Rules = v
	return s
}

type ApplyTagPoliciesShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Deprecated
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether to enable the routing rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The Microservices Engine (MSE) namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Optional. The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The details of the routing rule.
	RulesShrink *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s ApplyTagPoliciesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesShrinkRequest) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesShrinkRequest) SetAcceptLanguage(v string) *ApplyTagPoliciesShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ApplyTagPoliciesShrinkRequest) SetAppId(v string) *ApplyTagPoliciesShrinkRequest {
	s.AppId = &v
	return s
}

func (s *ApplyTagPoliciesShrinkRequest) SetAppName(v string) *ApplyTagPoliciesShrinkRequest {
	s.AppName = &v
	return s
}

func (s *ApplyTagPoliciesShrinkRequest) SetEnable(v bool) *ApplyTagPoliciesShrinkRequest {
	s.Enable = &v
	return s
}

func (s *ApplyTagPoliciesShrinkRequest) SetNamespace(v string) *ApplyTagPoliciesShrinkRequest {
	s.Namespace = &v
	return s
}

func (s *ApplyTagPoliciesShrinkRequest) SetNamespaceId(v string) *ApplyTagPoliciesShrinkRequest {
	s.NamespaceId = &v
	return s
}

func (s *ApplyTagPoliciesShrinkRequest) SetRegion(v string) *ApplyTagPoliciesShrinkRequest {
	s.Region = &v
	return s
}

func (s *ApplyTagPoliciesShrinkRequest) SetRulesShrink(v string) *ApplyTagPoliciesShrinkRequest {
	s.RulesShrink = &v
	return s
}

type ApplyTagPoliciesResponseBody struct {
	// The details of the data.
	Data []*ApplyTagPoliciesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ApplyTagPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesResponseBody) SetData(v []*ApplyTagPoliciesResponseBodyData) *ApplyTagPoliciesResponseBody {
	s.Data = v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetMessage(v string) *ApplyTagPoliciesResponseBody {
	s.Message = &v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetRequestId(v string) *ApplyTagPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetSuccess(v bool) *ApplyTagPoliciesResponseBody {
	s.Success = &v
	return s
}

type ApplyTagPoliciesResponseBodyData struct {
	// Indicates whether the field is the primary key.
	CarryData *bool `json:"CarryData,omitempty" xml:"CarryData,omitempty"`
	// Indicates whether the rule is enabled. Valid values:
	//
	// *   `true`: The rule is enabled.
	// *   `false`: The rule is disabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the primary key.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The number of instances.
	InstanceNum *int32 `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	// The policy name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The rate.
	Rate *int32 `json:"Rate,omitempty" xml:"Rate,omitempty"`
	// Indicates whether the routing rule was deleted.
	Remove *bool `json:"Remove,omitempty" xml:"Remove,omitempty"`
	// The details of the routing rule.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ApplyTagPoliciesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesResponseBodyData) SetCarryData(v bool) *ApplyTagPoliciesResponseBodyData {
	s.CarryData = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetEnable(v bool) *ApplyTagPoliciesResponseBodyData {
	s.Enable = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetId(v int64) *ApplyTagPoliciesResponseBodyData {
	s.Id = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetInstanceNum(v int32) *ApplyTagPoliciesResponseBodyData {
	s.InstanceNum = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetName(v string) *ApplyTagPoliciesResponseBodyData {
	s.Name = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetRate(v int32) *ApplyTagPoliciesResponseBodyData {
	s.Rate = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetRemove(v bool) *ApplyTagPoliciesResponseBodyData {
	s.Remove = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetRules(v string) *ApplyTagPoliciesResponseBodyData {
	s.Rules = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetStatus(v int32) *ApplyTagPoliciesResponseBodyData {
	s.Status = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetTag(v string) *ApplyTagPoliciesResponseBodyData {
	s.Tag = &v
	return s
}

type ApplyTagPoliciesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyTagPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyTagPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesResponse) SetHeaders(v map[string]*string) *ApplyTagPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ApplyTagPoliciesResponse) SetStatusCode(v int32) *ApplyTagPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyTagPoliciesResponse) SetBody(v *ApplyTagPoliciesResponseBody) *ApplyTagPoliciesResponse {
	s.Body = v
	return s
}

type CloneNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The data structure.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The ID of the destination namespace.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The policy used when a write conflict occurs.
	//
	// *   ABORT
	// *   SKIP
	// *   OVERWRITE
	OriginNamespaceId *string `json:"OriginNamespaceId,omitempty" xml:"OriginNamespaceId,omitempty"`
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The IDs of configurations.
	TargetNamespaceId *string `json:"TargetNamespaceId,omitempty" xml:"TargetNamespaceId,omitempty"`
}

func (s CloneNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigRequest) SetAcceptLanguage(v string) *CloneNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CloneNacosConfigRequest) SetIds(v string) *CloneNacosConfigRequest {
	s.Ids = &v
	return s
}

func (s *CloneNacosConfigRequest) SetInstanceId(v string) *CloneNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *CloneNacosConfigRequest) SetOriginNamespaceId(v string) *CloneNacosConfigRequest {
	s.OriginNamespaceId = &v
	return s
}

func (s *CloneNacosConfigRequest) SetPolicy(v string) *CloneNacosConfigRequest {
	s.Policy = &v
	return s
}

func (s *CloneNacosConfigRequest) SetTargetNamespaceId(v string) *CloneNacosConfigRequest {
	s.TargetNamespaceId = &v
	return s
}

type CloneNacosConfigResponseBody struct {
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of skipped operations.
	Data *CloneNacosConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The number of successful operations.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The message returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The details of the data.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The error code returned if the request failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The response code returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CloneNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBody) SetCode(v int32) *CloneNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetData(v *CloneNacosConfigResponseBodyData) *CloneNacosConfigResponseBody {
	s.Data = v
	return s
}

func (s *CloneNacosConfigResponseBody) SetDynamicMessage(v string) *CloneNacosConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetErrorCode(v string) *CloneNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetHttpStatusCode(v int32) *CloneNacosConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetMessage(v string) *CloneNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetRequestId(v string) *CloneNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetSuccess(v bool) *CloneNacosConfigResponseBody {
	s.Success = &v
	return s
}

type CloneNacosConfigResponseBodyData struct {
	// The ID of the data.
	FailData []*CloneNacosConfigResponseBodyDataFailData `json:"FailData,omitempty" xml:"FailData,omitempty" type:"Repeated"`
	// The data structure.
	SkipCount *int32 `json:"SkipCount,omitempty" xml:"SkipCount,omitempty"`
	// The ID of the data.
	SkipData []*CloneNacosConfigResponseBodyDataSkipData `json:"SkipData,omitempty" xml:"SkipData,omitempty" type:"Repeated"`
	// The details of the skipped configurations.
	SuccCount *int32 `json:"SuccCount,omitempty" xml:"SuccCount,omitempty"`
}

func (s CloneNacosConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBodyData) SetFailData(v []*CloneNacosConfigResponseBodyDataFailData) *CloneNacosConfigResponseBodyData {
	s.FailData = v
	return s
}

func (s *CloneNacosConfigResponseBodyData) SetSkipCount(v int32) *CloneNacosConfigResponseBodyData {
	s.SkipCount = &v
	return s
}

func (s *CloneNacosConfigResponseBodyData) SetSkipData(v []*CloneNacosConfigResponseBodyDataSkipData) *CloneNacosConfigResponseBodyData {
	s.SkipData = v
	return s
}

func (s *CloneNacosConfigResponseBodyData) SetSuccCount(v int32) *CloneNacosConfigResponseBodyData {
	s.SuccCount = &v
	return s
}

type CloneNacosConfigResponseBodyDataFailData struct {
	// mse-200-105
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// duplicatedClusterAliasName
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s CloneNacosConfigResponseBodyDataFailData) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBodyDataFailData) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBodyDataFailData) SetDataId(v string) *CloneNacosConfigResponseBodyDataFailData {
	s.DataId = &v
	return s
}

func (s *CloneNacosConfigResponseBodyDataFailData) SetGroup(v string) *CloneNacosConfigResponseBodyDataFailData {
	s.Group = &v
	return s
}

type CloneNacosConfigResponseBodyDataSkipData struct {
	// The details of the failed configurations.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The data structure.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s CloneNacosConfigResponseBodyDataSkipData) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBodyDataSkipData) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBodyDataSkipData) SetDataId(v string) *CloneNacosConfigResponseBodyDataSkipData {
	s.DataId = &v
	return s
}

func (s *CloneNacosConfigResponseBodyDataSkipData) SetGroup(v string) *CloneNacosConfigResponseBodyDataSkipData {
	s.Group = &v
	return s
}

type CloneNacosConfigResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloneNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloneNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponse) SetHeaders(v map[string]*string) *CloneNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *CloneNacosConfigResponse) SetStatusCode(v int32) *CloneNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *CloneNacosConfigResponse) SetBody(v *CloneNacosConfigResponseBody) *CloneNacosConfigResponse {
	s.Body = v
	return s
}

type CreateApplicationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// MSE
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region to which the application belongs.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Specifies whether to start the switch.
	SentinelEnable *string `json:"SentinelEnable,omitempty" xml:"SentinelEnable,omitempty"`
	// The service where the application is deployed. A value of ACK indicates Container Service for Kubernetes.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The name of the Microservices Engine (MSE) namespace.
	SwitchEnable *string `json:"SwitchEnable,omitempty" xml:"SwitchEnable,omitempty"`
}

func (s CreateApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationRequest) GoString() string {
	return s.String()
}

func (s *CreateApplicationRequest) SetAcceptLanguage(v string) *CreateApplicationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateApplicationRequest) SetAppName(v string) *CreateApplicationRequest {
	s.AppName = &v
	return s
}

func (s *CreateApplicationRequest) SetLanguage(v string) *CreateApplicationRequest {
	s.Language = &v
	return s
}

func (s *CreateApplicationRequest) SetNamespace(v string) *CreateApplicationRequest {
	s.Namespace = &v
	return s
}

func (s *CreateApplicationRequest) SetRegion(v string) *CreateApplicationRequest {
	s.Region = &v
	return s
}

func (s *CreateApplicationRequest) SetSentinelEnable(v string) *CreateApplicationRequest {
	s.SentinelEnable = &v
	return s
}

func (s *CreateApplicationRequest) SetSource(v string) *CreateApplicationRequest {
	s.Source = &v
	return s
}

func (s *CreateApplicationRequest) SetSwitchEnable(v string) *CreateApplicationRequest {
	s.SwitchEnable = &v
	return s
}

type CreateApplicationResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *CreateApplicationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateApplicationResponseBody) SetCode(v int32) *CreateApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *CreateApplicationResponseBody) SetData(v *CreateApplicationResponseBodyData) *CreateApplicationResponseBody {
	s.Data = v
	return s
}

func (s *CreateApplicationResponseBody) SetHttpStatusCode(v int32) *CreateApplicationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateApplicationResponseBody) SetMessage(v string) *CreateApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *CreateApplicationResponseBody) SetRequestId(v string) *CreateApplicationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateApplicationResponseBody) SetSuccess(v string) *CreateApplicationResponseBody {
	s.Success = &v
	return s
}

type CreateApplicationResponseBodyData struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The creation time.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	// MSE
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The service where the application is deployed. Valid values:
	//
	// *   \- ACK: Container Service for Kubernetes
	// *   \- Normal: another service
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status of the application. A value of 1 indicates that the application is in a normal state.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The update time.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// 
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s CreateApplicationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateApplicationResponseBodyData) SetAppId(v string) *CreateApplicationResponseBodyData {
	s.AppId = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetAppName(v string) *CreateApplicationResponseBodyData {
	s.AppName = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetCreateTime(v int64) *CreateApplicationResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetExtraInfo(v string) *CreateApplicationResponseBodyData {
	s.ExtraInfo = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetLanguage(v string) *CreateApplicationResponseBodyData {
	s.Language = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetLicenseKey(v string) *CreateApplicationResponseBodyData {
	s.LicenseKey = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetNamespace(v string) *CreateApplicationResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetRegionId(v string) *CreateApplicationResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetSource(v string) *CreateApplicationResponseBodyData {
	s.Source = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetStatus(v int32) *CreateApplicationResponseBodyData {
	s.Status = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetUpdateTime(v int64) *CreateApplicationResponseBodyData {
	s.UpdateTime = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetUserId(v string) *CreateApplicationResponseBodyData {
	s.UserId = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetVersion(v string) *CreateApplicationResponseBodyData {
	s.Version = &v
	return s
}

type CreateApplicationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationResponse) GoString() string {
	return s.String()
}

func (s *CreateApplicationResponse) SetHeaders(v map[string]*string) *CreateApplicationResponse {
	s.Headers = v
	return s
}

func (s *CreateApplicationResponse) SetStatusCode(v int32) *CreateApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateApplicationResponse) SetBody(v *CreateApplicationResponseBody) *CreateApplicationResponse {
	s.Body = v
	return s
}

type CreateCircuitBreakerRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether to enable the rule.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The minimum number of requests that can be passed in each step after circuit breaking recovers. Default value: 1.
	HalfOpenBaseAmountPerStep *int32 `json:"HalfOpenBaseAmountPerStep,omitempty" xml:"HalfOpenBaseAmountPerStep,omitempty"`
	// The number of circuit breaking recovery steps. Default value: 1.
	HalfOpenRecoveryStepNum *int32 `json:"HalfOpenRecoveryStepNum,omitempty" xml:"HalfOpenRecoveryStepNum,omitempty"`
	// The maximum response time (RT). Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
	MaxAllowedRtMs *int32 `json:"MaxAllowedRtMs,omitempty" xml:"MaxAllowedRtMs,omitempty"`
	// The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met. Default value: 10.
	MinRequestAmount *int32 `json:"MinRequestAmount,omitempty" xml:"MinRequestAmount,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region in which the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the interface to which the rule applies. The interface name must be the same as the name on the interface details page in the console.
	Resource     *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceType *int32  `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period. The value must be an integral multiple of 1,000. Default value: 10000. This value indicates 10 seconds.
	RetryTimeoutMs *int32 `json:"RetryTimeoutMs,omitempty" xml:"RetryTimeoutMs,omitempty"`
	// The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes. The default value is 20000. This value indicates 20 seconds.
	StatIntervalMs *int32 `json:"StatIntervalMs,omitempty" xml:"StatIntervalMs,omitempty"`
	// The threshold type.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     slow call proportion
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     abnormal proportion
	//
	//     <!-- -->
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateCircuitBreakerRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCircuitBreakerRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateCircuitBreakerRuleRequest) SetAcceptLanguage(v string) *CreateCircuitBreakerRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetAppId(v string) *CreateCircuitBreakerRuleRequest {
	s.AppId = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetAppName(v string) *CreateCircuitBreakerRuleRequest {
	s.AppName = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetEnable(v bool) *CreateCircuitBreakerRuleRequest {
	s.Enable = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetHalfOpenBaseAmountPerStep(v int32) *CreateCircuitBreakerRuleRequest {
	s.HalfOpenBaseAmountPerStep = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetHalfOpenRecoveryStepNum(v int32) *CreateCircuitBreakerRuleRequest {
	s.HalfOpenRecoveryStepNum = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetMaxAllowedRtMs(v int32) *CreateCircuitBreakerRuleRequest {
	s.MaxAllowedRtMs = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetMinRequestAmount(v int32) *CreateCircuitBreakerRuleRequest {
	s.MinRequestAmount = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetNamespace(v string) *CreateCircuitBreakerRuleRequest {
	s.Namespace = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetRegionId(v string) *CreateCircuitBreakerRuleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetResource(v string) *CreateCircuitBreakerRuleRequest {
	s.Resource = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetResourceType(v int32) *CreateCircuitBreakerRuleRequest {
	s.ResourceType = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetRetryTimeoutMs(v int32) *CreateCircuitBreakerRuleRequest {
	s.RetryTimeoutMs = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetStatIntervalMs(v int32) *CreateCircuitBreakerRuleRequest {
	s.StatIntervalMs = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetStrategy(v int32) *CreateCircuitBreakerRuleRequest {
	s.Strategy = &v
	return s
}

func (s *CreateCircuitBreakerRuleRequest) SetThreshold(v float32) *CreateCircuitBreakerRuleRequest {
	s.Threshold = &v
	return s
}

type CreateCircuitBreakerRuleResponseBody struct {
	// The response code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the rule.
	Data *CreateCircuitBreakerRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateCircuitBreakerRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCircuitBreakerRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCircuitBreakerRuleResponseBody) SetCode(v string) *CreateCircuitBreakerRuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBody) SetData(v *CreateCircuitBreakerRuleResponseBodyData) *CreateCircuitBreakerRuleResponseBody {
	s.Data = v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBody) SetMessage(v string) *CreateCircuitBreakerRuleResponseBody {
	s.Message = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBody) SetRequestId(v string) *CreateCircuitBreakerRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBody) SetSuccess(v bool) *CreateCircuitBreakerRuleResponseBody {
	s.Success = &v
	return s
}

type CreateCircuitBreakerRuleResponseBodyData struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Indicates whether the rule is enabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The minimum number of requests that can be passed in each step after circuit breaking recovers.
	HalfOpenBaseAmountPerStep *int32 `json:"HalfOpenBaseAmountPerStep,omitempty" xml:"HalfOpenBaseAmountPerStep,omitempty"`
	// The number of circuit breaking recovery steps.
	HalfOpenRecoveryStepNum *int32 `json:"HalfOpenRecoveryStepNum,omitempty" xml:"HalfOpenRecoveryStepNum,omitempty"`
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The maximum response time (RT). Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
	MaxAllowedRtMs *int32 `json:"MaxAllowedRtMs,omitempty" xml:"MaxAllowedRtMs,omitempty"`
	// The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met.
	MinRequestAmount *int32 `json:"MinRequestAmount,omitempty" xml:"MinRequestAmount,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region in which the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the interface to which the rule is applicable. The interface name must be the same as the name on the interface details page in the console.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period.
	RetryTimeoutMs *int32 `json:"RetryTimeoutMs,omitempty" xml:"RetryTimeoutMs,omitempty"`
	// The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes.
	StatIntervalMs *int32 `json:"StatIntervalMs,omitempty" xml:"StatIntervalMs,omitempty"`
	// The threshold type.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Slow call ratio
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Abnormal proportion
	//
	//     <!-- -->
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateCircuitBreakerRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateCircuitBreakerRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetAppId(v string) *CreateCircuitBreakerRuleResponseBodyData {
	s.AppId = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetAppName(v string) *CreateCircuitBreakerRuleResponseBodyData {
	s.AppName = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetEnable(v bool) *CreateCircuitBreakerRuleResponseBodyData {
	s.Enable = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetHalfOpenBaseAmountPerStep(v int32) *CreateCircuitBreakerRuleResponseBodyData {
	s.HalfOpenBaseAmountPerStep = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetHalfOpenRecoveryStepNum(v int32) *CreateCircuitBreakerRuleResponseBodyData {
	s.HalfOpenRecoveryStepNum = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetId(v int64) *CreateCircuitBreakerRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetMaxAllowedRtMs(v int32) *CreateCircuitBreakerRuleResponseBodyData {
	s.MaxAllowedRtMs = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetMinRequestAmount(v int32) *CreateCircuitBreakerRuleResponseBodyData {
	s.MinRequestAmount = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetNamespace(v string) *CreateCircuitBreakerRuleResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetRegionId(v string) *CreateCircuitBreakerRuleResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetResource(v string) *CreateCircuitBreakerRuleResponseBodyData {
	s.Resource = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetRetryTimeoutMs(v int32) *CreateCircuitBreakerRuleResponseBodyData {
	s.RetryTimeoutMs = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetStatIntervalMs(v int32) *CreateCircuitBreakerRuleResponseBodyData {
	s.StatIntervalMs = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetStrategy(v int32) *CreateCircuitBreakerRuleResponseBodyData {
	s.Strategy = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponseBodyData) SetThreshold(v float32) *CreateCircuitBreakerRuleResponseBodyData {
	s.Threshold = &v
	return s
}

type CreateCircuitBreakerRuleResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCircuitBreakerRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCircuitBreakerRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCircuitBreakerRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateCircuitBreakerRuleResponse) SetHeaders(v map[string]*string) *CreateCircuitBreakerRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateCircuitBreakerRuleResponse) SetStatusCode(v int32) *CreateCircuitBreakerRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCircuitBreakerRuleResponse) SetBody(v *CreateCircuitBreakerRuleResponseBody) *CreateCircuitBreakerRuleResponse {
	s.Body = v
	return s
}

type CreateClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The billing method.
	//
	// Valid values:
	//
	// *   PREPAY
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the subscription billing method
	//
	//     <!-- -->
	//
	// *   POSTPAY
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the pay-as-you-go billing method
	//
	//     <!-- -->
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The engine specifications. Valid values:
	//
	// \[Professional Edition]
	//
	// *   `MSE_SC_2_4_60_c`: 2 vCPUs and 4 GB of memory
	// *   `MSE_SC_1_2_60_c`: 1 vCPU and 2 GB of memory
	// *   `MSE_SC_4_8_60_c`: 4 vCPUs and 8 GB of memory
	// *   `MSE_SC_8_16_60_c`: 8 vCPUs and 16 GB of memory
	// *   `MSE_SC_16_32_60_c`: 16 vCPUs and 32 GB of memory
	//
	// \[Developer Edition]
	//
	// *   `MSE_SC_1_2_60_c`: 1 vCPU and 2 GB of memory
	// *   `MSE_SC_2_4_60_c`: 2 vCPUs and 4 GB of memory
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The type of the instance. Valid values: ZooKeeper and Nacos-Ans.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The engine version of the instance. Valid values:
	//
	// \[Professional version]
	//
	// *   `NACOS_2_0_0`: Nacos 2.0.0
	// *   `ZooKeeper_3_8_0`: ZooKeeper 3.8.0
	//
	// \[Developer Edition]
	//
	// *   `NACOS_2_0_0`: Nacos 2.0.0
	// *   `ZooKeeper_3_8_0`: ZooKeeper 3.8.0
	ClusterVersion *string `json:"ClusterVersion,omitempty" xml:"ClusterVersion,omitempty"`
	// The network connection type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	// Deprecated
	// The type of the disk. Valid values:
	//
	// *   alicloud-disk-ssd
	// *   alicloud-disk-essd-pl1
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// Specifies whether to enable Internet access (Elastic IP Address) if ConnectionType is set to `single_eni`.
	EipEnabled *bool `json:"EipEnabled,omitempty" xml:"EipEnabled,omitempty"`
	// The number of nodes in the instance. Valid values: 1 to 9.
	//
	// \[Professional Edition]
	//
	// *   The number of nodes in an instance is greater than or equal to 3 and must be an odd number.
	//
	// \[Developer Edition]
	//
	// *   Only one node can be deployed for an instance.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The name of the MSE instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Configure this parameter unless otherwise specified. Valid values:
	//
	// *   `mse_pro`: Professional Edition
	// *   `mse_dev`: Developer Edition.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The network type of the MSE instance. Valid values:
	//
	// *   `privatenet`: VPC
	// *   `pubnet`: Internet
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// Deprecated
	// The specifications of the internal-facing SLB instance. Valid values:
	//
	// *   `slb.s1.small`
	// *   `slb.s3.medium`
	PrivateSlbSpecification *string `json:"PrivateSlbSpecification,omitempty" xml:"PrivateSlbSpecification,omitempty"`
	// The public bandwidth. Unit: Mbit/s. This parameter is required.\
	// Valid values: 0 to 5000. A value of 0 indicates no access to the Internet.
	PubNetworkFlow *string `json:"PubNetworkFlow,omitempty" xml:"PubNetworkFlow,omitempty"`
	// Deprecated
	// The specifications of the Internet-facing Server Load Balancer (SLB) instance. Valid values:
	//
	// *   `slb.s1.small`
	// *   `slb.s3.medium`
	PubSlbSpecification *string `json:"PubSlbSpecification,omitempty" xml:"PubSlbSpecification,omitempty"`
	// The region where the instance resides. Examples:
	//
	// *   `cn-hangzhou`: China (Hangzhou)
	// *   `cn-beijing`: China (Beijing)
	// *   `cn-shanghai`: China (Shanghai)
	// *   `cn-zhangjiakou`: China (Zhangjiakou)
	// *   `cn-shenzhen`: China (Shenzhen)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The ID of the resource group. For the details of resource groups, see [View basic information of a resource group](~~457230~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of the security group to which the instance belongs. This parameter is valid only when the ConnectionType parameter is set to `single_eni`.
	//
	// Valid values:
	//
	// *   enterprise
	// *   normal
	SecurityGroupType *string `json:"SecurityGroupType,omitempty" xml:"SecurityGroupType,omitempty"`
	// The list of the tags that you want to add.
	Tag []*CreateClusterRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterRequest) GoString() string {
	return s.String()
}

func (s *CreateClusterRequest) SetAcceptLanguage(v string) *CreateClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateClusterRequest) SetChargeType(v string) *CreateClusterRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateClusterRequest) SetClusterSpecification(v string) *CreateClusterRequest {
	s.ClusterSpecification = &v
	return s
}

func (s *CreateClusterRequest) SetClusterType(v string) *CreateClusterRequest {
	s.ClusterType = &v
	return s
}

func (s *CreateClusterRequest) SetClusterVersion(v string) *CreateClusterRequest {
	s.ClusterVersion = &v
	return s
}

func (s *CreateClusterRequest) SetConnectionType(v string) *CreateClusterRequest {
	s.ConnectionType = &v
	return s
}

func (s *CreateClusterRequest) SetDiskType(v string) *CreateClusterRequest {
	s.DiskType = &v
	return s
}

func (s *CreateClusterRequest) SetEipEnabled(v bool) *CreateClusterRequest {
	s.EipEnabled = &v
	return s
}

func (s *CreateClusterRequest) SetInstanceCount(v int32) *CreateClusterRequest {
	s.InstanceCount = &v
	return s
}

func (s *CreateClusterRequest) SetInstanceName(v string) *CreateClusterRequest {
	s.InstanceName = &v
	return s
}

func (s *CreateClusterRequest) SetMseVersion(v string) *CreateClusterRequest {
	s.MseVersion = &v
	return s
}

func (s *CreateClusterRequest) SetNetType(v string) *CreateClusterRequest {
	s.NetType = &v
	return s
}

func (s *CreateClusterRequest) SetPrivateSlbSpecification(v string) *CreateClusterRequest {
	s.PrivateSlbSpecification = &v
	return s
}

func (s *CreateClusterRequest) SetPubNetworkFlow(v string) *CreateClusterRequest {
	s.PubNetworkFlow = &v
	return s
}

func (s *CreateClusterRequest) SetPubSlbSpecification(v string) *CreateClusterRequest {
	s.PubSlbSpecification = &v
	return s
}

func (s *CreateClusterRequest) SetRegion(v string) *CreateClusterRequest {
	s.Region = &v
	return s
}

func (s *CreateClusterRequest) SetRequestPars(v string) *CreateClusterRequest {
	s.RequestPars = &v
	return s
}

func (s *CreateClusterRequest) SetResourceGroupId(v string) *CreateClusterRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateClusterRequest) SetSecurityGroupType(v string) *CreateClusterRequest {
	s.SecurityGroupType = &v
	return s
}

func (s *CreateClusterRequest) SetTag(v []*CreateClusterRequestTag) *CreateClusterRequest {
	s.Tag = v
	return s
}

func (s *CreateClusterRequest) SetVSwitchId(v string) *CreateClusterRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateClusterRequest) SetVpcId(v string) *CreateClusterRequest {
	s.VpcId = &v
	return s
}

type CreateClusterRequestTag struct {
	// The key of a tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of a tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateClusterRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterRequestTag) GoString() string {
	return s.String()
}

func (s *CreateClusterRequestTag) SetKey(v string) *CreateClusterRequestTag {
	s.Key = &v
	return s
}

func (s *CreateClusterRequestTag) SetValue(v string) *CreateClusterRequestTag {
	s.Value = &v
	return s
}

type CreateClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterResponseBody) GoString() string {
	return s.String()
}

func (s *CreateClusterResponseBody) SetErrorCode(v string) *CreateClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateClusterResponseBody) SetInstanceId(v string) *CreateClusterResponseBody {
	s.InstanceId = &v
	return s
}

func (s *CreateClusterResponseBody) SetMessage(v string) *CreateClusterResponseBody {
	s.Message = &v
	return s
}

func (s *CreateClusterResponseBody) SetOrderId(v string) *CreateClusterResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateClusterResponseBody) SetRequestId(v string) *CreateClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateClusterResponseBody) SetSuccess(v bool) *CreateClusterResponseBody {
	s.Success = &v
	return s
}

type CreateClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterResponse) GoString() string {
	return s.String()
}

func (s *CreateClusterResponse) SetHeaders(v map[string]*string) *CreateClusterResponse {
	s.Headers = v
	return s
}

func (s *CreateClusterResponse) SetStatusCode(v int32) *CreateClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateClusterResponse) SetBody(v *CreateClusterResponseBody) *CreateClusterResponse {
	s.Body = v
	return s
}

type CreateEngineNamespaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The description of the namespace.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The custom ID of the namespace. If you do not specify this parameter, the automatically generated Universally Unique Identifier (UUID) is returned.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The display name of the namespace.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The maximum number of services that can run in the namespace.
	ServiceCount *int32 `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
}

func (s CreateEngineNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceRequest) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceRequest) SetAcceptLanguage(v string) *CreateEngineNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetClusterId(v string) *CreateEngineNamespaceRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetDesc(v string) *CreateEngineNamespaceRequest {
	s.Desc = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetId(v string) *CreateEngineNamespaceRequest {
	s.Id = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetInstanceId(v string) *CreateEngineNamespaceRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetName(v string) *CreateEngineNamespaceRequest {
	s.Name = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetServiceCount(v int32) *CreateEngineNamespaceRequest {
	s.ServiceCount = &v
	return s
}

type CreateEngineNamespaceResponseBody struct {
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The details of the data.
	Data *CreateEngineNamespaceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEngineNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceResponseBody) SetClusterId(v string) *CreateEngineNamespaceResponseBody {
	s.ClusterId = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetData(v *CreateEngineNamespaceResponseBodyData) *CreateEngineNamespaceResponseBody {
	s.Data = v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetErrorCode(v string) *CreateEngineNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetMessage(v string) *CreateEngineNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetRequestId(v string) *CreateEngineNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetSuccess(v bool) *CreateEngineNamespaceResponseBody {
	s.Success = &v
	return s
}

type CreateEngineNamespaceResponseBodyData struct {
	// The number of configurations.
	ConfigCount *int32 `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The display name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quota of configurations.
	Quota *int32 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The number of active services.
	ServiceCount *int32 `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   `0`: global configuration
	// *   `1`: default namespace
	// *   `2`: custom namespace
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEngineNamespaceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceResponseBodyData) SetConfigCount(v int32) *CreateEngineNamespaceResponseBodyData {
	s.ConfigCount = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetNamespace(v string) *CreateEngineNamespaceResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetNamespaceDesc(v string) *CreateEngineNamespaceResponseBodyData {
	s.NamespaceDesc = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetNamespaceShowName(v string) *CreateEngineNamespaceResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetQuota(v int32) *CreateEngineNamespaceResponseBodyData {
	s.Quota = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetServiceCount(v int32) *CreateEngineNamespaceResponseBodyData {
	s.ServiceCount = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetType(v int32) *CreateEngineNamespaceResponseBodyData {
	s.Type = &v
	return s
}

type CreateEngineNamespaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEngineNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEngineNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceResponse) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceResponse) SetHeaders(v map[string]*string) *CreateEngineNamespaceResponse {
	s.Headers = v
	return s
}

func (s *CreateEngineNamespaceResponse) SetStatusCode(v int32) *CreateEngineNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEngineNamespaceResponse) SetBody(v *CreateEngineNamespaceResponseBody) *CreateEngineNamespaceResponse {
	s.Body = v
	return s
}

type CreateFlowRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The throttling effect.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     fast failure
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     in queue
	//
	//     <!-- -->
	ControlBehavior *int32 `json:"ControlBehavior,omitempty" xml:"ControlBehavior,omitempty"`
	// Specifies whether to enable the rule.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The timeout period. Unit: milliseconds. This value is required if the ControlBehavior parameter is set to 2.
	MaxQueueingTimeMs *int32 `json:"MaxQueueingTimeMs,omitempty" xml:"MaxQueueingTimeMs,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region in which the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the API resource.
	Resource     *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceType *int32  `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The throttling threshold.
	Threshold *int32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateFlowRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateFlowRuleRequest) SetAcceptLanguage(v string) *CreateFlowRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateFlowRuleRequest) SetAppId(v string) *CreateFlowRuleRequest {
	s.AppId = &v
	return s
}

func (s *CreateFlowRuleRequest) SetAppName(v string) *CreateFlowRuleRequest {
	s.AppName = &v
	return s
}

func (s *CreateFlowRuleRequest) SetControlBehavior(v int32) *CreateFlowRuleRequest {
	s.ControlBehavior = &v
	return s
}

func (s *CreateFlowRuleRequest) SetEnable(v bool) *CreateFlowRuleRequest {
	s.Enable = &v
	return s
}

func (s *CreateFlowRuleRequest) SetMaxQueueingTimeMs(v int32) *CreateFlowRuleRequest {
	s.MaxQueueingTimeMs = &v
	return s
}

func (s *CreateFlowRuleRequest) SetNamespace(v string) *CreateFlowRuleRequest {
	s.Namespace = &v
	return s
}

func (s *CreateFlowRuleRequest) SetRegionId(v string) *CreateFlowRuleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateFlowRuleRequest) SetResource(v string) *CreateFlowRuleRequest {
	s.Resource = &v
	return s
}

func (s *CreateFlowRuleRequest) SetResourceType(v int32) *CreateFlowRuleRequest {
	s.ResourceType = &v
	return s
}

func (s *CreateFlowRuleRequest) SetThreshold(v int32) *CreateFlowRuleRequest {
	s.Threshold = &v
	return s
}

type CreateFlowRuleResponseBody struct {
	// The response code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *CreateFlowRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateFlowRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFlowRuleResponseBody) SetCode(v string) *CreateFlowRuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateFlowRuleResponseBody) SetData(v *CreateFlowRuleResponseBodyData) *CreateFlowRuleResponseBody {
	s.Data = v
	return s
}

func (s *CreateFlowRuleResponseBody) SetMessage(v string) *CreateFlowRuleResponseBody {
	s.Message = &v
	return s
}

func (s *CreateFlowRuleResponseBody) SetRequestId(v string) *CreateFlowRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFlowRuleResponseBody) SetSuccess(v bool) *CreateFlowRuleResponseBody {
	s.Success = &v
	return s
}

type CreateFlowRuleResponseBodyData struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The throttling effect.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     fast failure
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     in queue
	//
	//     <!-- -->
	ControlBehavior *int32 `json:"ControlBehavior,omitempty" xml:"ControlBehavior,omitempty"`
	// Indicates whether the rule is enabled.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period for queuing when the value of ControlBehavior is set to 2. Unit: milliseconds.
	MaxQueueingTimeMs *int32 `json:"MaxQueueingTimeMs,omitempty" xml:"MaxQueueingTimeMs,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the API resource.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The throttling threshold.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateFlowRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateFlowRuleResponseBodyData) SetAppId(v string) *CreateFlowRuleResponseBodyData {
	s.AppId = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetAppName(v string) *CreateFlowRuleResponseBodyData {
	s.AppName = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetControlBehavior(v int32) *CreateFlowRuleResponseBodyData {
	s.ControlBehavior = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetEnable(v bool) *CreateFlowRuleResponseBodyData {
	s.Enable = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetId(v int64) *CreateFlowRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetMaxQueueingTimeMs(v int32) *CreateFlowRuleResponseBodyData {
	s.MaxQueueingTimeMs = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetNamespace(v string) *CreateFlowRuleResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetRegionId(v string) *CreateFlowRuleResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetResource(v string) *CreateFlowRuleResponseBodyData {
	s.Resource = &v
	return s
}

func (s *CreateFlowRuleResponseBodyData) SetThreshold(v float32) *CreateFlowRuleResponseBodyData {
	s.Threshold = &v
	return s
}

type CreateFlowRuleResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateFlowRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFlowRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateFlowRuleResponse) SetHeaders(v map[string]*string) *CreateFlowRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateFlowRuleResponse) SetStatusCode(v int32) *CreateFlowRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFlowRuleResponse) SetBody(v *CreateFlowRuleResponseBody) *CreateFlowRuleResponse {
	s.Body = v
	return s
}

type CreateMseServiceApplicationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The edition of the MSE instance that you want to purchase.
	//
	// *   mse_pro: Professional Edition.
	// *   mse_dev: Developer Edition.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the region where the instance resides. Examples:
	//
	// *   cn-hangzhou: China (Hangzhou)
	// *   cn-beijing: China (Beijing)
	// *   cn-shanghai: China (Shanghai)
	// *   cn-zhangjiakou: China (Zhangjiakou)
	// *   cn-shenzhen: China (Shenzhen)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Specifies whether to enable the Sentinel-compatible mode.
	SentinelEnable *string `json:"SentinelEnable,omitempty" xml:"SentinelEnable,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// Specifies whether to enable switching.
	SwitchEnable *string `json:"SwitchEnable,omitempty" xml:"SwitchEnable,omitempty"`
}

func (s CreateMseServiceApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationRequest) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationRequest) SetAcceptLanguage(v string) *CreateMseServiceApplicationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetAppName(v string) *CreateMseServiceApplicationRequest {
	s.AppName = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetExtraInfo(v string) *CreateMseServiceApplicationRequest {
	s.ExtraInfo = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetLanguage(v string) *CreateMseServiceApplicationRequest {
	s.Language = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetMseVersion(v string) *CreateMseServiceApplicationRequest {
	s.MseVersion = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetRegion(v string) *CreateMseServiceApplicationRequest {
	s.Region = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetSentinelEnable(v string) *CreateMseServiceApplicationRequest {
	s.SentinelEnable = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetSource(v string) *CreateMseServiceApplicationRequest {
	s.Source = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetSwitchEnable(v string) *CreateMseServiceApplicationRequest {
	s.SwitchEnable = &v
	return s
}

type CreateMseServiceApplicationResponseBody struct {
	// The data structure.
	Data *CreateMseServiceApplicationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateMseServiceApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationResponseBody) SetData(v *CreateMseServiceApplicationResponseBodyData) *CreateMseServiceApplicationResponseBody {
	s.Data = v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetMessage(v string) *CreateMseServiceApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetRequestId(v string) *CreateMseServiceApplicationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetSuccess(v string) *CreateMseServiceApplicationResponseBody {
	s.Success = &v
	return s
}

type CreateMseServiceApplicationResponseBodyData struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The creation time.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The source type.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status. Valid values: 1: available; 2: deleted.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last modification time.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The version information.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s CreateMseServiceApplicationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationResponseBodyData) SetAppId(v string) *CreateMseServiceApplicationResponseBodyData {
	s.AppId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetAppName(v string) *CreateMseServiceApplicationResponseBodyData {
	s.AppName = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetCreateTime(v int64) *CreateMseServiceApplicationResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetExtraInfo(v string) *CreateMseServiceApplicationResponseBodyData {
	s.ExtraInfo = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetLanguage(v string) *CreateMseServiceApplicationResponseBodyData {
	s.Language = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetLicenseKey(v string) *CreateMseServiceApplicationResponseBodyData {
	s.LicenseKey = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetRegionId(v string) *CreateMseServiceApplicationResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetSource(v string) *CreateMseServiceApplicationResponseBodyData {
	s.Source = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetStatus(v int32) *CreateMseServiceApplicationResponseBodyData {
	s.Status = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetUpdateTime(v int64) *CreateMseServiceApplicationResponseBodyData {
	s.UpdateTime = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetUserId(v string) *CreateMseServiceApplicationResponseBodyData {
	s.UserId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetVersion(v string) *CreateMseServiceApplicationResponseBodyData {
	s.Version = &v
	return s
}

type CreateMseServiceApplicationResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateMseServiceApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateMseServiceApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationResponse) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationResponse) SetHeaders(v map[string]*string) *CreateMseServiceApplicationResponse {
	s.Headers = v
	return s
}

func (s *CreateMseServiceApplicationResponse) SetStatusCode(v int32) *CreateMseServiceApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateMseServiceApplicationResponse) SetBody(v *CreateMseServiceApplicationResponseBody) *CreateMseServiceApplicationResponse {
	s.Body = v
	return s
}

type CreateNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The list of IP addresses where the beta release of the configuration is performed.
	BetaIps *string `json:"BetaIps,omitempty" xml:"BetaIps,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The description of the configuration.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The tags of the configuration.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The format of the configuration. Supported formats include TEXT, JSON, and XML.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *CreateNacosConfigRequest) SetAcceptLanguage(v string) *CreateNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateNacosConfigRequest) SetAppName(v string) *CreateNacosConfigRequest {
	s.AppName = &v
	return s
}

func (s *CreateNacosConfigRequest) SetBetaIps(v string) *CreateNacosConfigRequest {
	s.BetaIps = &v
	return s
}

func (s *CreateNacosConfigRequest) SetContent(v string) *CreateNacosConfigRequest {
	s.Content = &v
	return s
}

func (s *CreateNacosConfigRequest) SetDataId(v string) *CreateNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *CreateNacosConfigRequest) SetDesc(v string) *CreateNacosConfigRequest {
	s.Desc = &v
	return s
}

func (s *CreateNacosConfigRequest) SetGroup(v string) *CreateNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *CreateNacosConfigRequest) SetInstanceId(v string) *CreateNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateNacosConfigRequest) SetNamespaceId(v string) *CreateNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *CreateNacosConfigRequest) SetTags(v string) *CreateNacosConfigRequest {
	s.Tags = &v
	return s
}

func (s *CreateNacosConfigRequest) SetType(v string) *CreateNacosConfigRequest {
	s.Type = &v
	return s
}

type CreateNacosConfigResponseBody struct {
	// The code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNacosConfigResponseBody) SetCode(v string) *CreateNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetErrorCode(v string) *CreateNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetHttpCode(v string) *CreateNacosConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetMessage(v string) *CreateNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetRequestId(v string) *CreateNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetSuccess(v bool) *CreateNacosConfigResponseBody {
	s.Success = &v
	return s
}

type CreateNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *CreateNacosConfigResponse) SetHeaders(v map[string]*string) *CreateNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *CreateNacosConfigResponse) SetStatusCode(v int32) *CreateNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNacosConfigResponse) SetBody(v *CreateNacosConfigResponseBody) *CreateNacosConfigResponse {
	s.Body = v
	return s
}

type CreateNacosInstanceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the Nacos instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Specifies whether to enable the service for the instance.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Specifies whether to mark the instance as a temporary node.
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the Nacos instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The node metadata of the instance.
	Metadata *string `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port number of the Nacos instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The weight. Valid values: 0 to 10000. The value must be an integer. A larger value indicates a higher frequency at which the instance is accessed.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateNacosInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateNacosInstanceRequest) SetAcceptLanguage(v string) *CreateNacosInstanceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetClusterName(v string) *CreateNacosInstanceRequest {
	s.ClusterName = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetEnabled(v bool) *CreateNacosInstanceRequest {
	s.Enabled = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetEphemeral(v bool) *CreateNacosInstanceRequest {
	s.Ephemeral = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetGroupName(v string) *CreateNacosInstanceRequest {
	s.GroupName = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetInstanceId(v string) *CreateNacosInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetIp(v string) *CreateNacosInstanceRequest {
	s.Ip = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetMetadata(v string) *CreateNacosInstanceRequest {
	s.Metadata = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetNamespaceId(v string) *CreateNacosInstanceRequest {
	s.NamespaceId = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetPort(v int32) *CreateNacosInstanceRequest {
	s.Port = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetServiceName(v string) *CreateNacosInstanceRequest {
	s.ServiceName = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetWeight(v string) *CreateNacosInstanceRequest {
	s.Weight = &v
	return s
}

type CreateNacosInstanceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateNacosInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNacosInstanceResponseBody) SetCode(v int32) *CreateNacosInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetData(v string) *CreateNacosInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetHttpStatusCode(v int32) *CreateNacosInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetMessage(v string) *CreateNacosInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetRequestId(v string) *CreateNacosInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetSuccess(v bool) *CreateNacosInstanceResponseBody {
	s.Success = &v
	return s
}

type CreateNacosInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNacosInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNacosInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateNacosInstanceResponse) SetHeaders(v map[string]*string) *CreateNacosInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateNacosInstanceResponse) SetStatusCode(v int32) *CreateNacosInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNacosInstanceResponse) SetBody(v *CreateNacosInstanceResponseBody) *CreateNacosInstanceResponse {
	s.Body = v
	return s
}

type CreateNacosServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Specifies whether the instance is marked as a temporary node. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The protection threshold.
	ProtectThreshold *string `json:"ProtectThreshold,omitempty" xml:"ProtectThreshold,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s CreateNacosServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosServiceRequest) GoString() string {
	return s.String()
}

func (s *CreateNacosServiceRequest) SetAcceptLanguage(v string) *CreateNacosServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateNacosServiceRequest) SetClusterId(v string) *CreateNacosServiceRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateNacosServiceRequest) SetEphemeral(v bool) *CreateNacosServiceRequest {
	s.Ephemeral = &v
	return s
}

func (s *CreateNacosServiceRequest) SetGroupName(v string) *CreateNacosServiceRequest {
	s.GroupName = &v
	return s
}

func (s *CreateNacosServiceRequest) SetInstanceId(v string) *CreateNacosServiceRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateNacosServiceRequest) SetNamespaceId(v string) *CreateNacosServiceRequest {
	s.NamespaceId = &v
	return s
}

func (s *CreateNacosServiceRequest) SetProtectThreshold(v string) *CreateNacosServiceRequest {
	s.ProtectThreshold = &v
	return s
}

func (s *CreateNacosServiceRequest) SetServiceName(v string) *CreateNacosServiceRequest {
	s.ServiceName = &v
	return s
}

type CreateNacosServiceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateNacosServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNacosServiceResponseBody) SetCode(v int32) *CreateNacosServiceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetData(v string) *CreateNacosServiceResponseBody {
	s.Data = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetHttpStatusCode(v int32) *CreateNacosServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetMessage(v string) *CreateNacosServiceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetRequestId(v string) *CreateNacosServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetSuccess(v bool) *CreateNacosServiceResponseBody {
	s.Success = &v
	return s
}

type CreateNacosServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNacosServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNacosServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosServiceResponse) GoString() string {
	return s.String()
}

func (s *CreateNacosServiceResponse) SetHeaders(v map[string]*string) *CreateNacosServiceResponse {
	s.Headers = v
	return s
}

func (s *CreateNacosServiceResponse) SetStatusCode(v int32) *CreateNacosServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNacosServiceResponse) SetBody(v *CreateNacosServiceResponseBody) *CreateNacosServiceResponse {
	s.Body = v
	return s
}

type CreateOrUpdateSwimmingLaneRequest struct {
	// The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the lane.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// Specifies whether to configure a routing rule for the lane. If an Ingress gateway is used, this parameter is not required.
	EnableRules *bool `json:"EnableRules,omitempty" xml:"EnableRules,omitempty"`
	// Deprecated
	// The JSON string.
	EntryRule  *string                                        `json:"EntryRule,omitempty" xml:"EntryRule,omitempty"`
	EntryRules []*CreateOrUpdateSwimmingLaneRequestEntryRules `json:"EntryRules,omitempty" xml:"EntryRules,omitempty" type:"Repeated"`
	// The information about the routing rule for the gateway. This parameter is required when a cloud-native gateway is used as the ingress.
	GatewaySwimmingLaneRouteJson *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson `json:"GatewaySwimmingLaneRouteJson,omitempty" xml:"GatewaySwimmingLaneRouteJson,omitempty" type:"Struct"`
	// The language of the response. Valid values:****
	//
	// *   **zh-CN**: Chinese
	// *   **en-US**: English
	//
	// > Default value: **zh-CN**.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the primary key. The value -1 indicates a request that is used to create a lane. A value greater than 0 indicates a request that is used to modify a lane.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane.
	Name      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetAcceptLanguage(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEnable(v bool) *CreateOrUpdateSwimmingLaneRequest {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEnableRules(v bool) *CreateOrUpdateSwimmingLaneRequest {
	s.EnableRules = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEntryRule(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.EntryRule = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEntryRules(v []*CreateOrUpdateSwimmingLaneRequestEntryRules) *CreateOrUpdateSwimmingLaneRequest {
	s.EntryRules = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetGatewaySwimmingLaneRouteJson(v *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) *CreateOrUpdateSwimmingLaneRequest {
	s.GatewaySwimmingLaneRouteJson = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetGroupId(v int64) *CreateOrUpdateSwimmingLaneRequest {
	s.GroupId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetId(v int64) *CreateOrUpdateSwimmingLaneRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetName(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetNamespace(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.Namespace = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetRegionId(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetTag(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.Tag = &v
	return s
}

type CreateOrUpdateSwimmingLaneRequestEntryRules struct {
	Condition *string                                                 `json:"Condition,omitempty" xml:"Condition,omitempty"`
	Paths     []*string                                               `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	Priority  *int32                                                  `json:"Priority,omitempty" xml:"Priority,omitempty"`
	RestItems []*CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems `json:"RestItems,omitempty" xml:"RestItems,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRules) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRules) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetCondition(v string) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Condition = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetPaths(v []*string) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Paths = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetPriority(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Priority = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetRestItems(v []*CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.RestItems = v
	return s
}

type CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems struct {
	Cond      *string   `json:"Cond,omitempty" xml:"Cond,omitempty"`
	Datum     *string   `json:"Datum,omitempty" xml:"Datum,omitempty"`
	Divisor   *int32    `json:"Divisor,omitempty" xml:"Divisor,omitempty"`
	Name      *string   `json:"Name,omitempty" xml:"Name,omitempty"`
	NameList  []*string `json:"NameList,omitempty" xml:"NameList,omitempty" type:"Repeated"`
	Operator  *string   `json:"Operator,omitempty" xml:"Operator,omitempty"`
	Rate      *int32    `json:"Rate,omitempty" xml:"Rate,omitempty"`
	Remainder *int32    `json:"Remainder,omitempty" xml:"Remainder,omitempty"`
	Type      *string   `json:"Type,omitempty" xml:"Type,omitempty"`
	Value     *string   `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetCond(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Cond = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetDatum(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Datum = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetDivisor(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Divisor = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetName(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetNameList(v []*string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.NameList = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetOperator(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetRate(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Rate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetRemainder(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Remainder = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetType(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Type = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetValue(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Value = &v
	return s
}

type CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson struct {
	// The matching conditions.
	Conditions []*CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions `json:"Conditions,omitempty" xml:"Conditions,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The route IDs.
	RouteIdList []*int64 `json:"RouteIdList,omitempty" xml:"RouteIdList,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetConditions(v []*CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.Conditions = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetGatewayId(v int64) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.GatewayId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetGatewayUniqueId(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.GatewayUniqueId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetRouteIdList(v []*int64) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.RouteIdList = v
	return s
}

type CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions struct {
	// The matching condition. Valid values:
	//
	// *   PRE: prefix matching
	// *   EQUAL: exact matching
	// *   ERGULAR: regular expression matching
	Cond *string `json:"Cond,omitempty" xml:"Cond,omitempty"`
	// The name of the parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the parameter. Valid values:
	//
	// *   header
	// *   param
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetCond(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Cond = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetName(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetType(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Type = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetValue(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Value = &v
	return s
}

type CreateOrUpdateSwimmingLaneShrinkRequest struct {
	// The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the lane.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// Specifies whether to configure a routing rule for the lane. If an Ingress gateway is used, this parameter is not required.
	EnableRules *bool `json:"EnableRules,omitempty" xml:"EnableRules,omitempty"`
	// Deprecated
	// The JSON string.
	EntryRule  *string                                              `json:"EntryRule,omitempty" xml:"EntryRule,omitempty"`
	EntryRules []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRules `json:"EntryRules,omitempty" xml:"EntryRules,omitempty" type:"Repeated"`
	// The information about the routing rule for the gateway. This parameter is required when a cloud-native gateway is used as the ingress.
	GatewaySwimmingLaneRouteJsonShrink *string `json:"GatewaySwimmingLaneRouteJson,omitempty" xml:"GatewaySwimmingLaneRouteJson,omitempty"`
	// The language of the response. Valid values:****
	//
	// *   **zh-CN**: Chinese
	// *   **en-US**: English
	//
	// > Default value: **zh-CN**.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the primary key. The value -1 indicates a request that is used to create a lane. A value greater than 0 indicates a request that is used to modify a lane.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane.
	Name      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetAcceptLanguage(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEnable(v bool) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEnableRules(v bool) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.EnableRules = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEntryRule(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.EntryRule = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEntryRules(v []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.EntryRules = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetGatewaySwimmingLaneRouteJsonShrink(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.GatewaySwimmingLaneRouteJsonShrink = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetGroupId(v int64) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.GroupId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetId(v int64) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetName(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetNamespace(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Namespace = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetRegionId(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetTag(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Tag = &v
	return s
}

type CreateOrUpdateSwimmingLaneShrinkRequestEntryRules struct {
	Condition *string                                                       `json:"Condition,omitempty" xml:"Condition,omitempty"`
	Paths     []*string                                                     `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	Priority  *int32                                                        `json:"Priority,omitempty" xml:"Priority,omitempty"`
	RestItems []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems `json:"RestItems,omitempty" xml:"RestItems,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetCondition(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Condition = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetPaths(v []*string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Paths = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetPriority(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Priority = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetRestItems(v []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.RestItems = v
	return s
}

type CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems struct {
	Cond      *string   `json:"Cond,omitempty" xml:"Cond,omitempty"`
	Datum     *string   `json:"Datum,omitempty" xml:"Datum,omitempty"`
	Divisor   *int32    `json:"Divisor,omitempty" xml:"Divisor,omitempty"`
	Name      *string   `json:"Name,omitempty" xml:"Name,omitempty"`
	NameList  []*string `json:"NameList,omitempty" xml:"NameList,omitempty" type:"Repeated"`
	Operator  *string   `json:"Operator,omitempty" xml:"Operator,omitempty"`
	Rate      *int32    `json:"Rate,omitempty" xml:"Rate,omitempty"`
	Remainder *int32    `json:"Remainder,omitempty" xml:"Remainder,omitempty"`
	Type      *string   `json:"Type,omitempty" xml:"Type,omitempty"`
	Value     *string   `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetCond(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Cond = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetDatum(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Datum = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetDivisor(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Divisor = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetName(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetNameList(v []*string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.NameList = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetOperator(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetRate(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Rate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetRemainder(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Remainder = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetType(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Type = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetValue(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Value = &v
	return s
}

type CreateOrUpdateSwimmingLaneResponseBody struct {
	// The status code. The value 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *CreateOrUpdateSwimmingLaneResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetCode(v int32) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetData(v *CreateOrUpdateSwimmingLaneResponseBodyData) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetErrorCode(v string) *CreateOrUpdateSwimmingLaneResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetHttpStatusCode(v int32) *CreateOrUpdateSwimmingLaneResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetMessage(v string) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetRequestId(v string) *CreateOrUpdateSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetSuccess(v bool) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Success = &v
	return s
}

type CreateOrUpdateSwimmingLaneResponseBodyData struct {
	Enable                       *bool                                                   `json:"enable,omitempty" xml:"enable,omitempty"`
	EnableRules                  *bool                                                   `json:"enableRules,omitempty" xml:"enableRules,omitempty"`
	EntryRule                    *string                                                 `json:"entryRule,omitempty" xml:"entryRule,omitempty"`
	EntryRules                   []*CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules `json:"entryRules,omitempty" xml:"entryRules,omitempty" type:"Repeated"`
	GatewaySwimmingLaneRouteJson *string                                                 `json:"gatewaySwimmingLaneRouteJson,omitempty" xml:"gatewaySwimmingLaneRouteJson,omitempty"`
	GmtCreate                    *string                                                 `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GmtModified                  *string                                                 `json:"gmtModified,omitempty" xml:"gmtModified,omitempty"`
	GroupId                      *int64                                                  `json:"groupId,omitempty" xml:"groupId,omitempty"`
	Id                           *int64                                                  `json:"id,omitempty" xml:"id,omitempty"`
	Name                         *string                                                 `json:"name,omitempty" xml:"name,omitempty"`
	RegionId                     *string                                                 `json:"regionId,omitempty" xml:"regionId,omitempty"`
	Status                       *int32                                                  `json:"status,omitempty" xml:"status,omitempty"`
	Tag                          *string                                                 `json:"tag,omitempty" xml:"tag,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetEnable(v bool) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetEnableRules(v bool) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.EnableRules = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetEntryRule(v string) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.EntryRule = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetEntryRules(v []*CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.EntryRules = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetGatewaySwimmingLaneRouteJson(v string) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.GatewaySwimmingLaneRouteJson = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetGmtCreate(v string) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetGmtModified(v string) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetGroupId(v int64) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetId(v int64) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetName(v string) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetRegionId(v string) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetStatus(v int32) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.Status = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyData) SetTag(v string) *CreateOrUpdateSwimmingLaneResponseBodyData {
	s.Tag = &v
	return s
}

type CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules struct {
	Condition *string                                                          `json:"condition,omitempty" xml:"condition,omitempty"`
	Path      *string                                                          `json:"path,omitempty" xml:"path,omitempty"`
	Paths     []*string                                                        `json:"paths,omitempty" xml:"paths,omitempty" type:"Repeated"`
	RestItems []*CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems `json:"restItems,omitempty" xml:"restItems,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules) SetCondition(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules {
	s.Condition = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules) SetPath(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules {
	s.Path = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules) SetPaths(v []*string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules {
	s.Paths = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules) SetRestItems(v []*CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRules {
	s.RestItems = v
	return s
}

type CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems struct {
	Cond      *string   `json:"cond,omitempty" xml:"cond,omitempty"`
	Datum     *string   `json:"datum,omitempty" xml:"datum,omitempty"`
	Divisor   *int32    `json:"divisor,omitempty" xml:"divisor,omitempty"`
	Name      *string   `json:"name,omitempty" xml:"name,omitempty"`
	NameList  []*string `json:"nameList,omitempty" xml:"nameList,omitempty" type:"Repeated"`
	Operator  *string   `json:"operator,omitempty" xml:"operator,omitempty"`
	Rate      *int32    `json:"rate,omitempty" xml:"rate,omitempty"`
	Remainder *int32    `json:"remainder,omitempty" xml:"remainder,omitempty"`
	Type      *string   `json:"type,omitempty" xml:"type,omitempty"`
	Value     *string   `json:"value,omitempty" xml:"value,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetCond(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Cond = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetDatum(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Datum = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetDivisor(v int32) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Divisor = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetName(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetNameList(v []*string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.NameList = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetOperator(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetRate(v int32) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Rate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetRemainder(v int32) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Remainder = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetType(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Type = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems) SetValue(v string) *CreateOrUpdateSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Value = &v
	return s
}

type CreateOrUpdateSwimmingLaneResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneResponse) SetHeaders(v map[string]*string) *CreateOrUpdateSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponse) SetStatusCode(v int32) *CreateOrUpdateSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponse) SetBody(v *CreateOrUpdateSwimmingLaneResponseBody) *CreateOrUpdateSwimmingLaneResponse {
	s.Body = v
	return s
}

type CreateOrUpdateSwimmingLaneGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The IDs of applications. Separate application IDs with commas (,).
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	// Specifies whether to enable database canary release.
	DbGrayEnable *bool `json:"DbGrayEnable,omitempty" xml:"DbGrayEnable,omitempty"`
	// The ingress application.
	EntryApp *string `json:"EntryApp,omitempty" xml:"EntryApp,omitempty"`
	// The ID of the lane group. A value of -1 is used to create a lane group. A value greater than 0 is used to modify the specified lane group.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	MessageQueueFilterSide *string `json:"MessageQueueFilterSide,omitempty" xml:"MessageQueueFilterSide,omitempty"`
	// Specifies whether to enable canary release for messaging.
	MessageQueueGrayEnable *bool `json:"MessageQueueGrayEnable,omitempty" xml:"MessageQueueGrayEnable,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the Microservices Engine (MSE) namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Specifies whether to record request details.
	RecordCanaryDetail *bool `json:"RecordCanaryDetail,omitempty" xml:"RecordCanaryDetail,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The status of the lane group. The value 0 specifies that the lane group is disabled. The value 1 specifies that the lane group is enabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetAcceptLanguage(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetAppIds(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.AppIds = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetDbGrayEnable(v bool) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.DbGrayEnable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetEntryApp(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.EntryApp = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetId(v int64) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetMessageQueueFilterSide(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.MessageQueueFilterSide = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetMessageQueueGrayEnable(v bool) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.MessageQueueGrayEnable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetName(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetNamespace(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Namespace = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetRecordCanaryDetail(v bool) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.RecordCanaryDetail = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetRegion(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Region = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetStatus(v int32) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Status = &v
	return s
}

type CreateOrUpdateSwimmingLaneGroupResponseBody struct {
	// The response parameters.
	Data *CreateOrUpdateSwimmingLaneGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful. false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetData(v *CreateOrUpdateSwimmingLaneGroupResponseBodyData) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetErrorCode(v string) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetMessage(v string) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetRequestId(v string) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetSuccess(v bool) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.Success = &v
	return s
}

type CreateOrUpdateSwimmingLaneGroupResponseBodyData struct {
	AppIds                 *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	DbGrayEnable           *string `json:"DbGrayEnable,omitempty" xml:"DbGrayEnable,omitempty"`
	EntryApp               *string `json:"EntryApp,omitempty" xml:"EntryApp,omitempty"`
	Id                     *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	MessageQueueFilterSide *string `json:"MessageQueueFilterSide,omitempty" xml:"MessageQueueFilterSide,omitempty"`
	MessageQueueGrayEnable *bool   `json:"MessageQueueGrayEnable,omitempty" xml:"MessageQueueGrayEnable,omitempty"`
	Name                   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace              *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	RecordCanaryDetail     *bool   `json:"RecordCanaryDetail,omitempty" xml:"RecordCanaryDetail,omitempty"`
	Region                 *string `json:"Region,omitempty" xml:"Region,omitempty"`
	UserId                 *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetAppIds(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.AppIds = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetDbGrayEnable(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.DbGrayEnable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetEntryApp(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.EntryApp = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetId(v int64) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetMessageQueueFilterSide(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.MessageQueueFilterSide = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetMessageQueueGrayEnable(v bool) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.MessageQueueGrayEnable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetName(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetNamespace(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetRecordCanaryDetail(v bool) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.RecordCanaryDetail = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetRegion(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.Region = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBodyData) SetUserId(v string) *CreateOrUpdateSwimmingLaneGroupResponseBodyData {
	s.UserId = &v
	return s
}

type CreateOrUpdateSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *CreateOrUpdateSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponse) SetStatusCode(v int32) *CreateOrUpdateSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponse) SetBody(v *CreateOrUpdateSwimmingLaneGroupResponseBody) *CreateOrUpdateSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type CreateZnodeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s CreateZnodeRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeRequest) GoString() string {
	return s.String()
}

func (s *CreateZnodeRequest) SetAcceptLanguage(v string) *CreateZnodeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateZnodeRequest) SetClusterId(v string) *CreateZnodeRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateZnodeRequest) SetData(v string) *CreateZnodeRequest {
	s.Data = &v
	return s
}

func (s *CreateZnodeRequest) SetPath(v string) *CreateZnodeRequest {
	s.Path = &v
	return s
}

type CreateZnodeResponseBody struct {
	// The details of the data.
	Data *CreateZnodeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateZnodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeResponseBody) GoString() string {
	return s.String()
}

func (s *CreateZnodeResponseBody) SetData(v *CreateZnodeResponseBodyData) *CreateZnodeResponseBody {
	s.Data = v
	return s
}

func (s *CreateZnodeResponseBody) SetErrorCode(v string) *CreateZnodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateZnodeResponseBody) SetHttpCode(v string) *CreateZnodeResponseBody {
	s.HttpCode = &v
	return s
}

func (s *CreateZnodeResponseBody) SetMessage(v string) *CreateZnodeResponseBody {
	s.Message = &v
	return s
}

func (s *CreateZnodeResponseBody) SetRequestId(v string) *CreateZnodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateZnodeResponseBody) SetSuccess(v bool) *CreateZnodeResponseBody {
	s.Success = &v
	return s
}

type CreateZnodeResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s CreateZnodeResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateZnodeResponseBodyData) SetData(v string) *CreateZnodeResponseBodyData {
	s.Data = &v
	return s
}

func (s *CreateZnodeResponseBodyData) SetDir(v bool) *CreateZnodeResponseBodyData {
	s.Dir = &v
	return s
}

func (s *CreateZnodeResponseBodyData) SetName(v string) *CreateZnodeResponseBodyData {
	s.Name = &v
	return s
}

func (s *CreateZnodeResponseBodyData) SetPath(v string) *CreateZnodeResponseBodyData {
	s.Path = &v
	return s
}

type CreateZnodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateZnodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateZnodeResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeResponse) GoString() string {
	return s.String()
}

func (s *CreateZnodeResponse) SetHeaders(v map[string]*string) *CreateZnodeResponse {
	s.Headers = v
	return s
}

func (s *CreateZnodeResponse) SetStatusCode(v int32) *CreateZnodeResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateZnodeResponse) SetBody(v *CreateZnodeResponseBody) *CreateZnodeResponse {
	s.Body = v
	return s
}

type DeleteAuthResourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The destination ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteAuthResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceRequest) SetAcceptLanguage(v string) *DeleteAuthResourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteAuthResourceRequest) SetGatewayUniqueId(v string) *DeleteAuthResourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteAuthResourceRequest) SetId(v int64) *DeleteAuthResourceRequest {
	s.Id = &v
	return s
}

type DeleteAuthResourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteAuthResourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAuthResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceResponseBody) SetCode(v int32) *DeleteAuthResourceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetData(v *DeleteAuthResourceResponseBodyData) *DeleteAuthResourceResponseBody {
	s.Data = v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetHttpStatusCode(v int32) *DeleteAuthResourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetMessage(v string) *DeleteAuthResourceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetRequestId(v string) *DeleteAuthResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetSuccess(v bool) *DeleteAuthResourceResponseBody {
	s.Success = &v
	return s
}

type DeleteAuthResourceResponseBodyData struct {
	// The authentication ID.
	AuthId *int64 `json:"AuthId,omitempty" xml:"AuthId,omitempty"`
	// The ID of the domain name.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the primary key.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the whitelist mode is enabled.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DeleteAuthResourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceResponseBodyData) SetAuthId(v int64) *DeleteAuthResourceResponseBodyData {
	s.AuthId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetDomainId(v int64) *DeleteAuthResourceResponseBodyData {
	s.DomainId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetDomainName(v string) *DeleteAuthResourceResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGatewayId(v int64) *DeleteAuthResourceResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGatewayUniqueId(v string) *DeleteAuthResourceResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGmtCreate(v string) *DeleteAuthResourceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGmtModified(v string) *DeleteAuthResourceResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetId(v int64) *DeleteAuthResourceResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetIsWhite(v bool) *DeleteAuthResourceResponseBodyData {
	s.IsWhite = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetPath(v string) *DeleteAuthResourceResponseBodyData {
	s.Path = &v
	return s
}

type DeleteAuthResourceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAuthResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAuthResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceResponse) SetHeaders(v map[string]*string) *DeleteAuthResourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteAuthResourceResponse) SetStatusCode(v int32) *DeleteAuthResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAuthResourceResponse) SetBody(v *DeleteAuthResourceResponseBody) *DeleteAuthResourceResponse {
	s.Body = v
	return s
}

type DeleteCircuitBreakerRulesRequest struct {
	// The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The IDs of the rules that you want to delete.
	Ids []*int64 `json:"Ids,omitempty" xml:"Ids,omitempty" type:"Repeated"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteCircuitBreakerRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCircuitBreakerRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteCircuitBreakerRulesRequest) SetAcceptLanguage(v string) *DeleteCircuitBreakerRulesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteCircuitBreakerRulesRequest) SetAppName(v string) *DeleteCircuitBreakerRulesRequest {
	s.AppName = &v
	return s
}

func (s *DeleteCircuitBreakerRulesRequest) SetIds(v []*int64) *DeleteCircuitBreakerRulesRequest {
	s.Ids = v
	return s
}

func (s *DeleteCircuitBreakerRulesRequest) SetNamespace(v string) *DeleteCircuitBreakerRulesRequest {
	s.Namespace = &v
	return s
}

type DeleteCircuitBreakerRulesShrinkRequest struct {
	// The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The IDs of the rules that you want to delete.
	IdsShrink *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteCircuitBreakerRulesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCircuitBreakerRulesShrinkRequest) GoString() string {
	return s.String()
}

func (s *DeleteCircuitBreakerRulesShrinkRequest) SetAcceptLanguage(v string) *DeleteCircuitBreakerRulesShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteCircuitBreakerRulesShrinkRequest) SetAppName(v string) *DeleteCircuitBreakerRulesShrinkRequest {
	s.AppName = &v
	return s
}

func (s *DeleteCircuitBreakerRulesShrinkRequest) SetIdsShrink(v string) *DeleteCircuitBreakerRulesShrinkRequest {
	s.IdsShrink = &v
	return s
}

func (s *DeleteCircuitBreakerRulesShrinkRequest) SetNamespace(v string) *DeleteCircuitBreakerRulesShrinkRequest {
	s.Namespace = &v
	return s
}

type DeleteCircuitBreakerRulesResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The IDs of the rules that were deleted.
	Data []*int64 `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteCircuitBreakerRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCircuitBreakerRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCircuitBreakerRulesResponseBody) SetCode(v int32) *DeleteCircuitBreakerRulesResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteCircuitBreakerRulesResponseBody) SetData(v []*int64) *DeleteCircuitBreakerRulesResponseBody {
	s.Data = v
	return s
}

func (s *DeleteCircuitBreakerRulesResponseBody) SetHttpStatusCode(v int32) *DeleteCircuitBreakerRulesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteCircuitBreakerRulesResponseBody) SetMessage(v string) *DeleteCircuitBreakerRulesResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteCircuitBreakerRulesResponseBody) SetRequestId(v string) *DeleteCircuitBreakerRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteCircuitBreakerRulesResponseBody) SetSuccess(v bool) *DeleteCircuitBreakerRulesResponseBody {
	s.Success = &v
	return s
}

type DeleteCircuitBreakerRulesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCircuitBreakerRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCircuitBreakerRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCircuitBreakerRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteCircuitBreakerRulesResponse) SetHeaders(v map[string]*string) *DeleteCircuitBreakerRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteCircuitBreakerRulesResponse) SetStatusCode(v int32) *DeleteCircuitBreakerRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCircuitBreakerRulesResponse) SetBody(v *DeleteCircuitBreakerRulesResponseBody) *DeleteCircuitBreakerRulesResponse {
	s.Body = v
	return s
}

type DeleteClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DeleteClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterRequest) GoString() string {
	return s.String()
}

func (s *DeleteClusterRequest) SetAcceptLanguage(v string) *DeleteClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteClusterRequest) SetInstanceId(v string) *DeleteClusterRequest {
	s.InstanceId = &v
	return s
}

type DeleteClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteClusterResponseBody) SetErrorCode(v string) *DeleteClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteClusterResponseBody) SetHttpCode(v string) *DeleteClusterResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteClusterResponseBody) SetMessage(v string) *DeleteClusterResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteClusterResponseBody) SetRequestId(v string) *DeleteClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteClusterResponseBody) SetSuccess(v bool) *DeleteClusterResponseBody {
	s.Success = &v
	return s
}

type DeleteClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterResponse) GoString() string {
	return s.String()
}

func (s *DeleteClusterResponse) SetHeaders(v map[string]*string) *DeleteClusterResponse {
	s.Headers = v
	return s
}

func (s *DeleteClusterResponse) SetStatusCode(v int32) *DeleteClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteClusterResponse) SetBody(v *DeleteClusterResponseBody) *DeleteClusterResponse {
	s.Body = v
	return s
}

type DeleteEngineNamespaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the namespace.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DeleteEngineNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEngineNamespaceRequest) GoString() string {
	return s.String()
}

func (s *DeleteEngineNamespaceRequest) SetAcceptLanguage(v string) *DeleteEngineNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteEngineNamespaceRequest) SetClusterId(v string) *DeleteEngineNamespaceRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteEngineNamespaceRequest) SetId(v string) *DeleteEngineNamespaceRequest {
	s.Id = &v
	return s
}

func (s *DeleteEngineNamespaceRequest) SetInstanceId(v string) *DeleteEngineNamespaceRequest {
	s.InstanceId = &v
	return s
}

type DeleteEngineNamespaceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteEngineNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEngineNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEngineNamespaceResponseBody) SetErrorCode(v string) *DeleteEngineNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetHttpCode(v string) *DeleteEngineNamespaceResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetMessage(v string) *DeleteEngineNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetRequestId(v string) *DeleteEngineNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetSuccess(v bool) *DeleteEngineNamespaceResponseBody {
	s.Success = &v
	return s
}

type DeleteEngineNamespaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEngineNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEngineNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEngineNamespaceResponse) GoString() string {
	return s.String()
}

func (s *DeleteEngineNamespaceResponse) SetHeaders(v map[string]*string) *DeleteEngineNamespaceResponse {
	s.Headers = v
	return s
}

func (s *DeleteEngineNamespaceResponse) SetStatusCode(v int32) *DeleteEngineNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEngineNamespaceResponse) SetBody(v *DeleteEngineNamespaceResponseBody) *DeleteEngineNamespaceResponse {
	s.Body = v
	return s
}

type DeleteFlowRulesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The IDs of the rules to be deleted.
	Ids []*int64 `json:"Ids,omitempty" xml:"Ids,omitempty" type:"Repeated"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteFlowRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteFlowRulesRequest) SetAcceptLanguage(v string) *DeleteFlowRulesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteFlowRulesRequest) SetAppName(v string) *DeleteFlowRulesRequest {
	s.AppName = &v
	return s
}

func (s *DeleteFlowRulesRequest) SetIds(v []*int64) *DeleteFlowRulesRequest {
	s.Ids = v
	return s
}

func (s *DeleteFlowRulesRequest) SetNamespace(v string) *DeleteFlowRulesRequest {
	s.Namespace = &v
	return s
}

type DeleteFlowRulesShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The IDs of the rules to be deleted.
	IdsShrink *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteFlowRulesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowRulesShrinkRequest) GoString() string {
	return s.String()
}

func (s *DeleteFlowRulesShrinkRequest) SetAcceptLanguage(v string) *DeleteFlowRulesShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteFlowRulesShrinkRequest) SetAppName(v string) *DeleteFlowRulesShrinkRequest {
	s.AppName = &v
	return s
}

func (s *DeleteFlowRulesShrinkRequest) SetIdsShrink(v string) *DeleteFlowRulesShrinkRequest {
	s.IdsShrink = &v
	return s
}

func (s *DeleteFlowRulesShrinkRequest) SetNamespace(v string) *DeleteFlowRulesShrinkRequest {
	s.Namespace = &v
	return s
}

type DeleteFlowRulesResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The IDs of the rules that were deleted.
	Data []*int64 `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteFlowRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFlowRulesResponseBody) SetCode(v int32) *DeleteFlowRulesResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteFlowRulesResponseBody) SetData(v []*int64) *DeleteFlowRulesResponseBody {
	s.Data = v
	return s
}

func (s *DeleteFlowRulesResponseBody) SetHttpStatusCode(v int32) *DeleteFlowRulesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteFlowRulesResponseBody) SetMessage(v string) *DeleteFlowRulesResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteFlowRulesResponseBody) SetRequestId(v string) *DeleteFlowRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFlowRulesResponseBody) SetSuccess(v bool) *DeleteFlowRulesResponseBody {
	s.Success = &v
	return s
}

type DeleteFlowRulesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteFlowRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteFlowRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteFlowRulesResponse) SetHeaders(v map[string]*string) *DeleteFlowRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteFlowRulesResponse) SetStatusCode(v int32) *DeleteFlowRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFlowRulesResponse) SetBody(v *DeleteFlowRulesResponseBody) *DeleteFlowRulesResponse {
	s.Body = v
	return s
}

type DeleteGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to delete the SLB instance purchased for the gateway when you delete the gateway.
	DeleteSlb *bool `json:"DeleteSlb,omitempty" xml:"DeleteSlb,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s DeleteGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRequest) SetAcceptLanguage(v string) *DeleteGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayRequest) SetDeleteSlb(v bool) *DeleteGatewayRequest {
	s.DeleteSlb = &v
	return s
}

func (s *DeleteGatewayRequest) SetGatewayUniqueId(v string) *DeleteGatewayRequest {
	s.GatewayUniqueId = &v
	return s
}

type DeleteGatewayResponseBody struct {
	// The HTTP status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *DeleteGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayResponseBody) SetCode(v int32) *DeleteGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetData(v *DeleteGatewayResponseBodyData) *DeleteGatewayResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetMessage(v string) *DeleteGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetRequestId(v string) *DeleteGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetSuccess(v bool) *DeleteGatewayResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayResponseBodyData struct {
	// The unique ID of the gateway. The ID is automatically generated by the system.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the gateway was last updated.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the primary key.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The information about the user.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of gateway replicas.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The ID of the security group.
	SecurityGroup *string `json:"SecurityGroup,omitempty" xml:"SecurityGroup,omitempty"`
	// The specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the gateway. Valid values: 0: The gateway is being created. 1: The gateway fails to be created. 2: The gateway is running. 3: The gateway is changing. 4: The gateway is scaling down. 6: The gateway is scaling up. 8: The gateway is being deleted. 10: The gateway is restarting. 11: The gateway is being rebuilt. 12: The gateway is updating. 13: The gateway fails to be updated.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the virtual private cloud (VPC) where the gateway resides.
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
	// The ID of the vSwitch.
	Vswitch *string `json:"Vswitch,omitempty" xml:"Vswitch,omitempty"`
}

func (s DeleteGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetGmtCreate(v string) *DeleteGatewayResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetGmtModified(v string) *DeleteGatewayResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetId(v int64) *DeleteGatewayResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetName(v string) *DeleteGatewayResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetPrimaryUser(v string) *DeleteGatewayResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetRegion(v string) *DeleteGatewayResponseBodyData {
	s.Region = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetReplica(v int32) *DeleteGatewayResponseBodyData {
	s.Replica = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetSecurityGroup(v string) *DeleteGatewayResponseBodyData {
	s.SecurityGroup = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetSpec(v string) *DeleteGatewayResponseBodyData {
	s.Spec = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetStatus(v int32) *DeleteGatewayResponseBodyData {
	s.Status = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetVpc(v string) *DeleteGatewayResponseBodyData {
	s.Vpc = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetVswitch(v string) *DeleteGatewayResponseBodyData {
	s.Vswitch = &v
	return s
}

type DeleteGatewayResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayResponse) SetHeaders(v map[string]*string) *DeleteGatewayResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayResponse) SetStatusCode(v int32) *DeleteGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayResponse) SetBody(v *DeleteGatewayResponseBody) *DeleteGatewayResponse {
	s.Body = v
	return s
}

type DeleteGatewayAuthConsumerRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the consumer on which the gateway performs authentication operations.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteGatewayAuthConsumerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayAuthConsumerRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayAuthConsumerRequest) SetAcceptLanguage(v string) *DeleteGatewayAuthConsumerRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayAuthConsumerRequest) SetGatewayUniqueId(v string) *DeleteGatewayAuthConsumerRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayAuthConsumerRequest) SetId(v int64) *DeleteGatewayAuthConsumerRequest {
	s.Id = &v
	return s
}

type DeleteGatewayAuthConsumerResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the execution was successful. Valid values:
	//
	// *   true: The execution was successful.
	// *   false: The execution failed.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayAuthConsumerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayAuthConsumerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetCode(v int32) *DeleteGatewayAuthConsumerResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetData(v bool) *DeleteGatewayAuthConsumerResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetDynamicCode(v string) *DeleteGatewayAuthConsumerResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetDynamicMessage(v string) *DeleteGatewayAuthConsumerResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetErrorCode(v string) *DeleteGatewayAuthConsumerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayAuthConsumerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetMessage(v string) *DeleteGatewayAuthConsumerResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetRequestId(v string) *DeleteGatewayAuthConsumerResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponseBody) SetSuccess(v bool) *DeleteGatewayAuthConsumerResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayAuthConsumerResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayAuthConsumerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayAuthConsumerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayAuthConsumerResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayAuthConsumerResponse) SetHeaders(v map[string]*string) *DeleteGatewayAuthConsumerResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayAuthConsumerResponse) SetStatusCode(v int32) *DeleteGatewayAuthConsumerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResponse) SetBody(v *DeleteGatewayAuthConsumerResponseBody) *DeleteGatewayAuthConsumerResponse {
	s.Body = v
	return s
}

type DeleteGatewayAuthConsumerResourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The consumer ID.
	ConsumerId *int64 `json:"ConsumerId,omitempty" xml:"ConsumerId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The IDs of the authorized resources that you want to delete.
	IdList *string `json:"IdList,omitempty" xml:"IdList,omitempty"`
}

func (s DeleteGatewayAuthConsumerResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayAuthConsumerResourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayAuthConsumerResourceRequest) SetAcceptLanguage(v string) *DeleteGatewayAuthConsumerResourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceRequest) SetConsumerId(v int64) *DeleteGatewayAuthConsumerResourceRequest {
	s.ConsumerId = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceRequest) SetGatewayUniqueId(v string) *DeleteGatewayAuthConsumerResourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceRequest) SetIdList(v string) *DeleteGatewayAuthConsumerResourceRequest {
	s.IdList = &v
	return s
}

type DeleteGatewayAuthConsumerResourceResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayAuthConsumerResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayAuthConsumerResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetCode(v int32) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetData(v bool) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetDynamicCode(v string) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetDynamicMessage(v string) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetErrorCode(v string) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetMessage(v string) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetRequestId(v string) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponseBody) SetSuccess(v bool) *DeleteGatewayAuthConsumerResourceResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayAuthConsumerResourceResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayAuthConsumerResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayAuthConsumerResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayAuthConsumerResourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayAuthConsumerResourceResponse) SetHeaders(v map[string]*string) *DeleteGatewayAuthConsumerResourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponse) SetStatusCode(v int32) *DeleteGatewayAuthConsumerResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayAuthConsumerResourceResponse) SetBody(v *DeleteGatewayAuthConsumerResourceResponseBody) *DeleteGatewayAuthConsumerResourceResponse {
	s.Body = v
	return s
}

type DeleteGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The domain ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainRequest) SetAcceptLanguage(v string) *DeleteGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayDomainRequest) SetGatewayUniqueId(v string) *DeleteGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayDomainRequest) SetId(v string) *DeleteGatewayDomainRequest {
	s.Id = &v
	return s
}

type DeleteGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteGatewayDomainResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainResponseBody) SetCode(v int32) *DeleteGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetData(v *DeleteGatewayDomainResponseBodyData) *DeleteGatewayDomainResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetMessage(v string) *DeleteGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetRequestId(v string) *DeleteGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetSuccess(v bool) *DeleteGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayDomainResponseBodyData struct {
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the domain name was added.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The domain ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether HTTP probing is allowed.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DeleteGatewayDomainResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainResponseBodyData) SetCertIdentifier(v string) *DeleteGatewayDomainResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGatewayId(v int64) *DeleteGatewayDomainResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayDomainResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGmtCreate(v string) *DeleteGatewayDomainResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGmtModified(v string) *DeleteGatewayDomainResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetId(v int64) *DeleteGatewayDomainResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetMustHttps(v bool) *DeleteGatewayDomainResponseBodyData {
	s.MustHttps = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetName(v string) *DeleteGatewayDomainResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetProtocol(v string) *DeleteGatewayDomainResponseBodyData {
	s.Protocol = &v
	return s
}

type DeleteGatewayDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainResponse) SetHeaders(v map[string]*string) *DeleteGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayDomainResponse) SetStatusCode(v int32) *DeleteGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayDomainResponse) SetBody(v *DeleteGatewayDomainResponseBody) *DeleteGatewayDomainResponse {
	s.Body = v
	return s
}

type DeleteGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *string `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s DeleteGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteRequest) SetAcceptLanguage(v string) *DeleteGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayRouteRequest) SetGatewayUniqueId(v string) *DeleteGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayRouteRequest) SetRouteId(v string) *DeleteGatewayRouteRequest {
	s.RouteId = &v
	return s
}

type DeleteGatewayRouteResponseBody struct {
	// The HTTP status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *DeleteGatewayRouteResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteResponseBody) SetCode(v int32) *DeleteGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetData(v *DeleteGatewayRouteResponseBodyData) *DeleteGatewayRouteResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetMessage(v string) *DeleteGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetRequestId(v string) *DeleteGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetSuccess(v bool) *DeleteGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayRouteResponseBodyData struct {
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rules.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The status of the route. Valid values:
	//
	// *   0: unpublished
	// *   2: publishing
	// *   3: published
	// *   4: editing (updated but not published)
	// *   5: unpublishing
	// *   6: unavailable
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DeleteGatewayRouteResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteResponseBodyData) SetDefaultServiceId(v int64) *DeleteGatewayRouteResponseBodyData {
	s.DefaultServiceId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGatewayId(v int64) *DeleteGatewayRouteResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayRouteResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGmtCreate(v string) *DeleteGatewayRouteResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGmtModified(v string) *DeleteGatewayRouteResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetId(v int64) *DeleteGatewayRouteResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetName(v string) *DeleteGatewayRouteResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetPredicates(v string) *DeleteGatewayRouteResponseBodyData {
	s.Predicates = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetRouteOrder(v int32) *DeleteGatewayRouteResponseBodyData {
	s.RouteOrder = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetStatus(v int32) *DeleteGatewayRouteResponseBodyData {
	s.Status = &v
	return s
}

type DeleteGatewayRouteResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteResponse) SetHeaders(v map[string]*string) *DeleteGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayRouteResponse) SetStatusCode(v int32) *DeleteGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayRouteResponse) SetBody(v *DeleteGatewayRouteResponseBody) *DeleteGatewayRouteResponse {
	s.Body = v
	return s
}

type DeleteGatewayServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s DeleteGatewayServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceRequest) SetAcceptLanguage(v string) *DeleteGatewayServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayServiceRequest) SetGatewayId(v int64) *DeleteGatewayServiceRequest {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayServiceRequest) SetGatewayUniqueId(v string) *DeleteGatewayServiceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayServiceRequest) SetServiceId(v string) *DeleteGatewayServiceRequest {
	s.ServiceId = &v
	return s
}

type DeleteGatewayServiceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteGatewayServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The unique ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceResponseBody) SetCode(v int32) *DeleteGatewayServiceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetData(v *DeleteGatewayServiceResponseBodyData) *DeleteGatewayServiceResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetMessage(v string) *DeleteGatewayServiceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetRequestId(v string) *DeleteGatewayServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetSuccess(v bool) *DeleteGatewayServiceResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayServiceResponseBodyData struct {
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the service was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the service.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// IP
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The basic information about the service.
	MetaInfo *string `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the service registered with the service registry.
	ServiceNameInRegistry *string `json:"ServiceNameInRegistry,omitempty" xml:"ServiceNameInRegistry,omitempty"`
	// The ID of the service source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The source type of the service.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s DeleteGatewayServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceResponseBodyData) SetGatewayId(v int64) *DeleteGatewayServiceResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayServiceResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGmtCreate(v string) *DeleteGatewayServiceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGmtModified(v string) *DeleteGatewayServiceResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGroupName(v string) *DeleteGatewayServiceResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetId(v int64) *DeleteGatewayServiceResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetIps(v []*string) *DeleteGatewayServiceResponseBodyData {
	s.Ips = v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetMetaInfo(v string) *DeleteGatewayServiceResponseBodyData {
	s.MetaInfo = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetName(v string) *DeleteGatewayServiceResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetNamespace(v string) *DeleteGatewayServiceResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetServiceNameInRegistry(v string) *DeleteGatewayServiceResponseBodyData {
	s.ServiceNameInRegistry = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetSourceId(v int64) *DeleteGatewayServiceResponseBodyData {
	s.SourceId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetSourceType(v string) *DeleteGatewayServiceResponseBodyData {
	s.SourceType = &v
	return s
}

type DeleteGatewayServiceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceResponse) SetHeaders(v map[string]*string) *DeleteGatewayServiceResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayServiceResponse) SetStatusCode(v int32) *DeleteGatewayServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayServiceResponse) SetBody(v *DeleteGatewayServiceResponseBody) *DeleteGatewayServiceResponse {
	s.Body = v
	return s
}

type DeleteGatewayServiceVersionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty"`
}

func (s DeleteGatewayServiceVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceVersionRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceVersionRequest) SetAcceptLanguage(v string) *DeleteGatewayServiceVersionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayServiceVersionRequest) SetGatewayUniqueId(v string) *DeleteGatewayServiceVersionRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayServiceVersionRequest) SetServiceId(v int64) *DeleteGatewayServiceVersionRequest {
	s.ServiceId = &v
	return s
}

func (s *DeleteGatewayServiceVersionRequest) SetServiceVersion(v string) *DeleteGatewayServiceVersionRequest {
	s.ServiceVersion = &v
	return s
}

type DeleteGatewayServiceVersionResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayServiceVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceVersionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceVersionResponseBody) SetCode(v int32) *DeleteGatewayServiceVersionResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetData(v int64) *DeleteGatewayServiceVersionResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayServiceVersionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetMessage(v string) *DeleteGatewayServiceVersionResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetRequestId(v string) *DeleteGatewayServiceVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetSuccess(v bool) *DeleteGatewayServiceVersionResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayServiceVersionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayServiceVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayServiceVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceVersionResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceVersionResponse) SetHeaders(v map[string]*string) *DeleteGatewayServiceVersionResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayServiceVersionResponse) SetStatusCode(v int32) *DeleteGatewayServiceVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponse) SetBody(v *DeleteGatewayServiceVersionResponseBody) *DeleteGatewayServiceVersionResponse {
	s.Body = v
	return s
}

type DeleteGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to delete the SLB instance purchased for the gateway when you delete the gateway.
	DeleteSlb *bool `json:"DeleteSlb,omitempty" xml:"DeleteSlb,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the association record.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the SLB instance that needs to be deleted.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
}

func (s DeleteGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewaySlbRequest) SetAcceptLanguage(v string) *DeleteGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewaySlbRequest) SetDeleteSlb(v bool) *DeleteGatewaySlbRequest {
	s.DeleteSlb = &v
	return s
}

func (s *DeleteGatewaySlbRequest) SetGatewayUniqueId(v string) *DeleteGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewaySlbRequest) SetId(v string) *DeleteGatewaySlbRequest {
	s.Id = &v
	return s
}

func (s *DeleteGatewaySlbRequest) SetSlbId(v string) *DeleteGatewaySlbRequest {
	s.SlbId = &v
	return s
}

type DeleteGatewaySlbResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The deletion result.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewaySlbResponseBody) SetCode(v int32) *DeleteGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetData(v string) *DeleteGatewaySlbResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetHttpStatusCode(v int32) *DeleteGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetMessage(v string) *DeleteGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetRequestId(v string) *DeleteGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetSuccess(v bool) *DeleteGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewaySlbResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewaySlbResponse) SetHeaders(v map[string]*string) *DeleteGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewaySlbResponse) SetStatusCode(v int32) *DeleteGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewaySlbResponse) SetBody(v *DeleteGatewaySlbResponseBody) *DeleteGatewaySlbResponse {
	s.Body = v
	return s
}

type DeleteMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s DeleteMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteMigrationTaskRequest) SetAcceptLanguage(v string) *DeleteMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteMigrationTaskRequest) SetId(v string) *DeleteMigrationTaskRequest {
	s.Id = &v
	return s
}

func (s *DeleteMigrationTaskRequest) SetRequestPars(v string) *DeleteMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

type DeleteMigrationTaskResponseBody struct {
	// The deletion result.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMigrationTaskResponseBody) SetData(v bool) *DeleteMigrationTaskResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetErrorCode(v string) *DeleteMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetHttpCode(v string) *DeleteMigrationTaskResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetMessage(v string) *DeleteMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetRequestId(v string) *DeleteMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetSuccess(v bool) *DeleteMigrationTaskResponseBody {
	s.Success = &v
	return s
}

type DeleteMigrationTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteMigrationTaskResponse) SetHeaders(v map[string]*string) *DeleteMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteMigrationTaskResponse) SetStatusCode(v int32) *DeleteMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMigrationTaskResponse) SetBody(v *DeleteMigrationTaskResponseBody) *DeleteMigrationTaskResponse {
	s.Body = v
	return s
}

type DeleteNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The error code returned if the request failed.
	Beta *bool `json:"Beta,omitempty" xml:"Beta,omitempty"`
	// The ID of the request.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The message returned.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The HTTP status code.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The request is successfully processed.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s DeleteNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigRequest) SetAcceptLanguage(v string) *DeleteNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetBeta(v bool) *DeleteNacosConfigRequest {
	s.Beta = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetDataId(v string) *DeleteNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetGroup(v string) *DeleteNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetInstanceId(v string) *DeleteNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetNamespaceId(v string) *DeleteNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

type DeleteNacosConfigResponseBody struct {
	Code      *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	Message  *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Deletes a Nacos configuration.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigResponseBody) SetCode(v string) *DeleteNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetErrorCode(v string) *DeleteNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetHttpCode(v string) *DeleteNacosConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetMessage(v string) *DeleteNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetRequestId(v string) *DeleteNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetSuccess(v bool) *DeleteNacosConfigResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigResponse) SetHeaders(v map[string]*string) *DeleteNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosConfigResponse) SetStatusCode(v int32) *DeleteNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosConfigResponse) SetBody(v *DeleteNacosConfigResponseBody) *DeleteNacosConfigResponse {
	s.Body = v
	return s
}

type DeleteNacosConfigsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The IDs of configurations.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s DeleteNacosConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigsRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigsRequest) SetAcceptLanguage(v string) *DeleteNacosConfigsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosConfigsRequest) SetIds(v string) *DeleteNacosConfigsRequest {
	s.Ids = &v
	return s
}

func (s *DeleteNacosConfigsRequest) SetInstanceId(v string) *DeleteNacosConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosConfigsRequest) SetNamespaceId(v string) *DeleteNacosConfigsRequest {
	s.NamespaceId = &v
	return s
}

type DeleteNacosConfigsResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigsResponseBody) SetCode(v int32) *DeleteNacosConfigsResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetErrorCode(v string) *DeleteNacosConfigsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetHttpCode(v string) *DeleteNacosConfigsResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetMessage(v string) *DeleteNacosConfigsResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetRequestId(v string) *DeleteNacosConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetSuccess(v bool) *DeleteNacosConfigsResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosConfigsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigsResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigsResponse) SetHeaders(v map[string]*string) *DeleteNacosConfigsResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosConfigsResponse) SetStatusCode(v int32) *DeleteNacosConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosConfigsResponse) SetBody(v *DeleteNacosConfigsResponseBody) *DeleteNacosConfigsResponse {
	s.Body = v
	return s
}

type DeleteNacosInstanceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The alias of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Specifies whether the node is an ephemeral node. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the Nacos instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the Nacos instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port of the Nacos instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s DeleteNacosInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosInstanceRequest) SetAcceptLanguage(v string) *DeleteNacosInstanceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetClusterName(v string) *DeleteNacosInstanceRequest {
	s.ClusterName = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetEphemeral(v bool) *DeleteNacosInstanceRequest {
	s.Ephemeral = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetGroupName(v string) *DeleteNacosInstanceRequest {
	s.GroupName = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetInstanceId(v string) *DeleteNacosInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetIp(v string) *DeleteNacosInstanceRequest {
	s.Ip = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetNamespaceId(v string) *DeleteNacosInstanceRequest {
	s.NamespaceId = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetPort(v int32) *DeleteNacosInstanceRequest {
	s.Port = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetServiceName(v string) *DeleteNacosInstanceRequest {
	s.ServiceName = &v
	return s
}

type DeleteNacosInstanceResponseBody struct {
	// The status code. The value 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosInstanceResponseBody) SetCode(v int32) *DeleteNacosInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetData(v string) *DeleteNacosInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetDynamicMessage(v string) *DeleteNacosInstanceResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetErrorCode(v string) *DeleteNacosInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetHttpStatusCode(v int32) *DeleteNacosInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetMessage(v string) *DeleteNacosInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetRequestId(v string) *DeleteNacosInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetSuccess(v bool) *DeleteNacosInstanceResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosInstanceResponse) SetHeaders(v map[string]*string) *DeleteNacosInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosInstanceResponse) SetStatusCode(v int32) *DeleteNacosInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosInstanceResponse) SetBody(v *DeleteNacosInstanceResponseBody) *DeleteNacosInstanceResponse {
	s.Body = v
	return s
}

type DeleteNacosServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s DeleteNacosServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosServiceRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosServiceRequest) SetAcceptLanguage(v string) *DeleteNacosServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetGroupName(v string) *DeleteNacosServiceRequest {
	s.GroupName = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetInstanceId(v string) *DeleteNacosServiceRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetNamespaceId(v string) *DeleteNacosServiceRequest {
	s.NamespaceId = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetServiceName(v string) *DeleteNacosServiceRequest {
	s.ServiceName = &v
	return s
}

type DeleteNacosServiceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The deletion result.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosServiceResponseBody) SetCode(v int32) *DeleteNacosServiceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetData(v string) *DeleteNacosServiceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetHttpStatusCode(v int32) *DeleteNacosServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetMessage(v string) *DeleteNacosServiceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetRequestId(v string) *DeleteNacosServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetSuccess(v bool) *DeleteNacosServiceResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosServiceResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosServiceResponse) SetHeaders(v map[string]*string) *DeleteNacosServiceResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosServiceResponse) SetStatusCode(v int32) *DeleteNacosServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosServiceResponse) SetBody(v *DeleteNacosServiceResponseBody) *DeleteNacosServiceResponse {
	s.Body = v
	return s
}

type DeleteNamespaceRequest struct {
	// The language in which you want to display the results. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Region         *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s DeleteNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNamespaceRequest) GoString() string {
	return s.String()
}

func (s *DeleteNamespaceRequest) SetAcceptLanguage(v string) *DeleteNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNamespaceRequest) SetName(v string) *DeleteNamespaceRequest {
	s.Name = &v
	return s
}

func (s *DeleteNamespaceRequest) SetRegion(v string) *DeleteNamespaceRequest {
	s.Region = &v
	return s
}

type DeleteNamespaceResponseBody struct {
	// The error code.
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	Message        *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNamespaceResponseBody) SetErrorCode(v string) *DeleteNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteNamespaceResponseBody) SetHttpStatusCode(v int32) *DeleteNamespaceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteNamespaceResponseBody) SetMessage(v string) *DeleteNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNamespaceResponseBody) SetRequestId(v string) *DeleteNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNamespaceResponseBody) SetSuccess(v bool) *DeleteNamespaceResponseBody {
	s.Success = &v
	return s
}

type DeleteNamespaceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNamespaceResponse) GoString() string {
	return s.String()
}

func (s *DeleteNamespaceResponse) SetHeaders(v map[string]*string) *DeleteNamespaceResponse {
	s.Headers = v
	return s
}

func (s *DeleteNamespaceResponse) SetStatusCode(v int32) *DeleteNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNamespaceResponse) SetBody(v *DeleteNamespaceResponseBody) *DeleteNamespaceResponse {
	s.Body = v
	return s
}

type DeleteSecurityGroupRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage  *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	CascadingDelete *bool   `json:"CascadingDelete,omitempty" xml:"CascadingDelete,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The destination ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteSecurityGroupRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleRequest) SetAcceptLanguage(v string) *DeleteSecurityGroupRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteSecurityGroupRuleRequest) SetCascadingDelete(v bool) *DeleteSecurityGroupRuleRequest {
	s.CascadingDelete = &v
	return s
}

func (s *DeleteSecurityGroupRuleRequest) SetGatewayUniqueId(v string) *DeleteSecurityGroupRuleRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteSecurityGroupRuleRequest) SetId(v int64) *DeleteSecurityGroupRuleRequest {
	s.Id = &v
	return s
}

type DeleteSecurityGroupRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteSecurityGroupRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSecurityGroupRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleResponseBody) SetCode(v int32) *DeleteSecurityGroupRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetData(v *DeleteSecurityGroupRuleResponseBodyData) *DeleteSecurityGroupRuleResponseBody {
	s.Data = v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetHttpStatusCode(v int32) *DeleteSecurityGroupRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetMessage(v string) *DeleteSecurityGroupRuleResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetRequestId(v string) *DeleteSecurityGroupRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetSuccess(v bool) *DeleteSecurityGroupRuleResponseBody {
	s.Success = &v
	return s
}

type DeleteSecurityGroupRuleResponseBodyData struct {
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The transport layer protocol. The value of this parameter is case-insensitive. Valid values:
	//
	// *   icmp
	// *   gre
	// *   tcp
	// *   udp
	// *   all: All protocols are supported.
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The range of ports for the transport layer protocol in the destination security group. Valid values:
	//
	// *   When the IpProtocol parameter is set to tcp or udp, the port number range is 1 to 65535. The start port number and the end port number are separated by a forward slash (/). Example: 1/200.
	// *   If the IpProtocol parameter is set to icmp, the port number range is -1/-1, which indicates all ports.
	// *   If the IpProtocol parameter is set to gre, the port number range is -1/-1, which indicates all ports.
	// *   If the IpProtocol parameter is set to all, the port number range is -1/-1, which indicates all ports.
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s DeleteSecurityGroupRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetDescription(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.Description = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGatewayId(v int64) *DeleteSecurityGroupRuleResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGatewayUniqueId(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGmtCreate(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGmtModified(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetId(v int64) *DeleteSecurityGroupRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetIpProtocol(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.IpProtocol = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetPortRange(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.PortRange = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetSecurityGroupId(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

type DeleteSecurityGroupRuleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSecurityGroupRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSecurityGroupRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleResponse) SetHeaders(v map[string]*string) *DeleteSecurityGroupRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteSecurityGroupRuleResponse) SetStatusCode(v int32) *DeleteSecurityGroupRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponse) SetBody(v *DeleteSecurityGroupRuleResponseBody) *DeleteSecurityGroupRuleResponse {
	s.Body = v
	return s
}

type DeleteServiceSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the data source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
}

func (s DeleteServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteServiceSourceRequest) SetAcceptLanguage(v string) *DeleteServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteServiceSourceRequest) SetGatewayUniqueId(v string) *DeleteServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteServiceSourceRequest) SetSourceId(v int64) *DeleteServiceSourceRequest {
	s.SourceId = &v
	return s
}

type DeleteServiceSourceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteServiceSourceResponseBody) SetCode(v int32) *DeleteServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetHttpStatusCode(v int32) *DeleteServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetMessage(v string) *DeleteServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetRequestId(v string) *DeleteServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetSuccess(v bool) *DeleteServiceSourceResponseBody {
	s.Success = &v
	return s
}

type DeleteServiceSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteServiceSourceResponse) SetHeaders(v map[string]*string) *DeleteServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteServiceSourceResponse) SetStatusCode(v int32) *DeleteServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteServiceSourceResponse) SetBody(v *DeleteServiceSourceResponseBody) *DeleteServiceSourceResponse {
	s.Body = v
	return s
}

type DeleteSwimmingLaneRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
	// The name of the Microservices Engine (MSE) namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneRequest) SetAcceptLanguage(v string) *DeleteSwimmingLaneRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteSwimmingLaneRequest) SetLaneId(v int64) *DeleteSwimmingLaneRequest {
	s.LaneId = &v
	return s
}

func (s *DeleteSwimmingLaneRequest) SetNamespace(v string) *DeleteSwimmingLaneRequest {
	s.Namespace = &v
	return s
}

type DeleteSwimmingLaneResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneResponseBody) SetErrorCode(v string) *DeleteSwimmingLaneResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetMessage(v string) *DeleteSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetRequestId(v string) *DeleteSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetSuccess(v bool) *DeleteSwimmingLaneResponseBody {
	s.Success = &v
	return s
}

type DeleteSwimmingLaneResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneResponse) SetHeaders(v map[string]*string) *DeleteSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *DeleteSwimmingLaneResponse) SetStatusCode(v int32) *DeleteSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSwimmingLaneResponse) SetBody(v *DeleteSwimmingLaneResponseBody) *DeleteSwimmingLaneResponse {
	s.Body = v
	return s
}

type DeleteSwimmingLaneGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the Microservices Engine (MSE) namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneGroupRequest) SetAcceptLanguage(v string) *DeleteSwimmingLaneGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteSwimmingLaneGroupRequest) SetGroupId(v int64) *DeleteSwimmingLaneGroupRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteSwimmingLaneGroupRequest) SetName(v string) *DeleteSwimmingLaneGroupRequest {
	s.Name = &v
	return s
}

func (s *DeleteSwimmingLaneGroupRequest) SetNamespace(v string) *DeleteSwimmingLaneGroupRequest {
	s.Namespace = &v
	return s
}

type DeleteSwimmingLaneGroupResponseBody struct {
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetData(v interface{}) *DeleteSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetErrorCode(v string) *DeleteSwimmingLaneGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetMessage(v string) *DeleteSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetRequestId(v string) *DeleteSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetSuccess(v bool) *DeleteSwimmingLaneGroupResponseBody {
	s.Success = &v
	return s
}

type DeleteSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *DeleteSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteSwimmingLaneGroupResponse) SetStatusCode(v int32) *DeleteSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponse) SetBody(v *DeleteSwimmingLaneGroupResponseBody) *DeleteSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type DeleteZnodeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s DeleteZnodeRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeRequest) GoString() string {
	return s.String()
}

func (s *DeleteZnodeRequest) SetAcceptLanguage(v string) *DeleteZnodeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteZnodeRequest) SetClusterId(v string) *DeleteZnodeRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteZnodeRequest) SetPath(v string) *DeleteZnodeRequest {
	s.Path = &v
	return s
}

func (s *DeleteZnodeRequest) SetRequestPars(v string) *DeleteZnodeRequest {
	s.RequestPars = &v
	return s
}

type DeleteZnodeResponseBody struct {
	// The details of the data.
	Data *DeleteZnodeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteZnodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteZnodeResponseBody) SetData(v *DeleteZnodeResponseBodyData) *DeleteZnodeResponseBody {
	s.Data = v
	return s
}

func (s *DeleteZnodeResponseBody) SetErrorCode(v string) *DeleteZnodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetHttpCode(v string) *DeleteZnodeResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetMessage(v string) *DeleteZnodeResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetRequestId(v string) *DeleteZnodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetSuccess(v bool) *DeleteZnodeResponseBody {
	s.Success = &v
	return s
}

type DeleteZnodeResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DeleteZnodeResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteZnodeResponseBodyData) SetData(v string) *DeleteZnodeResponseBodyData {
	s.Data = &v
	return s
}

func (s *DeleteZnodeResponseBodyData) SetDir(v bool) *DeleteZnodeResponseBodyData {
	s.Dir = &v
	return s
}

func (s *DeleteZnodeResponseBodyData) SetName(v string) *DeleteZnodeResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteZnodeResponseBodyData) SetPath(v string) *DeleteZnodeResponseBodyData {
	s.Path = &v
	return s
}

type DeleteZnodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteZnodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteZnodeResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeResponse) GoString() string {
	return s.String()
}

func (s *DeleteZnodeResponse) SetHeaders(v map[string]*string) *DeleteZnodeResponse {
	s.Headers = v
	return s
}

func (s *DeleteZnodeResponse) SetStatusCode(v int32) *DeleteZnodeResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteZnodeResponse) SetBody(v *DeleteZnodeResponseBody) *DeleteZnodeResponse {
	s.Body = v
	return s
}

type ExportNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Deprecated
	// The application tag.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Deprecated
	// The ID of the data that you want to export.
	//
	// >
	//
	// *   Multiple export methods are supported.
	//
	// *   If you want to export a single configuration, you must leave the Ids parameter empty and specify the DataID and Group parameters.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The configuration group name and the ID of the configuration that you want to export. Separate multiple configurations with comma (,).
	DataIds *string `json:"DataIds,omitempty" xml:"DataIds,omitempty"`
	// Deprecated
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// Deprecated
	// The ID of the primary key of a configuration item.
	//
	// >  - Multiple export methods are supported. You must specify this parameter if you want to export multiple configurations. - You can obtain the value of this parameter by calling the ListNacosConfigs operation. - If you specify this parameter, multiple configurations are exported. The DataId and Group parameters are invalid.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s ExportNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigRequest) SetAcceptLanguage(v string) *ExportNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ExportNacosConfigRequest) SetAppName(v string) *ExportNacosConfigRequest {
	s.AppName = &v
	return s
}

func (s *ExportNacosConfigRequest) SetDataId(v string) *ExportNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *ExportNacosConfigRequest) SetDataIds(v string) *ExportNacosConfigRequest {
	s.DataIds = &v
	return s
}

func (s *ExportNacosConfigRequest) SetGroup(v string) *ExportNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *ExportNacosConfigRequest) SetIds(v string) *ExportNacosConfigRequest {
	s.Ids = &v
	return s
}

func (s *ExportNacosConfigRequest) SetInstanceId(v string) *ExportNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *ExportNacosConfigRequest) SetNamespaceId(v string) *ExportNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

type ExportNacosConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ExportNacosConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace **%s** in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExportNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigResponseBody) SetCode(v int32) *ExportNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetData(v *ExportNacosConfigResponseBodyData) *ExportNacosConfigResponseBody {
	s.Data = v
	return s
}

func (s *ExportNacosConfigResponseBody) SetDynamicMessage(v string) *ExportNacosConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetErrorCode(v string) *ExportNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetHttpStatusCode(v int32) *ExportNacosConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetMessage(v string) *ExportNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetRequestId(v string) *ExportNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetSuccess(v bool) *ExportNacosConfigResponseBody {
	s.Success = &v
	return s
}

type ExportNacosConfigResponseBodyData struct {
	// The URL that is used to download the exported configurations.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ExportNacosConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigResponseBodyData) SetUrl(v string) *ExportNacosConfigResponseBodyData {
	s.Url = &v
	return s
}

type ExportNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExportNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigResponse) SetHeaders(v map[string]*string) *ExportNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *ExportNacosConfigResponse) SetStatusCode(v int32) *ExportNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportNacosConfigResponse) SetBody(v *ExportNacosConfigResponseBody) *ExportNacosConfigResponse {
	s.Body = v
	return s
}

type ExportZookeeperDataRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the object that you want to export. Valid values:
	//
	// *   transactionLog: transaction logs
	// *   snapshot: snapshots
	ExportType *string `json:"ExportType,omitempty" xml:"ExportType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ExportZookeeperDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataRequest) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataRequest) SetAcceptLanguage(v string) *ExportZookeeperDataRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetExportType(v string) *ExportZookeeperDataRequest {
	s.ExportType = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetInstanceId(v string) *ExportZookeeperDataRequest {
	s.InstanceId = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetRegionId(v string) *ExportZookeeperDataRequest {
	s.RegionId = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetRequestPars(v string) *ExportZookeeperDataRequest {
	s.RequestPars = &v
	return s
}

type ExportZookeeperDataResponseBody struct {
	// The details of the data.
	Data *ExportZookeeperDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExportZookeeperDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataResponseBody) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataResponseBody) SetData(v *ExportZookeeperDataResponseBodyData) *ExportZookeeperDataResponseBody {
	s.Data = v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetDynamicMessage(v string) *ExportZookeeperDataResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetErrorCode(v string) *ExportZookeeperDataResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetHttpStatusCode(v string) *ExportZookeeperDataResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetMessage(v string) *ExportZookeeperDataResponseBody {
	s.Message = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetRequestId(v string) *ExportZookeeperDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetSuccess(v bool) *ExportZookeeperDataResponseBody {
	s.Success = &v
	return s
}

type ExportZookeeperDataResponseBodyData struct {
	// The content of a task.
	ContentMap map[string]interface{} `json:"ContentMap,omitempty" xml:"ContentMap,omitempty"`
	// The creation time.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The type of the object that is exported. Valid values:
	//
	// *   transactionLog: transaction logs
	// *   snapshot: snapshots
	ExportType *string `json:"ExportType,omitempty" xml:"ExportType,omitempty"`
	// The extended information.
	Extend *string `json:"Extend,omitempty" xml:"Extend,omitempty"`
	// The ID of the task.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the associated task at the underlying layer. This parameter is used only to troubleshoot failures.
	KubeoneTaskIds *string `json:"KubeoneTaskIds,omitempty" xml:"KubeoneTaskIds,omitempty"`
	// The status of the task. Valid values:
	//
	// *   CREATE: The object is being created.
	// *   RUNNING: The task is running.
	// *   FINISH: The task is completed.
	// *   FAILED: The task fails.
	// *   EXPIRE: The task has expired.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last update time.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ExportZookeeperDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataResponseBodyData) SetContentMap(v map[string]interface{}) *ExportZookeeperDataResponseBodyData {
	s.ContentMap = v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetCreateTime(v int64) *ExportZookeeperDataResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetExportType(v string) *ExportZookeeperDataResponseBodyData {
	s.ExportType = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetExtend(v string) *ExportZookeeperDataResponseBodyData {
	s.Extend = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetId(v int32) *ExportZookeeperDataResponseBodyData {
	s.Id = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetInstanceId(v string) *ExportZookeeperDataResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetKubeoneTaskIds(v string) *ExportZookeeperDataResponseBodyData {
	s.KubeoneTaskIds = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetStatus(v string) *ExportZookeeperDataResponseBodyData {
	s.Status = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetUpdateTime(v int64) *ExportZookeeperDataResponseBodyData {
	s.UpdateTime = &v
	return s
}

type ExportZookeeperDataResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExportZookeeperDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportZookeeperDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataResponse) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataResponse) SetHeaders(v map[string]*string) *ExportZookeeperDataResponse {
	s.Headers = v
	return s
}

func (s *ExportZookeeperDataResponse) SetStatusCode(v int32) *ExportZookeeperDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportZookeeperDataResponse) SetBody(v *ExportZookeeperDataResponseBody) *ExportZookeeperDataResponse {
	s.Body = v
	return s
}

type FetchLosslessRuleListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s FetchLosslessRuleListRequest) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListRequest) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListRequest) SetAcceptLanguage(v string) *FetchLosslessRuleListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetAppId(v string) *FetchLosslessRuleListRequest {
	s.AppId = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetAppName(v string) *FetchLosslessRuleListRequest {
	s.AppName = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetNamespace(v string) *FetchLosslessRuleListRequest {
	s.Namespace = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetPageNumber(v int32) *FetchLosslessRuleListRequest {
	s.PageNumber = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetPageSize(v int32) *FetchLosslessRuleListRequest {
	s.PageSize = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetRegionId(v string) *FetchLosslessRuleListRequest {
	s.RegionId = &v
	return s
}

type FetchLosslessRuleListResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned result.
	Data           *FetchLosslessRuleListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                                `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	HttpStatusCode *int32                                 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s FetchLosslessRuleListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponseBody) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponseBody) SetCode(v int32) *FetchLosslessRuleListResponseBody {
	s.Code = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetData(v *FetchLosslessRuleListResponseBodyData) *FetchLosslessRuleListResponseBody {
	s.Data = v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetErrorCode(v string) *FetchLosslessRuleListResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetHttpStatusCode(v int32) *FetchLosslessRuleListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetMessage(v string) *FetchLosslessRuleListResponseBody {
	s.Message = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetRequestId(v string) *FetchLosslessRuleListResponseBody {
	s.RequestId = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetSuccess(v bool) *FetchLosslessRuleListResponseBody {
	s.Success = &v
	return s
}

type FetchLosslessRuleListResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned data.
	Results []*FetchLosslessRuleListResponseBodyDataResults `json:"Results,omitempty" xml:"Results,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s FetchLosslessRuleListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponseBodyData) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponseBodyData) SetPageNumber(v int32) *FetchLosslessRuleListResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyData) SetPageSize(v int32) *FetchLosslessRuleListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyData) SetResults(v []*FetchLosslessRuleListResponseBodyDataResults) *FetchLosslessRuleListResponseBodyData {
	s.Results = v
	return s
}

func (s *FetchLosslessRuleListResponseBodyData) SetTotalSize(v int32) *FetchLosslessRuleListResponseBodyData {
	s.TotalSize = &v
	return s
}

type FetchLosslessRuleListResponseBodyDataResults struct {
	// Indicates whether service registration is complete before readiness probe.
	Aligned *bool `json:"Aligned,omitempty" xml:"Aligned,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The number of instances.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The registration latency. Unit: seconds.
	DelayTime *int32 `json:"DelayTime,omitempty" xml:"DelayTime,omitempty"`
	// Indicates whether graceful start is enabled. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The slope of the prefetching curve.
	FuncType *int32 `json:"FuncType,omitempty" xml:"FuncType,omitempty"`
	// Indicates whether online and offline processing details are displayed.
	LossLessDetail *bool `json:"LossLessDetail,omitempty" xml:"LossLessDetail,omitempty"`
	// Indicates whether notification is enabled.
	Notice *bool `json:"Notice,omitempty" xml:"Notice,omitempty"`
	// Indicates whether service prefetching is complete before readiness probe.
	Related *bool `json:"Related,omitempty" xml:"Related,omitempty"`
	// The prefetching duration. Unit: seconds.
	WarmupTime *int32 `json:"WarmupTime,omitempty" xml:"WarmupTime,omitempty"`
}

func (s FetchLosslessRuleListResponseBodyDataResults) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponseBodyDataResults) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetAligned(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Aligned = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetAppId(v string) *FetchLosslessRuleListResponseBodyDataResults {
	s.AppId = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetAppName(v string) *FetchLosslessRuleListResponseBodyDataResults {
	s.AppName = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetCount(v int32) *FetchLosslessRuleListResponseBodyDataResults {
	s.Count = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetDelayTime(v int32) *FetchLosslessRuleListResponseBodyDataResults {
	s.DelayTime = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetEnable(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Enable = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetFuncType(v int32) *FetchLosslessRuleListResponseBodyDataResults {
	s.FuncType = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetLossLessDetail(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.LossLessDetail = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetNotice(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Notice = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetRelated(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Related = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetWarmupTime(v int32) *FetchLosslessRuleListResponseBodyDataResults {
	s.WarmupTime = &v
	return s
}

type FetchLosslessRuleListResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *FetchLosslessRuleListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s FetchLosslessRuleListResponse) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponse) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponse) SetHeaders(v map[string]*string) *FetchLosslessRuleListResponse {
	s.Headers = v
	return s
}

func (s *FetchLosslessRuleListResponse) SetStatusCode(v int32) *FetchLosslessRuleListResponse {
	s.StatusCode = &v
	return s
}

func (s *FetchLosslessRuleListResponse) SetBody(v *FetchLosslessRuleListResponseBody) *FetchLosslessRuleListResponse {
	s.Body = v
	return s
}

type GetAppMessageQueueRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The name of the Microservices Engine (MSE) namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region where the instance resides. Examples:
	//
	// *   `cn-hangzhou`: China (Hangzhou)
	// *   `cn-beijing`: China (Beijing)
	// *   `cn-shanghai`: China (Shanghai)
	// *   `cn-zhangjiakou`: China (Zhangjiakou)
	// *   `cn-shenzhen`: China (Shenzhen)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s GetAppMessageQueueRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteRequest) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteRequest) SetAcceptLanguage(v string) *GetAppMessageQueueRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetAppMessageQueueRouteRequest) SetAppId(v string) *GetAppMessageQueueRouteRequest {
	s.AppId = &v
	return s
}

func (s *GetAppMessageQueueRouteRequest) SetAppName(v string) *GetAppMessageQueueRouteRequest {
	s.AppName = &v
	return s
}

func (s *GetAppMessageQueueRouteRequest) SetNamespace(v string) *GetAppMessageQueueRouteRequest {
	s.Namespace = &v
	return s
}

func (s *GetAppMessageQueueRouteRequest) SetRegion(v string) *GetAppMessageQueueRouteRequest {
	s.Region = &v
	return s
}

type GetAppMessageQueueRouteResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *GetAppMessageQueueRouteResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true and false. The value true indicates that the request was successful. The value false indicates that the request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetAppMessageQueueRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteResponseBody) SetCode(v int32) *GetAppMessageQueueRouteResponseBody {
	s.Code = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetData(v *GetAppMessageQueueRouteResponseBodyData) *GetAppMessageQueueRouteResponseBody {
	s.Data = v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetHttpStatusCode(v int32) *GetAppMessageQueueRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetMessage(v string) *GetAppMessageQueueRouteResponseBody {
	s.Message = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetRequestId(v string) *GetAppMessageQueueRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetSuccess(v bool) *GetAppMessageQueueRouteResponseBody {
	s.Success = &v
	return s
}

type GetAppMessageQueueRouteResponseBodyData struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Indicates whether the canary release for messaging feature is enabled.
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	FilterSide *string `json:"FilterSide,omitempty" xml:"FilterSide,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The tags used to ignore message consumption for nodes in untagged environments.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetAppMessageQueueRouteResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetAppId(v string) *GetAppMessageQueueRouteResponseBodyData {
	s.AppId = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetEnable(v bool) *GetAppMessageQueueRouteResponseBodyData {
	s.Enable = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetFilterSide(v string) *GetAppMessageQueueRouteResponseBodyData {
	s.FilterSide = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetRegion(v string) *GetAppMessageQueueRouteResponseBodyData {
	s.Region = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetTags(v []*string) *GetAppMessageQueueRouteResponseBodyData {
	s.Tags = v
	return s
}

type GetAppMessageQueueRouteResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAppMessageQueueRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAppMessageQueueRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteResponse) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteResponse) SetHeaders(v map[string]*string) *GetAppMessageQueueRouteResponse {
	s.Headers = v
	return s
}

func (s *GetAppMessageQueueRouteResponse) SetStatusCode(v int32) *GetAppMessageQueueRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppMessageQueueRouteResponse) SetBody(v *GetAppMessageQueueRouteResponseBody) *GetAppMessageQueueRouteResponse {
	s.Body = v
	return s
}

type GetApplicationInstanceListRequest struct {
	// The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Deprecated
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The Microservices Engine (MSE) namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The page number. Pages start from page 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The tags that you want to add to nodes.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s GetApplicationInstanceListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationInstanceListRequest) GoString() string {
	return s.String()
}

func (s *GetApplicationInstanceListRequest) SetAcceptLanguage(v string) *GetApplicationInstanceListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetApplicationInstanceListRequest) SetAppId(v string) *GetApplicationInstanceListRequest {
	s.AppId = &v
	return s
}

func (s *GetApplicationInstanceListRequest) SetAppName(v string) *GetApplicationInstanceListRequest {
	s.AppName = &v
	return s
}

func (s *GetApplicationInstanceListRequest) SetNamespace(v string) *GetApplicationInstanceListRequest {
	s.Namespace = &v
	return s
}

func (s *GetApplicationInstanceListRequest) SetPageNumber(v int32) *GetApplicationInstanceListRequest {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationInstanceListRequest) SetPageSize(v int32) *GetApplicationInstanceListRequest {
	s.PageSize = &v
	return s
}

func (s *GetApplicationInstanceListRequest) SetRegion(v string) *GetApplicationInstanceListRequest {
	s.Region = &v
	return s
}

func (s *GetApplicationInstanceListRequest) SetTag(v string) *GetApplicationInstanceListRequest {
	s.Tag = &v
	return s
}

type GetApplicationInstanceListResponseBody struct {
	// The returned data.
	Data *GetApplicationInstanceListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
}

func (s GetApplicationInstanceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationInstanceListResponseBody) GoString() string {
	return s.String()
}

func (s *GetApplicationInstanceListResponseBody) SetData(v *GetApplicationInstanceListResponseBodyData) *GetApplicationInstanceListResponseBody {
	s.Data = v
	return s
}

type GetApplicationInstanceListResponseBodyData struct {
	// The page number. Pages start from page 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The queried nodes.
	Result []*GetApplicationInstanceListResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of nodes.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetApplicationInstanceListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationInstanceListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetApplicationInstanceListResponseBodyData) SetPageNumber(v int32) *GetApplicationInstanceListResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationInstanceListResponseBodyData) SetPageSize(v int32) *GetApplicationInstanceListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetApplicationInstanceListResponseBodyData) SetResult(v []*GetApplicationInstanceListResponseBodyDataResult) *GetApplicationInstanceListResponseBodyData {
	s.Result = v
	return s
}

func (s *GetApplicationInstanceListResponseBodyData) SetTotalSize(v int32) *GetApplicationInstanceListResponseBodyData {
	s.TotalSize = &v
	return s
}

type GetApplicationInstanceListResponseBodyDataResult struct {
	// The node IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The application port.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The node tags.
	Tags []*GetApplicationInstanceListResponseBodyDataResultTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetApplicationInstanceListResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationInstanceListResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *GetApplicationInstanceListResponseBodyDataResult) SetIp(v string) *GetApplicationInstanceListResponseBodyDataResult {
	s.Ip = &v
	return s
}

func (s *GetApplicationInstanceListResponseBodyDataResult) SetPort(v string) *GetApplicationInstanceListResponseBodyDataResult {
	s.Port = &v
	return s
}

func (s *GetApplicationInstanceListResponseBodyDataResult) SetTags(v []*GetApplicationInstanceListResponseBodyDataResultTags) *GetApplicationInstanceListResponseBodyDataResult {
	s.Tags = v
	return s
}

type GetApplicationInstanceListResponseBodyDataResultTags struct {
	// 
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s GetApplicationInstanceListResponseBodyDataResultTags) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationInstanceListResponseBodyDataResultTags) GoString() string {
	return s.String()
}

func (s *GetApplicationInstanceListResponseBodyDataResultTags) SetTag(v string) *GetApplicationInstanceListResponseBodyDataResultTags {
	s.Tag = &v
	return s
}

type GetApplicationInstanceListResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetApplicationInstanceListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetApplicationInstanceListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationInstanceListResponse) GoString() string {
	return s.String()
}

func (s *GetApplicationInstanceListResponse) SetHeaders(v map[string]*string) *GetApplicationInstanceListResponse {
	s.Headers = v
	return s
}

func (s *GetApplicationInstanceListResponse) SetStatusCode(v int32) *GetApplicationInstanceListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetApplicationInstanceListResponse) SetBody(v *GetApplicationInstanceListResponseBody) *GetApplicationInstanceListResponse {
	s.Body = v
	return s
}

type GetApplicationListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of an application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of an application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The programming language of the application, such as Java and Go.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Specifies whether to enable the Sentinel-compatible mode.
	SentinelEnable *bool `json:"SentinelEnable,omitempty" xml:"SentinelEnable,omitempty"`
	// The source of the application. The value is fixed as edasmsc.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// Specifies whether to enable switching.
	SwitchEnable *bool `json:"SwitchEnable,omitempty" xml:"SwitchEnable,omitempty"`
}

func (s GetApplicationListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListRequest) GoString() string {
	return s.String()
}

func (s *GetApplicationListRequest) SetAcceptLanguage(v string) *GetApplicationListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetApplicationListRequest) SetAppId(v string) *GetApplicationListRequest {
	s.AppId = &v
	return s
}

func (s *GetApplicationListRequest) SetAppName(v string) *GetApplicationListRequest {
	s.AppName = &v
	return s
}

func (s *GetApplicationListRequest) SetLanguage(v string) *GetApplicationListRequest {
	s.Language = &v
	return s
}

func (s *GetApplicationListRequest) SetNamespace(v string) *GetApplicationListRequest {
	s.Namespace = &v
	return s
}

func (s *GetApplicationListRequest) SetPageNumber(v int32) *GetApplicationListRequest {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationListRequest) SetPageSize(v int32) *GetApplicationListRequest {
	s.PageSize = &v
	return s
}

func (s *GetApplicationListRequest) SetRegion(v string) *GetApplicationListRequest {
	s.Region = &v
	return s
}

func (s *GetApplicationListRequest) SetSentinelEnable(v bool) *GetApplicationListRequest {
	s.SentinelEnable = &v
	return s
}

func (s *GetApplicationListRequest) SetSource(v string) *GetApplicationListRequest {
	s.Source = &v
	return s
}

func (s *GetApplicationListRequest) SetSwitchEnable(v bool) *GetApplicationListRequest {
	s.SwitchEnable = &v
	return s
}

type GetApplicationListResponseBody struct {
	// The details of the data.
	Data *GetApplicationListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetApplicationListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponseBody) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponseBody) SetData(v *GetApplicationListResponseBodyData) *GetApplicationListResponseBody {
	s.Data = v
	return s
}

func (s *GetApplicationListResponseBody) SetMessage(v string) *GetApplicationListResponseBody {
	s.Message = &v
	return s
}

func (s *GetApplicationListResponseBody) SetRequestId(v string) *GetApplicationListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetApplicationListResponseBody) SetSuccess(v bool) *GetApplicationListResponseBody {
	s.Success = &v
	return s
}

type GetApplicationListResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data returned.
	Result []*GetApplicationListResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetApplicationListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponseBodyData) SetPageNumber(v int32) *GetApplicationListResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationListResponseBodyData) SetPageSize(v int32) *GetApplicationListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetApplicationListResponseBodyData) SetResult(v []*GetApplicationListResponseBodyDataResult) *GetApplicationListResponseBodyData {
	s.Result = v
	return s
}

func (s *GetApplicationListResponseBodyData) SetTotalSize(v int32) *GetApplicationListResponseBodyData {
	s.TotalSize = &v
	return s
}

type GetApplicationListResponseBodyDataResult struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The number of instances.
	InstancesNumber *int32 `json:"InstancesNumber,omitempty" xml:"InstancesNumber,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The source of the application.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status.
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetApplicationListResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponseBodyDataResult) SetAppId(v string) *GetApplicationListResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetAppName(v string) *GetApplicationListResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetExtraInfo(v string) *GetApplicationListResponseBodyDataResult {
	s.ExtraInfo = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetInstancesNumber(v int32) *GetApplicationListResponseBodyDataResult {
	s.InstancesNumber = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetLanguage(v string) *GetApplicationListResponseBodyDataResult {
	s.Language = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetNamespace(v string) *GetApplicationListResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetRegionId(v string) *GetApplicationListResponseBodyDataResult {
	s.RegionId = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetSource(v string) *GetApplicationListResponseBodyDataResult {
	s.Source = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetStatus(v int64) *GetApplicationListResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetUserId(v string) *GetApplicationListResponseBodyDataResult {
	s.UserId = &v
	return s
}

type GetApplicationListResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetApplicationListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetApplicationListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponse) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponse) SetHeaders(v map[string]*string) *GetApplicationListResponse {
	s.Headers = v
	return s
}

func (s *GetApplicationListResponse) SetStatusCode(v int32) *GetApplicationListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetApplicationListResponse) SetBody(v *GetApplicationListResponseBody) *GetApplicationListResponse {
	s.Body = v
	return s
}

type GetBlackWhiteListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to enable the whitelist.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetBlackWhiteListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListRequest) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListRequest) SetAcceptLanguage(v string) *GetBlackWhiteListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetGatewayUniqueId(v string) *GetBlackWhiteListRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetIsWhite(v bool) *GetBlackWhiteListRequest {
	s.IsWhite = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetResourceType(v string) *GetBlackWhiteListRequest {
	s.ResourceType = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetType(v string) *GetBlackWhiteListRequest {
	s.Type = &v
	return s
}

type GetBlackWhiteListResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *GetBlackWhiteListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetBlackWhiteListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListResponseBody) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListResponseBody) SetCode(v int32) *GetBlackWhiteListResponseBody {
	s.Code = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetData(v *GetBlackWhiteListResponseBodyData) *GetBlackWhiteListResponseBody {
	s.Data = v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetHttpStatusCode(v int32) *GetBlackWhiteListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetMessage(v string) *GetBlackWhiteListResponseBody {
	s.Message = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetRequestId(v string) *GetBlackWhiteListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetSuccess(v bool) *GetBlackWhiteListResponseBody {
	s.Success = &v
	return s
}

type GetBlackWhiteListResponseBodyData struct {
	// The content of the blacklist.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the whitelist is enabled.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The ID of the resource.
	ResourceId *int64 `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of a resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the blacklist or whitelist.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetBlackWhiteListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListResponseBodyData) SetContent(v string) *GetBlackWhiteListResponseBodyData {
	s.Content = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGatewayId(v int64) *GetBlackWhiteListResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGatewayUniqueId(v string) *GetBlackWhiteListResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGmtCreate(v string) *GetBlackWhiteListResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGmtModified(v string) *GetBlackWhiteListResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetId(v int64) *GetBlackWhiteListResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetIsWhite(v bool) *GetBlackWhiteListResponseBodyData {
	s.IsWhite = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetResourceId(v int64) *GetBlackWhiteListResponseBodyData {
	s.ResourceId = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetResourceType(v string) *GetBlackWhiteListResponseBodyData {
	s.ResourceType = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetStatus(v string) *GetBlackWhiteListResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetType(v string) *GetBlackWhiteListResponseBodyData {
	s.Type = &v
	return s
}

type GetBlackWhiteListResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBlackWhiteListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBlackWhiteListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListResponse) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListResponse) SetHeaders(v map[string]*string) *GetBlackWhiteListResponse {
	s.Headers = v
	return s
}

func (s *GetBlackWhiteListResponse) SetStatusCode(v int32) *GetBlackWhiteListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBlackWhiteListResponse) SetBody(v *GetBlackWhiteListResponseBody) *GetBlackWhiteListResponse {
	s.Body = v
	return s
}

type GetEngineNamepaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The destination ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s GetEngineNamepaceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEngineNamepaceRequest) GoString() string {
	return s.String()
}

func (s *GetEngineNamepaceRequest) SetAcceptLanguage(v string) *GetEngineNamepaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetEngineNamepaceRequest) SetClusterId(v string) *GetEngineNamepaceRequest {
	s.ClusterId = &v
	return s
}

func (s *GetEngineNamepaceRequest) SetId(v string) *GetEngineNamepaceRequest {
	s.Id = &v
	return s
}

func (s *GetEngineNamepaceRequest) SetInstanceId(v string) *GetEngineNamepaceRequest {
	s.InstanceId = &v
	return s
}

type GetEngineNamepaceResponseBody struct {
	// The number of configurations.
	ConfigCount *string `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The display name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quota of configurations.
	Quota *string `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   0: global configuration
	// *   1: default namespace
	// *   2: custom namespace
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetEngineNamepaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEngineNamepaceResponseBody) GoString() string {
	return s.String()
}

func (s *GetEngineNamepaceResponseBody) SetConfigCount(v string) *GetEngineNamepaceResponseBody {
	s.ConfigCount = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetErrorCode(v string) *GetEngineNamepaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetHttpCode(v string) *GetEngineNamepaceResponseBody {
	s.HttpCode = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetMessage(v string) *GetEngineNamepaceResponseBody {
	s.Message = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetNamespace(v string) *GetEngineNamepaceResponseBody {
	s.Namespace = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetNamespaceDesc(v string) *GetEngineNamepaceResponseBody {
	s.NamespaceDesc = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetNamespaceShowName(v string) *GetEngineNamepaceResponseBody {
	s.NamespaceShowName = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetQuota(v string) *GetEngineNamepaceResponseBody {
	s.Quota = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetRequestId(v string) *GetEngineNamepaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetSuccess(v bool) *GetEngineNamepaceResponseBody {
	s.Success = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetType(v string) *GetEngineNamepaceResponseBody {
	s.Type = &v
	return s
}

type GetEngineNamepaceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEngineNamepaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEngineNamepaceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEngineNamepaceResponse) GoString() string {
	return s.String()
}

func (s *GetEngineNamepaceResponse) SetHeaders(v map[string]*string) *GetEngineNamepaceResponse {
	s.Headers = v
	return s
}

func (s *GetEngineNamepaceResponse) SetStatusCode(v int32) *GetEngineNamepaceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEngineNamepaceResponse) SetBody(v *GetEngineNamepaceResponseBody) *GetEngineNamepaceResponse {
	s.Body = v
	return s
}

type GetGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s GetGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayRequest) SetAcceptLanguage(v string) *GetGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayRequest) SetGatewayUniqueId(v string) *GetGatewayRequest {
	s.GatewayUniqueId = &v
	return s
}

type GetGatewayResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the gateway.
	Data *GetGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBody) SetCode(v int32) *GetGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayResponseBody) SetData(v *GetGatewayResponseBodyData) *GetGatewayResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayResponseBody) SetHttpStatusCode(v int32) *GetGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayResponseBody) SetMessage(v string) *GetGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayResponseBody) SetRequestId(v string) *GetGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayResponseBody) SetSuccess(v bool) *GetGatewayResponseBody {
	s.Success = &v
	return s
}

type GetGatewayResponseBodyData struct {
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// Indicates whether auto scale-out is enabled.
	Elastic *bool `json:"Elastic,omitempty" xml:"Elastic,omitempty"`
	// The auto scale-out policy.
	ElasticPolicy *GetGatewayResponseBodyDataElasticPolicy `json:"ElasticPolicy,omitempty" xml:"ElasticPolicy,omitempty" type:"Struct"`
	// The number of replicas that are automatically scaled out.
	ElasticReplica *int32 `json:"ElasticReplica,omitempty" xml:"ElasticReplica,omitempty"`
	// The type of auto scale-out. Valid value:
	//
	// *   CronHPA: scale-out by time
	ElasticType *string `json:"ElasticType,omitempty" xml:"ElasticType,omitempty"`
	// The time when the gateway expires.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the gateway was created. The time is displayed in GMT. The time is the local time of the region in which the gateway resides.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the gateway was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the gateway.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The log configuration.
	LogConfigDetails *GetGatewayResponseBodyDataLogConfigDetails `json:"LogConfigDetails,omitempty" xml:"LogConfigDetails,omitempty" type:"Struct"`
	// The tag of the resource.
	MseTag *string `json:"MseTag,omitempty" xml:"MseTag,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The Alibaba Cloud account ID of the user who created the gateway.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of gateway replicas.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the security group.
	SecurityGroup *string `json:"SecurityGroup,omitempty" xml:"SecurityGroup,omitempty"`
	// The specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the gateway. Valid values:
	// * 0: The gateway is being created.
	// * 1: The gateway fails to be created.
	// * 2: The gateway is running.
	// * 3: The gateway is changing.
	// * 4: The gateway is scaling down.
	// * 6: The gateway is scaling up.
	// * 8: The gateway is being deleted.
	// * 10: The gateway is restarting.
	// * 11: The gateway is being rebuilt.
	// * 12: The gateway is updating.
	// * 13: The gateway fails to be updated.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The total number of replicas, including the number of replicas that are automatically scaled out.
	TotalReplica *int32 `json:"TotalReplica,omitempty" xml:"TotalReplica,omitempty"`
	// The ID of the VPC.
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
	// The ID of the vSwitch.
	Vswitch *string `json:"Vswitch,omitempty" xml:"Vswitch,omitempty"`
	// The ID of the secondary vSwitch.
	Vswitch2 *string `json:"Vswitch2,omitempty" xml:"Vswitch2,omitempty"`
	// The details of Tracing Analysis.
	XtraceDetails *GetGatewayResponseBodyDataXtraceDetails `json:"XtraceDetails,omitempty" xml:"XtraceDetails,omitempty" type:"Struct"`
}

func (s GetGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyData) SetChargeType(v string) *GetGatewayResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetElastic(v bool) *GetGatewayResponseBodyData {
	s.Elastic = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetElasticPolicy(v *GetGatewayResponseBodyDataElasticPolicy) *GetGatewayResponseBodyData {
	s.ElasticPolicy = v
	return s
}

func (s *GetGatewayResponseBodyData) SetElasticReplica(v int32) *GetGatewayResponseBodyData {
	s.ElasticReplica = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetElasticType(v string) *GetGatewayResponseBodyData {
	s.ElasticType = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetEndDate(v string) *GetGatewayResponseBodyData {
	s.EndDate = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetGmtCreate(v string) *GetGatewayResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetGmtModified(v string) *GetGatewayResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetId(v int64) *GetGatewayResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetInstanceId(v string) *GetGatewayResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetLogConfigDetails(v *GetGatewayResponseBodyDataLogConfigDetails) *GetGatewayResponseBodyData {
	s.LogConfigDetails = v
	return s
}

func (s *GetGatewayResponseBodyData) SetMseTag(v string) *GetGatewayResponseBodyData {
	s.MseTag = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetName(v string) *GetGatewayResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetPrimaryUser(v string) *GetGatewayResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetRegion(v string) *GetGatewayResponseBodyData {
	s.Region = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetReplica(v int32) *GetGatewayResponseBodyData {
	s.Replica = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetResourceGroupId(v string) *GetGatewayResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetSecurityGroup(v string) *GetGatewayResponseBodyData {
	s.SecurityGroup = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetSpec(v string) *GetGatewayResponseBodyData {
	s.Spec = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetStatus(v int32) *GetGatewayResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetStatusDesc(v string) *GetGatewayResponseBodyData {
	s.StatusDesc = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetTotalReplica(v int32) *GetGatewayResponseBodyData {
	s.TotalReplica = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetVpc(v string) *GetGatewayResponseBodyData {
	s.Vpc = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetVswitch(v string) *GetGatewayResponseBodyData {
	s.Vswitch = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetVswitch2(v string) *GetGatewayResponseBodyData {
	s.Vswitch2 = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetXtraceDetails(v *GetGatewayResponseBodyDataXtraceDetails) *GetGatewayResponseBodyData {
	s.XtraceDetails = v
	return s
}

type GetGatewayResponseBodyDataElasticPolicy struct {
	// The type of auto scale-out. Valid value:
	//
	// *   CronHPA: scale-out by time
	ElasticType *string `json:"ElasticType,omitempty" xml:"ElasticType,omitempty"`
	// The maximum number of instances that are automatically scaled out. This parameter is used for horizontal scale-out.
	MaxReplica *int32 `json:"MaxReplica,omitempty" xml:"MaxReplica,omitempty"`
	// The policy of scale-out by time.
	TimePolicyList []*GetGatewayResponseBodyDataElasticPolicyTimePolicyList `json:"TimePolicyList,omitempty" xml:"TimePolicyList,omitempty" type:"Repeated"`
}

func (s GetGatewayResponseBodyDataElasticPolicy) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyDataElasticPolicy) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyDataElasticPolicy) SetElasticType(v string) *GetGatewayResponseBodyDataElasticPolicy {
	s.ElasticType = &v
	return s
}

func (s *GetGatewayResponseBodyDataElasticPolicy) SetMaxReplica(v int32) *GetGatewayResponseBodyDataElasticPolicy {
	s.MaxReplica = &v
	return s
}

func (s *GetGatewayResponseBodyDataElasticPolicy) SetTimePolicyList(v []*GetGatewayResponseBodyDataElasticPolicyTimePolicyList) *GetGatewayResponseBodyDataElasticPolicy {
	s.TimePolicyList = v
	return s
}

type GetGatewayResponseBodyDataElasticPolicyTimePolicyList struct {
	// The number of expected replicas.
	DesiredReplica *int32 `json:"DesiredReplica,omitempty" xml:"DesiredReplica,omitempty"`
	// The end time of auto scale-out.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start time of auto scale-out.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetGatewayResponseBodyDataElasticPolicyTimePolicyList) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyDataElasticPolicyTimePolicyList) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyDataElasticPolicyTimePolicyList) SetDesiredReplica(v int32) *GetGatewayResponseBodyDataElasticPolicyTimePolicyList {
	s.DesiredReplica = &v
	return s
}

func (s *GetGatewayResponseBodyDataElasticPolicyTimePolicyList) SetEndTime(v string) *GetGatewayResponseBodyDataElasticPolicyTimePolicyList {
	s.EndTime = &v
	return s
}

func (s *GetGatewayResponseBodyDataElasticPolicyTimePolicyList) SetStartTime(v string) *GetGatewayResponseBodyDataElasticPolicyTimePolicyList {
	s.StartTime = &v
	return s
}

type GetGatewayResponseBodyDataLogConfigDetails struct {
	// Indicates whether Log Service is activated.
	LogEnabled *bool `json:"LogEnabled,omitempty" xml:"LogEnabled,omitempty"`
	// The name of the Logstore.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	// The name of the project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s GetGatewayResponseBodyDataLogConfigDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyDataLogConfigDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyDataLogConfigDetails) SetLogEnabled(v bool) *GetGatewayResponseBodyDataLogConfigDetails {
	s.LogEnabled = &v
	return s
}

func (s *GetGatewayResponseBodyDataLogConfigDetails) SetLogStoreName(v string) *GetGatewayResponseBodyDataLogConfigDetails {
	s.LogStoreName = &v
	return s
}

func (s *GetGatewayResponseBodyDataLogConfigDetails) SetProjectName(v string) *GetGatewayResponseBodyDataLogConfigDetails {
	s.ProjectName = &v
	return s
}

type GetGatewayResponseBodyDataXtraceDetails struct {
	// The sampling rate of Tracing Analysis.
	Sample *int32 `json:"Sample,omitempty" xml:"Sample,omitempty"`
	// Indicates whether sampling by using Tracing Analysis is enabled.
	TraceOn *bool `json:"TraceOn,omitempty" xml:"TraceOn,omitempty"`
}

func (s GetGatewayResponseBodyDataXtraceDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyDataXtraceDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyDataXtraceDetails) SetSample(v int32) *GetGatewayResponseBodyDataXtraceDetails {
	s.Sample = &v
	return s
}

func (s *GetGatewayResponseBodyDataXtraceDetails) SetTraceOn(v bool) *GetGatewayResponseBodyDataXtraceDetails {
	s.TraceOn = &v
	return s
}

type GetGatewayResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayResponse) SetHeaders(v map[string]*string) *GetGatewayResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayResponse) SetStatusCode(v int32) *GetGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayResponse) SetBody(v *GetGatewayResponseBody) *GetGatewayResponse {
	s.Body = v
	return s
}

type GetGatewayAuthConsumerDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the consumer.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s GetGatewayAuthConsumerDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayAuthConsumerDetailRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayAuthConsumerDetailRequest) SetAcceptLanguage(v string) *GetGatewayAuthConsumerDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailRequest) SetGatewayUniqueId(v string) *GetGatewayAuthConsumerDetailRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailRequest) SetId(v int64) *GetGatewayAuthConsumerDetailRequest {
	s.Id = &v
	return s
}

type GetGatewayAuthConsumerDetailResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *GetGatewayAuthConsumerDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayAuthConsumerDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayAuthConsumerDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetCode(v int32) *GetGatewayAuthConsumerDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetData(v *GetGatewayAuthConsumerDetailResponseBodyData) *GetGatewayAuthConsumerDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetDynamicCode(v string) *GetGatewayAuthConsumerDetailResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetDynamicMessage(v string) *GetGatewayAuthConsumerDetailResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetErrorCode(v string) *GetGatewayAuthConsumerDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetHttpStatusCode(v int32) *GetGatewayAuthConsumerDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetMessage(v string) *GetGatewayAuthConsumerDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetRequestId(v string) *GetGatewayAuthConsumerDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBody) SetSuccess(v bool) *GetGatewayAuthConsumerDetailResponseBody {
	s.Success = &v
	return s
}

type GetGatewayAuthConsumerDetailResponseBodyData struct {
	// The status of the consumer. Valid values:
	//
	// *   true: enabled
	// *   false: disabled
	ConsumerStatus *bool `json:"ConsumerStatus,omitempty" xml:"ConsumerStatus,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The encryption type. Valid values:
	//
	// *   RSA
	// *   OCT
	EncodeType *string `json:"EncodeType,omitempty" xml:"EncodeType,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the consumer authentication record was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the consumer authentication record was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the consumer.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The JWT public key. The JSON format is supported.
	Jwks *string `json:"Jwks,omitempty" xml:"Jwks,omitempty"`
	// The name of the key used for JWT-based identity authentication.
	KeyName *string `json:"KeyName,omitempty" xml:"KeyName,omitempty"`
	// The value of the key used for JWT-based identity authentication.
	KeyValue *string `json:"KeyValue,omitempty" xml:"KeyValue,omitempty"`
	// The name of the consumer.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The creator.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The resource list.
	ResourceList []*GetGatewayAuthConsumerDetailResponseBodyDataResourceList `json:"ResourceList,omitempty" xml:"ResourceList,omitempty" type:"Repeated"`
	// The names of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenName *string `json:"TokenName,omitempty" xml:"TokenName,omitempty"`
	// Specifies whether to enable pass-through.
	TokenPass *bool `json:"TokenPass,omitempty" xml:"TokenPass,omitempty"`
	// The positions of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenPosition *string `json:"TokenPosition,omitempty" xml:"TokenPosition,omitempty"`
	// The prefixes of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenPrefix *string `json:"TokenPrefix,omitempty" xml:"TokenPrefix,omitempty"`
	// The authentication type. Valid values:
	//
	// *   JWT
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetGatewayAuthConsumerDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayAuthConsumerDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetConsumerStatus(v bool) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.ConsumerStatus = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetDescription(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetEncodeType(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.EncodeType = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetGmtCreate(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetGmtModified(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetId(v int64) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetJwks(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.Jwks = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetKeyName(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.KeyName = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetKeyValue(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.KeyValue = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetName(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetPrimaryUser(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetResourceList(v []*GetGatewayAuthConsumerDetailResponseBodyDataResourceList) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.ResourceList = v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetTokenName(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.TokenName = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetTokenPass(v bool) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.TokenPass = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetTokenPosition(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.TokenPosition = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetTokenPrefix(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.TokenPrefix = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyData) SetType(v string) *GetGatewayAuthConsumerDetailResponseBodyData {
	s.Type = &v
	return s
}

type GetGatewayAuthConsumerDetailResponseBodyDataResourceList struct {
	// The consumer ID.
	ConsumerId *int64 `json:"ConsumerId,omitempty" xml:"ConsumerId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the resource associated with the consumer authentication record was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the resource associated with the consumer authentication record was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the authorized resource for the consumer.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The resource authorization state. Valid values:
	//
	// *   true: Resource authorization is enabled.
	// *   false: Resource authorization is disabled.
	ResourceStatus *bool `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The ID of the route.
	RouteId *int64 `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
	// The name of the route.
	RouteName *string `json:"RouteName,omitempty" xml:"RouteName,omitempty"`
}

func (s GetGatewayAuthConsumerDetailResponseBodyDataResourceList) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayAuthConsumerDetailResponseBodyDataResourceList) GoString() string {
	return s.String()
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetConsumerId(v int64) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.ConsumerId = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetGatewayUniqueId(v string) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetGmtCreate(v string) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetGmtModified(v string) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetId(v int64) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.Id = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetResourceStatus(v bool) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.ResourceStatus = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetRouteId(v int64) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.RouteId = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponseBodyDataResourceList) SetRouteName(v string) *GetGatewayAuthConsumerDetailResponseBodyDataResourceList {
	s.RouteName = &v
	return s
}

type GetGatewayAuthConsumerDetailResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayAuthConsumerDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayAuthConsumerDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayAuthConsumerDetailResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayAuthConsumerDetailResponse) SetHeaders(v map[string]*string) *GetGatewayAuthConsumerDetailResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponse) SetStatusCode(v int32) *GetGatewayAuthConsumerDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayAuthConsumerDetailResponse) SetBody(v *GetGatewayAuthConsumerDetailResponseBody) *GetGatewayAuthConsumerDetailResponse {
	s.Body = v
	return s
}

type GetGatewayDomainDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The domain ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s GetGatewayDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailRequest) SetAcceptLanguage(v string) *GetGatewayDomainDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayDomainDetailRequest) SetGatewayUniqueId(v string) *GetGatewayDomainDetailRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayDomainDetailRequest) SetId(v string) *GetGatewayDomainDetailRequest {
	s.Id = &v
	return s
}

type GetGatewayDomainDetailResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetGatewayDomainDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailResponseBody) SetCode(v int32) *GetGatewayDomainDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetData(v *GetGatewayDomainDetailResponseBodyData) *GetGatewayDomainDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetHttpStatusCode(v int32) *GetGatewayDomainDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetMessage(v string) *GetGatewayDomainDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetRequestId(v string) *GetGatewayDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetSuccess(v bool) *GetGatewayDomainDetailResponseBody {
	s.Success = &v
	return s
}

type GetGatewayDomainDetailResponseBodyData struct {
	// The start time.
	AfterDate *int64 `json:"AfterDate,omitempty" xml:"AfterDate,omitempty"`
	// The algorithm.
	Algorithm *string `json:"Algorithm,omitempty" xml:"Algorithm,omitempty"`
	// The expiration time.
	BeforeDate *int64 `json:"BeforeDate,omitempty" xml:"BeforeDate,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The public domain name.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The start time.
	GmtAfter *string `json:"GmtAfter,omitempty" xml:"GmtAfter,omitempty"`
	// The expiration time.
	GmtBefore *string `json:"GmtBefore,omitempty" xml:"GmtBefore,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// Indicates whether `HTTP/2` is enabled.
	//
	// *   `open`: `HTTP/2` is enabled.
	// *   `close`: `HTTP/2` is disabled.
	// *   `globalConfig`: Global configurations are used.
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The issuer.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// Indicates whether HTTPS is forcibly used.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The domain name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol of the gateway.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The name of the extended field.
	Sans *string `json:"Sans,omitempty" xml:"Sans,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
}

func (s GetGatewayDomainDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailResponseBodyData) SetAfterDate(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.AfterDate = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetAlgorithm(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Algorithm = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetBeforeDate(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.BeforeDate = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetCertIdentifier(v string) *GetGatewayDomainDetailResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetCertName(v string) *GetGatewayDomainDetailResponseBodyData {
	s.CertName = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetCommonName(v string) *GetGatewayDomainDetailResponseBodyData {
	s.CommonName = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGatewayId(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtAfter(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtAfter = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtBefore(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtBefore = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtCreate(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtModified(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetHttp2(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Http2 = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetId(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetIssuer(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Issuer = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetMustHttps(v bool) *GetGatewayDomainDetailResponseBodyData {
	s.MustHttps = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetName(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetProtocol(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Protocol = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetSans(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Sans = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetTlsMax(v string) *GetGatewayDomainDetailResponseBodyData {
	s.TlsMax = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetTlsMin(v string) *GetGatewayDomainDetailResponseBodyData {
	s.TlsMin = &v
	return s
}

type GetGatewayDomainDetailResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailResponse) SetHeaders(v map[string]*string) *GetGatewayDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayDomainDetailResponse) SetStatusCode(v int32) *GetGatewayDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayDomainDetailResponse) SetBody(v *GetGatewayDomainDetailResponseBody) *GetGatewayDomainDetailResponse {
	s.Body = v
	return s
}

type GetGatewayOptionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s GetGatewayOptionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayOptionRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayOptionRequest) SetAcceptLanguage(v string) *GetGatewayOptionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayOptionRequest) SetGatewayId(v int64) *GetGatewayOptionRequest {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayOptionRequest) SetGatewayUniqueId(v string) *GetGatewayOptionRequest {
	s.GatewayUniqueId = &v
	return s
}

type GetGatewayOptionResponseBody struct {
	// The status code returned. The value 200 indicates that the request is successfully processed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The detailed configurations of the gateway.
	//
	// *   **TraceDetails**: the sampling description of Managed Service for OpenTelemetry. Content: TraceEnabled indicates whether Managed Service for OpenTelemetry is activated. Sample indicates the sampling rate of Managed Service for OpenTelemetry.
	// *   **LogConfigDetails**: the description of Simple Log Service. Content: LogEnabled indicates whether Simple Log Service is activated. ProjectName indicates the Simple Log Service project to which logs are delivered. LogStoreName indicates the name of the Logstore.
	// *   **EnableHardwareAcceleration**: indicates whether hardware acceleration is enabled.
	// *   **DisableHttp2Alpn**: indicates whether the HTTP/2 protocol is disabled.
	// *   **EnableWaf**: indicates whether Web Application Firewall (WAF) is enabled.
	Data *GatewayOption `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayOptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayOptionResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayOptionResponseBody) SetCode(v int32) *GetGatewayOptionResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetData(v *GatewayOption) *GetGatewayOptionResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayOptionResponseBody) SetHttpStatusCode(v int32) *GetGatewayOptionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetMessage(v string) *GetGatewayOptionResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetRequestId(v string) *GetGatewayOptionResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetSuccess(v bool) *GetGatewayOptionResponseBody {
	s.Success = &v
	return s
}

type GetGatewayOptionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayOptionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayOptionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayOptionResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayOptionResponse) SetHeaders(v map[string]*string) *GetGatewayOptionResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayOptionResponse) SetStatusCode(v int32) *GetGatewayOptionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayOptionResponse) SetBody(v *GetGatewayOptionResponseBody) *GetGatewayOptionResponse {
	s.Body = v
	return s
}

type GetGatewayRouteDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *int64 `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s GetGatewayRouteDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailRequest) SetAcceptLanguage(v string) *GetGatewayRouteDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayRouteDetailRequest) SetGatewayUniqueId(v string) *GetGatewayRouteDetailRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayRouteDetailRequest) SetRouteId(v int64) *GetGatewayRouteDetailRequest {
	s.RouteId = &v
	return s
}

type GetGatewayRouteDetailResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *GetGatewayRouteDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayRouteDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBody) SetCode(v int32) *GetGatewayRouteDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetData(v *GetGatewayRouteDetailResponseBodyData) *GetGatewayRouteDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetHttpStatusCode(v int32) *GetGatewayRouteDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetMessage(v string) *GetGatewayRouteDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetRequestId(v string) *GetGatewayRouteDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetSuccess(v bool) *GetGatewayRouteDetailResponseBody {
	s.Success = &v
	return s
}

type GetGatewayRouteDetailResponseBodyData struct {
	// The status of Application High Availability Service (AHAS).
	AhasStatus *int32 `json:"AhasStatus,omitempty" xml:"AhasStatus,omitempty"`
	// The configuration for cross-origin resource sharing (CORS).
	Cors *GetGatewayRouteDetailResponseBodyDataCors `json:"Cors,omitempty" xml:"Cors,omitempty" type:"Struct"`
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The default service name.
	DefaultServiceName *string `json:"DefaultServiceName,omitempty" xml:"DefaultServiceName,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponse *GetGatewayRouteDetailResponseBodyDataDirectResponse `json:"DirectResponse,omitempty" xml:"DirectResponse,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The IDs of domains.
	DomainIdList []*int64 `json:"DomainIdList,omitempty" xml:"DomainIdList,omitempty" type:"Repeated"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The list of domain names.
	DomainNameList []*string `json:"DomainNameList,omitempty" xml:"DomainNameList,omitempty" type:"Repeated"`
	// Indicates whether Web Application Firewall (WAF) is activated.
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Indicates whether the Fallback service is enabled.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information of the Fallback service.
	FallbackServices []*GetGatewayRouteDetailResponseBodyDataFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// 
	FlowMirror *GetGatewayRouteDetailResponseBodyDataFlowMirror `json:"FlowMirror,omitempty" xml:"FlowMirror,omitempty" type:"Struct"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The information about the rewrite policy.
	HTTPRewrite *GetGatewayRouteDetailResponseBodyDataHTTPRewrite `json:"HTTPRewrite,omitempty" xml:"HTTPRewrite,omitempty" type:"Struct"`
	// The header settings.
	HeaderOp *GetGatewayRouteDetailResponseBodyDataHeaderOp `json:"HeaderOp,omitempty" xml:"HeaderOp,omitempty" type:"Struct"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The routing policy in a JSON string.
	Policies *string `json:"Policies,omitempty" xml:"Policies,omitempty"`
	// The matching conditions.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The configuration of the redirection.
	Redirect *GetGatewayRouteDetailResponseBodyDataRedirect `json:"Redirect,omitempty" xml:"Redirect,omitempty" type:"Struct"`
	// The retry configuration.
	Retry *GetGatewayRouteDetailResponseBodyDataRetry `json:"Retry,omitempty" xml:"Retry,omitempty" type:"Struct"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about route matching.
	RoutePredicates *GetGatewayRouteDetailResponseBodyDataRoutePredicates `json:"RoutePredicates,omitempty" xml:"RoutePredicates,omitempty" type:"Struct"`
	// The services.
	RouteServices []*GetGatewayRouteDetailResponseBodyDataRouteServices `json:"RouteServices,omitempty" xml:"RouteServices,omitempty" type:"Repeated"`
	// The configurations of services.
	Services *string `json:"Services,omitempty" xml:"Services,omitempty"`
	// The status of the route. Valid values:
	//
	// *   0: unpublished
	// *   2: publishing
	// *   3: published
	// *   4: editing (updated but not published)
	// *   5: unpublishing
	// *   6: unavailable
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The timeout configuration.
	Timeout *GetGatewayRouteDetailResponseBodyDataTimeout `json:"Timeout,omitempty" xml:"Timeout,omitempty" type:"Struct"`
}

func (s GetGatewayRouteDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyData) SetAhasStatus(v int32) *GetGatewayRouteDetailResponseBodyData {
	s.AhasStatus = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetCors(v *GetGatewayRouteDetailResponseBodyDataCors) *GetGatewayRouteDetailResponseBodyData {
	s.Cors = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDefaultServiceId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.DefaultServiceId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDefaultServiceName(v string) *GetGatewayRouteDetailResponseBodyData {
	s.DefaultServiceName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDestinationType(v string) *GetGatewayRouteDetailResponseBodyData {
	s.DestinationType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDirectResponse(v *GetGatewayRouteDetailResponseBodyDataDirectResponse) *GetGatewayRouteDetailResponseBodyData {
	s.DirectResponse = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.DomainId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainIdList(v []*int64) *GetGatewayRouteDetailResponseBodyData {
	s.DomainIdList = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainName(v string) *GetGatewayRouteDetailResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainNameList(v []*string) *GetGatewayRouteDetailResponseBodyData {
	s.DomainNameList = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetEnableWaf(v bool) *GetGatewayRouteDetailResponseBodyData {
	s.EnableWaf = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetFallback(v bool) *GetGatewayRouteDetailResponseBodyData {
	s.Fallback = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetFallbackServices(v []*GetGatewayRouteDetailResponseBodyDataFallbackServices) *GetGatewayRouteDetailResponseBodyData {
	s.FallbackServices = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetFlowMirror(v *GetGatewayRouteDetailResponseBodyDataFlowMirror) *GetGatewayRouteDetailResponseBodyData {
	s.FlowMirror = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGatewayId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayRouteDetailResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGmtCreate(v string) *GetGatewayRouteDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGmtModified(v string) *GetGatewayRouteDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetHTTPRewrite(v *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) *GetGatewayRouteDetailResponseBodyData {
	s.HTTPRewrite = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetHeaderOp(v *GetGatewayRouteDetailResponseBodyDataHeaderOp) *GetGatewayRouteDetailResponseBodyData {
	s.HeaderOp = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetName(v string) *GetGatewayRouteDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetPolicies(v string) *GetGatewayRouteDetailResponseBodyData {
	s.Policies = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetPredicates(v string) *GetGatewayRouteDetailResponseBodyData {
	s.Predicates = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRedirect(v *GetGatewayRouteDetailResponseBodyDataRedirect) *GetGatewayRouteDetailResponseBodyData {
	s.Redirect = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRetry(v *GetGatewayRouteDetailResponseBodyDataRetry) *GetGatewayRouteDetailResponseBodyData {
	s.Retry = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRouteOrder(v int32) *GetGatewayRouteDetailResponseBodyData {
	s.RouteOrder = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRoutePredicates(v *GetGatewayRouteDetailResponseBodyDataRoutePredicates) *GetGatewayRouteDetailResponseBodyData {
	s.RoutePredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRouteServices(v []*GetGatewayRouteDetailResponseBodyDataRouteServices) *GetGatewayRouteDetailResponseBodyData {
	s.RouteServices = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetServices(v string) *GetGatewayRouteDetailResponseBodyData {
	s.Services = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetStatus(v int32) *GetGatewayRouteDetailResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetTimeout(v *GetGatewayRouteDetailResponseBodyDataTimeout) *GetGatewayRouteDetailResponseBodyData {
	s.Timeout = v
	return s
}

type GetGatewayRouteDetailResponseBodyDataCors struct {
	// The credentials allowed.
	AllowCredentials *bool `json:"AllowCredentials,omitempty" xml:"AllowCredentials,omitempty"`
	// The headers allowed.
	AllowHeaders *string `json:"AllowHeaders,omitempty" xml:"AllowHeaders,omitempty"`
	// The methods allowed.
	AllowMethods *string `json:"AllowMethods,omitempty" xml:"AllowMethods,omitempty"`
	// The origins allowed.
	AllowOrigins *string `json:"AllowOrigins,omitempty" xml:"AllowOrigins,omitempty"`
	// The response headers.
	ExposeHeaders *string `json:"ExposeHeaders,omitempty" xml:"ExposeHeaders,omitempty"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int64 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataCors) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataCors) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowCredentials(v bool) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowCredentials = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowHeaders(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowHeaders = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowMethods(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowMethods = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowOrigins(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowOrigins = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetExposeHeaders(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.ExposeHeaders = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetTimeUnit(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.TimeUnit = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetUnitNum(v int64) *GetGatewayRouteDetailResponseBodyDataCors {
	s.UnitNum = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataDirectResponse struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataDirectResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataDirectResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataDirectResponse) SetBody(v string) *GetGatewayRouteDetailResponseBodyDataDirectResponse {
	s.Body = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataDirectResponse) SetCode(v int32) *GetGatewayRouteDetailResponseBodyDataDirectResponse {
	s.Code = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataFallbackServices struct {
	// The protocol type.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the service belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The service ID.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service name.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The port number of the service.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type of the service.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The service version.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataFallbackServices) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetAgreementType(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetGroupName(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.GroupName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetName(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Name = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetNamespace(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Namespace = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetPercent(v int32) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Percent = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetServiceId(v int64) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetServiceName(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.ServiceName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetServicePort(v int32) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetSourceType(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.SourceType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetVersion(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Version = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataFlowMirror struct {
	// %0-100
	Percentage *int32 `json:"Percentage,omitempty" xml:"Percentage,omitempty"`
	// 
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// 
	//
	// - on
	// - off
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// ID
	TargetServiceId *int64 `json:"TargetServiceId,omitempty" xml:"TargetServiceId,omitempty"`
	// 
	TargetServiceName *string `json:"TargetServiceName,omitempty" xml:"TargetServiceName,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataFlowMirror) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataFlowMirror) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataFlowMirror) SetPercentage(v int32) *GetGatewayRouteDetailResponseBodyDataFlowMirror {
	s.Percentage = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFlowMirror) SetPort(v int32) *GetGatewayRouteDetailResponseBodyDataFlowMirror {
	s.Port = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFlowMirror) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataFlowMirror {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFlowMirror) SetTargetServiceId(v int64) *GetGatewayRouteDetailResponseBodyDataFlowMirror {
	s.TargetServiceId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFlowMirror) SetTargetServiceName(v string) *GetGatewayRouteDetailResponseBodyDataFlowMirror {
	s.TargetServiceName = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataHTTPRewrite struct {
	// The hostname of the gateway.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The rewrite type.
	PathType *string `json:"PathType,omitempty" xml:"PathType,omitempty"`
	// The matching pattern.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
	// The status of the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The replacement.
	Substitution *string `json:"Substitution,omitempty" xml:"Substitution,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataHTTPRewrite) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataHTTPRewrite) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetHost(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Host = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetPath(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Path = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetPathType(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.PathType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetPattern(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Pattern = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetSubstitution(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Substitution = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataHeaderOp struct {
	// The information about headers.
	HeaderOpItems []*GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems `json:"HeaderOpItems,omitempty" xml:"HeaderOpItems,omitempty" type:"Repeated"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOp) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOp) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOp) SetHeaderOpItems(v []*GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) *GetGatewayRouteDetailResponseBodyDataHeaderOp {
	s.HeaderOpItems = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOp) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOp {
	s.Status = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems struct {
	// The request or response.
	DirectionType *string `json:"DirectionType,omitempty" xml:"DirectionType,omitempty"`
	// The header key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The type of the operation.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The header value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetDirectionType(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.DirectionType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetKey(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.Key = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetOpType(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.OpType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetValue(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.Value = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRedirect struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRedirect) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRedirect) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRedirect) SetCode(v int32) *GetGatewayRouteDetailResponseBodyDataRedirect {
	s.Code = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRedirect) SetHost(v string) *GetGatewayRouteDetailResponseBodyDataRedirect {
	s.Host = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRedirect) SetPath(v string) *GetGatewayRouteDetailResponseBodyDataRedirect {
	s.Path = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRetry struct {
	// The number of retries allowed.
	Attempts *int32 `json:"Attempts,omitempty" xml:"Attempts,omitempty"`
	// The HTTP status codes.
	HttpCodes []*string `json:"HttpCodes,omitempty" xml:"HttpCodes,omitempty" type:"Repeated"`
	// The retry condition.
	RetryOn []*string `json:"RetryOn,omitempty" xml:"RetryOn,omitempty" type:"Repeated"`
	// The retry status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRetry) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRetry) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetAttempts(v int32) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.Attempts = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetHttpCodes(v []*string) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.HttpCodes = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetRetryOn(v []*string) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.RetryOn = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.Status = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicates struct {
	// The information about header matching.
	HeaderPredicates []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about route matching.
	PathPredicates *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The information about parameter matching.
	QueryPredicates []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetHeaderPredicates(v []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.HeaderPredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetMethodPredicates(v []*string) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.MethodPredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetPathPredicates(v *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.PathPredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetQueryPredicates(v []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.QueryPredicates = v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The route type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) SetKey(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) SetType(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) SetValue(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates struct {
	// Indicates whether case sensitivity is ignored.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) SetIgnoreCase(v bool) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) SetPath(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) SetType(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates {
	s.Type = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates struct {
	// The parameter name.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The route type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) SetKey(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) SetType(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) SetValue(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates {
	s.Value = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRouteServices struct {
	// The protocol type.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The service name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The service ID.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service name.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The port number of the service.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type of the service.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The service version.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRouteServices) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRouteServices) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetAgreementType(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.AgreementType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetGroupName(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.GroupName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetName(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Name = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetNamespace(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Namespace = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetPercent(v int32) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Percent = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetServiceId(v int64) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.ServiceId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetServiceName(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.ServiceName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetServicePort(v int32) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.ServicePort = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetSourceType(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.SourceType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetVersion(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Version = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataTimeout struct {
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int32 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataTimeout) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataTimeout) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataTimeout) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataTimeout {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataTimeout) SetTimeUnit(v string) *GetGatewayRouteDetailResponseBodyDataTimeout {
	s.TimeUnit = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataTimeout) SetUnitNum(v int32) *GetGatewayRouteDetailResponseBodyDataTimeout {
	s.UnitNum = &v
	return s
}

type GetGatewayRouteDetailResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayRouteDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayRouteDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponse) SetHeaders(v map[string]*string) *GetGatewayRouteDetailResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayRouteDetailResponse) SetStatusCode(v int32) *GetGatewayRouteDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayRouteDetailResponse) SetBody(v *GetGatewayRouteDetailResponseBody) *GetGatewayRouteDetailResponse {
	s.Body = v
	return s
}

type GetGatewayServiceDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s GetGatewayServiceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailRequest) SetAcceptLanguage(v string) *GetGatewayServiceDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayServiceDetailRequest) SetGatewayUniqueId(v string) *GetGatewayServiceDetailRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayServiceDetailRequest) SetServiceId(v int64) *GetGatewayServiceDetailRequest {
	s.ServiceId = &v
	return s
}

type GetGatewayServiceDetailResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GetGatewayServiceDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayServiceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBody) SetCode(v int32) *GetGatewayServiceDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetData(v *GetGatewayServiceDetailResponseBodyData) *GetGatewayServiceDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetHttpStatusCode(v int32) *GetGatewayServiceDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetMessage(v string) *GetGatewayServiceDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetRequestId(v string) *GetGatewayServiceDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetSuccess(v bool) *GetGatewayServiceDetailResponseBody {
	s.Success = &v
	return s
}

type GetGatewayServiceDetailResponseBodyData struct {
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic policy of the service.
	GatewayTrafficPolicy *TrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// Indicates whether the health check is enabled.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The status of the health check. Valid values:
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The ID of the service.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The IP address of the service.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The details of the tag.
	LabelDetails []*GetGatewayServiceDetailResponseBodyDataLabelDetails `json:"LabelDetails,omitempty" xml:"LabelDetails,omitempty" type:"Repeated"`
	// The basic information about the service.
	MetaInfo *string `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The traffic policy of service ports.
	PortTrafficPolicyList []*GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList `json:"PortTrafficPolicyList,omitempty" xml:"PortTrafficPolicyList,omitempty" type:"Repeated"`
	// The array of service ports.
	Ports []*int32 `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// The name of the service registered with the service registry.
	ServiceNameInRegistry *string `json:"ServiceNameInRegistry,omitempty" xml:"ServiceNameInRegistry,omitempty"`
	// The protocol of the service.
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
	// The ID of the service source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The source type of the service.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The details of versions.
	VersionDetails []*GetGatewayServiceDetailResponseBodyDataVersionDetails `json:"VersionDetails,omitempty" xml:"VersionDetails,omitempty" type:"Repeated"`
	// The version of the service.
	Versions []*GetGatewayServiceDetailResponseBodyDataVersions `json:"Versions,omitempty" xml:"Versions,omitempty" type:"Repeated"`
}

func (s GetGatewayServiceDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGatewayId(v int64) *GetGatewayServiceDetailResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGatewayTrafficPolicy(v *TrafficPolicy) *GetGatewayServiceDetailResponseBodyData {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGmtCreate(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGmtModified(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGroupName(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetHealthCheck(v string) *GetGatewayServiceDetailResponseBodyData {
	s.HealthCheck = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetHealthStatus(v string) *GetGatewayServiceDetailResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetId(v int64) *GetGatewayServiceDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetIps(v []*string) *GetGatewayServiceDetailResponseBodyData {
	s.Ips = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetLabelDetails(v []*GetGatewayServiceDetailResponseBodyDataLabelDetails) *GetGatewayServiceDetailResponseBodyData {
	s.LabelDetails = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetMetaInfo(v string) *GetGatewayServiceDetailResponseBodyData {
	s.MetaInfo = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetName(v string) *GetGatewayServiceDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetNamespace(v string) *GetGatewayServiceDetailResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetPortTrafficPolicyList(v []*GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) *GetGatewayServiceDetailResponseBodyData {
	s.PortTrafficPolicyList = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetPorts(v []*int32) *GetGatewayServiceDetailResponseBodyData {
	s.Ports = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetServiceNameInRegistry(v string) *GetGatewayServiceDetailResponseBodyData {
	s.ServiceNameInRegistry = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetServiceProtocol(v string) *GetGatewayServiceDetailResponseBodyData {
	s.ServiceProtocol = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetSourceId(v int64) *GetGatewayServiceDetailResponseBodyData {
	s.SourceId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetSourceType(v string) *GetGatewayServiceDetailResponseBodyData {
	s.SourceType = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetVersionDetails(v []*GetGatewayServiceDetailResponseBodyDataVersionDetails) *GetGatewayServiceDetailResponseBodyData {
	s.VersionDetails = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetVersions(v []*GetGatewayServiceDetailResponseBodyDataVersions) *GetGatewayServiceDetailResponseBodyData {
	s.Versions = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataLabelDetails struct {
	// The tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag values.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s GetGatewayServiceDetailResponseBodyDataLabelDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataLabelDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataLabelDetails) SetKey(v string) *GetGatewayServiceDetailResponseBodyDataLabelDetails {
	s.Key = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataLabelDetails) SetValues(v []*string) *GetGatewayServiceDetailResponseBodyDataLabelDetails {
	s.Values = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList struct {
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the service was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the service was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the port configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The service ID.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The traffic policy.
	TrafficPolicy *TrafficPolicy `json:"TrafficPolicy,omitempty" xml:"TrafficPolicy,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetGatewayUniqueId(v string) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetGmtCreate(v string) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetGmtModified(v string) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetId(v int64) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.Id = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetServiceId(v int64) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.ServiceId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetServicePort(v int32) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.ServicePort = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetTrafficPolicy(v *TrafficPolicy) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.TrafficPolicy = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersionDetails struct {
	// The number of instances.
	EndpointNum *int32 `json:"EndpointNum,omitempty" xml:"EndpointNum,omitempty"`
	// The percentage of instances.
	EndpointNumPercent *string `json:"EndpointNumPercent,omitempty" xml:"EndpointNumPercent,omitempty"`
	// The version of the service.
	ServiceVersion *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty" type:"Struct"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetails) SetEndpointNum(v int32) *GetGatewayServiceDetailResponseBodyDataVersionDetails {
	s.EndpointNum = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetails) SetEndpointNumPercent(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetails {
	s.EndpointNumPercent = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetails) SetServiceVersion(v *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) *GetGatewayServiceDetailResponseBodyDataVersionDetails {
	s.ServiceVersion = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion struct {
	// The tags.
	Labels []*GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The version number.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) SetLabels(v []*GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion {
	s.Labels = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) SetName(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion {
	s.Name = &v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels struct {
	// The tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) SetKey(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels {
	s.Key = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) SetValue(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels {
	s.Value = &v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersions struct {
	// The tag.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The type of the service.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersions) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersions) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersions) SetLabel(v string) *GetGatewayServiceDetailResponseBodyDataVersions {
	s.Label = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersions) SetType(v string) *GetGatewayServiceDetailResponseBodyDataVersions {
	s.Type = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersions) SetValue(v string) *GetGatewayServiceDetailResponseBodyDataVersions {
	s.Value = &v
	return s
}

type GetGatewayServiceDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayServiceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayServiceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponse) SetHeaders(v map[string]*string) *GetGatewayServiceDetailResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayServiceDetailResponse) SetStatusCode(v int32) *GetGatewayServiceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayServiceDetailResponse) SetBody(v *GetGatewayServiceDetailResponseBody) *GetGatewayServiceDetailResponse {
	s.Body = v
	return s
}

type GetGovernanceKubernetesClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetGovernanceKubernetesClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterRequest) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterRequest) SetAcceptLanguage(v string) *GetGovernanceKubernetesClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGovernanceKubernetesClusterRequest) SetClusterId(v string) *GetGovernanceKubernetesClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *GetGovernanceKubernetesClusterRequest) SetRegionId(v string) *GetGovernanceKubernetesClusterRequest {
	s.RegionId = &v
	return s
}

type GetGovernanceKubernetesClusterResponseBody struct {
	// The details of the data.
	Data *GetGovernanceKubernetesClusterResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGovernanceKubernetesClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponseBody) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetData(v *GetGovernanceKubernetesClusterResponseBodyData) *GetGovernanceKubernetesClusterResponseBody {
	s.Data = v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetMessage(v string) *GetGovernanceKubernetesClusterResponseBody {
	s.Message = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetRequestId(v string) *GetGovernanceKubernetesClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetSuccess(v bool) *GetGovernanceKubernetesClusterResponseBody {
	s.Success = &v
	return s
}

type GetGovernanceKubernetesClusterResponseBodyData struct {
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The version of Kubernetes.
	K8sVersion *string `json:"K8sVersion,omitempty" xml:"K8sVersion,omitempty"`
	// The information of the namespace.
	NamespaceInfos *string `json:"NamespaceInfos,omitempty" xml:"NamespaceInfos,omitempty"`
	// The queried namespaces.
	Namespaces []*GetGovernanceKubernetesClusterResponseBodyDataNamespaces `json:"Namespaces,omitempty" xml:"Namespaces,omitempty" type:"Repeated"`
	// The time when the pilot component was started.
	PilotStartTime *string `json:"PilotStartTime,omitempty" xml:"PilotStartTime,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The time of the last modification.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s GetGovernanceKubernetesClusterResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetClusterId(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetClusterName(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetK8sVersion(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.K8sVersion = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetNamespaceInfos(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.NamespaceInfos = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetNamespaces(v []*GetGovernanceKubernetesClusterResponseBodyDataNamespaces) *GetGovernanceKubernetesClusterResponseBodyData {
	s.Namespaces = v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetPilotStartTime(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.PilotStartTime = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetRegion(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.Region = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetUpdateTime(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.UpdateTime = &v
	return s
}

type GetGovernanceKubernetesClusterResponseBodyDataNamespaces struct {
	// The name of the MSE namespace that you want to access.
	MseNamespace *string `json:"MseNamespace,omitempty" xml:"MseNamespace,omitempty"`
	// The name of the namespace in the ACK cluster.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetGovernanceKubernetesClusterResponseBodyDataNamespaces) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponseBodyDataNamespaces) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponseBodyDataNamespaces) SetMseNamespace(v string) *GetGovernanceKubernetesClusterResponseBodyDataNamespaces {
	s.MseNamespace = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyDataNamespaces) SetName(v string) *GetGovernanceKubernetesClusterResponseBodyDataNamespaces {
	s.Name = &v
	return s
}

type GetGovernanceKubernetesClusterResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGovernanceKubernetesClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGovernanceKubernetesClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponse) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponse) SetHeaders(v map[string]*string) *GetGovernanceKubernetesClusterResponse {
	s.Headers = v
	return s
}

func (s *GetGovernanceKubernetesClusterResponse) SetStatusCode(v int32) *GetGovernanceKubernetesClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponse) SetBody(v *GetGovernanceKubernetesClusterResponseBody) *GetGovernanceKubernetesClusterResponse {
	s.Body = v
	return s
}

type GetImageRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The version number of the current instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s GetImageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImageRequest) GoString() string {
	return s.String()
}

func (s *GetImageRequest) SetAcceptLanguage(v string) *GetImageRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetImageRequest) SetVersionCode(v string) *GetImageRequest {
	s.VersionCode = &v
	return s
}

type GetImageResponseBody struct {
	// The details of the data.
	Data *GetImageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImageResponseBody) GoString() string {
	return s.String()
}

func (s *GetImageResponseBody) SetData(v *GetImageResponseBodyData) *GetImageResponseBody {
	s.Data = v
	return s
}

func (s *GetImageResponseBody) SetErrorCode(v string) *GetImageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetImageResponseBody) SetHttpCode(v string) *GetImageResponseBody {
	s.HttpCode = &v
	return s
}

func (s *GetImageResponseBody) SetMessage(v string) *GetImageResponseBody {
	s.Message = &v
	return s
}

func (s *GetImageResponseBody) SetRequestId(v string) *GetImageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetImageResponseBody) SetSuccess(v bool) *GetImageResponseBody {
	s.Success = &v
	return s
}

type GetImageResponseBodyData struct {
	// The full version number of the current instance image. The parameter is in the X.X.X.X format.
	CurrentVersionFullShowName *string `json:"CurrentVersionFullShowName,omitempty" xml:"CurrentVersionFullShowName,omitempty"`
	// The URL of the changelog for the maximum version to which the current version can be upgraded.
	MaxVersionChangelogUrl *string `json:"MaxVersionChangelogUrl,omitempty" xml:"MaxVersionChangelogUrl,omitempty"`
	// The code of the maximum version to which the current version can be upgraded.
	MaxVersionCode *string `json:"MaxVersionCode,omitempty" xml:"MaxVersionCode,omitempty"`
	// The full number of the maximum version to which the current version can be upgraded.
	MaxVersionFullShowName *string `json:"MaxVersionFullShowName,omitempty" xml:"MaxVersionFullShowName,omitempty"`
}

func (s GetImageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetImageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetImageResponseBodyData) SetCurrentVersionFullShowName(v string) *GetImageResponseBodyData {
	s.CurrentVersionFullShowName = &v
	return s
}

func (s *GetImageResponseBodyData) SetMaxVersionChangelogUrl(v string) *GetImageResponseBodyData {
	s.MaxVersionChangelogUrl = &v
	return s
}

func (s *GetImageResponseBodyData) SetMaxVersionCode(v string) *GetImageResponseBodyData {
	s.MaxVersionCode = &v
	return s
}

func (s *GetImageResponseBodyData) SetMaxVersionFullShowName(v string) *GetImageResponseBodyData {
	s.MaxVersionFullShowName = &v
	return s
}

type GetImageResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetImageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImageResponse) GoString() string {
	return s.String()
}

func (s *GetImageResponse) SetHeaders(v map[string]*string) *GetImageResponse {
	s.Headers = v
	return s
}

func (s *GetImageResponse) SetStatusCode(v int32) *GetImageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImageResponse) SetBody(v *GetImageResponseBody) *GetImageResponse {
	s.Body = v
	return s
}

type GetImportFileUrlRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The file type.
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s GetImportFileUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlRequest) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlRequest) SetAcceptLanguage(v string) *GetImportFileUrlRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetImportFileUrlRequest) SetContentType(v string) *GetImportFileUrlRequest {
	s.ContentType = &v
	return s
}

func (s *GetImportFileUrlRequest) SetInstanceId(v string) *GetImportFileUrlRequest {
	s.InstanceId = &v
	return s
}

func (s *GetImportFileUrlRequest) SetNamespaceId(v string) *GetImportFileUrlRequest {
	s.NamespaceId = &v
	return s
}

type GetImportFileUrlResponseBody struct {
	// The error code returned if the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GetImportFileUrlResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \\*\\*%s\\*\\* variable in the **ErrMessage** parameter.\n\n>  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	// *   `true`: The request was successful.
	// *  `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetImportFileUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlResponseBody) SetCode(v int32) *GetImportFileUrlResponseBody {
	s.Code = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetData(v *GetImportFileUrlResponseBodyData) *GetImportFileUrlResponseBody {
	s.Data = v
	return s
}

func (s *GetImportFileUrlResponseBody) SetDynamicMessage(v string) *GetImportFileUrlResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetErrorCode(v string) *GetImportFileUrlResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetHttpStatusCode(v int32) *GetImportFileUrlResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetMessage(v string) *GetImportFileUrlResponseBody {
	s.Message = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetRequestId(v string) *GetImportFileUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetSuccess(v bool) *GetImportFileUrlResponseBody {
	s.Success = &v
	return s
}

type GetImportFileUrlResponseBodyData struct {
	// The URL that is used to upload the configuration file.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetImportFileUrlResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlResponseBodyData) SetUrl(v string) *GetImportFileUrlResponseBodyData {
	s.Url = &v
	return s
}

type GetImportFileUrlResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetImportFileUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetImportFileUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlResponse) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlResponse) SetHeaders(v map[string]*string) *GetImportFileUrlResponse {
	s.Headers = v
	return s
}

func (s *GetImportFileUrlResponse) SetStatusCode(v int32) *GetImportFileUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImportFileUrlResponse) SetBody(v *GetImportFileUrlResponseBody) *GetImportFileUrlResponse {
	s.Body = v
	return s
}

type GetKubernetesSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to obtain the information about all Kubernetes clusters. If you set the value to false, only the information about unassociated clusters is obtained.
	IsAll *bool `json:"IsAll,omitempty" xml:"IsAll,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetKubernetesSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceRequest) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceRequest) SetAcceptLanguage(v string) *GetKubernetesSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetKubernetesSourceRequest) SetGatewayUniqueId(v string) *GetKubernetesSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetKubernetesSourceRequest) SetIsAll(v bool) *GetKubernetesSourceRequest {
	s.IsAll = &v
	return s
}

func (s *GetKubernetesSourceRequest) SetVpcId(v string) *GetKubernetesSourceRequest {
	s.VpcId = &v
	return s
}

type GetKubernetesSourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*GetKubernetesSourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetKubernetesSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceResponseBody) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceResponseBody) SetCode(v int32) *GetKubernetesSourceResponseBody {
	s.Code = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetData(v []*GetKubernetesSourceResponseBodyData) *GetKubernetesSourceResponseBody {
	s.Data = v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetHttpStatusCode(v int32) *GetKubernetesSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetMessage(v string) *GetKubernetesSourceResponseBody {
	s.Message = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetRequestId(v string) *GetKubernetesSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetSuccess(v bool) *GetKubernetesSourceResponseBody {
	s.Success = &v
	return s
}

type GetKubernetesSourceResponseBodyData struct {
	// The ID of the ACK cluster.
	Cluster *string `json:"Cluster,omitempty" xml:"Cluster,omitempty"`
	// The name of the ACK cluster.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetKubernetesSourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceResponseBodyData) SetCluster(v string) *GetKubernetesSourceResponseBodyData {
	s.Cluster = &v
	return s
}

func (s *GetKubernetesSourceResponseBodyData) SetName(v string) *GetKubernetesSourceResponseBodyData {
	s.Name = &v
	return s
}

type GetKubernetesSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetKubernetesSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetKubernetesSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceResponse) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceResponse) SetHeaders(v map[string]*string) *GetKubernetesSourceResponse {
	s.Headers = v
	return s
}

func (s *GetKubernetesSourceResponse) SetStatusCode(v int32) *GetKubernetesSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetKubernetesSourceResponse) SetBody(v *GetKubernetesSourceResponseBody) *GetKubernetesSourceResponse {
	s.Body = v
	return s
}

type GetLosslessRuleByAppRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The name of the MSE namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetLosslessRuleByAppRequest) String() string {
	return tea.Prettify(s)
}

func (s GetLosslessRuleByAppRequest) GoString() string {
	return s.String()
}

func (s *GetLosslessRuleByAppRequest) SetAcceptLanguage(v string) *GetLosslessRuleByAppRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetLosslessRuleByAppRequest) SetAppId(v string) *GetLosslessRuleByAppRequest {
	s.AppId = &v
	return s
}

func (s *GetLosslessRuleByAppRequest) SetAppName(v string) *GetLosslessRuleByAppRequest {
	s.AppName = &v
	return s
}

func (s *GetLosslessRuleByAppRequest) SetNamespace(v string) *GetLosslessRuleByAppRequest {
	s.Namespace = &v
	return s
}

func (s *GetLosslessRuleByAppRequest) SetRegionId(v string) *GetLosslessRuleByAppRequest {
	s.RegionId = &v
	return s
}

type GetLosslessRuleByAppResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *GetLosslessRuleByAppResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetLosslessRuleByAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetLosslessRuleByAppResponseBody) GoString() string {
	return s.String()
}

func (s *GetLosslessRuleByAppResponseBody) SetCode(v int32) *GetLosslessRuleByAppResponseBody {
	s.Code = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBody) SetData(v *GetLosslessRuleByAppResponseBodyData) *GetLosslessRuleByAppResponseBody {
	s.Data = v
	return s
}

func (s *GetLosslessRuleByAppResponseBody) SetErrorCode(v string) *GetLosslessRuleByAppResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBody) SetHttpStatusCode(v int32) *GetLosslessRuleByAppResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBody) SetMessage(v string) *GetLosslessRuleByAppResponseBody {
	s.Message = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBody) SetRequestId(v string) *GetLosslessRuleByAppResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBody) SetSuccess(v bool) *GetLosslessRuleByAppResponseBody {
	s.Success = &v
	return s
}

type GetLosslessRuleByAppResponseBodyData struct {
	// Indicates whether service registration is complete before readiness probe.
	Aligned *bool `json:"Aligned,omitempty" xml:"Aligned,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The number of instances.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The registration latency. Unit: seconds.
	DelayTime *int32 `json:"DelayTime,omitempty" xml:"DelayTime,omitempty"`
	// Indicates whether graceful start is enabled. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The slope of the prefetching curve.
	FuncType *int32 `json:"FuncType,omitempty" xml:"FuncType,omitempty"`
	// Indicates whether online and offline processing details are displayed.
	LossLessDetail *bool `json:"LossLessDetail,omitempty" xml:"LossLessDetail,omitempty"`
	// Indicates whether notification is enabled.
	Notice *bool `json:"Notice,omitempty" xml:"Notice,omitempty"`
	// Indicates whether service prefetching is complete before readiness probe.
	Related *bool `json:"Related,omitempty" xml:"Related,omitempty"`
	// The prefetching duration. Unit: seconds.
	WarmupTime *int32 `json:"WarmupTime,omitempty" xml:"WarmupTime,omitempty"`
}

func (s GetLosslessRuleByAppResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetLosslessRuleByAppResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetLosslessRuleByAppResponseBodyData) SetAligned(v bool) *GetLosslessRuleByAppResponseBodyData {
	s.Aligned = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetAppId(v string) *GetLosslessRuleByAppResponseBodyData {
	s.AppId = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetAppName(v string) *GetLosslessRuleByAppResponseBodyData {
	s.AppName = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetCount(v int32) *GetLosslessRuleByAppResponseBodyData {
	s.Count = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetDelayTime(v int32) *GetLosslessRuleByAppResponseBodyData {
	s.DelayTime = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetEnable(v bool) *GetLosslessRuleByAppResponseBodyData {
	s.Enable = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetFuncType(v int32) *GetLosslessRuleByAppResponseBodyData {
	s.FuncType = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetLossLessDetail(v bool) *GetLosslessRuleByAppResponseBodyData {
	s.LossLessDetail = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetNotice(v bool) *GetLosslessRuleByAppResponseBodyData {
	s.Notice = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetRelated(v bool) *GetLosslessRuleByAppResponseBodyData {
	s.Related = &v
	return s
}

func (s *GetLosslessRuleByAppResponseBodyData) SetWarmupTime(v int32) *GetLosslessRuleByAppResponseBodyData {
	s.WarmupTime = &v
	return s
}

type GetLosslessRuleByAppResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetLosslessRuleByAppResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLosslessRuleByAppResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLosslessRuleByAppResponse) GoString() string {
	return s.String()
}

func (s *GetLosslessRuleByAppResponse) SetHeaders(v map[string]*string) *GetLosslessRuleByAppResponse {
	s.Headers = v
	return s
}

func (s *GetLosslessRuleByAppResponse) SetStatusCode(v int32) *GetLosslessRuleByAppResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLosslessRuleByAppResponse) SetBody(v *GetLosslessRuleByAppResponseBody) *GetLosslessRuleByAppResponse {
	s.Body = v
	return s
}

type GetMseFeatureSwitchRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s GetMseFeatureSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMseFeatureSwitchRequest) GoString() string {
	return s.String()
}

func (s *GetMseFeatureSwitchRequest) SetAcceptLanguage(v string) *GetMseFeatureSwitchRequest {
	s.AcceptLanguage = &v
	return s
}

type GetMseFeatureSwitchResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result map[string]interface{} `json:"Result,omitempty" xml:"Result,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMseFeatureSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMseFeatureSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *GetMseFeatureSwitchResponseBody) SetErrorCode(v string) *GetMseFeatureSwitchResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetMessage(v string) *GetMseFeatureSwitchResponseBody {
	s.Message = &v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetRequestId(v string) *GetMseFeatureSwitchResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetResult(v map[string]interface{}) *GetMseFeatureSwitchResponseBody {
	s.Result = v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetSuccess(v bool) *GetMseFeatureSwitchResponseBody {
	s.Success = &v
	return s
}

type GetMseFeatureSwitchResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMseFeatureSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMseFeatureSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMseFeatureSwitchResponse) GoString() string {
	return s.String()
}

func (s *GetMseFeatureSwitchResponse) SetHeaders(v map[string]*string) *GetMseFeatureSwitchResponse {
	s.Headers = v
	return s
}

func (s *GetMseFeatureSwitchResponse) SetStatusCode(v int32) *GetMseFeatureSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMseFeatureSwitchResponse) SetBody(v *GetMseFeatureSwitchResponseBody) *GetMseFeatureSwitchResponse {
	s.Body = v
	return s
}

type GetMseSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The MSE engine type. Valid values:
	//
	// *   NACOS
	// *   ZOOKEEPER
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMseSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceRequest) GoString() string {
	return s.String()
}

func (s *GetMseSourceRequest) SetAcceptLanguage(v string) *GetMseSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetMseSourceRequest) SetGatewayUniqueId(v string) *GetMseSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetMseSourceRequest) SetType(v string) *GetMseSourceRequest {
	s.Type = &v
	return s
}

type GetMseSourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*GetMseSourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMseSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceResponseBody) GoString() string {
	return s.String()
}

func (s *GetMseSourceResponseBody) SetCode(v int32) *GetMseSourceResponseBody {
	s.Code = &v
	return s
}

func (s *GetMseSourceResponseBody) SetData(v []*GetMseSourceResponseBodyData) *GetMseSourceResponseBody {
	s.Data = v
	return s
}

func (s *GetMseSourceResponseBody) SetHttpStatusCode(v int32) *GetMseSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMseSourceResponseBody) SetMessage(v string) *GetMseSourceResponseBody {
	s.Message = &v
	return s
}

func (s *GetMseSourceResponseBody) SetRequestId(v string) *GetMseSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMseSourceResponseBody) SetSuccess(v bool) *GetMseSourceResponseBody {
	s.Success = &v
	return s
}

type GetMseSourceResponseBodyData struct {
	// The endpoint of the instance.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMseSourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMseSourceResponseBodyData) SetAddress(v string) *GetMseSourceResponseBodyData {
	s.Address = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetClusterId(v string) *GetMseSourceResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetInstanceId(v string) *GetMseSourceResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetName(v string) *GetMseSourceResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetType(v string) *GetMseSourceResponseBodyData {
	s.Type = &v
	return s
}

type GetMseSourceResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMseSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMseSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceResponse) GoString() string {
	return s.String()
}

func (s *GetMseSourceResponse) SetHeaders(v map[string]*string) *GetMseSourceResponse {
	s.Headers = v
	return s
}

func (s *GetMseSourceResponse) SetStatusCode(v int32) *GetMseSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMseSourceResponse) SetBody(v *GetMseSourceResponseBody) *GetMseSourceResponse {
	s.Body = v
	return s
}

type GetNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to perform a beta release. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Beta *bool `json:"Beta,omitempty" xml:"Beta,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s GetNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *GetNacosConfigRequest) SetAcceptLanguage(v string) *GetNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetNacosConfigRequest) SetBeta(v bool) *GetNacosConfigRequest {
	s.Beta = &v
	return s
}

func (s *GetNacosConfigRequest) SetDataId(v string) *GetNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *GetNacosConfigRequest) SetGroup(v string) *GetNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *GetNacosConfigRequest) SetInstanceId(v string) *GetNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *GetNacosConfigRequest) SetNamespaceId(v string) *GetNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

type GetNacosConfigResponseBody struct {
	// The configuration information.
	Configuration *GetNacosConfigResponseBodyConfiguration `json:"Configuration,omitempty" xml:"Configuration,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetNacosConfigResponseBody) SetConfiguration(v *GetNacosConfigResponseBodyConfiguration) *GetNacosConfigResponseBody {
	s.Configuration = v
	return s
}

func (s *GetNacosConfigResponseBody) SetErrorCode(v string) *GetNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNacosConfigResponseBody) SetMessage(v string) *GetNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetNacosConfigResponseBody) SetRequestId(v string) *GetNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNacosConfigResponseBody) SetSuccess(v bool) *GetNacosConfigResponseBody {
	s.Success = &v
	return s
}

type GetNacosConfigResponseBodyConfiguration struct {
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The list of IP addresses where the beta release of the configuration is performed.
	BetaIps *string `json:"BetaIps,omitempty" xml:"BetaIps,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The description of the configuration.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The encryption key.
	EncryptedDataKey *string `json:"EncryptedDataKey,omitempty" xml:"EncryptedDataKey,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The message digest of the configuration.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The tags of the configuration.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The format of the configuration.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetNacosConfigResponseBodyConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigResponseBodyConfiguration) GoString() string {
	return s.String()
}

func (s *GetNacosConfigResponseBodyConfiguration) SetAppName(v string) *GetNacosConfigResponseBodyConfiguration {
	s.AppName = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetBetaIps(v string) *GetNacosConfigResponseBodyConfiguration {
	s.BetaIps = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetContent(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Content = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetDataId(v string) *GetNacosConfigResponseBodyConfiguration {
	s.DataId = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetDesc(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Desc = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetEncryptedDataKey(v string) *GetNacosConfigResponseBodyConfiguration {
	s.EncryptedDataKey = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetGroup(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Group = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetMd5(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Md5 = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetTags(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Tags = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetType(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Type = &v
	return s
}

type GetNacosConfigResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *GetNacosConfigResponse) SetHeaders(v map[string]*string) *GetNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *GetNacosConfigResponse) SetStatusCode(v int32) *GetNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNacosConfigResponse) SetBody(v *GetNacosConfigResponseBody) *GetNacosConfigResponse {
	s.Body = v
	return s
}

type GetNacosHistoryConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The version ID of the configuration.
	Nid *string `json:"Nid,omitempty" xml:"Nid,omitempty"`
}

func (s GetNacosHistoryConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigRequest) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigRequest) SetAcceptLanguage(v string) *GetNacosHistoryConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetDataId(v string) *GetNacosHistoryConfigRequest {
	s.DataId = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetGroup(v string) *GetNacosHistoryConfigRequest {
	s.Group = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetInstanceId(v string) *GetNacosHistoryConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetNamespaceId(v string) *GetNacosHistoryConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetNid(v string) *GetNacosHistoryConfigRequest {
	s.Nid = &v
	return s
}

type GetNacosHistoryConfigResponseBody struct {
	// The configuration information.
	Configuration *GetNacosHistoryConfigResponseBodyConfiguration `json:"Configuration,omitempty" xml:"Configuration,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNacosHistoryConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigResponseBody) SetConfiguration(v *GetNacosHistoryConfigResponseBodyConfiguration) *GetNacosHistoryConfigResponseBody {
	s.Configuration = v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetErrorCode(v string) *GetNacosHistoryConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetMessage(v string) *GetNacosHistoryConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetRequestId(v string) *GetNacosHistoryConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetSuccess(v bool) *GetNacosHistoryConfigResponseBody {
	s.Success = &v
	return s
}

type GetNacosHistoryConfigResponseBodyConfiguration struct {
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The encryption key.
	EncryptedDataKey *string `json:"EncryptedDataKey,omitempty" xml:"EncryptedDataKey,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The MD5 value of the configuration.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The configuration type.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
}

func (s GetNacosHistoryConfigResponseBodyConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigResponseBodyConfiguration) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetAppName(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.AppName = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetContent(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.Content = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetDataId(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.DataId = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetEncryptedDataKey(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.EncryptedDataKey = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetGroup(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.Group = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetMd5(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.Md5 = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetOpType(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.OpType = &v
	return s
}

type GetNacosHistoryConfigResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetNacosHistoryConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetNacosHistoryConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigResponse) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigResponse) SetHeaders(v map[string]*string) *GetNacosHistoryConfigResponse {
	s.Headers = v
	return s
}

func (s *GetNacosHistoryConfigResponse) SetStatusCode(v int32) *GetNacosHistoryConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNacosHistoryConfigResponse) SetBody(v *GetNacosHistoryConfigResponseBody) *GetNacosHistoryConfigResponse {
	s.Body = v
	return s
}

type GetOverviewRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The query time. Unit: days. For example, if you set this parameter to 30, the governance rules within the last 30 days are queried.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s GetOverviewRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOverviewRequest) GoString() string {
	return s.String()
}

func (s *GetOverviewRequest) SetAcceptLanguage(v string) *GetOverviewRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetOverviewRequest) SetPeriod(v int32) *GetOverviewRequest {
	s.Period = &v
	return s
}

func (s *GetOverviewRequest) SetRegion(v string) *GetOverviewRequest {
	s.Region = &v
	return s
}

type GetOverviewResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetOverviewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOverviewResponseBody) GoString() string {
	return s.String()
}

func (s *GetOverviewResponseBody) SetCode(v int32) *GetOverviewResponseBody {
	s.Code = &v
	return s
}

func (s *GetOverviewResponseBody) SetData(v string) *GetOverviewResponseBody {
	s.Data = &v
	return s
}

func (s *GetOverviewResponseBody) SetHttpStatusCode(v int32) *GetOverviewResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetOverviewResponseBody) SetMessage(v string) *GetOverviewResponseBody {
	s.Message = &v
	return s
}

func (s *GetOverviewResponseBody) SetRequestId(v string) *GetOverviewResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOverviewResponseBody) SetSuccess(v string) *GetOverviewResponseBody {
	s.Success = &v
	return s
}

type GetOverviewResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOverviewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOverviewResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOverviewResponse) GoString() string {
	return s.String()
}

func (s *GetOverviewResponse) SetHeaders(v map[string]*string) *GetOverviewResponse {
	s.Headers = v
	return s
}

func (s *GetOverviewResponse) SetStatusCode(v int32) *GetOverviewResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOverviewResponse) SetBody(v *GetOverviewResponseBody) *GetOverviewResponse {
	s.Body = v
	return s
}

type GetPluginConfigRequest struct {
	// The language of the response. Valid values:
	//
	// zh: Chinese en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the gateway plug-in.
	PluginId *int64 `json:"PluginId,omitempty" xml:"PluginId,omitempty"`
}

func (s GetPluginConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigRequest) GoString() string {
	return s.String()
}

func (s *GetPluginConfigRequest) SetAcceptLanguage(v string) *GetPluginConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetPluginConfigRequest) SetGatewayUniqueId(v string) *GetPluginConfigRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetPluginConfigRequest) SetPluginId(v int64) *GetPluginConfigRequest {
	s.PluginId = &v
	return s
}

type GetPluginConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetPluginConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic error code.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetPluginConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponseBody) SetCode(v int32) *GetPluginConfigResponseBody {
	s.Code = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetData(v *GetPluginConfigResponseBodyData) *GetPluginConfigResponseBody {
	s.Data = v
	return s
}

func (s *GetPluginConfigResponseBody) SetDynamicCode(v string) *GetPluginConfigResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetDynamicMessage(v string) *GetPluginConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetErrorCode(v string) *GetPluginConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetHttpStatusCode(v int32) *GetPluginConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetMessage(v string) *GetPluginConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetRequestId(v string) *GetPluginConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetSuccess(v bool) *GetPluginConfigResponseBody {
	s.Success = &v
	return s
}

type GetPluginConfigResponseBodyData struct {
	// The category of the plug-in. Valid values:
	//
	// 0: user-defined
	//
	// 1: permission authentication
	//
	// 2: security protection
	//
	// 3: transmission protocol
	//
	// 4: traffic control
	//
	// 5: traffic observation
	Category *int32 `json:"Category,omitempty" xml:"Category,omitempty"`
	// The information about the plug-in configuration used for checking.
	ConfigCheck *string `json:"ConfigCheck,omitempty" xml:"ConfigCheck,omitempty"`
	// The list of gateway plug-in configurations.
	GatewayConfigList []*GetPluginConfigResponseBodyDataGatewayConfigList `json:"GatewayConfigList,omitempty" xml:"GatewayConfigList,omitempty" type:"Repeated"`
	// The ID of the plug-in.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the image.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The mode.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the plug-in.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The execution stage of the plug-in. Valid values:
	//
	// 0: default stage
	//
	// 1: authorization stage
	//
	// 2: authentication stage
	//
	// 3: statistics stage
	Phase *int32 `json:"Phase,omitempty" xml:"Phase,omitempty"`
	// The ID of the creator.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The execution priority of the plug-in. A larger value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The publish status.
	PublishState *int32 `json:"PublishState,omitempty" xml:"PublishState,omitempty"`
	// The description of the README file.
	Readme *string `json:"Readme,omitempty" xml:"Readme,omitempty"`
	// The description of the README file that is edited in English.
	ReadmeEn *string `json:"ReadmeEn,omitempty" xml:"ReadmeEn,omitempty"`
	// Indicates whether the plug-in is enabled. Valid values:
	//
	// 0: disabled
	//
	// 1: enabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The summary of the plug-in.
	Summary *string `json:"Summary,omitempty" xml:"Summary,omitempty"`
	// The type.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
	// The version of the plug-in.
	Version     *string `json:"Version,omitempty" xml:"Version,omitempty"`
	VersionJson *string `json:"VersionJson,omitempty" xml:"VersionJson,omitempty"`
	// The WebAssembly language. Valid values:
	//
	// 0: C++
	//
	// 1: TinyGo
	//
	// 2: Rust
	//
	// 3: AssemblyScript
	//
	// 4: Zig
	WasmLang *int32 `json:"WasmLang,omitempty" xml:"WasmLang,omitempty"`
}

func (s GetPluginConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponseBodyData) SetCategory(v int32) *GetPluginConfigResponseBodyData {
	s.Category = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetConfigCheck(v string) *GetPluginConfigResponseBodyData {
	s.ConfigCheck = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetGatewayConfigList(v []*GetPluginConfigResponseBodyDataGatewayConfigList) *GetPluginConfigResponseBodyData {
	s.GatewayConfigList = v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetId(v int64) *GetPluginConfigResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetImageName(v string) *GetPluginConfigResponseBodyData {
	s.ImageName = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetMode(v int32) *GetPluginConfigResponseBodyData {
	s.Mode = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetName(v string) *GetPluginConfigResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPhase(v int32) *GetPluginConfigResponseBodyData {
	s.Phase = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPrimaryUser(v string) *GetPluginConfigResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPriority(v int32) *GetPluginConfigResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPublishState(v int32) *GetPluginConfigResponseBodyData {
	s.PublishState = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetReadme(v string) *GetPluginConfigResponseBodyData {
	s.Readme = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetReadmeEn(v string) *GetPluginConfigResponseBodyData {
	s.ReadmeEn = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetStatus(v string) *GetPluginConfigResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetSummary(v string) *GetPluginConfigResponseBodyData {
	s.Summary = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetType(v int32) *GetPluginConfigResponseBodyData {
	s.Type = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetVersion(v string) *GetPluginConfigResponseBodyData {
	s.Version = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetVersionJson(v string) *GetPluginConfigResponseBodyData {
	s.VersionJson = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetWasmLang(v int32) *GetPluginConfigResponseBodyData {
	s.WasmLang = &v
	return s
}

type GetPluginConfigResponseBodyDataGatewayConfigList struct {
	// The plug-in configuration.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The application scope of the plug-in. Valid values:
	//
	// 0: global
	//
	// 1: domain names
	//
	// 2: routes
	ConfigLevel *int32 `json:"ConfigLevel,omitempty" xml:"ConfigLevel,omitempty"`
	// Indicates whether the plug-in is enabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the plug-in configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the gateway plug-in.
	PluginId *int64 `json:"PluginId,omitempty" xml:"PluginId,omitempty"`
}

func (s GetPluginConfigResponseBodyDataGatewayConfigList) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponseBodyDataGatewayConfigList) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetConfig(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.Config = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetConfigLevel(v int32) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.ConfigLevel = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetEnable(v bool) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.Enable = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGatewayId(v int64) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GatewayId = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGatewayUniqueId(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGmtCreate(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GmtCreate = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGmtModified(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GmtModified = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetId(v int64) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.Id = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetPluginId(v int64) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.PluginId = &v
	return s
}

type GetPluginConfigResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPluginConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPluginConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponse) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponse) SetHeaders(v map[string]*string) *GetPluginConfigResponse {
	s.Headers = v
	return s
}

func (s *GetPluginConfigResponse) SetStatusCode(v int32) *GetPluginConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPluginConfigResponse) SetBody(v *GetPluginConfigResponseBody) *GetPluginConfigResponse {
	s.Body = v
	return s
}

type GetPluginsRequest struct {
	// The language of the response. Valid values:
	//
	// zh: Chinese en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the plug-in. Valid values:
	//
	// *   0: custom
	// *   1: permission authorization
	// *   2: security protection
	// *   3: transmission protocol
	// *   4: traffic control
	// *   5: traffic observation
	Category *int32 `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to enable the plug-in.
	EnableOnly *bool `json:"EnableOnly,omitempty" xml:"EnableOnly,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the plug-in.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetPluginsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsRequest) GoString() string {
	return s.String()
}

func (s *GetPluginsRequest) SetAcceptLanguage(v string) *GetPluginsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetPluginsRequest) SetCategory(v int32) *GetPluginsRequest {
	s.Category = &v
	return s
}

func (s *GetPluginsRequest) SetEnableOnly(v bool) *GetPluginsRequest {
	s.EnableOnly = &v
	return s
}

func (s *GetPluginsRequest) SetGatewayUniqueId(v string) *GetPluginsRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetPluginsRequest) SetName(v string) *GetPluginsRequest {
	s.Name = &v
	return s
}

type GetPluginsResponseBody struct {
	// The returned code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*GetPluginsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetPluginsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsResponseBody) GoString() string {
	return s.String()
}

func (s *GetPluginsResponseBody) SetCode(v int32) *GetPluginsResponseBody {
	s.Code = &v
	return s
}

func (s *GetPluginsResponseBody) SetData(v []*GetPluginsResponseBodyData) *GetPluginsResponseBody {
	s.Data = v
	return s
}

func (s *GetPluginsResponseBody) SetDynamicCode(v string) *GetPluginsResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *GetPluginsResponseBody) SetDynamicMessage(v string) *GetPluginsResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetPluginsResponseBody) SetErrorCode(v string) *GetPluginsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetPluginsResponseBody) SetHttpStatusCode(v int32) *GetPluginsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetPluginsResponseBody) SetMessage(v string) *GetPluginsResponseBody {
	s.Message = &v
	return s
}

func (s *GetPluginsResponseBody) SetRequestId(v string) *GetPluginsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPluginsResponseBody) SetSuccess(v bool) *GetPluginsResponseBody {
	s.Success = &v
	return s
}

type GetPluginsResponseBodyData struct {
	// The type of the plug-in. Valid values:
	//
	// 0: custom
	//
	// 1: permission authorization
	//
	// 2: security protection
	//
	// 3: transmission protocol
	//
	// 4: traffic control
	//
	// 5: traffic observation
	Category *int32 `json:"Category,omitempty" xml:"Category,omitempty"`
	// The information about the plug-in configuration used for checking.
	ConfigCheck *string `json:"ConfigCheck,omitempty" xml:"ConfigCheck,omitempty"`
	// The ID of the plug-in.
	Id         *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	MaxVersion *string `json:"MaxVersion,omitempty" xml:"MaxVersion,omitempty"`
	Mode       *int32  `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the plug-in.
	Name                     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	NewVersionPublishingFlag *bool   `json:"NewVersionPublishingFlag,omitempty" xml:"NewVersionPublishingFlag,omitempty"`
	// The execution stage of the plug-in.
	//
	// *   0: default stage
	// *   1: authorization stage
	// *   2: authentication stage
	// *   3: statistics stage
	Phase *int32 `json:"Phase,omitempty" xml:"Phase,omitempty"`
	// The ID of the creator.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The execution priority of the plug-in. A larger value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The publish status.
	PublishState *int32 `json:"PublishState,omitempty" xml:"PublishState,omitempty"`
	// Indicates whether the plug-in is enabled.
	//
	// *   0: disabled
	// *   1: enabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The summary of the plug-in.
	Summary *string `json:"Summary,omitempty" xml:"Summary,omitempty"`
	// The version of the plug-in.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
	// The URL of the Object Storage Service (OSS) bucket that stores the WebAssembly plug-in.
	WasmFile *string `json:"WasmFile,omitempty" xml:"WasmFile,omitempty"`
	// The WebAssembly language. Valid values:
	//
	// *   0: C++
	// *   1: TinyGo
	// *   2: Rust
	// *   3: AssemblyScript
	// *   4: Zig
	WasmLang *int32 `json:"WasmLang,omitempty" xml:"WasmLang,omitempty"`
}

func (s GetPluginsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPluginsResponseBodyData) SetCategory(v int32) *GetPluginsResponseBodyData {
	s.Category = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetConfigCheck(v string) *GetPluginsResponseBodyData {
	s.ConfigCheck = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetId(v int64) *GetPluginsResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetMaxVersion(v string) *GetPluginsResponseBodyData {
	s.MaxVersion = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetMode(v int32) *GetPluginsResponseBodyData {
	s.Mode = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetName(v string) *GetPluginsResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetNewVersionPublishingFlag(v bool) *GetPluginsResponseBodyData {
	s.NewVersionPublishingFlag = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPhase(v int32) *GetPluginsResponseBodyData {
	s.Phase = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPrimaryUser(v string) *GetPluginsResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPriority(v int32) *GetPluginsResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPublishState(v int32) *GetPluginsResponseBodyData {
	s.PublishState = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetStatus(v string) *GetPluginsResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetSummary(v string) *GetPluginsResponseBodyData {
	s.Summary = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetVersion(v string) *GetPluginsResponseBodyData {
	s.Version = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetWasmFile(v string) *GetPluginsResponseBodyData {
	s.WasmFile = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetWasmLang(v int32) *GetPluginsResponseBodyData {
	s.WasmLang = &v
	return s
}

type GetPluginsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPluginsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPluginsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsResponse) GoString() string {
	return s.String()
}

func (s *GetPluginsResponse) SetHeaders(v map[string]*string) *GetPluginsResponse {
	s.Headers = v
	return s
}

func (s *GetPluginsResponse) SetStatusCode(v int32) *GetPluginsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPluginsResponse) SetBody(v *GetPluginsResponseBody) *GetPluginsResponse {
	s.Body = v
	return s
}

type GetServiceListRequest struct {
	// The language of the response.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The type of the framework.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
}

func (s GetServiceListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListRequest) GoString() string {
	return s.String()
}

func (s *GetServiceListRequest) SetAcceptLanguage(v string) *GetServiceListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetServiceListRequest) SetAppId(v string) *GetServiceListRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceListRequest) SetIp(v string) *GetServiceListRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceListRequest) SetRegion(v string) *GetServiceListRequest {
	s.Region = &v
	return s
}

func (s *GetServiceListRequest) SetServiceName(v string) *GetServiceListRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceListRequest) SetServiceType(v string) *GetServiceListRequest {
	s.ServiceType = &v
	return s
}

type GetServiceListResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*GetServiceListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceListResponseBody) SetCode(v int32) *GetServiceListResponseBody {
	s.Code = &v
	return s
}

func (s *GetServiceListResponseBody) SetData(v []*GetServiceListResponseBodyData) *GetServiceListResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceListResponseBody) SetHttpStatusCode(v int32) *GetServiceListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetServiceListResponseBody) SetMessage(v string) *GetServiceListResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceListResponseBody) SetRequestId(v string) *GetServiceListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetServiceListResponseBody) SetSuccess(v bool) *GetServiceListResponseBody {
	s.Success = &v
	return s
}

type GetServiceListResponseBodyData struct {
	// The name of the Dubbo application.
	DubboApplicationName *string `json:"DubboApplicationName,omitempty" xml:"DubboApplicationName,omitempty"`
	// The name of the application.
	EdasAppName *string `json:"EdasAppName,omitempty" xml:"EdasAppName,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The metadata.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The methods.
	Methods []*GetServiceListResponseBodyDataMethods `json:"Methods,omitempty" xml:"Methods,omitempty" type:"Repeated"`
	// The type of the service registry.
	RegistryType *string `json:"RegistryType,omitempty" xml:"RegistryType,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The type of the service.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	// The name of the Spring application.
	SpringApplicationName *string `json:"SpringApplicationName,omitempty" xml:"SpringApplicationName,omitempty"`
	// The version information.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetServiceListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceListResponseBodyData) SetDubboApplicationName(v string) *GetServiceListResponseBodyData {
	s.DubboApplicationName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetEdasAppName(v string) *GetServiceListResponseBodyData {
	s.EdasAppName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetGroup(v string) *GetServiceListResponseBodyData {
	s.Group = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetMetadata(v map[string]interface{}) *GetServiceListResponseBodyData {
	s.Metadata = v
	return s
}

func (s *GetServiceListResponseBodyData) SetMethods(v []*GetServiceListResponseBodyDataMethods) *GetServiceListResponseBodyData {
	s.Methods = v
	return s
}

func (s *GetServiceListResponseBodyData) SetRegistryType(v string) *GetServiceListResponseBodyData {
	s.RegistryType = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetServiceName(v string) *GetServiceListResponseBodyData {
	s.ServiceName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetServiceType(v string) *GetServiceListResponseBodyData {
	s.ServiceType = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetSpringApplicationName(v string) *GetServiceListResponseBodyData {
	s.SpringApplicationName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetVersion(v string) *GetServiceListResponseBodyData {
	s.Version = &v
	return s
}

type GetServiceListResponseBodyDataMethods struct {
	// The controller of the method.
	MethodController *string `json:"MethodController,omitempty" xml:"MethodController,omitempty"`
	// The name of the method.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The data types of the parameters.
	ParameterTypes []*string `json:"ParameterTypes,omitempty" xml:"ParameterTypes,omitempty" type:"Repeated"`
	// The paths.
	Paths []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The methods.
	RequestMethods []*string `json:"RequestMethods,omitempty" xml:"RequestMethods,omitempty" type:"Repeated"`
	// The type of the return value.
	ReturnType *string `json:"ReturnType,omitempty" xml:"ReturnType,omitempty"`
}

func (s GetServiceListResponseBodyDataMethods) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponseBodyDataMethods) GoString() string {
	return s.String()
}

func (s *GetServiceListResponseBodyDataMethods) SetMethodController(v string) *GetServiceListResponseBodyDataMethods {
	s.MethodController = &v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetName(v string) *GetServiceListResponseBodyDataMethods {
	s.Name = &v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetParameterTypes(v []*string) *GetServiceListResponseBodyDataMethods {
	s.ParameterTypes = v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetPaths(v []*string) *GetServiceListResponseBodyDataMethods {
	s.Paths = v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetRequestMethods(v []*string) *GetServiceListResponseBodyDataMethods {
	s.RequestMethods = v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetReturnType(v string) *GetServiceListResponseBodyDataMethods {
	s.ReturnType = &v
	return s
}

type GetServiceListResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetServiceListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetServiceListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponse) GoString() string {
	return s.String()
}

func (s *GetServiceListResponse) SetHeaders(v map[string]*string) *GetServiceListResponse {
	s.Headers = v
	return s
}

func (s *GetServiceListResponse) SetStatusCode(v int32) *GetServiceListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceListResponse) SetBody(v *GetServiceListResponseBody) *GetServiceListResponse {
	s.Body = v
	return s
}

type GetServiceListPageRequest struct {
	// The language of the response. Valid values: zh and en. Default value: zh. The value zh indicates Chinese, and the value en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The IP address from which the query is initiated.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The name of the MSE namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The service name.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The service type.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
}

func (s GetServiceListPageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageRequest) GoString() string {
	return s.String()
}

func (s *GetServiceListPageRequest) SetAcceptLanguage(v string) *GetServiceListPageRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetServiceListPageRequest) SetAppId(v string) *GetServiceListPageRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceListPageRequest) SetAppName(v string) *GetServiceListPageRequest {
	s.AppName = &v
	return s
}

func (s *GetServiceListPageRequest) SetIp(v string) *GetServiceListPageRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceListPageRequest) SetNamespace(v string) *GetServiceListPageRequest {
	s.Namespace = &v
	return s
}

func (s *GetServiceListPageRequest) SetPageNumber(v int32) *GetServiceListPageRequest {
	s.PageNumber = &v
	return s
}

func (s *GetServiceListPageRequest) SetPageSize(v int32) *GetServiceListPageRequest {
	s.PageSize = &v
	return s
}

func (s *GetServiceListPageRequest) SetRegion(v string) *GetServiceListPageRequest {
	s.Region = &v
	return s
}

func (s *GetServiceListPageRequest) SetServiceName(v string) *GetServiceListPageRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceListPageRequest) SetServiceType(v string) *GetServiceListPageRequest {
	s.ServiceType = &v
	return s
}

type GetServiceListPageResponseBody struct {
	// The response to the request.
	Data *GetServiceListPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The request information.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceListPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponseBody) SetData(v *GetServiceListPageResponseBodyData) *GetServiceListPageResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceListPageResponseBody) SetMessage(v string) *GetServiceListPageResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceListPageResponseBody) SetRequestId(v string) *GetServiceListPageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetServiceListPageResponseBody) SetSuccess(v bool) *GetServiceListPageResponseBody {
	s.Success = &v
	return s
}

type GetServiceListPageResponseBodyData struct {
	// The page number.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data on the current page.
	Result []*GetServiceListPageResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *string `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetServiceListPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponseBodyData) SetPageNumber(v string) *GetServiceListPageResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetServiceListPageResponseBodyData) SetPageSize(v string) *GetServiceListPageResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetServiceListPageResponseBodyData) SetResult(v []*GetServiceListPageResponseBodyDataResult) *GetServiceListPageResponseBodyData {
	s.Result = v
	return s
}

func (s *GetServiceListPageResponseBodyData) SetTotalSize(v string) *GetServiceListPageResponseBodyData {
	s.TotalSize = &v
	return s
}

type GetServiceListPageResponseBodyDataResult struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The time when the service was last updated.
	GmtModifyTime *string `json:"GmtModifyTime,omitempty" xml:"GmtModifyTime,omitempty"`
	// The group to which the service belongs.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The number of service nodes.
	InstanceNum *int32 `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	// The service name.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The service version.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetServiceListPageResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponseBodyDataResult) SetAppId(v string) *GetServiceListPageResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataResult) SetAppName(v string) *GetServiceListPageResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataResult) SetGmtModifyTime(v string) *GetServiceListPageResponseBodyDataResult {
	s.GmtModifyTime = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataResult) SetGroup(v string) *GetServiceListPageResponseBodyDataResult {
	s.Group = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataResult) SetInstanceNum(v int32) *GetServiceListPageResponseBodyDataResult {
	s.InstanceNum = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataResult) SetServiceName(v string) *GetServiceListPageResponseBodyDataResult {
	s.ServiceName = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataResult) SetVersion(v string) *GetServiceListPageResponseBodyDataResult {
	s.Version = &v
	return s
}

type GetServiceListPageResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetServiceListPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetServiceListPageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponse) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponse) SetHeaders(v map[string]*string) *GetServiceListPageResponse {
	s.Headers = v
	return s
}

func (s *GetServiceListPageResponse) SetStatusCode(v int32) *GetServiceListPageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceListPageResponse) SetBody(v *GetServiceListPageResponseBody) *GetServiceListPageResponse {
	s.Body = v
	return s
}

type GetServiceListenersRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the MSE instance to which the service belongs.
	//
	// > You must specify InstanceId or ClusterId.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster to which the service belongs.
	//
	// > The cluster is a concept for Nacos services and is not equivalent to a Microservices Engine (MSE) instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// A reserved parameter.
	HasIpCount *string `json:"HasIpCount,omitempty" xml:"HasIpCount,omitempty"`
	// The ID of the instance to which the service belongs.
	//
	// > You must specify InstanceId or ClusterId.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The namespace to which the service belongs.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service whose listeners you want to query.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s GetServiceListenersRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersRequest) GoString() string {
	return s.String()
}

func (s *GetServiceListenersRequest) SetAcceptLanguage(v string) *GetServiceListenersRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetServiceListenersRequest) SetClusterId(v string) *GetServiceListenersRequest {
	s.ClusterId = &v
	return s
}

func (s *GetServiceListenersRequest) SetClusterName(v string) *GetServiceListenersRequest {
	s.ClusterName = &v
	return s
}

func (s *GetServiceListenersRequest) SetGroupName(v string) *GetServiceListenersRequest {
	s.GroupName = &v
	return s
}

func (s *GetServiceListenersRequest) SetHasIpCount(v string) *GetServiceListenersRequest {
	s.HasIpCount = &v
	return s
}

func (s *GetServiceListenersRequest) SetInstanceId(v string) *GetServiceListenersRequest {
	s.InstanceId = &v
	return s
}

func (s *GetServiceListenersRequest) SetNamespaceId(v string) *GetServiceListenersRequest {
	s.NamespaceId = &v
	return s
}

func (s *GetServiceListenersRequest) SetPageNum(v int32) *GetServiceListenersRequest {
	s.PageNum = &v
	return s
}

func (s *GetServiceListenersRequest) SetPageSize(v int32) *GetServiceListenersRequest {
	s.PageSize = &v
	return s
}

func (s *GetServiceListenersRequest) SetRegionId(v string) *GetServiceListenersRequest {
	s.RegionId = &v
	return s
}

func (s *GetServiceListenersRequest) SetRequestPars(v string) *GetServiceListenersRequest {
	s.RequestPars = &v
	return s
}

func (s *GetServiceListenersRequest) SetServiceName(v string) *GetServiceListenersRequest {
	s.ServiceName = &v
	return s
}

type GetServiceListenersResponseBody struct {
	// The returned data.
	Data []*GetServiceListenersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of listeners that are queried.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetServiceListenersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceListenersResponseBody) SetData(v []*GetServiceListenersResponseBodyData) *GetServiceListenersResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceListenersResponseBody) SetErrorCode(v string) *GetServiceListenersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetHttpCode(v string) *GetServiceListenersResponseBody {
	s.HttpCode = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetMessage(v string) *GetServiceListenersResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetPageNumber(v int32) *GetServiceListenersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetPageSize(v int32) *GetServiceListenersResponseBody {
	s.PageSize = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetRequestId(v string) *GetServiceListenersResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetSuccess(v bool) *GetServiceListenersResponseBody {
	s.Success = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetTotalCount(v int32) *GetServiceListenersResponseBody {
	s.TotalCount = &v
	return s
}

type GetServiceListenersResponseBodyData struct {
	// The IP address of the listener.
	Addr *string `json:"Addr,omitempty" xml:"Addr,omitempty"`
	// The listener client version.
	Agent *string `json:"Agent,omitempty" xml:"Agent,omitempty"`
	// The application name of the listener.
	App *string `json:"App,omitempty" xml:"App,omitempty"`
	// The name of the cluster to which the monitored service belongs.
	Cluster *string `json:"Cluster,omitempty" xml:"Cluster,omitempty"`
	// The IP address of the monitored service.
	IP *string `json:"IP,omitempty" xml:"IP,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port number of the monitored service.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the monitored service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s GetServiceListenersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceListenersResponseBodyData) SetAddr(v string) *GetServiceListenersResponseBodyData {
	s.Addr = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetAgent(v string) *GetServiceListenersResponseBodyData {
	s.Agent = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetApp(v string) *GetServiceListenersResponseBodyData {
	s.App = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetCluster(v string) *GetServiceListenersResponseBodyData {
	s.Cluster = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetIP(v string) *GetServiceListenersResponseBodyData {
	s.IP = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetNamespaceId(v string) *GetServiceListenersResponseBodyData {
	s.NamespaceId = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetPort(v string) *GetServiceListenersResponseBodyData {
	s.Port = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetServiceName(v string) *GetServiceListenersResponseBodyData {
	s.ServiceName = &v
	return s
}

type GetServiceListenersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetServiceListenersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetServiceListenersResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersResponse) GoString() string {
	return s.String()
}

func (s *GetServiceListenersResponse) SetHeaders(v map[string]*string) *GetServiceListenersResponse {
	s.Headers = v
	return s
}

func (s *GetServiceListenersResponse) SetStatusCode(v int32) *GetServiceListenersResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceListenersResponse) SetBody(v *GetServiceListenersResponseBody) *GetServiceListenersResponse {
	s.Body = v
	return s
}

type GetServiceMethodPageRequest struct {
	AcceptLanguage   *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	AppId            *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName          *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	Ip               *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	MethodController *string `json:"MethodController,omitempty" xml:"MethodController,omitempty"`
	Name             *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace        *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	PageNumber       *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize         *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Path             *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Region           *string `json:"Region,omitempty" xml:"Region,omitempty"`
	ServiceGroup     *string `json:"ServiceGroup,omitempty" xml:"ServiceGroup,omitempty"`
	ServiceName      *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	ServiceType      *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	ServiceVersion   *string `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty"`
}

func (s GetServiceMethodPageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageRequest) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageRequest) SetAcceptLanguage(v string) *GetServiceMethodPageRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetAppId(v string) *GetServiceMethodPageRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetAppName(v string) *GetServiceMethodPageRequest {
	s.AppName = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetIp(v string) *GetServiceMethodPageRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetMethodController(v string) *GetServiceMethodPageRequest {
	s.MethodController = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetName(v string) *GetServiceMethodPageRequest {
	s.Name = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetNamespace(v string) *GetServiceMethodPageRequest {
	s.Namespace = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetPageNumber(v int32) *GetServiceMethodPageRequest {
	s.PageNumber = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetPageSize(v int32) *GetServiceMethodPageRequest {
	s.PageSize = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetPath(v string) *GetServiceMethodPageRequest {
	s.Path = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetRegion(v string) *GetServiceMethodPageRequest {
	s.Region = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceGroup(v string) *GetServiceMethodPageRequest {
	s.ServiceGroup = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceName(v string) *GetServiceMethodPageRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceType(v string) *GetServiceMethodPageRequest {
	s.ServiceType = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceVersion(v string) *GetServiceMethodPageRequest {
	s.ServiceVersion = &v
	return s
}

type GetServiceMethodPageResponseBody struct {
	Data      *GetServiceMethodPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message   *string                               `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceMethodPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBody) SetData(v *GetServiceMethodPageResponseBodyData) *GetServiceMethodPageResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetMessage(v string) *GetServiceMethodPageResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetRequestId(v string) *GetServiceMethodPageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetSuccess(v bool) *GetServiceMethodPageResponseBody {
	s.Success = &v
	return s
}

type GetServiceMethodPageResponseBodyData struct {
	PageNumber *int32                                        `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Result     []*GetServiceMethodPageResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	TotalSize  *int32                                        `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetServiceMethodPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBodyData) SetPageNumber(v int32) *GetServiceMethodPageResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyData) SetPageSize(v int32) *GetServiceMethodPageResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyData) SetResult(v []*GetServiceMethodPageResponseBodyDataResult) *GetServiceMethodPageResponseBodyData {
	s.Result = v
	return s
}

func (s *GetServiceMethodPageResponseBodyData) SetTotalSize(v int32) *GetServiceMethodPageResponseBodyData {
	s.TotalSize = &v
	return s
}

type GetServiceMethodPageResponseBodyDataResult struct {
	MethodController     *string                                                           `json:"MethodController,omitempty" xml:"MethodController,omitempty"`
	Name                 *string                                                           `json:"Name,omitempty" xml:"Name,omitempty"`
	NameDetail           *string                                                           `json:"NameDetail,omitempty" xml:"NameDetail,omitempty"`
	ParameterDefinitions []*GetServiceMethodPageResponseBodyDataResultParameterDefinitions `json:"ParameterDefinitions,omitempty" xml:"ParameterDefinitions,omitempty" type:"Repeated"`
	ParameterDetails     []*string                                                         `json:"ParameterDetails,omitempty" xml:"ParameterDetails,omitempty" type:"Repeated"`
	ParameterTypes       []*string                                                         `json:"ParameterTypes,omitempty" xml:"ParameterTypes,omitempty" type:"Repeated"`
	Paths                []*string                                                         `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	RequestMethods       []*string                                                         `json:"RequestMethods,omitempty" xml:"RequestMethods,omitempty" type:"Repeated"`
	ReturnDetails        *string                                                           `json:"ReturnDetails,omitempty" xml:"ReturnDetails,omitempty"`
	ReturnType           *string                                                           `json:"ReturnType,omitempty" xml:"ReturnType,omitempty"`
}

func (s GetServiceMethodPageResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetMethodController(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.MethodController = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetName(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetNameDetail(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.NameDetail = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetParameterDefinitions(v []*GetServiceMethodPageResponseBodyDataResultParameterDefinitions) *GetServiceMethodPageResponseBodyDataResult {
	s.ParameterDefinitions = v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetParameterDetails(v []*string) *GetServiceMethodPageResponseBodyDataResult {
	s.ParameterDetails = v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetParameterTypes(v []*string) *GetServiceMethodPageResponseBodyDataResult {
	s.ParameterTypes = v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetPaths(v []*string) *GetServiceMethodPageResponseBodyDataResult {
	s.Paths = v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetRequestMethods(v []*string) *GetServiceMethodPageResponseBodyDataResult {
	s.RequestMethods = v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetReturnDetails(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ReturnDetails = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetReturnType(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ReturnType = &v
	return s
}

type GetServiceMethodPageResponseBodyDataResultParameterDefinitions struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name        *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type        *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetServiceMethodPageResponseBodyDataResultParameterDefinitions) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBodyDataResultParameterDefinitions) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBodyDataResultParameterDefinitions) SetDescription(v string) *GetServiceMethodPageResponseBodyDataResultParameterDefinitions {
	s.Description = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResultParameterDefinitions) SetName(v string) *GetServiceMethodPageResponseBodyDataResultParameterDefinitions {
	s.Name = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResultParameterDefinitions) SetType(v string) *GetServiceMethodPageResponseBodyDataResultParameterDefinitions {
	s.Type = &v
	return s
}

type GetServiceMethodPageResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetServiceMethodPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetServiceMethodPageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponse) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponse) SetHeaders(v map[string]*string) *GetServiceMethodPageResponse {
	s.Headers = v
	return s
}

func (s *GetServiceMethodPageResponse) SetStatusCode(v int32) *GetServiceMethodPageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceMethodPageResponse) SetBody(v *GetServiceMethodPageResponseBody) *GetServiceMethodPageResponse {
	s.Body = v
	return s
}

type GetTagsBySwimmingLaneGroupIdRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the Microservices Engine (MSE) namespace that you want to query.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s GetTagsBySwimmingLaneGroupIdRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTagsBySwimmingLaneGroupIdRequest) GoString() string {
	return s.String()
}

func (s *GetTagsBySwimmingLaneGroupIdRequest) SetAcceptLanguage(v string) *GetTagsBySwimmingLaneGroupIdRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdRequest) SetGroupId(v int64) *GetTagsBySwimmingLaneGroupIdRequest {
	s.GroupId = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdRequest) SetNamespace(v string) *GetTagsBySwimmingLaneGroupIdRequest {
	s.Namespace = &v
	return s
}

type GetTagsBySwimmingLaneGroupIdResponseBody struct {
	// The data of the tag.
	Data []*string `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetTagsBySwimmingLaneGroupIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTagsBySwimmingLaneGroupIdResponseBody) GoString() string {
	return s.String()
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetData(v []*string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.Data = v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetErrorCode(v string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetMessage(v string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.Message = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetRequestId(v string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetSuccess(v bool) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.Success = &v
	return s
}

type GetTagsBySwimmingLaneGroupIdResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTagsBySwimmingLaneGroupIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTagsBySwimmingLaneGroupIdResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTagsBySwimmingLaneGroupIdResponse) GoString() string {
	return s.String()
}

func (s *GetTagsBySwimmingLaneGroupIdResponse) SetHeaders(v map[string]*string) *GetTagsBySwimmingLaneGroupIdResponse {
	s.Headers = v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponse) SetStatusCode(v int32) *GetTagsBySwimmingLaneGroupIdResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponse) SetBody(v *GetTagsBySwimmingLaneGroupIdResponseBody) *GetTagsBySwimmingLaneGroupIdResponse {
	s.Body = v
	return s
}

type GetZookeeperDataImportUrlRequest struct {
	// RestResult
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
	// The type of the file.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s GetZookeeperDataImportUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlRequest) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlRequest) SetAcceptLanguage(v string) *GetZookeeperDataImportUrlRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetZookeeperDataImportUrlRequest) SetContentType(v string) *GetZookeeperDataImportUrlRequest {
	s.ContentType = &v
	return s
}

func (s *GetZookeeperDataImportUrlRequest) SetInstanceId(v string) *GetZookeeperDataImportUrlRequest {
	s.InstanceId = &v
	return s
}

type GetZookeeperDataImportUrlResponseBody struct {
	// The error code returned if the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The URL that is used to upload the configuration file.
	Data *GetZookeeperDataImportUrlResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The returned data.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The HTTP status code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The request was successfully processed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status code. A value of 200 is returned if the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetZookeeperDataImportUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlResponseBody) SetCode(v int32) *GetZookeeperDataImportUrlResponseBody {
	s.Code = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetData(v *GetZookeeperDataImportUrlResponseBodyData) *GetZookeeperDataImportUrlResponseBody {
	s.Data = v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetDynamicCode(v string) *GetZookeeperDataImportUrlResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetDynamicMessage(v string) *GetZookeeperDataImportUrlResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetErrorCode(v string) *GetZookeeperDataImportUrlResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetHttpStatusCode(v int32) *GetZookeeperDataImportUrlResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetMessage(v string) *GetZookeeperDataImportUrlResponseBody {
	s.Message = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetRequestId(v string) *GetZookeeperDataImportUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetSuccess(v bool) *GetZookeeperDataImportUrlResponseBody {
	s.Success = &v
	return s
}

type GetZookeeperDataImportUrlResponseBodyData struct {
	// code
	MaxSize *string `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The maximum size of a file that can be uploaded each time. Unit: MB.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetZookeeperDataImportUrlResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlResponseBodyData) SetMaxSize(v string) *GetZookeeperDataImportUrlResponseBodyData {
	s.MaxSize = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBodyData) SetUrl(v string) *GetZookeeperDataImportUrlResponseBodyData {
	s.Url = &v
	return s
}

type GetZookeeperDataImportUrlResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetZookeeperDataImportUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetZookeeperDataImportUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlResponse) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlResponse) SetHeaders(v map[string]*string) *GetZookeeperDataImportUrlResponse {
	s.Headers = v
	return s
}

func (s *GetZookeeperDataImportUrlResponse) SetStatusCode(v int32) *GetZookeeperDataImportUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponse) SetBody(v *GetZookeeperDataImportUrlResponseBody) *GetZookeeperDataImportUrlResponse {
	s.Body = v
	return s
}

type ImportNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the namespace.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The policy.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The policy.
	//
	// Valid values:
	//
	// *   ABORT
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   OVERWRITE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   SKIP
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
}

func (s ImportNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigRequest) SetAcceptLanguage(v string) *ImportNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportNacosConfigRequest) SetFileUrl(v string) *ImportNacosConfigRequest {
	s.FileUrl = &v
	return s
}

func (s *ImportNacosConfigRequest) SetInstanceId(v string) *ImportNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *ImportNacosConfigRequest) SetNamespaceId(v string) *ImportNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *ImportNacosConfigRequest) SetPolicy(v string) *ImportNacosConfigRequest {
	s.Policy = &v
	return s
}

type ImportNacosConfigResponseBody struct {
	// The error message returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of configurations that are imported.
	Data *ImportNacosConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The details of the data.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The request is successfully processed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code that is returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBody) SetCode(v int32) *ImportNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetData(v *ImportNacosConfigResponseBodyData) *ImportNacosConfigResponseBody {
	s.Data = v
	return s
}

func (s *ImportNacosConfigResponseBody) SetDynamicMessage(v string) *ImportNacosConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetErrorCode(v string) *ImportNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetHttpStatusCode(v int32) *ImportNacosConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetMessage(v string) *ImportNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetRequestId(v string) *ImportNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetSuccess(v bool) *ImportNacosConfigResponseBody {
	s.Success = &v
	return s
}

type ImportNacosConfigResponseBodyData struct {
	// The data structure.
	FailData []*ImportNacosConfigResponseBodyDataFailData `json:"FailData,omitempty" xml:"FailData,omitempty" type:"Repeated"`
	// The information about skipped configurations.
	SkipCount *int32 `json:"SkipCount,omitempty" xml:"SkipCount,omitempty"`
	// The data structure.
	SkipData []*ImportNacosConfigResponseBodyDataSkipData `json:"SkipData,omitempty" xml:"SkipData,omitempty" type:"Repeated"`
	// The number of configurations that are skipped.
	SuccCount *int32 `json:"SuccCount,omitempty" xml:"SuccCount,omitempty"`
}

func (s ImportNacosConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBodyData) SetFailData(v []*ImportNacosConfigResponseBodyDataFailData) *ImportNacosConfigResponseBodyData {
	s.FailData = v
	return s
}

func (s *ImportNacosConfigResponseBodyData) SetSkipCount(v int32) *ImportNacosConfigResponseBodyData {
	s.SkipCount = &v
	return s
}

func (s *ImportNacosConfigResponseBodyData) SetSkipData(v []*ImportNacosConfigResponseBodyDataSkipData) *ImportNacosConfigResponseBodyData {
	s.SkipData = v
	return s
}

func (s *ImportNacosConfigResponseBodyData) SetSuccCount(v int32) *ImportNacosConfigResponseBodyData {
	s.SuccCount = &v
	return s
}

type ImportNacosConfigResponseBodyDataFailData struct {
	// The ID of the group.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	Group  *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s ImportNacosConfigResponseBodyDataFailData) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBodyDataFailData) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBodyDataFailData) SetDataId(v string) *ImportNacosConfigResponseBodyDataFailData {
	s.DataId = &v
	return s
}

func (s *ImportNacosConfigResponseBodyDataFailData) SetGroup(v string) *ImportNacosConfigResponseBodyDataFailData {
	s.Group = &v
	return s
}

type ImportNacosConfigResponseBodyDataSkipData struct {
	// The ID of the group.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The information about configurations that are failed to be imported.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s ImportNacosConfigResponseBodyDataSkipData) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBodyDataSkipData) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBodyDataSkipData) SetDataId(v string) *ImportNacosConfigResponseBodyDataSkipData {
	s.DataId = &v
	return s
}

func (s *ImportNacosConfigResponseBodyDataSkipData) SetGroup(v string) *ImportNacosConfigResponseBodyDataSkipData {
	s.Group = &v
	return s
}

type ImportNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponse) SetHeaders(v map[string]*string) *ImportNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *ImportNacosConfigResponse) SetStatusCode(v int32) *ImportNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportNacosConfigResponse) SetBody(v *ImportNacosConfigResponseBody) *ImportNacosConfigResponse {
	s.Body = v
	return s
}

type ImportServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	FcAlias        *string `json:"FcAlias,omitempty" xml:"FcAlias,omitempty"`
	FcServiceName  *string `json:"FcServiceName,omitempty" xml:"FcServiceName,omitempty"`
	FcVersion      *string `json:"FcVersion,omitempty" xml:"FcVersion,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The information about services.
	ServiceList []*ImportServicesRequestServiceList `json:"ServiceList,omitempty" xml:"ServiceList,omitempty" type:"Repeated"`
	// The service source. Valid values:
	//
	// *   MSE: MSE Nacos instance
	// *   K8s: ACK cluster
	// *   VIP: fixed address
	// *   DNS: DNS domain
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The Transport Layer Security (TLS) settings. Valid values:
	//
	// *   mode: TLS mode
	// *   certId: certificate ID
	// *   caCertId: CA certificate ID
	// *   caCertContent: CA certificate public key
	// *   sni: service name identification
	TlsSetting *string `json:"TlsSetting,omitempty" xml:"TlsSetting,omitempty"`
}

func (s ImportServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesRequest) GoString() string {
	return s.String()
}

func (s *ImportServicesRequest) SetAcceptLanguage(v string) *ImportServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportServicesRequest) SetFcAlias(v string) *ImportServicesRequest {
	s.FcAlias = &v
	return s
}

func (s *ImportServicesRequest) SetFcServiceName(v string) *ImportServicesRequest {
	s.FcServiceName = &v
	return s
}

func (s *ImportServicesRequest) SetFcVersion(v string) *ImportServicesRequest {
	s.FcVersion = &v
	return s
}

func (s *ImportServicesRequest) SetGatewayUniqueId(v string) *ImportServicesRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ImportServicesRequest) SetServiceList(v []*ImportServicesRequestServiceList) *ImportServicesRequest {
	s.ServiceList = v
	return s
}

func (s *ImportServicesRequest) SetSourceType(v string) *ImportServicesRequest {
	s.SourceType = &v
	return s
}

func (s *ImportServicesRequest) SetTlsSetting(v string) *ImportServicesRequest {
	s.TlsSetting = &v
	return s
}

type ImportServicesRequestServiceList struct {
	// The group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The IP addresses of the service.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The port of the service.
	ServicePort *int64 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The protocol of the service.
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
}

func (s ImportServicesRequestServiceList) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesRequestServiceList) GoString() string {
	return s.String()
}

func (s *ImportServicesRequestServiceList) SetGroupName(v string) *ImportServicesRequestServiceList {
	s.GroupName = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetIps(v []*string) *ImportServicesRequestServiceList {
	s.Ips = v
	return s
}

func (s *ImportServicesRequestServiceList) SetName(v string) *ImportServicesRequestServiceList {
	s.Name = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetNamespace(v string) *ImportServicesRequestServiceList {
	s.Namespace = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetServicePort(v int64) *ImportServicesRequestServiceList {
	s.ServicePort = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetServiceProtocol(v string) *ImportServicesRequestServiceList {
	s.ServiceProtocol = &v
	return s
}

type ImportServicesShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	FcAlias        *string `json:"FcAlias,omitempty" xml:"FcAlias,omitempty"`
	FcServiceName  *string `json:"FcServiceName,omitempty" xml:"FcServiceName,omitempty"`
	FcVersion      *string `json:"FcVersion,omitempty" xml:"FcVersion,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The information about services.
	ServiceListShrink *string `json:"ServiceList,omitempty" xml:"ServiceList,omitempty"`
	// The service source. Valid values:
	//
	// *   MSE: MSE Nacos instance
	// *   K8s: ACK cluster
	// *   VIP: fixed address
	// *   DNS: DNS domain
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The Transport Layer Security (TLS) settings. Valid values:
	//
	// *   mode: TLS mode
	// *   certId: certificate ID
	// *   caCertId: CA certificate ID
	// *   caCertContent: CA certificate public key
	// *   sni: service name identification
	TlsSetting *string `json:"TlsSetting,omitempty" xml:"TlsSetting,omitempty"`
}

func (s ImportServicesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesShrinkRequest) GoString() string {
	return s.String()
}

func (s *ImportServicesShrinkRequest) SetAcceptLanguage(v string) *ImportServicesShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetFcAlias(v string) *ImportServicesShrinkRequest {
	s.FcAlias = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetFcServiceName(v string) *ImportServicesShrinkRequest {
	s.FcServiceName = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetFcVersion(v string) *ImportServicesShrinkRequest {
	s.FcVersion = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetGatewayUniqueId(v string) *ImportServicesShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetServiceListShrink(v string) *ImportServicesShrinkRequest {
	s.ServiceListShrink = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetSourceType(v string) *ImportServicesShrinkRequest {
	s.SourceType = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetTlsSetting(v string) *ImportServicesShrinkRequest {
	s.TlsSetting = &v
	return s
}

type ImportServicesResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ImportServicesResponseBody) SetCode(v int32) *ImportServicesResponseBody {
	s.Code = &v
	return s
}

func (s *ImportServicesResponseBody) SetData(v bool) *ImportServicesResponseBody {
	s.Data = &v
	return s
}

func (s *ImportServicesResponseBody) SetHttpStatusCode(v int32) *ImportServicesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ImportServicesResponseBody) SetMessage(v string) *ImportServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ImportServicesResponseBody) SetRequestId(v string) *ImportServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportServicesResponseBody) SetSuccess(v bool) *ImportServicesResponseBody {
	s.Success = &v
	return s
}

type ImportServicesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesResponse) GoString() string {
	return s.String()
}

func (s *ImportServicesResponse) SetHeaders(v map[string]*string) *ImportServicesResponse {
	s.Headers = v
	return s
}

func (s *ImportServicesResponse) SetStatusCode(v int32) *ImportServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportServicesResponse) SetBody(v *ImportServicesResponseBody) *ImportServicesResponse {
	s.Body = v
	return s
}

type ImportZookeeperDataRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the file that you want to import.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The URL of the source data.
	//
	// > You must set this parameter to the URL that is generated by calling the GetZookeeperDataImportUrl operation.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ImportZookeeperDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportZookeeperDataRequest) GoString() string {
	return s.String()
}

func (s *ImportZookeeperDataRequest) SetAcceptLanguage(v string) *ImportZookeeperDataRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetFileName(v string) *ImportZookeeperDataRequest {
	s.FileName = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetFileUrl(v string) *ImportZookeeperDataRequest {
	s.FileUrl = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetInstanceId(v string) *ImportZookeeperDataRequest {
	s.InstanceId = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetRegionId(v string) *ImportZookeeperDataRequest {
	s.RegionId = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetRequestPars(v string) *ImportZookeeperDataRequest {
	s.RequestPars = &v
	return s
}

type ImportZookeeperDataResponseBody struct {
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportZookeeperDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportZookeeperDataResponseBody) GoString() string {
	return s.String()
}

func (s *ImportZookeeperDataResponseBody) SetData(v interface{}) *ImportZookeeperDataResponseBody {
	s.Data = v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetErrorCode(v string) *ImportZookeeperDataResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetHttpCode(v string) *ImportZookeeperDataResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetMessage(v string) *ImportZookeeperDataResponseBody {
	s.Message = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetRequestId(v string) *ImportZookeeperDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetSuccess(v bool) *ImportZookeeperDataResponseBody {
	s.Success = &v
	return s
}

type ImportZookeeperDataResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportZookeeperDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportZookeeperDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportZookeeperDataResponse) GoString() string {
	return s.String()
}

func (s *ImportZookeeperDataResponse) SetHeaders(v map[string]*string) *ImportZookeeperDataResponse {
	s.Headers = v
	return s
}

func (s *ImportZookeeperDataResponse) SetStatusCode(v int32) *ImportZookeeperDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportZookeeperDataResponse) SetBody(v *ImportZookeeperDataResponseBody) *ImportZookeeperDataResponse {
	s.Body = v
	return s
}

type ListAnsInstancesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the Nacos instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The alias of the Nacos instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The name of the contact group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListAnsInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesRequest) SetAcceptLanguage(v string) *ListAnsInstancesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAnsInstancesRequest) SetClusterId(v string) *ListAnsInstancesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListAnsInstancesRequest) SetClusterName(v string) *ListAnsInstancesRequest {
	s.ClusterName = &v
	return s
}

func (s *ListAnsInstancesRequest) SetGroupName(v string) *ListAnsInstancesRequest {
	s.GroupName = &v
	return s
}

func (s *ListAnsInstancesRequest) SetInstanceId(v string) *ListAnsInstancesRequest {
	s.InstanceId = &v
	return s
}

func (s *ListAnsInstancesRequest) SetNamespaceId(v string) *ListAnsInstancesRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListAnsInstancesRequest) SetPageNum(v int32) *ListAnsInstancesRequest {
	s.PageNum = &v
	return s
}

func (s *ListAnsInstancesRequest) SetPageSize(v int32) *ListAnsInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *ListAnsInstancesRequest) SetRequestPars(v string) *ListAnsInstancesRequest {
	s.RequestPars = &v
	return s
}

func (s *ListAnsInstancesRequest) SetServiceName(v string) *ListAnsInstancesRequest {
	s.ServiceName = &v
	return s
}

type ListAnsInstancesResponseBody struct {
	// The details of the data.
	Data []*ListAnsInstancesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAnsInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesResponseBody) SetData(v []*ListAnsInstancesResponseBodyData) *ListAnsInstancesResponseBody {
	s.Data = v
	return s
}

func (s *ListAnsInstancesResponseBody) SetErrorCode(v string) *ListAnsInstancesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetHttpCode(v string) *ListAnsInstancesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetMessage(v string) *ListAnsInstancesResponseBody {
	s.Message = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetPageNumber(v int32) *ListAnsInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetPageSize(v int32) *ListAnsInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetRequestId(v string) *ListAnsInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetSuccess(v bool) *ListAnsInstancesResponseBody {
	s.Success = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetTotalCount(v int32) *ListAnsInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type ListAnsInstancesResponseBodyData struct {
	// The name of the application.
	App *string `json:"App,omitempty" xml:"App,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The reference key.
	DatumKey *string `json:"DatumKey,omitempty" xml:"DatumKey,omitempty"`
	// The default key.
	DefaultKey *string `json:"DefaultKey,omitempty" xml:"DefaultKey,omitempty"`
	// The effective status of the instance. Valid values:
	//
	// *   `true`: The instance takes effect.
	// *   `false`: The instance does not take effect.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether the information about the ephemeral node is obtained. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The number of counted failures.
	FailCount *int32 `json:"FailCount,omitempty" xml:"FailCount,omitempty"`
	// The health status of the instance. Valid values:
	//
	// *   `true`: The instance is healthy.
	// *   `false`: The instance is unhealthy.
	Healthy *bool `json:"Healthy,omitempty" xml:"Healthy,omitempty"`
	// The heartbeat interval of the instance. Unit: seconds.
	InstanceHeartBeatInterval *int32 `json:"InstanceHeartBeatInterval,omitempty" xml:"InstanceHeartBeatInterval,omitempty"`
	// The timeout period of the instance heartbeat.
	InstanceHeartBeatTimeOut *int32 `json:"InstanceHeartBeatTimeOut,omitempty" xml:"InstanceHeartBeatTimeOut,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The public IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The timeout period for removing an IP address.
	IpDeleteTimeout *int32 `json:"IpDeleteTimeout,omitempty" xml:"IpDeleteTimeout,omitempty"`
	// The last heartbeat time.
	LastBeat *int64 `json:"LastBeat,omitempty" xml:"LastBeat,omitempty"`
	// Indicates whether the instance was marked. Valid values:
	//
	// *   `true`: The instance marking was successful.
	// *   `false`: The instance marking failed.
	Marked *bool `json:"Marked,omitempty" xml:"Marked,omitempty"`
	// The metadata.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The number of counted successes.
	OkCount *int32 `json:"OkCount,omitempty" xml:"OkCount,omitempty"`
	// The port number.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The weight.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ListAnsInstancesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesResponseBodyData) SetApp(v string) *ListAnsInstancesResponseBodyData {
	s.App = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetClusterName(v string) *ListAnsInstancesResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetDatumKey(v string) *ListAnsInstancesResponseBodyData {
	s.DatumKey = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetDefaultKey(v string) *ListAnsInstancesResponseBodyData {
	s.DefaultKey = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetEnabled(v bool) *ListAnsInstancesResponseBodyData {
	s.Enabled = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetEphemeral(v bool) *ListAnsInstancesResponseBodyData {
	s.Ephemeral = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetFailCount(v int32) *ListAnsInstancesResponseBodyData {
	s.FailCount = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetHealthy(v bool) *ListAnsInstancesResponseBodyData {
	s.Healthy = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetInstanceHeartBeatInterval(v int32) *ListAnsInstancesResponseBodyData {
	s.InstanceHeartBeatInterval = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetInstanceHeartBeatTimeOut(v int32) *ListAnsInstancesResponseBodyData {
	s.InstanceHeartBeatTimeOut = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetInstanceId(v string) *ListAnsInstancesResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetIp(v string) *ListAnsInstancesResponseBodyData {
	s.Ip = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetIpDeleteTimeout(v int32) *ListAnsInstancesResponseBodyData {
	s.IpDeleteTimeout = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetLastBeat(v int64) *ListAnsInstancesResponseBodyData {
	s.LastBeat = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetMarked(v bool) *ListAnsInstancesResponseBodyData {
	s.Marked = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetMetadata(v map[string]interface{}) *ListAnsInstancesResponseBodyData {
	s.Metadata = v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetOkCount(v int32) *ListAnsInstancesResponseBodyData {
	s.OkCount = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetPort(v int32) *ListAnsInstancesResponseBodyData {
	s.Port = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetServiceName(v string) *ListAnsInstancesResponseBodyData {
	s.ServiceName = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetWeight(v int32) *ListAnsInstancesResponseBodyData {
	s.Weight = &v
	return s
}

type ListAnsInstancesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAnsInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAnsInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesResponse) SetHeaders(v map[string]*string) *ListAnsInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListAnsInstancesResponse) SetStatusCode(v int32) *ListAnsInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnsInstancesResponse) SetBody(v *ListAnsInstancesResponseBody) *ListAnsInstancesResponse {
	s.Body = v
	return s
}

type ListAnsServiceClustersRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the MSE cluster.
	//
	// > The MSE cluster is different from the cluster of the Nacos service.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The alias of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListAnsServiceClustersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersRequest) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersRequest) SetAcceptLanguage(v string) *ListAnsServiceClustersRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetClusterId(v string) *ListAnsServiceClustersRequest {
	s.ClusterId = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetClusterName(v string) *ListAnsServiceClustersRequest {
	s.ClusterName = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetGroupName(v string) *ListAnsServiceClustersRequest {
	s.GroupName = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetInstanceId(v string) *ListAnsServiceClustersRequest {
	s.InstanceId = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetNamespaceId(v string) *ListAnsServiceClustersRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetPageNum(v int32) *ListAnsServiceClustersRequest {
	s.PageNum = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetPageSize(v int32) *ListAnsServiceClustersRequest {
	s.PageSize = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetServiceName(v string) *ListAnsServiceClustersRequest {
	s.ServiceName = &v
	return s
}

type ListAnsServiceClustersResponseBody struct {
	// The data returned.
	Data *ListAnsServiceClustersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAnsServiceClustersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponseBody) SetData(v *ListAnsServiceClustersResponseBodyData) *ListAnsServiceClustersResponseBody {
	s.Data = v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetErrorCode(v string) *ListAnsServiceClustersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetHttpCode(v string) *ListAnsServiceClustersResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetMessage(v string) *ListAnsServiceClustersResponseBody {
	s.Message = &v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetRequestId(v string) *ListAnsServiceClustersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetSuccess(v bool) *ListAnsServiceClustersResponseBody {
	s.Success = &v
	return s
}

type ListAnsServiceClustersResponseBodyData struct {
	// The information about the associated application for which Microservices Governance is enabled when the Source parameter is set to governance.
	AppDetail *ListAnsServiceClustersResponseBodyDataAppDetail `json:"AppDetail,omitempty" xml:"AppDetail,omitempty" type:"Struct"`
	// The cluster information.
	Clusters []*ListAnsServiceClustersResponseBodyDataClusters `json:"Clusters,omitempty" xml:"Clusters,omitempty" type:"Repeated"`
	// Indicates whether the service is a temporary service. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The service group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The metadata of the service.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protection threshold.
	ProtectThreshold *float32 `json:"ProtectThreshold,omitempty" xml:"ProtectThreshold,omitempty"`
	// The election mode.
	SelectorType *string `json:"SelectorType,omitempty" xml:"SelectorType,omitempty"`
	// The source type of the service. Valid values:
	//
	// *   console: The service was registered in the console.
	// *   sdk: The service was registered by using the SDK.
	// *   governance: The service was registered on Microservices Governance.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ListAnsServiceClustersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponseBodyData) SetAppDetail(v *ListAnsServiceClustersResponseBodyDataAppDetail) *ListAnsServiceClustersResponseBodyData {
	s.AppDetail = v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetClusters(v []*ListAnsServiceClustersResponseBodyDataClusters) *ListAnsServiceClustersResponseBodyData {
	s.Clusters = v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetEphemeral(v bool) *ListAnsServiceClustersResponseBodyData {
	s.Ephemeral = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetGroupName(v string) *ListAnsServiceClustersResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetMetadata(v map[string]interface{}) *ListAnsServiceClustersResponseBodyData {
	s.Metadata = v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetName(v string) *ListAnsServiceClustersResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetProtectThreshold(v float32) *ListAnsServiceClustersResponseBodyData {
	s.ProtectThreshold = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetSelectorType(v string) *ListAnsServiceClustersResponseBodyData {
	s.SelectorType = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetSource(v string) *ListAnsServiceClustersResponseBodyData {
	s.Source = &v
	return s
}

type ListAnsServiceClustersResponseBodyDataAppDetail struct {
	// The ID of the application for which Microservices Governance is enabled.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application for which Microservices Governance is enabled.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The health check interval. Unit: seconds.
	CheckInternal *int32 `json:"CheckInternal,omitempty" xml:"CheckInternal,omitempty"`
	// The path of the health check. This parameter is required only when the CheckType parameter is set to http.
	CheckPath *string `json:"CheckPath,omitempty" xml:"CheckPath,omitempty"`
	// The timeout period of the health check response. Unit: seconds.
	CheckTimeout *int32 `json:"CheckTimeout,omitempty" xml:"CheckTimeout,omitempty"`
	// The type of the health check. Valid values:
	//
	// *   connection: connection status check
	// *   tcp: TCP connection check
	// *   http: HTTP connection check
	CheckType *string `json:"CheckType,omitempty" xml:"CheckType,omitempty"`
	// The maximum number of health check retries when the instance state changes from unhealthy to healthy.
	HealthyCheckTimes *int32 `json:"HealthyCheckTimes,omitempty" xml:"HealthyCheckTimes,omitempty"`
	// The port number of the application for which Microservices Governance is enabled.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The maximum number of health check retries when the instance state changes from healthy to unhealthy.
	UnhealthyCheckTimes *int32 `json:"UnhealthyCheckTimes,omitempty" xml:"UnhealthyCheckTimes,omitempty"`
}

func (s ListAnsServiceClustersResponseBodyDataAppDetail) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponseBodyDataAppDetail) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetAppId(v string) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.AppId = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetAppName(v string) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.AppName = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetCheckInternal(v int32) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.CheckInternal = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetCheckPath(v string) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.CheckPath = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetCheckTimeout(v int32) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.CheckTimeout = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetCheckType(v string) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.CheckType = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetHealthyCheckTimes(v int32) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.HealthyCheckTimes = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetPort(v int32) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.Port = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataAppDetail) SetUnhealthyCheckTimes(v int32) *ListAnsServiceClustersResponseBodyDataAppDetail {
	s.UnhealthyCheckTimes = &v
	return s
}

type ListAnsServiceClustersResponseBodyDataClusters struct {
	// The default port used for a health check.
	DefaultCheckPort *int32 `json:"DefaultCheckPort,omitempty" xml:"DefaultCheckPort,omitempty"`
	// The default port.
	DefaultPort *int32 `json:"DefaultPort,omitempty" xml:"DefaultPort,omitempty"`
	// The type of the health check.
	HealthCheckerType *string `json:"HealthCheckerType,omitempty" xml:"HealthCheckerType,omitempty"`
	// The metadata of the cluster.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The cluster name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The full name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// Indicates whether an end-to-end health check was initiated by the server. This parameter is valid only if the service is not a temporary service.
	UseIPPort4Check *bool `json:"UseIPPort4Check,omitempty" xml:"UseIPPort4Check,omitempty"`
}

func (s ListAnsServiceClustersResponseBodyDataClusters) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponseBodyDataClusters) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetDefaultCheckPort(v int32) *ListAnsServiceClustersResponseBodyDataClusters {
	s.DefaultCheckPort = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetDefaultPort(v int32) *ListAnsServiceClustersResponseBodyDataClusters {
	s.DefaultPort = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetHealthCheckerType(v string) *ListAnsServiceClustersResponseBodyDataClusters {
	s.HealthCheckerType = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetMetadata(v map[string]interface{}) *ListAnsServiceClustersResponseBodyDataClusters {
	s.Metadata = v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetName(v string) *ListAnsServiceClustersResponseBodyDataClusters {
	s.Name = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetServiceName(v string) *ListAnsServiceClustersResponseBodyDataClusters {
	s.ServiceName = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetUseIPPort4Check(v bool) *ListAnsServiceClustersResponseBodyDataClusters {
	s.UseIPPort4Check = &v
	return s
}

type ListAnsServiceClustersResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAnsServiceClustersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAnsServiceClustersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponse) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponse) SetHeaders(v map[string]*string) *ListAnsServiceClustersResponse {
	s.Headers = v
	return s
}

func (s *ListAnsServiceClustersResponse) SetStatusCode(v int32) *ListAnsServiceClustersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnsServiceClustersResponse) SetBody(v *ListAnsServiceClustersResponseBody) *ListAnsServiceClustersResponse {
	s.Body = v
	return s
}

type ListAnsServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// 
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The name of the contact group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// Specifies whether to query the number of instances that are used for the service.
	HasIpCount *string `json:"HasIpCount,omitempty" xml:"HasIpCount,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries returned per page.
	PageSize *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListAnsServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesRequest) GoString() string {
	return s.String()
}

func (s *ListAnsServicesRequest) SetAcceptLanguage(v string) *ListAnsServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAnsServicesRequest) SetClusterId(v string) *ListAnsServicesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListAnsServicesRequest) SetClusterName(v string) *ListAnsServicesRequest {
	s.ClusterName = &v
	return s
}

func (s *ListAnsServicesRequest) SetGroupName(v string) *ListAnsServicesRequest {
	s.GroupName = &v
	return s
}

func (s *ListAnsServicesRequest) SetHasIpCount(v string) *ListAnsServicesRequest {
	s.HasIpCount = &v
	return s
}

func (s *ListAnsServicesRequest) SetInstanceId(v string) *ListAnsServicesRequest {
	s.InstanceId = &v
	return s
}

func (s *ListAnsServicesRequest) SetNamespaceId(v string) *ListAnsServicesRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListAnsServicesRequest) SetPageNum(v int32) *ListAnsServicesRequest {
	s.PageNum = &v
	return s
}

func (s *ListAnsServicesRequest) SetPageSize(v int32) *ListAnsServicesRequest {
	s.PageSize = &v
	return s
}

func (s *ListAnsServicesRequest) SetRegionId(v string) *ListAnsServicesRequest {
	s.RegionId = &v
	return s
}

func (s *ListAnsServicesRequest) SetRequestPars(v string) *ListAnsServicesRequest {
	s.RequestPars = &v
	return s
}

func (s *ListAnsServicesRequest) SetServiceName(v string) *ListAnsServicesRequest {
	s.ServiceName = &v
	return s
}

type ListAnsServicesResponseBody struct {
	// The details of the data.
	Data []*ListAnsServicesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of instances returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAnsServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnsServicesResponseBody) SetData(v []*ListAnsServicesResponseBodyData) *ListAnsServicesResponseBody {
	s.Data = v
	return s
}

func (s *ListAnsServicesResponseBody) SetErrorCode(v string) *ListAnsServicesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetHttpCode(v string) *ListAnsServicesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetMessage(v string) *ListAnsServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetPageNumber(v int32) *ListAnsServicesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetPageSize(v int32) *ListAnsServicesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetRequestId(v string) *ListAnsServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetSuccess(v bool) *ListAnsServicesResponseBody {
	s.Success = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetTotalCount(v int32) *ListAnsServicesResponseBody {
	s.TotalCount = &v
	return s
}

type ListAnsServicesResponseBodyData struct {
	// The total number of clusters.
	ClusterCount *int32 `json:"ClusterCount,omitempty" xml:"ClusterCount,omitempty"`
	// The name of the contact group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The total number of instances with healthy heartbeats.
	HealthyInstanceCount *int32 `json:"HealthyInstanceCount,omitempty" xml:"HealthyInstanceCount,omitempty"`
	// The total number of instances that are used for the current service.
	IpCount *int32 `json:"IpCount,omitempty" xml:"IpCount,omitempty"`
	// The name of the service.
	Name   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ListAnsServicesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAnsServicesResponseBodyData) SetClusterCount(v int32) *ListAnsServicesResponseBodyData {
	s.ClusterCount = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetGroupName(v string) *ListAnsServicesResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetHealthyInstanceCount(v int32) *ListAnsServicesResponseBodyData {
	s.HealthyInstanceCount = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetIpCount(v int32) *ListAnsServicesResponseBodyData {
	s.IpCount = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetName(v string) *ListAnsServicesResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetSource(v string) *ListAnsServicesResponseBodyData {
	s.Source = &v
	return s
}

type ListAnsServicesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAnsServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAnsServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesResponse) GoString() string {
	return s.String()
}

func (s *ListAnsServicesResponse) SetHeaders(v map[string]*string) *ListAnsServicesResponse {
	s.Headers = v
	return s
}

func (s *ListAnsServicesResponse) SetStatusCode(v int32) *ListAnsServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnsServicesResponse) SetBody(v *ListAnsServicesResponseBody) *ListAnsServicesResponse {
	s.Body = v
	return s
}

type ListAppBySwimmingLaneGroupTagRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the Microservices Engine (MSE) namespace that you want to query.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ListAppBySwimmingLaneGroupTagRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagRequest) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagRequest) SetAcceptLanguage(v string) *ListAppBySwimmingLaneGroupTagRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagRequest) SetGroupId(v int64) *ListAppBySwimmingLaneGroupTagRequest {
	s.GroupId = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagRequest) SetNamespace(v string) *ListAppBySwimmingLaneGroupTagRequest {
	s.Namespace = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagRequest) SetTag(v string) *ListAppBySwimmingLaneGroupTagRequest {
	s.Tag = &v
	return s
}

type ListAppBySwimmingLaneGroupTagResponseBody struct {
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAppBySwimmingLaneGroupTagResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagResponseBody) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetData(v interface{}) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.Data = v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetErrorCode(v string) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetMessage(v string) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.Message = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetRequestId(v string) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetSuccess(v bool) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.Success = &v
	return s
}

type ListAppBySwimmingLaneGroupTagResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAppBySwimmingLaneGroupTagResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAppBySwimmingLaneGroupTagResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagResponse) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagResponse) SetHeaders(v map[string]*string) *ListAppBySwimmingLaneGroupTagResponse {
	s.Headers = v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponse) SetStatusCode(v int32) *ListAppBySwimmingLaneGroupTagResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponse) SetBody(v *ListAppBySwimmingLaneGroupTagResponseBody) *ListAppBySwimmingLaneGroupTagResponse {
	s.Body = v
	return s
}

type ListAppBySwimmingLaneGroupTagsRequest struct {
	// The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the MSE namespace that you want to query.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The tag based on which you want to list applications.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListAppBySwimmingLaneGroupTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagsRequest) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagsRequest) SetAcceptLanguage(v string) *ListAppBySwimmingLaneGroupTagsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsRequest) SetGroupId(v int64) *ListAppBySwimmingLaneGroupTagsRequest {
	s.GroupId = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsRequest) SetNamespace(v string) *ListAppBySwimmingLaneGroupTagsRequest {
	s.Namespace = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsRequest) SetTags(v []*string) *ListAppBySwimmingLaneGroupTagsRequest {
	s.Tags = v
	return s
}

type ListAppBySwimmingLaneGroupTagsShrinkRequest struct {
	// The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the MSE namespace that you want to query.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The tag based on which you want to list applications.
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListAppBySwimmingLaneGroupTagsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagsShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagsShrinkRequest) SetAcceptLanguage(v string) *ListAppBySwimmingLaneGroupTagsShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsShrinkRequest) SetGroupId(v int64) *ListAppBySwimmingLaneGroupTagsShrinkRequest {
	s.GroupId = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsShrinkRequest) SetNamespace(v string) *ListAppBySwimmingLaneGroupTagsShrinkRequest {
	s.Namespace = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsShrinkRequest) SetTagsShrink(v string) *ListAppBySwimmingLaneGroupTagsShrinkRequest {
	s.TagsShrink = &v
	return s
}

type ListAppBySwimmingLaneGroupTagsResponseBody struct {
	// The returned data.
	Data map[string][]*DataValue `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The additional request information.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAppBySwimmingLaneGroupTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagsResponseBody) SetData(v map[string][]*DataValue) *ListAppBySwimmingLaneGroupTagsResponseBody {
	s.Data = v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsResponseBody) SetErrorCode(v string) *ListAppBySwimmingLaneGroupTagsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsResponseBody) SetMessage(v string) *ListAppBySwimmingLaneGroupTagsResponseBody {
	s.Message = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsResponseBody) SetRequestId(v string) *ListAppBySwimmingLaneGroupTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsResponseBody) SetSuccess(v bool) *ListAppBySwimmingLaneGroupTagsResponseBody {
	s.Success = &v
	return s
}

type ListAppBySwimmingLaneGroupTagsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAppBySwimmingLaneGroupTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAppBySwimmingLaneGroupTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagsResponse) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagsResponse) SetHeaders(v map[string]*string) *ListAppBySwimmingLaneGroupTagsResponse {
	s.Headers = v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsResponse) SetStatusCode(v int32) *ListAppBySwimmingLaneGroupTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagsResponse) SetBody(v *ListAppBySwimmingLaneGroupTagsResponseBody) *ListAppBySwimmingLaneGroupTagsResponse {
	s.Body = v
	return s
}

type ListApplicationsWithTagRulesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Deprecated
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The MSE namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The source of the routing rule. Default value: edasmsc.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ListApplicationsWithTagRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesRequest) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesRequest) SetAcceptLanguage(v string) *ListApplicationsWithTagRulesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetAppId(v string) *ListApplicationsWithTagRulesRequest {
	s.AppId = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetAppName(v string) *ListApplicationsWithTagRulesRequest {
	s.AppName = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetNamespace(v string) *ListApplicationsWithTagRulesRequest {
	s.Namespace = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetPageNumber(v int32) *ListApplicationsWithTagRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetPageSize(v int32) *ListApplicationsWithTagRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetRegion(v string) *ListApplicationsWithTagRulesRequest {
	s.Region = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetSource(v string) *ListApplicationsWithTagRulesRequest {
	s.Source = &v
	return s
}

type ListApplicationsWithTagRulesResponseBody struct {
	// The response parameters.
	Data *ListApplicationsWithTagRulesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBody) SetData(v *ListApplicationsWithTagRulesResponseBodyData) *ListApplicationsWithTagRulesResponseBody {
	s.Data = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetHttpStatusCode(v int32) *ListApplicationsWithTagRulesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetMessage(v string) *ListApplicationsWithTagRulesResponseBody {
	s.Message = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetRequestId(v string) *ListApplicationsWithTagRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetSuccess(v bool) *ListApplicationsWithTagRulesResponseBody {
	s.Success = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned data.
	Result []*ListApplicationsWithTagRulesResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetPageNumber(v int32) *ListApplicationsWithTagRulesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetPageSize(v int32) *ListApplicationsWithTagRulesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetResult(v []*ListApplicationsWithTagRulesResponseBodyDataResult) *ListApplicationsWithTagRulesResponseBodyData {
	s.Result = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetTotalSize(v int32) *ListApplicationsWithTagRulesResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResult struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The MSE namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The queried rules.
	RouteRules []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRules `json:"RouteRules,omitempty" xml:"RouteRules,omitempty" type:"Repeated"`
	// The route state. Valid values:
	//
	// *   0: disabled
	// *   1: enabled
	RouteStatus *int64 `json:"RouteStatus,omitempty" xml:"RouteStatus,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetAppId(v string) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetAppName(v string) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetNamespace(v string) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetRouteRules(v []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.RouteRules = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetRouteStatus(v int64) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.RouteStatus = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResultRouteRules struct {
	// Indicates whether the alert rule is enabled. Valid values:
	//
	// *   `true`
	// *   `false`
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The rule ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The number of instances.
	InstanceNum *int32 `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	// The rule name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The rate.
	Rate *int32 `json:"Rate,omitempty" xml:"Rate,omitempty"`
	// The details of the routing rule.
	Rules *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetEnable(v bool) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Enable = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetId(v int64) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Id = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetInstanceNum(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.InstanceNum = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetName(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Name = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetRate(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Rate = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetRules(v *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Rules = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetStatus(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Status = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetTag(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Tag = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules struct {
	Dubbo       []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo       `json:"dubbo,omitempty" xml:"dubbo,omitempty" type:"Repeated"`
	Springcloud []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud `json:"springcloud,omitempty" xml:"springcloud,omitempty" type:"Repeated"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules) SetDubbo(v []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules {
	s.Dubbo = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules) SetSpringcloud(v []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRules {
	s.Springcloud = v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo struct {
	AppId         *string                                                                                `json:"appId,omitempty" xml:"appId,omitempty"`
	ArgumentItems []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems `json:"argumentItems,omitempty" xml:"argumentItems,omitempty" type:"Repeated"`
	Condition     *string                                                                                `json:"condition,omitempty" xml:"condition,omitempty"`
	Group         *string                                                                                `json:"group,omitempty" xml:"group,omitempty"`
	MethodName    *string                                                                                `json:"methodName,omitempty" xml:"methodName,omitempty"`
	ParamTypes    []*string                                                                              `json:"paramTypes,omitempty" xml:"paramTypes,omitempty" type:"Repeated"`
	ServiceName   *string                                                                                `json:"serviceName,omitempty" xml:"serviceName,omitempty"`
	Tags          []*string                                                                              `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	TriggerPolicy *string                                                                                `json:"triggerPolicy,omitempty" xml:"triggerPolicy,omitempty"`
	Version       *string                                                                                `json:"version,omitempty" xml:"version,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetAppId(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.AppId = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetArgumentItems(v []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.ArgumentItems = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetCondition(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.Condition = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetGroup(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.Group = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetMethodName(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.MethodName = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetParamTypes(v []*string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.ParamTypes = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetServiceName(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.ServiceName = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetTags(v []*string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.Tags = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetTriggerPolicy(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.TriggerPolicy = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo) SetVersion(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubbo {
	s.Version = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems struct {
	Cond      *string   `json:"cond,omitempty" xml:"cond,omitempty"`
	Datum     *string   `json:"datum,omitempty" xml:"datum,omitempty"`
	Divisor   *int32    `json:"divisor,omitempty" xml:"divisor,omitempty"`
	Expr      *string   `json:"expr,omitempty" xml:"expr,omitempty"`
	Index     *int32    `json:"index,omitempty" xml:"index,omitempty"`
	NameList  []*string `json:"nameList,omitempty" xml:"nameList,omitempty" type:"Repeated"`
	Operator  *string   `json:"operator,omitempty" xml:"operator,omitempty"`
	Rate      *int32    `json:"rate,omitempty" xml:"rate,omitempty"`
	Remainder *int32    `json:"remainder,omitempty" xml:"remainder,omitempty"`
	Value     *string   `json:"value,omitempty" xml:"value,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetCond(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Cond = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetDatum(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Datum = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetDivisor(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Divisor = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetExpr(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Expr = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetIndex(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Index = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetNameList(v []*string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.NameList = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetOperator(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Operator = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetRate(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Rate = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetRemainder(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Remainder = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems) SetValue(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesDubboArgumentItems {
	s.Value = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud struct {
	AppId         *string                                                                                  `json:"appId,omitempty" xml:"appId,omitempty"`
	Condition     *string                                                                                  `json:"condition,omitempty" xml:"condition,omitempty"`
	Enable        *bool                                                                                    `json:"enable,omitempty" xml:"enable,omitempty"`
	Path          *string                                                                                  `json:"path,omitempty" xml:"path,omitempty"`
	Paths         []*string                                                                                `json:"paths,omitempty" xml:"paths,omitempty" type:"Repeated"`
	Priority      *int32                                                                                   `json:"priority,omitempty" xml:"priority,omitempty"`
	RestItems     []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems `json:"restItems,omitempty" xml:"restItems,omitempty" type:"Repeated"`
	Tags          []*string                                                                                `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	TriggerPolicy *string                                                                                  `json:"triggerPolicy,omitempty" xml:"triggerPolicy,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetAppId(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.AppId = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetCondition(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.Condition = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetEnable(v bool) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.Enable = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetPath(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.Path = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetPaths(v []*string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.Paths = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetPriority(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.Priority = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetRestItems(v []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.RestItems = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetTags(v []*string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.Tags = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud) SetTriggerPolicy(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloud {
	s.TriggerPolicy = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems struct {
	Cond      *string   `json:"cond,omitempty" xml:"cond,omitempty"`
	Datum     *string   `json:"datum,omitempty" xml:"datum,omitempty"`
	Divisor   *int32    `json:"divisor,omitempty" xml:"divisor,omitempty"`
	Name      *string   `json:"name,omitempty" xml:"name,omitempty"`
	NameList  []*string `json:"nameList,omitempty" xml:"nameList,omitempty" type:"Repeated"`
	Operator  *string   `json:"operator,omitempty" xml:"operator,omitempty"`
	Rate      *int32    `json:"rate,omitempty" xml:"rate,omitempty"`
	Remainder *int32    `json:"remainder,omitempty" xml:"remainder,omitempty"`
	Type      *string   `json:"type,omitempty" xml:"type,omitempty"`
	Value     *string   `json:"value,omitempty" xml:"value,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetCond(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Cond = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetDatum(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Datum = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetDivisor(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Divisor = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetName(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Name = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetNameList(v []*string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.NameList = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetOperator(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Operator = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetRate(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Rate = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetRemainder(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Remainder = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetType(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Type = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems) SetValue(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRulesRulesSpringcloudRestItems {
	s.Value = &v
	return s
}

type ListApplicationsWithTagRulesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListApplicationsWithTagRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListApplicationsWithTagRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponse) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponse) SetHeaders(v map[string]*string) *ListApplicationsWithTagRulesResponse {
	s.Headers = v
	return s
}

func (s *ListApplicationsWithTagRulesResponse) SetStatusCode(v int32) *ListApplicationsWithTagRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponse) SetBody(v *ListApplicationsWithTagRulesResponseBody) *ListApplicationsWithTagRulesResponse {
	s.Body = v
	return s
}

type ListAuthPolicyRequest struct {
	// The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese and the value en-US indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the authentication rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the Microservices Engine (MSE) namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The page number.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The protocol type. Valid values:
	//
	// *   **SPRING_CLOUD**
	// *   **DUBBO**
	// *   **istio**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ListAuthPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAuthPolicyRequest) GoString() string {
	return s.String()
}

func (s *ListAuthPolicyRequest) SetAcceptLanguage(v string) *ListAuthPolicyRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAuthPolicyRequest) SetAppId(v string) *ListAuthPolicyRequest {
	s.AppId = &v
	return s
}

func (s *ListAuthPolicyRequest) SetName(v string) *ListAuthPolicyRequest {
	s.Name = &v
	return s
}

func (s *ListAuthPolicyRequest) SetNamespace(v string) *ListAuthPolicyRequest {
	s.Namespace = &v
	return s
}

func (s *ListAuthPolicyRequest) SetPageNumber(v string) *ListAuthPolicyRequest {
	s.PageNumber = &v
	return s
}

func (s *ListAuthPolicyRequest) SetPageSize(v string) *ListAuthPolicyRequest {
	s.PageSize = &v
	return s
}

func (s *ListAuthPolicyRequest) SetProtocol(v string) *ListAuthPolicyRequest {
	s.Protocol = &v
	return s
}

func (s *ListAuthPolicyRequest) SetRegion(v string) *ListAuthPolicyRequest {
	s.Region = &v
	return s
}

func (s *ListAuthPolicyRequest) SetSource(v string) *ListAuthPolicyRequest {
	s.Source = &v
	return s
}

type ListAuthPolicyResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ListAuthPolicyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAuthPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAuthPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ListAuthPolicyResponseBody) SetCode(v int32) *ListAuthPolicyResponseBody {
	s.Code = &v
	return s
}

func (s *ListAuthPolicyResponseBody) SetData(v *ListAuthPolicyResponseBodyData) *ListAuthPolicyResponseBody {
	s.Data = v
	return s
}

func (s *ListAuthPolicyResponseBody) SetHttpStatusCode(v int32) *ListAuthPolicyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListAuthPolicyResponseBody) SetMessage(v string) *ListAuthPolicyResponseBody {
	s.Message = &v
	return s
}

func (s *ListAuthPolicyResponseBody) SetRequestId(v string) *ListAuthPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAuthPolicyResponseBody) SetSuccess(v bool) *ListAuthPolicyResponseBody {
	s.Success = &v
	return s
}

type ListAuthPolicyResponseBodyData struct {
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data returned.
	Result []*ListAuthPolicyResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListAuthPolicyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAuthPolicyResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAuthPolicyResponseBodyData) SetPageNumber(v int32) *ListAuthPolicyResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListAuthPolicyResponseBodyData) SetPageSize(v int32) *ListAuthPolicyResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListAuthPolicyResponseBodyData) SetResult(v []*ListAuthPolicyResponseBodyDataResult) *ListAuthPolicyResponseBodyData {
	s.Result = v
	return s
}

func (s *ListAuthPolicyResponseBodyData) SetTotalSize(v int32) *ListAuthPolicyResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListAuthPolicyResponseBodyDataResult struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *string `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The content of the service authentication rule.
	AuthRule []*ListAuthPolicyResponseBodyDataResultAuthRule `json:"AuthRule,omitempty" xml:"AuthRule,omitempty" type:"Repeated"`
	// The rule type. Valid values:
	//
	// *   0: by application
	// *   1: by namespace
	AuthType *int32 `json:"AuthType,omitempty" xml:"AuthType,omitempty"`
	// Indicates whether the rule was enabled or disabled. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The rule ID.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The namespace.
	K8sNamespace *string `json:"K8sNamespace,omitempty" xml:"K8sNamespace,omitempty"`
	// The name of the authentication rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace ID.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The protocol type. Valid values:
	//
	// *   **SPRING_CLOUD**
	// *   **DUBBO**
	// *   **istio**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The source of the application.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAuthPolicyResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListAuthPolicyResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListAuthPolicyResponseBodyDataResult) SetAccountId(v string) *ListAuthPolicyResponseBodyDataResult {
	s.AccountId = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetAppId(v string) *ListAuthPolicyResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetAppName(v string) *ListAuthPolicyResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetAuthRule(v []*ListAuthPolicyResponseBodyDataResultAuthRule) *ListAuthPolicyResponseBodyDataResult {
	s.AuthRule = v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetAuthType(v int32) *ListAuthPolicyResponseBodyDataResult {
	s.AuthType = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetEnable(v bool) *ListAuthPolicyResponseBodyDataResult {
	s.Enable = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetId(v int32) *ListAuthPolicyResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetK8sNamespace(v string) *ListAuthPolicyResponseBodyDataResult {
	s.K8sNamespace = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetName(v string) *ListAuthPolicyResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetNamespaceId(v string) *ListAuthPolicyResponseBodyDataResult {
	s.NamespaceId = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetProtocol(v string) *ListAuthPolicyResponseBodyDataResult {
	s.Protocol = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetRegionId(v string) *ListAuthPolicyResponseBodyDataResult {
	s.RegionId = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetSource(v string) *ListAuthPolicyResponseBodyDataResult {
	s.Source = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResult) SetStatus(v int32) *ListAuthPolicyResponseBodyDataResult {
	s.Status = &v
	return s
}

type ListAuthPolicyResponseBodyDataResultAuthRule struct {
	// The IDs of applications.
	AppIds []*string `json:"AppIds,omitempty" xml:"AppIds,omitempty" type:"Repeated"`
	// The rule type. Valid values:
	//
	// *   0: by application
	// *   1: by namespace
	AuthType *int32 `json:"AuthType,omitempty" xml:"AuthType,omitempty"`
	// Indicates whether the rule is a blacklist rule.
	Black *bool `json:"Black,omitempty" xml:"Black,omitempty"`
	// The queried namespaces.
	K8sNamespaces []*string `json:"K8sNamespaces,omitempty" xml:"K8sNamespaces,omitempty" type:"Repeated"`
	// The request method.
	Method *ListAuthPolicyResponseBodyDataResultAuthRuleMethod `json:"Method,omitempty" xml:"Method,omitempty" type:"Struct"`
	// The service path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListAuthPolicyResponseBodyDataResultAuthRule) String() string {
	return tea.Prettify(s)
}

func (s ListAuthPolicyResponseBodyDataResultAuthRule) GoString() string {
	return s.String()
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRule) SetAppIds(v []*string) *ListAuthPolicyResponseBodyDataResultAuthRule {
	s.AppIds = v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRule) SetAuthType(v int32) *ListAuthPolicyResponseBodyDataResultAuthRule {
	s.AuthType = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRule) SetBlack(v bool) *ListAuthPolicyResponseBodyDataResultAuthRule {
	s.Black = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRule) SetK8sNamespaces(v []*string) *ListAuthPolicyResponseBodyDataResultAuthRule {
	s.K8sNamespaces = v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRule) SetMethod(v *ListAuthPolicyResponseBodyDataResultAuthRuleMethod) *ListAuthPolicyResponseBodyDataResultAuthRule {
	s.Method = v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRule) SetPath(v string) *ListAuthPolicyResponseBodyDataResultAuthRule {
	s.Path = &v
	return s
}

type ListAuthPolicyResponseBodyDataResultAuthRuleMethod struct {
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The method name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The types of request parameters.
	ParameterTypes []*string `json:"ParameterTypes,omitempty" xml:"ParameterTypes,omitempty" type:"Repeated"`
	// The type of the return value.
	ReturnType *string `json:"ReturnType,omitempty" xml:"ReturnType,omitempty"`
	// The service name.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The method version.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListAuthPolicyResponseBodyDataResultAuthRuleMethod) String() string {
	return tea.Prettify(s)
}

func (s ListAuthPolicyResponseBodyDataResultAuthRuleMethod) GoString() string {
	return s.String()
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRuleMethod) SetGroup(v string) *ListAuthPolicyResponseBodyDataResultAuthRuleMethod {
	s.Group = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRuleMethod) SetName(v string) *ListAuthPolicyResponseBodyDataResultAuthRuleMethod {
	s.Name = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRuleMethod) SetParameterTypes(v []*string) *ListAuthPolicyResponseBodyDataResultAuthRuleMethod {
	s.ParameterTypes = v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRuleMethod) SetReturnType(v string) *ListAuthPolicyResponseBodyDataResultAuthRuleMethod {
	s.ReturnType = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRuleMethod) SetServiceName(v string) *ListAuthPolicyResponseBodyDataResultAuthRuleMethod {
	s.ServiceName = &v
	return s
}

func (s *ListAuthPolicyResponseBodyDataResultAuthRuleMethod) SetVersion(v string) *ListAuthPolicyResponseBodyDataResultAuthRuleMethod {
	s.Version = &v
	return s
}

type ListAuthPolicyResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAuthPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAuthPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAuthPolicyResponse) GoString() string {
	return s.String()
}

func (s *ListAuthPolicyResponse) SetHeaders(v map[string]*string) *ListAuthPolicyResponse {
	s.Headers = v
	return s
}

func (s *ListAuthPolicyResponse) SetStatusCode(v int32) *ListAuthPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAuthPolicyResponse) SetBody(v *ListAuthPolicyResponseBody) *ListAuthPolicyResponse {
	s.Body = v
	return s
}

type ListCircuitBreakerRulesRequest struct {
	// The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese, and the value en-US indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The start page of the returned pages. Default value: 1.
	PageIndex *int32 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries per page. Default value: 6.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// This parameter is used for exact match of circuit breaking rules.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// This parameter is used for fuzzy match of circuit breaking rules.
	ResourceSearchKey *string `json:"ResourceSearchKey,omitempty" xml:"ResourceSearchKey,omitempty"`
}

func (s ListCircuitBreakerRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCircuitBreakerRulesRequest) GoString() string {
	return s.String()
}

func (s *ListCircuitBreakerRulesRequest) SetAcceptLanguage(v string) *ListCircuitBreakerRulesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListCircuitBreakerRulesRequest) SetAppId(v string) *ListCircuitBreakerRulesRequest {
	s.AppId = &v
	return s
}

func (s *ListCircuitBreakerRulesRequest) SetAppName(v string) *ListCircuitBreakerRulesRequest {
	s.AppName = &v
	return s
}

func (s *ListCircuitBreakerRulesRequest) SetNamespace(v string) *ListCircuitBreakerRulesRequest {
	s.Namespace = &v
	return s
}

func (s *ListCircuitBreakerRulesRequest) SetPageIndex(v int32) *ListCircuitBreakerRulesRequest {
	s.PageIndex = &v
	return s
}

func (s *ListCircuitBreakerRulesRequest) SetPageSize(v int32) *ListCircuitBreakerRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListCircuitBreakerRulesRequest) SetResource(v string) *ListCircuitBreakerRulesRequest {
	s.Resource = &v
	return s
}

func (s *ListCircuitBreakerRulesRequest) SetResourceSearchKey(v string) *ListCircuitBreakerRulesRequest {
	s.ResourceSearchKey = &v
	return s
}

type ListCircuitBreakerRulesResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the rule.
	Data *ListCircuitBreakerRulesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListCircuitBreakerRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCircuitBreakerRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCircuitBreakerRulesResponseBody) SetCode(v int32) *ListCircuitBreakerRulesResponseBody {
	s.Code = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBody) SetData(v *ListCircuitBreakerRulesResponseBodyData) *ListCircuitBreakerRulesResponseBody {
	s.Data = v
	return s
}

func (s *ListCircuitBreakerRulesResponseBody) SetHttpStatusCode(v int32) *ListCircuitBreakerRulesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBody) SetMessage(v string) *ListCircuitBreakerRulesResponseBody {
	s.Message = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBody) SetRequestId(v string) *ListCircuitBreakerRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBody) SetSuccess(v bool) *ListCircuitBreakerRulesResponseBody {
	s.Success = &v
	return s
}

type ListCircuitBreakerRulesResponseBodyData struct {
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned result.
	Result []*ListCircuitBreakerRulesResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of pages.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListCircuitBreakerRulesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListCircuitBreakerRulesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListCircuitBreakerRulesResponseBodyData) SetPageNumber(v int32) *ListCircuitBreakerRulesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyData) SetPageSize(v int32) *ListCircuitBreakerRulesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyData) SetResult(v []*ListCircuitBreakerRulesResponseBodyDataResult) *ListCircuitBreakerRulesResponseBodyData {
	s.Result = v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyData) SetTotalSize(v int32) *ListCircuitBreakerRulesResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListCircuitBreakerRulesResponseBodyDataResult struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Indicates whether the rule was enabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The behavior that was bound to the rule.
	FallbackObject *string `json:"FallbackObject,omitempty" xml:"FallbackObject,omitempty"`
	// The minimum number of requests that can be passed in each step after circuit breaking recovers.
	HalfOpenBaseAmountPerStep *int32 `json:"HalfOpenBaseAmountPerStep,omitempty" xml:"HalfOpenBaseAmountPerStep,omitempty"`
	// The number of circuit breaking recovery steps.
	HalfOpenRecoveryStepNum *int32 `json:"HalfOpenRecoveryStepNum,omitempty" xml:"HalfOpenRecoveryStepNum,omitempty"`
	// The maximum response time (RT). Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
	MaxAllowedRtMs *int32 `json:"MaxAllowedRtMs,omitempty" xml:"MaxAllowedRtMs,omitempty"`
	// The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met.
	MinRequestAmount *int32 `json:"MinRequestAmount,omitempty" xml:"MinRequestAmount,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region where the cluster resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the interface to which the rule is applicable. The interface name must be the same as the name on the interface details page in the console.
	Resource     *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceType *int32  `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period.
	RetryTimeoutMs *int32 `json:"RetryTimeoutMs,omitempty" xml:"RetryTimeoutMs,omitempty"`
	// The ID of the rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes.
	StatIntervalMs *int32 `json:"StatIntervalMs,omitempty" xml:"StatIntervalMs,omitempty"`
	// The threshold type.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     slow call proportion
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     abnormal proportion
	//
	//     <!-- -->
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s ListCircuitBreakerRulesResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListCircuitBreakerRulesResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetAppId(v string) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetAppName(v string) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetEnable(v bool) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.Enable = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetFallbackObject(v string) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.FallbackObject = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetHalfOpenBaseAmountPerStep(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.HalfOpenBaseAmountPerStep = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetHalfOpenRecoveryStepNum(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.HalfOpenRecoveryStepNum = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetMaxAllowedRtMs(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.MaxAllowedRtMs = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetMinRequestAmount(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.MinRequestAmount = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetNamespace(v string) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetRegionId(v string) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.RegionId = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetResource(v string) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.Resource = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetResourceType(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.ResourceType = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetRetryTimeoutMs(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.RetryTimeoutMs = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetRuleId(v int64) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.RuleId = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetStatIntervalMs(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.StatIntervalMs = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetStrategy(v int32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.Strategy = &v
	return s
}

func (s *ListCircuitBreakerRulesResponseBodyDataResult) SetThreshold(v float32) *ListCircuitBreakerRulesResponseBodyDataResult {
	s.Threshold = &v
	return s
}

type ListCircuitBreakerRulesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCircuitBreakerRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCircuitBreakerRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCircuitBreakerRulesResponse) GoString() string {
	return s.String()
}

func (s *ListCircuitBreakerRulesResponse) SetHeaders(v map[string]*string) *ListCircuitBreakerRulesResponse {
	s.Headers = v
	return s
}

func (s *ListCircuitBreakerRulesResponse) SetStatusCode(v int32) *ListCircuitBreakerRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCircuitBreakerRulesResponse) SetBody(v *ListCircuitBreakerRulesResponseBody) *ListCircuitBreakerRulesResponse {
	s.Body = v
	return s
}

type ListClusterConnectionTypesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s ListClusterConnectionTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesRequest) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesRequest) SetAcceptLanguage(v string) *ListClusterConnectionTypesRequest {
	s.AcceptLanguage = &v
	return s
}

type ListClusterConnectionTypesResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*ListClusterConnectionTypesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterConnectionTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesResponseBody) SetCode(v int32) *ListClusterConnectionTypesResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetData(v []*ListClusterConnectionTypesResponseBodyData) *ListClusterConnectionTypesResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetDynamicMessage(v string) *ListClusterConnectionTypesResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetErrorCode(v string) *ListClusterConnectionTypesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetHttpStatusCode(v int32) *ListClusterConnectionTypesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetMessage(v string) *ListClusterConnectionTypesResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetRequestId(v string) *ListClusterConnectionTypesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetSuccess(v bool) *ListClusterConnectionTypesResponseBody {
	s.Success = &v
	return s
}

type ListClusterConnectionTypesResponseBodyData struct {
	// The connection type.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
}

func (s ListClusterConnectionTypesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesResponseBodyData) SetShowName(v string) *ListClusterConnectionTypesResponseBodyData {
	s.ShowName = &v
	return s
}

type ListClusterConnectionTypesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterConnectionTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterConnectionTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesResponse) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesResponse) SetHeaders(v map[string]*string) *ListClusterConnectionTypesResponse {
	s.Headers = v
	return s
}

func (s *ListClusterConnectionTypesResponse) SetStatusCode(v int32) *ListClusterConnectionTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterConnectionTypesResponse) SetBody(v *ListClusterConnectionTypesResponseBody) *ListClusterConnectionTypesResponse {
	s.Body = v
	return s
}

type ListClusterHealthCheckTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region in which the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListClusterHealthCheckTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskRequest) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskRequest) SetAcceptLanguage(v string) *ListClusterHealthCheckTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetInstanceId(v string) *ListClusterHealthCheckTaskRequest {
	s.InstanceId = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetPageNum(v int32) *ListClusterHealthCheckTaskRequest {
	s.PageNum = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetPageSize(v int32) *ListClusterHealthCheckTaskRequest {
	s.PageSize = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetRegionId(v string) *ListClusterHealthCheckTaskRequest {
	s.RegionId = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetRequestPars(v string) *ListClusterHealthCheckTaskRequest {
	s.RequestPars = &v
	return s
}

type ListClusterHealthCheckTaskResponseBody struct {
	// The status code. A value of 200 is returned if the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ListClusterHealthCheckTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed. Take note of the following rules:
	//
	// *   The **ErrorCode** parameter is not returned if the request is successful.
	// *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section in this topic.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBody) SetCode(v int32) *ListClusterHealthCheckTaskResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetData(v *ListClusterHealthCheckTaskResponseBodyData) *ListClusterHealthCheckTaskResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetDynamicCode(v string) *ListClusterHealthCheckTaskResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetDynamicMessage(v string) *ListClusterHealthCheckTaskResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetErrorCode(v string) *ListClusterHealthCheckTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetHttpStatusCode(v int32) *ListClusterHealthCheckTaskResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetMessage(v string) *ListClusterHealthCheckTaskResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetRequestId(v string) *ListClusterHealthCheckTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetSuccess(v bool) *ListClusterHealthCheckTaskResponseBody {
	s.Success = &v
	return s
}

type ListClusterHealthCheckTaskResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The list of health check tasks.
	Result []*ListClusterHealthCheckTaskResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of returned entries.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetPageNumber(v int32) *ListClusterHealthCheckTaskResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetPageSize(v int32) *ListClusterHealthCheckTaskResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetResult(v []*ListClusterHealthCheckTaskResponseBodyDataResult) *ListClusterHealthCheckTaskResponseBodyData {
	s.Result = v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetTotalSize(v int32) *ListClusterHealthCheckTaskResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListClusterHealthCheckTaskResponseBodyDataResult struct {
	// The complete version number.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The type of the cluster.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The time when the task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// A redundant parameter.
	ImageVersion *string `json:"ImageVersion,omitempty" xml:"ImageVersion,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the user to which the instance belongs.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The number of nodes in the instance.
	Replica *string `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The list of risk items.
	RiskList []*ListClusterHealthCheckTaskResponseBodyDataResultRiskList `json:"RiskList,omitempty" xml:"RiskList,omitempty" type:"Repeated"`
	// The total score.
	Score *int32 `json:"Score,omitempty" xml:"Score,omitempty"`
	// The specifications.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the task.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total number of check items.
	TotalItem *int32 `json:"TotalItem,omitempty" xml:"TotalItem,omitempty"`
	// The total number of risk items.
	TotalRisk *int32 `json:"TotalRisk,omitempty" xml:"TotalRisk,omitempty"`
	// A redundant parameter.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The last update time.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The version number.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetAppVersion(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.AppVersion = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetChargeType(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.ChargeType = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetClusterType(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.ClusterType = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetCreateTime(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.CreateTime = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetId(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetImageVersion(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.ImageVersion = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetInstanceId(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.InstanceId = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetPrimaryUser(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.PrimaryUser = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetReplica(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Replica = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetRiskList(v []*ListClusterHealthCheckTaskResponseBodyDataResultRiskList) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.RiskList = v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetScore(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Score = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetSpec(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Spec = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetStatus(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetTotalItem(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.TotalItem = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetTotalRisk(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.TotalRisk = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetType(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Type = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetUpdateTime(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.UpdateTime = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetVersionCode(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.VersionCode = &v
	return s
}

type ListClusterHealthCheckTaskResponseBodyDataResultRiskList struct {
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// A redundant parameter.
	Module *string `json:"Module,omitempty" xml:"Module,omitempty"`
	// Indicates whether the risk item notification feature is disabled.
	//
	// *   true: disabled
	// *   false: enabled
	Mute *bool `json:"Mute,omitempty" xml:"Mute,omitempty"`
	// A redundant parameter.
	NoticeFeature *bool `json:"NoticeFeature,omitempty" xml:"NoticeFeature,omitempty"`
	// The ID of the user to which the cluster belongs.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The risk code.
	RiskCode *string `json:"RiskCode,omitempty" xml:"RiskCode,omitempty"`
	// The severity of the risk. Valid values:
	//
	// *   HIGH: high risk
	// *   MID: medium risk
	// *   LOW: low risk
	RiskLevel *string `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The name of the risk.
	RiskName *string `json:"RiskName,omitempty" xml:"RiskName,omitempty"`
	// The type of the risk.
	RiskType *string `json:"RiskType,omitempty" xml:"RiskType,omitempty"`
	// The situation.
	Situation *string `json:"Situation,omitempty" xml:"Situation,omitempty"`
	// The suggestion.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The ID of the associated parent task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// A redundant parameter.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
	// A redundant parameter.
	Values *string `json:"Values,omitempty" xml:"Values,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBodyDataResultRiskList) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBodyDataResultRiskList) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetDescription(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Description = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetId(v int32) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Id = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetModule(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Module = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetMute(v bool) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Mute = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetNoticeFeature(v bool) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.NoticeFeature = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetPrimaryUser(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.PrimaryUser = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskCode(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskLevel(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskLevel = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskName(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskName = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskType(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskType = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetSituation(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Situation = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetSuggestion(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Suggestion = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetTaskId(v int64) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.TaskId = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetType(v int32) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Type = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetValues(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Values = &v
	return s
}

type ListClusterHealthCheckTaskResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterHealthCheckTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterHealthCheckTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponse) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponse) SetHeaders(v map[string]*string) *ListClusterHealthCheckTaskResponse {
	s.Headers = v
	return s
}

func (s *ListClusterHealthCheckTaskResponse) SetStatusCode(v int32) *ListClusterHealthCheckTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponse) SetBody(v *ListClusterHealthCheckTaskResponseBody) *ListClusterHealthCheckTaskResponse {
	s.Body = v
	return s
}

type ListClusterTypesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The network type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectType *string `json:"ConnectType,omitempty" xml:"ConnectType,omitempty"`
	// The edition of the MSE instance that you want to purchase.
	//
	// *   mse_pro: Professional Edition
	// *   mse_dev: Developer Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListClusterTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesRequest) GoString() string {
	return s.String()
}

func (s *ListClusterTypesRequest) SetAcceptLanguage(v string) *ListClusterTypesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClusterTypesRequest) SetConnectType(v string) *ListClusterTypesRequest {
	s.ConnectType = &v
	return s
}

func (s *ListClusterTypesRequest) SetMseVersion(v string) *ListClusterTypesRequest {
	s.MseVersion = &v
	return s
}

func (s *ListClusterTypesRequest) SetRegionId(v string) *ListClusterTypesRequest {
	s.RegionId = &v
	return s
}

type ListClusterTypesResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*ListClusterTypesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterTypesResponseBody) SetCode(v int32) *ListClusterTypesResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetData(v []*ListClusterTypesResponseBodyData) *ListClusterTypesResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterTypesResponseBody) SetDynamicMessage(v string) *ListClusterTypesResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetErrorCode(v string) *ListClusterTypesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetHttpStatusCode(v int32) *ListClusterTypesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetMessage(v string) *ListClusterTypesResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetRequestId(v string) *ListClusterTypesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetSuccess(v bool) *ListClusterTypesResponseBody {
	s.Success = &v
	return s
}

type ListClusterTypesResponseBodyData struct {
	// The type of the MSE engine that can be activated.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
}

func (s ListClusterTypesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterTypesResponseBodyData) SetShowName(v string) *ListClusterTypesResponseBodyData {
	s.ShowName = &v
	return s
}

type ListClusterTypesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesResponse) GoString() string {
	return s.String()
}

func (s *ListClusterTypesResponse) SetHeaders(v map[string]*string) *ListClusterTypesResponse {
	s.Headers = v
	return s
}

func (s *ListClusterTypesResponse) SetStatusCode(v int32) *ListClusterTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterTypesResponse) SetBody(v *ListClusterTypesResponseBody) *ListClusterTypesResponse {
	s.Body = v
	return s
}

type ListClusterVersionsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The instance edition. Valid values:
	//
	// *   `mse_dev`: Developer Edition.
	// *   `mse_pro`: Professional Edition. This is the default value.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
}

func (s ListClusterVersionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsRequest) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsRequest) SetAcceptLanguage(v string) *ListClusterVersionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClusterVersionsRequest) SetClusterType(v string) *ListClusterVersionsRequest {
	s.ClusterType = &v
	return s
}

func (s *ListClusterVersionsRequest) SetMseVersion(v string) *ListClusterVersionsRequest {
	s.MseVersion = &v
	return s
}

type ListClusterVersionsResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*ListClusterVersionsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterVersionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsResponseBody) SetCode(v int32) *ListClusterVersionsResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetData(v []*ListClusterVersionsResponseBodyData) *ListClusterVersionsResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterVersionsResponseBody) SetDynamicMessage(v string) *ListClusterVersionsResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetErrorCode(v string) *ListClusterVersionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetHttpStatusCode(v int32) *ListClusterVersionsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetMessage(v string) *ListClusterVersionsResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetRequestId(v string) *ListClusterVersionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetSuccess(v bool) *ListClusterVersionsResponseBody {
	s.Success = &v
	return s
}

type ListClusterVersionsResponseBodyData struct {
	// The type of the instance.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The code of the instance type.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The version of the instance.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
}

func (s ListClusterVersionsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsResponseBodyData) SetClusterType(v string) *ListClusterVersionsResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *ListClusterVersionsResponseBodyData) SetCode(v string) *ListClusterVersionsResponseBodyData {
	s.Code = &v
	return s
}

func (s *ListClusterVersionsResponseBodyData) SetShowName(v string) *ListClusterVersionsResponseBodyData {
	s.ShowName = &v
	return s
}

type ListClusterVersionsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterVersionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterVersionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsResponse) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsResponse) SetHeaders(v map[string]*string) *ListClusterVersionsResponse {
	s.Headers = v
	return s
}

func (s *ListClusterVersionsResponse) SetStatusCode(v int32) *ListClusterVersionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterVersionsResponse) SetBody(v *ListClusterVersionsResponseBody) *ListClusterVersionsResponse {
	s.Body = v
	return s
}

type ListClustersRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The alias of the instance. Fuzzy match is supported.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The ID of the resource group. For more information about resource groups, see the topic "View basic information of a resource group."
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of tags. A maximum number of 20 tags are supported.
	Tag []*ListClustersRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListClustersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClustersRequest) GoString() string {
	return s.String()
}

func (s *ListClustersRequest) SetAcceptLanguage(v string) *ListClustersRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClustersRequest) SetClusterAliasName(v string) *ListClustersRequest {
	s.ClusterAliasName = &v
	return s
}

func (s *ListClustersRequest) SetPageNum(v int32) *ListClustersRequest {
	s.PageNum = &v
	return s
}

func (s *ListClustersRequest) SetPageSize(v int32) *ListClustersRequest {
	s.PageSize = &v
	return s
}

func (s *ListClustersRequest) SetRegionId(v string) *ListClustersRequest {
	s.RegionId = &v
	return s
}

func (s *ListClustersRequest) SetRequestPars(v string) *ListClustersRequest {
	s.RequestPars = &v
	return s
}

func (s *ListClustersRequest) SetResourceGroupId(v string) *ListClustersRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListClustersRequest) SetTag(v []*ListClustersRequestTag) *ListClustersRequest {
	s.Tag = v
	return s
}

type ListClustersRequestTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListClustersRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListClustersRequestTag) GoString() string {
	return s.String()
}

func (s *ListClustersRequestTag) SetKey(v string) *ListClustersRequestTag {
	s.Key = &v
	return s
}

func (s *ListClustersRequestTag) SetValue(v string) *ListClustersRequestTag {
	s.Value = &v
	return s
}

type ListClustersResponseBody struct {
	// The details of the data.
	Data []*ListClustersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListClustersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClustersResponseBody) GoString() string {
	return s.String()
}

func (s *ListClustersResponseBody) SetData(v []*ListClustersResponseBodyData) *ListClustersResponseBody {
	s.Data = v
	return s
}

func (s *ListClustersResponseBody) SetErrorCode(v string) *ListClustersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClustersResponseBody) SetHttpCode(v string) *ListClustersResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListClustersResponseBody) SetMessage(v string) *ListClustersResponseBody {
	s.Message = &v
	return s
}

func (s *ListClustersResponseBody) SetPageNumber(v int32) *ListClustersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListClustersResponseBody) SetPageSize(v int32) *ListClustersResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListClustersResponseBody) SetRequestId(v string) *ListClustersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClustersResponseBody) SetSuccess(v bool) *ListClustersResponseBody {
	s.Success = &v
	return s
}

func (s *ListClustersResponseBody) SetTotalCount(v int32) *ListClustersResponseBody {
	s.TotalCount = &v
	return s
}

type ListClustersResponseBodyData struct {
	// The application version.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// Indicates whether the instance can be upgraded.
	CanUpdate *bool `json:"CanUpdate,omitempty" xml:"CanUpdate,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The alias of the cluster.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the cluster. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The time when the cluster was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the cluster expires.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The initialization status of the instance.
	InitStatus *string `json:"InitStatus,omitempty" xml:"InitStatus,omitempty"`
	// The number of clusters.
	InstanceCount *int64 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The public IP address.
	InternetAddress *string `json:"InternetAddress,omitempty" xml:"InternetAddress,omitempty"`
	// The public endpoint.
	InternetDomain *string `json:"InternetDomain,omitempty" xml:"InternetDomain,omitempty"`
	// The internal IP address.
	IntranetAddress *string `json:"IntranetAddress,omitempty" xml:"IntranetAddress,omitempty"`
	// The internal endpoint.
	IntranetDomain    *string                                        `json:"IntranetDomain,omitempty" xml:"IntranetDomain,omitempty"`
	MaintenancePeriod *ListClustersResponseBodyDataMaintenancePeriod `json:"MaintenancePeriod,omitempty" xml:"MaintenancePeriod,omitempty" type:"Struct"`
	// The edition of the cluster.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags that are attached to the instance.
	Tags map[string]interface{} `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The version information.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
	VpcId       *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListClustersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClustersResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClustersResponseBodyData) SetAppVersion(v string) *ListClustersResponseBodyData {
	s.AppVersion = &v
	return s
}

func (s *ListClustersResponseBodyData) SetCanUpdate(v bool) *ListClustersResponseBodyData {
	s.CanUpdate = &v
	return s
}

func (s *ListClustersResponseBodyData) SetChargeType(v string) *ListClustersResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *ListClustersResponseBodyData) SetClusterAliasName(v string) *ListClustersResponseBodyData {
	s.ClusterAliasName = &v
	return s
}

func (s *ListClustersResponseBodyData) SetClusterName(v string) *ListClustersResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *ListClustersResponseBodyData) SetClusterType(v string) *ListClustersResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *ListClustersResponseBodyData) SetCreateTime(v string) *ListClustersResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ListClustersResponseBodyData) SetEndDate(v string) *ListClustersResponseBodyData {
	s.EndDate = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInitStatus(v string) *ListClustersResponseBodyData {
	s.InitStatus = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInstanceCount(v int64) *ListClustersResponseBodyData {
	s.InstanceCount = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInstanceId(v string) *ListClustersResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInternetAddress(v string) *ListClustersResponseBodyData {
	s.InternetAddress = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInternetDomain(v string) *ListClustersResponseBodyData {
	s.InternetDomain = &v
	return s
}

func (s *ListClustersResponseBodyData) SetIntranetAddress(v string) *ListClustersResponseBodyData {
	s.IntranetAddress = &v
	return s
}

func (s *ListClustersResponseBodyData) SetIntranetDomain(v string) *ListClustersResponseBodyData {
	s.IntranetDomain = &v
	return s
}

func (s *ListClustersResponseBodyData) SetMaintenancePeriod(v *ListClustersResponseBodyDataMaintenancePeriod) *ListClustersResponseBodyData {
	s.MaintenancePeriod = v
	return s
}

func (s *ListClustersResponseBodyData) SetMseVersion(v string) *ListClustersResponseBodyData {
	s.MseVersion = &v
	return s
}

func (s *ListClustersResponseBodyData) SetResourceGroupId(v string) *ListClustersResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *ListClustersResponseBodyData) SetTags(v map[string]interface{}) *ListClustersResponseBodyData {
	s.Tags = v
	return s
}

func (s *ListClustersResponseBodyData) SetVersionCode(v string) *ListClustersResponseBodyData {
	s.VersionCode = &v
	return s
}

func (s *ListClustersResponseBodyData) SetVpcId(v string) *ListClustersResponseBodyData {
	s.VpcId = &v
	return s
}

type ListClustersResponseBodyDataMaintenancePeriod struct {
	EndTime   *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s ListClustersResponseBodyDataMaintenancePeriod) String() string {
	return tea.Prettify(s)
}

func (s ListClustersResponseBodyDataMaintenancePeriod) GoString() string {
	return s.String()
}

func (s *ListClustersResponseBodyDataMaintenancePeriod) SetEndTime(v string) *ListClustersResponseBodyDataMaintenancePeriod {
	s.EndTime = &v
	return s
}

func (s *ListClustersResponseBodyDataMaintenancePeriod) SetStartTime(v string) *ListClustersResponseBodyDataMaintenancePeriod {
	s.StartTime = &v
	return s
}

type ListClustersResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClustersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClustersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClustersResponse) GoString() string {
	return s.String()
}

func (s *ListClustersResponse) SetHeaders(v map[string]*string) *ListClustersResponse {
	s.Headers = v
	return s
}

func (s *ListClustersResponse) SetStatusCode(v int32) *ListClustersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClustersResponse) SetBody(v *ListClustersResponseBody) *ListClustersResponse {
	s.Body = v
	return s
}

type ListConfigTrackRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The end timestamp. Unit: seconds.
	EndTs *int64 `json:"EndTs,omitempty" xml:"EndTs,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the listener.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// Specifies whether to enable reverse ordering. Valid values:
	//
	// *   true
	// *   false
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The start timestamp. Unit: seconds.
	StartTs *int64 `json:"StartTs,omitempty" xml:"StartTs,omitempty"`
}

func (s ListConfigTrackRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackRequest) GoString() string {
	return s.String()
}

func (s *ListConfigTrackRequest) SetAcceptLanguage(v string) *ListConfigTrackRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListConfigTrackRequest) SetDataId(v string) *ListConfigTrackRequest {
	s.DataId = &v
	return s
}

func (s *ListConfigTrackRequest) SetEndTs(v int64) *ListConfigTrackRequest {
	s.EndTs = &v
	return s
}

func (s *ListConfigTrackRequest) SetGroup(v string) *ListConfigTrackRequest {
	s.Group = &v
	return s
}

func (s *ListConfigTrackRequest) SetInstanceId(v string) *ListConfigTrackRequest {
	s.InstanceId = &v
	return s
}

func (s *ListConfigTrackRequest) SetIp(v string) *ListConfigTrackRequest {
	s.Ip = &v
	return s
}

func (s *ListConfigTrackRequest) SetNamespaceId(v string) *ListConfigTrackRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListConfigTrackRequest) SetPageNum(v int64) *ListConfigTrackRequest {
	s.PageNum = &v
	return s
}

func (s *ListConfigTrackRequest) SetPageSize(v int64) *ListConfigTrackRequest {
	s.PageSize = &v
	return s
}

func (s *ListConfigTrackRequest) SetRequestPars(v string) *ListConfigTrackRequest {
	s.RequestPars = &v
	return s
}

func (s *ListConfigTrackRequest) SetReverse(v bool) *ListConfigTrackRequest {
	s.Reverse = &v
	return s
}

func (s *ListConfigTrackRequest) SetStartTs(v int64) *ListConfigTrackRequest {
	s.StartTs = &v
	return s
}

type ListConfigTrackResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The track data.
	Traces []*ListConfigTrackResponseBodyTraces `json:"Traces,omitempty" xml:"Traces,omitempty" type:"Repeated"`
}

func (s ListConfigTrackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigTrackResponseBody) SetErrorCode(v string) *ListConfigTrackResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetHttpCode(v string) *ListConfigTrackResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetMessage(v string) *ListConfigTrackResponseBody {
	s.Message = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetPageNumber(v int64) *ListConfigTrackResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetPageSize(v int64) *ListConfigTrackResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetRequestId(v string) *ListConfigTrackResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetSuccess(v bool) *ListConfigTrackResponseBody {
	s.Success = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetTotalCount(v int64) *ListConfigTrackResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetTraces(v []*ListConfigTrackResponseBodyTraces) *ListConfigTrackResponseBody {
	s.Traces = v
	return s
}

type ListConfigTrackResponseBodyTraces struct {
	// Indicates whether the request is sent from the client. Valid values:
	//
	// *   true
	// *   false
	Client *bool `json:"Client,omitempty" xml:"Client,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The response latency. Unit: milliseconds.
	Delay *string `json:"Delay,omitempty" xml:"Delay,omitempty"`
	// The event. Valid values:
	//
	// *   pull: configuration acquisition events
	// *   persist: persistence events
	Event *string `json:"Event,omitempty" xml:"Event,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The logging time.
	LogDate *string `json:"LogDate,omitempty" xml:"LogDate,omitempty"`
	// The MD5 value.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// Indicates whether messages are pushed by a server. Valid values:
	//
	// *   true
	// *   false
	Push *bool `json:"Push,omitempty" xml:"Push,omitempty"`
	// The source IP address of the request.
	RequestIp *string `json:"RequestIp,omitempty" xml:"RequestIp,omitempty"`
	// The response node.
	ResponseIp *string `json:"ResponseIp,omitempty" xml:"ResponseIp,omitempty"`
	// The result.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
	// The timestamp that indicates the time when the metric value is collected.
	//
	// Unit: seconds.
	Ts *string `json:"Ts,omitempty" xml:"Ts,omitempty"`
	// The release type. Valid values:
	//
	// *   beta: beta release
	// *   tag: canary release
	// *   batch: batch release
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListConfigTrackResponseBodyTraces) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackResponseBodyTraces) GoString() string {
	return s.String()
}

func (s *ListConfigTrackResponseBodyTraces) SetClient(v bool) *ListConfigTrackResponseBodyTraces {
	s.Client = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetDataId(v string) *ListConfigTrackResponseBodyTraces {
	s.DataId = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetDelay(v string) *ListConfigTrackResponseBodyTraces {
	s.Delay = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetEvent(v string) *ListConfigTrackResponseBodyTraces {
	s.Event = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetGroup(v string) *ListConfigTrackResponseBodyTraces {
	s.Group = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetLogDate(v string) *ListConfigTrackResponseBodyTraces {
	s.LogDate = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetMd5(v string) *ListConfigTrackResponseBodyTraces {
	s.Md5 = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetPush(v bool) *ListConfigTrackResponseBodyTraces {
	s.Push = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetRequestIp(v string) *ListConfigTrackResponseBodyTraces {
	s.RequestIp = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetResponseIp(v string) *ListConfigTrackResponseBodyTraces {
	s.ResponseIp = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetResult(v string) *ListConfigTrackResponseBodyTraces {
	s.Result = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetTs(v string) *ListConfigTrackResponseBodyTraces {
	s.Ts = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetType(v string) *ListConfigTrackResponseBodyTraces {
	s.Type = &v
	return s
}

type ListConfigTrackResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListConfigTrackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListConfigTrackResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackResponse) GoString() string {
	return s.String()
}

func (s *ListConfigTrackResponse) SetHeaders(v map[string]*string) *ListConfigTrackResponse {
	s.Headers = v
	return s
}

func (s *ListConfigTrackResponse) SetStatusCode(v int32) *ListConfigTrackResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigTrackResponse) SetBody(v *ListConfigTrackResponseBody) *ListConfigTrackResponse {
	s.Body = v
	return s
}

type ListEngineNamespacesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ListEngineNamespacesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesRequest) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesRequest) SetAcceptLanguage(v string) *ListEngineNamespacesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListEngineNamespacesRequest) SetInstanceId(v string) *ListEngineNamespacesRequest {
	s.InstanceId = &v
	return s
}

type ListEngineNamespacesResponseBody struct {
	// The details of the data.
	Data []*ListEngineNamespacesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListEngineNamespacesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesResponseBody) SetData(v []*ListEngineNamespacesResponseBodyData) *ListEngineNamespacesResponseBody {
	s.Data = v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetErrorCode(v string) *ListEngineNamespacesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetHttpCode(v string) *ListEngineNamespacesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetMessage(v string) *ListEngineNamespacesResponseBody {
	s.Message = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetPageNumber(v int32) *ListEngineNamespacesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetPageSize(v int32) *ListEngineNamespacesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetRequestId(v string) *ListEngineNamespacesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetSuccess(v bool) *ListEngineNamespacesResponseBody {
	s.Success = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetTotalCount(v int32) *ListEngineNamespacesResponseBody {
	s.TotalCount = &v
	return s
}

type ListEngineNamespacesResponseBodyData struct {
	// The quota value.
	ConfigCount *int32 `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quota.
	Quota *int32 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The number of active services.
	ServiceCount *string `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
	// The source from which the namespace was created.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   `0`: global configuration
	// *   `1`: default namespace
	// *   `2`: custom namespace
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListEngineNamespacesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesResponseBodyData) SetConfigCount(v int32) *ListEngineNamespacesResponseBodyData {
	s.ConfigCount = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetNamespace(v string) *ListEngineNamespacesResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetNamespaceDesc(v string) *ListEngineNamespacesResponseBodyData {
	s.NamespaceDesc = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetNamespaceShowName(v string) *ListEngineNamespacesResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetQuota(v int32) *ListEngineNamespacesResponseBodyData {
	s.Quota = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetServiceCount(v string) *ListEngineNamespacesResponseBodyData {
	s.ServiceCount = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetSourceType(v string) *ListEngineNamespacesResponseBodyData {
	s.SourceType = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetType(v int32) *ListEngineNamespacesResponseBodyData {
	s.Type = &v
	return s
}

type ListEngineNamespacesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEngineNamespacesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEngineNamespacesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesResponse) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesResponse) SetHeaders(v map[string]*string) *ListEngineNamespacesResponse {
	s.Headers = v
	return s
}

func (s *ListEngineNamespacesResponse) SetStatusCode(v int32) *ListEngineNamespacesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEngineNamespacesResponse) SetBody(v *ListEngineNamespacesResponseBody) *ListEngineNamespacesResponse {
	s.Body = v
	return s
}

type ListEurekaInstancesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListEurekaInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesRequest) SetAcceptLanguage(v string) *ListEurekaInstancesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetClusterId(v string) *ListEurekaInstancesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetPageNum(v int32) *ListEurekaInstancesRequest {
	s.PageNum = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetPageSize(v int32) *ListEurekaInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetRequestPars(v string) *ListEurekaInstancesRequest {
	s.RequestPars = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetServiceName(v string) *ListEurekaInstancesRequest {
	s.ServiceName = &v
	return s
}

type ListEurekaInstancesResponseBody struct {
	// The details of the data.
	Data []*ListEurekaInstancesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListEurekaInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesResponseBody) SetData(v []*ListEurekaInstancesResponseBodyData) *ListEurekaInstancesResponseBody {
	s.Data = v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetErrorCode(v string) *ListEurekaInstancesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetHttpCode(v string) *ListEurekaInstancesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetMessage(v string) *ListEurekaInstancesResponseBody {
	s.Message = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetPageNumber(v int32) *ListEurekaInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetPageSize(v int32) *ListEurekaInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetRequestId(v string) *ListEurekaInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetSuccess(v bool) *ListEurekaInstancesResponseBody {
	s.Success = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetTotalCount(v int32) *ListEurekaInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type ListEurekaInstancesResponseBodyData struct {
	// The name of the application.
	App *string `json:"App,omitempty" xml:"App,omitempty"`
	// The timeout period of the instance.\
	// After the specified timeout period expires, the service is unavailable by default and is deleted.
	DurationInSecs *int32 `json:"DurationInSecs,omitempty" xml:"DurationInSecs,omitempty"`
	// The URL of the homepage.
	HomePageUrl *string `json:"HomePageUrl,omitempty" xml:"HomePageUrl,omitempty"`
	// The hostname.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The time when the instance was last modified.
	LastDirtyTimestamp *int64 `json:"LastDirtyTimestamp,omitempty" xml:"LastDirtyTimestamp,omitempty"`
	// The time when the instance heartbeat was last checked.
	LastUpdatedTimestamp *int64 `json:"LastUpdatedTimestamp,omitempty" xml:"LastUpdatedTimestamp,omitempty"`
	// The metadata.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The service port number.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The maximum interval between two heartbeat checks after a heartbeat check times out.\
	// Default value: 10.
	RenewalIntervalInSecs *int32 `json:"RenewalIntervalInSecs,omitempty" xml:"RenewalIntervalInSecs,omitempty"`
	// The security port.
	SecurePort *int32 `json:"SecurePort,omitempty" xml:"SecurePort,omitempty"`
	// The number of service providers. The value is in the following format: Number of healthy instances/Total number of instances.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The virtual IP address (VIP).
	VipAddress *string `json:"VipAddress,omitempty" xml:"VipAddress,omitempty"`
}

func (s ListEurekaInstancesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesResponseBodyData) SetApp(v string) *ListEurekaInstancesResponseBodyData {
	s.App = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetDurationInSecs(v int32) *ListEurekaInstancesResponseBodyData {
	s.DurationInSecs = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetHomePageUrl(v string) *ListEurekaInstancesResponseBodyData {
	s.HomePageUrl = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetHostName(v string) *ListEurekaInstancesResponseBodyData {
	s.HostName = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetInstanceId(v string) *ListEurekaInstancesResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetIpAddr(v string) *ListEurekaInstancesResponseBodyData {
	s.IpAddr = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetLastDirtyTimestamp(v int64) *ListEurekaInstancesResponseBodyData {
	s.LastDirtyTimestamp = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetLastUpdatedTimestamp(v int64) *ListEurekaInstancesResponseBodyData {
	s.LastUpdatedTimestamp = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetMetadata(v map[string]interface{}) *ListEurekaInstancesResponseBodyData {
	s.Metadata = v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetPort(v int32) *ListEurekaInstancesResponseBodyData {
	s.Port = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetRenewalIntervalInSecs(v int32) *ListEurekaInstancesResponseBodyData {
	s.RenewalIntervalInSecs = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetSecurePort(v int32) *ListEurekaInstancesResponseBodyData {
	s.SecurePort = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetStatus(v string) *ListEurekaInstancesResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetVipAddress(v string) *ListEurekaInstancesResponseBodyData {
	s.VipAddress = &v
	return s
}

type ListEurekaInstancesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEurekaInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEurekaInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesResponse) SetHeaders(v map[string]*string) *ListEurekaInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListEurekaInstancesResponse) SetStatusCode(v int32) *ListEurekaInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEurekaInstancesResponse) SetBody(v *ListEurekaInstancesResponseBody) *ListEurekaInstancesResponse {
	s.Body = v
	return s
}

type ListEurekaServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListEurekaServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesRequest) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesRequest) SetAcceptLanguage(v string) *ListEurekaServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListEurekaServicesRequest) SetClusterId(v string) *ListEurekaServicesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListEurekaServicesRequest) SetPageNum(v int32) *ListEurekaServicesRequest {
	s.PageNum = &v
	return s
}

func (s *ListEurekaServicesRequest) SetPageSize(v int32) *ListEurekaServicesRequest {
	s.PageSize = &v
	return s
}

func (s *ListEurekaServicesRequest) SetRegionId(v string) *ListEurekaServicesRequest {
	s.RegionId = &v
	return s
}

func (s *ListEurekaServicesRequest) SetRequestPars(v string) *ListEurekaServicesRequest {
	s.RequestPars = &v
	return s
}

type ListEurekaServicesResponseBody struct {
	// The details of the data.
	Data []*ListEurekaServicesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListEurekaServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesResponseBody) SetData(v []*ListEurekaServicesResponseBodyData) *ListEurekaServicesResponseBody {
	s.Data = v
	return s
}

func (s *ListEurekaServicesResponseBody) SetErrorCode(v string) *ListEurekaServicesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetHttpCode(v string) *ListEurekaServicesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetMessage(v string) *ListEurekaServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetPageNumber(v int32) *ListEurekaServicesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetPageSize(v int32) *ListEurekaServicesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetRequestId(v string) *ListEurekaServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetSuccess(v bool) *ListEurekaServicesResponseBody {
	s.Success = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetTotalCount(v int32) *ListEurekaServicesResponseBody {
	s.TotalCount = &v
	return s
}

type ListEurekaServicesResponseBodyData struct {
	// The details of the instance.
	InstancesId []*string `json:"InstancesId,omitempty" xml:"InstancesId,omitempty" type:"Repeated"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of service providers. The value is in the following format: Number of healthy instances/Total number of instances.
	UpStatus *string `json:"UpStatus,omitempty" xml:"UpStatus,omitempty"`
}

func (s ListEurekaServicesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesResponseBodyData) SetInstancesId(v []*string) *ListEurekaServicesResponseBodyData {
	s.InstancesId = v
	return s
}

func (s *ListEurekaServicesResponseBodyData) SetName(v string) *ListEurekaServicesResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListEurekaServicesResponseBodyData) SetUpStatus(v string) *ListEurekaServicesResponseBodyData {
	s.UpStatus = &v
	return s
}

type ListEurekaServicesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEurekaServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEurekaServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesResponse) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesResponse) SetHeaders(v map[string]*string) *ListEurekaServicesResponse {
	s.Headers = v
	return s
}

func (s *ListEurekaServicesResponse) SetStatusCode(v int32) *ListEurekaServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEurekaServicesResponse) SetBody(v *ListEurekaServicesResponseBody) *ListEurekaServicesResponse {
	s.Body = v
	return s
}

type ListExportZookeeperDataRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListExportZookeeperDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataRequest) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataRequest) SetAcceptLanguage(v string) *ListExportZookeeperDataRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListExportZookeeperDataRequest) SetInstanceId(v string) *ListExportZookeeperDataRequest {
	s.InstanceId = &v
	return s
}

func (s *ListExportZookeeperDataRequest) SetPageNumber(v int32) *ListExportZookeeperDataRequest {
	s.PageNumber = &v
	return s
}

func (s *ListExportZookeeperDataRequest) SetPageSize(v int32) *ListExportZookeeperDataRequest {
	s.PageSize = &v
	return s
}

type ListExportZookeeperDataResponseBody struct {
	// The details of the data.
	Data []*ListExportZookeeperDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListExportZookeeperDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataResponseBody) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataResponseBody) SetData(v []*ListExportZookeeperDataResponseBodyData) *ListExportZookeeperDataResponseBody {
	s.Data = v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetDynamicMessage(v string) *ListExportZookeeperDataResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetErrorCode(v string) *ListExportZookeeperDataResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetHttpStatusCode(v string) *ListExportZookeeperDataResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetMessage(v string) *ListExportZookeeperDataResponseBody {
	s.Message = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetRequestId(v string) *ListExportZookeeperDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetSuccess(v bool) *ListExportZookeeperDataResponseBody {
	s.Success = &v
	return s
}

type ListExportZookeeperDataResponseBodyData struct {
	// The details of the task.
	ContentMap *string `json:"ContentMap,omitempty" xml:"ContentMap,omitempty"`
	// The time when the task was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The type of the object that is exported. Valid values:
	//
	// *   transactionLog: transaction logs
	// *   snapshot: snapshots
	ExportType *string `json:"ExportType,omitempty" xml:"ExportType,omitempty"`
	// The extension information that is in the JSON format. The extension information facilitates addition of parameters.
	Extend *string `json:"Extend,omitempty" xml:"Extend,omitempty"`
	// The ID of the task.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the associated task at the underlying layer. This parameter is used only to troubleshoot failures.
	KubeoneTaskIds *string `json:"KubeoneTaskIds,omitempty" xml:"KubeoneTaskIds,omitempty"`
	// The status of the task. Valid values:
	//
	// *   CREATE: The task is being created.
	// *   RUNNING: The task is being executed.
	// *   FINISH: The task is completed.
	// *   FAILED: The task failed.
	// *   EXPIRE: The task has expired.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time when the task was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ListExportZookeeperDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataResponseBodyData) SetContentMap(v string) *ListExportZookeeperDataResponseBodyData {
	s.ContentMap = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetCreateTime(v int64) *ListExportZookeeperDataResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetExportType(v string) *ListExportZookeeperDataResponseBodyData {
	s.ExportType = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetExtend(v string) *ListExportZookeeperDataResponseBodyData {
	s.Extend = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetId(v int32) *ListExportZookeeperDataResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetInstanceId(v string) *ListExportZookeeperDataResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetKubeoneTaskIds(v string) *ListExportZookeeperDataResponseBodyData {
	s.KubeoneTaskIds = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetStatus(v string) *ListExportZookeeperDataResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetUpdateTime(v int64) *ListExportZookeeperDataResponseBodyData {
	s.UpdateTime = &v
	return s
}

type ListExportZookeeperDataResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListExportZookeeperDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListExportZookeeperDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataResponse) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataResponse) SetHeaders(v map[string]*string) *ListExportZookeeperDataResponse {
	s.Headers = v
	return s
}

func (s *ListExportZookeeperDataResponse) SetStatusCode(v int32) *ListExportZookeeperDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ListExportZookeeperDataResponse) SetBody(v *ListExportZookeeperDataResponseBody) *ListExportZookeeperDataResponse {
	s.Body = v
	return s
}

type ListFlowRulesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The page number. Default value: 1.
	PageIndex *int32 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the resource.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The keyword that is used for the search.
	ResourceSearchKey *string `json:"ResourceSearchKey,omitempty" xml:"ResourceSearchKey,omitempty"`
}

func (s ListFlowRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFlowRulesRequest) GoString() string {
	return s.String()
}

func (s *ListFlowRulesRequest) SetAcceptLanguage(v string) *ListFlowRulesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListFlowRulesRequest) SetAppId(v string) *ListFlowRulesRequest {
	s.AppId = &v
	return s
}

func (s *ListFlowRulesRequest) SetAppName(v string) *ListFlowRulesRequest {
	s.AppName = &v
	return s
}

func (s *ListFlowRulesRequest) SetNamespace(v string) *ListFlowRulesRequest {
	s.Namespace = &v
	return s
}

func (s *ListFlowRulesRequest) SetPageIndex(v int32) *ListFlowRulesRequest {
	s.PageIndex = &v
	return s
}

func (s *ListFlowRulesRequest) SetPageSize(v int32) *ListFlowRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListFlowRulesRequest) SetResource(v string) *ListFlowRulesRequest {
	s.Resource = &v
	return s
}

func (s *ListFlowRulesRequest) SetResourceSearchKey(v string) *ListFlowRulesRequest {
	s.ResourceSearchKey = &v
	return s
}

type ListFlowRulesResponseBody struct {
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ListFlowRulesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The request was successful.
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The request failed.
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListFlowRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFlowRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListFlowRulesResponseBody) SetCode(v int32) *ListFlowRulesResponseBody {
	s.Code = &v
	return s
}

func (s *ListFlowRulesResponseBody) SetData(v *ListFlowRulesResponseBodyData) *ListFlowRulesResponseBody {
	s.Data = v
	return s
}

func (s *ListFlowRulesResponseBody) SetHttpStatusCode(v int32) *ListFlowRulesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListFlowRulesResponseBody) SetMessage(v string) *ListFlowRulesResponseBody {
	s.Message = &v
	return s
}

func (s *ListFlowRulesResponseBody) SetRequestId(v string) *ListFlowRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListFlowRulesResponseBody) SetSuccess(v bool) *ListFlowRulesResponseBody {
	s.Success = &v
	return s
}

type ListFlowRulesResponseBodyData struct {
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data returned.
	Result []*ListFlowRulesResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListFlowRulesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListFlowRulesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListFlowRulesResponseBodyData) SetPageNumber(v int32) *ListFlowRulesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListFlowRulesResponseBodyData) SetPageSize(v int32) *ListFlowRulesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListFlowRulesResponseBodyData) SetResult(v []*ListFlowRulesResponseBodyDataResult) *ListFlowRulesResponseBodyData {
	s.Result = v
	return s
}

func (s *ListFlowRulesResponseBodyData) SetTotalSize(v int32) *ListFlowRulesResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListFlowRulesResponseBodyDataResult struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The throttling effect.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     fast failure
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     in queue
	//
	//     <!-- -->
	ControlBehavior *int32 `json:"ControlBehavior,omitempty" xml:"ControlBehavior,omitempty"`
	// Indicates whether the throttling rule was enabled.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The throttling behavior.
	FallbackObject *string `json:"FallbackObject,omitempty" xml:"FallbackObject,omitempty"`
	// The timeout period for queuing when the value of ControlBehavior is set to 2. Unit: milliseconds.
	MaxQueueingTimeMs *int32 `json:"MaxQueueingTimeMs,omitempty" xml:"MaxQueueingTimeMs,omitempty"`
	// The statistical dimension. The value 1 indicates the number of accepted requests.
	MetricType *int32 `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the interface resource.
	Resource     *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	ResourceType *int32  `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The throttling threshold.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
	// A reserved parameter.
	TrafficTags map[string]interface{} `json:"TrafficTags,omitempty" xml:"TrafficTags,omitempty"`
}

func (s ListFlowRulesResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListFlowRulesResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListFlowRulesResponseBodyDataResult) SetAppId(v string) *ListFlowRulesResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetAppName(v string) *ListFlowRulesResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetControlBehavior(v int32) *ListFlowRulesResponseBodyDataResult {
	s.ControlBehavior = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetEnable(v bool) *ListFlowRulesResponseBodyDataResult {
	s.Enable = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetFallbackObject(v string) *ListFlowRulesResponseBodyDataResult {
	s.FallbackObject = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetMaxQueueingTimeMs(v int32) *ListFlowRulesResponseBodyDataResult {
	s.MaxQueueingTimeMs = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetMetricType(v int32) *ListFlowRulesResponseBodyDataResult {
	s.MetricType = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetNamespace(v string) *ListFlowRulesResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetRegionId(v string) *ListFlowRulesResponseBodyDataResult {
	s.RegionId = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetResource(v string) *ListFlowRulesResponseBodyDataResult {
	s.Resource = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetResourceType(v int32) *ListFlowRulesResponseBodyDataResult {
	s.ResourceType = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetRuleId(v int64) *ListFlowRulesResponseBodyDataResult {
	s.RuleId = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetThreshold(v float32) *ListFlowRulesResponseBodyDataResult {
	s.Threshold = &v
	return s
}

func (s *ListFlowRulesResponseBodyDataResult) SetTrafficTags(v map[string]interface{}) *ListFlowRulesResponseBodyDataResult {
	s.TrafficTags = v
	return s
}

type ListFlowRulesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListFlowRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFlowRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFlowRulesResponse) GoString() string {
	return s.String()
}

func (s *ListFlowRulesResponse) SetHeaders(v map[string]*string) *ListFlowRulesResponse {
	s.Headers = v
	return s
}

func (s *ListFlowRulesResponse) SetStatusCode(v int32) *ListFlowRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFlowRulesResponse) SetBody(v *ListFlowRulesResponseBody) *ListFlowRulesResponse {
	s.Body = v
	return s
}

type ListGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the sorting feature. This feature is not available.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The details of parameters.
	FilterParams *ListGatewayRequestFilterParams `json:"FilterParams,omitempty" xml:"FilterParams,omitempty" type:"Struct"`
	// The order information.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRequest) SetAcceptLanguage(v string) *ListGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayRequest) SetDescSort(v bool) *ListGatewayRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayRequest) SetFilterParams(v *ListGatewayRequestFilterParams) *ListGatewayRequest {
	s.FilterParams = v
	return s
}

func (s *ListGatewayRequest) SetOrderItem(v string) *ListGatewayRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayRequest) SetPageNumber(v int32) *ListGatewayRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRequest) SetPageSize(v int32) *ListGatewayRequest {
	s.PageSize = &v
	return s
}

type ListGatewayRequestFilterParams struct {
	// The type of the gateway.
	GatewayType *string `json:"GatewayType,omitempty" xml:"GatewayType,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The tag of the instance.
	MseTag *string `json:"MseTag,omitempty" xml:"MseTag,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
}

func (s ListGatewayRequestFilterParams) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRequestFilterParams) GoString() string {
	return s.String()
}

func (s *ListGatewayRequestFilterParams) SetGatewayType(v string) *ListGatewayRequestFilterParams {
	s.GatewayType = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetGatewayUniqueId(v string) *ListGatewayRequestFilterParams {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetInstanceId(v string) *ListGatewayRequestFilterParams {
	s.InstanceId = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetMseTag(v string) *ListGatewayRequestFilterParams {
	s.MseTag = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetName(v string) *ListGatewayRequestFilterParams {
	s.Name = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetResourceGroupId(v string) *ListGatewayRequestFilterParams {
	s.ResourceGroupId = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetVpc(v string) *ListGatewayRequestFilterParams {
	s.Vpc = &v
	return s
}

type ListGatewayShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the sorting feature. This feature is not available.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The details of parameters.
	FilterParamsShrink *string `json:"FilterParams,omitempty" xml:"FilterParams,omitempty"`
	// The order information.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayShrinkRequest) SetAcceptLanguage(v string) *ListGatewayShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetDescSort(v bool) *ListGatewayShrinkRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetFilterParamsShrink(v string) *ListGatewayShrinkRequest {
	s.FilterParamsShrink = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetOrderItem(v string) *ListGatewayShrinkRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetPageNumber(v int32) *ListGatewayShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetPageSize(v int32) *ListGatewayShrinkRequest {
	s.PageSize = &v
	return s
}

type ListGatewayResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *ListGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBody) SetCode(v int32) *ListGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayResponseBody) SetData(v *ListGatewayResponseBodyData) *ListGatewayResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayResponseBody) SetHttpStatusCode(v int32) *ListGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayResponseBody) SetMessage(v string) *ListGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayResponseBody) SetRequestId(v string) *ListGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayResponseBody) SetSuccess(v bool) *ListGatewayResponseBody {
	s.Success = &v
	return s
}

type ListGatewayResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data returned.
	Result []*ListGatewayResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyData) SetPageNumber(v int32) *ListGatewayResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayResponseBodyData) SetPageSize(v int32) *ListGatewayResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayResponseBodyData) SetResult(v []*ListGatewayResponseBodyDataResult) *ListGatewayResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayResponseBodyData) SetTotalSize(v int64) *ListGatewayResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayResponseBodyDataResult struct {
	// Indicates whether Application High Availability Service (AHAS) is activated.
	AhasOn *bool `json:"AhasOn,omitempty" xml:"AhasOn,omitempty"`
	// The version of the application.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// Indicates whether Application Real-Time Monitoring Service (ARMS) is activated.
	ArmsOn *bool `json:"ArmsOn,omitempty" xml:"ArmsOn,omitempty"`
	// The billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The current version of the gateway.
	CurrentVersion *string `json:"CurrentVersion,omitempty" xml:"CurrentVersion,omitempty"`
	// Indicates whether auto scale-out is enabled.
	Elastic *bool `json:"Elastic,omitempty" xml:"Elastic,omitempty"`
	// The ID of the elastic gateway. This parameter is returned if auto scale-out is used.
	ElasticInstanceId *string `json:"ElasticInstanceId,omitempty" xml:"ElasticInstanceId,omitempty"`
	// The auto scale-out policy.
	ElasticPolicy *ListGatewayResponseBodyDataResultElasticPolicy `json:"ElasticPolicy,omitempty" xml:"ElasticPolicy,omitempty" type:"Struct"`
	// The number of replicas that are automatically scaled out.
	ElasticReplica *int32 `json:"ElasticReplica,omitempty" xml:"ElasticReplica,omitempty"`
	// The type of auto scale-out. Valid value:
	//
	// *   CronHPA: scale-out by time
	ElasticType *string `json:"ElasticType,omitempty" xml:"ElasticType,omitempty"`
	// The time when the instance expires.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The gateway type.
	GatewayType *string `json:"GatewayType,omitempty" xml:"GatewayType,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The version of the gateway.
	GatewayVersion *string `json:"GatewayVersion,omitempty" xml:"GatewayVersion,omitempty"`
	// The time when the gateway was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the gateway was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The gateway ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The configurations.
	InitConfig *ListGatewayResponseBodyDataResultInitConfig `json:"InitConfig,omitempty" xml:"InitConfig,omitempty" type:"Struct"`
	// The instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The details of the Internet-facing SLB instances.
	InternetSlb []*ListGatewayResponseBodyDataResultInternetSlb `json:"InternetSlb,omitempty" xml:"InternetSlb,omitempty" type:"Repeated"`
	// The latest version of the gateway.
	LatestVersion     *string                                             `json:"LatestVersion,omitempty" xml:"LatestVersion,omitempty"`
	MaintenancePeriod *ListGatewayResponseBodyDataResultMaintenancePeriod `json:"MaintenancePeriod,omitempty" xml:"MaintenancePeriod,omitempty" type:"Struct"`
	// The resource tag.
	MseTag     *string `json:"MseTag,omitempty" xml:"MseTag,omitempty"`
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// Indicates whether the instance was forcefully upgraded.
	MustUpgrade *bool `json:"MustUpgrade,omitempty" xml:"MustUpgrade,omitempty"`
	// The gateway name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The user information.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of replicas.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether rollbacks are allowed.
	RollBack *bool `json:"RollBack,omitempty" xml:"RollBack,omitempty"`
	// The details of Server Load Balancer (SLB) instances.
	Slb []*ListGatewayResponseBodyDataResultSlb `json:"Slb,omitempty" xml:"Slb,omitempty" type:"Repeated"`
	// The specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The gateway state. Valid values:
	//
	// *   0: The gateway is being created.
	// *   1: The gateway failed to be created.
	// *   2: The gateway is running.
	// *   3: The gateway is being changed.
	// *   4: The gateway is scaling in.
	// *   6: The gateway is scaling out.
	// *   8: The gateway is being deleted.
	// *   9: The gateway is suspended and is to be released.
	// *   10: The gateway is restarting.
	// *   11: The gateway is being rebuilt.
	// *   12: The gateway is being upgraded.
	// *   13: The gateway failed to be upgraded.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The description of the gateway state.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// Indicates whether WebAssembly (Wasm) is supported.
	SupportWasm *bool `json:"SupportWasm,omitempty" xml:"SupportWasm,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The total number of replicas, including the number of replicas that are automatically scaled out.
	TotalReplica *int32 `json:"TotalReplica,omitempty" xml:"TotalReplica,omitempty"`
	// Indicates whether the instance was upgraded.
	Upgrade *bool `json:"Upgrade,omitempty" xml:"Upgrade,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the gateway belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the secondary vSwitch.
	Vswitch2 *string `json:"Vswitch2,omitempty" xml:"Vswitch2,omitempty"`
}

func (s ListGatewayResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResult) SetAhasOn(v bool) *ListGatewayResponseBodyDataResult {
	s.AhasOn = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetAppVersion(v string) *ListGatewayResponseBodyDataResult {
	s.AppVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetArmsOn(v bool) *ListGatewayResponseBodyDataResult {
	s.ArmsOn = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetChargeType(v string) *ListGatewayResponseBodyDataResult {
	s.ChargeType = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetCurrentVersion(v string) *ListGatewayResponseBodyDataResult {
	s.CurrentVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetElastic(v bool) *ListGatewayResponseBodyDataResult {
	s.Elastic = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetElasticInstanceId(v string) *ListGatewayResponseBodyDataResult {
	s.ElasticInstanceId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetElasticPolicy(v *ListGatewayResponseBodyDataResultElasticPolicy) *ListGatewayResponseBodyDataResult {
	s.ElasticPolicy = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetElasticReplica(v int32) *ListGatewayResponseBodyDataResult {
	s.ElasticReplica = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetElasticType(v string) *ListGatewayResponseBodyDataResult {
	s.ElasticType = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetEndDate(v string) *ListGatewayResponseBodyDataResult {
	s.EndDate = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGatewayType(v string) *ListGatewayResponseBodyDataResult {
	s.GatewayType = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGatewayVersion(v string) *ListGatewayResponseBodyDataResult {
	s.GatewayVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGmtModified(v string) *ListGatewayResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetId(v int64) *ListGatewayResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetInitConfig(v *ListGatewayResponseBodyDataResultInitConfig) *ListGatewayResponseBodyDataResult {
	s.InitConfig = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetInstanceId(v string) *ListGatewayResponseBodyDataResult {
	s.InstanceId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetInternetSlb(v []*ListGatewayResponseBodyDataResultInternetSlb) *ListGatewayResponseBodyDataResult {
	s.InternetSlb = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetLatestVersion(v string) *ListGatewayResponseBodyDataResult {
	s.LatestVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetMaintenancePeriod(v *ListGatewayResponseBodyDataResultMaintenancePeriod) *ListGatewayResponseBodyDataResult {
	s.MaintenancePeriod = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetMseTag(v string) *ListGatewayResponseBodyDataResult {
	s.MseTag = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetMseVersion(v string) *ListGatewayResponseBodyDataResult {
	s.MseVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetMustUpgrade(v bool) *ListGatewayResponseBodyDataResult {
	s.MustUpgrade = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetName(v string) *ListGatewayResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetPrimaryUser(v string) *ListGatewayResponseBodyDataResult {
	s.PrimaryUser = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetRegion(v string) *ListGatewayResponseBodyDataResult {
	s.Region = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetReplica(v int32) *ListGatewayResponseBodyDataResult {
	s.Replica = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetResourceGroupId(v string) *ListGatewayResponseBodyDataResult {
	s.ResourceGroupId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetRollBack(v bool) *ListGatewayResponseBodyDataResult {
	s.RollBack = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetSlb(v []*ListGatewayResponseBodyDataResultSlb) *ListGatewayResponseBodyDataResult {
	s.Slb = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetSpec(v string) *ListGatewayResponseBodyDataResult {
	s.Spec = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetStatus(v int32) *ListGatewayResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetStatusDesc(v string) *ListGatewayResponseBodyDataResult {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetSupportWasm(v bool) *ListGatewayResponseBodyDataResult {
	s.SupportWasm = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetTag(v string) *ListGatewayResponseBodyDataResult {
	s.Tag = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetTotalReplica(v int32) *ListGatewayResponseBodyDataResult {
	s.TotalReplica = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetUpgrade(v bool) *ListGatewayResponseBodyDataResult {
	s.Upgrade = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetVpcId(v string) *ListGatewayResponseBodyDataResult {
	s.VpcId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetVswitch2(v string) *ListGatewayResponseBodyDataResult {
	s.Vswitch2 = &v
	return s
}

type ListGatewayResponseBodyDataResultElasticPolicy struct {
	// Indicates whether auto scale-out is enabled.
	Elastic *bool `json:"Elastic,omitempty" xml:"Elastic,omitempty"`
	// The type of auto scale-out. Valid value:
	//
	// *   CronHPA: scale-out by time
	ElasticType *string `json:"ElasticType,omitempty" xml:"ElasticType,omitempty"`
	// The maximum number of instances that are automatically scaled out. This parameter is used for horizontal scale-out.
	MaxReplica *int32 `json:"MaxReplica,omitempty" xml:"MaxReplica,omitempty"`
	// The time policy list for auto scale-out.
	TimePolicyList []*ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList `json:"TimePolicyList,omitempty" xml:"TimePolicyList,omitempty" type:"Repeated"`
}

func (s ListGatewayResponseBodyDataResultElasticPolicy) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultElasticPolicy) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultElasticPolicy) SetElastic(v bool) *ListGatewayResponseBodyDataResultElasticPolicy {
	s.Elastic = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultElasticPolicy) SetElasticType(v string) *ListGatewayResponseBodyDataResultElasticPolicy {
	s.ElasticType = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultElasticPolicy) SetMaxReplica(v int32) *ListGatewayResponseBodyDataResultElasticPolicy {
	s.MaxReplica = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultElasticPolicy) SetTimePolicyList(v []*ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList) *ListGatewayResponseBodyDataResultElasticPolicy {
	s.TimePolicyList = v
	return s
}

type ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList struct {
	// The expected number of replicas for auto scale-out.
	DesiredReplica *int32 `json:"DesiredReplica,omitempty" xml:"DesiredReplica,omitempty"`
	// The end time of auto scale-out.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start time of auto scale-out.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList) SetDesiredReplica(v int32) *ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList {
	s.DesiredReplica = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList) SetEndTime(v string) *ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList {
	s.EndTime = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList) SetStartTime(v string) *ListGatewayResponseBodyDataResultElasticPolicyTimePolicyList {
	s.StartTime = &v
	return s
}

type ListGatewayResponseBodyDataResultInitConfig struct {
	// Indicates whether Web Application Firewall (WAF) is enabled.
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Indicates whether WAF is supported.
	SupportWaf *bool `json:"SupportWaf,omitempty" xml:"SupportWaf,omitempty"`
}

func (s ListGatewayResponseBodyDataResultInitConfig) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultInitConfig) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultInitConfig) SetEnableWaf(v bool) *ListGatewayResponseBodyDataResultInitConfig {
	s.EnableWaf = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInitConfig) SetSupportWaf(v bool) *ListGatewayResponseBodyDataResultInitConfig {
	s.SupportWaf = &v
	return s
}

type ListGatewayResponseBodyDataResultInternetSlb struct {
	// The mode of the SLB instance.
	GatewaySlbMode *string `json:"GatewaySlbMode,omitempty" xml:"GatewaySlbMode,omitempty"`
	// The state of the SLB instance.
	GatewaySlbStatus *string `json:"GatewaySlbStatus,omitempty" xml:"GatewaySlbStatus,omitempty"`
	// The traffic of the gateway.
	InternetNetworkFlow *string `json:"InternetNetworkFlow,omitempty" xml:"InternetNetworkFlow,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The port number of the SLB instance.
	SlbPort *string `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The specifications of the SLB instance.
	SlbSpec *string `json:"SlbSpec,omitempty" xml:"SlbSpec,omitempty"`
	// The description of the state.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The type of the SLB instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayResponseBodyDataResultInternetSlb) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultInternetSlb) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetGatewaySlbMode(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.GatewaySlbMode = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetGatewaySlbStatus(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.GatewaySlbStatus = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetInternetNetworkFlow(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.InternetNetworkFlow = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbId(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbIp(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbIp = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbPort(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbPort = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbSpec(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbSpec = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetStatusDesc(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetType(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.Type = &v
	return s
}

type ListGatewayResponseBodyDataResultMaintenancePeriod struct {
	EndTime   *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TimeZone  *string `json:"TimeZone,omitempty" xml:"TimeZone,omitempty"`
}

func (s ListGatewayResponseBodyDataResultMaintenancePeriod) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultMaintenancePeriod) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultMaintenancePeriod) SetEndTime(v string) *ListGatewayResponseBodyDataResultMaintenancePeriod {
	s.EndTime = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultMaintenancePeriod) SetStartTime(v string) *ListGatewayResponseBodyDataResultMaintenancePeriod {
	s.StartTime = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultMaintenancePeriod) SetTimeZone(v string) *ListGatewayResponseBodyDataResultMaintenancePeriod {
	s.TimeZone = &v
	return s
}

type ListGatewayResponseBodyDataResultSlb struct {
	// The mode of the SLB instance.
	GatewaySlbMode *string `json:"GatewaySlbMode,omitempty" xml:"GatewaySlbMode,omitempty"`
	// The state of the SLB instance.
	GatewaySlbStatus *string `json:"GatewaySlbStatus,omitempty" xml:"GatewaySlbStatus,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The port number of the SLB instance.
	SlbPort *string `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The specifications of the SLB instance.
	SlbSpec *string `json:"SlbSpec,omitempty" xml:"SlbSpec,omitempty"`
	// The description of the state.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The network type. Valid values:
	//
	// *   PUB_NET
	// *   PRIVATE_NET
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayResponseBodyDataResultSlb) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultSlb) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultSlb) SetGatewaySlbMode(v string) *ListGatewayResponseBodyDataResultSlb {
	s.GatewaySlbMode = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetGatewaySlbStatus(v string) *ListGatewayResponseBodyDataResultSlb {
	s.GatewaySlbStatus = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbId(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbIp(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbIp = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbPort(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbPort = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbSpec(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbSpec = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetStatusDesc(v string) *ListGatewayResponseBodyDataResultSlb {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetType(v string) *ListGatewayResponseBodyDataResultSlb {
	s.Type = &v
	return s
}

type ListGatewayResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayResponse) SetHeaders(v map[string]*string) *ListGatewayResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayResponse) SetStatusCode(v int32) *ListGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayResponse) SetBody(v *ListGatewayResponseBody) *ListGatewayResponse {
	s.Body = v
	return s
}

type ListGatewayAuthConsumerRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The status of the consumer. Valid values:
	//
	// *   true: enabled
	// *   false: disabled
	ConsumerStatus *bool `json:"ConsumerStatus,omitempty" xml:"ConsumerStatus,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the consumer.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return.
	PageNum *string `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The authentication type. Valid values:
	//
	// *   JWT
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayAuthConsumerRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerRequest) SetAcceptLanguage(v string) *ListGatewayAuthConsumerRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayAuthConsumerRequest) SetConsumerStatus(v bool) *ListGatewayAuthConsumerRequest {
	s.ConsumerStatus = &v
	return s
}

func (s *ListGatewayAuthConsumerRequest) SetGatewayUniqueId(v string) *ListGatewayAuthConsumerRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayAuthConsumerRequest) SetName(v string) *ListGatewayAuthConsumerRequest {
	s.Name = &v
	return s
}

func (s *ListGatewayAuthConsumerRequest) SetPageNum(v string) *ListGatewayAuthConsumerRequest {
	s.PageNum = &v
	return s
}

func (s *ListGatewayAuthConsumerRequest) SetPageSize(v string) *ListGatewayAuthConsumerRequest {
	s.PageSize = &v
	return s
}

func (s *ListGatewayAuthConsumerRequest) SetType(v string) *ListGatewayAuthConsumerRequest {
	s.Type = &v
	return s
}

type ListGatewayAuthConsumerResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *ListGatewayAuthConsumerResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayAuthConsumerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResponseBody) SetCode(v int32) *ListGatewayAuthConsumerResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetData(v *ListGatewayAuthConsumerResponseBodyData) *ListGatewayAuthConsumerResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetDynamicCode(v string) *ListGatewayAuthConsumerResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetDynamicMessage(v string) *ListGatewayAuthConsumerResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetErrorCode(v string) *ListGatewayAuthConsumerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetHttpStatusCode(v int32) *ListGatewayAuthConsumerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetMessage(v string) *ListGatewayAuthConsumerResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetRequestId(v string) *ListGatewayAuthConsumerResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBody) SetSuccess(v bool) *ListGatewayAuthConsumerResponseBody {
	s.Success = &v
	return s
}

type ListGatewayAuthConsumerResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned information.
	Result []*ListGatewayAuthConsumerResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of returned entries.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayAuthConsumerResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResponseBodyData) SetPageNumber(v int32) *ListGatewayAuthConsumerResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyData) SetPageSize(v int32) *ListGatewayAuthConsumerResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyData) SetResult(v []*ListGatewayAuthConsumerResponseBodyDataResult) *ListGatewayAuthConsumerResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyData) SetTotalSize(v int64) *ListGatewayAuthConsumerResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayAuthConsumerResponseBodyDataResult struct {
	// The status of the consumer. Valid values:
	//
	// *   true: enabled
	// *   false: disabled
	ConsumerStatus *bool `json:"ConsumerStatus,omitempty" xml:"ConsumerStatus,omitempty"`
	// The description of the consumer.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the consumer.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the consumer.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The creator.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The authentication type. Valid values:
	//
	// *   JWT
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayAuthConsumerResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetConsumerStatus(v bool) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.ConsumerStatus = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetDescription(v string) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.Description = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetGmtModified(v string) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetId(v int64) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetName(v string) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetPrimaryUser(v string) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.PrimaryUser = &v
	return s
}

func (s *ListGatewayAuthConsumerResponseBodyDataResult) SetType(v string) *ListGatewayAuthConsumerResponseBodyDataResult {
	s.Type = &v
	return s
}

type ListGatewayAuthConsumerResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayAuthConsumerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayAuthConsumerResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResponse) SetHeaders(v map[string]*string) *ListGatewayAuthConsumerResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayAuthConsumerResponse) SetStatusCode(v int32) *ListGatewayAuthConsumerResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResponse) SetBody(v *ListGatewayAuthConsumerResponseBody) *ListGatewayAuthConsumerResponse {
	s.Body = v
	return s
}

type ListGatewayAuthConsumerResourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the consumer.
	ConsumerId *int64 `json:"ConsumerId,omitempty" xml:"ConsumerId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The number of the page to return.
	PageNum *string `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The resource authorization status. Valid values:
	//
	// *   true: enabled
	// *   false: disabled
	ResourceStatus *bool `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The name of the route.
	RouteName *string `json:"RouteName,omitempty" xml:"RouteName,omitempty"`
}

func (s ListGatewayAuthConsumerResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResourceRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResourceRequest) SetAcceptLanguage(v string) *ListGatewayAuthConsumerResourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceRequest) SetConsumerId(v int64) *ListGatewayAuthConsumerResourceRequest {
	s.ConsumerId = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceRequest) SetGatewayUniqueId(v string) *ListGatewayAuthConsumerResourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceRequest) SetPageNum(v string) *ListGatewayAuthConsumerResourceRequest {
	s.PageNum = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceRequest) SetPageSize(v string) *ListGatewayAuthConsumerResourceRequest {
	s.PageSize = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceRequest) SetResourceStatus(v bool) *ListGatewayAuthConsumerResourceRequest {
	s.ResourceStatus = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceRequest) SetRouteName(v string) *ListGatewayAuthConsumerResourceRequest {
	s.RouteName = &v
	return s
}

type ListGatewayAuthConsumerResourceResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned result.
	Data *ListGatewayAuthConsumerResourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayAuthConsumerResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResourceResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetCode(v int32) *ListGatewayAuthConsumerResourceResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetData(v *ListGatewayAuthConsumerResourceResponseBodyData) *ListGatewayAuthConsumerResourceResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetDynamicCode(v string) *ListGatewayAuthConsumerResourceResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetDynamicMessage(v string) *ListGatewayAuthConsumerResourceResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetErrorCode(v string) *ListGatewayAuthConsumerResourceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetHttpStatusCode(v int32) *ListGatewayAuthConsumerResourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetMessage(v string) *ListGatewayAuthConsumerResourceResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetRequestId(v string) *ListGatewayAuthConsumerResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBody) SetSuccess(v bool) *ListGatewayAuthConsumerResourceResponseBody {
	s.Success = &v
	return s
}

type ListGatewayAuthConsumerResourceResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data structure.
	Result []*ListGatewayAuthConsumerResourceResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayAuthConsumerResourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResourceResponseBodyData) SetPageNumber(v int32) *ListGatewayAuthConsumerResourceResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyData) SetPageSize(v int32) *ListGatewayAuthConsumerResourceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyData) SetResult(v []*ListGatewayAuthConsumerResourceResponseBodyDataResult) *ListGatewayAuthConsumerResourceResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyData) SetTotalSize(v int64) *ListGatewayAuthConsumerResourceResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayAuthConsumerResourceResponseBodyDataResult struct {
	// The ID of the consumer.
	ConsumerId *int64 `json:"ConsumerId,omitempty" xml:"ConsumerId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the authorized resource for the consumer.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The resource authorization status. Valid values:
	//
	// *   true: enabled
	// *   false: disabled
	ResourceStatus *bool `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The ID of the route.
	RouteId *int64 `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
	// The name of the route.
	RouteName *string `json:"RouteName,omitempty" xml:"RouteName,omitempty"`
}

func (s ListGatewayAuthConsumerResourceResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResourceResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetConsumerId(v int64) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.ConsumerId = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetGmtModified(v string) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetId(v int64) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetResourceStatus(v bool) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.ResourceStatus = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetRouteId(v int64) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.RouteId = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponseBodyDataResult) SetRouteName(v string) *ListGatewayAuthConsumerResourceResponseBodyDataResult {
	s.RouteName = &v
	return s
}

type ListGatewayAuthConsumerResourceResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayAuthConsumerResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayAuthConsumerResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayAuthConsumerResourceResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayAuthConsumerResourceResponse) SetHeaders(v map[string]*string) *ListGatewayAuthConsumerResourceResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponse) SetStatusCode(v int32) *ListGatewayAuthConsumerResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayAuthConsumerResourceResponse) SetBody(v *ListGatewayAuthConsumerResourceResponseBody) *ListGatewayAuthConsumerResourceResponse {
	s.Body = v
	return s
}

type ListGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The type of the domain name.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainRequest) SetAcceptLanguage(v string) *ListGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayDomainRequest) SetGatewayUniqueId(v string) *ListGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayDomainRequest) SetType(v string) *ListGatewayDomainRequest {
	s.Type = &v
	return s
}

type ListGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*ListGatewayDomainResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponseBody) SetCode(v int32) *ListGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetData(v []*ListGatewayDomainResponseBodyData) *ListGatewayDomainResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayDomainResponseBody) SetHttpStatusCode(v int32) *ListGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetMessage(v string) *ListGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetRequestId(v string) *ListGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetSuccess(v bool) *ListGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type ListGatewayDomainResponseBodyData struct {
	// The time when the certificate expires.
	CertBeforeDate *string `json:"CertBeforeDate,omitempty" xml:"CertBeforeDate,omitempty"`
	// The certificate ID.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The route comment. This parameter is returned only in ingress scenarios.
	Comment *ListGatewayDomainResponseBodyDataComment `json:"Comment,omitempty" xml:"Comment,omitempty" type:"Struct"`
	// The gateway ID.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The time when the domain name was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the domain name was updated.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// Indicates whether `HTTP/2` is enabled.
	//
	// *   `open`: `HTTP/2` is enabled.
	// *   `close`: `HTTP/2` is disabled.
	// *   `globalConfig`: Global configurations are used.
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// The ID of the domain name.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether HTTPS is forcefully used.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The domain name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The state of the domain name. Valid values:
	//
	// *   0: unpublished
	// *   2: publishing
	// *   3: published
	// *   4: editing
	// *   5: unpublishing
	// *   6: unavailable
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
	// The type of the domain name source. Valid values:
	//
	// *   Op: console
	// *   Ingress: MSE Ingress
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayDomainResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponseBodyData) SetCertBeforeDate(v string) *ListGatewayDomainResponseBodyData {
	s.CertBeforeDate = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetCertIdentifier(v string) *ListGatewayDomainResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetComment(v *ListGatewayDomainResponseBodyDataComment) *ListGatewayDomainResponseBodyData {
	s.Comment = v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetGatewayId(v int64) *ListGatewayDomainResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetGmtCreate(v string) *ListGatewayDomainResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetGmtModified(v string) *ListGatewayDomainResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetHttp2(v string) *ListGatewayDomainResponseBodyData {
	s.Http2 = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetId(v int64) *ListGatewayDomainResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetMustHttps(v bool) *ListGatewayDomainResponseBodyData {
	s.MustHttps = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetName(v string) *ListGatewayDomainResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetProtocol(v string) *ListGatewayDomainResponseBodyData {
	s.Protocol = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetStatus(v int32) *ListGatewayDomainResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetTlsMax(v string) *ListGatewayDomainResponseBodyData {
	s.TlsMax = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetTlsMin(v string) *ListGatewayDomainResponseBodyData {
	s.TlsMin = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetType(v string) *ListGatewayDomainResponseBodyData {
	s.Type = &v
	return s
}

type ListGatewayDomainResponseBodyDataComment struct {
	// The route status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListGatewayDomainResponseBodyDataComment) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponseBodyDataComment) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponseBodyDataComment) SetStatus(v string) *ListGatewayDomainResponseBodyDataComment {
	s.Status = &v
	return s
}

type ListGatewayDomainResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponse) SetHeaders(v map[string]*string) *ListGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayDomainResponse) SetStatusCode(v int32) *ListGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayDomainResponse) SetBody(v *ListGatewayDomainResponseBody) *ListGatewayDomainResponse {
	s.Body = v
	return s
}

type ListGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting. This parameter is unavailable.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that specify filter conditions. The parameters are in the format of {"key1":"value1"}.
	FilterParams *ListGatewayRouteRequestFilterParams `json:"FilterParams,omitempty" xml:"FilterParams,omitempty" type:"Struct"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteRequest) SetAcceptLanguage(v string) *ListGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayRouteRequest) SetDescSort(v bool) *ListGatewayRouteRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayRouteRequest) SetFilterParams(v *ListGatewayRouteRequestFilterParams) *ListGatewayRouteRequest {
	s.FilterParams = v
	return s
}

func (s *ListGatewayRouteRequest) SetOrderItem(v string) *ListGatewayRouteRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayRouteRequest) SetPageNumber(v int32) *ListGatewayRouteRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRouteRequest) SetPageSize(v int32) *ListGatewayRouteRequest {
	s.PageSize = &v
	return s
}

type ListGatewayRouteRequestFilterParams struct {
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The associated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The order.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListGatewayRouteRequestFilterParams) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteRequestFilterParams) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteRequestFilterParams) SetDefaultServiceId(v int64) *ListGatewayRouteRequestFilterParams {
	s.DefaultServiceId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetDomainId(v int64) *ListGatewayRouteRequestFilterParams {
	s.DomainId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetDomainName(v string) *ListGatewayRouteRequestFilterParams {
	s.DomainName = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetGatewayId(v int64) *ListGatewayRouteRequestFilterParams {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetGatewayUniqueId(v string) *ListGatewayRouteRequestFilterParams {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetName(v string) *ListGatewayRouteRequestFilterParams {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetRouteOrder(v int32) *ListGatewayRouteRequestFilterParams {
	s.RouteOrder = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetStatus(v int32) *ListGatewayRouteRequestFilterParams {
	s.Status = &v
	return s
}

type ListGatewayRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting. This parameter is unavailable.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that specify filter conditions. The parameters are in the format of {"key1":"value1"}.
	FilterParamsShrink *string `json:"FilterParams,omitempty" xml:"FilterParams,omitempty"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteShrinkRequest) SetAcceptLanguage(v string) *ListGatewayRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetDescSort(v bool) *ListGatewayRouteShrinkRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetFilterParamsShrink(v string) *ListGatewayRouteShrinkRequest {
	s.FilterParamsShrink = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetOrderItem(v string) *ListGatewayRouteShrinkRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetPageNumber(v int32) *ListGatewayRouteShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetPageSize(v int32) *ListGatewayRouteShrinkRequest {
	s.PageSize = &v
	return s
}

type ListGatewayRouteResponseBody struct {
	// The code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *ListGatewayRouteResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBody) SetCode(v int32) *ListGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetData(v *ListGatewayRouteResponseBodyData) *ListGatewayRouteResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayRouteResponseBody) SetHttpStatusCode(v int32) *ListGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetMessage(v string) *ListGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetRequestId(v string) *ListGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetSuccess(v bool) *ListGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type ListGatewayRouteResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data structure.
	Result []*ListGatewayRouteResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayRouteResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyData) SetPageNumber(v int32) *ListGatewayRouteResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRouteResponseBodyData) SetPageSize(v int32) *ListGatewayRouteResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayRouteResponseBodyData) SetResult(v []*ListGatewayRouteResponseBodyDataResult) *ListGatewayRouteResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayRouteResponseBodyData) SetTotalSize(v int64) *ListGatewayRouteResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayRouteResponseBodyDataResult struct {
	// The route comment (ingress).
	Comment *ListGatewayRouteResponseBodyDataResultComment `json:"Comment,omitempty" xml:"Comment,omitempty" type:"Struct"`
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The default service name.
	DefaultServiceName *string `json:"DefaultServiceName,omitempty" xml:"DefaultServiceName,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponse *ListGatewayRouteResponseBodyDataResultDirectResponse `json:"DirectResponse,omitempty" xml:"DirectResponse,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain IDs.
	DomainIdList []*int64 `json:"DomainIdList,omitempty" xml:"DomainIdList,omitempty" type:"Repeated"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The domain names.
	DomainNameList []*string `json:"DomainNameList,omitempty" xml:"DomainNameList,omitempty" type:"Repeated"`
	// Indicates whether Web Application Firewall (WAF) is activated.
	EnableWaf *string `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Indicates whether the Fallback service is enabled.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServices []*ListGatewayRouteResponseBodyDataResultFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rules.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The information about redirection.
	Redirect *ListGatewayRouteResponseBodyDataResultRedirect `json:"Redirect,omitempty" xml:"Redirect,omitempty" type:"Struct"`
	// The order.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The matching rules.
	RoutePredicates *ListGatewayRouteResponseBodyDataResultRoutePredicates `json:"RoutePredicates,omitempty" xml:"RoutePredicates,omitempty" type:"Struct"`
	// The information about services.
	RouteServices []*ListGatewayRouteResponseBodyDataResultRouteServices `json:"RouteServices,omitempty" xml:"RouteServices,omitempty" type:"Repeated"`
	// The information about services.
	Services *string `json:"Services,omitempty" xml:"Services,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The route type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResult) SetComment(v *ListGatewayRouteResponseBodyDataResultComment) *ListGatewayRouteResponseBodyDataResult {
	s.Comment = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDefaultServiceId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.DefaultServiceId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDefaultServiceName(v string) *ListGatewayRouteResponseBodyDataResult {
	s.DefaultServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDestinationType(v string) *ListGatewayRouteResponseBodyDataResult {
	s.DestinationType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDirectResponse(v *ListGatewayRouteResponseBodyDataResultDirectResponse) *ListGatewayRouteResponseBodyDataResult {
	s.DirectResponse = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.DomainId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainIdList(v []*int64) *ListGatewayRouteResponseBodyDataResult {
	s.DomainIdList = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainName(v string) *ListGatewayRouteResponseBodyDataResult {
	s.DomainName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainNameList(v []*string) *ListGatewayRouteResponseBodyDataResult {
	s.DomainNameList = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetEnableWaf(v string) *ListGatewayRouteResponseBodyDataResult {
	s.EnableWaf = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetFallback(v bool) *ListGatewayRouteResponseBodyDataResult {
	s.Fallback = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetFallbackServices(v []*ListGatewayRouteResponseBodyDataResultFallbackServices) *ListGatewayRouteResponseBodyDataResult {
	s.FallbackServices = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGatewayId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayRouteResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayRouteResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGmtModified(v string) *ListGatewayRouteResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetName(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetPredicates(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Predicates = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRedirect(v *ListGatewayRouteResponseBodyDataResultRedirect) *ListGatewayRouteResponseBodyDataResult {
	s.Redirect = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRouteOrder(v int32) *ListGatewayRouteResponseBodyDataResult {
	s.RouteOrder = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRoutePredicates(v *ListGatewayRouteResponseBodyDataResultRoutePredicates) *ListGatewayRouteResponseBodyDataResult {
	s.RoutePredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRouteServices(v []*ListGatewayRouteResponseBodyDataResultRouteServices) *ListGatewayRouteResponseBodyDataResult {
	s.RouteServices = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetServices(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Services = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetStatus(v int32) *ListGatewayRouteResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetType(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Type = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultComment struct {
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultComment) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultComment) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultComment) SetStatus(v string) *ListGatewayRouteResponseBodyDataResultComment {
	s.Status = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultDirectResponse struct {
	// The return value for service mocking.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultDirectResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultDirectResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultDirectResponse) SetBody(v string) *ListGatewayRouteResponseBodyDataResultDirectResponse {
	s.Body = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultDirectResponse) SetCode(v int32) *ListGatewayRouteResponseBodyDataResultDirectResponse {
	s.Code = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultFallbackServices struct {
	// The type of the protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the service belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultFallbackServices) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetAgreementType(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetGroupName(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.GroupName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetName(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetNamespace(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Namespace = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetPercent(v int32) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Percent = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetServiceId(v int64) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetServiceName(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.ServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetServicePort(v int32) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetSourceType(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.SourceType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetVersion(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Version = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRedirect struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname to be redirected to.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRedirect) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRedirect) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRedirect) SetCode(v int32) *ListGatewayRouteResponseBodyDataResultRedirect {
	s.Code = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRedirect) SetHost(v string) *ListGatewayRouteResponseBodyDataResultRedirect {
	s.Host = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRedirect) SetPath(v string) *ListGatewayRouteResponseBodyDataResultRedirect {
	s.Path = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicates struct {
	// The headers used for route matching.
	HeaderPredicates []*ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The HTTP methods used for route matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The path used for route matching.
	PathPredicates *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The parameters used for route matching.
	QueryPredicates []*ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetHeaderPredicates(v []*ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.HeaderPredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetMethodPredicates(v []*string) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.MethodPredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetPathPredicates(v *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.PathPredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetQueryPredicates(v []*ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.QueryPredicates = v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates struct {
	// The header key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) SetKey(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) SetType(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) SetValue(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates struct {
	// Indicates whether case sensitivity is ignored.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) SetIgnoreCase(v bool) *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) SetPath(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) SetType(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates {
	s.Type = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates struct {
	// The key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) SetKey(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) SetType(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) SetValue(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates {
	s.Value = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServices struct {
	// The type of the protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The transcoder of the Dubbo protocol.
	HttpDubboTranscoder *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder `json:"HttpDubboTranscoder,omitempty" xml:"HttpDubboTranscoder,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The Dubbo port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServices) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServices) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetAgreementType(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.AgreementType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetGroupName(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.GroupName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetHttpDubboTranscoder(v *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.HttpDubboTranscoder = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetName(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetNamespace(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Namespace = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetPercent(v int32) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Percent = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetServiceId(v int64) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.ServiceId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetServiceName(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.ServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetServicePort(v int32) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.ServicePort = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetSourceType(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.SourceType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetVersion(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Version = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder struct {
	// The Dubbo service group.
	DubboServiceGroup *string `json:"DubboServiceGroup,omitempty" xml:"DubboServiceGroup,omitempty"`
	// The name of the Dubbo service.
	DubboServiceName *string `json:"DubboServiceName,omitempty" xml:"DubboServiceName,omitempty"`
	// The version of the Dubbo service.
	DubboServiceVersion *string `json:"DubboServiceVersion,omitempty" xml:"DubboServiceVersion,omitempty"`
	// The forwarding rules of the Dubbo service.
	MothedMapList []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList `json:"MothedMapList,omitempty" xml:"MothedMapList,omitempty" type:"Repeated"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetDubboServiceGroup(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.DubboServiceGroup = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetDubboServiceName(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.DubboServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetDubboServiceVersion(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.DubboServiceVersion = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetMothedMapList(v []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.MothedMapList = v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList struct {
	// The method name of the Dubbo service.
	DubboMothedName *string `json:"DubboMothedName,omitempty" xml:"DubboMothedName,omitempty"`
	// The HTTP method.
	//
	// > Valid values:
	//
	// *   ALL_GET
	//
	// *   ALL_POST
	//
	// *   ALL_PUT
	//
	// *   ALL_DELETE
	//
	// *   ALL_PATCH
	HttpMothed *string `json:"HttpMothed,omitempty" xml:"HttpMothed,omitempty"`
	// The path used for method matching.
	Mothedpath *string `json:"Mothedpath,omitempty" xml:"Mothedpath,omitempty"`
	// The information about parameter mappings.
	ParamMapsList []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList `json:"ParamMapsList,omitempty" xml:"ParamMapsList,omitempty" type:"Repeated"`
	// The pass-through type of the header.
	//
	// > Valid values:
	//
	// *   PASS_ALL: All headers are passed through.
	//
	// *   PASS_NOT: All headers are not passed through.
	//
	// *   PASS_ASSIGN: Specified headers are passed through.
	PassThroughAllHeaders *string `json:"PassThroughAllHeaders,omitempty" xml:"PassThroughAllHeaders,omitempty"`
	// The list of headers to be passed through.
	PassThroughList []*string `json:"PassThroughList,omitempty" xml:"PassThroughList,omitempty" type:"Repeated"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetDubboMothedName(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.DubboMothedName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetHttpMothed(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.HttpMothed = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetMothedpath(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.Mothedpath = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetParamMapsList(v []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.ParamMapsList = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetPassThroughAllHeaders(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughAllHeaders = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetPassThroughList(v []*string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughList = v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList struct {
	// The key extracted from the input parameter.
	ExtractKey *string `json:"ExtractKey,omitempty" xml:"ExtractKey,omitempty"`
	// The position of the input parameter.
	//
	// > Valid values:
	//
	// *   `ALL_QUERY_PARAMETER`: request parameter
	//
	// *   `ALL_HEADER`: request header
	//
	// *   `ALL_PATH`: request path
	//
	// *   `ALL_BODY`: request body
	ExtractKeySpec *string `json:"ExtractKeySpec,omitempty" xml:"ExtractKeySpec,omitempty"`
	// The type of the backend service parameter.
	MappingType *string `json:"MappingType,omitempty" xml:"MappingType,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKey(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKey = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKeySpec(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKeySpec = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) SetMappingType(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.MappingType = &v
	return s
}

type ListGatewayRouteResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponse) SetHeaders(v map[string]*string) *ListGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayRouteResponse) SetStatusCode(v int32) *ListGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayRouteResponse) SetBody(v *ListGatewayRouteResponseBody) *ListGatewayRouteResponse {
	s.Body = v
	return s
}

type ListGatewayRouteOnAuthRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The authentication method. Valid values:
	//
	// *   JWT
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayRouteOnAuthRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteOnAuthRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteOnAuthRequest) SetAcceptLanguage(v string) *ListGatewayRouteOnAuthRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayRouteOnAuthRequest) SetGatewayUniqueId(v string) *ListGatewayRouteOnAuthRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRouteOnAuthRequest) SetType(v string) *ListGatewayRouteOnAuthRequest {
	s.Type = &v
	return s
}

type ListGatewayRouteOnAuthResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*ListGatewayRouteOnAuthResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayRouteOnAuthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteOnAuthResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteOnAuthResponseBody) SetCode(v int32) *ListGatewayRouteOnAuthResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBody) SetData(v []*ListGatewayRouteOnAuthResponseBodyData) *ListGatewayRouteOnAuthResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBody) SetHttpStatusCode(v int32) *ListGatewayRouteOnAuthResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBody) SetMessage(v string) *ListGatewayRouteOnAuthResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBody) SetRequestId(v string) *ListGatewayRouteOnAuthResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBody) SetSuccess(v bool) *ListGatewayRouteOnAuthResponseBody {
	s.Success = &v
	return s
}

type ListGatewayRouteOnAuthResponseBodyData struct {
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain IDs.
	DomainIdList []*int64 `json:"DomainIdList,omitempty" xml:"DomainIdList,omitempty" type:"Repeated"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The domain names.
	DomainNameList []*string `json:"DomainNameList,omitempty" xml:"DomainNameList,omitempty" type:"Repeated"`
	// The gateway ID.
	GatewayId *string `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The route ID.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The information about route matching.
	RoutePredicates *ListGatewayRouteOnAuthResponseBodyDataRoutePredicates `json:"RoutePredicates,omitempty" xml:"RoutePredicates,omitempty" type:"Struct"`
}

func (s ListGatewayRouteOnAuthResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteOnAuthResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetDomainId(v int64) *ListGatewayRouteOnAuthResponseBodyData {
	s.DomainId = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetDomainIdList(v []*int64) *ListGatewayRouteOnAuthResponseBodyData {
	s.DomainIdList = v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetDomainName(v string) *ListGatewayRouteOnAuthResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetDomainNameList(v []*string) *ListGatewayRouteOnAuthResponseBodyData {
	s.DomainNameList = v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetGatewayId(v string) *ListGatewayRouteOnAuthResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetGatewayUniqueId(v string) *ListGatewayRouteOnAuthResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetId(v int32) *ListGatewayRouteOnAuthResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetName(v string) *ListGatewayRouteOnAuthResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyData) SetRoutePredicates(v *ListGatewayRouteOnAuthResponseBodyDataRoutePredicates) *ListGatewayRouteOnAuthResponseBodyData {
	s.RoutePredicates = v
	return s
}

type ListGatewayRouteOnAuthResponseBodyDataRoutePredicates struct {
	// The information about route matching.
	PathPredicates *ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
}

func (s ListGatewayRouteOnAuthResponseBodyDataRoutePredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteOnAuthResponseBodyDataRoutePredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteOnAuthResponseBodyDataRoutePredicates) SetPathPredicates(v *ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates) *ListGatewayRouteOnAuthResponseBodyDataRoutePredicates {
	s.PathPredicates = v
	return s
}

type ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates struct {
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates) SetPath(v string) *ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates) SetType(v string) *ListGatewayRouteOnAuthResponseBodyDataRoutePredicatesPathPredicates {
	s.Type = &v
	return s
}

type ListGatewayRouteOnAuthResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayRouteOnAuthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayRouteOnAuthResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteOnAuthResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteOnAuthResponse) SetHeaders(v map[string]*string) *ListGatewayRouteOnAuthResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayRouteOnAuthResponse) SetStatusCode(v int32) *ListGatewayRouteOnAuthResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayRouteOnAuthResponse) SetBody(v *ListGatewayRouteOnAuthResponseBody) *ListGatewayRouteOnAuthResponse {
	s.Body = v
	return s
}

type ListGatewayServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that are used to specify filter conditions. The values of the parameters are in the format of {"key1":"value1"}.
	FilterParams *ListGatewayServiceRequestFilterParams `json:"FilterParams,omitempty" xml:"FilterParams,omitempty" type:"Struct"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceRequest) SetAcceptLanguage(v string) *ListGatewayServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayServiceRequest) SetDescSort(v bool) *ListGatewayServiceRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayServiceRequest) SetFilterParams(v *ListGatewayServiceRequestFilterParams) *ListGatewayServiceRequest {
	s.FilterParams = v
	return s
}

func (s *ListGatewayServiceRequest) SetOrderItem(v string) *ListGatewayServiceRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayServiceRequest) SetPageNumber(v int32) *ListGatewayServiceRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayServiceRequest) SetPageSize(v int32) *ListGatewayServiceRequest {
	s.PageSize = &v
	return s
}

type ListGatewayServiceRequestFilterParams struct {
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the service belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The protocol of the service.
	//
	// *   HTTP
	// *   HTTPS
	// *   HTTP2
	// *   GRPC
	// *   DUBBO
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
	// The type of the source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s ListGatewayServiceRequestFilterParams) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceRequestFilterParams) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceRequestFilterParams) SetGatewayUniqueId(v string) *ListGatewayServiceRequestFilterParams {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetGroupName(v string) *ListGatewayServiceRequestFilterParams {
	s.GroupName = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetName(v string) *ListGatewayServiceRequestFilterParams {
	s.Name = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetNamespace(v string) *ListGatewayServiceRequestFilterParams {
	s.Namespace = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetServiceProtocol(v string) *ListGatewayServiceRequestFilterParams {
	s.ServiceProtocol = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetSourceType(v string) *ListGatewayServiceRequestFilterParams {
	s.SourceType = &v
	return s
}

type ListGatewayServiceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that are used to specify filter conditions. The values of the parameters are in the format of {"key1":"value1"}.
	FilterParamsShrink *string `json:"FilterParams,omitempty" xml:"FilterParams,omitempty"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayServiceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceShrinkRequest) SetAcceptLanguage(v string) *ListGatewayServiceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetDescSort(v bool) *ListGatewayServiceShrinkRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetFilterParamsShrink(v string) *ListGatewayServiceShrinkRequest {
	s.FilterParamsShrink = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetOrderItem(v string) *ListGatewayServiceShrinkRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetPageNumber(v int32) *ListGatewayServiceShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetPageSize(v int32) *ListGatewayServiceShrinkRequest {
	s.PageSize = &v
	return s
}

type ListGatewayServiceResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response parameters.
	Data *ListGatewayServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBody) SetCode(v int32) *ListGatewayServiceResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetData(v *ListGatewayServiceResponseBodyData) *ListGatewayServiceResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayServiceResponseBody) SetHttpStatusCode(v int32) *ListGatewayServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetMessage(v string) *ListGatewayServiceResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetRequestId(v string) *ListGatewayServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetSuccess(v bool) *ListGatewayServiceResponseBody {
	s.Success = &v
	return s
}

type ListGatewayServiceResponseBodyData struct {
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned information.
	Result []*ListGatewayServiceResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyData) SetPageNumber(v int32) *ListGatewayServiceResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayServiceResponseBodyData) SetPageSize(v int32) *ListGatewayServiceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayServiceResponseBodyData) SetResult(v []*ListGatewayServiceResponseBodyDataResult) *ListGatewayServiceResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayServiceResponseBodyData) SetTotalSize(v int64) *ListGatewayServiceResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayServiceResponseBodyDataResult struct {
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic management policy.
	GatewayTrafficPolicy *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty" type:"Struct"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The health status.
	//
	// *   Health
	// *   Unhealthy
	// *   Unknown
	HealehStatus *string `json:"HealehStatus,omitempty" xml:"HealehStatus,omitempty"`
	// Indicates whether health checks are performed.
	HealthCheck *bool `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The information about health checks.
	HealthCheckInfo *ListGatewayServiceResponseBodyDataResultHealthCheckInfo `json:"HealthCheckInfo,omitempty" xml:"HealthCheckInfo,omitempty" type:"Struct"`
	// The health status.
	//
	// *   Health
	// *   Unhealthy
	// *   Unknown
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The IP addresses.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The metadata or IP addresses of the service.
	MetaInfo *string `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The port array.
	Ports []*int32 `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// The name of the service that is registered with the service registry.
	ServiceNameInRegistry *string `json:"ServiceNameInRegistry,omitempty" xml:"ServiceNameInRegistry,omitempty"`
	// The service port.
	ServicePort *int64 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The protocol of the service.
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
	// The ID of the service source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The array of unhealthy endpoints.
	UnhealthyEndpoints []*string `json:"UnhealthyEndpoints,omitempty" xml:"UnhealthyEndpoints,omitempty" type:"Repeated"`
	// The version of the service.
	Versions []*ListGatewayServiceResponseBodyDataResultVersions `json:"Versions,omitempty" xml:"Versions,omitempty" type:"Repeated"`
}

func (s ListGatewayServiceResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGatewayId(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGatewayTrafficPolicy(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) *ListGatewayServiceResponseBodyDataResult {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGmtModified(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGroupName(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GroupName = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealehStatus(v string) *ListGatewayServiceResponseBodyDataResult {
	s.HealehStatus = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealthCheck(v bool) *ListGatewayServiceResponseBodyDataResult {
	s.HealthCheck = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealthCheckInfo(v *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) *ListGatewayServiceResponseBodyDataResult {
	s.HealthCheckInfo = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealthStatus(v string) *ListGatewayServiceResponseBodyDataResult {
	s.HealthStatus = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetId(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetIps(v []*string) *ListGatewayServiceResponseBodyDataResult {
	s.Ips = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetMetaInfo(v string) *ListGatewayServiceResponseBodyDataResult {
	s.MetaInfo = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetName(v string) *ListGatewayServiceResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetNamespace(v string) *ListGatewayServiceResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetPorts(v []*int32) *ListGatewayServiceResponseBodyDataResult {
	s.Ports = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetServiceNameInRegistry(v string) *ListGatewayServiceResponseBodyDataResult {
	s.ServiceNameInRegistry = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetServicePort(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.ServicePort = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetServiceProtocol(v string) *ListGatewayServiceResponseBodyDataResult {
	s.ServiceProtocol = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetSourceId(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.SourceId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetSourceType(v string) *ListGatewayServiceResponseBodyDataResult {
	s.SourceType = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetUnhealthyEndpoints(v []*string) *ListGatewayServiceResponseBodyDataResult {
	s.UnhealthyEndpoints = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetVersions(v []*ListGatewayServiceResponseBodyDataResultVersions) *ListGatewayServiceResponseBodyDataResult {
	s.Versions = v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy struct {
	// The load balancing settings.
	LoadBalancerSettings *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings `json:"LoadBalancerSettings,omitempty" xml:"LoadBalancerSettings,omitempty" type:"Struct"`
	// The Transport Layer Security (TLS).
	Tls *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls `json:"Tls,omitempty" xml:"Tls,omitempty" type:"Struct"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) SetLoadBalancerSettings(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy {
	s.LoadBalancerSettings = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) SetTls(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy {
	s.Tls = v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings struct {
	// The consistent hashing settings.
	ConsistentHashLBConfig *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig `json:"ConsistentHashLBConfig,omitempty" xml:"ConsistentHashLBConfig,omitempty" type:"Struct"`
	// The load balancing type.
	//
	// *   ROUND_ROBIN
	// *   LEAST_CONN
	// *   RANDOM
	// *   CONSISTENT_HASH
	LoadbalancerType *string `json:"LoadbalancerType,omitempty" xml:"LoadbalancerType,omitempty"`
	// The prefetch time of the least connection load balancing.
	WarmupDuration *int32 `json:"WarmupDuration,omitempty" xml:"WarmupDuration,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) SetConsistentHashLBConfig(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings {
	s.ConsistentHashLBConfig = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) SetLoadbalancerType(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings {
	s.LoadbalancerType = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) SetWarmupDuration(v int32) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings {
	s.WarmupDuration = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig struct {
	// The type based on which consistent hashing load balancing is performed.
	//
	// *   HEADER
	// *   COOKIE
	// *   SOURCE_IP
	// *   QUERY_PARAMETER
	ConsistentHashLBType *string `json:"ConsistentHashLBType,omitempty" xml:"ConsistentHashLBType,omitempty"`
	// The cookie-based load balancing parameters.
	HttpCookie *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie `json:"HttpCookie,omitempty" xml:"HttpCookie,omitempty" type:"Struct"`
	// The minimum value of the hash ring.
	MinimumRingSize *int64 `json:"MinimumRingSize,omitempty" xml:"MinimumRingSize,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetConsistentHashLBType(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ConsistentHashLBType = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetHttpCookie(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.HttpCookie = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetMinimumRingSize(v int64) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.MinimumRingSize = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetParameterName(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ParameterName = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie struct {
	// The name of the cookie.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the cookie.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The lifecycle of the cookie.
	Ttl *string `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetName(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Name = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetPath(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Path = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetTtl(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Ttl = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls struct {
	// The public key of the CA certificate .
	CaCertContent *string `json:"CaCertContent,omitempty" xml:"CaCertContent,omitempty"`
	// The ID of the certification authority (CA) certificate.
	CaCertId *string `json:"CaCertId,omitempty" xml:"CaCertId,omitempty"`
	// The ID of the certificate.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The TLS mode.
	//
	// *   DISABLE
	// *   SIMPLE
	// *   MUTUAL
	// *   ISTIO_MUTUAL
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The Server Name Indication (SNI) value.
	Sni *string `json:"Sni,omitempty" xml:"Sni,omitempty"`
	// The array of subject aliases.
	SubjectAltNames []*string `json:"SubjectAltNames,omitempty" xml:"SubjectAltNames,omitempty" type:"Repeated"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetCaCertContent(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.CaCertContent = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetCaCertId(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.CaCertId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetCertId(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.CertId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetMode(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.Mode = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetSni(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.Sni = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetSubjectAltNames(v []*string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.SubjectAltNames = v
	return s
}

type ListGatewayServiceResponseBodyDataResultHealthCheckInfo struct {
	// Indicates whether checks are performed.
	Check *bool `json:"Check,omitempty" xml:"Check,omitempty"`
	// The expected status of the health check.
	ExpectedStatuses []*int32 `json:"ExpectedStatuses,omitempty" xml:"ExpectedStatuses,omitempty" type:"Repeated"`
	// The threshold for healthy instances.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The URL of the HTTP request for the health check.
	HttpHost *string `json:"HttpHost,omitempty" xml:"HttpHost,omitempty"`
	// The path to which the HTTP request for the health check is sent.
	HttpPath *string `json:"HttpPath,omitempty" xml:"HttpPath,omitempty"`
	// The health check interval.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The network protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The timeout period.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The threshold for unhealthy instances.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultHealthCheckInfo) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultHealthCheckInfo) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetCheck(v bool) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Check = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetExpectedStatuses(v []*int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.ExpectedStatuses = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetHealthyThreshold(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.HealthyThreshold = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetHttpHost(v string) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.HttpHost = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetHttpPath(v string) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.HttpPath = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetInterval(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Interval = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetProtocol(v string) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Protocol = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetTimeout(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Timeout = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetUnhealthyThreshold(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.UnhealthyThreshold = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultVersions struct {
	// The version number.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultVersions) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultVersions) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultVersions) SetName(v string) *ListGatewayServiceResponseBodyDataResultVersions {
	s.Name = &v
	return s
}

type ListGatewayServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponse) SetHeaders(v map[string]*string) *ListGatewayServiceResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayServiceResponse) SetStatusCode(v int32) *ListGatewayServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayServiceResponse) SetBody(v *ListGatewayServiceResponseBody) *ListGatewayServiceResponse {
	s.Body = v
	return s
}

type ListGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbRequest) SetAcceptLanguage(v string) *ListGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewaySlbRequest) SetGatewayUniqueId(v string) *ListGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListGatewaySlbResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*ListGatewaySlbResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbResponseBody) SetCode(v int32) *ListGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetData(v []*ListGatewaySlbResponseBodyData) *ListGatewaySlbResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewaySlbResponseBody) SetHttpStatusCode(v int32) *ListGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetMessage(v string) *ListGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetRequestId(v string) *ListGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetSuccess(v bool) *ListGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type ListGatewaySlbResponseBodyData struct {
	// Indicates whether the edit operation is supported.
	EditEnable *bool `json:"EditEnable,omitempty" xml:"EditEnable,omitempty"`
	// The ID of the gateway.
	GatewayId *string `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The mode of the SLB instance.
	GatewaySlbMode *string `json:"GatewaySlbMode,omitempty" xml:"GatewaySlbMode,omitempty"`
	// The association status.
	GatewaySlbStatus *string `json:"GatewaySlbStatus,omitempty" xml:"GatewaySlbStatus,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The port number of the HTTP virtual service group.
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The port number of the HTTPS virtual service group.
	HttpsPort *int32 `json:"HttpsPort,omitempty" xml:"HttpsPort,omitempty"`
	// The ID of the HTTPS virtual service group.
	HttpsVServerGroupId *string `json:"HttpsVServerGroupId,omitempty" xml:"HttpsVServerGroupId,omitempty"`
	// The ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The service weight.
	ServiceWeight *int32 `json:"ServiceWeight,omitempty" xml:"ServiceWeight,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The port number of the SLB instance.
	SlbPort *string `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	SlbType *string `json:"SlbType,omitempty" xml:"SlbType,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the HTTP virtual service group.
	VServerGroupId *string                                       `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	VServiceList   []*ListGatewaySlbResponseBodyDataVServiceList `json:"VServiceList,omitempty" xml:"VServiceList,omitempty" type:"Repeated"`
	VsMetaInfo     *string                                       `json:"VsMetaInfo,omitempty" xml:"VsMetaInfo,omitempty"`
}

func (s ListGatewaySlbResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbResponseBodyData) SetEditEnable(v bool) *ListGatewaySlbResponseBodyData {
	s.EditEnable = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGatewayId(v string) *ListGatewaySlbResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGatewaySlbMode(v string) *ListGatewaySlbResponseBodyData {
	s.GatewaySlbMode = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGatewaySlbStatus(v string) *ListGatewaySlbResponseBodyData {
	s.GatewaySlbStatus = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGmtCreate(v string) *ListGatewaySlbResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetHttpPort(v int32) *ListGatewaySlbResponseBodyData {
	s.HttpPort = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetHttpsPort(v int32) *ListGatewaySlbResponseBodyData {
	s.HttpsPort = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetHttpsVServerGroupId(v string) *ListGatewaySlbResponseBodyData {
	s.HttpsVServerGroupId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetId(v string) *ListGatewaySlbResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetServiceWeight(v int32) *ListGatewaySlbResponseBodyData {
	s.ServiceWeight = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetSlbId(v string) *ListGatewaySlbResponseBodyData {
	s.SlbId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetSlbIp(v string) *ListGatewaySlbResponseBodyData {
	s.SlbIp = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetSlbPort(v string) *ListGatewaySlbResponseBodyData {
	s.SlbPort = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetSlbType(v string) *ListGatewaySlbResponseBodyData {
	s.SlbType = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetStatusDesc(v string) *ListGatewaySlbResponseBodyData {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetType(v string) *ListGatewaySlbResponseBodyData {
	s.Type = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetVServerGroupId(v string) *ListGatewaySlbResponseBodyData {
	s.VServerGroupId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetVServiceList(v []*ListGatewaySlbResponseBodyDataVServiceList) *ListGatewaySlbResponseBodyData {
	s.VServiceList = v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetVsMetaInfo(v string) *ListGatewaySlbResponseBodyData {
	s.VsMetaInfo = &v
	return s
}

type ListGatewaySlbResponseBodyDataVServiceList struct {
	Port             *string `json:"Port,omitempty" xml:"Port,omitempty"`
	Protocol         *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	VServerGroupId   *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s ListGatewaySlbResponseBodyDataVServiceList) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbResponseBodyDataVServiceList) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbResponseBodyDataVServiceList) SetPort(v string) *ListGatewaySlbResponseBodyDataVServiceList {
	s.Port = &v
	return s
}

func (s *ListGatewaySlbResponseBodyDataVServiceList) SetProtocol(v string) *ListGatewaySlbResponseBodyDataVServiceList {
	s.Protocol = &v
	return s
}

func (s *ListGatewaySlbResponseBodyDataVServiceList) SetVServerGroupId(v string) *ListGatewaySlbResponseBodyDataVServiceList {
	s.VServerGroupId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyDataVServiceList) SetVServerGroupName(v string) *ListGatewaySlbResponseBodyDataVServiceList {
	s.VServerGroupName = &v
	return s
}

type ListGatewaySlbResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbResponse) SetHeaders(v map[string]*string) *ListGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *ListGatewaySlbResponse) SetStatusCode(v int32) *ListGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewaySlbResponse) SetBody(v *ListGatewaySlbResponseBody) *ListGatewaySlbResponse {
	s.Body = v
	return s
}

type ListInstanceCountRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values: ZooKeeper and Nacos-Ans.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The edition type of the instance. Valid values:
	//
	// *   `mse_dev`: Developer Edition
	// *   `mse_pro`: Professional Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the region where the instance resides. Examples:
	//
	// *   cn-hangzhou: China (Hangzhou)
	// *   cn-beijing: China (Beijing)
	// *   cn-shanghai: China (Shanghai)
	// *   cn-zhangjiakou: China (Zhangjiakou)
	// *   cn-shenzhen: China (Shenzhen)
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListInstanceCountRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceCountRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceCountRequest) SetAcceptLanguage(v string) *ListInstanceCountRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListInstanceCountRequest) SetClusterType(v string) *ListInstanceCountRequest {
	s.ClusterType = &v
	return s
}

func (s *ListInstanceCountRequest) SetMseVersion(v string) *ListInstanceCountRequest {
	s.MseVersion = &v
	return s
}

func (s *ListInstanceCountRequest) SetRegionId(v string) *ListInstanceCountRequest {
	s.RegionId = &v
	return s
}

func (s *ListInstanceCountRequest) SetRequestPars(v string) *ListInstanceCountRequest {
	s.RequestPars = &v
	return s
}

type ListInstanceCountResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*int32 `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace `%s` in the `ErrMessage` parameter.
	//
	// >  If the return value of the `ErrMessage` parameter is `The Value of Input Parameter %s is not valid` and the return value of the `DynamicMessage` parameter is `DtsJobId`, the specified `DtsJobId` parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed. If the request failed, the ErrorCode parameter is returned. For more information, see the [Error codes](~~456441~~) section of this topic.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message. If the request is successful, a success message is returned. If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListInstanceCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceCountResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceCountResponseBody) SetCode(v int32) *ListInstanceCountResponseBody {
	s.Code = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetData(v []*int32) *ListInstanceCountResponseBody {
	s.Data = v
	return s
}

func (s *ListInstanceCountResponseBody) SetDynamicCode(v string) *ListInstanceCountResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetDynamicMessage(v string) *ListInstanceCountResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetErrorCode(v string) *ListInstanceCountResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetHttpStatusCode(v int32) *ListInstanceCountResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetMessage(v string) *ListInstanceCountResponseBody {
	s.Message = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetRequestId(v string) *ListInstanceCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetSuccess(v bool) *ListInstanceCountResponseBody {
	s.Success = &v
	return s
}

type ListInstanceCountResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListInstanceCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListInstanceCountResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceCountResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceCountResponse) SetHeaders(v map[string]*string) *ListInstanceCountResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceCountResponse) SetStatusCode(v int32) *ListInstanceCountResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceCountResponse) SetBody(v *ListInstanceCountResponseBody) *ListInstanceCountResponse {
	s.Body = v
	return s
}

type ListListenersByConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListListenersByConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigRequest) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigRequest) SetAcceptLanguage(v string) *ListListenersByConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListListenersByConfigRequest) SetDataId(v string) *ListListenersByConfigRequest {
	s.DataId = &v
	return s
}

func (s *ListListenersByConfigRequest) SetGroup(v string) *ListListenersByConfigRequest {
	s.Group = &v
	return s
}

func (s *ListListenersByConfigRequest) SetInstanceId(v string) *ListListenersByConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *ListListenersByConfigRequest) SetNamespaceId(v string) *ListListenersByConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListListenersByConfigRequest) SetRequestPars(v string) *ListListenersByConfigRequest {
	s.RequestPars = &v
	return s
}

type ListListenersByConfigResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The information about listeners.
	Listeners []*ListListenersByConfigResponseBodyListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Repeated"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListListenersByConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigResponseBody) SetErrorCode(v string) *ListListenersByConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetHttpCode(v string) *ListListenersByConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetListeners(v []*ListListenersByConfigResponseBodyListeners) *ListListenersByConfigResponseBody {
	s.Listeners = v
	return s
}

func (s *ListListenersByConfigResponseBody) SetMessage(v string) *ListListenersByConfigResponseBody {
	s.Message = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetPageNumber(v int32) *ListListenersByConfigResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetPageSize(v int32) *ListListenersByConfigResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetRequestId(v string) *ListListenersByConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetSuccess(v bool) *ListListenersByConfigResponseBody {
	s.Success = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetTotalCount(v int32) *ListListenersByConfigResponseBody {
	s.TotalCount = &v
	return s
}

type ListListenersByConfigResponseBodyListeners struct {
	// The IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The verification string.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListListenersByConfigResponseBodyListeners) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigResponseBodyListeners) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigResponseBodyListeners) SetIp(v string) *ListListenersByConfigResponseBodyListeners {
	s.Ip = &v
	return s
}

func (s *ListListenersByConfigResponseBodyListeners) SetMd5(v string) *ListListenersByConfigResponseBodyListeners {
	s.Md5 = &v
	return s
}

func (s *ListListenersByConfigResponseBodyListeners) SetStatus(v string) *ListListenersByConfigResponseBodyListeners {
	s.Status = &v
	return s
}

type ListListenersByConfigResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListListenersByConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListListenersByConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigResponse) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigResponse) SetHeaders(v map[string]*string) *ListListenersByConfigResponse {
	s.Headers = v
	return s
}

func (s *ListListenersByConfigResponse) SetStatusCode(v int32) *ListListenersByConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ListListenersByConfigResponse) SetBody(v *ListListenersByConfigResponseBody) *ListListenersByConfigResponse {
	s.Body = v
	return s
}

type ListListenersByIpRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the listener.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListListenersByIpRequest) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpRequest) GoString() string {
	return s.String()
}

func (s *ListListenersByIpRequest) SetAcceptLanguage(v string) *ListListenersByIpRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListListenersByIpRequest) SetInstanceId(v string) *ListListenersByIpRequest {
	s.InstanceId = &v
	return s
}

func (s *ListListenersByIpRequest) SetIp(v string) *ListListenersByIpRequest {
	s.Ip = &v
	return s
}

func (s *ListListenersByIpRequest) SetNamespaceId(v string) *ListListenersByIpRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListListenersByIpRequest) SetRequestPars(v string) *ListListenersByIpRequest {
	s.RequestPars = &v
	return s
}

type ListListenersByIpResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The information about listeners.
	Listeners []*ListListenersByIpResponseBodyListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Repeated"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListListenersByIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpResponseBody) GoString() string {
	return s.String()
}

func (s *ListListenersByIpResponseBody) SetErrorCode(v string) *ListListenersByIpResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetHttpCode(v string) *ListListenersByIpResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetListeners(v []*ListListenersByIpResponseBodyListeners) *ListListenersByIpResponseBody {
	s.Listeners = v
	return s
}

func (s *ListListenersByIpResponseBody) SetMessage(v string) *ListListenersByIpResponseBody {
	s.Message = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetPageNumber(v int32) *ListListenersByIpResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetPageSize(v int32) *ListListenersByIpResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetRequestId(v string) *ListListenersByIpResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetSuccess(v bool) *ListListenersByIpResponseBody {
	s.Success = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetTotalCount(v int32) *ListListenersByIpResponseBody {
	s.TotalCount = &v
	return s
}

type ListListenersByIpResponseBodyListeners struct {
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The verification string.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
}

func (s ListListenersByIpResponseBodyListeners) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpResponseBodyListeners) GoString() string {
	return s.String()
}

func (s *ListListenersByIpResponseBodyListeners) SetDataId(v string) *ListListenersByIpResponseBodyListeners {
	s.DataId = &v
	return s
}

func (s *ListListenersByIpResponseBodyListeners) SetGroup(v string) *ListListenersByIpResponseBodyListeners {
	s.Group = &v
	return s
}

func (s *ListListenersByIpResponseBodyListeners) SetMd5(v string) *ListListenersByIpResponseBodyListeners {
	s.Md5 = &v
	return s
}

type ListListenersByIpResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListListenersByIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListListenersByIpResponse) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpResponse) GoString() string {
	return s.String()
}

func (s *ListListenersByIpResponse) SetHeaders(v map[string]*string) *ListListenersByIpResponse {
	s.Headers = v
	return s
}

func (s *ListListenersByIpResponse) SetStatusCode(v int32) *ListListenersByIpResponse {
	s.StatusCode = &v
	return s
}

func (s *ListListenersByIpResponse) SetBody(v *ListListenersByIpResponseBody) *ListListenersByIpResponse {
	s.Body = v
	return s
}

type ListMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskRequest) SetAcceptLanguage(v string) *ListMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListMigrationTaskRequest) SetOriginInstanceName(v string) *ListMigrationTaskRequest {
	s.OriginInstanceName = &v
	return s
}

func (s *ListMigrationTaskRequest) SetPageNum(v int64) *ListMigrationTaskRequest {
	s.PageNum = &v
	return s
}

func (s *ListMigrationTaskRequest) SetPageSize(v int64) *ListMigrationTaskRequest {
	s.PageSize = &v
	return s
}

func (s *ListMigrationTaskRequest) SetRequestPars(v string) *ListMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

type ListMigrationTaskResponseBody struct {
	// The array structure.
	Data []*ListMigrationTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskResponseBody) SetData(v []*ListMigrationTaskResponseBodyData) *ListMigrationTaskResponseBody {
	s.Data = v
	return s
}

func (s *ListMigrationTaskResponseBody) SetErrorCode(v string) *ListMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetHttpCode(v string) *ListMigrationTaskResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetMessage(v string) *ListMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetPageNumber(v int64) *ListMigrationTaskResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetPageSize(v int64) *ListMigrationTaskResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetRequestId(v string) *ListMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetSuccess(v bool) *ListMigrationTaskResponseBody {
	s.Success = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetTotalCount(v int64) *ListMigrationTaskResponseBody {
	s.TotalCount = &v
	return s
}

type ListMigrationTaskResponseBodyData struct {
	// The type of the instance.
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the job.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The address of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListMigrationTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskResponseBodyData) SetClusterType(v string) *ListMigrationTaskResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetGmtCreate(v string) *ListMigrationTaskResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetGmtModified(v string) *ListMigrationTaskResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetId(v int64) *ListMigrationTaskResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetOriginInstanceAddress(v string) *ListMigrationTaskResponseBodyData {
	s.OriginInstanceAddress = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetOriginInstanceName(v string) *ListMigrationTaskResponseBodyData {
	s.OriginInstanceName = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetOriginInstanceNamespace(v string) *ListMigrationTaskResponseBodyData {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetProjectDesc(v string) *ListMigrationTaskResponseBodyData {
	s.ProjectDesc = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetTargetClusterName(v string) *ListMigrationTaskResponseBodyData {
	s.TargetClusterName = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetTargetClusterUrl(v string) *ListMigrationTaskResponseBodyData {
	s.TargetClusterUrl = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetTargetInstanceId(v string) *ListMigrationTaskResponseBodyData {
	s.TargetInstanceId = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetUserId(v string) *ListMigrationTaskResponseBodyData {
	s.UserId = &v
	return s
}

type ListMigrationTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskResponse) SetHeaders(v map[string]*string) *ListMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *ListMigrationTaskResponse) SetStatusCode(v int32) *ListMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMigrationTaskResponse) SetBody(v *ListMigrationTaskResponseBody) *ListMigrationTaskResponse {
	s.Body = v
	return s
}

type ListNacosConfigsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the group. Default value: `default`
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters. The JSON format is supported.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The tags.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListNacosConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsRequest) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsRequest) SetAcceptLanguage(v string) *ListNacosConfigsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListNacosConfigsRequest) SetAppName(v string) *ListNacosConfigsRequest {
	s.AppName = &v
	return s
}

func (s *ListNacosConfigsRequest) SetDataId(v string) *ListNacosConfigsRequest {
	s.DataId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetGroup(v string) *ListNacosConfigsRequest {
	s.Group = &v
	return s
}

func (s *ListNacosConfigsRequest) SetInstanceId(v string) *ListNacosConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetNamespaceId(v string) *ListNacosConfigsRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetPageNum(v int32) *ListNacosConfigsRequest {
	s.PageNum = &v
	return s
}

func (s *ListNacosConfigsRequest) SetPageSize(v int32) *ListNacosConfigsRequest {
	s.PageSize = &v
	return s
}

func (s *ListNacosConfigsRequest) SetRegionId(v string) *ListNacosConfigsRequest {
	s.RegionId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetRequestPars(v string) *ListNacosConfigsRequest {
	s.RequestPars = &v
	return s
}

func (s *ListNacosConfigsRequest) SetTags(v string) *ListNacosConfigsRequest {
	s.Tags = &v
	return s
}

type ListNacosConfigsResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The configurations.
	Configurations []*ListNacosConfigsResponseBodyConfigurations `json:"Configurations,omitempty" xml:"Configurations,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListNacosConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsResponseBody) SetCode(v int32) *ListNacosConfigsResponseBody {
	s.Code = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetConfigurations(v []*ListNacosConfigsResponseBodyConfigurations) *ListNacosConfigsResponseBody {
	s.Configurations = v
	return s
}

func (s *ListNacosConfigsResponseBody) SetErrorCode(v string) *ListNacosConfigsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetHttpCode(v string) *ListNacosConfigsResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetMessage(v string) *ListNacosConfigsResponseBody {
	s.Message = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetPageNumber(v int32) *ListNacosConfigsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetPageSize(v int32) *ListNacosConfigsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetRequestId(v string) *ListNacosConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetSuccess(v bool) *ListNacosConfigsResponseBody {
	s.Success = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetTotalCount(v int32) *ListNacosConfigsResponseBody {
	s.TotalCount = &v
	return s
}

type ListNacosConfigsResponseBodyConfigurations struct {
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the application.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s ListNacosConfigsResponseBodyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsResponseBodyConfigurations) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetAppName(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.AppName = &v
	return s
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetDataId(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.DataId = &v
	return s
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetGroup(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.Group = &v
	return s
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetId(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.Id = &v
	return s
}

type ListNacosConfigsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNacosConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNacosConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsResponse) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsResponse) SetHeaders(v map[string]*string) *ListNacosConfigsResponse {
	s.Headers = v
	return s
}

func (s *ListNacosConfigsResponse) SetStatusCode(v int32) *ListNacosConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNacosConfigsResponse) SetBody(v *ListNacosConfigsResponseBody) *ListNacosConfigsResponse {
	s.Body = v
	return s
}

type ListNacosHistoryConfigsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListNacosHistoryConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsRequest) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsRequest) SetAcceptLanguage(v string) *ListNacosHistoryConfigsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetDataId(v string) *ListNacosHistoryConfigsRequest {
	s.DataId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetGroup(v string) *ListNacosHistoryConfigsRequest {
	s.Group = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetInstanceId(v string) *ListNacosHistoryConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetNamespaceId(v string) *ListNacosHistoryConfigsRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetPageNum(v int32) *ListNacosHistoryConfigsRequest {
	s.PageNum = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetPageSize(v int32) *ListNacosHistoryConfigsRequest {
	s.PageSize = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetRegionId(v string) *ListNacosHistoryConfigsRequest {
	s.RegionId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetRequestPars(v string) *ListNacosHistoryConfigsRequest {
	s.RequestPars = &v
	return s
}

type ListNacosHistoryConfigsResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The configuration items.
	HistoryItems []*ListNacosHistoryConfigsResponseBodyHistoryItems `json:"HistoryItems,omitempty" xml:"HistoryItems,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListNacosHistoryConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsResponseBody) SetErrorCode(v string) *ListNacosHistoryConfigsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetHistoryItems(v []*ListNacosHistoryConfigsResponseBodyHistoryItems) *ListNacosHistoryConfigsResponseBody {
	s.HistoryItems = v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetHttpCode(v string) *ListNacosHistoryConfigsResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetMessage(v string) *ListNacosHistoryConfigsResponseBody {
	s.Message = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetPageNumber(v int32) *ListNacosHistoryConfigsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetPageSize(v int32) *ListNacosHistoryConfigsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetRequestId(v string) *ListNacosHistoryConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetSuccess(v bool) *ListNacosHistoryConfigsResponseBody {
	s.Success = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetTotalCount(v int32) *ListNacosHistoryConfigsResponseBody {
	s.TotalCount = &v
	return s
}

type ListNacosHistoryConfigsResponseBodyHistoryItems struct {
	// The application tag.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timestamp when the configuration was last modified.
	LastModifiedTime *int64 `json:"LastModifiedTime,omitempty" xml:"LastModifiedTime,omitempty"`
	// The format of the configuration file.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
}

func (s ListNacosHistoryConfigsResponseBodyHistoryItems) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsResponseBodyHistoryItems) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetAppName(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.AppName = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetDataId(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.DataId = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetGroup(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.Group = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetId(v int64) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.Id = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetLastModifiedTime(v int64) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.LastModifiedTime = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetOpType(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.OpType = &v
	return s
}

type ListNacosHistoryConfigsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNacosHistoryConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNacosHistoryConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsResponse) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsResponse) SetHeaders(v map[string]*string) *ListNacosHistoryConfigsResponse {
	s.Headers = v
	return s
}

func (s *ListNacosHistoryConfigsResponse) SetStatusCode(v int32) *ListNacosHistoryConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNacosHistoryConfigsResponse) SetBody(v *ListNacosHistoryConfigsResponseBody) *ListNacosHistoryConfigsResponse {
	s.Body = v
	return s
}

type ListNamingTrackRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The end timestamp. Unit: seconds.
	EndTs *int64 `json:"EndTs,omitempty" xml:"EndTs,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the client.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
	//
	// *   `true`: sorts the query results in reverse chronological order.
	// *   `false`: sorts the query results in chronological order.
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The start timestamp. Unit: seconds.
	StartTs *int64 `json:"StartTs,omitempty" xml:"StartTs,omitempty"`
}

func (s ListNamingTrackRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackRequest) GoString() string {
	return s.String()
}

func (s *ListNamingTrackRequest) SetAcceptLanguage(v string) *ListNamingTrackRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListNamingTrackRequest) SetEndTs(v int64) *ListNamingTrackRequest {
	s.EndTs = &v
	return s
}

func (s *ListNamingTrackRequest) SetGroup(v string) *ListNamingTrackRequest {
	s.Group = &v
	return s
}

func (s *ListNamingTrackRequest) SetInstanceId(v string) *ListNamingTrackRequest {
	s.InstanceId = &v
	return s
}

func (s *ListNamingTrackRequest) SetIp(v string) *ListNamingTrackRequest {
	s.Ip = &v
	return s
}

func (s *ListNamingTrackRequest) SetNamespaceId(v string) *ListNamingTrackRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListNamingTrackRequest) SetPageNum(v int64) *ListNamingTrackRequest {
	s.PageNum = &v
	return s
}

func (s *ListNamingTrackRequest) SetPageSize(v int64) *ListNamingTrackRequest {
	s.PageSize = &v
	return s
}

func (s *ListNamingTrackRequest) SetRequestPars(v string) *ListNamingTrackRequest {
	s.RequestPars = &v
	return s
}

func (s *ListNamingTrackRequest) SetReverse(v bool) *ListNamingTrackRequest {
	s.Reverse = &v
	return s
}

func (s *ListNamingTrackRequest) SetServiceName(v string) *ListNamingTrackRequest {
	s.ServiceName = &v
	return s
}

func (s *ListNamingTrackRequest) SetStartTs(v int64) *ListNamingTrackRequest {
	s.StartTs = &v
	return s
}

type ListNamingTrackResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned entries.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The data information.
	Traces []*ListNamingTrackResponseBodyTraces `json:"Traces,omitempty" xml:"Traces,omitempty" type:"Repeated"`
}

func (s ListNamingTrackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackResponseBody) GoString() string {
	return s.String()
}

func (s *ListNamingTrackResponseBody) SetErrorCode(v string) *ListNamingTrackResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetHttpCode(v string) *ListNamingTrackResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetMessage(v string) *ListNamingTrackResponseBody {
	s.Message = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetPageNumber(v int64) *ListNamingTrackResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetPageSize(v int64) *ListNamingTrackResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetRequestId(v string) *ListNamingTrackResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetSuccess(v bool) *ListNamingTrackResponseBody {
	s.Success = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetTotalCount(v int64) *ListNamingTrackResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetTraces(v []*ListNamingTrackResponseBodyTraces) *ListNamingTrackResponseBody {
	s.Traces = v
	return s
}

type ListNamingTrackResponseBodyTraces struct {
	// The IP address of the client.
	ClientIp *string `json:"ClientIp,omitempty" xml:"ClientIp,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The number of instances.
	InstanceSize *string `json:"InstanceSize,omitempty" xml:"InstanceSize,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The push time.
	PushTime *string `json:"PushTime,omitempty" xml:"PushTime,omitempty"`
	// The total push time.
	PushTimeAll *string `json:"PushTimeAll,omitempty" xml:"PushTimeAll,omitempty"`
	// The push time for the network.
	PushTimeNetwork *string `json:"PushTimeNetwork,omitempty" xml:"PushTimeNetwork,omitempty"`
	// The name of the service.
	ServerName *string `json:"ServerName,omitempty" xml:"ServerName,omitempty"`
	// The duration that is specified in the service-level agreement (SLA).
	SlaTime *string `json:"SlaTime,omitempty" xml:"SlaTime,omitempty"`
}

func (s ListNamingTrackResponseBodyTraces) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackResponseBodyTraces) GoString() string {
	return s.String()
}

func (s *ListNamingTrackResponseBodyTraces) SetClientIp(v string) *ListNamingTrackResponseBodyTraces {
	s.ClientIp = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetGroup(v string) *ListNamingTrackResponseBodyTraces {
	s.Group = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetInstanceSize(v string) *ListNamingTrackResponseBodyTraces {
	s.InstanceSize = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetNodeName(v string) *ListNamingTrackResponseBodyTraces {
	s.NodeName = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetPushTime(v string) *ListNamingTrackResponseBodyTraces {
	s.PushTime = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetPushTimeAll(v string) *ListNamingTrackResponseBodyTraces {
	s.PushTimeAll = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetPushTimeNetwork(v string) *ListNamingTrackResponseBodyTraces {
	s.PushTimeNetwork = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetServerName(v string) *ListNamingTrackResponseBodyTraces {
	s.ServerName = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetSlaTime(v string) *ListNamingTrackResponseBodyTraces {
	s.SlaTime = &v
	return s
}

type ListNamingTrackResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNamingTrackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNamingTrackResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackResponse) GoString() string {
	return s.String()
}

func (s *ListNamingTrackResponse) SetHeaders(v map[string]*string) *ListNamingTrackResponse {
	s.Headers = v
	return s
}

func (s *ListNamingTrackResponse) SetStatusCode(v int32) *ListNamingTrackResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNamingTrackResponse) SetBody(v *ListNamingTrackResponseBody) *ListNamingTrackResponse {
	s.Body = v
	return s
}

type ListSSLCertRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListSSLCertRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertRequest) GoString() string {
	return s.String()
}

func (s *ListSSLCertRequest) SetAcceptLanguage(v string) *ListSSLCertRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListSSLCertRequest) SetGatewayUniqueId(v string) *ListSSLCertRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListSSLCertResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*ListSSLCertResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSSLCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertResponseBody) GoString() string {
	return s.String()
}

func (s *ListSSLCertResponseBody) SetCode(v int32) *ListSSLCertResponseBody {
	s.Code = &v
	return s
}

func (s *ListSSLCertResponseBody) SetData(v []*ListSSLCertResponseBodyData) *ListSSLCertResponseBody {
	s.Data = v
	return s
}

func (s *ListSSLCertResponseBody) SetHttpStatusCode(v int32) *ListSSLCertResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListSSLCertResponseBody) SetMessage(v string) *ListSSLCertResponseBody {
	s.Message = &v
	return s
}

func (s *ListSSLCertResponseBody) SetRequestId(v string) *ListSSLCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSSLCertResponseBody) SetSuccess(v bool) *ListSSLCertResponseBody {
	s.Success = &v
	return s
}

type ListSSLCertResponseBodyData struct {
	// The time when the certificate expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	AfterDate *string `json:"AfterDate,omitempty" xml:"AfterDate,omitempty"`
	// The algorithm.
	Algorithm *string `json:"Algorithm,omitempty" xml:"Algorithm,omitempty"`
	// The time when the certificate took effect. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	BeforeDate *string `json:"BeforeDate,omitempty" xml:"BeforeDate,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The domain name with which the certificate is associated.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The time when the certificate expires. This value is a GMT timestamp.
	GmtAfter *string `json:"GmtAfter,omitempty" xml:"GmtAfter,omitempty"`
	// The time when the certificate took effect. This value is a GMT timestamp.
	GmtBefore *string `json:"GmtBefore,omitempty" xml:"GmtBefore,omitempty"`
	// The issuer of the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The SSL certificate.
	Sans *string `json:"Sans,omitempty" xml:"Sans,omitempty"`
}

func (s ListSSLCertResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSSLCertResponseBodyData) SetAfterDate(v string) *ListSSLCertResponseBodyData {
	s.AfterDate = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetAlgorithm(v string) *ListSSLCertResponseBodyData {
	s.Algorithm = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetBeforeDate(v string) *ListSSLCertResponseBodyData {
	s.BeforeDate = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetCertIdentifier(v string) *ListSSLCertResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetCertName(v string) *ListSSLCertResponseBodyData {
	s.CertName = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetCommonName(v string) *ListSSLCertResponseBodyData {
	s.CommonName = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetGmtAfter(v string) *ListSSLCertResponseBodyData {
	s.GmtAfter = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetGmtBefore(v string) *ListSSLCertResponseBodyData {
	s.GmtBefore = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetIssuer(v string) *ListSSLCertResponseBodyData {
	s.Issuer = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetSans(v string) *ListSSLCertResponseBodyData {
	s.Sans = &v
	return s
}

type ListSSLCertResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSSLCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSSLCertResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertResponse) GoString() string {
	return s.String()
}

func (s *ListSSLCertResponse) SetHeaders(v map[string]*string) *ListSSLCertResponse {
	s.Headers = v
	return s
}

func (s *ListSSLCertResponse) SetStatusCode(v int32) *ListSSLCertResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSSLCertResponse) SetBody(v *ListSSLCertResponseBody) *ListSSLCertResponse {
	s.Body = v
	return s
}

type ListSecurityGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListSecurityGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRequest) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRequest) SetAcceptLanguage(v string) *ListSecurityGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListSecurityGroupRequest) SetGatewayUniqueId(v string) *ListSecurityGroupRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListSecurityGroupResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*ListSecurityGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSecurityGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupResponseBody) SetCode(v int32) *ListSecurityGroupResponseBody {
	s.Code = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetData(v []*ListSecurityGroupResponseBodyData) *ListSecurityGroupResponseBody {
	s.Data = v
	return s
}

func (s *ListSecurityGroupResponseBody) SetHttpStatusCode(v int32) *ListSecurityGroupResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetMessage(v string) *ListSecurityGroupResponseBody {
	s.Message = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetRequestId(v string) *ListSecurityGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetSuccess(v bool) *ListSecurityGroupResponseBody {
	s.Success = &v
	return s
}

type ListSecurityGroupResponseBodyData struct {
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The name of the security group.
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
	// The type of the security group. Valid values:
	//
	// *   normal: basic security group
	// *   enterprise: advanced security group For more information, see [Advanced security groups](~~120621~~).
	SecurityGroupType *string `json:"SecurityGroupType,omitempty" xml:"SecurityGroupType,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListSecurityGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupResponseBodyData) SetSecurityGroupId(v string) *ListSecurityGroupResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

func (s *ListSecurityGroupResponseBodyData) SetSecurityGroupName(v string) *ListSecurityGroupResponseBodyData {
	s.SecurityGroupName = &v
	return s
}

func (s *ListSecurityGroupResponseBodyData) SetSecurityGroupType(v string) *ListSecurityGroupResponseBodyData {
	s.SecurityGroupType = &v
	return s
}

func (s *ListSecurityGroupResponseBodyData) SetVpcId(v string) *ListSecurityGroupResponseBodyData {
	s.VpcId = &v
	return s
}

type ListSecurityGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSecurityGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSecurityGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupResponse) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupResponse) SetHeaders(v map[string]*string) *ListSecurityGroupResponse {
	s.Headers = v
	return s
}

func (s *ListSecurityGroupResponse) SetStatusCode(v int32) *ListSecurityGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSecurityGroupResponse) SetBody(v *ListSecurityGroupResponseBody) *ListSecurityGroupResponse {
	s.Body = v
	return s
}

type ListSecurityGroupRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListSecurityGroupRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleRequest) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleRequest) SetAcceptLanguage(v string) *ListSecurityGroupRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListSecurityGroupRuleRequest) SetGatewayUniqueId(v string) *ListSecurityGroupRuleRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListSecurityGroupRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*ListSecurityGroupRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSecurityGroupRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleResponseBody) SetCode(v int32) *ListSecurityGroupRuleResponseBody {
	s.Code = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetData(v []*ListSecurityGroupRuleResponseBodyData) *ListSecurityGroupRuleResponseBody {
	s.Data = v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetHttpStatusCode(v int32) *ListSecurityGroupRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetMessage(v string) *ListSecurityGroupRuleResponseBody {
	s.Message = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetRequestId(v string) *ListSecurityGroupRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetSuccess(v bool) *ListSecurityGroupRuleResponseBody {
	s.Success = &v
	return s
}

type ListSecurityGroupRuleResponseBodyData struct {
	AuthCidrs []*string `json:"AuthCidrs,omitempty" xml:"AuthCidrs,omitempty" type:"Repeated"`
	// The rule description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The gateway ID.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the instance was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the instance configuration was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The authorization record ID of the security group.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The protocol type.
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The port range.
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s ListSecurityGroupRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleResponseBodyData) SetAuthCidrs(v []*string) *ListSecurityGroupRuleResponseBodyData {
	s.AuthCidrs = v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetDescription(v string) *ListSecurityGroupRuleResponseBodyData {
	s.Description = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGatewayId(v int64) *ListSecurityGroupRuleResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGatewayUniqueId(v string) *ListSecurityGroupRuleResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGmtCreate(v string) *ListSecurityGroupRuleResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGmtModified(v string) *ListSecurityGroupRuleResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetId(v string) *ListSecurityGroupRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetIpProtocol(v string) *ListSecurityGroupRuleResponseBodyData {
	s.IpProtocol = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetPortRange(v string) *ListSecurityGroupRuleResponseBodyData {
	s.PortRange = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetSecurityGroupId(v string) *ListSecurityGroupRuleResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

type ListSecurityGroupRuleResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSecurityGroupRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSecurityGroupRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleResponse) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleResponse) SetHeaders(v map[string]*string) *ListSecurityGroupRuleResponse {
	s.Headers = v
	return s
}

func (s *ListSecurityGroupRuleResponse) SetStatusCode(v int32) *ListSecurityGroupRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSecurityGroupRuleResponse) SetBody(v *ListSecurityGroupRuleResponseBody) *ListSecurityGroupRuleResponse {
	s.Body = v
	return s
}

type ListServiceSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies the type of the returned service source. If this parameter is not specified, service sources of all types are returned. Valid values:
	//
	// *   K8s
	// *   MSE
	// *   MSE_ZK
	// *   SAE
	// *   EDAS
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ListServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *ListServiceSourceRequest) SetAcceptLanguage(v string) *ListServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListServiceSourceRequest) SetGatewayUniqueId(v string) *ListServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListServiceSourceRequest) SetSource(v string) *ListServiceSourceRequest {
	s.Source = &v
	return s
}

type ListServiceSourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*ListServiceSourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponseBody) SetCode(v int32) *ListServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetData(v []*ListServiceSourceResponseBodyData) *ListServiceSourceResponseBody {
	s.Data = v
	return s
}

func (s *ListServiceSourceResponseBody) SetHttpStatusCode(v int32) *ListServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetMessage(v string) *ListServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetRequestId(v string) *ListServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetSuccess(v bool) *ListServiceSourceResponseBody {
	s.Success = &v
	return s
}

type ListServiceSourceResponseBodyData struct {
	// The ID of the Container Service for Kubernetes (ACK) cluster or the endpoint of the Microservices Engine (MSE) instance.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// Indicates whether the service source is associated with the gateway. The value 1 indicates that the service source is associated with the gateway.
	BindingWithGateway *int32 `json:"BindingWithGateway,omitempty" xml:"BindingWithGateway,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The array of service groups.
	GroupList []*string `json:"GroupList,omitempty" xml:"GroupList,omitempty" type:"Repeated"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The information about the support for Ingresses by applications.
	IngressOptions *ListServiceSourceResponseBodyDataIngressOptions `json:"IngressOptions,omitempty" xml:"IngressOptions,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The array of root paths of service lists.
	PathList []*string `json:"PathList,omitempty" xml:"PathList,omitempty" type:"Repeated"`
	// The type of the service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The unique ID of the service source.
	SourceUniqueId *string `json:"SourceUniqueId,omitempty" xml:"SourceUniqueId,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListServiceSourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponseBodyData) SetAddress(v string) *ListServiceSourceResponseBodyData {
	s.Address = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetBindingWithGateway(v int32) *ListServiceSourceResponseBodyData {
	s.BindingWithGateway = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGatewayId(v int64) *ListServiceSourceResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGatewayUniqueId(v string) *ListServiceSourceResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGmtCreate(v string) *ListServiceSourceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGmtModified(v string) *ListServiceSourceResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGroupList(v []*string) *ListServiceSourceResponseBodyData {
	s.GroupList = v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetId(v int64) *ListServiceSourceResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetIngressOptions(v *ListServiceSourceResponseBodyDataIngressOptions) *ListServiceSourceResponseBodyData {
	s.IngressOptions = v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetName(v string) *ListServiceSourceResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetPathList(v []*string) *ListServiceSourceResponseBodyData {
	s.PathList = v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetSource(v string) *ListServiceSourceResponseBodyData {
	s.Source = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetSourceUniqueId(v string) *ListServiceSourceResponseBodyData {
	s.SourceUniqueId = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetType(v string) *ListServiceSourceResponseBodyData {
	s.Type = &v
	return s
}

type ListServiceSourceResponseBodyDataIngressOptions struct {
	// Indicates whether Ingresses are enabled.
	EnableIngress *bool `json:"EnableIngress,omitempty" xml:"EnableIngress,omitempty"`
	// Indicates whether the Ingress status is updated.
	EnableStatus *bool `json:"EnableStatus,omitempty" xml:"EnableStatus,omitempty"`
	// The Ingress class.
	IngressClass *string `json:"IngressClass,omitempty" xml:"IngressClass,omitempty"`
	// The namespace that you want to monitor.
	WatchNamespace *string `json:"WatchNamespace,omitempty" xml:"WatchNamespace,omitempty"`
}

func (s ListServiceSourceResponseBodyDataIngressOptions) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponseBodyDataIngressOptions) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetEnableIngress(v bool) *ListServiceSourceResponseBodyDataIngressOptions {
	s.EnableIngress = &v
	return s
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetEnableStatus(v bool) *ListServiceSourceResponseBodyDataIngressOptions {
	s.EnableStatus = &v
	return s
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetIngressClass(v string) *ListServiceSourceResponseBodyDataIngressOptions {
	s.IngressClass = &v
	return s
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetWatchNamespace(v string) *ListServiceSourceResponseBodyDataIngressOptions {
	s.WatchNamespace = &v
	return s
}

type ListServiceSourceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponse) SetHeaders(v map[string]*string) *ListServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *ListServiceSourceResponse) SetStatusCode(v int32) *ListServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListServiceSourceResponse) SetBody(v *ListServiceSourceResponseBody) *ListServiceSourceResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The token used to start the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs. You can specify a maximum of 50 resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource. Valid values:
	//
	// *   CLUSTER: MSE instance
	// *   GATEWAY: cloud-native gateway
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tags. A maximum number of 20 tags are supported.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetAcceptLanguage(v string) *ListTagResourcesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The token that is required for the next query. If the NextToken parameter is empty, no subsequent query is required.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The list of resources.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetErrorCode(v string) *ListTagResourcesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetMessage(v string) *ListTagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetSuccess(v bool) *ListTagResourcesResponseBody {
	s.Success = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListZkTrackRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The end timestamp. Unit: seconds.
	EndTs *int64 `json:"EndTs,omitempty" xml:"EndTs,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The request parameters.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// Specifies whether to enable reverse ordering.
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The session ID.
	SessionId *string `json:"SessionId,omitempty" xml:"SessionId,omitempty"`
	// The start timestamp. Unit: seconds.
	StartTs *int64 `json:"StartTs,omitempty" xml:"StartTs,omitempty"`
}

func (s ListZkTrackRequest) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackRequest) GoString() string {
	return s.String()
}

func (s *ListZkTrackRequest) SetAcceptLanguage(v string) *ListZkTrackRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListZkTrackRequest) SetEndTs(v int64) *ListZkTrackRequest {
	s.EndTs = &v
	return s
}

func (s *ListZkTrackRequest) SetInstanceId(v string) *ListZkTrackRequest {
	s.InstanceId = &v
	return s
}

func (s *ListZkTrackRequest) SetPageNum(v int64) *ListZkTrackRequest {
	s.PageNum = &v
	return s
}

func (s *ListZkTrackRequest) SetPageSize(v int64) *ListZkTrackRequest {
	s.PageSize = &v
	return s
}

func (s *ListZkTrackRequest) SetPath(v string) *ListZkTrackRequest {
	s.Path = &v
	return s
}

func (s *ListZkTrackRequest) SetRequestPars(v string) *ListZkTrackRequest {
	s.RequestPars = &v
	return s
}

func (s *ListZkTrackRequest) SetReverse(v bool) *ListZkTrackRequest {
	s.Reverse = &v
	return s
}

func (s *ListZkTrackRequest) SetSessionId(v string) *ListZkTrackRequest {
	s.SessionId = &v
	return s
}

func (s *ListZkTrackRequest) SetStartTs(v int64) *ListZkTrackRequest {
	s.StartTs = &v
	return s
}

type ListZkTrackResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The track data.
	Traces []*ListZkTrackResponseBodyTraces `json:"Traces,omitempty" xml:"Traces,omitempty" type:"Repeated"`
}

func (s ListZkTrackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackResponseBody) GoString() string {
	return s.String()
}

func (s *ListZkTrackResponseBody) SetErrorCode(v string) *ListZkTrackResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListZkTrackResponseBody) SetHttpCode(v string) *ListZkTrackResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListZkTrackResponseBody) SetMessage(v string) *ListZkTrackResponseBody {
	s.Message = &v
	return s
}

func (s *ListZkTrackResponseBody) SetPageNumber(v int64) *ListZkTrackResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListZkTrackResponseBody) SetPageSize(v int64) *ListZkTrackResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListZkTrackResponseBody) SetRequestId(v string) *ListZkTrackResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListZkTrackResponseBody) SetSuccess(v bool) *ListZkTrackResponseBody {
	s.Success = &v
	return s
}

func (s *ListZkTrackResponseBody) SetTotalCount(v int64) *ListZkTrackResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListZkTrackResponseBody) SetTraces(v []*ListZkTrackResponseBodyTraces) *ListZkTrackResponseBody {
	s.Traces = v
	return s
}

type ListZkTrackResponseBodyTraces struct {
	// The access control list (ACL).
	Acl *string `json:"Acl,omitempty" xml:"Acl,omitempty"`
	// The data type. Valid values:
	//
	// *   persist
	// *   ephemeral
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The type of the event. For trajectory of the Notify type:
	//
	// *   NodeCreated
	// *   NodeDeleted
	// *   NodeDataChanged
	// *   NodeChildrenChanged
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// Indicates whether the transaction ended.
	Finished *bool `json:"Finished,omitempty" xml:"Finished,omitempty"`
	// The logging time.
	LogDate *string `json:"LogDate,omitempty" xml:"LogDate,omitempty"`
	// The transaction size.
	MultiSize *int64 `json:"MultiSize,omitempty" xml:"MultiSize,omitempty"`
	// The type of the operation. For trajectory of the Push type:
	//
	// *   Create
	// *   Update
	// *   Delete
	// *   SetAcl
	// *   Multi
	//
	// For trajectory of the Pull type:
	//
	// *   GetData
	// *   GetChild
	// *   GetStat
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The returned result.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
	// The session ID.
	SessionId *string `json:"SessionId,omitempty" xml:"SessionId,omitempty"`
	// The timestamp. It is not available.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The type of the trajectory. Valid values:
	//
	// *   Push
	// *   Pull
	// *   Notify
	TraceType *string `json:"TraceType,omitempty" xml:"TraceType,omitempty"`
	// The time to live (TTL).
	Ttl *int64 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// Indicates whether the monitoring feature is enabled.
	Watch *bool `json:"Watch,omitempty" xml:"Watch,omitempty"`
}

func (s ListZkTrackResponseBodyTraces) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackResponseBodyTraces) GoString() string {
	return s.String()
}

func (s *ListZkTrackResponseBodyTraces) SetAcl(v string) *ListZkTrackResponseBodyTraces {
	s.Acl = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetDataType(v string) *ListZkTrackResponseBodyTraces {
	s.DataType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetEventType(v string) *ListZkTrackResponseBodyTraces {
	s.EventType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetFinished(v bool) *ListZkTrackResponseBodyTraces {
	s.Finished = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetLogDate(v string) *ListZkTrackResponseBodyTraces {
	s.LogDate = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetMultiSize(v int64) *ListZkTrackResponseBodyTraces {
	s.MultiSize = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetOpType(v string) *ListZkTrackResponseBodyTraces {
	s.OpType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetPath(v string) *ListZkTrackResponseBodyTraces {
	s.Path = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetResult(v string) *ListZkTrackResponseBodyTraces {
	s.Result = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetSessionId(v string) *ListZkTrackResponseBodyTraces {
	s.SessionId = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetTimestamp(v string) *ListZkTrackResponseBodyTraces {
	s.Timestamp = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetTraceType(v string) *ListZkTrackResponseBodyTraces {
	s.TraceType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetTtl(v int64) *ListZkTrackResponseBodyTraces {
	s.Ttl = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetWatch(v bool) *ListZkTrackResponseBodyTraces {
	s.Watch = &v
	return s
}

type ListZkTrackResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListZkTrackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListZkTrackResponse) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackResponse) GoString() string {
	return s.String()
}

func (s *ListZkTrackResponse) SetHeaders(v map[string]*string) *ListZkTrackResponse {
	s.Headers = v
	return s
}

func (s *ListZkTrackResponse) SetStatusCode(v int32) *ListZkTrackResponse {
	s.StatusCode = &v
	return s
}

func (s *ListZkTrackResponse) SetBody(v *ListZkTrackResponseBody) *ListZkTrackResponse {
	s.Body = v
	return s
}

type ListZnodeChildrenRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListZnodeChildrenRequest) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenRequest) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenRequest) SetAcceptLanguage(v string) *ListZnodeChildrenRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListZnodeChildrenRequest) SetClusterId(v string) *ListZnodeChildrenRequest {
	s.ClusterId = &v
	return s
}

func (s *ListZnodeChildrenRequest) SetPath(v string) *ListZnodeChildrenRequest {
	s.Path = &v
	return s
}

type ListZnodeChildrenResponseBody struct {
	// The details of the data.
	Data []*ListZnodeChildrenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListZnodeChildrenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenResponseBody) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenResponseBody) SetData(v []*ListZnodeChildrenResponseBodyData) *ListZnodeChildrenResponseBody {
	s.Data = v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetErrorCode(v string) *ListZnodeChildrenResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetMessage(v string) *ListZnodeChildrenResponseBody {
	s.Message = &v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetRequestId(v string) *ListZnodeChildrenResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetSuccess(v bool) *ListZnodeChildrenResponseBody {
	s.Success = &v
	return s
}

type ListZnodeChildrenResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListZnodeChildrenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenResponseBodyData) SetData(v string) *ListZnodeChildrenResponseBodyData {
	s.Data = &v
	return s
}

func (s *ListZnodeChildrenResponseBodyData) SetDir(v bool) *ListZnodeChildrenResponseBodyData {
	s.Dir = &v
	return s
}

func (s *ListZnodeChildrenResponseBodyData) SetName(v string) *ListZnodeChildrenResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListZnodeChildrenResponseBodyData) SetPath(v string) *ListZnodeChildrenResponseBodyData {
	s.Path = &v
	return s
}

type ListZnodeChildrenResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListZnodeChildrenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListZnodeChildrenResponse) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenResponse) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenResponse) SetHeaders(v map[string]*string) *ListZnodeChildrenResponse {
	s.Headers = v
	return s
}

func (s *ListZnodeChildrenResponse) SetStatusCode(v int32) *ListZnodeChildrenResponse {
	s.StatusCode = &v
	return s
}

func (s *ListZnodeChildrenResponse) SetBody(v *ListZnodeChildrenResponseBody) *ListZnodeChildrenResponse {
	s.Body = v
	return s
}

type ModifyGovernanceKubernetesClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The information about the namespace for which Microservices Engine(MSE) Microservices Governance is enabled.
	NamespaceInfos []*ModifyGovernanceKubernetesClusterRequestNamespaceInfos `json:"NamespaceInfos,omitempty" xml:"NamespaceInfos,omitempty" type:"Repeated"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyGovernanceKubernetesClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterRequest) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetAcceptLanguage(v string) *ModifyGovernanceKubernetesClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetClusterId(v string) *ModifyGovernanceKubernetesClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetNamespaceInfos(v []*ModifyGovernanceKubernetesClusterRequestNamespaceInfos) *ModifyGovernanceKubernetesClusterRequest {
	s.NamespaceInfos = v
	return s
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetRegionId(v string) *ModifyGovernanceKubernetesClusterRequest {
	s.RegionId = &v
	return s
}

type ModifyGovernanceKubernetesClusterRequestNamespaceInfos struct {
	// The microservice namespace.If you do not specify this parameter, Microservice Governance is not enabled for the namespace.
	MseNamespace *string `json:"MseNamespace,omitempty" xml:"MseNamespace,omitempty"`
	// The name of the Kubernetes namespace.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ModifyGovernanceKubernetesClusterRequestNamespaceInfos) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterRequestNamespaceInfos) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterRequestNamespaceInfos) SetMseNamespace(v string) *ModifyGovernanceKubernetesClusterRequestNamespaceInfos {
	s.MseNamespace = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterRequestNamespaceInfos) SetName(v string) *ModifyGovernanceKubernetesClusterRequestNamespaceInfos {
	s.Name = &v
	return s
}

type ModifyGovernanceKubernetesClusterShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The information about the namespace for which Microservices Engine(MSE) Microservices Governance is enabled.
	NamespaceInfosShrink *string `json:"NamespaceInfos,omitempty" xml:"NamespaceInfos,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyGovernanceKubernetesClusterShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterShrinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterShrinkRequest) SetAcceptLanguage(v string) *ModifyGovernanceKubernetesClusterShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterShrinkRequest) SetClusterId(v string) *ModifyGovernanceKubernetesClusterShrinkRequest {
	s.ClusterId = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterShrinkRequest) SetNamespaceInfosShrink(v string) *ModifyGovernanceKubernetesClusterShrinkRequest {
	s.NamespaceInfosShrink = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterShrinkRequest) SetRegionId(v string) *ModifyGovernanceKubernetesClusterShrinkRequest {
	s.RegionId = &v
	return s
}

type ModifyGovernanceKubernetesClusterResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The deletion result.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyGovernanceKubernetesClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetCode(v int32) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetData(v bool) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Data = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetHttpStatusCode(v int32) *ModifyGovernanceKubernetesClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetMessage(v string) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetRequestId(v string) *ModifyGovernanceKubernetesClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetSuccess(v bool) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Success = &v
	return s
}

type ModifyGovernanceKubernetesClusterResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyGovernanceKubernetesClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyGovernanceKubernetesClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterResponse) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterResponse) SetHeaders(v map[string]*string) *ModifyGovernanceKubernetesClusterResponse {
	s.Headers = v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponse) SetStatusCode(v int32) *ModifyGovernanceKubernetesClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponse) SetBody(v *ModifyGovernanceKubernetesClusterResponseBody) *ModifyGovernanceKubernetesClusterResponse {
	s.Body = v
	return s
}

type ModifyLosslessRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to align the lifecycle of the application in the Kubernetes cluster with that of the microservice.
	Aligned *bool `json:"Aligned,omitempty" xml:"Aligned,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The registration latency.
	DelayTime *int32 `json:"DelayTime,omitempty" xml:"DelayTime,omitempty"`
	// Specifies whether to enable the alert rule. Valid values:
	//
	// *   `true`: enables the rule.
	// *   `false`: disables the rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The slope of the prefetching curve.
	FuncType *int32 `json:"FuncType,omitempty" xml:"FuncType,omitempty"`
	// Specifies whether to display online and offline processing details.
	LossLessDetail *bool `json:"LossLessDetail,omitempty" xml:"LossLessDetail,omitempty"`
	// The microservice namespace to which the rule applies.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Specifies whether to enable notification.
	Notice *bool `json:"Notice,omitempty" xml:"Notice,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to associate with service prefetching.
	Related *bool `json:"Related,omitempty" xml:"Related,omitempty"`
	// The prefetching duration.
	WarmupTime *int32 `json:"WarmupTime,omitempty" xml:"WarmupTime,omitempty"`
}

func (s ModifyLosslessRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLosslessRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyLosslessRuleRequest) SetAcceptLanguage(v string) *ModifyLosslessRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetAligned(v bool) *ModifyLosslessRuleRequest {
	s.Aligned = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetAppId(v string) *ModifyLosslessRuleRequest {
	s.AppId = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetAppName(v string) *ModifyLosslessRuleRequest {
	s.AppName = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetDelayTime(v int32) *ModifyLosslessRuleRequest {
	s.DelayTime = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetEnable(v bool) *ModifyLosslessRuleRequest {
	s.Enable = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetFuncType(v int32) *ModifyLosslessRuleRequest {
	s.FuncType = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetLossLessDetail(v bool) *ModifyLosslessRuleRequest {
	s.LossLessDetail = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetNamespace(v string) *ModifyLosslessRuleRequest {
	s.Namespace = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetNotice(v bool) *ModifyLosslessRuleRequest {
	s.Notice = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetRegionId(v string) *ModifyLosslessRuleRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetRelated(v bool) *ModifyLosslessRuleRequest {
	s.Related = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetWarmupTime(v int32) *ModifyLosslessRuleRequest {
	s.WarmupTime = &v
	return s
}

type ModifyLosslessRuleResponseBody struct {
	// 
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// 
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// HTTP
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyLosslessRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLosslessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLosslessRuleResponseBody) SetCode(v int32) *ModifyLosslessRuleResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetData(v interface{}) *ModifyLosslessRuleResponseBody {
	s.Data = v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetErrorCode(v string) *ModifyLosslessRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetHttpStatusCode(v int32) *ModifyLosslessRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetMessage(v string) *ModifyLosslessRuleResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetRequestId(v string) *ModifyLosslessRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetSuccess(v bool) *ModifyLosslessRuleResponseBody {
	s.Success = &v
	return s
}

type ModifyLosslessRuleResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLosslessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLosslessRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLosslessRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyLosslessRuleResponse) SetHeaders(v map[string]*string) *ModifyLosslessRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyLosslessRuleResponse) SetStatusCode(v int32) *ModifyLosslessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLosslessRuleResponse) SetBody(v *ModifyLosslessRuleResponseBody) *ModifyLosslessRuleResponse {
	s.Body = v
	return s
}

type OfflineGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *string `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s OfflineGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s OfflineGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *OfflineGatewayRouteRequest) SetAcceptLanguage(v string) *OfflineGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *OfflineGatewayRouteRequest) SetGatewayUniqueId(v string) *OfflineGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *OfflineGatewayRouteRequest) SetRouteId(v string) *OfflineGatewayRouteRequest {
	s.RouteId = &v
	return s
}

type OfflineGatewayRouteResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the route is unpublished.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s OfflineGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OfflineGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *OfflineGatewayRouteResponseBody) SetCode(v int32) *OfflineGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetData(v bool) *OfflineGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetHttpStatusCode(v int32) *OfflineGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetMessage(v string) *OfflineGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetRequestId(v string) *OfflineGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetSuccess(v bool) *OfflineGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type OfflineGatewayRouteResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OfflineGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OfflineGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s OfflineGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *OfflineGatewayRouteResponse) SetHeaders(v map[string]*string) *OfflineGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *OfflineGatewayRouteResponse) SetStatusCode(v int32) *OfflineGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *OfflineGatewayRouteResponse) SetBody(v *OfflineGatewayRouteResponseBody) *OfflineGatewayRouteResponse {
	s.Body = v
	return s
}

type OrderClusterHealthCheckRiskNoticeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether to disable the notification feature if the risk item occurs.
	//
	// *   true: disabled
	// *   false: enabled
	Mute *bool `json:"Mute,omitempty" xml:"Mute,omitempty"`
	// A reserved parameter.
	NoticeType *string `json:"NoticeType,omitempty" xml:"NoticeType,omitempty"`
	// The region in which the cluster resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The ID of the risk item.
	RiskCode *string `json:"RiskCode,omitempty" xml:"RiskCode,omitempty"`
}

func (s OrderClusterHealthCheckRiskNoticeRequest) String() string {
	return tea.Prettify(s)
}

func (s OrderClusterHealthCheckRiskNoticeRequest) GoString() string {
	return s.String()
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetAcceptLanguage(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetInstanceId(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.InstanceId = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetMute(v bool) *OrderClusterHealthCheckRiskNoticeRequest {
	s.Mute = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetNoticeType(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.NoticeType = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetRegionId(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.RegionId = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetRequestPars(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.RequestPars = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetRiskCode(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.RiskCode = &v
	return s
}

type OrderClusterHealthCheckRiskNoticeResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the subscription was successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s OrderClusterHealthCheckRiskNoticeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OrderClusterHealthCheckRiskNoticeResponseBody) GoString() string {
	return s.String()
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetCode(v int32) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Code = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetData(v bool) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Data = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetDynamicCode(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetDynamicMessage(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetErrorCode(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetHttpStatusCode(v int32) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetMessage(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Message = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetRequestId(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.RequestId = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetSuccess(v bool) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Success = &v
	return s
}

type OrderClusterHealthCheckRiskNoticeResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OrderClusterHealthCheckRiskNoticeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OrderClusterHealthCheckRiskNoticeResponse) String() string {
	return tea.Prettify(s)
}

func (s OrderClusterHealthCheckRiskNoticeResponse) GoString() string {
	return s.String()
}

func (s *OrderClusterHealthCheckRiskNoticeResponse) SetHeaders(v map[string]*string) *OrderClusterHealthCheckRiskNoticeResponse {
	s.Headers = v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponse) SetStatusCode(v int32) *OrderClusterHealthCheckRiskNoticeResponse {
	s.StatusCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponse) SetBody(v *OrderClusterHealthCheckRiskNoticeResponseBody) *OrderClusterHealthCheckRiskNoticeResponse {
	s.Body = v
	return s
}

type PullServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s PullServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s PullServicesRequest) GoString() string {
	return s.String()
}

func (s *PullServicesRequest) SetAcceptLanguage(v string) *PullServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *PullServicesRequest) SetGatewayUniqueId(v string) *PullServicesRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *PullServicesRequest) SetNamespace(v string) *PullServicesRequest {
	s.Namespace = &v
	return s
}

func (s *PullServicesRequest) SetSourceType(v string) *PullServicesRequest {
	s.SourceType = &v
	return s
}

type PullServicesResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*PullServicesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PullServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponseBody) GoString() string {
	return s.String()
}

func (s *PullServicesResponseBody) SetCode(v int32) *PullServicesResponseBody {
	s.Code = &v
	return s
}

func (s *PullServicesResponseBody) SetData(v []*PullServicesResponseBodyData) *PullServicesResponseBody {
	s.Data = v
	return s
}

func (s *PullServicesResponseBody) SetHttpStatusCode(v int32) *PullServicesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *PullServicesResponseBody) SetMessage(v string) *PullServicesResponseBody {
	s.Message = &v
	return s
}

func (s *PullServicesResponseBody) SetRequestId(v string) *PullServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *PullServicesResponseBody) SetSuccess(v bool) *PullServicesResponseBody {
	s.Success = &v
	return s
}

type PullServicesResponseBodyData struct {
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The alias of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The information about services.
	Services []*PullServicesResponseBodyDataServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s PullServicesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponseBodyData) GoString() string {
	return s.String()
}

func (s *PullServicesResponseBodyData) SetGroupName(v string) *PullServicesResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *PullServicesResponseBodyData) SetNamespace(v string) *PullServicesResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *PullServicesResponseBodyData) SetNamespaceShowName(v string) *PullServicesResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *PullServicesResponseBodyData) SetServices(v []*PullServicesResponseBodyDataServices) *PullServicesResponseBodyData {
	s.Services = v
	return s
}

type PullServicesResponseBodyDataServices struct {
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the service source.
	SourceId *string `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s PullServicesResponseBodyDataServices) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponseBodyDataServices) GoString() string {
	return s.String()
}

func (s *PullServicesResponseBodyDataServices) SetGroupName(v string) *PullServicesResponseBodyDataServices {
	s.GroupName = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetName(v string) *PullServicesResponseBodyDataServices {
	s.Name = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetNamespace(v string) *PullServicesResponseBodyDataServices {
	s.Namespace = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetSourceId(v string) *PullServicesResponseBodyDataServices {
	s.SourceId = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetSourceType(v string) *PullServicesResponseBodyDataServices {
	s.SourceType = &v
	return s
}

type PullServicesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PullServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PullServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponse) GoString() string {
	return s.String()
}

func (s *PullServicesResponse) SetHeaders(v map[string]*string) *PullServicesResponse {
	s.Headers = v
	return s
}

func (s *PullServicesResponse) SetStatusCode(v int32) *PullServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *PullServicesResponse) SetBody(v *PullServicesResponseBody) *PullServicesResponse {
	s.Body = v
	return s
}

type PutClusterHealthCheckTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s PutClusterHealthCheckTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s PutClusterHealthCheckTaskRequest) GoString() string {
	return s.String()
}

func (s *PutClusterHealthCheckTaskRequest) SetAcceptLanguage(v string) *PutClusterHealthCheckTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *PutClusterHealthCheckTaskRequest) SetInstanceId(v string) *PutClusterHealthCheckTaskRequest {
	s.InstanceId = &v
	return s
}

type PutClusterHealthCheckTaskResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PutClusterHealthCheckTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PutClusterHealthCheckTaskResponseBody) GoString() string {
	return s.String()
}

func (s *PutClusterHealthCheckTaskResponseBody) SetCode(v int32) *PutClusterHealthCheckTaskResponseBody {
	s.Code = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetData(v bool) *PutClusterHealthCheckTaskResponseBody {
	s.Data = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetDynamicCode(v string) *PutClusterHealthCheckTaskResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetDynamicMessage(v string) *PutClusterHealthCheckTaskResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetErrorCode(v string) *PutClusterHealthCheckTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetHttpStatusCode(v int32) *PutClusterHealthCheckTaskResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetMessage(v string) *PutClusterHealthCheckTaskResponseBody {
	s.Message = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetRequestId(v string) *PutClusterHealthCheckTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetSuccess(v bool) *PutClusterHealthCheckTaskResponseBody {
	s.Success = &v
	return s
}

type PutClusterHealthCheckTaskResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PutClusterHealthCheckTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PutClusterHealthCheckTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s PutClusterHealthCheckTaskResponse) GoString() string {
	return s.String()
}

func (s *PutClusterHealthCheckTaskResponse) SetHeaders(v map[string]*string) *PutClusterHealthCheckTaskResponse {
	s.Headers = v
	return s
}

func (s *PutClusterHealthCheckTaskResponse) SetStatusCode(v int32) *PutClusterHealthCheckTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponse) SetBody(v *PutClusterHealthCheckTaskResponseBody) *PutClusterHealthCheckTaskResponse {
	s.Body = v
	return s
}

type QueryAllSwimmingLaneRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the MSE namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s QueryAllSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneRequest) SetAcceptLanguage(v string) *QueryAllSwimmingLaneRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryAllSwimmingLaneRequest) SetGroupId(v int64) *QueryAllSwimmingLaneRequest {
	s.GroupId = &v
	return s
}

func (s *QueryAllSwimmingLaneRequest) SetNamespace(v string) *QueryAllSwimmingLaneRequest {
	s.Namespace = &v
	return s
}

type QueryAllSwimmingLaneResponseBody struct {
	// The details of the data.
	Data []*QueryAllSwimmingLaneResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryAllSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneResponseBody) SetData(v []*QueryAllSwimmingLaneResponseBodyData) *QueryAllSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetErrorCode(v string) *QueryAllSwimmingLaneResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetMessage(v string) *QueryAllSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetRequestId(v string) *QueryAllSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetSuccess(v bool) *QueryAllSwimmingLaneResponseBody {
	s.Success = &v
	return s
}

type QueryAllSwimmingLaneResponseBodyData struct {
	EntryRules             []*QueryAllSwimmingLaneResponseBodyDataEntryRules `json:"EntryRules,omitempty" xml:"EntryRules,omitempty" type:"Repeated"`
	GroupId                *string                                           `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	Id                     *int64                                            `json:"Id,omitempty" xml:"Id,omitempty"`
	MessageQueueFilterSide *string                                           `json:"MessageQueueFilterSide,omitempty" xml:"MessageQueueFilterSide,omitempty"`
	MessageQueueGrayEnable *bool                                             `json:"MessageQueueGrayEnable,omitempty" xml:"MessageQueueGrayEnable,omitempty"`
	Name                   *string                                           `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace              *string                                           `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	RecordCanaryDetail     *bool                                             `json:"RecordCanaryDetail,omitempty" xml:"RecordCanaryDetail,omitempty"`
	RegionId               *string                                           `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Tag                    *string                                           `json:"Tag,omitempty" xml:"Tag,omitempty"`
	UserId                 *string                                           `json:"UserId,omitempty" xml:"UserId,omitempty"`
	EnableRules            *bool                                             `json:"enableRules,omitempty" xml:"enableRules,omitempty"`
	GmtCreate              *string                                           `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GmtModified            *string                                           `json:"gmtModified,omitempty" xml:"gmtModified,omitempty"`
}

func (s QueryAllSwimmingLaneResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetEntryRules(v []*QueryAllSwimmingLaneResponseBodyDataEntryRules) *QueryAllSwimmingLaneResponseBodyData {
	s.EntryRules = v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetGroupId(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetId(v int64) *QueryAllSwimmingLaneResponseBodyData {
	s.Id = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetMessageQueueFilterSide(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.MessageQueueFilterSide = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetMessageQueueGrayEnable(v bool) *QueryAllSwimmingLaneResponseBodyData {
	s.MessageQueueGrayEnable = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetName(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetNamespace(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetRecordCanaryDetail(v bool) *QueryAllSwimmingLaneResponseBodyData {
	s.RecordCanaryDetail = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetRegionId(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetTag(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.Tag = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetUserId(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.UserId = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetEnableRules(v bool) *QueryAllSwimmingLaneResponseBodyData {
	s.EnableRules = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetGmtCreate(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyData) SetGmtModified(v string) *QueryAllSwimmingLaneResponseBodyData {
	s.GmtModified = &v
	return s
}

type QueryAllSwimmingLaneResponseBodyDataEntryRules struct {
	Condition *string                                                    `json:"condition,omitempty" xml:"condition,omitempty"`
	Path      *string                                                    `json:"path,omitempty" xml:"path,omitempty"`
	Paths     []*string                                                  `json:"paths,omitempty" xml:"paths,omitempty" type:"Repeated"`
	RestItems []*QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems `json:"restItems,omitempty" xml:"restItems,omitempty" type:"Repeated"`
}

func (s QueryAllSwimmingLaneResponseBodyDataEntryRules) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneResponseBodyDataEntryRules) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRules) SetCondition(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRules {
	s.Condition = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRules) SetPath(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRules {
	s.Path = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRules) SetPaths(v []*string) *QueryAllSwimmingLaneResponseBodyDataEntryRules {
	s.Paths = v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRules) SetRestItems(v []*QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) *QueryAllSwimmingLaneResponseBodyDataEntryRules {
	s.RestItems = v
	return s
}

type QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems struct {
	Cond      *string   `json:"cond,omitempty" xml:"cond,omitempty"`
	Datum     *string   `json:"datum,omitempty" xml:"datum,omitempty"`
	Divisor   *int32    `json:"divisor,omitempty" xml:"divisor,omitempty"`
	Name      *string   `json:"name,omitempty" xml:"name,omitempty"`
	NameList  []*string `json:"nameList,omitempty" xml:"nameList,omitempty" type:"Repeated"`
	Operator  *string   `json:"operator,omitempty" xml:"operator,omitempty"`
	Rate      *int32    `json:"rate,omitempty" xml:"rate,omitempty"`
	Remainder *int32    `json:"remainder,omitempty" xml:"remainder,omitempty"`
	Type      *string   `json:"type,omitempty" xml:"type,omitempty"`
	Value     *string   `json:"value,omitempty" xml:"value,omitempty"`
}

func (s QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetCond(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Cond = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetDatum(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Datum = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetDivisor(v int32) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Divisor = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetName(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Name = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetNameList(v []*string) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.NameList = v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetOperator(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Operator = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetRate(v int32) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Rate = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetRemainder(v int32) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Remainder = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetType(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Type = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems) SetValue(v string) *QueryAllSwimmingLaneResponseBodyDataEntryRulesRestItems {
	s.Value = &v
	return s
}

type QueryAllSwimmingLaneResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryAllSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryAllSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneResponse) SetHeaders(v map[string]*string) *QueryAllSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *QueryAllSwimmingLaneResponse) SetStatusCode(v int32) *QueryAllSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryAllSwimmingLaneResponse) SetBody(v *QueryAllSwimmingLaneResponseBody) *QueryAllSwimmingLaneResponse {
	s.Body = v
	return s
}

type QueryAllSwimmingLaneGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the Microservices Engine (MSE) namespace that you want to query.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s QueryAllSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneGroupRequest) SetAcceptLanguage(v string) *QueryAllSwimmingLaneGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupRequest) SetNamespace(v string) *QueryAllSwimmingLaneGroupRequest {
	s.Namespace = &v
	return s
}

type QueryAllSwimmingLaneGroupResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*QueryAllSwimmingLaneGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryAllSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetCode(v int32) *QueryAllSwimmingLaneGroupResponseBody {
	s.Code = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetData(v []*QueryAllSwimmingLaneGroupResponseBodyData) *QueryAllSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetDynamicMessage(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetErrorCode(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetHttpStatusCode(v int32) *QueryAllSwimmingLaneGroupResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetMessage(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetRequestId(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetSuccess(v bool) *QueryAllSwimmingLaneGroupResponseBody {
	s.Success = &v
	return s
}

type QueryAllSwimmingLaneGroupResponseBodyData struct {
	AppIds                 *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	EntryApp               *string `json:"EntryApp,omitempty" xml:"EntryApp,omitempty"`
	Id                     *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	MessageQueueFilterSide *string `json:"MessageQueueFilterSide,omitempty" xml:"MessageQueueFilterSide,omitempty"`
	MessageQueueGrayEnable *bool   `json:"MessageQueueGrayEnable,omitempty" xml:"MessageQueueGrayEnable,omitempty"`
	Name                   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace              *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	RecordCanaryDetail     *bool   `json:"RecordCanaryDetail,omitempty" xml:"RecordCanaryDetail,omitempty"`
	Region                 *string `json:"Region,omitempty" xml:"Region,omitempty"`
	UserId                 *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s QueryAllSwimmingLaneGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetAppIds(v string) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.AppIds = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetEntryApp(v string) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.EntryApp = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetId(v int64) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.Id = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetMessageQueueFilterSide(v string) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.MessageQueueFilterSide = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetMessageQueueGrayEnable(v bool) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.MessageQueueGrayEnable = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetName(v string) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetNamespace(v string) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetRecordCanaryDetail(v bool) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.RecordCanaryDetail = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetRegion(v string) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.Region = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBodyData) SetUserId(v string) *QueryAllSwimmingLaneGroupResponseBodyData {
	s.UserId = &v
	return s
}

type QueryAllSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryAllSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryAllSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *QueryAllSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponse) SetStatusCode(v int32) *QueryAllSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponse) SetBody(v *QueryAllSwimmingLaneGroupResponseBody) *QueryAllSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type QueryBusinessLocationsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QueryBusinessLocationsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsRequest) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsRequest) SetAcceptLanguage(v string) *QueryBusinessLocationsRequest {
	s.AcceptLanguage = &v
	return s
}

type QueryBusinessLocationsResponseBody struct {
	// The details of the data.
	Data []*QueryBusinessLocationsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The result of the request.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryBusinessLocationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsResponseBody) SetData(v []*QueryBusinessLocationsResponseBodyData) *QueryBusinessLocationsResponseBody {
	s.Data = v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetErrorCode(v string) *QueryBusinessLocationsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetMessage(v string) *QueryBusinessLocationsResponseBody {
	s.Message = &v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetRequestId(v string) *QueryBusinessLocationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetSuccess(v string) *QueryBusinessLocationsResponseBody {
	s.Success = &v
	return s
}

type QueryBusinessLocationsResponseBodyData struct {
	// The Chinese name of the region.
	CnName *string `json:"CnName,omitempty" xml:"CnName,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The Chinese name of the district.
	DistrictCnName *string `json:"DistrictCnName,omitempty" xml:"DistrictCnName,omitempty"`
	// The English name of the district.
	DistrictEnName *string `json:"DistrictEnName,omitempty" xml:"DistrictEnName,omitempty"`
	// The ID of the region.
	DistrictId *string `json:"DistrictId,omitempty" xml:"DistrictId,omitempty"`
	// The ordering information of the district.
	DistrictOrdering *int32 `json:"DistrictOrdering,omitempty" xml:"DistrictOrdering,omitempty"`
	// The display name of the district.
	DistrictShowName *string `json:"DistrictShowName,omitempty" xml:"DistrictShowName,omitempty"`
	// The complete description of the region.
	EnDescription *string `json:"EnDescription,omitempty" xml:"EnDescription,omitempty"`
	// The English name of the region.
	EnName *string `json:"EnName,omitempty" xml:"EnName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ordering information.
	Ordering *int32 `json:"Ordering,omitempty" xml:"Ordering,omitempty"`
	// The display name.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryBusinessLocationsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsResponseBodyData) SetCnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.CnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDescription(v string) *QueryBusinessLocationsResponseBodyData {
	s.Description = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictCnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictCnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictEnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictEnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictId(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictId = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictOrdering(v int32) *QueryBusinessLocationsResponseBodyData {
	s.DistrictOrdering = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictShowName(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictShowName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetEnDescription(v string) *QueryBusinessLocationsResponseBodyData {
	s.EnDescription = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetEnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.EnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetName(v string) *QueryBusinessLocationsResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetOrdering(v int32) *QueryBusinessLocationsResponseBodyData {
	s.Ordering = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetShowName(v string) *QueryBusinessLocationsResponseBodyData {
	s.ShowName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetType(v string) *QueryBusinessLocationsResponseBodyData {
	s.Type = &v
	return s
}

type QueryBusinessLocationsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryBusinessLocationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryBusinessLocationsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsResponse) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsResponse) SetHeaders(v map[string]*string) *QueryBusinessLocationsResponse {
	s.Headers = v
	return s
}

func (s *QueryBusinessLocationsResponse) SetStatusCode(v int32) *QueryBusinessLocationsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryBusinessLocationsResponse) SetBody(v *QueryBusinessLocationsResponseBody) *QueryBusinessLocationsResponse {
	s.Body = v
	return s
}

type QueryClusterDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to query access control lists (ACLs).
	AclSwitch *bool `json:"AclSwitch,omitempty" xml:"AclSwitch,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
}

func (s QueryClusterDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailRequest) SetAcceptLanguage(v string) *QueryClusterDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterDetailRequest) SetAclSwitch(v bool) *QueryClusterDetailRequest {
	s.AclSwitch = &v
	return s
}

func (s *QueryClusterDetailRequest) SetInstanceId(v string) *QueryClusterDetailRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterDetailRequest) SetOrderId(v string) *QueryClusterDetailRequest {
	s.OrderId = &v
	return s
}

type QueryClusterDetailResponseBody struct {
	// The details of the data.
	Data *QueryClusterDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponseBody) SetData(v *QueryClusterDetailResponseBodyData) *QueryClusterDetailResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterDetailResponseBody) SetErrorCode(v string) *QueryClusterDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterDetailResponseBody) SetMessage(v string) *QueryClusterDetailResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterDetailResponseBody) SetRequestId(v string) *QueryClusterDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterDetailResponseBody) SetSuccess(v bool) *QueryClusterDetailResponseBody {
	s.Success = &v
	return s
}

type QueryClusterDetailResponseBodyData struct {
	// The whitelist.
	AclEntryList *string `json:"AclEntryList,omitempty" xml:"AclEntryList,omitempty"`
	// The ID of the whitelist.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The application version.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The alias of the instance.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The engine specifications.
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The version of the instance.
	ClusterVersion *string `json:"ClusterVersion,omitempty" xml:"ClusterVersion,omitempty"`
	// The network connection type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	// The number of vCPUs.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The capacity of the disk. Unit: GB.
	DiskCapacity *int64 `json:"DiskCapacity,omitempty" xml:"DiskCapacity,omitempty"`
	// The type of the disk.
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The health status of the instance.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The amount of time taken to create the instance. Unit: milliseconds.
	InitCostTime *int64 `json:"InitCostTime,omitempty" xml:"InitCostTime,omitempty"`
	// The creation status of the instance.
	InitStatus *string `json:"InitStatus,omitempty" xml:"InitStatus,omitempty"`
	// The number of instance nodes.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The list of instance nodes.
	InstanceModels []*QueryClusterDetailResponseBodyDataInstanceModels `json:"InstanceModels,omitempty" xml:"InstanceModels,omitempty" type:"Repeated"`
	// The public IP address of the instance.
	InternetAddress *string `json:"InternetAddress,omitempty" xml:"InternetAddress,omitempty"`
	// The public endpoint of the instance.
	InternetDomain *string `json:"InternetDomain,omitempty" xml:"InternetDomain,omitempty"`
	// The private port number.
	InternetPort *string `json:"InternetPort,omitempty" xml:"InternetPort,omitempty"`
	// The internal IP address.
	IntranetAddress *string `json:"IntranetAddress,omitempty" xml:"IntranetAddress,omitempty"`
	// The internal endpoint of the instance.
	IntranetDomain *string `json:"IntranetDomain,omitempty" xml:"IntranetDomain,omitempty"`
	// The private port number.
	IntranetPort *string `json:"IntranetPort,omitempty" xml:"IntranetPort,omitempty"`
	// The size of the memory. Unit: GB.
	MemoryCapacity *int64 `json:"MemoryCapacity,omitempty" xml:"MemoryCapacity,omitempty"`
	// The edition of Microservices Engine (MSE).
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   `privatenet`: VPC
	// *   `pubnet`: Internet
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The version number of the original order.
	OrderClusterVersion *string `json:"OrderClusterVersion,omitempty" xml:"OrderClusterVersion,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	PayInfo *string `json:"PayInfo,omitempty" xml:"PayInfo,omitempty"`
	// The public bandwidth. Unit: Mbit/s.\
	// Valid values: 0 to 5000. The value 0 indicates no access to the Internet.
	PubNetworkFlow *string `json:"PubNetworkFlow,omitempty" xml:"PubNetworkFlow,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags that are attached to the instance.
	Tags map[string]interface{} `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s QueryClusterDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponseBodyData) SetAclEntryList(v string) *QueryClusterDetailResponseBodyData {
	s.AclEntryList = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetAclId(v string) *QueryClusterDetailResponseBodyData {
	s.AclId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetAppVersion(v string) *QueryClusterDetailResponseBodyData {
	s.AppVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetChargeType(v string) *QueryClusterDetailResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterAliasName(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterAliasName = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterName(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterSpecification(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterSpecification = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterType(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterVersion(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetConnectionType(v string) *QueryClusterDetailResponseBodyData {
	s.ConnectionType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetCpu(v int32) *QueryClusterDetailResponseBodyData {
	s.Cpu = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetCreateTime(v string) *QueryClusterDetailResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetDiskCapacity(v int64) *QueryClusterDetailResponseBodyData {
	s.DiskCapacity = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetDiskType(v string) *QueryClusterDetailResponseBodyData {
	s.DiskType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetHealthStatus(v string) *QueryClusterDetailResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInitCostTime(v int64) *QueryClusterDetailResponseBodyData {
	s.InitCostTime = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInitStatus(v string) *QueryClusterDetailResponseBodyData {
	s.InitStatus = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInstanceCount(v int32) *QueryClusterDetailResponseBodyData {
	s.InstanceCount = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInstanceId(v string) *QueryClusterDetailResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInstanceModels(v []*QueryClusterDetailResponseBodyDataInstanceModels) *QueryClusterDetailResponseBodyData {
	s.InstanceModels = v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInternetAddress(v string) *QueryClusterDetailResponseBodyData {
	s.InternetAddress = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInternetDomain(v string) *QueryClusterDetailResponseBodyData {
	s.InternetDomain = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInternetPort(v string) *QueryClusterDetailResponseBodyData {
	s.InternetPort = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetIntranetAddress(v string) *QueryClusterDetailResponseBodyData {
	s.IntranetAddress = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetIntranetDomain(v string) *QueryClusterDetailResponseBodyData {
	s.IntranetDomain = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetIntranetPort(v string) *QueryClusterDetailResponseBodyData {
	s.IntranetPort = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetMemoryCapacity(v int64) *QueryClusterDetailResponseBodyData {
	s.MemoryCapacity = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetMseVersion(v string) *QueryClusterDetailResponseBodyData {
	s.MseVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetNetType(v string) *QueryClusterDetailResponseBodyData {
	s.NetType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetOrderClusterVersion(v string) *QueryClusterDetailResponseBodyData {
	s.OrderClusterVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetPayInfo(v string) *QueryClusterDetailResponseBodyData {
	s.PayInfo = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetPubNetworkFlow(v string) *QueryClusterDetailResponseBodyData {
	s.PubNetworkFlow = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetRegionId(v string) *QueryClusterDetailResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetResourceGroupId(v string) *QueryClusterDetailResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetTags(v map[string]interface{}) *QueryClusterDetailResponseBodyData {
	s.Tags = v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetVSwitchId(v string) *QueryClusterDetailResponseBodyData {
	s.VSwitchId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetVpcId(v string) *QueryClusterDetailResponseBodyData {
	s.VpcId = &v
	return s
}

type QueryClusterDetailResponseBodyDataInstanceModels struct {
	// The timestamp when the instance was created.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// The health status of the instance.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The public IP address.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The IP address of the instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The name of the pod.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// The role.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The single-thread IP address.
	SingleTunnelVip *string `json:"SingleTunnelVip,omitempty" xml:"SingleTunnelVip,omitempty"`
	// The zone ID.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s QueryClusterDetailResponseBodyDataInstanceModels) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponseBodyDataInstanceModels) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetCreationTimestamp(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.CreationTimestamp = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetHealthStatus(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetInternetIp(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.InternetIp = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetIp(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.Ip = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetPodName(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.PodName = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetRole(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.Role = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetSingleTunnelVip(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.SingleTunnelVip = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetZone(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.Zone = &v
	return s
}

type QueryClusterDetailResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponse) SetHeaders(v map[string]*string) *QueryClusterDetailResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterDetailResponse) SetStatusCode(v int32) *QueryClusterDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterDetailResponse) SetBody(v *QueryClusterDetailResponseBody) *QueryClusterDetailResponse {
	s.Body = v
	return s
}

type QueryClusterDiskSpecificationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
}

func (s QueryClusterDiskSpecificationRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationRequest) SetAcceptLanguage(v string) *QueryClusterDiskSpecificationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterDiskSpecificationRequest) SetClusterType(v string) *QueryClusterDiskSpecificationRequest {
	s.ClusterType = &v
	return s
}

type QueryClusterDiskSpecificationResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *QueryClusterDiskSpecificationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterDiskSpecificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationResponseBody) SetCode(v int32) *QueryClusterDiskSpecificationResponseBody {
	s.Code = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetData(v *QueryClusterDiskSpecificationResponseBodyData) *QueryClusterDiskSpecificationResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetDynamicMessage(v string) *QueryClusterDiskSpecificationResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetErrorCode(v string) *QueryClusterDiskSpecificationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetHttpStatusCode(v int32) *QueryClusterDiskSpecificationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetMessage(v string) *QueryClusterDiskSpecificationResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetRequestId(v string) *QueryClusterDiskSpecificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetSuccess(v bool) *QueryClusterDiskSpecificationResponseBody {
	s.Success = &v
	return s
}

type QueryClusterDiskSpecificationResponseBodyData struct {
	// The maximum disk capacity. Unit: GB.
	Max *int32 `json:"Max,omitempty" xml:"Max,omitempty"`
	// The minimum disk capacity. Unit: GB.
	Min *int32 `json:"Min,omitempty" xml:"Min,omitempty"`
	// The step size of the disk capacity.
	Step *int32 `json:"Step,omitempty" xml:"Step,omitempty"`
}

func (s QueryClusterDiskSpecificationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationResponseBodyData) SetMax(v int32) *QueryClusterDiskSpecificationResponseBodyData {
	s.Max = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBodyData) SetMin(v int32) *QueryClusterDiskSpecificationResponseBodyData {
	s.Min = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBodyData) SetStep(v int32) *QueryClusterDiskSpecificationResponseBodyData {
	s.Step = &v
	return s
}

type QueryClusterDiskSpecificationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterDiskSpecificationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterDiskSpecificationResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationResponse) SetHeaders(v map[string]*string) *QueryClusterDiskSpecificationResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterDiskSpecificationResponse) SetStatusCode(v int32) *QueryClusterDiskSpecificationResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponse) SetBody(v *QueryClusterDiskSpecificationResponseBody) *QueryClusterDiskSpecificationResponse {
	s.Body = v
	return s
}

type QueryClusterInfoRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to query the configuration of a public IP address whitelist.
	AclSwitch *bool `json:"AclSwitch,omitempty" xml:"AclSwitch,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryClusterInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoRequest) SetAcceptLanguage(v string) *QueryClusterInfoRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterInfoRequest) SetAclSwitch(v bool) *QueryClusterInfoRequest {
	s.AclSwitch = &v
	return s
}

func (s *QueryClusterInfoRequest) SetClusterId(v string) *QueryClusterInfoRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetInstanceId(v string) *QueryClusterInfoRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetOrderId(v string) *QueryClusterInfoRequest {
	s.OrderId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetRegionId(v string) *QueryClusterInfoRequest {
	s.RegionId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetRequestPars(v string) *QueryClusterInfoRequest {
	s.RequestPars = &v
	return s
}

type QueryClusterInfoResponseBody struct {
	// The details of the data.
	Data *QueryClusterInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponseBody) SetData(v *QueryClusterInfoResponseBodyData) *QueryClusterInfoResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterInfoResponseBody) SetErrorCode(v string) *QueryClusterInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterInfoResponseBody) SetMessage(v string) *QueryClusterInfoResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterInfoResponseBody) SetRequestId(v string) *QueryClusterInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterInfoResponseBody) SetSuccess(v bool) *QueryClusterInfoResponseBody {
	s.Success = &v
	return s
}

type QueryClusterInfoResponseBodyData struct {
	// The public IP address whitelist.
	AclEntryList *string `json:"AclEntryList,omitempty" xml:"AclEntryList,omitempty"`
	// The ID of the instance in the public IP address whitelist.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The version of the instance.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The alias of the instance.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The full name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The engine specifications.
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The version of the order.
	ClusterVersion *string `json:"ClusterVersion,omitempty" xml:"ClusterVersion,omitempty"`
	// A deprecated parameter.
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	// A deprecated parameter.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// A deprecated parameter.
	DiskCapacity *int64 `json:"DiskCapacity,omitempty" xml:"DiskCapacity,omitempty"`
	// A deprecated parameter.
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The ID of the instance that is associated with the Elastic IP Address (EIP).
	EipInstanceId *string `json:"EipInstanceId,omitempty" xml:"EipInstanceId,omitempty"`
	// The time when the subscription instance expires.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The zones to which the current cluster can be distributed.
	ExpectZones []*string `json:"ExpectZones,omitempty" xml:"ExpectZones,omitempty" type:"Repeated"`
	// The status of the instance.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The time that is required to initialize the instance. Unit: milliseconds.
	InitCostTime *int64 `json:"InitCostTime,omitempty" xml:"InitCostTime,omitempty"`
	// The initial status of the instance.
	InitStatus *string `json:"InitStatus,omitempty" xml:"InitStatus,omitempty"`
	// The number of instance nodes.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The ID of the instance
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The reserved structure.
	InstanceModels []*QueryClusterInfoResponseBodyDataInstanceModels `json:"InstanceModels,omitempty" xml:"InstanceModels,omitempty" type:"Repeated"`
	// A reserved parameter.
	InternetAddress *string `json:"InternetAddress,omitempty" xml:"InternetAddress,omitempty"`
	// The public endpoint.
	InternetDomain *string `json:"InternetDomain,omitempty" xml:"InternetDomain,omitempty"`
	// The instance ports that are accessible over the Internet.
	InternetPort *string `json:"InternetPort,omitempty" xml:"InternetPort,omitempty"`
	// A reserved parameter.
	IntranetAddress *string `json:"IntranetAddress,omitempty" xml:"IntranetAddress,omitempty"`
	// The internal endpoint.
	IntranetDomain *string `json:"IntranetDomain,omitempty" xml:"IntranetDomain,omitempty"`
	// The instance ports that are accessible over an internal network.
	IntranetPort *string `json:"IntranetPort,omitempty" xml:"IntranetPort,omitempty"`
	// The O\&M time window.
	MaintenancePeriod *QueryClusterInfoResponseBodyDataMaintenancePeriod `json:"MaintenancePeriod,omitempty" xml:"MaintenancePeriod,omitempty" type:"Struct"`
	// A deprecated parameter.
	MemoryCapacity *int64 `json:"MemoryCapacity,omitempty" xml:"MemoryCapacity,omitempty"`
	// The version of the instance.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The network connection type of the instance.
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The billing method.
	PayInfo *string `json:"PayInfo,omitempty" xml:"PayInfo,omitempty"`
	// The public bandwidth. Unit: Mbit/s.\
	// Valid values: 0 to 5000. The value 0 indicates no access to the Internet.
	PubNetworkFlow *string `json:"PubNetworkFlow,omitempty" xml:"PubNetworkFlow,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the security group to which the elastic network interface (ENI) is connected.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The type of the security group to which the ENI is connected.
	SecurityGroupType *string `json:"SecurityGroupType,omitempty" xml:"SecurityGroupType,omitempty"`
	// The tag.
	Tags map[string]interface{} `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC where the instance resides.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s QueryClusterInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponseBodyData) SetAclEntryList(v string) *QueryClusterInfoResponseBodyData {
	s.AclEntryList = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetAclId(v string) *QueryClusterInfoResponseBodyData {
	s.AclId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetAppVersion(v string) *QueryClusterInfoResponseBodyData {
	s.AppVersion = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetChargeType(v string) *QueryClusterInfoResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterAliasName(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterAliasName = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterName(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterSpecification(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterSpecification = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterType(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterVersion(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterVersion = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetConnectionType(v string) *QueryClusterInfoResponseBodyData {
	s.ConnectionType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetCpu(v int32) *QueryClusterInfoResponseBodyData {
	s.Cpu = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetCreateTime(v string) *QueryClusterInfoResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetDiskCapacity(v int64) *QueryClusterInfoResponseBodyData {
	s.DiskCapacity = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetDiskType(v string) *QueryClusterInfoResponseBodyData {
	s.DiskType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetEipInstanceId(v string) *QueryClusterInfoResponseBodyData {
	s.EipInstanceId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetEndDate(v string) *QueryClusterInfoResponseBodyData {
	s.EndDate = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetExpectZones(v []*string) *QueryClusterInfoResponseBodyData {
	s.ExpectZones = v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetHealthStatus(v string) *QueryClusterInfoResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInitCostTime(v int64) *QueryClusterInfoResponseBodyData {
	s.InitCostTime = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInitStatus(v string) *QueryClusterInfoResponseBodyData {
	s.InitStatus = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInstanceCount(v int32) *QueryClusterInfoResponseBodyData {
	s.InstanceCount = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInstanceId(v string) *QueryClusterInfoResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInstanceModels(v []*QueryClusterInfoResponseBodyDataInstanceModels) *QueryClusterInfoResponseBodyData {
	s.InstanceModels = v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInternetAddress(v string) *QueryClusterInfoResponseBodyData {
	s.InternetAddress = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInternetDomain(v string) *QueryClusterInfoResponseBodyData {
	s.InternetDomain = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInternetPort(v string) *QueryClusterInfoResponseBodyData {
	s.InternetPort = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetIntranetAddress(v string) *QueryClusterInfoResponseBodyData {
	s.IntranetAddress = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetIntranetDomain(v string) *QueryClusterInfoResponseBodyData {
	s.IntranetDomain = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetIntranetPort(v string) *QueryClusterInfoResponseBodyData {
	s.IntranetPort = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetMaintenancePeriod(v *QueryClusterInfoResponseBodyDataMaintenancePeriod) *QueryClusterInfoResponseBodyData {
	s.MaintenancePeriod = v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetMemoryCapacity(v int64) *QueryClusterInfoResponseBodyData {
	s.MemoryCapacity = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetMseVersion(v string) *QueryClusterInfoResponseBodyData {
	s.MseVersion = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetNetType(v string) *QueryClusterInfoResponseBodyData {
	s.NetType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetPayInfo(v string) *QueryClusterInfoResponseBodyData {
	s.PayInfo = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetPubNetworkFlow(v string) *QueryClusterInfoResponseBodyData {
	s.PubNetworkFlow = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetRegionId(v string) *QueryClusterInfoResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetSecurityGroupId(v string) *QueryClusterInfoResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetSecurityGroupType(v string) *QueryClusterInfoResponseBodyData {
	s.SecurityGroupType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetTags(v map[string]interface{}) *QueryClusterInfoResponseBodyData {
	s.Tags = v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetVSwitchId(v string) *QueryClusterInfoResponseBodyData {
	s.VSwitchId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetVpcId(v string) *QueryClusterInfoResponseBodyData {
	s.VpcId = &v
	return s
}

type QueryClusterInfoResponseBodyDataInstanceModels struct {
	// A reserved parameter.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// A reserved parameter.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// A reserved parameter.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// A reserved parameter.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// A reserved parameter.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// A reserved parameter.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// A reserved parameter.
	SingleTunnelVip *string `json:"SingleTunnelVip,omitempty" xml:"SingleTunnelVip,omitempty"`
	// A reserved parameter.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s QueryClusterInfoResponseBodyDataInstanceModels) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponseBodyDataInstanceModels) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetCreationTimestamp(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.CreationTimestamp = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetHealthStatus(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetInternetIp(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.InternetIp = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetIp(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.Ip = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetPodName(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.PodName = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetRole(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.Role = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetSingleTunnelVip(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.SingleTunnelVip = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetZone(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.Zone = &v
	return s
}

type QueryClusterInfoResponseBodyDataMaintenancePeriod struct {
	// The start time of the O\&M time window.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The end time of the O\&M time window.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryClusterInfoResponseBodyDataMaintenancePeriod) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponseBodyDataMaintenancePeriod) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponseBodyDataMaintenancePeriod) SetEndTime(v string) *QueryClusterInfoResponseBodyDataMaintenancePeriod {
	s.EndTime = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataMaintenancePeriod) SetStartTime(v string) *QueryClusterInfoResponseBodyDataMaintenancePeriod {
	s.StartTime = &v
	return s
}

type QueryClusterInfoResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponse) SetHeaders(v map[string]*string) *QueryClusterInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterInfoResponse) SetStatusCode(v int32) *QueryClusterInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterInfoResponse) SetBody(v *QueryClusterInfoResponseBody) *QueryClusterInfoResponse {
	s.Body = v
	return s
}

type QueryClusterSpecificationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The network type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectType *string `json:"ConnectType,omitempty" xml:"ConnectType,omitempty"`
	// The edition of the MSE instance that you want to purchase.
	//
	// *   mse_pro: Professional Edition
	// *   mse_dev: Developer Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
}

func (s QueryClusterSpecificationRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationRequest) SetAcceptLanguage(v string) *QueryClusterSpecificationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterSpecificationRequest) SetConnectType(v string) *QueryClusterSpecificationRequest {
	s.ConnectType = &v
	return s
}

func (s *QueryClusterSpecificationRequest) SetMseVersion(v string) *QueryClusterSpecificationRequest {
	s.MseVersion = &v
	return s
}

type QueryClusterSpecificationResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*QueryClusterSpecificationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterSpecificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationResponseBody) SetCode(v int32) *QueryClusterSpecificationResponseBody {
	s.Code = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetData(v []*QueryClusterSpecificationResponseBodyData) *QueryClusterSpecificationResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetErrorCode(v string) *QueryClusterSpecificationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetHttpStatusCode(v int32) *QueryClusterSpecificationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetMessage(v string) *QueryClusterSpecificationResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetRequestId(v string) *QueryClusterSpecificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetSuccess(v bool) *QueryClusterSpecificationResponseBody {
	s.Success = &v
	return s
}

type QueryClusterSpecificationResponseBodyData struct {
	// The engine specifications that can be used.
	ClusterSpecificationName *string `json:"ClusterSpecificationName,omitempty" xml:"ClusterSpecificationName,omitempty"`
	// The number of vCPUs in the specifications.
	CpuCapacity *string `json:"CpuCapacity,omitempty" xml:"CpuCapacity,omitempty"`
	// The memory size in the specifications. Unit: GB.
	MemoryCapacity *string `json:"MemoryCapacity,omitempty" xml:"MemoryCapacity,omitempty"`
}

func (s QueryClusterSpecificationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationResponseBodyData) SetClusterSpecificationName(v string) *QueryClusterSpecificationResponseBodyData {
	s.ClusterSpecificationName = &v
	return s
}

func (s *QueryClusterSpecificationResponseBodyData) SetCpuCapacity(v string) *QueryClusterSpecificationResponseBodyData {
	s.CpuCapacity = &v
	return s
}

func (s *QueryClusterSpecificationResponseBodyData) SetMemoryCapacity(v string) *QueryClusterSpecificationResponseBodyData {
	s.MemoryCapacity = &v
	return s
}

type QueryClusterSpecificationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterSpecificationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterSpecificationResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationResponse) SetHeaders(v map[string]*string) *QueryClusterSpecificationResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterSpecificationResponse) SetStatusCode(v int32) *QueryClusterSpecificationResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterSpecificationResponse) SetBody(v *QueryClusterSpecificationResponseBody) *QueryClusterSpecificationResponse {
	s.Body = v
	return s
}

type QueryConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// A reserved parameter.
	ConfigType *string `json:"ConfigType,omitempty" xml:"ConfigType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether runtime configurations are required.
	NeedRunningConf *bool `json:"NeedRunningConf,omitempty" xml:"NeedRunningConf,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigRequest) GoString() string {
	return s.String()
}

func (s *QueryConfigRequest) SetAcceptLanguage(v string) *QueryConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryConfigRequest) SetClusterId(v string) *QueryConfigRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryConfigRequest) SetConfigType(v string) *QueryConfigRequest {
	s.ConfigType = &v
	return s
}

func (s *QueryConfigRequest) SetInstanceId(v string) *QueryConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryConfigRequest) SetNeedRunningConf(v bool) *QueryConfigRequest {
	s.NeedRunningConf = &v
	return s
}

func (s *QueryConfigRequest) SetRequestPars(v string) *QueryConfigRequest {
	s.RequestPars = &v
	return s
}

type QueryConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *QueryConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponseBody) GoString() string {
	return s.String()
}

func (s *QueryConfigResponseBody) SetCode(v int32) *QueryConfigResponseBody {
	s.Code = &v
	return s
}

func (s *QueryConfigResponseBody) SetData(v *QueryConfigResponseBodyData) *QueryConfigResponseBody {
	s.Data = v
	return s
}

func (s *QueryConfigResponseBody) SetHttpStatusCode(v int32) *QueryConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryConfigResponseBody) SetMessage(v string) *QueryConfigResponseBody {
	s.Message = &v
	return s
}

func (s *QueryConfigResponseBody) SetRequestId(v string) *QueryConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryConfigResponseBody) SetSuccess(v bool) *QueryConfigResponseBody {
	s.Success = &v
	return s
}

type QueryConfigResponseBodyData struct {
	// A reserved parameter.
	AutopurgePurgeInterval *string `json:"AutopurgePurgeInterval,omitempty" xml:"AutopurgePurgeInterval,omitempty"`
	// A reserved parameter.
	AutopurgeSnapRetainCount *string `json:"AutopurgeSnapRetainCount,omitempty" xml:"AutopurgeSnapRetainCount,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Indicates whether RAM authentication of a configuration center is enabled. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	ConfigAuthEnabled *bool `json:"ConfigAuthEnabled,omitempty" xml:"ConfigAuthEnabled,omitempty"`
	// Indicates whether RAM authentication is supported by a configuration center of the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported.
	// *   `false`: not supported.
	ConfigAuthSupported *bool `json:"ConfigAuthSupported,omitempty" xml:"ConfigAuthSupported,omitempty"`
	// The maximum size of contents in a configuration. Unit: KB.
	ConfigContentLimit *int64 `json:"ConfigContentLimit,omitempty" xml:"ConfigContentLimit,omitempty"`
	// Indicates whether configuration encryption of a configuration center is enabled by the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	ConfigSecretEnabled *bool `json:"ConfigSecretEnabled,omitempty" xml:"ConfigSecretEnabled,omitempty"`
	// Indicates whether configuration encryption of a configuration center is supported by the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported.
	// *   `false`: not supported.
	ConfigSecretSupported *bool `json:"ConfigSecretSupported,omitempty" xml:"ConfigSecretSupported,omitempty"`
	// Indicates whether the Nacos open source console is enabled.
	ConsoleUIEnabled *bool `json:"ConsoleUIEnabled,omitempty" xml:"ConsoleUIEnabled,omitempty"`
	// Indicates whether access port 8761 was enabled for Eureka. If this port is disabled, applications cannot use the Eureka protocol for service registration and discovery.
	EurekaSupported *bool `json:"EurekaSupported,omitempty" xml:"EurekaSupported,omitempty"`
	// Indicates whether the time to live (TTL) configuration is enabled. This parameter is valid for ZooKeeper instances.
	ExtendedTypesEnable *bool `json:"ExtendedTypesEnable,omitempty" xml:"ExtendedTypesEnable,omitempty"`
	// The maximum connection duration of the instance. Unit: seconds. This parameter is valid for ZooKeeper instances.
	InitLimit *string `json:"InitLimit,omitempty" xml:"InitLimit,omitempty"`
	// The maximum amount of data on each node. This parameter is valid for ZooKeeper instances. Unit: bytes.
	JuteMaxbuffer *string `json:"JuteMaxbuffer,omitempty" xml:"JuteMaxbuffer,omitempty"`
	// A reserved parameter.
	JvmFlagsCustom *string `json:"JvmFlagsCustom,omitempty" xml:"JvmFlagsCustom,omitempty"`
	// Indicates whether Mesh Configuration Protocol (MCP) is enabled. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	MCPEnabled *bool `json:"MCPEnabled,omitempty" xml:"MCPEnabled,omitempty"`
	// Indicates whether MCP is supported. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported.
	// *   `false`: not supported.
	MCPSupported *bool `json:"MCPSupported,omitempty" xml:"MCPSupported,omitempty"`
	// The number of connections between a client and a server. This parameter is valid for ZooKeeper instances.\
	// If this parameter is set to 0, no limits are imposed on the number of connections.
	MaxClientCnxns *string `json:"MaxClientCnxns,omitempty" xml:"MaxClientCnxns,omitempty"`
	// The maximum timeout period. This parameter is valid for ZooKeeper instances.
	MaxSessionTimeout *string `json:"MaxSessionTimeout,omitempty" xml:"MaxSessionTimeout,omitempty"`
	// The minimum timeout period. This parameter is valid for ZooKeeper instances.
	MinSessionTimeout *string `json:"MinSessionTimeout,omitempty" xml:"MinSessionTimeout,omitempty"`
	// The runtime configuration of the Nacos instance.
	NacosRunningEnv *QueryConfigResponseBodyDataNacosRunningEnv `json:"NacosRunningEnv,omitempty" xml:"NacosRunningEnv,omitempty" type:"Struct"`
	// Indicates whether RAM authentication of a registry is enabled. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	NamingAuthEnabled *bool `json:"NamingAuthEnabled,omitempty" xml:"NamingAuthEnabled,omitempty"`
	// Indicates whether RAM authentication of services is supported by the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported.
	// *   `false`: not supported.
	NamingAuthSupported *bool `json:"NamingAuthSupported,omitempty" xml:"NamingAuthSupported,omitempty"`
	// Indicates whether service creation is supported for the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported.
	// *   `false`: not supported.
	NamingCreateServiceSupported *bool `json:"NamingCreateServiceSupported,omitempty" xml:"NamingCreateServiceSupported,omitempty"`
	// Indicates whether super permissions are enabled. This parameter is valid for ZooKeeper instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	OpenSuperAcl *bool `json:"OpenSuperAcl,omitempty" xml:"OpenSuperAcl,omitempty"`
	// The password that corresponds to the username. This parameter is valid only if OpenSuperAcl is set to true.
	PassWord *string `json:"PassWord,omitempty" xml:"PassWord,omitempty"`
	// Indicates whether the instance was restarted and new configurations have taken effect. Valid values:
	//
	// *   `true`: The restart was successful.
	// *   `false`: The restart failed.
	RestartFlag *bool `json:"RestartFlag,omitempty" xml:"RestartFlag,omitempty"`
	// The frequency for generating snapshots. This parameter is valid for ZooKeeper instances.
	SnapshotCount *string `json:"SnapshotCount,omitempty" xml:"SnapshotCount,omitempty"`
	// The connection timeout period of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
	SyncLimit *string `json:"SyncLimit,omitempty" xml:"SyncLimit,omitempty"`
	// MSE Nacos supports TLS transmission link encryption since version 2.1.2.1. Nacos clients must be upgraded to version 2.2.1 or later. After TLS is enabled, the system performance will decrease by about 10%. You must evaluate the system capacity. For more information about the relevant operations, see Nacos TLS transmission encryption.
	TLSEnabled *bool `json:"TLSEnabled,omitempty" xml:"TLSEnabled,omitempty"`
	// The time unit of the engine. This parameter is valid for ZooKeeper instances. Default value: 2000. Unit: milliseconds.
	TickTime *string `json:"TickTime,omitempty" xml:"TickTime,omitempty"`
	// The username of the user. This parameter is valid only if OpenSuperAcl is set to true.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s QueryConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryConfigResponseBodyData) SetAutopurgePurgeInterval(v string) *QueryConfigResponseBodyData {
	s.AutopurgePurgeInterval = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetAutopurgeSnapRetainCount(v string) *QueryConfigResponseBodyData {
	s.AutopurgeSnapRetainCount = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetClusterName(v string) *QueryConfigResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigAuthEnabled(v bool) *QueryConfigResponseBodyData {
	s.ConfigAuthEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigAuthSupported(v bool) *QueryConfigResponseBodyData {
	s.ConfigAuthSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigContentLimit(v int64) *QueryConfigResponseBodyData {
	s.ConfigContentLimit = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigSecretEnabled(v bool) *QueryConfigResponseBodyData {
	s.ConfigSecretEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigSecretSupported(v bool) *QueryConfigResponseBodyData {
	s.ConfigSecretSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConsoleUIEnabled(v bool) *QueryConfigResponseBodyData {
	s.ConsoleUIEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetEurekaSupported(v bool) *QueryConfigResponseBodyData {
	s.EurekaSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetExtendedTypesEnable(v bool) *QueryConfigResponseBodyData {
	s.ExtendedTypesEnable = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetInitLimit(v string) *QueryConfigResponseBodyData {
	s.InitLimit = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetJuteMaxbuffer(v string) *QueryConfigResponseBodyData {
	s.JuteMaxbuffer = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetJvmFlagsCustom(v string) *QueryConfigResponseBodyData {
	s.JvmFlagsCustom = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMCPEnabled(v bool) *QueryConfigResponseBodyData {
	s.MCPEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMCPSupported(v bool) *QueryConfigResponseBodyData {
	s.MCPSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMaxClientCnxns(v string) *QueryConfigResponseBodyData {
	s.MaxClientCnxns = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMaxSessionTimeout(v string) *QueryConfigResponseBodyData {
	s.MaxSessionTimeout = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMinSessionTimeout(v string) *QueryConfigResponseBodyData {
	s.MinSessionTimeout = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetNacosRunningEnv(v *QueryConfigResponseBodyDataNacosRunningEnv) *QueryConfigResponseBodyData {
	s.NacosRunningEnv = v
	return s
}

func (s *QueryConfigResponseBodyData) SetNamingAuthEnabled(v bool) *QueryConfigResponseBodyData {
	s.NamingAuthEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetNamingAuthSupported(v bool) *QueryConfigResponseBodyData {
	s.NamingAuthSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetNamingCreateServiceSupported(v bool) *QueryConfigResponseBodyData {
	s.NamingCreateServiceSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetOpenSuperAcl(v bool) *QueryConfigResponseBodyData {
	s.OpenSuperAcl = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetPassWord(v string) *QueryConfigResponseBodyData {
	s.PassWord = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetRestartFlag(v bool) *QueryConfigResponseBodyData {
	s.RestartFlag = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetSnapshotCount(v string) *QueryConfigResponseBodyData {
	s.SnapshotCount = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetSyncLimit(v string) *QueryConfigResponseBodyData {
	s.SyncLimit = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetTLSEnabled(v bool) *QueryConfigResponseBodyData {
	s.TLSEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetTickTime(v string) *QueryConfigResponseBodyData {
	s.TickTime = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetUserName(v string) *QueryConfigResponseBodyData {
	s.UserName = &v
	return s
}

type QueryConfigResponseBodyDataNacosRunningEnv struct {
	// Indicates whether empty list protection is enabled.
	EmptyProtect *bool `json:"emptyProtect,omitempty" xml:"emptyProtect,omitempty"`
}

func (s QueryConfigResponseBodyDataNacosRunningEnv) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponseBodyDataNacosRunningEnv) GoString() string {
	return s.String()
}

func (s *QueryConfigResponseBodyDataNacosRunningEnv) SetEmptyProtect(v bool) *QueryConfigResponseBodyDataNacosRunningEnv {
	s.EmptyProtect = &v
	return s
}

type QueryConfigResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponse) GoString() string {
	return s.String()
}

func (s *QueryConfigResponse) SetHeaders(v map[string]*string) *QueryConfigResponse {
	s.Headers = v
	return s
}

func (s *QueryConfigResponse) SetStatusCode(v int32) *QueryConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryConfigResponse) SetBody(v *QueryConfigResponseBody) *QueryConfigResponse {
	s.Body = v
	return s
}

type QueryGatewayRegionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QueryGatewayRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayRegionRequest) GoString() string {
	return s.String()
}

func (s *QueryGatewayRegionRequest) SetAcceptLanguage(v string) *QueryGatewayRegionRequest {
	s.AcceptLanguage = &v
	return s
}

type QueryGatewayRegionResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*string `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryGatewayRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayRegionResponseBody) GoString() string {
	return s.String()
}

func (s *QueryGatewayRegionResponseBody) SetCode(v int32) *QueryGatewayRegionResponseBody {
	s.Code = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetData(v []*string) *QueryGatewayRegionResponseBody {
	s.Data = v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetHttpStatusCode(v int32) *QueryGatewayRegionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetMessage(v string) *QueryGatewayRegionResponseBody {
	s.Message = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetRequestId(v string) *QueryGatewayRegionResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetSuccess(v bool) *QueryGatewayRegionResponseBody {
	s.Success = &v
	return s
}

type QueryGatewayRegionResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryGatewayRegionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryGatewayRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayRegionResponse) GoString() string {
	return s.String()
}

func (s *QueryGatewayRegionResponse) SetHeaders(v map[string]*string) *QueryGatewayRegionResponse {
	s.Headers = v
	return s
}

func (s *QueryGatewayRegionResponse) SetStatusCode(v int32) *QueryGatewayRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryGatewayRegionResponse) SetBody(v *QueryGatewayRegionResponseBody) *QueryGatewayRegionResponse {
	s.Body = v
	return s
}

type QueryGatewayTypeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QueryGatewayTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayTypeRequest) GoString() string {
	return s.String()
}

func (s *QueryGatewayTypeRequest) SetAcceptLanguage(v string) *QueryGatewayTypeRequest {
	s.AcceptLanguage = &v
	return s
}

type QueryGatewayTypeResponseBody struct {
	// The status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the gateway type. The data type of this parameter is List.
	Data []*string `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned. If the request is successful, a success message is returned. If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryGatewayTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayTypeResponseBody) GoString() string {
	return s.String()
}

func (s *QueryGatewayTypeResponseBody) SetCode(v int32) *QueryGatewayTypeResponseBody {
	s.Code = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetData(v []*string) *QueryGatewayTypeResponseBody {
	s.Data = v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetHttpStatusCode(v int32) *QueryGatewayTypeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetMessage(v string) *QueryGatewayTypeResponseBody {
	s.Message = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetRequestId(v string) *QueryGatewayTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetSuccess(v bool) *QueryGatewayTypeResponseBody {
	s.Success = &v
	return s
}

type QueryGatewayTypeResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryGatewayTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryGatewayTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayTypeResponse) GoString() string {
	return s.String()
}

func (s *QueryGatewayTypeResponse) SetHeaders(v map[string]*string) *QueryGatewayTypeResponse {
	s.Headers = v
	return s
}

func (s *QueryGatewayTypeResponse) SetStatusCode(v int32) *QueryGatewayTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryGatewayTypeResponse) SetBody(v *QueryGatewayTypeResponseBody) *QueryGatewayTypeResponse {
	s.Body = v
	return s
}

type QueryGovernanceKubernetesClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the Kubernetes cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryGovernanceKubernetesClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterRequest) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterRequest) SetAcceptLanguage(v string) *QueryGovernanceKubernetesClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetClusterId(v string) *QueryGovernanceKubernetesClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetClusterName(v string) *QueryGovernanceKubernetesClusterRequest {
	s.ClusterName = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetPageNumber(v int32) *QueryGovernanceKubernetesClusterRequest {
	s.PageNumber = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetPageSize(v int32) *QueryGovernanceKubernetesClusterRequest {
	s.PageSize = &v
	return s
}

type QueryGovernanceKubernetesClusterResponseBody struct {
	// The data returned.
	Data *QueryGovernanceKubernetesClusterResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryGovernanceKubernetesClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponseBody) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetData(v *QueryGovernanceKubernetesClusterResponseBodyData) *QueryGovernanceKubernetesClusterResponseBody {
	s.Data = v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetMessage(v string) *QueryGovernanceKubernetesClusterResponseBody {
	s.Message = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetRequestId(v string) *QueryGovernanceKubernetesClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetSuccess(v bool) *QueryGovernanceKubernetesClusterResponseBody {
	s.Success = &v
	return s
}

type QueryGovernanceKubernetesClusterResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The details of the data.
	Result []*QueryGovernanceKubernetesClusterResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of clusters.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s QueryGovernanceKubernetesClusterResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetPageNumber(v int32) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetPageSize(v int32) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetResult(v []*QueryGovernanceKubernetesClusterResponseBodyDataResult) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.Result = v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetTotalSize(v int32) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.TotalSize = &v
	return s
}

type QueryGovernanceKubernetesClusterResponseBodyDataResult struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The version of the cluster.
	K8sVersion *string `json:"K8sVersion,omitempty" xml:"K8sVersion,omitempty"`
	// The information about the namespace.
	NamespaceInfos *string `json:"NamespaceInfos,omitempty" xml:"NamespaceInfos,omitempty"`
	// The time when the pilot component was started.
	PilotStartTime *string `json:"PilotStartTime,omitempty" xml:"PilotStartTime,omitempty"`
	// The region where the cluster resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s QueryGovernanceKubernetesClusterResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetClusterId(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.ClusterId = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetClusterName(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.ClusterName = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetK8sVersion(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.K8sVersion = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetNamespaceInfos(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.NamespaceInfos = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetPilotStartTime(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.PilotStartTime = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetRegion(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.Region = &v
	return s
}

type QueryGovernanceKubernetesClusterResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryGovernanceKubernetesClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryGovernanceKubernetesClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponse) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponse) SetHeaders(v map[string]*string) *QueryGovernanceKubernetesClusterResponse {
	s.Headers = v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponse) SetStatusCode(v int32) *QueryGovernanceKubernetesClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponse) SetBody(v *QueryGovernanceKubernetesClusterResponseBody) *QueryGovernanceKubernetesClusterResponse {
	s.Body = v
	return s
}

type QueryInstancesInfoRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the region where the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryInstancesInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoRequest) SetAcceptLanguage(v string) *QueryInstancesInfoRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetClusterId(v string) *QueryInstancesInfoRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetInstanceId(v string) *QueryInstancesInfoRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetOrderId(v string) *QueryInstancesInfoRequest {
	s.OrderId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetRegionId(v string) *QueryInstancesInfoRequest {
	s.RegionId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetRequestPars(v string) *QueryInstancesInfoRequest {
	s.RequestPars = &v
	return s
}

type QueryInstancesInfoResponseBody struct {
	// The details of the data.
	Data []*QueryInstancesInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message that is returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryInstancesInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoResponseBody) SetData(v []*QueryInstancesInfoResponseBodyData) *QueryInstancesInfoResponseBody {
	s.Data = v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetErrorCode(v string) *QueryInstancesInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetHttpCode(v string) *QueryInstancesInfoResponseBody {
	s.HttpCode = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetMessage(v string) *QueryInstancesInfoResponseBody {
	s.Message = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetRequestId(v string) *QueryInstancesInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetSuccess(v bool) *QueryInstancesInfoResponseBody {
	s.Success = &v
	return s
}

type QueryInstancesInfoResponseBodyData struct {
	// The enabled port.
	ClientPort *string `json:"ClientPort,omitempty" xml:"ClientPort,omitempty"`
	// The creation time.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// A reserved parameter.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The public IP address.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The IP address of the pod.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The pod name.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// A reserved parameter.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The internal IP address.
	SingleTunnelVip *string `json:"SingleTunnelVip,omitempty" xml:"SingleTunnelVip,omitempty"`
	// The zone ID.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
	// Indicates whether all pods in the cluster are distributed in the specified zones.
	ZoneDistributed *bool `json:"ZoneDistributed,omitempty" xml:"ZoneDistributed,omitempty"`
}

func (s QueryInstancesInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoResponseBodyData) SetClientPort(v string) *QueryInstancesInfoResponseBodyData {
	s.ClientPort = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetCreationTimestamp(v string) *QueryInstancesInfoResponseBodyData {
	s.CreationTimestamp = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetHealthStatus(v string) *QueryInstancesInfoResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetInternetIp(v string) *QueryInstancesInfoResponseBodyData {
	s.InternetIp = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetIp(v string) *QueryInstancesInfoResponseBodyData {
	s.Ip = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetPodName(v string) *QueryInstancesInfoResponseBodyData {
	s.PodName = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetRole(v string) *QueryInstancesInfoResponseBodyData {
	s.Role = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetSingleTunnelVip(v string) *QueryInstancesInfoResponseBodyData {
	s.SingleTunnelVip = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetZone(v string) *QueryInstancesInfoResponseBodyData {
	s.Zone = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetZoneDistributed(v bool) *QueryInstancesInfoResponseBodyData {
	s.ZoneDistributed = &v
	return s
}

type QueryInstancesInfoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryInstancesInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryInstancesInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoResponse) SetHeaders(v map[string]*string) *QueryInstancesInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryInstancesInfoResponse) SetStatusCode(v int32) *QueryInstancesInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryInstancesInfoResponse) SetBody(v *QueryInstancesInfoResponseBody) *QueryInstancesInfoResponse {
	s.Body = v
	return s
}

type QueryMonitorRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The timestamp when the monitoring ends.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The metric type. The following metric types are supported:
	//
	// \[Basic system metrics]
	//
	// *   cpuUsage
	// *   memoryUsage
	// *   diskUsage
	// *   gcCount
	// *   gcTime
	//
	// \[Nacos registry]
	//
	// *   serviceCount
	// *   writeCostTime
	// *   readCostTime
	// *   TPS regCenterTps
	// *   QPS regCenterQps
	//
	// \[Nacos configuration center]
	//
	// *   publish
	// *   getConfig
	//
	// \[zookeeper]
	//
	// *   TPS zk_TpsCount
	// *   QPS zk_QpsCount
	// *   zookeeper_AvgRequestLatency
	MonitorType *string `json:"MonitorType,omitempty" xml:"MonitorType,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The timestamp when the monitoring starts.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The interval between data points. Unit: seconds.
	Step *int64 `json:"Step,omitempty" xml:"Step,omitempty"`
}

func (s QueryMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorRequest) GoString() string {
	return s.String()
}

func (s *QueryMonitorRequest) SetAcceptLanguage(v string) *QueryMonitorRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryMonitorRequest) SetEndTime(v int64) *QueryMonitorRequest {
	s.EndTime = &v
	return s
}

func (s *QueryMonitorRequest) SetInstanceId(v string) *QueryMonitorRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryMonitorRequest) SetMonitorType(v string) *QueryMonitorRequest {
	s.MonitorType = &v
	return s
}

func (s *QueryMonitorRequest) SetRequestPars(v string) *QueryMonitorRequest {
	s.RequestPars = &v
	return s
}

func (s *QueryMonitorRequest) SetStartTime(v int64) *QueryMonitorRequest {
	s.StartTime = &v
	return s
}

func (s *QueryMonitorRequest) SetStep(v int64) *QueryMonitorRequest {
	s.Step = &v
	return s
}

type QueryMonitorResponseBody struct {
	// The details of the data.
	Data []*QueryMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *QueryMonitorResponseBody) SetData(v []*QueryMonitorResponseBodyData) *QueryMonitorResponseBody {
	s.Data = v
	return s
}

func (s *QueryMonitorResponseBody) SetErrorCode(v string) *QueryMonitorResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryMonitorResponseBody) SetMessage(v string) *QueryMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *QueryMonitorResponseBody) SetRequestId(v string) *QueryMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryMonitorResponseBody) SetSuccess(v bool) *QueryMonitorResponseBody {
	s.Success = &v
	return s
}

type QueryMonitorResponseBodyData struct {
	// The prefix of the name.
	ClusterNamePrefix *string `json:"clusterNamePrefix,omitempty" xml:"clusterNamePrefix,omitempty"`
	// The name of the pod.
	PodName *string `json:"podName,omitempty" xml:"podName,omitempty"`
	// The details of the data.
	Values []map[string]interface{} `json:"values,omitempty" xml:"values,omitempty" type:"Repeated"`
}

func (s QueryMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryMonitorResponseBodyData) SetClusterNamePrefix(v string) *QueryMonitorResponseBodyData {
	s.ClusterNamePrefix = &v
	return s
}

func (s *QueryMonitorResponseBodyData) SetPodName(v string) *QueryMonitorResponseBodyData {
	s.PodName = &v
	return s
}

func (s *QueryMonitorResponseBodyData) SetValues(v []map[string]interface{}) *QueryMonitorResponseBodyData {
	s.Values = v
	return s
}

type QueryMonitorResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorResponse) GoString() string {
	return s.String()
}

func (s *QueryMonitorResponse) SetHeaders(v map[string]*string) *QueryMonitorResponse {
	s.Headers = v
	return s
}

func (s *QueryMonitorResponse) SetStatusCode(v int32) *QueryMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryMonitorResponse) SetBody(v *QueryMonitorResponseBody) *QueryMonitorResponse {
	s.Body = v
	return s
}

type QueryNamespaceRequest struct {
	// The language of the response. Valid values: zh and en. Default value: zh. The value zh which indicates Chinese, and the value en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Region         *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s QueryNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryNamespaceRequest) GoString() string {
	return s.String()
}

func (s *QueryNamespaceRequest) SetAcceptLanguage(v string) *QueryNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryNamespaceRequest) SetName(v string) *QueryNamespaceRequest {
	s.Name = &v
	return s
}

func (s *QueryNamespaceRequest) SetRegion(v string) *QueryNamespaceRequest {
	s.Region = &v
	return s
}

type QueryNamespaceResponseBody struct {
	// The data returned.
	Data []*QueryNamespaceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *QueryNamespaceResponseBody) SetData(v []*QueryNamespaceResponseBodyData) *QueryNamespaceResponseBody {
	s.Data = v
	return s
}

func (s *QueryNamespaceResponseBody) SetErrorCode(v string) *QueryNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryNamespaceResponseBody) SetMessage(v string) *QueryNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *QueryNamespaceResponseBody) SetRequestId(v string) *QueryNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryNamespaceResponseBody) SetSuccess(v bool) *QueryNamespaceResponseBody {
	s.Success = &v
	return s
}

type QueryNamespaceResponseBodyData struct {
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region to which the namespace belongs.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s QueryNamespaceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryNamespaceResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryNamespaceResponseBodyData) SetNamespace(v string) *QueryNamespaceResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *QueryNamespaceResponseBodyData) SetRegion(v string) *QueryNamespaceResponseBodyData {
	s.Region = &v
	return s
}

type QueryNamespaceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryNamespaceResponse) GoString() string {
	return s.String()
}

func (s *QueryNamespaceResponse) SetHeaders(v map[string]*string) *QueryNamespaceResponse {
	s.Headers = v
	return s
}

func (s *QueryNamespaceResponse) SetStatusCode(v int32) *QueryNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryNamespaceResponse) SetBody(v *QueryNamespaceResponseBody) *QueryNamespaceResponse {
	s.Body = v
	return s
}

type QuerySlbSpecRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QuerySlbSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecRequest) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecRequest) SetAcceptLanguage(v string) *QuerySlbSpecRequest {
	s.AcceptLanguage = &v
	return s
}

type QuerySlbSpecResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*QuerySlbSpecResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned. If the request is successful, a success message is returned. If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySlbSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecResponseBody) SetCode(v int32) *QuerySlbSpecResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetData(v []*QuerySlbSpecResponseBodyData) *QuerySlbSpecResponseBody {
	s.Data = v
	return s
}

func (s *QuerySlbSpecResponseBody) SetHttpStatusCode(v int32) *QuerySlbSpecResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetMessage(v string) *QuerySlbSpecResponseBody {
	s.Message = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetRequestId(v string) *QuerySlbSpecResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetSuccess(v bool) *QuerySlbSpecResponseBody {
	s.Success = &v
	return s
}

type QuerySlbSpecResponseBodyData struct {
	// The ID of the returned data.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The maximum number of connections.
	MaxConnection *string `json:"MaxConnection,omitempty" xml:"MaxConnection,omitempty"`
	// The name of the instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of connections per second.
	NewConnectionPerSecond *string `json:"NewConnectionPerSecond,omitempty" xml:"NewConnectionPerSecond,omitempty"`
	// The number of queries per second (QPS).
	Qps *string `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The specification of the instance.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s QuerySlbSpecResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecResponseBodyData) SetId(v int32) *QuerySlbSpecResponseBodyData {
	s.Id = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetMaxConnection(v string) *QuerySlbSpecResponseBodyData {
	s.MaxConnection = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetName(v string) *QuerySlbSpecResponseBodyData {
	s.Name = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetNewConnectionPerSecond(v string) *QuerySlbSpecResponseBodyData {
	s.NewConnectionPerSecond = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetQps(v string) *QuerySlbSpecResponseBodyData {
	s.Qps = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetSpec(v string) *QuerySlbSpecResponseBodyData {
	s.Spec = &v
	return s
}

type QuerySlbSpecResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySlbSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySlbSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecResponse) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecResponse) SetHeaders(v map[string]*string) *QuerySlbSpecResponse {
	s.Headers = v
	return s
}

func (s *QuerySlbSpecResponse) SetStatusCode(v int32) *QuerySlbSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySlbSpecResponse) SetBody(v *QuerySlbSpecResponseBody) *QuerySlbSpecResponse {
	s.Body = v
	return s
}

type QuerySwimmingLaneByIdRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
	// The name of the Microservices Engine (MSE) namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s QuerySwimmingLaneByIdRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdRequest) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdRequest) SetAcceptLanguage(v string) *QuerySwimmingLaneByIdRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QuerySwimmingLaneByIdRequest) SetLaneId(v int64) *QuerySwimmingLaneByIdRequest {
	s.LaneId = &v
	return s
}

func (s *QuerySwimmingLaneByIdRequest) SetNamespace(v string) *QuerySwimmingLaneByIdRequest {
	s.Namespace = &v
	return s
}

type QuerySwimmingLaneByIdResponseBody struct {
	// The details of the data.
	Data *QuerySwimmingLaneByIdResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySwimmingLaneByIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdResponseBody) SetData(v *QuerySwimmingLaneByIdResponseBodyData) *QuerySwimmingLaneByIdResponseBody {
	s.Data = v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetErrorCode(v string) *QuerySwimmingLaneByIdResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetMessage(v string) *QuerySwimmingLaneByIdResponseBody {
	s.Message = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetRequestId(v string) *QuerySwimmingLaneByIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetSuccess(v bool) *QuerySwimmingLaneByIdResponseBody {
	s.Success = &v
	return s
}

type QuerySwimmingLaneByIdResponseBodyData struct {
	Enable                       *bool                                              `json:"enable,omitempty" xml:"enable,omitempty"`
	EnableRules                  *bool                                              `json:"enableRules,omitempty" xml:"enableRules,omitempty"`
	EntryRule                    *string                                            `json:"entryRule,omitempty" xml:"entryRule,omitempty"`
	EntryRules                   []*QuerySwimmingLaneByIdResponseBodyDataEntryRules `json:"entryRules,omitempty" xml:"entryRules,omitempty" type:"Repeated"`
	GatewaySwimmingLaneRouteJson *string                                            `json:"gatewaySwimmingLaneRouteJson,omitempty" xml:"gatewaySwimmingLaneRouteJson,omitempty"`
	GmtCreate                    *string                                            `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GmtModified                  *string                                            `json:"gmtModified,omitempty" xml:"gmtModified,omitempty"`
	GroupId                      *int64                                             `json:"groupId,omitempty" xml:"groupId,omitempty"`
	Id                           *int64                                             `json:"id,omitempty" xml:"id,omitempty"`
	Name                         *string                                            `json:"name,omitempty" xml:"name,omitempty"`
	RegionId                     *string                                            `json:"regionId,omitempty" xml:"regionId,omitempty"`
	Status                       *int32                                             `json:"status,omitempty" xml:"status,omitempty"`
	Tag                          *string                                            `json:"tag,omitempty" xml:"tag,omitempty"`
}

func (s QuerySwimmingLaneByIdResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetEnable(v bool) *QuerySwimmingLaneByIdResponseBodyData {
	s.Enable = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetEnableRules(v bool) *QuerySwimmingLaneByIdResponseBodyData {
	s.EnableRules = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetEntryRule(v string) *QuerySwimmingLaneByIdResponseBodyData {
	s.EntryRule = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetEntryRules(v []*QuerySwimmingLaneByIdResponseBodyDataEntryRules) *QuerySwimmingLaneByIdResponseBodyData {
	s.EntryRules = v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetGatewaySwimmingLaneRouteJson(v string) *QuerySwimmingLaneByIdResponseBodyData {
	s.GatewaySwimmingLaneRouteJson = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetGmtCreate(v string) *QuerySwimmingLaneByIdResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetGmtModified(v string) *QuerySwimmingLaneByIdResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetGroupId(v int64) *QuerySwimmingLaneByIdResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetId(v int64) *QuerySwimmingLaneByIdResponseBodyData {
	s.Id = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetName(v string) *QuerySwimmingLaneByIdResponseBodyData {
	s.Name = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetRegionId(v string) *QuerySwimmingLaneByIdResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetStatus(v int32) *QuerySwimmingLaneByIdResponseBodyData {
	s.Status = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyData) SetTag(v string) *QuerySwimmingLaneByIdResponseBodyData {
	s.Tag = &v
	return s
}

type QuerySwimmingLaneByIdResponseBodyDataEntryRules struct {
	Condition *string                                                     `json:"condition,omitempty" xml:"condition,omitempty"`
	Path      *string                                                     `json:"path,omitempty" xml:"path,omitempty"`
	Paths     []*string                                                   `json:"paths,omitempty" xml:"paths,omitempty" type:"Repeated"`
	RestItems []*QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems `json:"restItems,omitempty" xml:"restItems,omitempty" type:"Repeated"`
}

func (s QuerySwimmingLaneByIdResponseBodyDataEntryRules) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdResponseBodyDataEntryRules) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRules) SetCondition(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRules {
	s.Condition = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRules) SetPath(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRules {
	s.Path = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRules) SetPaths(v []*string) *QuerySwimmingLaneByIdResponseBodyDataEntryRules {
	s.Paths = v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRules) SetRestItems(v []*QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) *QuerySwimmingLaneByIdResponseBodyDataEntryRules {
	s.RestItems = v
	return s
}

type QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems struct {
	Cond      *string   `json:"cond,omitempty" xml:"cond,omitempty"`
	Datum     *string   `json:"datum,omitempty" xml:"datum,omitempty"`
	Divisor   *int32    `json:"divisor,omitempty" xml:"divisor,omitempty"`
	Name      *string   `json:"name,omitempty" xml:"name,omitempty"`
	NameList  []*string `json:"nameList,omitempty" xml:"nameList,omitempty" type:"Repeated"`
	Operator  *string   `json:"operator,omitempty" xml:"operator,omitempty"`
	Rate      *int32    `json:"rate,omitempty" xml:"rate,omitempty"`
	Remainder *int32    `json:"remainder,omitempty" xml:"remainder,omitempty"`
	Type      *string   `json:"type,omitempty" xml:"type,omitempty"`
	Value     *string   `json:"value,omitempty" xml:"value,omitempty"`
}

func (s QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetCond(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Cond = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetDatum(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Datum = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetDivisor(v int32) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Divisor = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetName(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Name = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetNameList(v []*string) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.NameList = v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetOperator(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Operator = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetRate(v int32) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Rate = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetRemainder(v int32) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Remainder = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetType(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Type = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems) SetValue(v string) *QuerySwimmingLaneByIdResponseBodyDataEntryRulesRestItems {
	s.Value = &v
	return s
}

type QuerySwimmingLaneByIdResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySwimmingLaneByIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySwimmingLaneByIdResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdResponse) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdResponse) SetHeaders(v map[string]*string) *QuerySwimmingLaneByIdResponse {
	s.Headers = v
	return s
}

func (s *QuerySwimmingLaneByIdResponse) SetStatusCode(v int32) *QuerySwimmingLaneByIdResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponse) SetBody(v *QuerySwimmingLaneByIdResponseBody) *QuerySwimmingLaneByIdResponse {
	s.Body = v
	return s
}

type QueryZnodeDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryZnodeDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailRequest) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailRequest) SetAcceptLanguage(v string) *QueryZnodeDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetClusterId(v string) *QueryZnodeDetailRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetInstanceId(v string) *QueryZnodeDetailRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetPath(v string) *QueryZnodeDetailRequest {
	s.Path = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetRequestPars(v string) *QueryZnodeDetailRequest {
	s.RequestPars = &v
	return s
}

type QueryZnodeDetailResponseBody struct {
	// The details of the data.
	Data *QueryZnodeDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryZnodeDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailResponseBody) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailResponseBody) SetData(v *QueryZnodeDetailResponseBodyData) *QueryZnodeDetailResponseBody {
	s.Data = v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetErrorCode(v string) *QueryZnodeDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetMessage(v string) *QueryZnodeDetailResponseBody {
	s.Message = &v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetRequestId(v string) *QueryZnodeDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetSuccess(v string) *QueryZnodeDetailResponseBody {
	s.Success = &v
	return s
}

type QueryZnodeDetailResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s QueryZnodeDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailResponseBodyData) SetData(v string) *QueryZnodeDetailResponseBodyData {
	s.Data = &v
	return s
}

func (s *QueryZnodeDetailResponseBodyData) SetDir(v bool) *QueryZnodeDetailResponseBodyData {
	s.Dir = &v
	return s
}

func (s *QueryZnodeDetailResponseBodyData) SetName(v string) *QueryZnodeDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryZnodeDetailResponseBodyData) SetPath(v string) *QueryZnodeDetailResponseBodyData {
	s.Path = &v
	return s
}

type QueryZnodeDetailResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryZnodeDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryZnodeDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailResponse) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailResponse) SetHeaders(v map[string]*string) *QueryZnodeDetailResponse {
	s.Headers = v
	return s
}

func (s *QueryZnodeDetailResponse) SetStatusCode(v int32) *QueryZnodeDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryZnodeDetailResponse) SetBody(v *QueryZnodeDetailResponseBody) *QueryZnodeDetailResponse {
	s.Body = v
	return s
}

type RemoveApplicationRequest struct {
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	AppId          *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName        *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	Namespace      *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	Region         *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s RemoveApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveApplicationRequest) GoString() string {
	return s.String()
}

func (s *RemoveApplicationRequest) SetAcceptLanguage(v string) *RemoveApplicationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *RemoveApplicationRequest) SetAppId(v string) *RemoveApplicationRequest {
	s.AppId = &v
	return s
}

func (s *RemoveApplicationRequest) SetAppName(v string) *RemoveApplicationRequest {
	s.AppName = &v
	return s
}

func (s *RemoveApplicationRequest) SetNamespace(v string) *RemoveApplicationRequest {
	s.Namespace = &v
	return s
}

func (s *RemoveApplicationRequest) SetRegion(v string) *RemoveApplicationRequest {
	s.Region = &v
	return s
}

type RemoveApplicationResponseBody struct {
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RemoveApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveApplicationResponseBody) SetData(v string) *RemoveApplicationResponseBody {
	s.Data = &v
	return s
}

func (s *RemoveApplicationResponseBody) SetErrorCode(v string) *RemoveApplicationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RemoveApplicationResponseBody) SetMessage(v string) *RemoveApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *RemoveApplicationResponseBody) SetRequestId(v string) *RemoveApplicationResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveApplicationResponseBody) SetSuccess(v bool) *RemoveApplicationResponseBody {
	s.Success = &v
	return s
}

type RemoveApplicationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveApplicationResponse) GoString() string {
	return s.String()
}

func (s *RemoveApplicationResponse) SetHeaders(v map[string]*string) *RemoveApplicationResponse {
	s.Headers = v
	return s
}

func (s *RemoveApplicationResponse) SetStatusCode(v int32) *RemoveApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveApplicationResponse) SetBody(v *RemoveApplicationResponseBody) *RemoveApplicationResponse {
	s.Body = v
	return s
}

type RemoveAuthPolicyRequest struct {
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	PolicyId       *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s RemoveAuthPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveAuthPolicyRequest) GoString() string {
	return s.String()
}

func (s *RemoveAuthPolicyRequest) SetAcceptLanguage(v string) *RemoveAuthPolicyRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *RemoveAuthPolicyRequest) SetPolicyId(v string) *RemoveAuthPolicyRequest {
	s.PolicyId = &v
	return s
}

type RemoveAuthPolicyResponseBody struct {
	Code           *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data           *string `json:"Data,omitempty" xml:"Data,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	Message        *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RemoveAuthPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveAuthPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveAuthPolicyResponseBody) SetCode(v int32) *RemoveAuthPolicyResponseBody {
	s.Code = &v
	return s
}

func (s *RemoveAuthPolicyResponseBody) SetData(v string) *RemoveAuthPolicyResponseBody {
	s.Data = &v
	return s
}

func (s *RemoveAuthPolicyResponseBody) SetHttpStatusCode(v int32) *RemoveAuthPolicyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *RemoveAuthPolicyResponseBody) SetMessage(v string) *RemoveAuthPolicyResponseBody {
	s.Message = &v
	return s
}

func (s *RemoveAuthPolicyResponseBody) SetRequestId(v string) *RemoveAuthPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveAuthPolicyResponseBody) SetSuccess(v bool) *RemoveAuthPolicyResponseBody {
	s.Success = &v
	return s
}

type RemoveAuthPolicyResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveAuthPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveAuthPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveAuthPolicyResponse) GoString() string {
	return s.String()
}

func (s *RemoveAuthPolicyResponse) SetHeaders(v map[string]*string) *RemoveAuthPolicyResponse {
	s.Headers = v
	return s
}

func (s *RemoveAuthPolicyResponse) SetStatusCode(v int32) *RemoveAuthPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveAuthPolicyResponse) SetBody(v *RemoveAuthPolicyResponseBody) *RemoveAuthPolicyResponse {
	s.Body = v
	return s
}

type RestartClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The names of pods. You can specify the names of multiple pods at a time. Separate multiple pod names with commas (,). Example: mse-a8aba010-1629719288255-reg-center-0-1,mse-a8aba010-1629719288255-reg-center-0-2.
	//
	// The specified pods must belong to the current cluster and be associated with the specified instance. Otherwise, a restart exception occurs.
	PodNameList *string `json:"PodNameList,omitempty" xml:"PodNameList,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s RestartClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartClusterRequest) GoString() string {
	return s.String()
}

func (s *RestartClusterRequest) SetAcceptLanguage(v string) *RestartClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *RestartClusterRequest) SetClusterId(v string) *RestartClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *RestartClusterRequest) SetInstanceId(v string) *RestartClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *RestartClusterRequest) SetPodNameList(v string) *RestartClusterRequest {
	s.PodNameList = &v
	return s
}

func (s *RestartClusterRequest) SetRequestPars(v string) *RestartClusterRequest {
	s.RequestPars = &v
	return s
}

type RestartClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RestartClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartClusterResponseBody) GoString() string {
	return s.String()
}

func (s *RestartClusterResponseBody) SetErrorCode(v string) *RestartClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RestartClusterResponseBody) SetMessage(v string) *RestartClusterResponseBody {
	s.Message = &v
	return s
}

func (s *RestartClusterResponseBody) SetRequestId(v string) *RestartClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartClusterResponseBody) SetSuccess(v bool) *RestartClusterResponseBody {
	s.Success = &v
	return s
}

type RestartClusterResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestartClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestartClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartClusterResponse) GoString() string {
	return s.String()
}

func (s *RestartClusterResponse) SetHeaders(v map[string]*string) *RestartClusterResponse {
	s.Headers = v
	return s
}

func (s *RestartClusterResponse) SetStatusCode(v int32) *RestartClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartClusterResponse) SetBody(v *RestartClusterResponseBody) *RestartClusterResponse {
	s.Body = v
	return s
}

type RetryClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s RetryClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s RetryClusterRequest) GoString() string {
	return s.String()
}

func (s *RetryClusterRequest) SetAcceptLanguage(v string) *RetryClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *RetryClusterRequest) SetInstanceId(v string) *RetryClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *RetryClusterRequest) SetRequestPars(v string) *RetryClusterRequest {
	s.RequestPars = &v
	return s
}

type RetryClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RetryClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RetryClusterResponseBody) GoString() string {
	return s.String()
}

func (s *RetryClusterResponseBody) SetErrorCode(v string) *RetryClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RetryClusterResponseBody) SetMessage(v string) *RetryClusterResponseBody {
	s.Message = &v
	return s
}

func (s *RetryClusterResponseBody) SetRequestId(v string) *RetryClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *RetryClusterResponseBody) SetSuccess(v bool) *RetryClusterResponseBody {
	s.Success = &v
	return s
}

type RetryClusterResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RetryClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RetryClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s RetryClusterResponse) GoString() string {
	return s.String()
}

func (s *RetryClusterResponse) SetHeaders(v map[string]*string) *RetryClusterResponse {
	s.Headers = v
	return s
}

func (s *RetryClusterResponse) SetStatusCode(v int32) *RetryClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *RetryClusterResponse) SetBody(v *RetryClusterResponseBody) *RetryClusterResponse {
	s.Body = v
	return s
}

type SelectGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the SLB instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the SLB instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SelectGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbRequest) SetAcceptLanguage(v string) *SelectGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *SelectGatewaySlbRequest) SetGatewayUniqueId(v string) *SelectGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *SelectGatewaySlbRequest) SetName(v string) *SelectGatewaySlbRequest {
	s.Name = &v
	return s
}

func (s *SelectGatewaySlbRequest) SetType(v string) *SelectGatewaySlbRequest {
	s.Type = &v
	return s
}

type SelectGatewaySlbResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*SelectGatewaySlbResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SelectGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbResponseBody) SetCode(v int32) *SelectGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetData(v []*SelectGatewaySlbResponseBodyData) *SelectGatewaySlbResponseBody {
	s.Data = v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetHttpStatusCode(v int32) *SelectGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetMessage(v string) *SelectGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetRequestId(v string) *SelectGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetSuccess(v bool) *SelectGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type SelectGatewaySlbResponseBodyData struct {
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The name of the SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
}

func (s SelectGatewaySlbResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbResponseBodyData) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbResponseBodyData) SetSlbId(v string) *SelectGatewaySlbResponseBodyData {
	s.SlbId = &v
	return s
}

func (s *SelectGatewaySlbResponseBodyData) SetSlbName(v string) *SelectGatewaySlbResponseBodyData {
	s.SlbName = &v
	return s
}

type SelectGatewaySlbResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SelectGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SelectGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbResponse) SetHeaders(v map[string]*string) *SelectGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *SelectGatewaySlbResponse) SetStatusCode(v int32) *SelectGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *SelectGatewaySlbResponse) SetBody(v *SelectGatewaySlbResponseBody) *SelectGatewaySlbResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The instance ID.
	//
	// > This parameter specifies the instance ID that is passed. Examples:
	//
	// - ResourceId.0 specifies the first instance ID that is passed.
	// - ResourceId.1 specifies the second instance ID that is passed.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resources. Valid values:
	//
	// *   CLUSTER: Microservices Engine (MSE) instance
	// *   GATEWAY: cloud-native gateway
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tags. You can specify a maximum of 20 tags.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetAcceptLanguage(v string) *TagResourcesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The tag key. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key must be 1 to 128 characters in length. The tag key cannot start with acs: or aliyun or contain [http:// or https://.](http://https://)
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetErrorCode(v string) *TagResourcesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *TagResourcesResponseBody) SetMessage(v string) *TagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *TagResourcesResponseBody) SetSuccess(v bool) *TagResourcesResponseBody {
	s.Success = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs. A maximum of 50 resource IDs can be specified.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource. Valid values:
	//
	// *   CLUSTER: MSE instance
	// *   GATEWAY: cloud-native gateway
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag keys. A maximum of 20 tag keys are supported.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAcceptLanguage(v string) *UntagResourcesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetErrorCode(v string) *UntagResourcesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UntagResourcesResponseBody) SetMessage(v string) *UntagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UntagResourcesResponseBody) SetSuccess(v bool) *UntagResourcesResponseBody {
	s.Success = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAclRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The IP addresses or CIDR blocks in the IP address whitelist.
	AclEntryList *string `json:"AclEntryList,omitempty" xml:"AclEntryList,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s UpdateAclRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclRequest) GoString() string {
	return s.String()
}

func (s *UpdateAclRequest) SetAcceptLanguage(v string) *UpdateAclRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateAclRequest) SetAclEntryList(v string) *UpdateAclRequest {
	s.AclEntryList = &v
	return s
}

func (s *UpdateAclRequest) SetInstanceId(v string) *UpdateAclRequest {
	s.InstanceId = &v
	return s
}

type UpdateAclResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAclResponseBody) SetErrorCode(v string) *UpdateAclResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateAclResponseBody) SetMessage(v string) *UpdateAclResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateAclResponseBody) SetRequestId(v string) *UpdateAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAclResponseBody) SetSuccess(v bool) *UpdateAclResponseBody {
	s.Success = &v
	return s
}

type UpdateAclResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAclResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclResponse) GoString() string {
	return s.String()
}

func (s *UpdateAclResponse) SetHeaders(v map[string]*string) *UpdateAclResponse {
	s.Headers = v
	return s
}

func (s *UpdateAclResponse) SetStatusCode(v int32) *UpdateAclResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAclResponse) SetBody(v *UpdateAclResponseBody) *UpdateAclResponse {
	s.Body = v
	return s
}

type UpdateAuthPolicyRequest struct {
	// The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese, and the value en-US indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The content of the service authentication rule.
	AuthRule *string `json:"AuthRule,omitempty" xml:"AuthRule,omitempty"`
	// Specifies whether to enable the rule.
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The rule ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the ACK cluster namespace.
	K8sNamespace *string `json:"K8sNamespace,omitempty" xml:"K8sNamespace,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol type. Valid values:
	//
	// *   **SPRING_CLOUD**
	// *   **DUBBO**
	// *   **istio**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The source for application access.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s UpdateAuthPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAuthPolicyRequest) GoString() string {
	return s.String()
}

func (s *UpdateAuthPolicyRequest) SetAcceptLanguage(v string) *UpdateAuthPolicyRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetAppId(v string) *UpdateAuthPolicyRequest {
	s.AppId = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetAuthRule(v string) *UpdateAuthPolicyRequest {
	s.AuthRule = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetEnable(v string) *UpdateAuthPolicyRequest {
	s.Enable = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetId(v string) *UpdateAuthPolicyRequest {
	s.Id = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetK8sNamespace(v string) *UpdateAuthPolicyRequest {
	s.K8sNamespace = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetName(v string) *UpdateAuthPolicyRequest {
	s.Name = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetProtocol(v string) *UpdateAuthPolicyRequest {
	s.Protocol = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetRegion(v string) *UpdateAuthPolicyRequest {
	s.Region = &v
	return s
}

func (s *UpdateAuthPolicyRequest) SetSource(v string) *UpdateAuthPolicyRequest {
	s.Source = &v
	return s
}

type UpdateAuthPolicyResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true: The request was successful. false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateAuthPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAuthPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAuthPolicyResponseBody) SetCode(v int32) *UpdateAuthPolicyResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateAuthPolicyResponseBody) SetData(v string) *UpdateAuthPolicyResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateAuthPolicyResponseBody) SetHttpStatusCode(v int32) *UpdateAuthPolicyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateAuthPolicyResponseBody) SetMessage(v string) *UpdateAuthPolicyResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateAuthPolicyResponseBody) SetRequestId(v string) *UpdateAuthPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAuthPolicyResponseBody) SetSuccess(v bool) *UpdateAuthPolicyResponseBody {
	s.Success = &v
	return s
}

type UpdateAuthPolicyResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAuthPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAuthPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAuthPolicyResponse) GoString() string {
	return s.String()
}

func (s *UpdateAuthPolicyResponse) SetHeaders(v map[string]*string) *UpdateAuthPolicyResponse {
	s.Headers = v
	return s
}

func (s *UpdateAuthPolicyResponse) SetStatusCode(v int32) *UpdateAuthPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAuthPolicyResponse) SetBody(v *UpdateAuthPolicyResponseBody) *UpdateAuthPolicyResponse {
	s.Body = v
	return s
}

type UpdateBlackWhiteListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The content of the blacklist.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the blacklist.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Specifies whether to enable the whitelist.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The description.
	Note *string `json:"Note,omitempty" xml:"Note,omitempty"`
	// The resource IDs in the JSON format.
	ResourceIdJsonList *string `json:"ResourceIdJsonList,omitempty" xml:"ResourceIdJsonList,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Specifies whether to enable the blacklist or whitelist.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the blacklist or whitelist.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateBlackWhiteListRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackWhiteListRequest) GoString() string {
	return s.String()
}

func (s *UpdateBlackWhiteListRequest) SetAcceptLanguage(v string) *UpdateBlackWhiteListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetContent(v string) *UpdateBlackWhiteListRequest {
	s.Content = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetGatewayUniqueId(v string) *UpdateBlackWhiteListRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetId(v int64) *UpdateBlackWhiteListRequest {
	s.Id = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetIsWhite(v bool) *UpdateBlackWhiteListRequest {
	s.IsWhite = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetName(v string) *UpdateBlackWhiteListRequest {
	s.Name = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetNote(v string) *UpdateBlackWhiteListRequest {
	s.Note = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetResourceIdJsonList(v string) *UpdateBlackWhiteListRequest {
	s.ResourceIdJsonList = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetResourceType(v string) *UpdateBlackWhiteListRequest {
	s.ResourceType = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetStatus(v string) *UpdateBlackWhiteListRequest {
	s.Status = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetType(v string) *UpdateBlackWhiteListRequest {
	s.Type = &v
	return s
}

type UpdateBlackWhiteListResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the record.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateBlackWhiteListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackWhiteListResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBlackWhiteListResponseBody) SetCode(v int32) *UpdateBlackWhiteListResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetData(v int64) *UpdateBlackWhiteListResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetHttpStatusCode(v int32) *UpdateBlackWhiteListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetMessage(v string) *UpdateBlackWhiteListResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetRequestId(v string) *UpdateBlackWhiteListResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetSuccess(v bool) *UpdateBlackWhiteListResponseBody {
	s.Success = &v
	return s
}

type UpdateBlackWhiteListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBlackWhiteListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBlackWhiteListResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackWhiteListResponse) GoString() string {
	return s.String()
}

func (s *UpdateBlackWhiteListResponse) SetHeaders(v map[string]*string) *UpdateBlackWhiteListResponse {
	s.Headers = v
	return s
}

func (s *UpdateBlackWhiteListResponse) SetStatusCode(v int32) *UpdateBlackWhiteListResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBlackWhiteListResponse) SetBody(v *UpdateBlackWhiteListResponseBody) *UpdateBlackWhiteListResponse {
	s.Body = v
	return s
}

type UpdateCircuitBreakerRuleRequest struct {
	// The language of the response. Valid values: zh-CN and en-US. Default value: zh-CN. The value zh-CN indicates Chinese, and the value en-US indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether to enable the rule.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The minimum number of requests that can be passed in each step after circuit breaking recovers. Default value: 1.
	HalfOpenBaseAmountPerStep *int32 `json:"HalfOpenBaseAmountPerStep,omitempty" xml:"HalfOpenBaseAmountPerStep,omitempty"`
	// The number of circuit breaking recovery steps. Default value: 1.
	HalfOpenRecoveryStepNum *int32 `json:"HalfOpenRecoveryStepNum,omitempty" xml:"HalfOpenRecoveryStepNum,omitempty"`
	// The maximum response time (RT). Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
	MaxAllowedRtMs *int32 `json:"MaxAllowedRtMs,omitempty" xml:"MaxAllowedRtMs,omitempty"`
	// The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met. Default value: 10.
	MinRequestAmount *int32 `json:"MinRequestAmount,omitempty" xml:"MinRequestAmount,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period. The value must be an integral multiple of 1,000. Default value: 10000. This value indicates 10 seconds.
	RetryTimeoutMs *int32 `json:"RetryTimeoutMs,omitempty" xml:"RetryTimeoutMs,omitempty"`
	// The rule ID.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes. The default value is 20000. This value indicates 20 seconds.
	StatIntervalMs *int32 `json:"StatIntervalMs,omitempty" xml:"StatIntervalMs,omitempty"`
	// The threshold type.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     slow call proportion
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     abnormal proportion
	//
	//     <!-- -->
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s UpdateCircuitBreakerRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCircuitBreakerRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateCircuitBreakerRuleRequest) SetAcceptLanguage(v string) *UpdateCircuitBreakerRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetAppId(v string) *UpdateCircuitBreakerRuleRequest {
	s.AppId = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetAppName(v string) *UpdateCircuitBreakerRuleRequest {
	s.AppName = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetEnable(v bool) *UpdateCircuitBreakerRuleRequest {
	s.Enable = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetHalfOpenBaseAmountPerStep(v int32) *UpdateCircuitBreakerRuleRequest {
	s.HalfOpenBaseAmountPerStep = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetHalfOpenRecoveryStepNum(v int32) *UpdateCircuitBreakerRuleRequest {
	s.HalfOpenRecoveryStepNum = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetMaxAllowedRtMs(v int32) *UpdateCircuitBreakerRuleRequest {
	s.MaxAllowedRtMs = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetMinRequestAmount(v int32) *UpdateCircuitBreakerRuleRequest {
	s.MinRequestAmount = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetNamespace(v string) *UpdateCircuitBreakerRuleRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetRetryTimeoutMs(v int32) *UpdateCircuitBreakerRuleRequest {
	s.RetryTimeoutMs = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetRuleId(v int64) *UpdateCircuitBreakerRuleRequest {
	s.RuleId = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetStatIntervalMs(v int32) *UpdateCircuitBreakerRuleRequest {
	s.StatIntervalMs = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetStrategy(v int32) *UpdateCircuitBreakerRuleRequest {
	s.Strategy = &v
	return s
}

func (s *UpdateCircuitBreakerRuleRequest) SetThreshold(v float32) *UpdateCircuitBreakerRuleRequest {
	s.Threshold = &v
	return s
}

type UpdateCircuitBreakerRuleResponseBody struct {
	// The response code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the rule.
	Data *UpdateCircuitBreakerRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The request was successful.
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The request failed.
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateCircuitBreakerRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCircuitBreakerRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCircuitBreakerRuleResponseBody) SetCode(v string) *UpdateCircuitBreakerRuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBody) SetData(v *UpdateCircuitBreakerRuleResponseBodyData) *UpdateCircuitBreakerRuleResponseBody {
	s.Data = v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBody) SetMessage(v string) *UpdateCircuitBreakerRuleResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBody) SetRequestId(v string) *UpdateCircuitBreakerRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBody) SetSuccess(v bool) *UpdateCircuitBreakerRuleResponseBody {
	s.Success = &v
	return s
}

type UpdateCircuitBreakerRuleResponseBodyData struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Indicates whether the rule is enabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The minimum number of requests that can be passed in each step after circuit breaking recovers.
	HalfOpenBaseAmountPerStep *int32 `json:"HalfOpenBaseAmountPerStep,omitempty" xml:"HalfOpenBaseAmountPerStep,omitempty"`
	// The number of circuit breaking recovery steps.
	HalfOpenRecoveryStepNum *int32 `json:"HalfOpenRecoveryStepNum,omitempty" xml:"HalfOpenRecoveryStepNum,omitempty"`
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The maximum RT. Unit: milliseconds. If the RT of a request is greater than the value of this parameter, a slow call is counted. If you set Strategy to 0, you must specify this parameter.
	MaxAllowedRtMs *int32 `json:"MaxAllowedRtMs,omitempty" xml:"MaxAllowedRtMs,omitempty"`
	// The minimum number of requests to trigger circuit breaking. If the number of requests in the current time window is less than the value of this parameter, circuit breaking is not triggered even if the circuit breaking rule is met.
	MinRequestAmount *int32 `json:"MinRequestAmount,omitempty" xml:"MinRequestAmount,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the interface to which the rule is applicable. The interface name must be the same as the name on the interface details page in the console.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The period in which circuit breaking is implemented. Unit: milliseconds. If circuit breaking is implemented on the requests for the route, the calls to all the requests for the route fail in the configured circuit breaking period.
	RetryTimeoutMs *int32 `json:"RetryTimeoutMs,omitempty" xml:"RetryTimeoutMs,omitempty"`
	// The length of the time window. Unit: milliseconds. The valid range is from 1 second to 120 minutes.
	StatIntervalMs *int32 `json:"StatIntervalMs,omitempty" xml:"StatIntervalMs,omitempty"`
	// The threshold type.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     slow call proportion
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     abnormal proportion
	//
	//     <!-- -->
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// A percentage threshold for triggering circuit breaking. Valid values: 0-1. These values represent 0% to 100%.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s UpdateCircuitBreakerRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateCircuitBreakerRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetAppId(v string) *UpdateCircuitBreakerRuleResponseBodyData {
	s.AppId = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetAppName(v string) *UpdateCircuitBreakerRuleResponseBodyData {
	s.AppName = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetEnable(v bool) *UpdateCircuitBreakerRuleResponseBodyData {
	s.Enable = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetHalfOpenBaseAmountPerStep(v int32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.HalfOpenBaseAmountPerStep = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetHalfOpenRecoveryStepNum(v int32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.HalfOpenRecoveryStepNum = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetId(v int64) *UpdateCircuitBreakerRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetMaxAllowedRtMs(v int32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.MaxAllowedRtMs = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetMinRequestAmount(v int32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.MinRequestAmount = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetNamespace(v string) *UpdateCircuitBreakerRuleResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetResource(v string) *UpdateCircuitBreakerRuleResponseBodyData {
	s.Resource = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetRetryTimeoutMs(v int32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.RetryTimeoutMs = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetStatIntervalMs(v int32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.StatIntervalMs = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetStrategy(v int32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.Strategy = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponseBodyData) SetThreshold(v float32) *UpdateCircuitBreakerRuleResponseBodyData {
	s.Threshold = &v
	return s
}

type UpdateCircuitBreakerRuleResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCircuitBreakerRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCircuitBreakerRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCircuitBreakerRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateCircuitBreakerRuleResponse) SetHeaders(v map[string]*string) *UpdateCircuitBreakerRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateCircuitBreakerRuleResponse) SetStatusCode(v int32) *UpdateCircuitBreakerRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCircuitBreakerRuleResponse) SetBody(v *UpdateCircuitBreakerRuleResponseBody) *UpdateCircuitBreakerRuleResponse {
	s.Body = v
	return s
}

type UpdateClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The alias of the instance.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The end time of the O\&M window.
	MaintenanceEndTime *string `json:"MaintenanceEndTime,omitempty" xml:"MaintenanceEndTime,omitempty"`
	// The start time of the O\&M window.
	MaintenanceStartTime *string `json:"MaintenanceStartTime,omitempty" xml:"MaintenanceStartTime,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s UpdateClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterRequest) GoString() string {
	return s.String()
}

func (s *UpdateClusterRequest) SetAcceptLanguage(v string) *UpdateClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateClusterRequest) SetClusterAliasName(v string) *UpdateClusterRequest {
	s.ClusterAliasName = &v
	return s
}

func (s *UpdateClusterRequest) SetInstanceId(v string) *UpdateClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateClusterRequest) SetMaintenanceEndTime(v string) *UpdateClusterRequest {
	s.MaintenanceEndTime = &v
	return s
}

func (s *UpdateClusterRequest) SetMaintenanceStartTime(v string) *UpdateClusterRequest {
	s.MaintenanceStartTime = &v
	return s
}

func (s *UpdateClusterRequest) SetRequestPars(v string) *UpdateClusterRequest {
	s.RequestPars = &v
	return s
}

type UpdateClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateClusterResponseBody) SetErrorCode(v string) *UpdateClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateClusterResponseBody) SetHttpStatusCode(v string) *UpdateClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateClusterResponseBody) SetMessage(v string) *UpdateClusterResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateClusterResponseBody) SetRequestId(v string) *UpdateClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateClusterResponseBody) SetSuccess(v bool) *UpdateClusterResponseBody {
	s.Success = &v
	return s
}

type UpdateClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterResponse) GoString() string {
	return s.String()
}

func (s *UpdateClusterResponse) SetHeaders(v map[string]*string) *UpdateClusterResponse {
	s.Headers = v
	return s
}

func (s *UpdateClusterResponse) SetStatusCode(v int32) *UpdateClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateClusterResponse) SetBody(v *UpdateClusterResponseBody) *UpdateClusterResponse {
	s.Body = v
	return s
}

type UpdateClusterSpecRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The destination engine specifications.
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The number of destination nodes.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The MSE version.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
}

func (s UpdateClusterSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterSpecRequest) GoString() string {
	return s.String()
}

func (s *UpdateClusterSpecRequest) SetAcceptLanguage(v string) *UpdateClusterSpecRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetClusterId(v string) *UpdateClusterSpecRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetClusterSpecification(v string) *UpdateClusterSpecRequest {
	s.ClusterSpecification = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetInstanceCount(v int32) *UpdateClusterSpecRequest {
	s.InstanceCount = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetInstanceId(v string) *UpdateClusterSpecRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetMseVersion(v string) *UpdateClusterSpecRequest {
	s.MseVersion = &v
	return s
}

type UpdateClusterSpecResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// A reserved parameter.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed. Take note of the following rules:
	//
	// *   The **ErrorCode** parameter is not returned if the request succeeds.
	// *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section in this topic.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateClusterSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterSpecResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateClusterSpecResponseBody) SetCode(v int32) *UpdateClusterSpecResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetData(v string) *UpdateClusterSpecResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetErrorCode(v string) *UpdateClusterSpecResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetHttpStatusCode(v int32) *UpdateClusterSpecResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetMessage(v string) *UpdateClusterSpecResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetRequestId(v string) *UpdateClusterSpecResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetSuccess(v bool) *UpdateClusterSpecResponseBody {
	s.Success = &v
	return s
}

type UpdateClusterSpecResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateClusterSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateClusterSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterSpecResponse) GoString() string {
	return s.String()
}

func (s *UpdateClusterSpecResponse) SetHeaders(v map[string]*string) *UpdateClusterSpecResponse {
	s.Headers = v
	return s
}

func (s *UpdateClusterSpecResponse) SetStatusCode(v int32) *UpdateClusterSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateClusterSpecResponse) SetBody(v *UpdateClusterSpecResponseBody) *UpdateClusterSpecResponse {
	s.Body = v
	return s
}

type UpdateConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// A reserved parameter.
	AutopurgePurgeInterval *string `json:"AutopurgePurgeInterval,omitempty" xml:"AutopurgePurgeInterval,omitempty"`
	// A reserved parameter.
	AutopurgeSnapRetainCount *string `json:"AutopurgeSnapRetainCount,omitempty" xml:"AutopurgeSnapRetainCount,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Specifies whether to enable Resource Access Management (RAM) authentication for a configuration center. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the ConfigAuthSupported parameter value to check whether the instance supports the RAM authentication feature.
	ConfigAuthEnabled *bool `json:"ConfigAuthEnabled,omitempty" xml:"ConfigAuthEnabled,omitempty"`
	// Specifies whether to enable configuration encryption for a configuration center. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the ConfigSecretSupported parameter value to check whether the instance supports configuration encryption.
	ConfigSecretEnabled *bool `json:"ConfigSecretEnabled,omitempty" xml:"ConfigSecretEnabled,omitempty"`
	// The format of the configuration. Supported formats include TEXT, JSON, XML, and HTML.
	ConfigType       *string `json:"ConfigType,omitempty" xml:"ConfigType,omitempty"`
	ConsoleUIEnabled *bool   `json:"ConsoleUIEnabled,omitempty" xml:"ConsoleUIEnabled,omitempty"`
	EurekaSupported  *bool   `json:"EurekaSupported,omitempty" xml:"EurekaSupported,omitempty"`
	// Specifies whether to enable the time to live (TTL) configuration. This parameter is valid for ZooKeeper instances.
	ExtendedTypesEnable *string `json:"ExtendedTypesEnable,omitempty" xml:"ExtendedTypesEnable,omitempty"`
	// The maximum connection duration of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
	InitLimit *string `json:"InitLimit,omitempty" xml:"InitLimit,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The maximum amount of data on each node. This parameter is valid for ZooKeeper instances. The default maximum data amount on each node is 1 megabyte. Unit: bytes.
	JuteMaxbuffer *string `json:"JuteMaxbuffer,omitempty" xml:"JuteMaxbuffer,omitempty"`
	// Specifies whether to enable Mesh Configuration Protocol (MCP). This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the MCPSupported parameter value to check whether the instance supports MCP.
	MCPEnabled *bool `json:"MCPEnabled,omitempty" xml:"MCPEnabled,omitempty"`
	// The number of connections between a client and a server. This parameter is valid for ZooKeeper instances.\
	// If this parameter is set to 0, no limits are imposed on the number of connections.
	MaxClientCnxns *string `json:"MaxClientCnxns,omitempty" xml:"MaxClientCnxns,omitempty"`
	// The maximum timeout period. This parameter is valid for ZooKeeper instances. Unit: seconds.
	MaxSessionTimeout *string `json:"MaxSessionTimeout,omitempty" xml:"MaxSessionTimeout,omitempty"`
	// The minimum timeout period. This parameter is valid for ZooKeeper instances. Unit: seconds.
	MinSessionTimeout *string `json:"MinSessionTimeout,omitempty" xml:"MinSessionTimeout,omitempty"`
	// Specifies whether to enable RAM authentication for a registry. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the NamingAuthSupporte parameter value to check whether the instance supports the RAM authentication feature.
	NamingAuthEnabled *bool `json:"NamingAuthEnabled,omitempty" xml:"NamingAuthEnabled,omitempty"`
	// Specifies whether to enable super permissions. This parameter is valid for ZooKeeper instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	OpenSuperAcl *string `json:"OpenSuperAcl,omitempty" xml:"OpenSuperAcl,omitempty"`
	// The password that corresponds to the username.
	//
	// > You must specify this parameter if OpenSuperAcl is set to true.
	PassWord *string `json:"PassWord,omitempty" xml:"PassWord,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The frequency for generating snapshots. This parameter is valid for ZooKeeper instances.
	SnapshotCount *string `json:"SnapshotCount,omitempty" xml:"SnapshotCount,omitempty"`
	// The connection timeout period of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
	SyncLimit  *string `json:"SyncLimit,omitempty" xml:"SyncLimit,omitempty"`
	TLSEnabled *bool   `json:"TLSEnabled,omitempty" xml:"TLSEnabled,omitempty"`
	// The time unit. This parameter is valid for ZooKeeper instances. Default value: 2000. Unit: milliseconds.
	TickTime *string `json:"TickTime,omitempty" xml:"TickTime,omitempty"`
	// The name of the user.
	//
	// > You must specify this parameter if OpenSuperAcl is set to true.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s UpdateConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigRequest) SetAcceptLanguage(v string) *UpdateConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateConfigRequest) SetAutopurgePurgeInterval(v string) *UpdateConfigRequest {
	s.AutopurgePurgeInterval = &v
	return s
}

func (s *UpdateConfigRequest) SetAutopurgeSnapRetainCount(v string) *UpdateConfigRequest {
	s.AutopurgeSnapRetainCount = &v
	return s
}

func (s *UpdateConfigRequest) SetClusterId(v string) *UpdateConfigRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateConfigRequest) SetConfigAuthEnabled(v bool) *UpdateConfigRequest {
	s.ConfigAuthEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetConfigSecretEnabled(v bool) *UpdateConfigRequest {
	s.ConfigSecretEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetConfigType(v string) *UpdateConfigRequest {
	s.ConfigType = &v
	return s
}

func (s *UpdateConfigRequest) SetConsoleUIEnabled(v bool) *UpdateConfigRequest {
	s.ConsoleUIEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetEurekaSupported(v bool) *UpdateConfigRequest {
	s.EurekaSupported = &v
	return s
}

func (s *UpdateConfigRequest) SetExtendedTypesEnable(v string) *UpdateConfigRequest {
	s.ExtendedTypesEnable = &v
	return s
}

func (s *UpdateConfigRequest) SetInitLimit(v string) *UpdateConfigRequest {
	s.InitLimit = &v
	return s
}

func (s *UpdateConfigRequest) SetInstanceId(v string) *UpdateConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateConfigRequest) SetJuteMaxbuffer(v string) *UpdateConfigRequest {
	s.JuteMaxbuffer = &v
	return s
}

func (s *UpdateConfigRequest) SetMCPEnabled(v bool) *UpdateConfigRequest {
	s.MCPEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetMaxClientCnxns(v string) *UpdateConfigRequest {
	s.MaxClientCnxns = &v
	return s
}

func (s *UpdateConfigRequest) SetMaxSessionTimeout(v string) *UpdateConfigRequest {
	s.MaxSessionTimeout = &v
	return s
}

func (s *UpdateConfigRequest) SetMinSessionTimeout(v string) *UpdateConfigRequest {
	s.MinSessionTimeout = &v
	return s
}

func (s *UpdateConfigRequest) SetNamingAuthEnabled(v bool) *UpdateConfigRequest {
	s.NamingAuthEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetOpenSuperAcl(v string) *UpdateConfigRequest {
	s.OpenSuperAcl = &v
	return s
}

func (s *UpdateConfigRequest) SetPassWord(v string) *UpdateConfigRequest {
	s.PassWord = &v
	return s
}

func (s *UpdateConfigRequest) SetRequestPars(v string) *UpdateConfigRequest {
	s.RequestPars = &v
	return s
}

func (s *UpdateConfigRequest) SetSnapshotCount(v string) *UpdateConfigRequest {
	s.SnapshotCount = &v
	return s
}

func (s *UpdateConfigRequest) SetSyncLimit(v string) *UpdateConfigRequest {
	s.SyncLimit = &v
	return s
}

func (s *UpdateConfigRequest) SetTLSEnabled(v bool) *UpdateConfigRequest {
	s.TLSEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetTickTime(v string) *UpdateConfigRequest {
	s.TickTime = &v
	return s
}

func (s *UpdateConfigRequest) SetUserName(v string) *UpdateConfigRequest {
	s.UserName = &v
	return s
}

type UpdateConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConfigResponseBody) SetCode(v int32) *UpdateConfigResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateConfigResponseBody) SetHttpStatusCode(v int32) *UpdateConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateConfigResponseBody) SetMessage(v string) *UpdateConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateConfigResponseBody) SetRequestId(v string) *UpdateConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateConfigResponseBody) SetSuccess(v bool) *UpdateConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateConfigResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateConfigResponse) SetHeaders(v map[string]*string) *UpdateConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateConfigResponse) SetStatusCode(v int32) *UpdateConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConfigResponse) SetBody(v *UpdateConfigResponseBody) *UpdateConfigResponse {
	s.Body = v
	return s
}

type UpdateEngineNamespaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The description of the cluster.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The ID of the namespace.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the cluster.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of active services.
	ServiceCount *int32 `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
}

func (s UpdateEngineNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceRequest) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceRequest) SetAcceptLanguage(v string) *UpdateEngineNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetClusterId(v string) *UpdateEngineNamespaceRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetDesc(v string) *UpdateEngineNamespaceRequest {
	s.Desc = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetId(v string) *UpdateEngineNamespaceRequest {
	s.Id = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetInstanceId(v string) *UpdateEngineNamespaceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetName(v string) *UpdateEngineNamespaceRequest {
	s.Name = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetServiceCount(v int32) *UpdateEngineNamespaceRequest {
	s.ServiceCount = &v
	return s
}

type UpdateEngineNamespaceResponseBody struct {
	// The details of the data.
	Data *UpdateEngineNamespaceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateEngineNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceResponseBody) SetData(v *UpdateEngineNamespaceResponseBodyData) *UpdateEngineNamespaceResponseBody {
	s.Data = v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetErrorCode(v string) *UpdateEngineNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetMessage(v string) *UpdateEngineNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetRequestId(v string) *UpdateEngineNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetSuccess(v bool) *UpdateEngineNamespaceResponseBody {
	s.Success = &v
	return s
}

type UpdateEngineNamespaceResponseBodyData struct {
	// The quota value.
	ConfigCount *int32 `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The display name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quota of configurations.
	Quota *int32 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   `0`: global configuration
	// *   `1`: default namespace
	// *   `2`: custom namespace
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateEngineNamespaceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceResponseBodyData) SetConfigCount(v int32) *UpdateEngineNamespaceResponseBodyData {
	s.ConfigCount = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetNamespace(v string) *UpdateEngineNamespaceResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetNamespaceDesc(v string) *UpdateEngineNamespaceResponseBodyData {
	s.NamespaceDesc = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetNamespaceShowName(v string) *UpdateEngineNamespaceResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetQuota(v int32) *UpdateEngineNamespaceResponseBodyData {
	s.Quota = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetType(v int32) *UpdateEngineNamespaceResponseBodyData {
	s.Type = &v
	return s
}

type UpdateEngineNamespaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEngineNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEngineNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceResponse) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceResponse) SetHeaders(v map[string]*string) *UpdateEngineNamespaceResponse {
	s.Headers = v
	return s
}

func (s *UpdateEngineNamespaceResponse) SetStatusCode(v int32) *UpdateEngineNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEngineNamespaceResponse) SetBody(v *UpdateEngineNamespaceResponseBody) *UpdateEngineNamespaceResponse {
	s.Body = v
	return s
}

type UpdateFlowRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The throttling effect.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     fast failure
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     in queue
	//
	//     <!-- -->
	ControlBehavior *int32 `json:"ControlBehavior,omitempty" xml:"ControlBehavior,omitempty"`
	// Specifies whether to enable the rule.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The timeout period. Unit: milliseconds. This parameter is required when the value of ControlBehavior is set to 2.
	MaxQueueingTimeMs *int32 `json:"MaxQueueingTimeMs,omitempty" xml:"MaxQueueingTimeMs,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The rule ID.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The throttling threshold.
	Threshold *int32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s UpdateFlowRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateFlowRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateFlowRuleRequest) SetAcceptLanguage(v string) *UpdateFlowRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetAppId(v string) *UpdateFlowRuleRequest {
	s.AppId = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetAppName(v string) *UpdateFlowRuleRequest {
	s.AppName = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetControlBehavior(v int32) *UpdateFlowRuleRequest {
	s.ControlBehavior = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetEnable(v bool) *UpdateFlowRuleRequest {
	s.Enable = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetMaxQueueingTimeMs(v int32) *UpdateFlowRuleRequest {
	s.MaxQueueingTimeMs = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetNamespace(v string) *UpdateFlowRuleRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetRuleId(v int64) *UpdateFlowRuleRequest {
	s.RuleId = &v
	return s
}

func (s *UpdateFlowRuleRequest) SetThreshold(v int32) *UpdateFlowRuleRequest {
	s.Threshold = &v
	return s
}

type UpdateFlowRuleResponseBody struct {
	// The response code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *UpdateFlowRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The request was successful.
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The request failed.
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateFlowRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateFlowRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateFlowRuleResponseBody) SetCode(v string) *UpdateFlowRuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateFlowRuleResponseBody) SetData(v *UpdateFlowRuleResponseBodyData) *UpdateFlowRuleResponseBody {
	s.Data = v
	return s
}

func (s *UpdateFlowRuleResponseBody) SetMessage(v string) *UpdateFlowRuleResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateFlowRuleResponseBody) SetRequestId(v string) *UpdateFlowRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateFlowRuleResponseBody) SetSuccess(v bool) *UpdateFlowRuleResponseBody {
	s.Success = &v
	return s
}

type UpdateFlowRuleResponseBodyData struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The throttling effect.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     fast failure
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     in queue
	//
	//     <!-- -->
	ControlBehavior *int32 `json:"ControlBehavior,omitempty" xml:"ControlBehavior,omitempty"`
	// Indicates whether the rule was enabled.
	//
	// Valid value:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The rule ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period for queuing when the value of ControlBehavior is set to 2. Unit: milliseconds.
	MaxQueueingTimeMs *int32 `json:"MaxQueueingTimeMs,omitempty" xml:"MaxQueueingTimeMs,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the API resource.
	Resource *string `json:"Resource,omitempty" xml:"Resource,omitempty"`
	// The throttling threshold.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s UpdateFlowRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateFlowRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateFlowRuleResponseBodyData) SetAppId(v string) *UpdateFlowRuleResponseBodyData {
	s.AppId = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetAppName(v string) *UpdateFlowRuleResponseBodyData {
	s.AppName = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetControlBehavior(v int32) *UpdateFlowRuleResponseBodyData {
	s.ControlBehavior = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetEnable(v bool) *UpdateFlowRuleResponseBodyData {
	s.Enable = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetId(v int64) *UpdateFlowRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetMaxQueueingTimeMs(v int32) *UpdateFlowRuleResponseBodyData {
	s.MaxQueueingTimeMs = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetNamespace(v string) *UpdateFlowRuleResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetResource(v string) *UpdateFlowRuleResponseBodyData {
	s.Resource = &v
	return s
}

func (s *UpdateFlowRuleResponseBodyData) SetThreshold(v float32) *UpdateFlowRuleResponseBodyData {
	s.Threshold = &v
	return s
}

type UpdateFlowRuleResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateFlowRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFlowRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateFlowRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateFlowRuleResponse) SetHeaders(v map[string]*string) *UpdateFlowRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateFlowRuleResponse) SetStatusCode(v int32) *UpdateFlowRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateFlowRuleResponse) SetBody(v *UpdateFlowRuleResponseBody) *UpdateFlowRuleResponse {
	s.Body = v
	return s
}

type UpdateGatewayAuthConsumerRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The description of the consumer.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The encryption type. Valid values:
	//
	// *   RSA
	// *   OCT
	EncodeType *string `json:"EncodeType,omitempty" xml:"EncodeType,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the consumer.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The JWT public key. The JSON format is supported.
	Jwks *string `json:"Jwks,omitempty" xml:"Jwks,omitempty"`
	// The name of the key used for JWT-based identity authentication.
	KeyName *string `json:"KeyName,omitempty" xml:"KeyName,omitempty"`
	// The value of the key used for JWT-based identity authentication.
	KeyValue *string `json:"KeyValue,omitempty" xml:"KeyValue,omitempty"`
	// The names of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenName *string `json:"TokenName,omitempty" xml:"TokenName,omitempty"`
	// Specifies whether to enable pass-through.
	TokenPass *bool `json:"TokenPass,omitempty" xml:"TokenPass,omitempty"`
	// The positions of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenPosition *string `json:"TokenPosition,omitempty" xml:"TokenPosition,omitempty"`
	// The prefixes of the parameters that are required to verify each token. By default, each token is prefixed with Bearer and stored in the Authorization header, such as `Authorization: Bearer <Content of a token>`.
	TokenPrefix *string `json:"TokenPrefix,omitempty" xml:"TokenPrefix,omitempty"`
}

func (s UpdateGatewayAuthConsumerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerRequest) SetAcceptLanguage(v string) *UpdateGatewayAuthConsumerRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetDescription(v string) *UpdateGatewayAuthConsumerRequest {
	s.Description = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetEncodeType(v string) *UpdateGatewayAuthConsumerRequest {
	s.EncodeType = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetGatewayUniqueId(v string) *UpdateGatewayAuthConsumerRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetId(v int64) *UpdateGatewayAuthConsumerRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetJwks(v string) *UpdateGatewayAuthConsumerRequest {
	s.Jwks = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetKeyName(v string) *UpdateGatewayAuthConsumerRequest {
	s.KeyName = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetKeyValue(v string) *UpdateGatewayAuthConsumerRequest {
	s.KeyValue = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetTokenName(v string) *UpdateGatewayAuthConsumerRequest {
	s.TokenName = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetTokenPass(v bool) *UpdateGatewayAuthConsumerRequest {
	s.TokenPass = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetTokenPosition(v string) *UpdateGatewayAuthConsumerRequest {
	s.TokenPosition = &v
	return s
}

func (s *UpdateGatewayAuthConsumerRequest) SetTokenPrefix(v string) *UpdateGatewayAuthConsumerRequest {
	s.TokenPrefix = &v
	return s
}

type UpdateGatewayAuthConsumerResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the consumer.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayAuthConsumerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetCode(v int32) *UpdateGatewayAuthConsumerResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetData(v int64) *UpdateGatewayAuthConsumerResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetDynamicCode(v string) *UpdateGatewayAuthConsumerResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetDynamicMessage(v string) *UpdateGatewayAuthConsumerResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetErrorCode(v string) *UpdateGatewayAuthConsumerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayAuthConsumerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetMessage(v string) *UpdateGatewayAuthConsumerResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetRequestId(v string) *UpdateGatewayAuthConsumerResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponseBody) SetSuccess(v bool) *UpdateGatewayAuthConsumerResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayAuthConsumerResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayAuthConsumerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayAuthConsumerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResponse) SetHeaders(v map[string]*string) *UpdateGatewayAuthConsumerResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayAuthConsumerResponse) SetStatusCode(v int32) *UpdateGatewayAuthConsumerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResponse) SetBody(v *UpdateGatewayAuthConsumerResponseBody) *UpdateGatewayAuthConsumerResponse {
	s.Body = v
	return s
}

type UpdateGatewayAuthConsumerResourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The gateway authentication consumer ID.
	ConsumerId *int64 `json:"ConsumerId,omitempty" xml:"ConsumerId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The gateway authentication consumer ID.
	ResourceList []*UpdateGatewayAuthConsumerResourceRequestResourceList `json:"ResourceList,omitempty" xml:"ResourceList,omitempty" type:"Repeated"`
}

func (s UpdateGatewayAuthConsumerResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceRequest) SetAcceptLanguage(v string) *UpdateGatewayAuthConsumerResourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceRequest) SetConsumerId(v int64) *UpdateGatewayAuthConsumerResourceRequest {
	s.ConsumerId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceRequest) SetGatewayUniqueId(v string) *UpdateGatewayAuthConsumerResourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceRequest) SetResourceList(v []*UpdateGatewayAuthConsumerResourceRequestResourceList) *UpdateGatewayAuthConsumerResourceRequest {
	s.ResourceList = v
	return s
}

type UpdateGatewayAuthConsumerResourceRequestResourceList struct {
	// The route ID.
	RouteId *int64 `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
	// The name of the route.
	RouteName *string `json:"RouteName,omitempty" xml:"RouteName,omitempty"`
}

func (s UpdateGatewayAuthConsumerResourceRequestResourceList) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceRequestResourceList) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceRequestResourceList) SetRouteId(v int64) *UpdateGatewayAuthConsumerResourceRequestResourceList {
	s.RouteId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceRequestResourceList) SetRouteName(v string) *UpdateGatewayAuthConsumerResourceRequestResourceList {
	s.RouteName = &v
	return s
}

type UpdateGatewayAuthConsumerResourceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The gateway authentication consumer ID.
	ConsumerId *int64 `json:"ConsumerId,omitempty" xml:"ConsumerId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The gateway authentication consumer ID.
	ResourceListShrink *string `json:"ResourceList,omitempty" xml:"ResourceList,omitempty"`
}

func (s UpdateGatewayAuthConsumerResourceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayAuthConsumerResourceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceShrinkRequest) SetConsumerId(v int64) *UpdateGatewayAuthConsumerResourceShrinkRequest {
	s.ConsumerId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayAuthConsumerResourceShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceShrinkRequest) SetResourceListShrink(v string) *UpdateGatewayAuthConsumerResourceShrinkRequest {
	s.ResourceListShrink = &v
	return s
}

type UpdateGatewayAuthConsumerResourceResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the list of the resources was updated. Valid values:
	//
	// *   true: The list of the resources was updated.
	// *   false: The list of the resources was not updated.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayAuthConsumerResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetCode(v int32) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetData(v bool) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetDynamicCode(v string) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetDynamicMessage(v string) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetErrorCode(v string) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetMessage(v string) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetRequestId(v string) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponseBody) SetSuccess(v bool) *UpdateGatewayAuthConsumerResourceResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayAuthConsumerResourceResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayAuthConsumerResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayAuthConsumerResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceResponse) SetHeaders(v map[string]*string) *UpdateGatewayAuthConsumerResourceResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponse) SetStatusCode(v int32) *UpdateGatewayAuthConsumerResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceResponse) SetBody(v *UpdateGatewayAuthConsumerResourceResponseBody) *UpdateGatewayAuthConsumerResourceResponse {
	s.Body = v
	return s
}

type UpdateGatewayAuthConsumerResourceStatusRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the consumer.
	ConsumerId *int64 `json:"ConsumerId,omitempty" xml:"ConsumerId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The list of IDs of the authorized resources that a user wants to update.
	IdList *string `json:"IdList,omitempty" xml:"IdList,omitempty"`
	// The resource authorization status. Valid values:
	//
	// *   true: enabled
	// *   false: disabled
	ResourceStatus *bool `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
}

func (s UpdateGatewayAuthConsumerResourceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceStatusRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceStatusRequest) SetAcceptLanguage(v string) *UpdateGatewayAuthConsumerResourceStatusRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusRequest) SetConsumerId(v int64) *UpdateGatewayAuthConsumerResourceStatusRequest {
	s.ConsumerId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusRequest) SetGatewayUniqueId(v string) *UpdateGatewayAuthConsumerResourceStatusRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusRequest) SetIdList(v string) *UpdateGatewayAuthConsumerResourceStatusRequest {
	s.IdList = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusRequest) SetResourceStatus(v bool) *UpdateGatewayAuthConsumerResourceStatusRequest {
	s.ResourceStatus = &v
	return s
}

type UpdateGatewayAuthConsumerResourceStatusResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the execution was successful. Valid values:
	//
	// *   true: The execution was successful.
	// *   false: The execution failed.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the `%s` variable in the `ErrMessage` parameter.
	//
	// >  If the return value of the `ErrMessage` parameter is `The Value of Input Parameter %s is not valid` and the return value of the `DynamicMessage` parameter is `DtsJobId`, the specified `DtsJobId` parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayAuthConsumerResourceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetCode(v int32) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetData(v bool) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetDynamicCode(v string) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetDynamicMessage(v string) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetErrorCode(v string) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetMessage(v string) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetRequestId(v string) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponseBody) SetSuccess(v bool) *UpdateGatewayAuthConsumerResourceStatusResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayAuthConsumerResourceStatusResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayAuthConsumerResourceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayAuthConsumerResourceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerResourceStatusResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponse) SetHeaders(v map[string]*string) *UpdateGatewayAuthConsumerResourceStatusResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponse) SetStatusCode(v int32) *UpdateGatewayAuthConsumerResourceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerResourceStatusResponse) SetBody(v *UpdateGatewayAuthConsumerResourceStatusResponseBody) *UpdateGatewayAuthConsumerResourceStatusResponse {
	s.Body = v
	return s
}

type UpdateGatewayAuthConsumerStatusRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The status of the consumer. Valid values:
	//
	// *   true: The consumer is enabled.
	// *   false: The consumer is disabled.
	ConsumerStatus *bool `json:"ConsumerStatus,omitempty" xml:"ConsumerStatus,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The consumer ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayAuthConsumerStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerStatusRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerStatusRequest) SetAcceptLanguage(v string) *UpdateGatewayAuthConsumerStatusRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusRequest) SetConsumerStatus(v bool) *UpdateGatewayAuthConsumerStatusRequest {
	s.ConsumerStatus = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusRequest) SetGatewayUniqueId(v string) *UpdateGatewayAuthConsumerStatusRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusRequest) SetId(v int64) *UpdateGatewayAuthConsumerStatusRequest {
	s.Id = &v
	return s
}

type UpdateGatewayAuthConsumerStatusResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayAuthConsumerStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerStatusResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetCode(v int32) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetData(v bool) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetDynamicCode(v string) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetDynamicMessage(v string) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetErrorCode(v string) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetMessage(v string) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetRequestId(v string) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponseBody) SetSuccess(v bool) *UpdateGatewayAuthConsumerStatusResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayAuthConsumerStatusResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayAuthConsumerStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayAuthConsumerStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayAuthConsumerStatusResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayAuthConsumerStatusResponse) SetHeaders(v map[string]*string) *UpdateGatewayAuthConsumerStatusResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponse) SetStatusCode(v int32) *UpdateGatewayAuthConsumerStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayAuthConsumerStatusResponse) SetBody(v *UpdateGatewayAuthConsumerStatusResponseBody) *UpdateGatewayAuthConsumerStatusResponse {
	s.Body = v
	return s
}

type UpdateGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to enable `HTTP/2`.
	//
	// *   `open`: `HTTP/2` is enabled.
	// *   `close`: `HTTP/2` is disabled.
	// *   `globalConfig`: Global configurations are used.
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// The ID of the domain name that you want to update.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Specifies whether to forcibly use HTTPS.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   HTTPS
	// *   HTTP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
}

func (s UpdateGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayDomainRequest) SetAcceptLanguage(v string) *UpdateGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetCertIdentifier(v string) *UpdateGatewayDomainRequest {
	s.CertIdentifier = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetGatewayUniqueId(v string) *UpdateGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetHttp2(v string) *UpdateGatewayDomainRequest {
	s.Http2 = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetId(v int64) *UpdateGatewayDomainRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetMustHttps(v bool) *UpdateGatewayDomainRequest {
	s.MustHttps = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetProtocol(v string) *UpdateGatewayDomainRequest {
	s.Protocol = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetTlsMax(v string) *UpdateGatewayDomainRequest {
	s.TlsMax = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetTlsMin(v string) *UpdateGatewayDomainRequest {
	s.TlsMin = &v
	return s
}

type UpdateGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayDomainResponseBody) SetCode(v int32) *UpdateGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetData(v int64) *UpdateGatewayDomainResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetMessage(v string) *UpdateGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetRequestId(v string) *UpdateGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetSuccess(v bool) *UpdateGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayDomainResponse) SetHeaders(v map[string]*string) *UpdateGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayDomainResponse) SetStatusCode(v int32) *UpdateGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayDomainResponse) SetBody(v *UpdateGatewayDomainResponseBody) *UpdateGatewayDomainResponse {
	s.Body = v
	return s
}

type UpdateGatewayNameRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateGatewayNameRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayNameRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayNameRequest) SetAcceptLanguage(v string) *UpdateGatewayNameRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayNameRequest) SetGatewayUniqueId(v string) *UpdateGatewayNameRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayNameRequest) SetName(v string) *UpdateGatewayNameRequest {
	s.Name = &v
	return s
}

type UpdateGatewayNameResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayNameResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayNameResponseBody) SetCode(v int32) *UpdateGatewayNameResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetData(v string) *UpdateGatewayNameResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayNameResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetMessage(v string) *UpdateGatewayNameResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetRequestId(v string) *UpdateGatewayNameResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetSuccess(v bool) *UpdateGatewayNameResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayNameResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayNameResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayNameResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayNameResponse) SetHeaders(v map[string]*string) *UpdateGatewayNameResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayNameResponse) SetStatusCode(v int32) *UpdateGatewayNameResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayNameResponse) SetBody(v *UpdateGatewayNameResponseBody) *UpdateGatewayNameResponse {
	s.Body = v
	return s
}

type UpdateGatewayOptionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The detailed configurations of the gateway.
	//
	// *   **TraceDetails**: the sampling description of Managed Service for OpenTelemetry. Content: TraceEnabled indicates whether Managed Service for OpenTelemetry is activated. Sample indicates the sampling rate of Managed Service for OpenTelemetry.
	// *   **LogConfigDetails**: the description of Simple Log Service. Content: LogEnabled indicates whether Simple Log Service is activated. ProjectName indicates the Simple Log Service project to which logs are delivered. LogStoreName indicates the name of the Logstore.
	// *   **EnableHardwareAcceleration**: indicates whether hardware acceleration is enabled.
	// *   **DisableHttp2Alpn**: indicates whether the HTTP/2 protocol is disabled.
	// *   **EnableWaf**: indicates whether Web Application Firewall (WAF) is enabled.
	GatewayOption *GatewayOption `json:"GatewayOption,omitempty" xml:"GatewayOption,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s UpdateGatewayOptionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionRequest) SetAcceptLanguage(v string) *UpdateGatewayOptionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayOptionRequest) SetGatewayId(v int64) *UpdateGatewayOptionRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayOptionRequest) SetGatewayOption(v *GatewayOption) *UpdateGatewayOptionRequest {
	s.GatewayOption = v
	return s
}

func (s *UpdateGatewayOptionRequest) SetGatewayUniqueId(v string) *UpdateGatewayOptionRequest {
	s.GatewayUniqueId = &v
	return s
}

type UpdateGatewayOptionShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The detailed configurations of the gateway.
	//
	// *   **TraceDetails**: the sampling description of Managed Service for OpenTelemetry. Content: TraceEnabled indicates whether Managed Service for OpenTelemetry is activated. Sample indicates the sampling rate of Managed Service for OpenTelemetry.
	// *   **LogConfigDetails**: the description of Simple Log Service. Content: LogEnabled indicates whether Simple Log Service is activated. ProjectName indicates the Simple Log Service project to which logs are delivered. LogStoreName indicates the name of the Logstore.
	// *   **EnableHardwareAcceleration**: indicates whether hardware acceleration is enabled.
	// *   **DisableHttp2Alpn**: indicates whether the HTTP/2 protocol is disabled.
	// *   **EnableWaf**: indicates whether Web Application Firewall (WAF) is enabled.
	GatewayOptionShrink *string `json:"GatewayOption,omitempty" xml:"GatewayOption,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s UpdateGatewayOptionShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayOptionShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayOptionShrinkRequest) SetGatewayId(v int64) *UpdateGatewayOptionShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayOptionShrinkRequest) SetGatewayOptionShrink(v string) *UpdateGatewayOptionShrinkRequest {
	s.GatewayOptionShrink = &v
	return s
}

func (s *UpdateGatewayOptionShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayOptionShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

type UpdateGatewayOptionResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *GatewayOption `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayOptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionResponseBody) SetCode(v int32) *UpdateGatewayOptionResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetData(v *GatewayOption) *UpdateGatewayOptionResponseBody {
	s.Data = v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayOptionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetMessage(v string) *UpdateGatewayOptionResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetRequestId(v string) *UpdateGatewayOptionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetSuccess(v bool) *UpdateGatewayOptionResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayOptionResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayOptionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayOptionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionResponse) SetHeaders(v map[string]*string) *UpdateGatewayOptionResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayOptionResponse) SetStatusCode(v int32) *UpdateGatewayOptionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayOptionResponse) SetBody(v *UpdateGatewayOptionResponseBody) *UpdateGatewayOptionResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponseJSON *UpdateGatewayRouteRequestDirectResponseJSON `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty" type:"Struct"`
	// The associated domain name.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to activate Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServices []*UpdateGatewayRouteRequestFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The route matching conditions.
	Predicates *UpdateGatewayRouteRequestPredicates `json:"Predicates,omitempty" xml:"Predicates,omitempty" type:"Struct"`
	// The information about redirection.
	RedirectJSON *UpdateGatewayRouteRequestRedirectJSON `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty" type:"Struct"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about destination services.
	Services []*UpdateGatewayRouteRequestServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetDestinationType(v string) *UpdateGatewayRouteRequest {
	s.DestinationType = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetDirectResponseJSON(v *UpdateGatewayRouteRequestDirectResponseJSON) *UpdateGatewayRouteRequest {
	s.DirectResponseJSON = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetDomainIdListJSON(v string) *UpdateGatewayRouteRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetEnableWaf(v bool) *UpdateGatewayRouteRequest {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetFallback(v bool) *UpdateGatewayRouteRequest {
	s.Fallback = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetFallbackServices(v []*UpdateGatewayRouteRequestFallbackServices) *UpdateGatewayRouteRequest {
	s.FallbackServices = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetGatewayId(v int64) *UpdateGatewayRouteRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetId(v int64) *UpdateGatewayRouteRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetName(v string) *UpdateGatewayRouteRequest {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetPredicates(v *UpdateGatewayRouteRequestPredicates) *UpdateGatewayRouteRequest {
	s.Predicates = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetRedirectJSON(v *UpdateGatewayRouteRequestRedirectJSON) *UpdateGatewayRouteRequest {
	s.RedirectJSON = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetRouteOrder(v int32) *UpdateGatewayRouteRequest {
	s.RouteOrder = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetServices(v []*UpdateGatewayRouteRequestServices) *UpdateGatewayRouteRequest {
	s.Services = v
	return s
}

type UpdateGatewayRouteRequestDirectResponseJSON struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The mock return code.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s UpdateGatewayRouteRequestDirectResponseJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestDirectResponseJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestDirectResponseJSON) SetBody(v string) *UpdateGatewayRouteRequestDirectResponseJSON {
	s.Body = &v
	return s
}

func (s *UpdateGatewayRouteRequestDirectResponseJSON) SetCode(v int64) *UpdateGatewayRouteRequestDirectResponseJSON {
	s.Code = &v
	return s
}

type UpdateGatewayRouteRequestFallbackServices struct {
	// The type of the protocol. Valid values:
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace in which the service resides.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s UpdateGatewayRouteRequestFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestFallbackServices) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetAgreementType(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetGroupName(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.GroupName = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetName(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetNamespace(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.Namespace = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetPercent(v int32) *UpdateGatewayRouteRequestFallbackServices {
	s.Percent = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetServiceId(v int64) *UpdateGatewayRouteRequestFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetServicePort(v int32) *UpdateGatewayRouteRequestFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetSourceType(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.SourceType = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetVersion(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.Version = &v
	return s
}

type UpdateGatewayRouteRequestPredicates struct {
	// The information about header matching.
	HeaderPredicates []*UpdateGatewayRouteRequestPredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about path matching.
	PathPredicates *UpdateGatewayRouteRequestPredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The information about parameter matching.
	QueryPredicates []*UpdateGatewayRouteRequestPredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequestPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicates) SetHeaderPredicates(v []*UpdateGatewayRouteRequestPredicatesHeaderPredicates) *UpdateGatewayRouteRequestPredicates {
	s.HeaderPredicates = v
	return s
}

func (s *UpdateGatewayRouteRequestPredicates) SetMethodPredicates(v []*string) *UpdateGatewayRouteRequestPredicates {
	s.MethodPredicates = v
	return s
}

func (s *UpdateGatewayRouteRequestPredicates) SetPathPredicates(v *UpdateGatewayRouteRequestPredicatesPathPredicates) *UpdateGatewayRouteRequestPredicates {
	s.PathPredicates = v
	return s
}

func (s *UpdateGatewayRouteRequestPredicates) SetQueryPredicates(v []*UpdateGatewayRouteRequestPredicatesQueryPredicates) *UpdateGatewayRouteRequestPredicates {
	s.QueryPredicates = v
	return s
}

type UpdateGatewayRouteRequestPredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteRequestPredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicatesHeaderPredicates) SetKey(v string) *UpdateGatewayRouteRequestPredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesHeaderPredicates) SetType(v string) *UpdateGatewayRouteRequestPredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesHeaderPredicates) SetValue(v string) *UpdateGatewayRouteRequestPredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteRequestPredicatesPathPredicates struct {
	// Specifies whether to perform case-insensitive matching.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path used for route matching.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateGatewayRouteRequestPredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicatesPathPredicates) SetIgnoreCase(v bool) *UpdateGatewayRouteRequestPredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesPathPredicates) SetPath(v string) *UpdateGatewayRouteRequestPredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesPathPredicates) SetType(v string) *UpdateGatewayRouteRequestPredicatesPathPredicates {
	s.Type = &v
	return s
}

type UpdateGatewayRouteRequestPredicatesQueryPredicates struct {
	// The name of the parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteRequestPredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicatesQueryPredicates) SetKey(v string) *UpdateGatewayRouteRequestPredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesQueryPredicates) SetType(v string) *UpdateGatewayRouteRequestPredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesQueryPredicates) SetValue(v string) *UpdateGatewayRouteRequestPredicatesQueryPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteRequestRedirectJSON struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname to be redirected to.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path to be redirected to.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s UpdateGatewayRouteRequestRedirectJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestRedirectJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestRedirectJSON) SetCode(v int32) *UpdateGatewayRouteRequestRedirectJSON {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteRequestRedirectJSON) SetHost(v string) *UpdateGatewayRouteRequestRedirectJSON {
	s.Host = &v
	return s
}

func (s *UpdateGatewayRouteRequestRedirectJSON) SetPath(v string) *UpdateGatewayRouteRequestRedirectJSON {
	s.Path = &v
	return s
}

type UpdateGatewayRouteRequestServices struct {
	// The type of the protocol. Valid values:
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The transcoder of the Dubbo protocol.
	HttpDubboTranscoder *UpdateGatewayRouteRequestServicesHttpDubboTranscoder `json:"HttpDubboTranscoder,omitempty" xml:"HttpDubboTranscoder,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace in which the service resides.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The percentage.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The Dubbo port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s UpdateGatewayRouteRequestServices) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServices) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServices) SetAgreementType(v string) *UpdateGatewayRouteRequestServices {
	s.AgreementType = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetGroupName(v string) *UpdateGatewayRouteRequestServices {
	s.GroupName = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetHttpDubboTranscoder(v *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) *UpdateGatewayRouteRequestServices {
	s.HttpDubboTranscoder = v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetName(v string) *UpdateGatewayRouteRequestServices {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetNamespace(v string) *UpdateGatewayRouteRequestServices {
	s.Namespace = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetPercent(v int32) *UpdateGatewayRouteRequestServices {
	s.Percent = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetServiceId(v int64) *UpdateGatewayRouteRequestServices {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetServicePort(v int32) *UpdateGatewayRouteRequestServices {
	s.ServicePort = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetSourceType(v string) *UpdateGatewayRouteRequestServices {
	s.SourceType = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetVersion(v string) *UpdateGatewayRouteRequestServices {
	s.Version = &v
	return s
}

type UpdateGatewayRouteRequestServicesHttpDubboTranscoder struct {
	// The Dubbo service group.
	DubboServiceGroup *string `json:"DubboServiceGroup,omitempty" xml:"DubboServiceGroup,omitempty"`
	// The name of the Dubbo service.
	DubboServiceName *string `json:"DubboServiceName,omitempty" xml:"DubboServiceName,omitempty"`
	// The version of the Dubbo service.
	DubboServiceVersion *string `json:"DubboServiceVersion,omitempty" xml:"DubboServiceVersion,omitempty"`
	// The forwarding rules of the Dubbo service.
	MothedMapList []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList `json:"MothedMapList,omitempty" xml:"MothedMapList,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoder) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoder) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceGroup(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceGroup = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceName(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceName = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceVersion(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceVersion = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetMothedMapList(v []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.MothedMapList = v
	return s
}

type UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList struct {
	// The method name of the Dubbo service.
	DubboMothedName *string `json:"DubboMothedName,omitempty" xml:"DubboMothedName,omitempty"`
	// The HTTP method.
	//
	// > Valid values:
	//
	// *   ALL_GET
	//
	// *   ALL_POST
	//
	// *   ALL_PUT
	//
	// *   ALL_DELETE
	//
	// *   ALL_PATCH
	HttpMothed *string `json:"HttpMothed,omitempty" xml:"HttpMothed,omitempty"`
	// The path that is used to match a method.
	Mothedpath *string `json:"Mothedpath,omitempty" xml:"Mothedpath,omitempty"`
	// The information of parameter mappings.
	ParamMapsList []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList `json:"ParamMapsList,omitempty" xml:"ParamMapsList,omitempty" type:"Repeated"`
	// The pass-through type of the header.
	//
	// > Valid values:
	//
	// *   PASS_ALL: All headers are passed through.
	//
	// *   PASS_NOT: All headers are not passed through.
	//
	// *   PASS_ASSIGN: Specified headers are passed through.
	PassThroughAllHeaders *string `json:"PassThroughAllHeaders,omitempty" xml:"PassThroughAllHeaders,omitempty"`
	// The list of headers to be passed through.
	PassThroughList []*string `json:"PassThroughList,omitempty" xml:"PassThroughList,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetDubboMothedName(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.DubboMothedName = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetHttpMothed(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.HttpMothed = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetMothedpath(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.Mothedpath = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetParamMapsList(v []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.ParamMapsList = v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughAllHeaders(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughAllHeaders = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughList(v []*string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughList = v
	return s
}

type UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList struct {
	// The key extracted from the input parameter.
	ExtractKey *string `json:"ExtractKey,omitempty" xml:"ExtractKey,omitempty"`
	// The position of the input parameter.
	//
	// > Valid values:
	//
	// *   `ALL_QUERY_PARAMETER`: request parameter
	//
	// *   `ALL_HEADER`: request header
	//
	// *   `ALL_PATH`: request path
	//
	// *   `ALL_BODY`: request body
	ExtractKeySpec *string `json:"ExtractKeySpec,omitempty" xml:"ExtractKeySpec,omitempty"`
	// The type of the backend service parameter.
	MappingType *string `json:"MappingType,omitempty" xml:"MappingType,omitempty"`
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKey(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKey = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKeySpec(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKeySpec = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetMappingType(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.MappingType = &v
	return s
}

type UpdateGatewayRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponseJSONShrink *string `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty"`
	// The associated domain name.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to activate Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServicesShrink *string `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The route matching conditions.
	PredicatesShrink *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The information about redirection.
	RedirectJSONShrink *string `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about destination services.
	ServicesShrink *string `json:"Services,omitempty" xml:"Services,omitempty"`
}

func (s UpdateGatewayRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetDestinationType(v string) *UpdateGatewayRouteShrinkRequest {
	s.DestinationType = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetDirectResponseJSONShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.DirectResponseJSONShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetDomainIdListJSON(v string) *UpdateGatewayRouteShrinkRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetEnableWaf(v bool) *UpdateGatewayRouteShrinkRequest {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetFallback(v bool) *UpdateGatewayRouteShrinkRequest {
	s.Fallback = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetFallbackServicesShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.FallbackServicesShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetId(v int64) *UpdateGatewayRouteShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetName(v string) *UpdateGatewayRouteShrinkRequest {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetPredicatesShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.PredicatesShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetRedirectJSONShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.RedirectJSONShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetRouteOrder(v int32) *UpdateGatewayRouteShrinkRequest {
	s.RouteOrder = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetServicesShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.ServicesShrink = &v
	return s
}

type UpdateGatewayRouteResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteResponseBody) SetCode(v int32) *UpdateGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetData(v int64) *UpdateGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetErrorCode(v string) *UpdateGatewayRouteResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetMessage(v string) *UpdateGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetRequestId(v string) *UpdateGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetSuccess(v bool) *UpdateGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteResponse) SetStatusCode(v int32) *UpdateGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteResponse) SetBody(v *UpdateGatewayRouteResponseBody) *UpdateGatewayRouteResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteAuthRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The authentication configurations.
	AuthJSON *UpdateGatewayRouteAuthRequestAuthJSON `json:"AuthJSON,omitempty" xml:"AuthJSON,omitempty" type:"Struct"`
	// The gateway ID.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The route ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteAuthRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteAuthRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteAuthRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteAuthRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteAuthRequest) SetAuthJSON(v *UpdateGatewayRouteAuthRequestAuthJSON) *UpdateGatewayRouteAuthRequest {
	s.AuthJSON = v
	return s
}

func (s *UpdateGatewayRouteAuthRequest) SetGatewayId(v int64) *UpdateGatewayRouteAuthRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteAuthRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteAuthRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteAuthRequest) SetId(v int64) *UpdateGatewayRouteAuthRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteAuthRequestAuthJSON struct {
	// The authentication type. If an empty string is passed, no authentication type is available. Valid values:
	//
	// *   JWT
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateGatewayRouteAuthRequestAuthJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteAuthRequestAuthJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteAuthRequestAuthJSON) SetType(v string) *UpdateGatewayRouteAuthRequestAuthJSON {
	s.Type = &v
	return s
}

type UpdateGatewayRouteAuthShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The authentication configurations.
	AuthJSONShrink *string `json:"AuthJSON,omitempty" xml:"AuthJSON,omitempty"`
	// The gateway ID.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The route ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteAuthShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteAuthShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteAuthShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteAuthShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteAuthShrinkRequest) SetAuthJSONShrink(v string) *UpdateGatewayRouteAuthShrinkRequest {
	s.AuthJSONShrink = &v
	return s
}

func (s *UpdateGatewayRouteAuthShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteAuthShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteAuthShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteAuthShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteAuthShrinkRequest) SetId(v int64) *UpdateGatewayRouteAuthShrinkRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteAuthResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The route ID.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteAuthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteAuthResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteAuthResponseBody) SetCode(v int32) *UpdateGatewayRouteAuthResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetData(v int64) *UpdateGatewayRouteAuthResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetDynamicCode(v string) *UpdateGatewayRouteAuthResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetDynamicMessage(v string) *UpdateGatewayRouteAuthResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetErrorCode(v string) *UpdateGatewayRouteAuthResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteAuthResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetMessage(v string) *UpdateGatewayRouteAuthResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetRequestId(v string) *UpdateGatewayRouteAuthResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponseBody) SetSuccess(v bool) *UpdateGatewayRouteAuthResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteAuthResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteAuthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteAuthResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteAuthResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteAuthResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteAuthResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteAuthResponse) SetStatusCode(v int32) *UpdateGatewayRouteAuthResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteAuthResponse) SetBody(v *UpdateGatewayRouteAuthResponseBody) *UpdateGatewayRouteAuthResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteCORSRequest struct {
	// The language of the response. In compliance with [RFC 7231](https://tools.ietf.org/html/rfc7231), the backend service must return a response based on the language used by the user.
	//
	// *   No default value.
	// *   zh-CN: Chinese
	// *   en-US: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The information about the CORS policy.
	CorsJSON *UpdateGatewayRouteCORSRequestCorsJSON `json:"CorsJSON,omitempty" xml:"CorsJSON,omitempty" type:"Struct"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteCORSRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteCORSRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetCorsJSON(v *UpdateGatewayRouteCORSRequestCorsJSON) *UpdateGatewayRouteCORSRequest {
	s.CorsJSON = v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetGatewayId(v int64) *UpdateGatewayRouteCORSRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteCORSRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetId(v int64) *UpdateGatewayRouteCORSRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteCORSRequestCorsJSON struct {
	// The credentials allowed.
	AllowCredentials *bool `json:"AllowCredentials,omitempty" xml:"AllowCredentials,omitempty"`
	// The request headers allowed.
	AllowHeaders *string `json:"AllowHeaders,omitempty" xml:"AllowHeaders,omitempty"`
	// The HTTP methods allowed.
	AllowMethods *string `json:"AllowMethods,omitempty" xml:"AllowMethods,omitempty"`
	// The origins from which access is allowed.
	AllowOrigins *string `json:"AllowOrigins,omitempty" xml:"AllowOrigins,omitempty"`
	// The response headers allowed.
	ExposeHeaders *string `json:"ExposeHeaders,omitempty" xml:"ExposeHeaders,omitempty"`
	// The status of the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The unit of time.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The value of time.
	UnitNum *int64 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteCORSRequestCorsJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSRequestCorsJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowCredentials(v bool) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowCredentials = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowHeaders(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowHeaders = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowMethods(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowMethods = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowOrigins(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowOrigins = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetExposeHeaders(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.ExposeHeaders = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetStatus(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetTimeUnit(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetUnitNum(v int64) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteCORSShrinkRequest struct {
	// The language of the response. In compliance with [RFC 7231](https://tools.ietf.org/html/rfc7231), the backend service must return a response based on the language used by the user.
	//
	// *   No default value.
	// *   zh-CN: Chinese
	// *   en-US: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The information about the CORS policy.
	CorsJSONShrink *string `json:"CorsJSON,omitempty" xml:"CorsJSON,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteCORSShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteCORSShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetCorsJSONShrink(v string) *UpdateGatewayRouteCORSShrinkRequest {
	s.CorsJSONShrink = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteCORSShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteCORSShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetId(v int64) *UpdateGatewayRouteCORSShrinkRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteCORSResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteCORSResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSResponseBody) SetCode(v int32) *UpdateGatewayRouteCORSResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetData(v int64) *UpdateGatewayRouteCORSResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteCORSResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetMessage(v string) *UpdateGatewayRouteCORSResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetRequestId(v string) *UpdateGatewayRouteCORSResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetSuccess(v bool) *UpdateGatewayRouteCORSResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteCORSResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteCORSResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteCORSResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteCORSResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteCORSResponse) SetStatusCode(v int32) *UpdateGatewayRouteCORSResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponse) SetBody(v *UpdateGatewayRouteCORSResponseBody) *UpdateGatewayRouteCORSResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteHTTPRewriteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The information about the rewrite policy. The JSON format is supported.
	HttpRewriteJSON *string `json:"HttpRewriteJSON,omitempty" xml:"HttpRewriteJSON,omitempty"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteHTTPRewriteRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHTTPRewriteRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteHTTPRewriteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetGatewayId(v int64) *UpdateGatewayRouteHTTPRewriteRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteHTTPRewriteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetHttpRewriteJSON(v string) *UpdateGatewayRouteHTTPRewriteRequest {
	s.HttpRewriteJSON = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetId(v int64) *UpdateGatewayRouteHTTPRewriteRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteHTTPRewriteResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteHTTPRewriteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHTTPRewriteResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetCode(v int32) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetData(v int64) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetMessage(v string) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetRequestId(v string) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetSuccess(v bool) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteHTTPRewriteResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteHTTPRewriteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteHTTPRewriteResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHTTPRewriteResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHTTPRewriteResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteHTTPRewriteResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponse) SetStatusCode(v int32) *UpdateGatewayRouteHTTPRewriteResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponse) SetBody(v *UpdateGatewayRouteHTTPRewriteResponseBody) *UpdateGatewayRouteHTTPRewriteResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteHeaderOpRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The description of user header settings.
	HeaderOpJSON *string `json:"HeaderOpJSON,omitempty" xml:"HeaderOpJSON,omitempty"`
	// The ID of the record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteHeaderOpRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHeaderOpRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteHeaderOpRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetGatewayId(v int64) *UpdateGatewayRouteHeaderOpRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteHeaderOpRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetHeaderOpJSON(v string) *UpdateGatewayRouteHeaderOpRequest {
	s.HeaderOpJSON = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetId(v int64) *UpdateGatewayRouteHeaderOpRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteHeaderOpResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteHeaderOpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHeaderOpResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetCode(v int32) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetData(v int64) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteHeaderOpResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetMessage(v string) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetRequestId(v string) *UpdateGatewayRouteHeaderOpResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetSuccess(v bool) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteHeaderOpResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteHeaderOpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteHeaderOpResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHeaderOpResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHeaderOpResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteHeaderOpResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponse) SetStatusCode(v int32) *UpdateGatewayRouteHeaderOpResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponse) SetBody(v *UpdateGatewayRouteHeaderOpResponseBody) *UpdateGatewayRouteHeaderOpResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteRetryRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The information about the retry policy.
	RetryJSON *UpdateGatewayRouteRetryRequestRetryJSON `json:"RetryJSON,omitempty" xml:"RetryJSON,omitempty" type:"Struct"`
}

func (s UpdateGatewayRouteRetryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteRetryRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetGatewayId(v int64) *UpdateGatewayRouteRetryRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteRetryRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetId(v int64) *UpdateGatewayRouteRetryRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetRetryJSON(v *UpdateGatewayRouteRetryRequestRetryJSON) *UpdateGatewayRouteRetryRequest {
	s.RetryJSON = v
	return s
}

type UpdateGatewayRouteRetryRequestRetryJSON struct {
	// The number of retries.
	Attempts *int32 `json:"Attempts,omitempty" xml:"Attempts,omitempty"`
	// The HTTP status codes.
	HttpCodes []*string `json:"HttpCodes,omitempty" xml:"HttpCodes,omitempty" type:"Repeated"`
	// The retry conditions.
	RetryOn []*string `json:"RetryOn,omitempty" xml:"RetryOn,omitempty" type:"Repeated"`
	// The status of the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateGatewayRouteRetryRequestRetryJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryRequestRetryJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetAttempts(v int32) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.Attempts = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetHttpCodes(v []*string) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.HttpCodes = v
	return s
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetRetryOn(v []*string) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.RetryOn = v
	return s
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetStatus(v string) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.Status = &v
	return s
}

type UpdateGatewayRouteRetryShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The information about the retry policy.
	RetryJSONShrink *string `json:"RetryJSON,omitempty" xml:"RetryJSON,omitempty"`
}

func (s UpdateGatewayRouteRetryShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteRetryShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteRetryShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteRetryShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetId(v int64) *UpdateGatewayRouteRetryShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetRetryJSONShrink(v string) *UpdateGatewayRouteRetryShrinkRequest {
	s.RetryJSONShrink = &v
	return s
}

type UpdateGatewayRouteRetryResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteRetryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryResponseBody) SetCode(v int32) *UpdateGatewayRouteRetryResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetData(v int64) *UpdateGatewayRouteRetryResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteRetryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetMessage(v string) *UpdateGatewayRouteRetryResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetRequestId(v string) *UpdateGatewayRouteRetryResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetSuccess(v bool) *UpdateGatewayRouteRetryResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteRetryResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteRetryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteRetryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteRetryResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteRetryResponse) SetStatusCode(v int32) *UpdateGatewayRouteRetryResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponse) SetBody(v *UpdateGatewayRouteRetryResponseBody) *UpdateGatewayRouteRetryResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteTimeoutRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period.
	TimeoutJSON *UpdateGatewayRouteTimeoutRequestTimeoutJSON `json:"TimeoutJSON,omitempty" xml:"TimeoutJSON,omitempty" type:"Struct"`
}

func (s UpdateGatewayRouteTimeoutRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteTimeoutRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetGatewayId(v int64) *UpdateGatewayRouteTimeoutRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteTimeoutRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetId(v int64) *UpdateGatewayRouteTimeoutRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetTimeoutJSON(v *UpdateGatewayRouteTimeoutRequestTimeoutJSON) *UpdateGatewayRouteTimeoutRequest {
	s.TimeoutJSON = v
	return s
}

type UpdateGatewayRouteTimeoutRequestTimeoutJSON struct {
	// The status of the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The unit of time. A value of s indicates seconds.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The value of the timeout period.
	UnitNum *int32 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteTimeoutRequestTimeoutJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutRequestTimeoutJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutRequestTimeoutJSON) SetStatus(v string) *UpdateGatewayRouteTimeoutRequestTimeoutJSON {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequestTimeoutJSON) SetTimeUnit(v string) *UpdateGatewayRouteTimeoutRequestTimeoutJSON {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequestTimeoutJSON) SetUnitNum(v int32) *UpdateGatewayRouteTimeoutRequestTimeoutJSON {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteTimeoutShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period.
	TimeoutJSONShrink *string `json:"TimeoutJSON,omitempty" xml:"TimeoutJSON,omitempty"`
}

func (s UpdateGatewayRouteTimeoutShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetId(v int64) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetTimeoutJSONShrink(v string) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.TimeoutJSONShrink = &v
	return s
}

type UpdateGatewayRouteTimeoutResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. true: The request was successful. false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteTimeoutResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetCode(v int32) *UpdateGatewayRouteTimeoutResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetData(v int64) *UpdateGatewayRouteTimeoutResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteTimeoutResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetMessage(v string) *UpdateGatewayRouteTimeoutResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetRequestId(v string) *UpdateGatewayRouteTimeoutResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetSuccess(v bool) *UpdateGatewayRouteTimeoutResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteTimeoutResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteTimeoutResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteTimeoutResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteTimeoutResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponse) SetStatusCode(v int32) *UpdateGatewayRouteTimeoutResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponse) SetBody(v *UpdateGatewayRouteTimeoutResponseBody) *UpdateGatewayRouteTimeoutResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteWafStatusRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to activate Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *int64 `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s UpdateGatewayRouteWafStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteWafStatusRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusRequest) SetEnableWaf(v bool) *UpdateGatewayRouteWafStatusRequest {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteWafStatusRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusRequest) SetRouteId(v int64) *UpdateGatewayRouteWafStatusRequest {
	s.RouteId = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *UpdateGatewayRouteWafStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetCode(v int32) *UpdateGatewayRouteWafStatusResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetData(v *UpdateGatewayRouteWafStatusResponseBodyData) *UpdateGatewayRouteWafStatusResponseBody {
	s.Data = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteWafStatusResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetMessage(v string) *UpdateGatewayRouteWafStatusResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetRequestId(v string) *UpdateGatewayRouteWafStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetSuccess(v bool) *UpdateGatewayRouteWafStatusResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyData struct {
	// The configuration for cross-origin resource sharing (CORS).
	Cors *UpdateGatewayRouteWafStatusResponseBodyDataCors `json:"Cors,omitempty" xml:"Cors,omitempty" type:"Struct"`
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The default service name.
	DefaultServiceName *string `json:"DefaultServiceName,omitempty" xml:"DefaultServiceName,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponse *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse `json:"DirectResponse,omitempty" xml:"DirectResponse,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The list of domain IDs.
	DomainIdList []*int64 `json:"DomainIdList,omitempty" xml:"DomainIdList,omitempty" type:"Repeated"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The domain names.
	DomainNameList []*string `json:"DomainNameList,omitempty" xml:"DomainNameList,omitempty" type:"Repeated"`
	// Indicates whether WAF is activated.
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The information about the rewrite policy.
	HTTPRewrite *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite `json:"HTTPRewrite,omitempty" xml:"HTTPRewrite,omitempty" type:"Struct"`
	// The header settings.
	HeaderOp *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp `json:"HeaderOp,omitempty" xml:"HeaderOp,omitempty" type:"Struct"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rule.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The configuration of the redirection.
	Redirect *UpdateGatewayRouteWafStatusResponseBodyDataRedirect `json:"Redirect,omitempty" xml:"Redirect,omitempty" type:"Struct"`
	// The retry configuration.
	Retry *UpdateGatewayRouteWafStatusResponseBodyDataRetry `json:"Retry,omitempty" xml:"Retry,omitempty" type:"Struct"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about route matching.
	RoutePredicates *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates `json:"RoutePredicates,omitempty" xml:"RoutePredicates,omitempty" type:"Struct"`
	// The information about services.
	RouteServices []*UpdateGatewayRouteWafStatusResponseBodyDataRouteServices `json:"RouteServices,omitempty" xml:"RouteServices,omitempty" type:"Repeated"`
	// The information about services.
	Services *string `json:"Services,omitempty" xml:"Services,omitempty"`
	// The status of the route.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The timeout configuration.
	Timeout *UpdateGatewayRouteWafStatusResponseBodyDataTimeout `json:"Timeout,omitempty" xml:"Timeout,omitempty" type:"Struct"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetCors(v *UpdateGatewayRouteWafStatusResponseBodyDataCors) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Cors = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDefaultServiceId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DefaultServiceId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDefaultServiceName(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DefaultServiceName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDestinationType(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DestinationType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDirectResponse(v *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DirectResponse = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainIdList(v []*int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainIdList = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainName(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainNameList(v []*string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainNameList = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetEnableWaf(v bool) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGatewayId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGatewayUniqueId(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGmtCreate(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGmtModified(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetHTTPRewrite(v *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.HTTPRewrite = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetHeaderOp(v *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.HeaderOp = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetName(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetPredicates(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Predicates = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRedirect(v *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Redirect = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRetry(v *UpdateGatewayRouteWafStatusResponseBodyDataRetry) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Retry = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRouteOrder(v int32) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.RouteOrder = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRoutePredicates(v *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.RoutePredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRouteServices(v []*UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.RouteServices = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetServices(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Services = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetStatus(v int32) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetTimeout(v *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Timeout = v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataCors struct {
	// The credentials allowed.
	AllowCredentials *bool `json:"AllowCredentials,omitempty" xml:"AllowCredentials,omitempty"`
	// The headers allowed.
	AllowHeaders *string `json:"AllowHeaders,omitempty" xml:"AllowHeaders,omitempty"`
	// The methods allowed.
	AllowMethods *string `json:"AllowMethods,omitempty" xml:"AllowMethods,omitempty"`
	// The origins allowed.
	AllowOrigins *string `json:"AllowOrigins,omitempty" xml:"AllowOrigins,omitempty"`
	// The response headers.
	ExposeHeaders *string `json:"ExposeHeaders,omitempty" xml:"ExposeHeaders,omitempty"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int64 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataCors) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataCors) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowCredentials(v bool) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowCredentials = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowHeaders(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowHeaders = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowMethods(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowMethods = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowOrigins(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowOrigins = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetExposeHeaders(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.ExposeHeaders = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetTimeUnit(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetUnitNum(v int64) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) SetBody(v string) *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse {
	s.Body = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) SetCode(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse {
	s.Code = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite struct {
	// The domain name.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The HTTP request path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The path type of the HTTP request.
	PathType *string `json:"PathType,omitempty" xml:"PathType,omitempty"`
	// The matching pattern.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
	// The HTTP status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The replacement.
	Substitution *string `json:"Substitution,omitempty" xml:"Substitution,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetHost(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Host = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetPath(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Path = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetPathType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.PathType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetPattern(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Pattern = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetSubstitution(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Substitution = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp struct {
	// The policy.
	HeaderOpItems []*UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems `json:"HeaderOpItems,omitempty" xml:"HeaderOpItems,omitempty" type:"Repeated"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) SetHeaderOpItems(v []*UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp {
	s.HeaderOpItems = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp {
	s.Status = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems struct {
	// The request or response.
	DirectionType *string `json:"DirectionType,omitempty" xml:"DirectionType,omitempty"`
	// The header key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The operation type.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The header value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetDirectionType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.DirectionType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetKey(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetOpType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.OpType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetValue(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.Value = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRedirect struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRedirect) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRedirect) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) SetCode(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataRedirect {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) SetHost(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRedirect {
	s.Host = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) SetPath(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRedirect {
	s.Path = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRetry struct {
	// The number of retries allowed for a request.
	Attempts *int32 `json:"Attempts,omitempty" xml:"Attempts,omitempty"`
	// The HTTP status code.
	HttpCodes []*string `json:"HttpCodes,omitempty" xml:"HttpCodes,omitempty" type:"Repeated"`
	// The retry condition.
	RetryOn []*string `json:"RetryOn,omitempty" xml:"RetryOn,omitempty" type:"Repeated"`
	// The retry status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRetry) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRetry) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetAttempts(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.Attempts = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetHttpCodes(v []*string) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.HttpCodes = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetRetryOn(v []*string) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.RetryOn = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.Status = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates struct {
	// The information about matching based on request headers.
	HeaderPredicates []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about route matching.
	PathPredicates *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The parameter matching rules.
	QueryPredicates []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetHeaderPredicates(v []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.HeaderPredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetMethodPredicates(v []*string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.MethodPredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetPathPredicates(v *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.PathPredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetQueryPredicates(v []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.QueryPredicates = v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) SetKey(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) SetType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) SetValue(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates struct {
	// Indicates whether case sensitivity is ignored.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) SetIgnoreCase(v bool) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) SetPath(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) SetType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates {
	s.Type = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates struct {
	// The name of the parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) SetKey(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) SetType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) SetValue(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRouteServices struct {
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetGroupName(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.GroupName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetName(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetNamespace(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Namespace = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetPercent(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Percent = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetServiceId(v int64) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetServiceName(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.ServiceName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetSourceType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.SourceType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetVersion(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Version = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataTimeout struct {
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int32 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataTimeout) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataTimeout) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataTimeout {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) SetTimeUnit(v string) *UpdateGatewayRouteWafStatusResponseBodyDataTimeout {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) SetUnitNum(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataTimeout {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteWafStatusResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteWafStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteWafStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteWafStatusResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponse) SetStatusCode(v int32) *UpdateGatewayRouteWafStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponse) SetBody(v *UpdateGatewayRouteWafStatusResponseBody) *UpdateGatewayRouteWafStatusResponse {
	s.Body = v
	return s
}

type UpdateGatewayServiceCheckRequest struct {
	// The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the health check.
	Check *bool `json:"Check,omitempty" xml:"Check,omitempty"`
	// The expected status code, which is required if the health check protocol is HTTP.
	ExpectedStatuses []*int32 `json:"ExpectedStatuses,omitempty" xml:"ExpectedStatuses,omitempty" type:"Repeated"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The healthy threshold of the health check.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The health check domain name, which is optional if the health check protocol is HTTP.
	HttpHost *string `json:"HttpHost,omitempty" xml:"HttpHost,omitempty"`
	// The health check path, which is required if the health check protocol is HTTP.
	HttpPath *string `json:"HttpPath,omitempty" xml:"HttpPath,omitempty"`
	// The interval at which the health check is performed.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The health check protocol. Valid values:
	//
	// *   HTTP
	// *   TCP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The ID of the service.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The timeout period of responses to the health check. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The unhealthy threshold of the health check.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
}

func (s UpdateGatewayServiceCheckRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceCheckRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceCheckRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceCheckRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetCheck(v bool) *UpdateGatewayServiceCheckRequest {
	s.Check = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetExpectedStatuses(v []*int32) *UpdateGatewayServiceCheckRequest {
	s.ExpectedStatuses = v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceCheckRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetHealthyThreshold(v int32) *UpdateGatewayServiceCheckRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetHttpHost(v string) *UpdateGatewayServiceCheckRequest {
	s.HttpHost = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetHttpPath(v string) *UpdateGatewayServiceCheckRequest {
	s.HttpPath = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetInterval(v int32) *UpdateGatewayServiceCheckRequest {
	s.Interval = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetProtocol(v string) *UpdateGatewayServiceCheckRequest {
	s.Protocol = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetServiceId(v string) *UpdateGatewayServiceCheckRequest {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetTimeout(v int32) *UpdateGatewayServiceCheckRequest {
	s.Timeout = &v
	return s
}

func (s *UpdateGatewayServiceCheckRequest) SetUnhealthyThreshold(v int32) *UpdateGatewayServiceCheckRequest {
	s.UnhealthyThreshold = &v
	return s
}

type UpdateGatewayServiceCheckShrinkRequest struct {
	// The language in which you want to display the results. Valid values: zh and en. zh indicates Chinese, which is the default value. en indicates English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the health check.
	Check *bool `json:"Check,omitempty" xml:"Check,omitempty"`
	// The expected status code, which is required if the health check protocol is HTTP.
	ExpectedStatusesShrink *string `json:"ExpectedStatuses,omitempty" xml:"ExpectedStatuses,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The healthy threshold of the health check.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The health check domain name, which is optional if the health check protocol is HTTP.
	HttpHost *string `json:"HttpHost,omitempty" xml:"HttpHost,omitempty"`
	// The health check path, which is required if the health check protocol is HTTP.
	HttpPath *string `json:"HttpPath,omitempty" xml:"HttpPath,omitempty"`
	// The interval at which the health check is performed.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The health check protocol. Valid values:
	//
	// *   HTTP
	// *   TCP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The ID of the service.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The timeout period of responses to the health check. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The unhealthy threshold of the health check.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
}

func (s UpdateGatewayServiceCheckShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceCheckShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceCheckShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetCheck(v bool) *UpdateGatewayServiceCheckShrinkRequest {
	s.Check = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetExpectedStatusesShrink(v string) *UpdateGatewayServiceCheckShrinkRequest {
	s.ExpectedStatusesShrink = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceCheckShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetHealthyThreshold(v int32) *UpdateGatewayServiceCheckShrinkRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetHttpHost(v string) *UpdateGatewayServiceCheckShrinkRequest {
	s.HttpHost = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetHttpPath(v string) *UpdateGatewayServiceCheckShrinkRequest {
	s.HttpPath = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetInterval(v int32) *UpdateGatewayServiceCheckShrinkRequest {
	s.Interval = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetProtocol(v string) *UpdateGatewayServiceCheckShrinkRequest {
	s.Protocol = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetServiceId(v string) *UpdateGatewayServiceCheckShrinkRequest {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetTimeout(v int32) *UpdateGatewayServiceCheckShrinkRequest {
	s.Timeout = &v
	return s
}

func (s *UpdateGatewayServiceCheckShrinkRequest) SetUnhealthyThreshold(v int32) *UpdateGatewayServiceCheckShrinkRequest {
	s.UnhealthyThreshold = &v
	return s
}

type UpdateGatewayServiceCheckResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The service ID of the operation.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true and false.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayServiceCheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceCheckResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceCheckResponseBody) SetCode(v int32) *UpdateGatewayServiceCheckResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayServiceCheckResponseBody) SetData(v int64) *UpdateGatewayServiceCheckResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayServiceCheckResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayServiceCheckResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayServiceCheckResponseBody) SetMessage(v string) *UpdateGatewayServiceCheckResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayServiceCheckResponseBody) SetRequestId(v string) *UpdateGatewayServiceCheckResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayServiceCheckResponseBody) SetSuccess(v bool) *UpdateGatewayServiceCheckResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayServiceCheckResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayServiceCheckResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayServiceCheckResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceCheckResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceCheckResponse) SetHeaders(v map[string]*string) *UpdateGatewayServiceCheckResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayServiceCheckResponse) SetStatusCode(v int32) *UpdateGatewayServiceCheckResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayServiceCheckResponse) SetBody(v *UpdateGatewayServiceCheckResponseBody) *UpdateGatewayServiceCheckResponse {
	s.Body = v
	return s
}

type UpdateGatewayServiceTrafficPolicyRequest struct {
	// The language of the response. Valid values:
	//
	// *   **zh-CN** (default): Chinese
	// *   **en-US**: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic policy of the gateway.
	GatewayTrafficPolicy *TrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s UpdateGatewayServiceTrafficPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceTrafficPolicyRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetGatewayId(v int64) *UpdateGatewayServiceTrafficPolicyRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetGatewayTrafficPolicy(v *TrafficPolicy) *UpdateGatewayServiceTrafficPolicyRequest {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceTrafficPolicyRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetServiceId(v int64) *UpdateGatewayServiceTrafficPolicyRequest {
	s.ServiceId = &v
	return s
}

type UpdateGatewayServiceTrafficPolicyShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   **zh-CN** (default): Chinese
	// *   **en-US**: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic policy of the gateway.
	GatewayTrafficPolicyShrink *string `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s UpdateGatewayServiceTrafficPolicyShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetGatewayId(v int64) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetGatewayTrafficPolicyShrink(v string) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.GatewayTrafficPolicyShrink = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetServiceId(v int64) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.ServiceId = &v
	return s
}

type UpdateGatewayServiceTrafficPolicyResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GatewayService `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayServiceTrafficPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetCode(v int32) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetData(v *GatewayService) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Data = v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetMessage(v string) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetRequestId(v string) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetSuccess(v bool) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayServiceTrafficPolicyResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayServiceTrafficPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayServiceTrafficPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyResponse) SetHeaders(v map[string]*string) *UpdateGatewayServiceTrafficPolicyResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponse) SetStatusCode(v int32) *UpdateGatewayServiceTrafficPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponse) SetBody(v *UpdateGatewayServiceTrafficPolicyResponseBody) *UpdateGatewayServiceTrafficPolicyResponse {
	s.Body = v
	return s
}

type UpdateGatewayServiceVersionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty"`
}

func (s UpdateGatewayServiceVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceVersionRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceVersionRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceVersionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceVersionRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceVersionRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceVersionRequest) SetServiceId(v int64) *UpdateGatewayServiceVersionRequest {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayServiceVersionRequest) SetServiceVersion(v string) *UpdateGatewayServiceVersionRequest {
	s.ServiceVersion = &v
	return s
}

type UpdateGatewayServiceVersionResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayServiceVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceVersionResponseBody) SetCode(v int32) *UpdateGatewayServiceVersionResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetData(v int64) *UpdateGatewayServiceVersionResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayServiceVersionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetMessage(v string) *UpdateGatewayServiceVersionResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetRequestId(v string) *UpdateGatewayServiceVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetSuccess(v bool) *UpdateGatewayServiceVersionResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayServiceVersionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayServiceVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayServiceVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceVersionResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceVersionResponse) SetHeaders(v map[string]*string) *UpdateGatewayServiceVersionResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayServiceVersionResponse) SetStatusCode(v int32) *UpdateGatewayServiceVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponse) SetBody(v *UpdateGatewayServiceVersionResponseBody) *UpdateGatewayServiceVersionResponse {
	s.Body = v
	return s
}

type UpdateGatewaySpecRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The number of nodes.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The node specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s UpdateGatewaySpecRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewaySpecRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewaySpecRequest) SetAcceptLanguage(v string) *UpdateGatewaySpecRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewaySpecRequest) SetGatewayUniqueId(v string) *UpdateGatewaySpecRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewaySpecRequest) SetReplica(v int32) *UpdateGatewaySpecRequest {
	s.Replica = &v
	return s
}

func (s *UpdateGatewaySpecRequest) SetSpec(v string) *UpdateGatewaySpecRequest {
	s.Spec = &v
	return s
}

type UpdateGatewaySpecResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewaySpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewaySpecResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewaySpecResponseBody) SetCode(v int32) *UpdateGatewaySpecResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetData(v string) *UpdateGatewaySpecResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetHttpStatusCode(v int32) *UpdateGatewaySpecResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetMessage(v string) *UpdateGatewaySpecResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetRequestId(v string) *UpdateGatewaySpecResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetSuccess(v bool) *UpdateGatewaySpecResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewaySpecResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewaySpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewaySpecResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewaySpecResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewaySpecResponse) SetHeaders(v map[string]*string) *UpdateGatewaySpecResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewaySpecResponse) SetStatusCode(v int32) *UpdateGatewaySpecResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewaySpecResponse) SetBody(v *UpdateGatewaySpecResponseBody) *UpdateGatewaySpecResponse {
	s.Body = v
	return s
}

type UpdateImageRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the destination cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The destination version number.
	//
	// > You must call the GetImage operation to obtain the maximum destination version number that corresponds to MaxVersionCode.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s UpdateImageRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageRequest) GoString() string {
	return s.String()
}

func (s *UpdateImageRequest) SetAcceptLanguage(v string) *UpdateImageRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateImageRequest) SetClusterId(v string) *UpdateImageRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateImageRequest) SetVersionCode(v string) *UpdateImageRequest {
	s.VersionCode = &v
	return s
}

type UpdateImageResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateImageResponseBody) SetErrorCode(v string) *UpdateImageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateImageResponseBody) SetMessage(v string) *UpdateImageResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateImageResponseBody) SetRequestId(v string) *UpdateImageResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateImageResponseBody) SetSuccess(v bool) *UpdateImageResponseBody {
	s.Success = &v
	return s
}

type UpdateImageResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateImageResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageResponse) GoString() string {
	return s.String()
}

func (s *UpdateImageResponse) SetHeaders(v map[string]*string) *UpdateImageResponse {
	s.Headers = v
	return s
}

func (s *UpdateImageResponse) SetStatusCode(v int32) *UpdateImageResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateImageResponse) SetBody(v *UpdateImageResponseBody) *UpdateImageResponse {
	s.Body = v
	return s
}

type UpdateMessageQueueRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId   *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether the canary release for messaging feature is enabled for the application. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	FilterSide *string `json:"FilterSide,omitempty" xml:"FilterSide,omitempty"`
	Namespace  *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The tag that is negligible for the untagged environment of the application.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s UpdateMessageQueueRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteRequest) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteRequest) SetAcceptLanguage(v string) *UpdateMessageQueueRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetAppId(v string) *UpdateMessageQueueRouteRequest {
	s.AppId = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetAppName(v string) *UpdateMessageQueueRouteRequest {
	s.AppName = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetEnable(v bool) *UpdateMessageQueueRouteRequest {
	s.Enable = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetFilterSide(v string) *UpdateMessageQueueRouteRequest {
	s.FilterSide = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetNamespace(v string) *UpdateMessageQueueRouteRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetRegion(v string) *UpdateMessageQueueRouteRequest {
	s.Region = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetTags(v []*string) *UpdateMessageQueueRouteRequest {
	s.Tags = v
	return s
}

type UpdateMessageQueueRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId   *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether the canary release for messaging feature is enabled for the application. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	FilterSide *string `json:"FilterSide,omitempty" xml:"FilterSide,omitempty"`
	Namespace  *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The tag that is negligible for the untagged environment of the application.
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s UpdateMessageQueueRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetAcceptLanguage(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetAppId(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.AppId = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetAppName(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.AppName = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetEnable(v bool) *UpdateMessageQueueRouteShrinkRequest {
	s.Enable = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetFilterSide(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.FilterSide = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetNamespace(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetRegion(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.Region = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetTagsShrink(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.TagsShrink = &v
	return s
}

type UpdateMessageQueueRouteResponseBody struct {
	// The status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateMessageQueueRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteResponseBody) SetCode(v int32) *UpdateMessageQueueRouteResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetData(v string) *UpdateMessageQueueRouteResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetHttpStatusCode(v int32) *UpdateMessageQueueRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetMessage(v string) *UpdateMessageQueueRouteResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetRequestId(v string) *UpdateMessageQueueRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetSuccess(v bool) *UpdateMessageQueueRouteResponseBody {
	s.Success = &v
	return s
}

type UpdateMessageQueueRouteResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateMessageQueueRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMessageQueueRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteResponse) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteResponse) SetHeaders(v map[string]*string) *UpdateMessageQueueRouteResponse {
	s.Headers = v
	return s
}

func (s *UpdateMessageQueueRouteResponse) SetStatusCode(v int32) *UpdateMessageQueueRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMessageQueueRouteResponse) SetBody(v *UpdateMessageQueueRouteResponseBody) *UpdateMessageQueueRouteResponse {
	s.Body = v
	return s
}

type UpdateMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values:
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The address of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if you want to migrate applications from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
}

func (s UpdateMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskRequest) SetAcceptLanguage(v string) *UpdateMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetClusterType(v string) *UpdateMigrationTaskRequest {
	s.ClusterType = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetId(v string) *UpdateMigrationTaskRequest {
	s.Id = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetOriginInstanceAddress(v string) *UpdateMigrationTaskRequest {
	s.OriginInstanceAddress = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetOriginInstanceName(v string) *UpdateMigrationTaskRequest {
	s.OriginInstanceName = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetOriginInstanceNamespace(v string) *UpdateMigrationTaskRequest {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetProjectDesc(v string) *UpdateMigrationTaskRequest {
	s.ProjectDesc = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetRequestPars(v string) *UpdateMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetTargetClusterName(v string) *UpdateMigrationTaskRequest {
	s.TargetClusterName = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetTargetClusterUrl(v string) *UpdateMigrationTaskRequest {
	s.TargetClusterUrl = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetTargetInstanceId(v string) *UpdateMigrationTaskRequest {
	s.TargetInstanceId = &v
	return s
}

type UpdateMigrationTaskResponseBody struct {
	// The data structure.
	Data *UpdateMigrationTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskResponseBody) SetData(v *UpdateMigrationTaskResponseBodyData) *UpdateMigrationTaskResponseBody {
	s.Data = v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetErrorCode(v string) *UpdateMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetHttpCode(v string) *UpdateMigrationTaskResponseBody {
	s.HttpCode = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetMessage(v string) *UpdateMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetRequestId(v string) *UpdateMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetSuccess(v bool) *UpdateMigrationTaskResponseBody {
	s.Success = &v
	return s
}

type UpdateMigrationTaskResponseBodyData struct {
	// The type of the instance.
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The address of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s UpdateMigrationTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskResponseBodyData) SetClusterType(v string) *UpdateMigrationTaskResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetGmtCreate(v string) *UpdateMigrationTaskResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetGmtModified(v string) *UpdateMigrationTaskResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetId(v string) *UpdateMigrationTaskResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetOriginInstanceAddress(v string) *UpdateMigrationTaskResponseBodyData {
	s.OriginInstanceAddress = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetOriginInstanceName(v string) *UpdateMigrationTaskResponseBodyData {
	s.OriginInstanceName = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetOriginInstanceNamespace(v string) *UpdateMigrationTaskResponseBodyData {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetProjectDesc(v string) *UpdateMigrationTaskResponseBodyData {
	s.ProjectDesc = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetTargetClusterName(v string) *UpdateMigrationTaskResponseBodyData {
	s.TargetClusterName = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetTargetClusterUrl(v string) *UpdateMigrationTaskResponseBodyData {
	s.TargetClusterUrl = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetTargetInstanceId(v string) *UpdateMigrationTaskResponseBodyData {
	s.TargetInstanceId = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetUserId(v string) *UpdateMigrationTaskResponseBodyData {
	s.UserId = &v
	return s
}

type UpdateMigrationTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskResponse) SetHeaders(v map[string]*string) *UpdateMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateMigrationTaskResponse) SetStatusCode(v int32) *UpdateMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMigrationTaskResponse) SetBody(v *UpdateMigrationTaskResponseBody) *UpdateMigrationTaskResponse {
	s.Body = v
	return s
}

type UpdateNacosClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The port used for health checks.
	CheckPort *int32 `json:"CheckPort,omitempty" xml:"CheckPort,omitempty"`
	// The name of the Nacos cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the health check.
	HealthChecker *string `json:"HealthChecker,omitempty" xml:"HealthChecker,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// Specifies whether to use the port of the instance for a health check.
	UseInstancePortForCheck *bool `json:"UseInstancePortForCheck,omitempty" xml:"UseInstancePortForCheck,omitempty"`
}

func (s UpdateNacosClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosClusterRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosClusterRequest) SetAcceptLanguage(v string) *UpdateNacosClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetCheckPort(v int32) *UpdateNacosClusterRequest {
	s.CheckPort = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetClusterName(v string) *UpdateNacosClusterRequest {
	s.ClusterName = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetGroupName(v string) *UpdateNacosClusterRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetHealthChecker(v string) *UpdateNacosClusterRequest {
	s.HealthChecker = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetInstanceId(v string) *UpdateNacosClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetNamespaceId(v string) *UpdateNacosClusterRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetServiceName(v string) *UpdateNacosClusterRequest {
	s.ServiceName = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetUseInstancePortForCheck(v bool) *UpdateNacosClusterRequest {
	s.UseInstancePortForCheck = &v
	return s
}

type UpdateNacosClusterResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosClusterResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosClusterResponseBody) SetCode(v int32) *UpdateNacosClusterResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetData(v string) *UpdateNacosClusterResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetHttpStatusCode(v int32) *UpdateNacosClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetMessage(v string) *UpdateNacosClusterResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetRequestId(v string) *UpdateNacosClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetSuccess(v bool) *UpdateNacosClusterResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosClusterResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosClusterResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosClusterResponse) SetHeaders(v map[string]*string) *UpdateNacosClusterResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosClusterResponse) SetStatusCode(v int32) *UpdateNacosClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosClusterResponse) SetBody(v *UpdateNacosClusterResponseBody) *UpdateNacosClusterResponse {
	s.Body = v
	return s
}

type UpdateNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The list of IP addresses where the beta release of the configuration is performed.
	BetaIps *string `json:"BetaIps,omitempty" xml:"BetaIps,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The description of the configuration.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The encryption key.
	EncryptedDataKey *string `json:"EncryptedDataKey,omitempty" xml:"EncryptedDataKey,omitempty"`
	// The name of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The MD5 value of the configuration.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The list of tags.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The format of the configuration. Supported formats include TEXT, JSON, XML, and HTML.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosConfigRequest) SetAcceptLanguage(v string) *UpdateNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetAppName(v string) *UpdateNacosConfigRequest {
	s.AppName = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetBetaIps(v string) *UpdateNacosConfigRequest {
	s.BetaIps = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetContent(v string) *UpdateNacosConfigRequest {
	s.Content = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetDataId(v string) *UpdateNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetDesc(v string) *UpdateNacosConfigRequest {
	s.Desc = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetEncryptedDataKey(v string) *UpdateNacosConfigRequest {
	s.EncryptedDataKey = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetGroup(v string) *UpdateNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetInstanceId(v string) *UpdateNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetMd5(v string) *UpdateNacosConfigRequest {
	s.Md5 = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetNamespaceId(v string) *UpdateNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetTags(v string) *UpdateNacosConfigRequest {
	s.Tags = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetType(v string) *UpdateNacosConfigRequest {
	s.Type = &v
	return s
}

type UpdateNacosConfigResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosConfigResponseBody) SetErrorCode(v string) *UpdateNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetHttpCode(v string) *UpdateNacosConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetMessage(v string) *UpdateNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetRequestId(v string) *UpdateNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetSuccess(v bool) *UpdateNacosConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosConfigResponse) SetHeaders(v map[string]*string) *UpdateNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosConfigResponse) SetStatusCode(v int32) *UpdateNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosConfigResponse) SetBody(v *UpdateNacosConfigResponseBody) *UpdateNacosConfigResponse {
	s.Body = v
	return s
}

type UpdateNacosInstanceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the Nacos instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Specifies whether to disable this service. Valid values:
	//
	// *   `true`: yes.
	// *   `false`: no.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Specifies whether the node is a non-persistent node. Valid values:
	//
	// *   `true`: yes.
	// *   `false`: no.
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the Nacos instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The metadata of the instance.
	Metadata *string `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port number of the Nacos instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The weight. Valid values: 0 to 10000. The value must be an integer. A larger value indicates a higher frequency at which the instance is accessed.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s UpdateNacosInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosInstanceRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosInstanceRequest) SetAcceptLanguage(v string) *UpdateNacosInstanceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetClusterName(v string) *UpdateNacosInstanceRequest {
	s.ClusterName = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetEnabled(v bool) *UpdateNacosInstanceRequest {
	s.Enabled = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetEphemeral(v bool) *UpdateNacosInstanceRequest {
	s.Ephemeral = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetGroupName(v string) *UpdateNacosInstanceRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetInstanceId(v string) *UpdateNacosInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetIp(v string) *UpdateNacosInstanceRequest {
	s.Ip = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetMetadata(v string) *UpdateNacosInstanceRequest {
	s.Metadata = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetNamespaceId(v string) *UpdateNacosInstanceRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetPort(v int32) *UpdateNacosInstanceRequest {
	s.Port = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetServiceName(v string) *UpdateNacosInstanceRequest {
	s.ServiceName = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetWeight(v string) *UpdateNacosInstanceRequest {
	s.Weight = &v
	return s
}

type UpdateNacosInstanceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the modification.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosInstanceResponseBody) SetCode(v int32) *UpdateNacosInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetData(v string) *UpdateNacosInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetHttpStatusCode(v int32) *UpdateNacosInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetMessage(v string) *UpdateNacosInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetRequestId(v string) *UpdateNacosInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetSuccess(v bool) *UpdateNacosInstanceResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosInstanceResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosInstanceResponse) SetHeaders(v map[string]*string) *UpdateNacosInstanceResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosInstanceResponse) SetStatusCode(v int32) *UpdateNacosInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosInstanceResponse) SetBody(v *UpdateNacosInstanceResponseBody) *UpdateNacosInstanceResponse {
	s.Body = v
	return s
}

type UpdateNacosServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The protection threshold.
	ProtectThreshold *string `json:"ProtectThreshold,omitempty" xml:"ProtectThreshold,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s UpdateNacosServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosServiceRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosServiceRequest) SetAcceptLanguage(v string) *UpdateNacosServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetClusterId(v string) *UpdateNacosServiceRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetGroupName(v string) *UpdateNacosServiceRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetInstanceId(v string) *UpdateNacosServiceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetNamespaceId(v string) *UpdateNacosServiceRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetProtectThreshold(v string) *UpdateNacosServiceRequest {
	s.ProtectThreshold = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetServiceName(v string) *UpdateNacosServiceRequest {
	s.ServiceName = &v
	return s
}

type UpdateNacosServiceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosServiceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosServiceResponseBody) SetCode(v int32) *UpdateNacosServiceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetData(v string) *UpdateNacosServiceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetHttpStatusCode(v int32) *UpdateNacosServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetMessage(v string) *UpdateNacosServiceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetRequestId(v string) *UpdateNacosServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetSuccess(v bool) *UpdateNacosServiceResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosServiceResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosServiceResponse) SetHeaders(v map[string]*string) *UpdateNacosServiceResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosServiceResponse) SetStatusCode(v int32) *UpdateNacosServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosServiceResponse) SetBody(v *UpdateNacosServiceResponseBody) *UpdateNacosServiceResponse {
	s.Body = v
	return s
}

type UpdatePluginConfigRequest struct {
	// The language of the response. Valid values:
	//
	// zh: Chinese en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The plug-in configuration. Configurations of WebAssembly plug-ins are in the YAML format, and configurations of Lua plug-ins are in the Lua code.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The application scope of the plug-in.
	//
	// *   0: global
	// *   1: route
	// *   2: domain name
	ConfigLevel *int32 `json:"ConfigLevel,omitempty" xml:"ConfigLevel,omitempty"`
	// Specifies whether to enable the plug-in.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the plug-in configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the gateway plug-in.
	PluginId *int64 `json:"PluginId,omitempty" xml:"PluginId,omitempty"`
}

func (s UpdatePluginConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePluginConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdatePluginConfigRequest) SetAcceptLanguage(v string) *UpdatePluginConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetConfig(v string) *UpdatePluginConfigRequest {
	s.Config = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetConfigLevel(v int32) *UpdatePluginConfigRequest {
	s.ConfigLevel = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetEnable(v bool) *UpdatePluginConfigRequest {
	s.Enable = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGatewayId(v int64) *UpdatePluginConfigRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGatewayUniqueId(v string) *UpdatePluginConfigRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGmtCreate(v string) *UpdatePluginConfigRequest {
	s.GmtCreate = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGmtModified(v string) *UpdatePluginConfigRequest {
	s.GmtModified = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetId(v int64) *UpdatePluginConfigRequest {
	s.Id = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetPluginId(v int64) *UpdatePluginConfigRequest {
	s.PluginId = &v
	return s
}

type UpdatePluginConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the plug-in configuration.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdatePluginConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePluginConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePluginConfigResponseBody) SetCode(v int32) *UpdatePluginConfigResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetData(v int64) *UpdatePluginConfigResponseBody {
	s.Data = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetDynamicMessage(v string) *UpdatePluginConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetErrorCode(v string) *UpdatePluginConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetHttpStatusCode(v int32) *UpdatePluginConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetMessage(v string) *UpdatePluginConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetRequestId(v string) *UpdatePluginConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetSuccess(v bool) *UpdatePluginConfigResponseBody {
	s.Success = &v
	return s
}

type UpdatePluginConfigResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePluginConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePluginConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePluginConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdatePluginConfigResponse) SetHeaders(v map[string]*string) *UpdatePluginConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdatePluginConfigResponse) SetStatusCode(v int32) *UpdatePluginConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePluginConfigResponse) SetBody(v *UpdatePluginConfigResponseBody) *UpdatePluginConfigResponse {
	s.Body = v
	return s
}

type UpdateSSLCertRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The ID of the domain name.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s UpdateSSLCertRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSSLCertRequest) GoString() string {
	return s.String()
}

func (s *UpdateSSLCertRequest) SetAcceptLanguage(v string) *UpdateSSLCertRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateSSLCertRequest) SetCertIdentifier(v string) *UpdateSSLCertRequest {
	s.CertIdentifier = &v
	return s
}

func (s *UpdateSSLCertRequest) SetDomainId(v int64) *UpdateSSLCertRequest {
	s.DomainId = &v
	return s
}

func (s *UpdateSSLCertRequest) SetGatewayUniqueId(v string) *UpdateSSLCertRequest {
	s.GatewayUniqueId = &v
	return s
}

type UpdateSSLCertResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the update is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSSLCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSSLCertResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSSLCertResponseBody) SetCode(v int32) *UpdateSSLCertResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetData(v bool) *UpdateSSLCertResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetHttpStatusCode(v int32) *UpdateSSLCertResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetMessage(v string) *UpdateSSLCertResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetRequestId(v string) *UpdateSSLCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetSuccess(v bool) *UpdateSSLCertResponseBody {
	s.Success = &v
	return s
}

type UpdateSSLCertResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSSLCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSSLCertResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSSLCertResponse) GoString() string {
	return s.String()
}

func (s *UpdateSSLCertResponse) SetHeaders(v map[string]*string) *UpdateSSLCertResponse {
	s.Headers = v
	return s
}

func (s *UpdateSSLCertResponse) SetStatusCode(v int32) *UpdateSSLCertResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSSLCertResponse) SetBody(v *UpdateSSLCertResponseBody) *UpdateSSLCertResponse {
	s.Body = v
	return s
}

type UpdateServiceSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese.
	// *   en: English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service source.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The configurations of Ingress resources.
	IngressOptionsRequest *UpdateServiceSourceRequestIngressOptionsRequest `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of service root paths.
	PathList []*string `json:"PathList,omitempty" xml:"PathList,omitempty" type:"Repeated"`
	// The service source. Valid values:
	//
	// *   K8s: ACK cluster.
	// *   MSE: Nacos instance.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   K8s: ACK cluster.
	// *   NACOS: Nacos instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceRequest) SetAcceptLanguage(v string) *UpdateServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetAddress(v string) *UpdateServiceSourceRequest {
	s.Address = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetGatewayId(v int64) *UpdateServiceSourceRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetGatewayUniqueId(v string) *UpdateServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetId(v int64) *UpdateServiceSourceRequest {
	s.Id = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetIngressOptionsRequest(v *UpdateServiceSourceRequestIngressOptionsRequest) *UpdateServiceSourceRequest {
	s.IngressOptionsRequest = v
	return s
}

func (s *UpdateServiceSourceRequest) SetName(v string) *UpdateServiceSourceRequest {
	s.Name = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetPathList(v []*string) *UpdateServiceSourceRequest {
	s.PathList = v
	return s
}

func (s *UpdateServiceSourceRequest) SetSource(v string) *UpdateServiceSourceRequest {
	s.Source = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetType(v string) *UpdateServiceSourceRequest {
	s.Type = &v
	return s
}

type UpdateServiceSourceRequestIngressOptionsRequest struct {
	// Specifies whether to enable Ingress.
	EnableIngress *bool `json:"EnableIngress,omitempty" xml:"EnableIngress,omitempty"`
	// Specifies whether to update the Ingress status.
	EnableStatus *bool `json:"EnableStatus,omitempty" xml:"EnableStatus,omitempty"`
	// Specifies whether to monitor Ingress classes.
	IngressClass *string `json:"IngressClass,omitempty" xml:"IngressClass,omitempty"`
	// The namespace whose resources you want to monitor.
	WatchNamespace *string `json:"WatchNamespace,omitempty" xml:"WatchNamespace,omitempty"`
}

func (s UpdateServiceSourceRequestIngressOptionsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceRequestIngressOptionsRequest) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetEnableIngress(v bool) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.EnableIngress = &v
	return s
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetEnableStatus(v bool) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.EnableStatus = &v
	return s
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetIngressClass(v string) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.IngressClass = &v
	return s
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetWatchNamespace(v string) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.WatchNamespace = &v
	return s
}

type UpdateServiceSourceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese.
	// *   en: English.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service source.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The configurations of Ingress resources.
	IngressOptionsRequestShrink *string `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of service root paths.
	PathListShrink *string `json:"PathList,omitempty" xml:"PathList,omitempty"`
	// The service source. Valid values:
	//
	// *   K8s: ACK cluster.
	// *   MSE: Nacos instance.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   K8s: ACK cluster.
	// *   NACOS: Nacos instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateServiceSourceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceShrinkRequest) SetAcceptLanguage(v string) *UpdateServiceSourceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetAddress(v string) *UpdateServiceSourceShrinkRequest {
	s.Address = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetGatewayId(v int64) *UpdateServiceSourceShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetGatewayUniqueId(v string) *UpdateServiceSourceShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetId(v int64) *UpdateServiceSourceShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetIngressOptionsRequestShrink(v string) *UpdateServiceSourceShrinkRequest {
	s.IngressOptionsRequestShrink = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetName(v string) *UpdateServiceSourceShrinkRequest {
	s.Name = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetPathListShrink(v string) *UpdateServiceSourceShrinkRequest {
	s.PathListShrink = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetSource(v string) *UpdateServiceSourceShrinkRequest {
	s.Source = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetType(v string) *UpdateServiceSourceShrinkRequest {
	s.Type = &v
	return s
}

type UpdateServiceSourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceResponseBody) SetCode(v int32) *UpdateServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetData(v int64) *UpdateServiceSourceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetHttpStatusCode(v int32) *UpdateServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetMessage(v string) *UpdateServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetRequestId(v string) *UpdateServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetSuccess(v bool) *UpdateServiceSourceResponseBody {
	s.Success = &v
	return s
}

type UpdateServiceSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceResponse) SetHeaders(v map[string]*string) *UpdateServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *UpdateServiceSourceResponse) SetStatusCode(v int32) *UpdateServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateServiceSourceResponse) SetBody(v *UpdateServiceSourceResponseBody) *UpdateServiceSourceResponse {
	s.Body = v
	return s
}

type UpdateZnodeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s UpdateZnodeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateZnodeRequest) GoString() string {
	return s.String()
}

func (s *UpdateZnodeRequest) SetAcceptLanguage(v string) *UpdateZnodeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateZnodeRequest) SetClusterId(v string) *UpdateZnodeRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateZnodeRequest) SetData(v string) *UpdateZnodeRequest {
	s.Data = &v
	return s
}

func (s *UpdateZnodeRequest) SetPath(v string) *UpdateZnodeRequest {
	s.Path = &v
	return s
}

func (s *UpdateZnodeRequest) SetRequestPars(v string) *UpdateZnodeRequest {
	s.RequestPars = &v
	return s
}

type UpdateZnodeResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateZnodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateZnodeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateZnodeResponseBody) SetErrorCode(v string) *UpdateZnodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateZnodeResponseBody) SetMessage(v string) *UpdateZnodeResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateZnodeResponseBody) SetRequestId(v string) *UpdateZnodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateZnodeResponseBody) SetSuccess(v bool) *UpdateZnodeResponseBody {
	s.Success = &v
	return s
}

type UpdateZnodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateZnodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateZnodeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateZnodeResponse) GoString() string {
	return s.String()
}

func (s *UpdateZnodeResponse) SetHeaders(v map[string]*string) *UpdateZnodeResponse {
	s.Headers = v
	return s
}

func (s *UpdateZnodeResponse) SetStatusCode(v int32) *UpdateZnodeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateZnodeResponse) SetBody(v *UpdateZnodeResponseBody) *UpdateZnodeResponse {
	s.Body = v
	return s
}

type UpgradeClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The destination version.
	UpgradeVersion *string `json:"UpgradeVersion,omitempty" xml:"UpgradeVersion,omitempty"`
}

func (s UpgradeClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeClusterRequest) GoString() string {
	return s.String()
}

func (s *UpgradeClusterRequest) SetAcceptLanguage(v string) *UpgradeClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpgradeClusterRequest) SetInstanceId(v string) *UpgradeClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *UpgradeClusterRequest) SetRequestPars(v string) *UpgradeClusterRequest {
	s.RequestPars = &v
	return s
}

func (s *UpgradeClusterRequest) SetUpgradeVersion(v string) *UpgradeClusterRequest {
	s.UpgradeVersion = &v
	return s
}

type UpgradeClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The response code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpgradeClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeClusterResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeClusterResponseBody) SetErrorCode(v string) *UpgradeClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetHttpCode(v string) *UpgradeClusterResponseBody {
	s.HttpCode = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetMessage(v string) *UpgradeClusterResponseBody {
	s.Message = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetRequestId(v string) *UpgradeClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetSuccess(v bool) *UpgradeClusterResponseBody {
	s.Success = &v
	return s
}

type UpgradeClusterResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeClusterResponse) GoString() string {
	return s.String()
}

func (s *UpgradeClusterResponse) SetHeaders(v map[string]*string) *UpgradeClusterResponse {
	s.Headers = v
	return s
}

func (s *UpgradeClusterResponse) SetStatusCode(v int32) *UpgradeClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeClusterResponse) SetBody(v *UpgradeClusterResponseBody) *UpgradeClusterResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.SignatureAlgorithm = tea.String("v2")
	client.EndpointRule = tea.String("regional")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("mse"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddAuthPolicyWithOptions(request *AddAuthPolicyRequest, runtime *util.RuntimeOptions) (_result *AddAuthPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthRule)) {
		query["AuthRule"] = request.AuthRule
	}

	if !tea.BoolValue(util.IsUnset(request.AuthType)) {
		query["AuthType"] = request.AuthType
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.K8sNamespace)) {
		query["K8sNamespace"] = request.K8sNamespace
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAuthPolicy"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAuthPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddAuthPolicy(request *AddAuthPolicyRequest) (_result *AddAuthPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAuthPolicyResponse{}
	_body, _err := client.AddAuthPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddAuthResourceWithOptions(tmpReq *AddAuthResourceRequest, runtime *util.RuntimeOptions) (_result *AddAuthResourceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddAuthResourceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AuthResourceHeaderList)) {
		request.AuthResourceHeaderListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AuthResourceHeaderList, tea.String("AuthResourceHeaderList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AuthId)) {
		query["AuthId"] = request.AuthId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthResourceHeaderListShrink)) {
		query["AuthResourceHeaderList"] = request.AuthResourceHeaderListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreCase)) {
		query["IgnoreCase"] = request.IgnoreCase
	}

	if !tea.BoolValue(util.IsUnset(request.MatchType)) {
		query["MatchType"] = request.MatchType
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAuthResource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAuthResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddAuthResource(request *AddAuthResourceRequest) (_result *AddAuthResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAuthResourceResponse{}
	_body, _err := client.AddAuthResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddBlackWhiteListWithOptions(request *AddBlackWhiteListRequest, runtime *util.RuntimeOptions) (_result *AddBlackWhiteListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IsWhite)) {
		query["IsWhite"] = request.IsWhite
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Note)) {
		query["Note"] = request.Note
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIdJsonList)) {
		query["ResourceIdJsonList"] = request.ResourceIdJsonList
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddBlackWhiteList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddBlackWhiteListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddBlackWhiteList(request *AddBlackWhiteListRequest) (_result *AddBlackWhiteListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddBlackWhiteListResponse{}
	_body, _err := client.AddBlackWhiteListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayWithOptions(tmpReq *AddGatewayRequest, runtime *util.RuntimeOptions) (_result *AddGatewayResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddGatewayShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ZoneInfo)) {
		request.ZoneInfoShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ZoneInfo, tea.String("ZoneInfo"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.EnableHardwareAcceleration)) {
		query["EnableHardwareAcceleration"] = request.EnableHardwareAcceleration
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSls)) {
		query["EnableSls"] = request.EnableSls
	}

	if !tea.BoolValue(util.IsUnset(request.EnableXtrace)) {
		query["EnableXtrace"] = request.EnableXtrace
	}

	if !tea.BoolValue(util.IsUnset(request.EnterpriseSecurityGroup)) {
		query["EnterpriseSecurityGroup"] = request.EnterpriseSecurityGroup
	}

	if !tea.BoolValue(util.IsUnset(request.InternetSlbSpec)) {
		query["InternetSlbSpec"] = request.InternetSlbSpec
	}

	if !tea.BoolValue(util.IsUnset(request.MserVersion)) {
		query["MserVersion"] = request.MserVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NlbNetworkType)) {
		query["NlbNetworkType"] = request.NlbNetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Replica)) {
		query["Replica"] = request.Replica
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SlbSpec)) {
		query["SlbSpec"] = request.SlbSpec
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId2)) {
		query["VSwitchId2"] = request.VSwitchId2
	}

	if !tea.BoolValue(util.IsUnset(request.Vpc)) {
		query["Vpc"] = request.Vpc
	}

	if !tea.BoolValue(util.IsUnset(request.XtraceRatio)) {
		query["XtraceRatio"] = request.XtraceRatio
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneInfoShrink)) {
		query["ZoneInfo"] = request.ZoneInfoShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGateway(request *AddGatewayRequest) (_result *AddGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayResponse{}
	_body, _err := client.AddGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayAuthConsumerWithOptions(request *AddGatewayAuthConsumerRequest, runtime *util.RuntimeOptions) (_result *AddGatewayAuthConsumerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EncodeType)) {
		query["EncodeType"] = request.EncodeType
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Jwks)) {
		query["Jwks"] = request.Jwks
	}

	if !tea.BoolValue(util.IsUnset(request.KeyName)) {
		query["KeyName"] = request.KeyName
	}

	if !tea.BoolValue(util.IsUnset(request.KeyValue)) {
		query["KeyValue"] = request.KeyValue
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TokenName)) {
		query["TokenName"] = request.TokenName
	}

	if !tea.BoolValue(util.IsUnset(request.TokenPass)) {
		query["TokenPass"] = request.TokenPass
	}

	if !tea.BoolValue(util.IsUnset(request.TokenPosition)) {
		query["TokenPosition"] = request.TokenPosition
	}

	if !tea.BoolValue(util.IsUnset(request.TokenPrefix)) {
		query["TokenPrefix"] = request.TokenPrefix
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewayAuthConsumer"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayAuthConsumerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewayAuthConsumer(request *AddGatewayAuthConsumerRequest) (_result *AddGatewayAuthConsumerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayAuthConsumerResponse{}
	_body, _err := client.AddGatewayAuthConsumerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayDomainWithOptions(request *AddGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *AddGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Http2)) {
		query["Http2"] = request.Http2
	}

	if !tea.BoolValue(util.IsUnset(request.MustHttps)) {
		query["MustHttps"] = request.MustHttps
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMax)) {
		query["TlsMax"] = request.TlsMax
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMin)) {
		query["TlsMin"] = request.TlsMin
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewayDomain(request *AddGatewayDomainRequest) (_result *AddGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayDomainResponse{}
	_body, _err := client.AddGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayRouteWithOptions(tmpReq *AddGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *AddGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddGatewayRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DirectResponseJSON)) {
		request.DirectResponseJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DirectResponseJSON, tea.String("DirectResponseJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FallbackServices)) {
		request.FallbackServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FallbackServices, tea.String("FallbackServices"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Predicates)) {
		request.PredicatesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Predicates, tea.String("Predicates"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RedirectJSON)) {
		request.RedirectJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RedirectJSON, tea.String("RedirectJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Services)) {
		request.ServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Services, tea.String("Services"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationType)) {
		query["DestinationType"] = request.DestinationType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectResponseJSONShrink)) {
		query["DirectResponseJSON"] = request.DirectResponseJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainIdListJSON)) {
		query["DomainIdListJSON"] = request.DomainIdListJSON
	}

	if !tea.BoolValue(util.IsUnset(request.EnableWaf)) {
		query["EnableWaf"] = request.EnableWaf
	}

	if !tea.BoolValue(util.IsUnset(request.Fallback)) {
		query["Fallback"] = request.Fallback
	}

	if !tea.BoolValue(util.IsUnset(request.FallbackServicesShrink)) {
		query["FallbackServices"] = request.FallbackServicesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Policies)) {
		query["Policies"] = request.Policies
	}

	if !tea.BoolValue(util.IsUnset(request.PredicatesShrink)) {
		query["Predicates"] = request.PredicatesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RedirectJSONShrink)) {
		query["RedirectJSON"] = request.RedirectJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RouteOrder)) {
		query["RouteOrder"] = request.RouteOrder
	}

	if !tea.BoolValue(util.IsUnset(request.RouteType)) {
		query["RouteType"] = request.RouteType
	}

	if !tea.BoolValue(util.IsUnset(request.ServicesShrink)) {
		query["Services"] = request.ServicesShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewayRoute(request *AddGatewayRouteRequest) (_result *AddGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayRouteResponse{}
	_body, _err := client.AddGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayServiceVersionWithOptions(request *AddGatewayServiceVersionRequest, runtime *util.RuntimeOptions) (_result *AddGatewayServiceVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["ServiceVersion"] = request.ServiceVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewayServiceVersion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayServiceVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewayServiceVersion(request *AddGatewayServiceVersionRequest) (_result *AddGatewayServiceVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayServiceVersionResponse{}
	_body, _err := client.AddGatewayServiceVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewaySlbWithOptions(tmpReq *AddGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *AddGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddGatewaySlbShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.VServiceList)) {
		request.VServiceListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.VServiceList, tea.String("VServiceList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.HttpPort)) {
		query["HttpPort"] = request.HttpPort
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsPort)) {
		query["HttpsPort"] = request.HttpsPort
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsVServerGroupId)) {
		query["HttpsVServerGroupId"] = request.HttpsVServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceWeight)) {
		query["ServiceWeight"] = request.ServiceWeight
	}

	if !tea.BoolValue(util.IsUnset(request.SlbId)) {
		query["SlbId"] = request.SlbId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VServiceListShrink)) {
		query["VServiceList"] = request.VServiceListShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewaySlb(request *AddGatewaySlbRequest) (_result *AddGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewaySlbResponse{}
	_body, _err := client.AddGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddMigrationTaskWithOptions(request *AddMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *AddMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceAddress)) {
		query["OriginInstanceAddress"] = request.OriginInstanceAddress
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceName)) {
		query["OriginInstanceName"] = request.OriginInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceNamespace)) {
		query["OriginInstanceNamespace"] = request.OriginInstanceNamespace
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectDesc)) {
		query["ProjectDesc"] = request.ProjectDesc
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterName)) {
		query["TargetClusterName"] = request.TargetClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterUrl)) {
		query["TargetClusterUrl"] = request.TargetClusterUrl
	}

	if !tea.BoolValue(util.IsUnset(request.TargetInstanceId)) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddMigrationTask(request *AddMigrationTaskRequest) (_result *AddMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddMigrationTaskResponse{}
	_body, _err := client.AddMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddMockRuleWithOptions(request *AddMockRuleRequest, runtime *util.RuntimeOptions) (_result *AddMockRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerAppIds)) {
		query["ConsumerAppIds"] = request.ConsumerAppIds
	}

	if !tea.BoolValue(util.IsUnset(request.DubboMockItems)) {
		query["DubboMockItems"] = request.DubboMockItems
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.ExtraJson)) {
		query["ExtraJson"] = request.ExtraJson
	}

	if !tea.BoolValue(util.IsUnset(request.MockType)) {
		query["MockType"] = request.MockType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProviderAppId)) {
		query["ProviderAppId"] = request.ProviderAppId
	}

	if !tea.BoolValue(util.IsUnset(request.ProviderAppName)) {
		query["ProviderAppName"] = request.ProviderAppName
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ScMockItems)) {
		query["ScMockItems"] = request.ScMockItems
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddMockRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddMockRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddMockRule(request *AddMockRuleRequest) (_result *AddMockRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddMockRuleResponse{}
	_body, _err := client.AddMockRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddSSLCertWithOptions(request *AddSSLCertRequest, runtime *util.RuntimeOptions) (_result *AddSSLCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddSSLCert"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddSSLCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddSSLCert(request *AddSSLCertRequest) (_result *AddSSLCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddSSLCertResponse{}
	_body, _err := client.AddSSLCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddSecurityGroupRuleWithOptions(request *AddSecurityGroupRuleRequest, runtime *util.RuntimeOptions) (_result *AddSecurityGroupRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.PortRange)) {
		query["PortRange"] = request.PortRange
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddSecurityGroupRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddSecurityGroupRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddSecurityGroupRule(request *AddSecurityGroupRuleRequest) (_result *AddSecurityGroupRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddSecurityGroupRuleResponse{}
	_body, _err := client.AddSecurityGroupRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddServiceSourceWithOptions(tmpReq *AddServiceSourceRequest, runtime *util.RuntimeOptions) (_result *AddServiceSourceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddServiceSourceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GroupList)) {
		request.GroupListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GroupList, tea.String("GroupList"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.IngressOptionsRequest)) {
		request.IngressOptionsRequestShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.IngressOptionsRequest, tea.String("IngressOptionsRequest"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.PathList)) {
		request.PathListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.PathList, tea.String("PathList"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ToAuthorizeSecurityGroups)) {
		request.ToAuthorizeSecurityGroupsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ToAuthorizeSecurityGroups, tea.String("ToAuthorizeSecurityGroups"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupListShrink)) {
		query["GroupList"] = request.GroupListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.IngressOptionsRequestShrink)) {
		query["IngressOptionsRequest"] = request.IngressOptionsRequestShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PathListShrink)) {
		query["PathList"] = request.PathListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.ToAuthorizeSecurityGroupsShrink)) {
		query["ToAuthorizeSecurityGroups"] = request.ToAuthorizeSecurityGroupsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddServiceSource(request *AddServiceSourceRequest) (_result *AddServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddServiceSourceResponse{}
	_body, _err := client.AddServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyGatewayRouteWithOptions(request *ApplyGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *ApplyGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyGatewayRoute(request *ApplyGatewayRouteRequest) (_result *ApplyGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyGatewayRouteResponse{}
	_body, _err := client.ApplyGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyTagPoliciesWithOptions(tmpReq *ApplyTagPoliciesRequest, runtime *util.RuntimeOptions) (_result *ApplyTagPoliciesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ApplyTagPoliciesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Rules)) {
		request.RulesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Rules, tea.String("Rules"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RulesShrink)) {
		query["Rules"] = request.RulesShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyTagPolicies"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyTagPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyTagPolicies(request *ApplyTagPoliciesRequest) (_result *ApplyTagPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyTagPoliciesResponse{}
	_body, _err := client.ApplyTagPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * mse-200-105
 *
 * @param request CloneNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloneNacosConfigResponse
 */
func (client *Client) CloneNacosConfigWithOptions(request *CloneNacosConfigRequest, runtime *util.RuntimeOptions) (_result *CloneNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OriginNamespaceId)) {
		query["OriginNamespaceId"] = request.OriginNamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Policy)) {
		query["Policy"] = request.Policy
	}

	if !tea.BoolValue(util.IsUnset(request.TargetNamespaceId)) {
		query["TargetNamespaceId"] = request.TargetNamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloneNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloneNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * mse-200-105
 *
 * @param request CloneNacosConfigRequest
 * @return CloneNacosConfigResponse
 */
func (client *Client) CloneNacosConfig(request *CloneNacosConfigRequest) (_result *CloneNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloneNacosConfigResponse{}
	_body, _err := client.CloneNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateApplicationWithOptions(request *CreateApplicationRequest, runtime *util.RuntimeOptions) (_result *CreateApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SentinelEnable)) {
		query["SentinelEnable"] = request.SentinelEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchEnable)) {
		query["SwitchEnable"] = request.SwitchEnable
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateApplication"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateApplication(request *CreateApplicationRequest) (_result *CreateApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateApplicationResponse{}
	_body, _err := client.CreateApplicationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateCircuitBreakerRuleWithOptions(request *CreateCircuitBreakerRuleRequest, runtime *util.RuntimeOptions) (_result *CreateCircuitBreakerRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.HalfOpenBaseAmountPerStep)) {
		query["HalfOpenBaseAmountPerStep"] = request.HalfOpenBaseAmountPerStep
	}

	if !tea.BoolValue(util.IsUnset(request.HalfOpenRecoveryStepNum)) {
		query["HalfOpenRecoveryStepNum"] = request.HalfOpenRecoveryStepNum
	}

	if !tea.BoolValue(util.IsUnset(request.MaxAllowedRtMs)) {
		query["MaxAllowedRtMs"] = request.MaxAllowedRtMs
	}

	if !tea.BoolValue(util.IsUnset(request.MinRequestAmount)) {
		query["MinRequestAmount"] = request.MinRequestAmount
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.RetryTimeoutMs)) {
		query["RetryTimeoutMs"] = request.RetryTimeoutMs
	}

	if !tea.BoolValue(util.IsUnset(request.StatIntervalMs)) {
		query["StatIntervalMs"] = request.StatIntervalMs
	}

	if !tea.BoolValue(util.IsUnset(request.Strategy)) {
		query["Strategy"] = request.Strategy
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCircuitBreakerRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCircuitBreakerRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateCircuitBreakerRule(request *CreateCircuitBreakerRuleRequest) (_result *CreateCircuitBreakerRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCircuitBreakerRuleResponse{}
	_body, _err := client.CreateCircuitBreakerRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this API operation, you must make sure that you fully understand the billing methods and pricing of MSE.
 *
 * @param request CreateClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateClusterResponse
 */
func (client *Client) CreateClusterWithOptions(request *CreateClusterRequest, runtime *util.RuntimeOptions) (_result *CreateClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterSpecification)) {
		query["ClusterSpecification"] = request.ClusterSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterVersion)) {
		query["ClusterVersion"] = request.ClusterVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionType)) {
		query["ConnectionType"] = request.ConnectionType
	}

	if !tea.BoolValue(util.IsUnset(request.DiskType)) {
		query["DiskType"] = request.DiskType
	}

	if !tea.BoolValue(util.IsUnset(request.EipEnabled)) {
		query["EipEnabled"] = request.EipEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceCount)) {
		query["InstanceCount"] = request.InstanceCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.NetType)) {
		query["NetType"] = request.NetType
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateSlbSpecification)) {
		query["PrivateSlbSpecification"] = request.PrivateSlbSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.PubNetworkFlow)) {
		query["PubNetworkFlow"] = request.PubNetworkFlow
	}

	if !tea.BoolValue(util.IsUnset(request.PubSlbSpecification)) {
		query["PubSlbSpecification"] = request.PubSlbSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupType)) {
		query["SecurityGroupType"] = request.SecurityGroupType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this API operation, you must make sure that you fully understand the billing methods and pricing of MSE.
 *
 * @param request CreateClusterRequest
 * @return CreateClusterResponse
 */
func (client *Client) CreateCluster(request *CreateClusterRequest) (_result *CreateClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateClusterResponse{}
	_body, _err := client.CreateClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEngineNamespaceWithOptions(request *CreateEngineNamespaceRequest, runtime *util.RuntimeOptions) (_result *CreateEngineNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceCount)) {
		query["ServiceCount"] = request.ServiceCount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEngineNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEngineNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEngineNamespace(request *CreateEngineNamespaceRequest) (_result *CreateEngineNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEngineNamespaceResponse{}
	_body, _err := client.CreateEngineNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateFlowRuleWithOptions(request *CreateFlowRuleRequest, runtime *util.RuntimeOptions) (_result *CreateFlowRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.ControlBehavior)) {
		query["ControlBehavior"] = request.ControlBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.MaxQueueingTimeMs)) {
		query["MaxQueueingTimeMs"] = request.MaxQueueingTimeMs
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateFlowRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateFlowRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateFlowRule(request *CreateFlowRuleRequest) (_result *CreateFlowRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateFlowRuleResponse{}
	_body, _err := client.CreateFlowRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : CreateMseServiceApplication is deprecated, please use mse::2019-05-31::CreateApplication instead.
 *
 * @param request CreateMseServiceApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMseServiceApplicationResponse
 */
// Deprecated
func (client *Client) CreateMseServiceApplicationWithOptions(request *CreateMseServiceApplicationRequest, runtime *util.RuntimeOptions) (_result *CreateMseServiceApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.ExtraInfo)) {
		query["ExtraInfo"] = request.ExtraInfo
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SentinelEnable)) {
		query["SentinelEnable"] = request.SentinelEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchEnable)) {
		query["SwitchEnable"] = request.SwitchEnable
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMseServiceApplication"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateMseServiceApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : CreateMseServiceApplication is deprecated, please use mse::2019-05-31::CreateApplication instead.
 *
 * @param request CreateMseServiceApplicationRequest
 * @return CreateMseServiceApplicationResponse
 */
// Deprecated
func (client *Client) CreateMseServiceApplication(request *CreateMseServiceApplicationRequest) (_result *CreateMseServiceApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateMseServiceApplicationResponse{}
	_body, _err := client.CreateMseServiceApplicationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNacosConfigResponse
 */
func (client *Client) CreateNacosConfigWithOptions(request *CreateNacosConfigRequest, runtime *util.RuntimeOptions) (_result *CreateNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.BetaIps)) {
		query["BetaIps"] = request.BetaIps
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosConfigRequest
 * @return CreateNacosConfigResponse
 */
func (client *Client) CreateNacosConfig(request *CreateNacosConfigRequest) (_result *CreateNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNacosConfigResponse{}
	_body, _err := client.CreateNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNacosInstanceResponse
 */
func (client *Client) CreateNacosInstanceWithOptions(request *CreateNacosInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateNacosInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Metadata)) {
		body["Metadata"] = request.Metadata
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNacosInstance"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNacosInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosInstanceRequest
 * @return CreateNacosInstanceResponse
 */
func (client *Client) CreateNacosInstance(request *CreateNacosInstanceRequest) (_result *CreateNacosInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNacosInstanceResponse{}
	_body, _err := client.CreateNacosInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNacosServiceResponse
 */
func (client *Client) CreateNacosServiceWithOptions(request *CreateNacosServiceRequest, runtime *util.RuntimeOptions) (_result *CreateNacosServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectThreshold)) {
		query["ProtectThreshold"] = request.ProtectThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNacosService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNacosServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosServiceRequest
 * @return CreateNacosServiceResponse
 */
func (client *Client) CreateNacosService(request *CreateNacosServiceRequest) (_result *CreateNacosServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNacosServiceResponse{}
	_body, _err := client.CreateNacosServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLaneWithOptions(tmpReq *CreateOrUpdateSwimmingLaneRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateOrUpdateSwimmingLaneShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GatewaySwimmingLaneRouteJson)) {
		request.GatewaySwimmingLaneRouteJsonShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GatewaySwimmingLaneRouteJson, tea.String("GatewaySwimmingLaneRouteJson"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.EnableRules)) {
		query["EnableRules"] = request.EnableRules
	}

	if !tea.BoolValue(util.IsUnset(request.EntryRule)) {
		query["EntryRule"] = request.EntryRule
	}

	if !tea.BoolValue(util.IsUnset(request.GatewaySwimmingLaneRouteJsonShrink)) {
		query["GatewaySwimmingLaneRouteJson"] = request.GatewaySwimmingLaneRouteJsonShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EntryRules)) {
		body["EntryRules"] = request.EntryRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateSwimmingLane"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLane(request *CreateOrUpdateSwimmingLaneRequest) (_result *CreateOrUpdateSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateSwimmingLaneResponse{}
	_body, _err := client.CreateOrUpdateSwimmingLaneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLaneGroupWithOptions(request *CreateOrUpdateSwimmingLaneGroupRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	if !tea.BoolValue(util.IsUnset(request.DbGrayEnable)) {
		query["DbGrayEnable"] = request.DbGrayEnable
	}

	if !tea.BoolValue(util.IsUnset(request.EntryApp)) {
		query["EntryApp"] = request.EntryApp
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.MessageQueueFilterSide)) {
		query["MessageQueueFilterSide"] = request.MessageQueueFilterSide
	}

	if !tea.BoolValue(util.IsUnset(request.MessageQueueGrayEnable)) {
		query["MessageQueueGrayEnable"] = request.MessageQueueGrayEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RecordCanaryDetail)) {
		query["RecordCanaryDetail"] = request.RecordCanaryDetail
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateSwimmingLaneGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLaneGroup(request *CreateOrUpdateSwimmingLaneGroupRequest) (_result *CreateOrUpdateSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateSwimmingLaneGroupResponse{}
	_body, _err := client.CreateOrUpdateSwimmingLaneGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateZnodeWithOptions(request *CreateZnodeRequest, runtime *util.RuntimeOptions) (_result *CreateZnodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		query["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateZnode"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateZnodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateZnode(request *CreateZnodeRequest) (_result *CreateZnodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateZnodeResponse{}
	_body, _err := client.CreateZnodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAuthResourceWithOptions(request *DeleteAuthResourceRequest, runtime *util.RuntimeOptions) (_result *DeleteAuthResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAuthResource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAuthResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAuthResource(request *DeleteAuthResourceRequest) (_result *DeleteAuthResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAuthResourceResponse{}
	_body, _err := client.DeleteAuthResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCircuitBreakerRulesWithOptions(tmpReq *DeleteCircuitBreakerRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteCircuitBreakerRulesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DeleteCircuitBreakerRulesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Ids)) {
		request.IdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Ids, tea.String("Ids"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.IdsShrink)) {
		query["Ids"] = request.IdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCircuitBreakerRules"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCircuitBreakerRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCircuitBreakerRules(request *DeleteCircuitBreakerRulesRequest) (_result *DeleteCircuitBreakerRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCircuitBreakerRulesResponse{}
	_body, _err := client.DeleteCircuitBreakerRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteClusterWithOptions(request *DeleteClusterRequest, runtime *util.RuntimeOptions) (_result *DeleteClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCluster(request *DeleteClusterRequest) (_result *DeleteClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteClusterResponse{}
	_body, _err := client.DeleteClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEngineNamespaceWithOptions(request *DeleteEngineNamespaceRequest, runtime *util.RuntimeOptions) (_result *DeleteEngineNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEngineNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEngineNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEngineNamespace(request *DeleteEngineNamespaceRequest) (_result *DeleteEngineNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEngineNamespaceResponse{}
	_body, _err := client.DeleteEngineNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteFlowRulesWithOptions(tmpReq *DeleteFlowRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteFlowRulesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DeleteFlowRulesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Ids)) {
		request.IdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Ids, tea.String("Ids"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.IdsShrink)) {
		query["Ids"] = request.IdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFlowRules"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFlowRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteFlowRules(request *DeleteFlowRulesRequest) (_result *DeleteFlowRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFlowRulesResponse{}
	_body, _err := client.DeleteFlowRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayWithOptions(request *DeleteGatewayRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteSlb)) {
		query["DeleteSlb"] = request.DeleteSlb
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGateway(request *DeleteGatewayRequest) (_result *DeleteGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayResponse{}
	_body, _err := client.DeleteGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayAuthConsumerWithOptions(request *DeleteGatewayAuthConsumerRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayAuthConsumerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayAuthConsumer"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayAuthConsumerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayAuthConsumer(request *DeleteGatewayAuthConsumerRequest) (_result *DeleteGatewayAuthConsumerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayAuthConsumerResponse{}
	_body, _err := client.DeleteGatewayAuthConsumerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayAuthConsumerResourceWithOptions(request *DeleteGatewayAuthConsumerResourceRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayAuthConsumerResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerId)) {
		query["ConsumerId"] = request.ConsumerId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IdList)) {
		query["IdList"] = request.IdList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayAuthConsumerResource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayAuthConsumerResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayAuthConsumerResource(request *DeleteGatewayAuthConsumerResourceRequest) (_result *DeleteGatewayAuthConsumerResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayAuthConsumerResourceResponse{}
	_body, _err := client.DeleteGatewayAuthConsumerResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayDomainWithOptions(request *DeleteGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayDomain(request *DeleteGatewayDomainRequest) (_result *DeleteGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayDomainResponse{}
	_body, _err := client.DeleteGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayRouteWithOptions(request *DeleteGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayRoute(request *DeleteGatewayRouteRequest) (_result *DeleteGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayRouteResponse{}
	_body, _err := client.DeleteGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayServiceWithOptions(request *DeleteGatewayServiceRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayService(request *DeleteGatewayServiceRequest) (_result *DeleteGatewayServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayServiceResponse{}
	_body, _err := client.DeleteGatewayServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayServiceVersionWithOptions(request *DeleteGatewayServiceVersionRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayServiceVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["ServiceVersion"] = request.ServiceVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayServiceVersion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayServiceVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayServiceVersion(request *DeleteGatewayServiceVersionRequest) (_result *DeleteGatewayServiceVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayServiceVersionResponse{}
	_body, _err := client.DeleteGatewayServiceVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewaySlbWithOptions(request *DeleteGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteSlb)) {
		query["DeleteSlb"] = request.DeleteSlb
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.SlbId)) {
		query["SlbId"] = request.SlbId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewaySlb(request *DeleteGatewaySlbRequest) (_result *DeleteGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewaySlbResponse{}
	_body, _err := client.DeleteGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteMigrationTaskWithOptions(request *DeleteMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteMigrationTask(request *DeleteMigrationTaskRequest) (_result *DeleteMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMigrationTaskResponse{}
	_body, _err := client.DeleteMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteNacosConfigWithOptions(request *DeleteNacosConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Beta)) {
		query["Beta"] = request.Beta
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteNacosConfig(request *DeleteNacosConfigRequest) (_result *DeleteNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosConfigResponse{}
	_body, _err := client.DeleteNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The current API operation is not provided in Nacos SDK. For more information about the Nacos-SDK API, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNacosConfigsResponse
 */
func (client *Client) DeleteNacosConfigsWithOptions(request *DeleteNacosConfigsRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosConfigs"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The current API operation is not provided in Nacos SDK. For more information about the Nacos-SDK API, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosConfigsRequest
 * @return DeleteNacosConfigsResponse
 */
func (client *Client) DeleteNacosConfigs(request *DeleteNacosConfigsRequest) (_result *DeleteNacosConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosConfigsResponse{}
	_body, _err := client.DeleteNacosConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNacosInstanceResponse
 */
func (client *Client) DeleteNacosInstanceWithOptions(request *DeleteNacosInstanceRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosInstance"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosInstanceRequest
 * @return DeleteNacosInstanceResponse
 */
func (client *Client) DeleteNacosInstance(request *DeleteNacosInstanceRequest) (_result *DeleteNacosInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosInstanceResponse{}
	_body, _err := client.DeleteNacosInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNacosServiceResponse
 */
func (client *Client) DeleteNacosServiceWithOptions(request *DeleteNacosServiceRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosServiceRequest
 * @return DeleteNacosServiceResponse
 */
func (client *Client) DeleteNacosService(request *DeleteNacosServiceRequest) (_result *DeleteNacosServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosServiceResponse{}
	_body, _err := client.DeleteNacosServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteNamespaceWithOptions(request *DeleteNamespaceRequest, runtime *util.RuntimeOptions) (_result *DeleteNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteNamespace(request *DeleteNamespaceRequest) (_result *DeleteNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNamespaceResponse{}
	_body, _err := client.DeleteNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSecurityGroupRuleWithOptions(request *DeleteSecurityGroupRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteSecurityGroupRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CascadingDelete)) {
		query["CascadingDelete"] = request.CascadingDelete
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSecurityGroupRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSecurityGroupRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSecurityGroupRule(request *DeleteSecurityGroupRuleRequest) (_result *DeleteSecurityGroupRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSecurityGroupRuleResponse{}
	_body, _err := client.DeleteSecurityGroupRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteServiceSourceWithOptions(request *DeleteServiceSourceRequest, runtime *util.RuntimeOptions) (_result *DeleteServiceSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceId)) {
		query["SourceId"] = request.SourceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteServiceSource(request *DeleteServiceSourceRequest) (_result *DeleteServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteServiceSourceResponse{}
	_body, _err := client.DeleteServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSwimmingLaneWithOptions(request *DeleteSwimmingLaneRequest, runtime *util.RuntimeOptions) (_result *DeleteSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.LaneId)) {
		query["LaneId"] = request.LaneId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSwimmingLane"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSwimmingLane(request *DeleteSwimmingLaneRequest) (_result *DeleteSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSwimmingLaneResponse{}
	_body, _err := client.DeleteSwimmingLaneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSwimmingLaneGroupWithOptions(request *DeleteSwimmingLaneGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSwimmingLaneGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSwimmingLaneGroup(request *DeleteSwimmingLaneGroupRequest) (_result *DeleteSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSwimmingLaneGroupResponse{}
	_body, _err := client.DeleteSwimmingLaneGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteZnodeWithOptions(request *DeleteZnodeRequest, runtime *util.RuntimeOptions) (_result *DeleteZnodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteZnode"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteZnodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteZnode(request *DeleteZnodeRequest) (_result *DeleteZnodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteZnodeResponse{}
	_body, _err := client.DeleteZnodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ExportNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportNacosConfigResponse
 */
func (client *Client) ExportNacosConfigWithOptions(request *ExportNacosConfigRequest, runtime *util.RuntimeOptions) (_result *ExportNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.DataIds)) {
		query["DataIds"] = request.DataIds
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ExportNacosConfigRequest
 * @return ExportNacosConfigResponse
 */
func (client *Client) ExportNacosConfig(request *ExportNacosConfigRequest) (_result *ExportNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportNacosConfigResponse{}
	_body, _err := client.ExportNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Only one task can run at a time.
 *
 * @param request ExportZookeeperDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportZookeeperDataResponse
 */
func (client *Client) ExportZookeeperDataWithOptions(request *ExportZookeeperDataRequest, runtime *util.RuntimeOptions) (_result *ExportZookeeperDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ExportType)) {
		query["ExportType"] = request.ExportType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportZookeeperData"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportZookeeperDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Only one task can run at a time.
 *
 * @param request ExportZookeeperDataRequest
 * @return ExportZookeeperDataResponse
 */
func (client *Client) ExportZookeeperData(request *ExportZookeeperDataRequest) (_result *ExportZookeeperDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportZookeeperDataResponse{}
	_body, _err := client.ExportZookeeperDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query the rules for graceful start and shutdown.
 *
 * @param request FetchLosslessRuleListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FetchLosslessRuleListResponse
 */
func (client *Client) FetchLosslessRuleListWithOptions(request *FetchLosslessRuleListRequest, runtime *util.RuntimeOptions) (_result *FetchLosslessRuleListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("FetchLosslessRuleList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &FetchLosslessRuleListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query the rules for graceful start and shutdown.
 *
 * @param request FetchLosslessRuleListRequest
 * @return FetchLosslessRuleListResponse
 */
func (client *Client) FetchLosslessRuleList(request *FetchLosslessRuleListRequest) (_result *FetchLosslessRuleListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &FetchLosslessRuleListResponse{}
	_body, _err := client.FetchLosslessRuleListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAppMessageQueueRouteWithOptions(request *GetAppMessageQueueRouteRequest, runtime *util.RuntimeOptions) (_result *GetAppMessageQueueRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppMessageQueueRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppMessageQueueRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAppMessageQueueRoute(request *GetAppMessageQueueRouteRequest) (_result *GetAppMessageQueueRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAppMessageQueueRouteResponse{}
	_body, _err := client.GetAppMessageQueueRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetApplicationInstanceListWithOptions(request *GetApplicationInstanceListRequest, runtime *util.RuntimeOptions) (_result *GetApplicationInstanceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetApplicationInstanceList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetApplicationInstanceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetApplicationInstanceList(request *GetApplicationInstanceListRequest) (_result *GetApplicationInstanceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetApplicationInstanceListResponse{}
	_body, _err := client.GetApplicationInstanceListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetApplicationListWithOptions(request *GetApplicationListRequest, runtime *util.RuntimeOptions) (_result *GetApplicationListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SentinelEnable)) {
		query["SentinelEnable"] = request.SentinelEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchEnable)) {
		query["SwitchEnable"] = request.SwitchEnable
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetApplicationList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetApplicationListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetApplicationList(request *GetApplicationListRequest) (_result *GetApplicationListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetApplicationListResponse{}
	_body, _err := client.GetApplicationListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBlackWhiteListWithOptions(request *GetBlackWhiteListRequest, runtime *util.RuntimeOptions) (_result *GetBlackWhiteListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IsWhite)) {
		query["IsWhite"] = request.IsWhite
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBlackWhiteList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBlackWhiteListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBlackWhiteList(request *GetBlackWhiteListRequest) (_result *GetBlackWhiteListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBlackWhiteListResponse{}
	_body, _err := client.GetBlackWhiteListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetEngineNamepaceWithOptions(request *GetEngineNamepaceRequest, runtime *util.RuntimeOptions) (_result *GetEngineNamepaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEngineNamepace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEngineNamepaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetEngineNamepace(request *GetEngineNamepaceRequest) (_result *GetEngineNamepaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEngineNamepaceResponse{}
	_body, _err := client.GetEngineNamepaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayWithOptions(request *GetGatewayRequest, runtime *util.RuntimeOptions) (_result *GetGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGateway(request *GetGatewayRequest) (_result *GetGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayResponse{}
	_body, _err := client.GetGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayAuthConsumerDetailWithOptions(request *GetGatewayAuthConsumerDetailRequest, runtime *util.RuntimeOptions) (_result *GetGatewayAuthConsumerDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayAuthConsumerDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayAuthConsumerDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayAuthConsumerDetail(request *GetGatewayAuthConsumerDetailRequest) (_result *GetGatewayAuthConsumerDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayAuthConsumerDetailResponse{}
	_body, _err := client.GetGatewayAuthConsumerDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayDomainDetailWithOptions(request *GetGatewayDomainDetailRequest, runtime *util.RuntimeOptions) (_result *GetGatewayDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayDomainDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayDomainDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayDomainDetail(request *GetGatewayDomainDetailRequest) (_result *GetGatewayDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayDomainDetailResponse{}
	_body, _err := client.GetGatewayDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayOptionWithOptions(request *GetGatewayOptionRequest, runtime *util.RuntimeOptions) (_result *GetGatewayOptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayOption"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayOptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayOption(request *GetGatewayOptionRequest) (_result *GetGatewayOptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayOptionResponse{}
	_body, _err := client.GetGatewayOptionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayRouteDetailWithOptions(request *GetGatewayRouteDetailRequest, runtime *util.RuntimeOptions) (_result *GetGatewayRouteDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayRouteDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayRouteDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayRouteDetail(request *GetGatewayRouteDetailRequest) (_result *GetGatewayRouteDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayRouteDetailResponse{}
	_body, _err := client.GetGatewayRouteDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayServiceDetailWithOptions(request *GetGatewayServiceDetailRequest, runtime *util.RuntimeOptions) (_result *GetGatewayServiceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayServiceDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayServiceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayServiceDetail(request *GetGatewayServiceDetailRequest) (_result *GetGatewayServiceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayServiceDetailResponse{}
	_body, _err := client.GetGatewayServiceDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGovernanceKubernetesClusterWithOptions(request *GetGovernanceKubernetesClusterRequest, runtime *util.RuntimeOptions) (_result *GetGovernanceKubernetesClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGovernanceKubernetesCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGovernanceKubernetesClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGovernanceKubernetesCluster(request *GetGovernanceKubernetesClusterRequest) (_result *GetGovernanceKubernetesClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGovernanceKubernetesClusterResponse{}
	_body, _err := client.GetGovernanceKubernetesClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetImageWithOptions(request *GetImageRequest, runtime *util.RuntimeOptions) (_result *GetImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.VersionCode)) {
		query["VersionCode"] = request.VersionCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImage"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetImage(request *GetImageRequest) (_result *GetImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImageResponse{}
	_body, _err := client.GetImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).\\n
 *
 * @param request GetImportFileUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImportFileUrlResponse
 */
func (client *Client) GetImportFileUrlWithOptions(request *GetImportFileUrlRequest, runtime *util.RuntimeOptions) (_result *GetImportFileUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ContentType)) {
		query["ContentType"] = request.ContentType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImportFileUrl"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetImportFileUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).\\n
 *
 * @param request GetImportFileUrlRequest
 * @return GetImportFileUrlResponse
 */
func (client *Client) GetImportFileUrl(request *GetImportFileUrlRequest) (_result *GetImportFileUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImportFileUrlResponse{}
	_body, _err := client.GetImportFileUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetKubernetesSourceWithOptions(request *GetKubernetesSourceRequest, runtime *util.RuntimeOptions) (_result *GetKubernetesSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IsAll)) {
		query["IsAll"] = request.IsAll
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetKubernetesSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetKubernetesSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetKubernetesSource(request *GetKubernetesSourceRequest) (_result *GetKubernetesSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetKubernetesSourceResponse{}
	_body, _err := client.GetKubernetesSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query the rules for graceful start and shutdown of an application.
 * You can query the rules for graceful start and shutdown of an application preferentially by using the AppId parameter.
 * If the AppId parameter is left empty, you can use the RegionId, Namespace, and AppName parameters to query the rules for graceful start and shutdown of an application.
 *
 * @param request GetLosslessRuleByAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLosslessRuleByAppResponse
 */
func (client *Client) GetLosslessRuleByAppWithOptions(request *GetLosslessRuleByAppRequest, runtime *util.RuntimeOptions) (_result *GetLosslessRuleByAppResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetLosslessRuleByApp"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLosslessRuleByAppResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query the rules for graceful start and shutdown of an application.
 * You can query the rules for graceful start and shutdown of an application preferentially by using the AppId parameter.
 * If the AppId parameter is left empty, you can use the RegionId, Namespace, and AppName parameters to query the rules for graceful start and shutdown of an application.
 *
 * @param request GetLosslessRuleByAppRequest
 * @return GetLosslessRuleByAppResponse
 */
func (client *Client) GetLosslessRuleByApp(request *GetLosslessRuleByAppRequest) (_result *GetLosslessRuleByAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetLosslessRuleByAppResponse{}
	_body, _err := client.GetLosslessRuleByAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMseFeatureSwitchWithOptions(request *GetMseFeatureSwitchRequest, runtime *util.RuntimeOptions) (_result *GetMseFeatureSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMseFeatureSwitch"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMseFeatureSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMseFeatureSwitch(request *GetMseFeatureSwitchRequest) (_result *GetMseFeatureSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMseFeatureSwitchResponse{}
	_body, _err := client.GetMseFeatureSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMseSourceWithOptions(request *GetMseSourceRequest, runtime *util.RuntimeOptions) (_result *GetMseSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMseSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMseSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMseSource(request *GetMseSourceRequest) (_result *GetMseSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMseSourceResponse{}
	_body, _err := client.GetMseSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNacosConfigResponse
 */
func (client *Client) GetNacosConfigWithOptions(request *GetNacosConfigRequest, runtime *util.RuntimeOptions) (_result *GetNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Beta)) {
		query["Beta"] = request.Beta
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosConfigRequest
 * @return GetNacosConfigResponse
 */
func (client *Client) GetNacosConfig(request *GetNacosConfigRequest) (_result *GetNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNacosConfigResponse{}
	_body, _err := client.GetNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosHistoryConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNacosHistoryConfigResponse
 */
func (client *Client) GetNacosHistoryConfigWithOptions(request *GetNacosHistoryConfigRequest, runtime *util.RuntimeOptions) (_result *GetNacosHistoryConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Nid)) {
		query["Nid"] = request.Nid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNacosHistoryConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNacosHistoryConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosHistoryConfigRequest
 * @return GetNacosHistoryConfigResponse
 */
func (client *Client) GetNacosHistoryConfig(request *GetNacosHistoryConfigRequest) (_result *GetNacosHistoryConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNacosHistoryConfigResponse{}
	_body, _err := client.GetNacosHistoryConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query overview information about service governance.
 *
 * @param request GetOverviewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOverviewResponse
 */
func (client *Client) GetOverviewWithOptions(request *GetOverviewRequest, runtime *util.RuntimeOptions) (_result *GetOverviewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOverview"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOverviewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query overview information about service governance.
 *
 * @param request GetOverviewRequest
 * @return GetOverviewResponse
 */
func (client *Client) GetOverview(request *GetOverviewRequest) (_result *GetOverviewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOverviewResponse{}
	_body, _err := client.GetOverviewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPluginConfigWithOptions(request *GetPluginConfigRequest, runtime *util.RuntimeOptions) (_result *GetPluginConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.PluginId)) {
		query["PluginId"] = request.PluginId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPluginConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPluginConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPluginConfig(request *GetPluginConfigRequest) (_result *GetPluginConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPluginConfigResponse{}
	_body, _err := client.GetPluginConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPluginsWithOptions(request *GetPluginsRequest, runtime *util.RuntimeOptions) (_result *GetPluginsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.EnableOnly)) {
		query["EnableOnly"] = request.EnableOnly
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPlugins"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPluginsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPlugins(request *GetPluginsRequest) (_result *GetPluginsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPluginsResponse{}
	_body, _err := client.GetPluginsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceListWithOptions(request *GetServiceListRequest, runtime *util.RuntimeOptions) (_result *GetServiceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceList(request *GetServiceListRequest) (_result *GetServiceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetServiceListResponse{}
	_body, _err := client.GetServiceListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceListPageWithOptions(request *GetServiceListPageRequest, runtime *util.RuntimeOptions) (_result *GetServiceListPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceListPage"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceListPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceListPage(request *GetServiceListPageRequest) (_result *GetServiceListPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetServiceListPageResponse{}
	_body, _err := client.GetServiceListPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceListenersWithOptions(request *GetServiceListenersRequest, runtime *util.RuntimeOptions) (_result *GetServiceListenersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.HasIpCount)) {
		query["HasIpCount"] = request.HasIpCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceListeners"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceListenersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceListeners(request *GetServiceListenersRequest) (_result *GetServiceListenersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetServiceListenersResponse{}
	_body, _err := client.GetServiceListenersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceMethodPageWithOptions(request *GetServiceMethodPageRequest, runtime *util.RuntimeOptions) (_result *GetServiceMethodPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.MethodController)) {
		query["MethodController"] = request.MethodController
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceGroup)) {
		query["ServiceGroup"] = request.ServiceGroup
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["ServiceVersion"] = request.ServiceVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceMethodPage"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceMethodPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceMethodPage(request *GetServiceMethodPageRequest) (_result *GetServiceMethodPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetServiceMethodPageResponse{}
	_body, _err := client.GetServiceMethodPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTagsBySwimmingLaneGroupIdWithOptions(request *GetTagsBySwimmingLaneGroupIdRequest, runtime *util.RuntimeOptions) (_result *GetTagsBySwimmingLaneGroupIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTagsBySwimmingLaneGroupId"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTagsBySwimmingLaneGroupIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTagsBySwimmingLaneGroupId(request *GetTagsBySwimmingLaneGroupIdRequest) (_result *GetTagsBySwimmingLaneGroupIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTagsBySwimmingLaneGroupIdResponse{}
	_body, _err := client.GetTagsBySwimmingLaneGroupIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetZookeeperDataImportUrlWithOptions(request *GetZookeeperDataImportUrlRequest, runtime *util.RuntimeOptions) (_result *GetZookeeperDataImportUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ContentType)) {
		query["ContentType"] = request.ContentType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetZookeeperDataImportUrl"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetZookeeperDataImportUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetZookeeperDataImportUrl(request *GetZookeeperDataImportUrlRequest) (_result *GetZookeeperDataImportUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetZookeeperDataImportUrlResponse{}
	_body, _err := client.GetZookeeperDataImportUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ImportNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportNacosConfigResponse
 */
func (client *Client) ImportNacosConfigWithOptions(request *ImportNacosConfigRequest, runtime *util.RuntimeOptions) (_result *ImportNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.FileUrl)) {
		query["FileUrl"] = request.FileUrl
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Policy)) {
		query["Policy"] = request.Policy
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ImportNacosConfigRequest
 * @return ImportNacosConfigResponse
 */
func (client *Client) ImportNacosConfig(request *ImportNacosConfigRequest) (_result *ImportNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportNacosConfigResponse{}
	_body, _err := client.ImportNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ImportServicesWithOptions(tmpReq *ImportServicesRequest, runtime *util.RuntimeOptions) (_result *ImportServicesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ImportServicesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ServiceList)) {
		request.ServiceListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ServiceList, tea.String("ServiceList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.FcAlias)) {
		query["FcAlias"] = request.FcAlias
	}

	if !tea.BoolValue(util.IsUnset(request.FcServiceName)) {
		query["FcServiceName"] = request.FcServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.FcVersion)) {
		query["FcVersion"] = request.FcVersion
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceListShrink)) {
		query["ServiceList"] = request.ServiceListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TlsSetting)) {
		query["TlsSetting"] = request.TlsSetting
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ImportServices(request *ImportServicesRequest) (_result *ImportServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportServicesResponse{}
	_body, _err := client.ImportServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **Danger** This operation clears existing data. Exercise caution when you call this API operation.
 *
 * @param request ImportZookeeperDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportZookeeperDataResponse
 */
func (client *Client) ImportZookeeperDataWithOptions(request *ImportZookeeperDataRequest, runtime *util.RuntimeOptions) (_result *ImportZookeeperDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileUrl)) {
		query["FileUrl"] = request.FileUrl
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportZookeeperData"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportZookeeperDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **Danger** This operation clears existing data. Exercise caution when you call this API operation.
 *
 * @param request ImportZookeeperDataRequest
 * @return ImportZookeeperDataResponse
 */
func (client *Client) ImportZookeeperData(request *ImportZookeeperDataRequest) (_result *ImportZookeeperDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportZookeeperDataResponse{}
	_body, _err := client.ImportZookeeperDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnsInstancesResponse
 */
func (client *Client) ListAnsInstancesWithOptions(request *ListAnsInstancesRequest, runtime *util.RuntimeOptions) (_result *ListAnsInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnsInstances"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnsInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsInstancesRequest
 * @return ListAnsInstancesResponse
 */
func (client *Client) ListAnsInstances(request *ListAnsInstancesRequest) (_result *ListAnsInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAnsInstancesResponse{}
	_body, _err := client.ListAnsInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServiceClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnsServiceClustersResponse
 */
func (client *Client) ListAnsServiceClustersWithOptions(request *ListAnsServiceClustersRequest, runtime *util.RuntimeOptions) (_result *ListAnsServiceClustersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnsServiceClusters"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnsServiceClustersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServiceClustersRequest
 * @return ListAnsServiceClustersResponse
 */
func (client *Client) ListAnsServiceClusters(request *ListAnsServiceClustersRequest) (_result *ListAnsServiceClustersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAnsServiceClustersResponse{}
	_body, _err := client.ListAnsServiceClustersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnsServicesResponse
 */
func (client *Client) ListAnsServicesWithOptions(request *ListAnsServicesRequest, runtime *util.RuntimeOptions) (_result *ListAnsServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.HasIpCount)) {
		query["HasIpCount"] = request.HasIpCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnsServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnsServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServicesRequest
 * @return ListAnsServicesResponse
 */
func (client *Client) ListAnsServices(request *ListAnsServicesRequest) (_result *ListAnsServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAnsServicesResponse{}
	_body, _err := client.ListAnsServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : ListAppBySwimmingLaneGroupTag is deprecated, please use mse::2019-05-31::ListAppBySwimmingLaneGroupTags instead.
 *
 * @param request ListAppBySwimmingLaneGroupTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAppBySwimmingLaneGroupTagResponse
 */
// Deprecated
func (client *Client) ListAppBySwimmingLaneGroupTagWithOptions(request *ListAppBySwimmingLaneGroupTagRequest, runtime *util.RuntimeOptions) (_result *ListAppBySwimmingLaneGroupTagResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAppBySwimmingLaneGroupTag"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAppBySwimmingLaneGroupTagResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : ListAppBySwimmingLaneGroupTag is deprecated, please use mse::2019-05-31::ListAppBySwimmingLaneGroupTags instead.
 *
 * @param request ListAppBySwimmingLaneGroupTagRequest
 * @return ListAppBySwimmingLaneGroupTagResponse
 */
// Deprecated
func (client *Client) ListAppBySwimmingLaneGroupTag(request *ListAppBySwimmingLaneGroupTagRequest) (_result *ListAppBySwimmingLaneGroupTagResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAppBySwimmingLaneGroupTagResponse{}
	_body, _err := client.ListAppBySwimmingLaneGroupTagWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAppBySwimmingLaneGroupTagsWithOptions(tmpReq *ListAppBySwimmingLaneGroupTagsRequest, runtime *util.RuntimeOptions) (_result *ListAppBySwimmingLaneGroupTagsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListAppBySwimmingLaneGroupTagsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAppBySwimmingLaneGroupTags"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAppBySwimmingLaneGroupTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAppBySwimmingLaneGroupTags(request *ListAppBySwimmingLaneGroupTagsRequest) (_result *ListAppBySwimmingLaneGroupTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAppBySwimmingLaneGroupTagsResponse{}
	_body, _err := client.ListAppBySwimmingLaneGroupTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListApplicationsWithTagRulesWithOptions(request *ListApplicationsWithTagRulesRequest, runtime *util.RuntimeOptions) (_result *ListApplicationsWithTagRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListApplicationsWithTagRules"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListApplicationsWithTagRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListApplicationsWithTagRules(request *ListApplicationsWithTagRulesRequest) (_result *ListApplicationsWithTagRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListApplicationsWithTagRulesResponse{}
	_body, _err := client.ListApplicationsWithTagRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAuthPolicyWithOptions(request *ListAuthPolicyRequest, runtime *util.RuntimeOptions) (_result *ListAuthPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAuthPolicy"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAuthPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAuthPolicy(request *ListAuthPolicyRequest) (_result *ListAuthPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAuthPolicyResponse{}
	_body, _err := client.ListAuthPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCircuitBreakerRulesWithOptions(request *ListCircuitBreakerRulesRequest, runtime *util.RuntimeOptions) (_result *ListCircuitBreakerRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageIndex)) {
		query["PageIndex"] = request.PageIndex
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceSearchKey)) {
		query["ResourceSearchKey"] = request.ResourceSearchKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCircuitBreakerRules"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCircuitBreakerRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCircuitBreakerRules(request *ListCircuitBreakerRulesRequest) (_result *ListCircuitBreakerRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCircuitBreakerRulesResponse{}
	_body, _err := client.ListCircuitBreakerRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterConnectionTypesWithOptions(request *ListClusterConnectionTypesRequest, runtime *util.RuntimeOptions) (_result *ListClusterConnectionTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterConnectionTypes"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterConnectionTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterConnectionTypes(request *ListClusterConnectionTypesRequest) (_result *ListClusterConnectionTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterConnectionTypesResponse{}
	_body, _err := client.ListClusterConnectionTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterHealthCheckTaskWithOptions(request *ListClusterHealthCheckTaskRequest, runtime *util.RuntimeOptions) (_result *ListClusterHealthCheckTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterHealthCheckTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterHealthCheckTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterHealthCheckTask(request *ListClusterHealthCheckTaskRequest) (_result *ListClusterHealthCheckTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterHealthCheckTaskResponse{}
	_body, _err := client.ListClusterHealthCheckTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterTypesWithOptions(request *ListClusterTypesRequest, runtime *util.RuntimeOptions) (_result *ListClusterTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectType)) {
		query["ConnectType"] = request.ConnectType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterTypes"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterTypes(request *ListClusterTypesRequest) (_result *ListClusterTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterTypesResponse{}
	_body, _err := client.ListClusterTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterVersionsWithOptions(request *ListClusterVersionsRequest, runtime *util.RuntimeOptions) (_result *ListClusterVersionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterVersions"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterVersionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterVersions(request *ListClusterVersionsRequest) (_result *ListClusterVersionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterVersionsResponse{}
	_body, _err := client.ListClusterVersionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClustersWithOptions(request *ListClustersRequest, runtime *util.RuntimeOptions) (_result *ListClustersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterAliasName)) {
		query["ClusterAliasName"] = request.ClusterAliasName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusters"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClustersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusters(request *ListClustersRequest) (_result *ListClustersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClustersResponse{}
	_body, _err := client.ListClustersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListConfigTrackWithOptions(request *ListConfigTrackRequest, runtime *util.RuntimeOptions) (_result *ListConfigTrackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTs)) {
		query["EndTs"] = request.EndTs
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.Reverse)) {
		query["Reverse"] = request.Reverse
	}

	if !tea.BoolValue(util.IsUnset(request.StartTs)) {
		query["StartTs"] = request.StartTs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConfigTrack"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigTrackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListConfigTrack(request *ListConfigTrackRequest) (_result *ListConfigTrackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListConfigTrackResponse{}
	_body, _err := client.ListConfigTrackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEngineNamespacesWithOptions(request *ListEngineNamespacesRequest, runtime *util.RuntimeOptions) (_result *ListEngineNamespacesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEngineNamespaces"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEngineNamespacesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEngineNamespaces(request *ListEngineNamespacesRequest) (_result *ListEngineNamespacesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEngineNamespacesResponse{}
	_body, _err := client.ListEngineNamespacesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEurekaInstancesWithOptions(request *ListEurekaInstancesRequest, runtime *util.RuntimeOptions) (_result *ListEurekaInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEurekaInstances"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEurekaInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEurekaInstances(request *ListEurekaInstancesRequest) (_result *ListEurekaInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEurekaInstancesResponse{}
	_body, _err := client.ListEurekaInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEurekaServicesWithOptions(request *ListEurekaServicesRequest, runtime *util.RuntimeOptions) (_result *ListEurekaServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEurekaServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEurekaServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEurekaServices(request *ListEurekaServicesRequest) (_result *ListEurekaServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEurekaServicesResponse{}
	_body, _err := client.ListEurekaServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListExportZookeeperDataWithOptions(request *ListExportZookeeperDataRequest, runtime *util.RuntimeOptions) (_result *ListExportZookeeperDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListExportZookeeperData"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListExportZookeeperDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListExportZookeeperData(request *ListExportZookeeperDataRequest) (_result *ListExportZookeeperDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListExportZookeeperDataResponse{}
	_body, _err := client.ListExportZookeeperDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListFlowRulesWithOptions(request *ListFlowRulesRequest, runtime *util.RuntimeOptions) (_result *ListFlowRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageIndex)) {
		query["PageIndex"] = request.PageIndex
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Resource)) {
		query["Resource"] = request.Resource
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceSearchKey)) {
		query["ResourceSearchKey"] = request.ResourceSearchKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFlowRules"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFlowRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListFlowRules(request *ListFlowRulesRequest) (_result *ListFlowRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFlowRulesResponse{}
	_body, _err := client.ListFlowRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayWithOptions(tmpReq *ListGatewayRequest, runtime *util.RuntimeOptions) (_result *ListGatewayResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListGatewayShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FilterParams)) {
		request.FilterParamsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterParams, tea.String("FilterParams"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DescSort)) {
		query["DescSort"] = request.DescSort
	}

	if !tea.BoolValue(util.IsUnset(request.FilterParamsShrink)) {
		query["FilterParams"] = request.FilterParamsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderItem)) {
		query["OrderItem"] = request.OrderItem
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGateway(request *ListGatewayRequest) (_result *ListGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayResponse{}
	_body, _err := client.ListGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayAuthConsumerWithOptions(request *ListGatewayAuthConsumerRequest, runtime *util.RuntimeOptions) (_result *ListGatewayAuthConsumerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerStatus)) {
		query["ConsumerStatus"] = request.ConsumerStatus
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayAuthConsumer"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayAuthConsumerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayAuthConsumer(request *ListGatewayAuthConsumerRequest) (_result *ListGatewayAuthConsumerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayAuthConsumerResponse{}
	_body, _err := client.ListGatewayAuthConsumerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayAuthConsumerResourceWithOptions(request *ListGatewayAuthConsumerResourceRequest, runtime *util.RuntimeOptions) (_result *ListGatewayAuthConsumerResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerId)) {
		query["ConsumerId"] = request.ConsumerId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceStatus)) {
		query["ResourceStatus"] = request.ResourceStatus
	}

	if !tea.BoolValue(util.IsUnset(request.RouteName)) {
		query["RouteName"] = request.RouteName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayAuthConsumerResource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayAuthConsumerResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayAuthConsumerResource(request *ListGatewayAuthConsumerResourceRequest) (_result *ListGatewayAuthConsumerResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayAuthConsumerResourceResponse{}
	_body, _err := client.ListGatewayAuthConsumerResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayDomainWithOptions(request *ListGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *ListGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayDomain(request *ListGatewayDomainRequest) (_result *ListGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayDomainResponse{}
	_body, _err := client.ListGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayRouteWithOptions(tmpReq *ListGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *ListGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListGatewayRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FilterParams)) {
		request.FilterParamsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterParams, tea.String("FilterParams"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DescSort)) {
		query["DescSort"] = request.DescSort
	}

	if !tea.BoolValue(util.IsUnset(request.FilterParamsShrink)) {
		query["FilterParams"] = request.FilterParamsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderItem)) {
		query["OrderItem"] = request.OrderItem
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayRoute(request *ListGatewayRouteRequest) (_result *ListGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayRouteResponse{}
	_body, _err := client.ListGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayRouteOnAuthWithOptions(request *ListGatewayRouteOnAuthRequest, runtime *util.RuntimeOptions) (_result *ListGatewayRouteOnAuthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayRouteOnAuth"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayRouteOnAuthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayRouteOnAuth(request *ListGatewayRouteOnAuthRequest) (_result *ListGatewayRouteOnAuthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayRouteOnAuthResponse{}
	_body, _err := client.ListGatewayRouteOnAuthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayServiceWithOptions(tmpReq *ListGatewayServiceRequest, runtime *util.RuntimeOptions) (_result *ListGatewayServiceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListGatewayServiceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FilterParams)) {
		request.FilterParamsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterParams, tea.String("FilterParams"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DescSort)) {
		query["DescSort"] = request.DescSort
	}

	if !tea.BoolValue(util.IsUnset(request.FilterParamsShrink)) {
		query["FilterParams"] = request.FilterParamsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderItem)) {
		query["OrderItem"] = request.OrderItem
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayService(request *ListGatewayServiceRequest) (_result *ListGatewayServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayServiceResponse{}
	_body, _err := client.ListGatewayServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewaySlbWithOptions(request *ListGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *ListGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewaySlb(request *ListGatewaySlbRequest) (_result *ListGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewaySlbResponse{}
	_body, _err := client.ListGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstanceCountWithOptions(request *ListInstanceCountRequest, runtime *util.RuntimeOptions) (_result *ListInstanceCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceCount"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstanceCount(request *ListInstanceCountRequest) (_result *ListInstanceCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstanceCountResponse{}
	_body, _err := client.ListInstanceCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListListenersByConfigResponse
 */
func (client *Client) ListListenersByConfigWithOptions(request *ListListenersByConfigRequest, runtime *util.RuntimeOptions) (_result *ListListenersByConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListListenersByConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListListenersByConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByConfigRequest
 * @return ListListenersByConfigResponse
 */
func (client *Client) ListListenersByConfig(request *ListListenersByConfigRequest) (_result *ListListenersByConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListListenersByConfigResponse{}
	_body, _err := client.ListListenersByConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListListenersByIpResponse
 */
func (client *Client) ListListenersByIpWithOptions(request *ListListenersByIpRequest, runtime *util.RuntimeOptions) (_result *ListListenersByIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListListenersByIp"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListListenersByIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByIpRequest
 * @return ListListenersByIpResponse
 */
func (client *Client) ListListenersByIp(request *ListListenersByIpRequest) (_result *ListListenersByIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListListenersByIpResponse{}
	_body, _err := client.ListListenersByIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListMigrationTaskWithOptions(request *ListMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *ListMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListMigrationTask(request *ListMigrationTaskRequest) (_result *ListMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListMigrationTaskResponse{}
	_body, _err := client.ListMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNacosConfigsResponse
 */
func (client *Client) ListNacosConfigsWithOptions(request *ListNacosConfigsRequest, runtime *util.RuntimeOptions) (_result *ListNacosConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNacosConfigs"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNacosConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosConfigsRequest
 * @return ListNacosConfigsResponse
 */
func (client *Client) ListNacosConfigs(request *ListNacosConfigsRequest) (_result *ListNacosConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNacosConfigsResponse{}
	_body, _err := client.ListNacosConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosHistoryConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNacosHistoryConfigsResponse
 */
func (client *Client) ListNacosHistoryConfigsWithOptions(request *ListNacosHistoryConfigsRequest, runtime *util.RuntimeOptions) (_result *ListNacosHistoryConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNacosHistoryConfigs"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNacosHistoryConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosHistoryConfigsRequest
 * @return ListNacosHistoryConfigsResponse
 */
func (client *Client) ListNacosHistoryConfigs(request *ListNacosHistoryConfigsRequest) (_result *ListNacosHistoryConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNacosHistoryConfigsResponse{}
	_body, _err := client.ListNacosHistoryConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNamingTrackWithOptions(request *ListNamingTrackRequest, runtime *util.RuntimeOptions) (_result *ListNamingTrackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNamingTrack"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNamingTrackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNamingTrack(request *ListNamingTrackRequest) (_result *ListNamingTrackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNamingTrackResponse{}
	_body, _err := client.ListNamingTrackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSSLCertWithOptions(request *ListSSLCertRequest, runtime *util.RuntimeOptions) (_result *ListSSLCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSSLCert"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSSLCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSSLCert(request *ListSSLCertRequest) (_result *ListSSLCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSSLCertResponse{}
	_body, _err := client.ListSSLCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSecurityGroupWithOptions(request *ListSecurityGroupRequest, runtime *util.RuntimeOptions) (_result *ListSecurityGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSecurityGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSecurityGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSecurityGroup(request *ListSecurityGroupRequest) (_result *ListSecurityGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSecurityGroupResponse{}
	_body, _err := client.ListSecurityGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSecurityGroupRuleWithOptions(request *ListSecurityGroupRuleRequest, runtime *util.RuntimeOptions) (_result *ListSecurityGroupRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSecurityGroupRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSecurityGroupRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSecurityGroupRule(request *ListSecurityGroupRuleRequest) (_result *ListSecurityGroupRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSecurityGroupRuleResponse{}
	_body, _err := client.ListSecurityGroupRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListServiceSourceWithOptions(request *ListServiceSourceRequest, runtime *util.RuntimeOptions) (_result *ListServiceSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListServiceSource(request *ListServiceSourceRequest) (_result *ListServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListServiceSourceResponse{}
	_body, _err := client.ListServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListZkTrackWithOptions(request *ListZkTrackRequest, runtime *util.RuntimeOptions) (_result *ListZkTrackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTs)) {
		query["EndTs"] = request.EndTs
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.Reverse)) {
		query["Reverse"] = request.Reverse
	}

	if !tea.BoolValue(util.IsUnset(request.SessionId)) {
		query["SessionId"] = request.SessionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTs)) {
		query["StartTs"] = request.StartTs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListZkTrack"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListZkTrackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListZkTrack(request *ListZkTrackRequest) (_result *ListZkTrackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListZkTrackResponse{}
	_body, _err := client.ListZkTrackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListZnodeChildrenWithOptions(request *ListZnodeChildrenRequest, runtime *util.RuntimeOptions) (_result *ListZnodeChildrenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListZnodeChildren"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListZnodeChildrenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListZnodeChildren(request *ListZnodeChildrenRequest) (_result *ListZnodeChildrenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListZnodeChildrenResponse{}
	_body, _err := client.ListZnodeChildrenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyGovernanceKubernetesClusterWithOptions(tmpReq *ModifyGovernanceKubernetesClusterRequest, runtime *util.RuntimeOptions) (_result *ModifyGovernanceKubernetesClusterResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ModifyGovernanceKubernetesClusterShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.NamespaceInfos)) {
		request.NamespaceInfosShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.NamespaceInfos, tea.String("NamespaceInfos"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NamespaceInfosShrink)) {
		body["NamespaceInfos"] = request.NamespaceInfosShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyGovernanceKubernetesCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyGovernanceKubernetesClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyGovernanceKubernetesCluster(request *ModifyGovernanceKubernetesClusterRequest) (_result *ModifyGovernanceKubernetesClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyGovernanceKubernetesClusterResponse{}
	_body, _err := client.ModifyGovernanceKubernetesClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyLosslessRuleWithOptions(request *ModifyLosslessRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyLosslessRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Aligned)) {
		query["Aligned"] = request.Aligned
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DelayTime)) {
		query["DelayTime"] = request.DelayTime
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.FuncType)) {
		query["FuncType"] = request.FuncType
	}

	if !tea.BoolValue(util.IsUnset(request.LossLessDetail)) {
		query["LossLessDetail"] = request.LossLessDetail
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Notice)) {
		query["Notice"] = request.Notice
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Related)) {
		query["Related"] = request.Related
	}

	if !tea.BoolValue(util.IsUnset(request.WarmupTime)) {
		query["WarmupTime"] = request.WarmupTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLosslessRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLosslessRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyLosslessRule(request *ModifyLosslessRuleRequest) (_result *ModifyLosslessRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLosslessRuleResponse{}
	_body, _err := client.ModifyLosslessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OfflineGatewayRouteWithOptions(request *OfflineGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *OfflineGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OfflineGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OfflineGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OfflineGatewayRoute(request *OfflineGatewayRouteRequest) (_result *OfflineGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OfflineGatewayRouteResponse{}
	_body, _err := client.OfflineGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OrderClusterHealthCheckRiskNoticeWithOptions(request *OrderClusterHealthCheckRiskNoticeRequest, runtime *util.RuntimeOptions) (_result *OrderClusterHealthCheckRiskNoticeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Mute)) {
		query["Mute"] = request.Mute
	}

	if !tea.BoolValue(util.IsUnset(request.NoticeType)) {
		query["NoticeType"] = request.NoticeType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.RiskCode)) {
		query["RiskCode"] = request.RiskCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OrderClusterHealthCheckRiskNotice"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OrderClusterHealthCheckRiskNoticeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OrderClusterHealthCheckRiskNotice(request *OrderClusterHealthCheckRiskNoticeRequest) (_result *OrderClusterHealthCheckRiskNoticeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OrderClusterHealthCheckRiskNoticeResponse{}
	_body, _err := client.OrderClusterHealthCheckRiskNoticeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PullServicesWithOptions(request *PullServicesRequest, runtime *util.RuntimeOptions) (_result *PullServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PullServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PullServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PullServices(request *PullServicesRequest) (_result *PullServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PullServicesResponse{}
	_body, _err := client.PullServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PutClusterHealthCheckTaskWithOptions(request *PutClusterHealthCheckTaskRequest, runtime *util.RuntimeOptions) (_result *PutClusterHealthCheckTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PutClusterHealthCheckTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PutClusterHealthCheckTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PutClusterHealthCheckTask(request *PutClusterHealthCheckTaskRequest) (_result *PutClusterHealthCheckTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PutClusterHealthCheckTaskResponse{}
	_body, _err := client.PutClusterHealthCheckTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryAllSwimmingLaneWithOptions(request *QueryAllSwimmingLaneRequest, runtime *util.RuntimeOptions) (_result *QueryAllSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryAllSwimmingLane"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryAllSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryAllSwimmingLane(request *QueryAllSwimmingLaneRequest) (_result *QueryAllSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryAllSwimmingLaneResponse{}
	_body, _err := client.QueryAllSwimmingLaneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryAllSwimmingLaneGroupWithOptions(request *QueryAllSwimmingLaneGroupRequest, runtime *util.RuntimeOptions) (_result *QueryAllSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryAllSwimmingLaneGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryAllSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryAllSwimmingLaneGroup(request *QueryAllSwimmingLaneGroupRequest) (_result *QueryAllSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryAllSwimmingLaneGroupResponse{}
	_body, _err := client.QueryAllSwimmingLaneGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryBusinessLocationsWithOptions(request *QueryBusinessLocationsRequest, runtime *util.RuntimeOptions) (_result *QueryBusinessLocationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryBusinessLocations"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryBusinessLocationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryBusinessLocations(request *QueryBusinessLocationsRequest) (_result *QueryBusinessLocationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryBusinessLocationsResponse{}
	_body, _err := client.QueryBusinessLocationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterDetailWithOptions(request *QueryClusterDetailRequest, runtime *util.RuntimeOptions) (_result *QueryClusterDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AclSwitch)) {
		query["AclSwitch"] = request.AclSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterDetail(request *QueryClusterDetailRequest) (_result *QueryClusterDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterDetailResponse{}
	_body, _err := client.QueryClusterDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterDiskSpecificationWithOptions(request *QueryClusterDiskSpecificationRequest, runtime *util.RuntimeOptions) (_result *QueryClusterDiskSpecificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterDiskSpecification"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterDiskSpecificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterDiskSpecification(request *QueryClusterDiskSpecificationRequest) (_result *QueryClusterDiskSpecificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterDiskSpecificationResponse{}
	_body, _err := client.QueryClusterDiskSpecificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterInfoWithOptions(request *QueryClusterInfoRequest, runtime *util.RuntimeOptions) (_result *QueryClusterInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AclSwitch)) {
		query["AclSwitch"] = request.AclSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterInfo"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterInfo(request *QueryClusterInfoRequest) (_result *QueryClusterInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterInfoResponse{}
	_body, _err := client.QueryClusterInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterSpecificationWithOptions(request *QueryClusterSpecificationRequest, runtime *util.RuntimeOptions) (_result *QueryClusterSpecificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectType)) {
		query["ConnectType"] = request.ConnectType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterSpecification"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterSpecificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterSpecification(request *QueryClusterSpecificationRequest) (_result *QueryClusterSpecificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterSpecificationResponse{}
	_body, _err := client.QueryClusterSpecificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryConfigWithOptions(request *QueryConfigRequest, runtime *util.RuntimeOptions) (_result *QueryConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigType)) {
		query["ConfigType"] = request.ConfigType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NeedRunningConf)) {
		query["NeedRunningConf"] = request.NeedRunningConf
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryConfig(request *QueryConfigRequest) (_result *QueryConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryConfigResponse{}
	_body, _err := client.QueryConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryGatewayRegionWithOptions(request *QueryGatewayRegionRequest, runtime *util.RuntimeOptions) (_result *QueryGatewayRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryGatewayRegion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryGatewayRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryGatewayRegion(request *QueryGatewayRegionRequest) (_result *QueryGatewayRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryGatewayRegionResponse{}
	_body, _err := client.QueryGatewayRegionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryGatewayTypeWithOptions(request *QueryGatewayTypeRequest, runtime *util.RuntimeOptions) (_result *QueryGatewayTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryGatewayType"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryGatewayTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryGatewayType(request *QueryGatewayTypeRequest) (_result *QueryGatewayTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryGatewayTypeResponse{}
	_body, _err := client.QueryGatewayTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryGovernanceKubernetesClusterWithOptions(request *QueryGovernanceKubernetesClusterRequest, runtime *util.RuntimeOptions) (_result *QueryGovernanceKubernetesClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryGovernanceKubernetesCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryGovernanceKubernetesClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryGovernanceKubernetesCluster(request *QueryGovernanceKubernetesClusterRequest) (_result *QueryGovernanceKubernetesClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryGovernanceKubernetesClusterResponse{}
	_body, _err := client.QueryGovernanceKubernetesClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryInstancesInfoWithOptions(request *QueryInstancesInfoRequest, runtime *util.RuntimeOptions) (_result *QueryInstancesInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryInstancesInfo"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryInstancesInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryInstancesInfo(request *QueryInstancesInfoRequest) (_result *QueryInstancesInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryInstancesInfoResponse{}
	_body, _err := client.QueryInstancesInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryMonitorWithOptions(request *QueryMonitorRequest, runtime *util.RuntimeOptions) (_result *QueryMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorType)) {
		query["MonitorType"] = request.MonitorType
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Step)) {
		query["Step"] = request.Step
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryMonitor"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryMonitor(request *QueryMonitorRequest) (_result *QueryMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryMonitorResponse{}
	_body, _err := client.QueryMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryNamespaceWithOptions(request *QueryNamespaceRequest, runtime *util.RuntimeOptions) (_result *QueryNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryNamespace(request *QueryNamespaceRequest) (_result *QueryNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryNamespaceResponse{}
	_body, _err := client.QueryNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySlbSpecWithOptions(request *QuerySlbSpecRequest, runtime *util.RuntimeOptions) (_result *QuerySlbSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySlbSpec"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySlbSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySlbSpec(request *QuerySlbSpecRequest) (_result *QuerySlbSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySlbSpecResponse{}
	_body, _err := client.QuerySlbSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySwimmingLaneByIdWithOptions(request *QuerySwimmingLaneByIdRequest, runtime *util.RuntimeOptions) (_result *QuerySwimmingLaneByIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.LaneId)) {
		query["LaneId"] = request.LaneId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySwimmingLaneById"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySwimmingLaneByIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySwimmingLaneById(request *QuerySwimmingLaneByIdRequest) (_result *QuerySwimmingLaneByIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySwimmingLaneByIdResponse{}
	_body, _err := client.QuerySwimmingLaneByIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryZnodeDetailWithOptions(request *QueryZnodeDetailRequest, runtime *util.RuntimeOptions) (_result *QueryZnodeDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryZnodeDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryZnodeDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryZnodeDetail(request *QueryZnodeDetailRequest) (_result *QueryZnodeDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryZnodeDetailResponse{}
	_body, _err := client.QueryZnodeDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveApplicationWithOptions(request *RemoveApplicationRequest, runtime *util.RuntimeOptions) (_result *RemoveApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveApplication"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveApplication(request *RemoveApplicationRequest) (_result *RemoveApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveApplicationResponse{}
	_body, _err := client.RemoveApplicationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveAuthPolicyWithOptions(request *RemoveAuthPolicyRequest, runtime *util.RuntimeOptions) (_result *RemoveAuthPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveAuthPolicy"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveAuthPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveAuthPolicy(request *RemoveAuthPolicyRequest) (_result *RemoveAuthPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveAuthPolicyResponse{}
	_body, _err := client.RemoveAuthPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestartClusterWithOptions(request *RestartClusterRequest, runtime *util.RuntimeOptions) (_result *RestartClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PodNameList)) {
		query["PodNameList"] = request.PodNameList
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestartCluster(request *RestartClusterRequest) (_result *RestartClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestartClusterResponse{}
	_body, _err := client.RestartClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RetryClusterWithOptions(request *RetryClusterRequest, runtime *util.RuntimeOptions) (_result *RetryClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RetryCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RetryClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RetryCluster(request *RetryClusterRequest) (_result *RetryClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RetryClusterResponse{}
	_body, _err := client.RetryClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SelectGatewaySlbWithOptions(request *SelectGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *SelectGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SelectGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SelectGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SelectGatewaySlb(request *SelectGatewaySlbRequest) (_result *SelectGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SelectGatewaySlbResponse{}
	_body, _err := client.SelectGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAclWithOptions(request *UpdateAclRequest, runtime *util.RuntimeOptions) (_result *UpdateAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AclEntryList)) {
		query["AclEntryList"] = request.AclEntryList
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAcl"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAcl(request *UpdateAclRequest) (_result *UpdateAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAclResponse{}
	_body, _err := client.UpdateAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAuthPolicyWithOptions(request *UpdateAuthPolicyRequest, runtime *util.RuntimeOptions) (_result *UpdateAuthPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthRule)) {
		query["AuthRule"] = request.AuthRule
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.K8sNamespace)) {
		query["K8sNamespace"] = request.K8sNamespace
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAuthPolicy"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAuthPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAuthPolicy(request *UpdateAuthPolicyRequest) (_result *UpdateAuthPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAuthPolicyResponse{}
	_body, _err := client.UpdateAuthPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateBlackWhiteListWithOptions(request *UpdateBlackWhiteListRequest, runtime *util.RuntimeOptions) (_result *UpdateBlackWhiteListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.IsWhite)) {
		query["IsWhite"] = request.IsWhite
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Note)) {
		query["Note"] = request.Note
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIdJsonList)) {
		query["ResourceIdJsonList"] = request.ResourceIdJsonList
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBlackWhiteList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBlackWhiteListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateBlackWhiteList(request *UpdateBlackWhiteListRequest) (_result *UpdateBlackWhiteListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBlackWhiteListResponse{}
	_body, _err := client.UpdateBlackWhiteListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateCircuitBreakerRuleWithOptions(request *UpdateCircuitBreakerRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateCircuitBreakerRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.HalfOpenBaseAmountPerStep)) {
		query["HalfOpenBaseAmountPerStep"] = request.HalfOpenBaseAmountPerStep
	}

	if !tea.BoolValue(util.IsUnset(request.HalfOpenRecoveryStepNum)) {
		query["HalfOpenRecoveryStepNum"] = request.HalfOpenRecoveryStepNum
	}

	if !tea.BoolValue(util.IsUnset(request.MaxAllowedRtMs)) {
		query["MaxAllowedRtMs"] = request.MaxAllowedRtMs
	}

	if !tea.BoolValue(util.IsUnset(request.MinRequestAmount)) {
		query["MinRequestAmount"] = request.MinRequestAmount
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RetryTimeoutMs)) {
		query["RetryTimeoutMs"] = request.RetryTimeoutMs
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.StatIntervalMs)) {
		query["StatIntervalMs"] = request.StatIntervalMs
	}

	if !tea.BoolValue(util.IsUnset(request.Strategy)) {
		query["Strategy"] = request.Strategy
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCircuitBreakerRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCircuitBreakerRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateCircuitBreakerRule(request *UpdateCircuitBreakerRuleRequest) (_result *UpdateCircuitBreakerRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCircuitBreakerRuleResponse{}
	_body, _err := client.UpdateCircuitBreakerRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateClusterWithOptions(request *UpdateClusterRequest, runtime *util.RuntimeOptions) (_result *UpdateClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterAliasName)) {
		query["ClusterAliasName"] = request.ClusterAliasName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MaintenanceEndTime)) {
		query["MaintenanceEndTime"] = request.MaintenanceEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.MaintenanceStartTime)) {
		query["MaintenanceStartTime"] = request.MaintenanceStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateCluster(request *UpdateClusterRequest) (_result *UpdateClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateClusterResponse{}
	_body, _err := client.UpdateClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to update the number or specifications of nodes in a pay-as-you-go MSE instance. You are charged when you add nodes or upgrade node specifications. For more information, see \\[Pricing] (`~~1806469~~`).
 *
 * @param request UpdateClusterSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateClusterSpecResponse
 */
func (client *Client) UpdateClusterSpecWithOptions(request *UpdateClusterSpecRequest, runtime *util.RuntimeOptions) (_result *UpdateClusterSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterSpecification)) {
		query["ClusterSpecification"] = request.ClusterSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceCount)) {
		query["InstanceCount"] = request.InstanceCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateClusterSpec"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateClusterSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to update the number or specifications of nodes in a pay-as-you-go MSE instance. You are charged when you add nodes or upgrade node specifications. For more information, see \\[Pricing] (`~~1806469~~`).
 *
 * @param request UpdateClusterSpecRequest
 * @return UpdateClusterSpecResponse
 */
func (client *Client) UpdateClusterSpec(request *UpdateClusterSpecRequest) (_result *UpdateClusterSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateClusterSpecResponse{}
	_body, _err := client.UpdateClusterSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateConfigWithOptions(request *UpdateConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AutopurgePurgeInterval)) {
		query["AutopurgePurgeInterval"] = request.AutopurgePurgeInterval
	}

	if !tea.BoolValue(util.IsUnset(request.AutopurgeSnapRetainCount)) {
		query["AutopurgeSnapRetainCount"] = request.AutopurgeSnapRetainCount
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigAuthEnabled)) {
		query["ConfigAuthEnabled"] = request.ConfigAuthEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigSecretEnabled)) {
		query["ConfigSecretEnabled"] = request.ConfigSecretEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigType)) {
		query["ConfigType"] = request.ConfigType
	}

	if !tea.BoolValue(util.IsUnset(request.ConsoleUIEnabled)) {
		query["ConsoleUIEnabled"] = request.ConsoleUIEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.EurekaSupported)) {
		query["EurekaSupported"] = request.EurekaSupported
	}

	if !tea.BoolValue(util.IsUnset(request.ExtendedTypesEnable)) {
		query["ExtendedTypesEnable"] = request.ExtendedTypesEnable
	}

	if !tea.BoolValue(util.IsUnset(request.InitLimit)) {
		query["InitLimit"] = request.InitLimit
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JuteMaxbuffer)) {
		query["JuteMaxbuffer"] = request.JuteMaxbuffer
	}

	if !tea.BoolValue(util.IsUnset(request.MCPEnabled)) {
		query["MCPEnabled"] = request.MCPEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.MaxClientCnxns)) {
		query["MaxClientCnxns"] = request.MaxClientCnxns
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSessionTimeout)) {
		query["MaxSessionTimeout"] = request.MaxSessionTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.MinSessionTimeout)) {
		query["MinSessionTimeout"] = request.MinSessionTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.NamingAuthEnabled)) {
		query["NamingAuthEnabled"] = request.NamingAuthEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.PassWord)) {
		query["PassWord"] = request.PassWord
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotCount)) {
		query["SnapshotCount"] = request.SnapshotCount
	}

	if !tea.BoolValue(util.IsUnset(request.SyncLimit)) {
		query["SyncLimit"] = request.SyncLimit
	}

	if !tea.BoolValue(util.IsUnset(request.TLSEnabled)) {
		query["TLSEnabled"] = request.TLSEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.TickTime)) {
		query["TickTime"] = request.TickTime
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		query["UserName"] = request.UserName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OpenSuperAcl)) {
		body["OpenSuperAcl"] = request.OpenSuperAcl
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateConfig(request *UpdateConfigRequest) (_result *UpdateConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateConfigResponse{}
	_body, _err := client.UpdateConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEngineNamespaceWithOptions(request *UpdateEngineNamespaceRequest, runtime *util.RuntimeOptions) (_result *UpdateEngineNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceCount)) {
		query["ServiceCount"] = request.ServiceCount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEngineNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEngineNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEngineNamespace(request *UpdateEngineNamespaceRequest) (_result *UpdateEngineNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEngineNamespaceResponse{}
	_body, _err := client.UpdateEngineNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateFlowRuleWithOptions(request *UpdateFlowRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateFlowRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.ControlBehavior)) {
		query["ControlBehavior"] = request.ControlBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.MaxQueueingTimeMs)) {
		query["MaxQueueingTimeMs"] = request.MaxQueueingTimeMs
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateFlowRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateFlowRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateFlowRule(request *UpdateFlowRuleRequest) (_result *UpdateFlowRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateFlowRuleResponse{}
	_body, _err := client.UpdateFlowRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumerWithOptions(request *UpdateGatewayAuthConsumerRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayAuthConsumerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EncodeType)) {
		query["EncodeType"] = request.EncodeType
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Jwks)) {
		query["Jwks"] = request.Jwks
	}

	if !tea.BoolValue(util.IsUnset(request.KeyName)) {
		query["KeyName"] = request.KeyName
	}

	if !tea.BoolValue(util.IsUnset(request.KeyValue)) {
		query["KeyValue"] = request.KeyValue
	}

	if !tea.BoolValue(util.IsUnset(request.TokenName)) {
		query["TokenName"] = request.TokenName
	}

	if !tea.BoolValue(util.IsUnset(request.TokenPass)) {
		query["TokenPass"] = request.TokenPass
	}

	if !tea.BoolValue(util.IsUnset(request.TokenPosition)) {
		query["TokenPosition"] = request.TokenPosition
	}

	if !tea.BoolValue(util.IsUnset(request.TokenPrefix)) {
		query["TokenPrefix"] = request.TokenPrefix
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayAuthConsumer"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayAuthConsumerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumer(request *UpdateGatewayAuthConsumerRequest) (_result *UpdateGatewayAuthConsumerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayAuthConsumerResponse{}
	_body, _err := client.UpdateGatewayAuthConsumerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumerResourceWithOptions(tmpReq *UpdateGatewayAuthConsumerResourceRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayAuthConsumerResourceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayAuthConsumerResourceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceList)) {
		request.ResourceListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceList, tea.String("ResourceList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerId)) {
		query["ConsumerId"] = request.ConsumerId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceListShrink)) {
		query["ResourceList"] = request.ResourceListShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayAuthConsumerResource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayAuthConsumerResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumerResource(request *UpdateGatewayAuthConsumerResourceRequest) (_result *UpdateGatewayAuthConsumerResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayAuthConsumerResourceResponse{}
	_body, _err := client.UpdateGatewayAuthConsumerResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumerResourceStatusWithOptions(request *UpdateGatewayAuthConsumerResourceStatusRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayAuthConsumerResourceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerId)) {
		query["ConsumerId"] = request.ConsumerId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IdList)) {
		query["IdList"] = request.IdList
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceStatus)) {
		query["ResourceStatus"] = request.ResourceStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayAuthConsumerResourceStatus"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayAuthConsumerResourceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumerResourceStatus(request *UpdateGatewayAuthConsumerResourceStatusRequest) (_result *UpdateGatewayAuthConsumerResourceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayAuthConsumerResourceStatusResponse{}
	_body, _err := client.UpdateGatewayAuthConsumerResourceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumerStatusWithOptions(request *UpdateGatewayAuthConsumerStatusRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayAuthConsumerStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerStatus)) {
		query["ConsumerStatus"] = request.ConsumerStatus
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayAuthConsumerStatus"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayAuthConsumerStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayAuthConsumerStatus(request *UpdateGatewayAuthConsumerStatusRequest) (_result *UpdateGatewayAuthConsumerStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayAuthConsumerStatusResponse{}
	_body, _err := client.UpdateGatewayAuthConsumerStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayDomainWithOptions(request *UpdateGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Http2)) {
		query["Http2"] = request.Http2
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.MustHttps)) {
		query["MustHttps"] = request.MustHttps
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMax)) {
		query["TlsMax"] = request.TlsMax
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMin)) {
		query["TlsMin"] = request.TlsMin
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayDomain(request *UpdateGatewayDomainRequest) (_result *UpdateGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayDomainResponse{}
	_body, _err := client.UpdateGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayNameWithOptions(request *UpdateGatewayNameRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayName"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayName(request *UpdateGatewayNameRequest) (_result *UpdateGatewayNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayNameResponse{}
	_body, _err := client.UpdateGatewayNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayOptionWithOptions(tmpReq *UpdateGatewayOptionRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayOptionResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayOptionShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GatewayOption)) {
		request.GatewayOptionShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GatewayOption, tea.String("GatewayOption"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayOptionShrink)) {
		query["GatewayOption"] = request.GatewayOptionShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayOption"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayOptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayOption(request *UpdateGatewayOptionRequest) (_result *UpdateGatewayOptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayOptionResponse{}
	_body, _err := client.UpdateGatewayOptionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteWithOptions(tmpReq *UpdateGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DirectResponseJSON)) {
		request.DirectResponseJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DirectResponseJSON, tea.String("DirectResponseJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FallbackServices)) {
		request.FallbackServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FallbackServices, tea.String("FallbackServices"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Predicates)) {
		request.PredicatesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Predicates, tea.String("Predicates"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RedirectJSON)) {
		request.RedirectJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RedirectJSON, tea.String("RedirectJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Services)) {
		request.ServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Services, tea.String("Services"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationType)) {
		query["DestinationType"] = request.DestinationType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectResponseJSONShrink)) {
		query["DirectResponseJSON"] = request.DirectResponseJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DomainIdListJSON)) {
		query["DomainIdListJSON"] = request.DomainIdListJSON
	}

	if !tea.BoolValue(util.IsUnset(request.EnableWaf)) {
		query["EnableWaf"] = request.EnableWaf
	}

	if !tea.BoolValue(util.IsUnset(request.Fallback)) {
		query["Fallback"] = request.Fallback
	}

	if !tea.BoolValue(util.IsUnset(request.FallbackServicesShrink)) {
		query["FallbackServices"] = request.FallbackServicesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PredicatesShrink)) {
		query["Predicates"] = request.PredicatesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RedirectJSONShrink)) {
		query["RedirectJSON"] = request.RedirectJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RouteOrder)) {
		query["RouteOrder"] = request.RouteOrder
	}

	if !tea.BoolValue(util.IsUnset(request.ServicesShrink)) {
		query["Services"] = request.ServicesShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRoute(request *UpdateGatewayRouteRequest) (_result *UpdateGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteResponse{}
	_body, _err := client.UpdateGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteAuthWithOptions(tmpReq *UpdateGatewayRouteAuthRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteAuthResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteAuthShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AuthJSON)) {
		request.AuthJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AuthJSON, tea.String("AuthJSON"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AuthJSONShrink)) {
		query["AuthJSON"] = request.AuthJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteAuth"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteAuthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteAuth(request *UpdateGatewayRouteAuthRequest) (_result *UpdateGatewayRouteAuthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteAuthResponse{}
	_body, _err := client.UpdateGatewayRouteAuthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteCORSWithOptions(tmpReq *UpdateGatewayRouteCORSRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteCORSResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteCORSShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.CorsJSON)) {
		request.CorsJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CorsJSON, tea.String("CorsJSON"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CorsJSONShrink)) {
		query["CorsJSON"] = request.CorsJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteCORS"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteCORSResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteCORS(request *UpdateGatewayRouteCORSRequest) (_result *UpdateGatewayRouteCORSResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteCORSResponse{}
	_body, _err := client.UpdateGatewayRouteCORSWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHTTPRewriteWithOptions(request *UpdateGatewayRouteHTTPRewriteRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteHTTPRewriteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.HttpRewriteJSON)) {
		query["HttpRewriteJSON"] = request.HttpRewriteJSON
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteHTTPRewrite"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteHTTPRewriteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHTTPRewrite(request *UpdateGatewayRouteHTTPRewriteRequest) (_result *UpdateGatewayRouteHTTPRewriteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteHTTPRewriteResponse{}
	_body, _err := client.UpdateGatewayRouteHTTPRewriteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHeaderOpWithOptions(request *UpdateGatewayRouteHeaderOpRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteHeaderOpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.HeaderOpJSON)) {
		query["HeaderOpJSON"] = request.HeaderOpJSON
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteHeaderOp"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteHeaderOpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHeaderOp(request *UpdateGatewayRouteHeaderOpRequest) (_result *UpdateGatewayRouteHeaderOpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteHeaderOpResponse{}
	_body, _err := client.UpdateGatewayRouteHeaderOpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteRetryWithOptions(tmpReq *UpdateGatewayRouteRetryRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteRetryResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteRetryShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.RetryJSON)) {
		request.RetryJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RetryJSON, tea.String("RetryJSON"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.RetryJSONShrink)) {
		query["RetryJSON"] = request.RetryJSONShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteRetry"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteRetryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteRetry(request *UpdateGatewayRouteRetryRequest) (_result *UpdateGatewayRouteRetryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteRetryResponse{}
	_body, _err := client.UpdateGatewayRouteRetryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteTimeoutWithOptions(tmpReq *UpdateGatewayRouteTimeoutRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteTimeoutResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteTimeoutShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.TimeoutJSON)) {
		request.TimeoutJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TimeoutJSON, tea.String("TimeoutJSON"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.TimeoutJSONShrink)) {
		query["TimeoutJSON"] = request.TimeoutJSONShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteTimeout"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteTimeoutResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteTimeout(request *UpdateGatewayRouteTimeoutRequest) (_result *UpdateGatewayRouteTimeoutResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteTimeoutResponse{}
	_body, _err := client.UpdateGatewayRouteTimeoutWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteWafStatusWithOptions(request *UpdateGatewayRouteWafStatusRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteWafStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.EnableWaf)) {
		query["EnableWaf"] = request.EnableWaf
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteWafStatus"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteWafStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteWafStatus(request *UpdateGatewayRouteWafStatusRequest) (_result *UpdateGatewayRouteWafStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteWafStatusResponse{}
	_body, _err := client.UpdateGatewayRouteWafStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayServiceCheckWithOptions(tmpReq *UpdateGatewayServiceCheckRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayServiceCheckResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayServiceCheckShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ExpectedStatuses)) {
		request.ExpectedStatusesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ExpectedStatuses, tea.String("ExpectedStatuses"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Check)) {
		query["Check"] = request.Check
	}

	if !tea.BoolValue(util.IsUnset(request.ExpectedStatusesShrink)) {
		query["ExpectedStatuses"] = request.ExpectedStatusesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.HttpHost)) {
		query["HttpHost"] = request.HttpHost
	}

	if !tea.BoolValue(util.IsUnset(request.HttpPath)) {
		query["HttpPath"] = request.HttpPath
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayServiceCheck"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayServiceCheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayServiceCheck(request *UpdateGatewayServiceCheckRequest) (_result *UpdateGatewayServiceCheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayServiceCheckResponse{}
	_body, _err := client.UpdateGatewayServiceCheckWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayServiceTrafficPolicyWithOptions(tmpReq *UpdateGatewayServiceTrafficPolicyRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayServiceTrafficPolicyResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayServiceTrafficPolicyShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GatewayTrafficPolicy)) {
		request.GatewayTrafficPolicyShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GatewayTrafficPolicy, tea.String("GatewayTrafficPolicy"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayTrafficPolicyShrink)) {
		query["GatewayTrafficPolicy"] = request.GatewayTrafficPolicyShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayServiceTrafficPolicy"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayServiceTrafficPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayServiceTrafficPolicy(request *UpdateGatewayServiceTrafficPolicyRequest) (_result *UpdateGatewayServiceTrafficPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayServiceTrafficPolicyResponse{}
	_body, _err := client.UpdateGatewayServiceTrafficPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayServiceVersionWithOptions(request *UpdateGatewayServiceVersionRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayServiceVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["ServiceVersion"] = request.ServiceVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayServiceVersion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayServiceVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayServiceVersion(request *UpdateGatewayServiceVersionRequest) (_result *UpdateGatewayServiceVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayServiceVersionResponse{}
	_body, _err := client.UpdateGatewayServiceVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to update the number of nodes or the specifications of nodes in a pay-as-you-go or subscription cloud-native gateway. If you add nodes or increase the specifications, you will incur fees. For more information, see [Pricing](~~250950~~).
 *
 * @param request UpdateGatewaySpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGatewaySpecResponse
 */
func (client *Client) UpdateGatewaySpecWithOptions(request *UpdateGatewaySpecRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewaySpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Replica)) {
		query["Replica"] = request.Replica
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewaySpec"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewaySpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to update the number of nodes or the specifications of nodes in a pay-as-you-go or subscription cloud-native gateway. If you add nodes or increase the specifications, you will incur fees. For more information, see [Pricing](~~250950~~).
 *
 * @param request UpdateGatewaySpecRequest
 * @return UpdateGatewaySpecResponse
 */
func (client *Client) UpdateGatewaySpec(request *UpdateGatewaySpecRequest) (_result *UpdateGatewaySpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewaySpecResponse{}
	_body, _err := client.UpdateGatewaySpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateImageWithOptions(request *UpdateImageRequest, runtime *util.RuntimeOptions) (_result *UpdateImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.VersionCode)) {
		query["VersionCode"] = request.VersionCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateImage"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateImage(request *UpdateImageRequest) (_result *UpdateImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateImageResponse{}
	_body, _err := client.UpdateImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMessageQueueRouteWithOptions(tmpReq *UpdateMessageQueueRouteRequest, runtime *util.RuntimeOptions) (_result *UpdateMessageQueueRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateMessageQueueRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.FilterSide)) {
		query["FilterSide"] = request.FilterSide
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMessageQueueRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMessageQueueRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMessageQueueRoute(request *UpdateMessageQueueRouteRequest) (_result *UpdateMessageQueueRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMessageQueueRouteResponse{}
	_body, _err := client.UpdateMessageQueueRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMigrationTaskWithOptions(request *UpdateMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceAddress)) {
		query["OriginInstanceAddress"] = request.OriginInstanceAddress
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceName)) {
		query["OriginInstanceName"] = request.OriginInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceNamespace)) {
		query["OriginInstanceNamespace"] = request.OriginInstanceNamespace
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectDesc)) {
		query["ProjectDesc"] = request.ProjectDesc
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterName)) {
		query["TargetClusterName"] = request.TargetClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterUrl)) {
		query["TargetClusterUrl"] = request.TargetClusterUrl
	}

	if !tea.BoolValue(util.IsUnset(request.TargetInstanceId)) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMigrationTask(request *UpdateMigrationTaskRequest) (_result *UpdateMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMigrationTaskResponse{}
	_body, _err := client.UpdateMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateNacosClusterWithOptions(request *UpdateNacosClusterRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CheckPort)) {
		query["CheckPort"] = request.CheckPort
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.HealthChecker)) {
		query["HealthChecker"] = request.HealthChecker
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.UseInstancePortForCheck)) {
		query["UseInstancePortForCheck"] = request.UseInstancePortForCheck
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateNacosCluster(request *UpdateNacosClusterRequest) (_result *UpdateNacosClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosClusterResponse{}
	_body, _err := client.UpdateNacosClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The current API operation is not provided in Nacos SDK. For more information about Nacos SDK, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNacosConfigResponse
 */
func (client *Client) UpdateNacosConfigWithOptions(request *UpdateNacosConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.BetaIps)) {
		query["BetaIps"] = request.BetaIps
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptedDataKey)) {
		query["EncryptedDataKey"] = request.EncryptedDataKey
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Md5)) {
		query["Md5"] = request.Md5
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The current API operation is not provided in Nacos SDK. For more information about Nacos SDK, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosConfigRequest
 * @return UpdateNacosConfigResponse
 */
func (client *Client) UpdateNacosConfig(request *UpdateNacosConfigRequest) (_result *UpdateNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosConfigResponse{}
	_body, _err := client.UpdateNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNacosInstanceResponse
 */
func (client *Client) UpdateNacosInstanceWithOptions(request *UpdateNacosInstanceRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Metadata)) {
		body["Metadata"] = request.Metadata
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosInstance"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosInstanceRequest
 * @return UpdateNacosInstanceResponse
 */
func (client *Client) UpdateNacosInstance(request *UpdateNacosInstanceRequest) (_result *UpdateNacosInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosInstanceResponse{}
	_body, _err := client.UpdateNacosInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNacosServiceResponse
 */
func (client *Client) UpdateNacosServiceWithOptions(request *UpdateNacosServiceRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectThreshold)) {
		query["ProtectThreshold"] = request.ProtectThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosServiceRequest
 * @return UpdateNacosServiceResponse
 */
func (client *Client) UpdateNacosService(request *UpdateNacosServiceRequest) (_result *UpdateNacosServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosServiceResponse{}
	_body, _err := client.UpdateNacosServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePluginConfigWithOptions(request *UpdatePluginConfigRequest, runtime *util.RuntimeOptions) (_result *UpdatePluginConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigLevel)) {
		query["ConfigLevel"] = request.ConfigLevel
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.GmtCreate)) {
		query["GmtCreate"] = request.GmtCreate
	}

	if !tea.BoolValue(util.IsUnset(request.GmtModified)) {
		query["GmtModified"] = request.GmtModified
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.PluginId)) {
		query["PluginId"] = request.PluginId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePluginConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePluginConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePluginConfig(request *UpdatePluginConfigRequest) (_result *UpdatePluginConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePluginConfigResponse{}
	_body, _err := client.UpdatePluginConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSSLCertWithOptions(request *UpdateSSLCertRequest, runtime *util.RuntimeOptions) (_result *UpdateSSLCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSSLCert"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSSLCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSSLCert(request *UpdateSSLCertRequest) (_result *UpdateSSLCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSSLCertResponse{}
	_body, _err := client.UpdateSSLCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateServiceSourceWithOptions(tmpReq *UpdateServiceSourceRequest, runtime *util.RuntimeOptions) (_result *UpdateServiceSourceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateServiceSourceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.IngressOptionsRequest)) {
		request.IngressOptionsRequestShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.IngressOptionsRequest, tea.String("IngressOptionsRequest"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.PathList)) {
		request.PathListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.PathList, tea.String("PathList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.IngressOptionsRequestShrink)) {
		query["IngressOptionsRequest"] = request.IngressOptionsRequestShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PathListShrink)) {
		query["PathList"] = request.PathListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateServiceSource(request *UpdateServiceSourceRequest) (_result *UpdateServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateServiceSourceResponse{}
	_body, _err := client.UpdateServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateZnodeWithOptions(request *UpdateZnodeRequest, runtime *util.RuntimeOptions) (_result *UpdateZnodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		query["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateZnode"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateZnodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateZnode(request *UpdateZnodeRequest) (_result *UpdateZnodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateZnodeResponse{}
	_body, _err := client.UpdateZnodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpgradeClusterWithOptions(request *UpgradeClusterRequest, runtime *util.RuntimeOptions) (_result *UpgradeClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.UpgradeVersion)) {
		query["UpgradeVersion"] = request.UpgradeVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpgradeCluster(request *UpgradeClusterRequest) (_result *UpgradeClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeClusterResponse{}
	_body, _err := client.UpgradeClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
