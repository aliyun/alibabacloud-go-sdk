// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type GatewayDomain struct {
	CertIdentifier  *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	GatewayId       *int64  `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	GatewayName     *string `json:"GatewayName,omitempty" xml:"GatewayName,omitempty"`
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	GmtCreate       *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified     *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Id              *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	MustHttps       *string `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Protocol        *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s GatewayDomain) String() string {
	return tea.Prettify(s)
}

func (s GatewayDomain) GoString() string {
	return s.String()
}

func (s *GatewayDomain) SetCertIdentifier(v string) *GatewayDomain {
	s.CertIdentifier = &v
	return s
}

func (s *GatewayDomain) SetGatewayId(v int64) *GatewayDomain {
	s.GatewayId = &v
	return s
}

func (s *GatewayDomain) SetGatewayName(v string) *GatewayDomain {
	s.GatewayName = &v
	return s
}

func (s *GatewayDomain) SetGatewayUniqueId(v string) *GatewayDomain {
	s.GatewayUniqueId = &v
	return s
}

func (s *GatewayDomain) SetGmtCreate(v string) *GatewayDomain {
	s.GmtCreate = &v
	return s
}

func (s *GatewayDomain) SetGmtModified(v string) *GatewayDomain {
	s.GmtModified = &v
	return s
}

func (s *GatewayDomain) SetId(v int64) *GatewayDomain {
	s.Id = &v
	return s
}

func (s *GatewayDomain) SetMustHttps(v string) *GatewayDomain {
	s.MustHttps = &v
	return s
}

func (s *GatewayDomain) SetName(v string) *GatewayDomain {
	s.Name = &v
	return s
}

func (s *GatewayDomain) SetProtocol(v string) *GatewayDomain {
	s.Protocol = &v
	return s
}

type GatewayOption struct {
	DisableHttp2Alpn           *bool                          `json:"DisableHttp2Alpn,omitempty" xml:"DisableHttp2Alpn,omitempty"`
	EnableHardwareAcceleration *bool                          `json:"EnableHardwareAcceleration,omitempty" xml:"EnableHardwareAcceleration,omitempty"`
	EnableWaf                  *bool                          `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	LogConfigDetails           *GatewayOptionLogConfigDetails `json:"LogConfigDetails,omitempty" xml:"LogConfigDetails,omitempty" type:"Struct"`
	TraceDetails               *GatewayOptionTraceDetails     `json:"TraceDetails,omitempty" xml:"TraceDetails,omitempty" type:"Struct"`
}

func (s GatewayOption) String() string {
	return tea.Prettify(s)
}

func (s GatewayOption) GoString() string {
	return s.String()
}

func (s *GatewayOption) SetDisableHttp2Alpn(v bool) *GatewayOption {
	s.DisableHttp2Alpn = &v
	return s
}

func (s *GatewayOption) SetEnableHardwareAcceleration(v bool) *GatewayOption {
	s.EnableHardwareAcceleration = &v
	return s
}

func (s *GatewayOption) SetEnableWaf(v bool) *GatewayOption {
	s.EnableWaf = &v
	return s
}

func (s *GatewayOption) SetLogConfigDetails(v *GatewayOptionLogConfigDetails) *GatewayOption {
	s.LogConfigDetails = v
	return s
}

func (s *GatewayOption) SetTraceDetails(v *GatewayOptionTraceDetails) *GatewayOption {
	s.TraceDetails = v
	return s
}

type GatewayOptionLogConfigDetails struct {
	LogEnabled   *bool   `json:"LogEnabled,omitempty" xml:"LogEnabled,omitempty"`
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	ProjectName  *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s GatewayOptionLogConfigDetails) String() string {
	return tea.Prettify(s)
}

func (s GatewayOptionLogConfigDetails) GoString() string {
	return s.String()
}

func (s *GatewayOptionLogConfigDetails) SetLogEnabled(v bool) *GatewayOptionLogConfigDetails {
	s.LogEnabled = &v
	return s
}

func (s *GatewayOptionLogConfigDetails) SetLogStoreName(v string) *GatewayOptionLogConfigDetails {
	s.LogStoreName = &v
	return s
}

func (s *GatewayOptionLogConfigDetails) SetProjectName(v string) *GatewayOptionLogConfigDetails {
	s.ProjectName = &v
	return s
}

type GatewayOptionTraceDetails struct {
	Sample       *int64 `json:"Sample,omitempty" xml:"Sample,omitempty"`
	TraceEnabled *bool  `json:"TraceEnabled,omitempty" xml:"TraceEnabled,omitempty"`
}

func (s GatewayOptionTraceDetails) String() string {
	return tea.Prettify(s)
}

func (s GatewayOptionTraceDetails) GoString() string {
	return s.String()
}

func (s *GatewayOptionTraceDetails) SetSample(v int64) *GatewayOptionTraceDetails {
	s.Sample = &v
	return s
}

func (s *GatewayOptionTraceDetails) SetTraceEnabled(v bool) *GatewayOptionTraceDetails {
	s.TraceEnabled = &v
	return s
}

type GatewayService struct {
	GatewayTrafficPolicy *TrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	GatewayUniqueId      *string        `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	GroupName            *string        `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	Id                   *int64         `json:"Id,omitempty" xml:"Id,omitempty"`
	MetaInfo             *string        `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	Name                 *string        `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace            *string        `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	SourceType           *string        `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s GatewayService) String() string {
	return tea.Prettify(s)
}

func (s GatewayService) GoString() string {
	return s.String()
}

func (s *GatewayService) SetGatewayTrafficPolicy(v *TrafficPolicy) *GatewayService {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *GatewayService) SetGatewayUniqueId(v string) *GatewayService {
	s.GatewayUniqueId = &v
	return s
}

func (s *GatewayService) SetGroupName(v string) *GatewayService {
	s.GroupName = &v
	return s
}

func (s *GatewayService) SetId(v int64) *GatewayService {
	s.Id = &v
	return s
}

func (s *GatewayService) SetMetaInfo(v string) *GatewayService {
	s.MetaInfo = &v
	return s
}

func (s *GatewayService) SetName(v string) *GatewayService {
	s.Name = &v
	return s
}

func (s *GatewayService) SetNamespace(v string) *GatewayService {
	s.Namespace = &v
	return s
}

func (s *GatewayService) SetSourceType(v string) *GatewayService {
	s.SourceType = &v
	return s
}

type TrafficPolicy struct {
	LoadBalancerSettings *TrafficPolicyLoadBalancerSettings `json:"LoadBalancerSettings,omitempty" xml:"LoadBalancerSettings,omitempty" type:"Struct"`
	TlsSetting           *TrafficPolicyTlsSetting           `json:"TlsSetting,omitempty" xml:"TlsSetting,omitempty" type:"Struct"`
}

func (s TrafficPolicy) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicy) GoString() string {
	return s.String()
}

func (s *TrafficPolicy) SetLoadBalancerSettings(v *TrafficPolicyLoadBalancerSettings) *TrafficPolicy {
	s.LoadBalancerSettings = v
	return s
}

func (s *TrafficPolicy) SetTlsSetting(v *TrafficPolicyTlsSetting) *TrafficPolicy {
	s.TlsSetting = v
	return s
}

type TrafficPolicyLoadBalancerSettings struct {
	ConsistentHashLBConfig *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig `json:"ConsistentHashLBConfig,omitempty" xml:"ConsistentHashLBConfig,omitempty" type:"Struct"`
	LoadbalancerType       *string                                                  `json:"LoadbalancerType,omitempty" xml:"LoadbalancerType,omitempty"`
	WarmupDuration         *int64                                                   `json:"WarmupDuration,omitempty" xml:"WarmupDuration,omitempty"`
}

func (s TrafficPolicyLoadBalancerSettings) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyLoadBalancerSettings) GoString() string {
	return s.String()
}

func (s *TrafficPolicyLoadBalancerSettings) SetConsistentHashLBConfig(v *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) *TrafficPolicyLoadBalancerSettings {
	s.ConsistentHashLBConfig = v
	return s
}

func (s *TrafficPolicyLoadBalancerSettings) SetLoadbalancerType(v string) *TrafficPolicyLoadBalancerSettings {
	s.LoadbalancerType = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettings) SetWarmupDuration(v int64) *TrafficPolicyLoadBalancerSettings {
	s.WarmupDuration = &v
	return s
}

type TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig struct {
	ConsistentHashLBType *string                                                            `json:"ConsistentHashLBType,omitempty" xml:"ConsistentHashLBType,omitempty"`
	HttpCookie           *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie `json:"HttpCookie,omitempty" xml:"HttpCookie,omitempty" type:"Struct"`
	ParameterName        *string                                                            `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) GoString() string {
	return s.String()
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetConsistentHashLBType(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ConsistentHashLBType = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetHttpCookie(v *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.HttpCookie = v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetParameterName(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ParameterName = &v
	return s
}

type TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie struct {
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	TTL  *string `json:"TTL,omitempty" xml:"TTL,omitempty"`
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) GoString() string {
	return s.String()
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetName(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Name = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetPath(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Path = &v
	return s
}

func (s *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetTTL(v string) *TrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.TTL = &v
	return s
}

type TrafficPolicyTlsSetting struct {
	CaCertContent *string `json:"CaCertContent,omitempty" xml:"CaCertContent,omitempty"`
	CertId        *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	Sni           *string `json:"Sni,omitempty" xml:"Sni,omitempty"`
	TlsMode       *string `json:"TlsMode,omitempty" xml:"TlsMode,omitempty"`
}

func (s TrafficPolicyTlsSetting) String() string {
	return tea.Prettify(s)
}

func (s TrafficPolicyTlsSetting) GoString() string {
	return s.String()
}

func (s *TrafficPolicyTlsSetting) SetCaCertContent(v string) *TrafficPolicyTlsSetting {
	s.CaCertContent = &v
	return s
}

func (s *TrafficPolicyTlsSetting) SetCertId(v string) *TrafficPolicyTlsSetting {
	s.CertId = &v
	return s
}

func (s *TrafficPolicyTlsSetting) SetSni(v string) *TrafficPolicyTlsSetting {
	s.Sni = &v
	return s
}

func (s *TrafficPolicyTlsSetting) SetTlsMode(v string) *TrafficPolicyTlsSetting {
	s.TlsMode = &v
	return s
}

type AddAuthResourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the authorization record.
	AuthId                 *int64                                          `json:"AuthId,omitempty" xml:"AuthId,omitempty"`
	AuthResourceHeaderList []*AddAuthResourceRequestAuthResourceHeaderList `json:"AuthResourceHeaderList,omitempty" xml:"AuthResourceHeaderList,omitempty" type:"Repeated"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	IgnoreCase      *bool   `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The matching type.
	//
	// *   exact: exact matching
	// *   prefix: prefix matching
	// *   regex: regular expression matching
	MatchType *string `json:"MatchType,omitempty" xml:"MatchType,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AddAuthResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceRequest) GoString() string {
	return s.String()
}

func (s *AddAuthResourceRequest) SetAcceptLanguage(v string) *AddAuthResourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddAuthResourceRequest) SetAuthId(v int64) *AddAuthResourceRequest {
	s.AuthId = &v
	return s
}

func (s *AddAuthResourceRequest) SetAuthResourceHeaderList(v []*AddAuthResourceRequestAuthResourceHeaderList) *AddAuthResourceRequest {
	s.AuthResourceHeaderList = v
	return s
}

func (s *AddAuthResourceRequest) SetDomainId(v int64) *AddAuthResourceRequest {
	s.DomainId = &v
	return s
}

func (s *AddAuthResourceRequest) SetGatewayUniqueId(v string) *AddAuthResourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddAuthResourceRequest) SetIgnoreCase(v bool) *AddAuthResourceRequest {
	s.IgnoreCase = &v
	return s
}

func (s *AddAuthResourceRequest) SetMatchType(v string) *AddAuthResourceRequest {
	s.MatchType = &v
	return s
}

func (s *AddAuthResourceRequest) SetPath(v string) *AddAuthResourceRequest {
	s.Path = &v
	return s
}

type AddAuthResourceRequestAuthResourceHeaderList struct {
	HeaderKey    *string `json:"HeaderKey,omitempty" xml:"HeaderKey,omitempty"`
	HeaderMethod *string `json:"HeaderMethod,omitempty" xml:"HeaderMethod,omitempty"`
	HeaderValue  *string `json:"HeaderValue,omitempty" xml:"HeaderValue,omitempty"`
}

func (s AddAuthResourceRequestAuthResourceHeaderList) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceRequestAuthResourceHeaderList) GoString() string {
	return s.String()
}

func (s *AddAuthResourceRequestAuthResourceHeaderList) SetHeaderKey(v string) *AddAuthResourceRequestAuthResourceHeaderList {
	s.HeaderKey = &v
	return s
}

func (s *AddAuthResourceRequestAuthResourceHeaderList) SetHeaderMethod(v string) *AddAuthResourceRequestAuthResourceHeaderList {
	s.HeaderMethod = &v
	return s
}

func (s *AddAuthResourceRequestAuthResourceHeaderList) SetHeaderValue(v string) *AddAuthResourceRequestAuthResourceHeaderList {
	s.HeaderValue = &v
	return s
}

type AddAuthResourceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the authorization record.
	AuthId                       *int64  `json:"AuthId,omitempty" xml:"AuthId,omitempty"`
	AuthResourceHeaderListShrink *string `json:"AuthResourceHeaderList,omitempty" xml:"AuthResourceHeaderList,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	IgnoreCase      *bool   `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The matching type.
	//
	// *   exact: exact matching
	// *   prefix: prefix matching
	// *   regex: regular expression matching
	MatchType *string `json:"MatchType,omitempty" xml:"MatchType,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AddAuthResourceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddAuthResourceShrinkRequest) SetAcceptLanguage(v string) *AddAuthResourceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetAuthId(v int64) *AddAuthResourceShrinkRequest {
	s.AuthId = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetAuthResourceHeaderListShrink(v string) *AddAuthResourceShrinkRequest {
	s.AuthResourceHeaderListShrink = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetDomainId(v int64) *AddAuthResourceShrinkRequest {
	s.DomainId = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetGatewayUniqueId(v string) *AddAuthResourceShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetIgnoreCase(v bool) *AddAuthResourceShrinkRequest {
	s.IgnoreCase = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetMatchType(v string) *AddAuthResourceShrinkRequest {
	s.MatchType = &v
	return s
}

func (s *AddAuthResourceShrinkRequest) SetPath(v string) *AddAuthResourceShrinkRequest {
	s.Path = &v
	return s
}

type AddAuthResourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddAuthResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceResponseBody) GoString() string {
	return s.String()
}

func (s *AddAuthResourceResponseBody) SetCode(v int32) *AddAuthResourceResponseBody {
	s.Code = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetData(v int64) *AddAuthResourceResponseBody {
	s.Data = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetHttpStatusCode(v int32) *AddAuthResourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetMessage(v string) *AddAuthResourceResponseBody {
	s.Message = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetRequestId(v string) *AddAuthResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddAuthResourceResponseBody) SetSuccess(v bool) *AddAuthResourceResponseBody {
	s.Success = &v
	return s
}

type AddAuthResourceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddAuthResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddAuthResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAuthResourceResponse) GoString() string {
	return s.String()
}

func (s *AddAuthResourceResponse) SetHeaders(v map[string]*string) *AddAuthResourceResponse {
	s.Headers = v
	return s
}

func (s *AddAuthResourceResponse) SetStatusCode(v int32) *AddAuthResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAuthResourceResponse) SetBody(v *AddAuthResourceResponseBody) *AddAuthResourceResponse {
	s.Body = v
	return s
}

type AddBlackWhiteListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The content of the blacklist.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to create a whitelist.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The description.
	Note *string `json:"Note,omitempty" xml:"Note,omitempty"`
	// The resource IDs in the JSON format.
	ResourceIdJsonList *string `json:"ResourceIdJsonList,omitempty" xml:"ResourceIdJsonList,omitempty"`
	// The resource type to which the blacklist or whitelist applies.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the blacklist.
	//
	// *   on: enabled
	// *   off: disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of object in the blacklist or whitelist.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddBlackWhiteListRequest) String() string {
	return tea.Prettify(s)
}

func (s AddBlackWhiteListRequest) GoString() string {
	return s.String()
}

func (s *AddBlackWhiteListRequest) SetAcceptLanguage(v string) *AddBlackWhiteListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetContent(v string) *AddBlackWhiteListRequest {
	s.Content = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetGatewayUniqueId(v string) *AddBlackWhiteListRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetIsWhite(v bool) *AddBlackWhiteListRequest {
	s.IsWhite = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetName(v string) *AddBlackWhiteListRequest {
	s.Name = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetNote(v string) *AddBlackWhiteListRequest {
	s.Note = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetResourceIdJsonList(v string) *AddBlackWhiteListRequest {
	s.ResourceIdJsonList = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetResourceType(v string) *AddBlackWhiteListRequest {
	s.ResourceType = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetStatus(v string) *AddBlackWhiteListRequest {
	s.Status = &v
	return s
}

func (s *AddBlackWhiteListRequest) SetType(v string) *AddBlackWhiteListRequest {
	s.Type = &v
	return s
}

type AddBlackWhiteListResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the record.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddBlackWhiteListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddBlackWhiteListResponseBody) GoString() string {
	return s.String()
}

func (s *AddBlackWhiteListResponseBody) SetCode(v int32) *AddBlackWhiteListResponseBody {
	s.Code = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetData(v int64) *AddBlackWhiteListResponseBody {
	s.Data = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetHttpStatusCode(v int32) *AddBlackWhiteListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetMessage(v string) *AddBlackWhiteListResponseBody {
	s.Message = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetRequestId(v string) *AddBlackWhiteListResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddBlackWhiteListResponseBody) SetSuccess(v bool) *AddBlackWhiteListResponseBody {
	s.Success = &v
	return s
}

type AddBlackWhiteListResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddBlackWhiteListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddBlackWhiteListResponse) String() string {
	return tea.Prettify(s)
}

func (s AddBlackWhiteListResponse) GoString() string {
	return s.String()
}

func (s *AddBlackWhiteListResponse) SetHeaders(v map[string]*string) *AddBlackWhiteListResponse {
	s.Headers = v
	return s
}

func (s *AddBlackWhiteListResponse) SetStatusCode(v int32) *AddBlackWhiteListResponse {
	s.StatusCode = &v
	return s
}

func (s *AddBlackWhiteListResponse) SetBody(v *AddBlackWhiteListResponseBody) *AddBlackWhiteListResponse {
	s.Body = v
	return s
}

type AddGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable hardware acceleration.
	EnableHardwareAcceleration *bool `json:"EnableHardwareAcceleration,omitempty" xml:"EnableHardwareAcceleration,omitempty"`
	// Specifies whether to activate Log Service.
	EnableSls *bool `json:"EnableSls,omitempty" xml:"EnableSls,omitempty"`
	// Specifies whether to activate Tracing Analysis.
	EnableXtrace *bool `json:"EnableXtrace,omitempty" xml:"EnableXtrace,omitempty"`
	// Specifies whether to use an advanced security group.
	EnterpriseSecurityGroup *bool `json:"EnterpriseSecurityGroup,omitempty" xml:"EnterpriseSecurityGroup,omitempty"`
	// The specifications of the Internet-facing SLB instance. Valid values:
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	InternetSlbSpec *string `json:"InternetSlbSpec,omitempty" xml:"InternetSlbSpec,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of nodes.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The specifications of the internal-facing Server Load Balancer (SLB) instance. Valid values:
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	SlbSpec *string `json:"SlbSpec,omitempty" xml:"SlbSpec,omitempty"`
	// The node specifications. Valid values:
	//
	// *   MSE_GTW\_16\_32\_200\_c(16C32G)
	// *   MSE_GTW\_2\_4\_200\_c(2C4G)
	// *   MSE_GTW\_4\_8\_200\_c(4C8G)
	// *   MSE_GTW\_8\_16\_200\_c(8C16G)
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The tag of the gateway.
	Tag []*AddGatewayRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the primary vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the secondary vSwitch.
	VSwitchId2 *string `json:"VSwitchId2,omitempty" xml:"VSwitchId2,omitempty"`
	// The ID of the virtual private cloud (VPC) in which the instances reside.
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
	// The sample rate of Tracing Analysis. Valid values: \[1,100].
	XtraceRatio *string `json:"XtraceRatio,omitempty" xml:"XtraceRatio,omitempty"`
}

func (s AddGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayRequest) SetAcceptLanguage(v string) *AddGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayRequest) SetEnableHardwareAcceleration(v bool) *AddGatewayRequest {
	s.EnableHardwareAcceleration = &v
	return s
}

func (s *AddGatewayRequest) SetEnableSls(v bool) *AddGatewayRequest {
	s.EnableSls = &v
	return s
}

func (s *AddGatewayRequest) SetEnableXtrace(v bool) *AddGatewayRequest {
	s.EnableXtrace = &v
	return s
}

func (s *AddGatewayRequest) SetEnterpriseSecurityGroup(v bool) *AddGatewayRequest {
	s.EnterpriseSecurityGroup = &v
	return s
}

func (s *AddGatewayRequest) SetInternetSlbSpec(v string) *AddGatewayRequest {
	s.InternetSlbSpec = &v
	return s
}

func (s *AddGatewayRequest) SetName(v string) *AddGatewayRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayRequest) SetRegion(v string) *AddGatewayRequest {
	s.Region = &v
	return s
}

func (s *AddGatewayRequest) SetReplica(v int32) *AddGatewayRequest {
	s.Replica = &v
	return s
}

func (s *AddGatewayRequest) SetResourceGroupId(v string) *AddGatewayRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddGatewayRequest) SetSlbSpec(v string) *AddGatewayRequest {
	s.SlbSpec = &v
	return s
}

func (s *AddGatewayRequest) SetSpec(v string) *AddGatewayRequest {
	s.Spec = &v
	return s
}

func (s *AddGatewayRequest) SetTag(v []*AddGatewayRequestTag) *AddGatewayRequest {
	s.Tag = v
	return s
}

func (s *AddGatewayRequest) SetVSwitchId(v string) *AddGatewayRequest {
	s.VSwitchId = &v
	return s
}

func (s *AddGatewayRequest) SetVSwitchId2(v string) *AddGatewayRequest {
	s.VSwitchId2 = &v
	return s
}

func (s *AddGatewayRequest) SetVpc(v string) *AddGatewayRequest {
	s.Vpc = &v
	return s
}

func (s *AddGatewayRequest) SetXtraceRatio(v string) *AddGatewayRequest {
	s.XtraceRatio = &v
	return s
}

type AddGatewayRequestTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGatewayRequestTag) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRequestTag) GoString() string {
	return s.String()
}

func (s *AddGatewayRequestTag) SetKey(v string) *AddGatewayRequestTag {
	s.Key = &v
	return s
}

func (s *AddGatewayRequestTag) SetValue(v string) *AddGatewayRequestTag {
	s.Value = &v
	return s
}

type AddGatewayResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *AddGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayResponseBody) SetCode(v int32) *AddGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayResponseBody) SetData(v *AddGatewayResponseBodyData) *AddGatewayResponseBody {
	s.Data = v
	return s
}

func (s *AddGatewayResponseBody) SetHttpStatusCode(v int32) *AddGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayResponseBody) SetMessage(v string) *AddGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayResponseBody) SetRequestId(v string) *AddGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayResponseBody) SetSuccess(v bool) *AddGatewayResponseBody {
	s.Success = &v
	return s
}

type AddGatewayResponseBodyData struct {
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s AddGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddGatewayResponseBodyData) SetGatewayUniqueId(v string) *AddGatewayResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

type AddGatewayResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayResponse) SetHeaders(v map[string]*string) *AddGatewayResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayResponse) SetStatusCode(v int32) *AddGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayResponse) SetBody(v *AddGatewayResponseBody) *AddGatewayResponse {
	s.Body = v
	return s
}

type AddGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to enable `HTTP/2`.
	//
	// *   `open`: enables `HTTP/2`
	// *   `close`: disables `HTTP/2`
	// *   `globalConfig`: uses global configurations
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// Specifies whether to enable HTTPS.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The domain name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   `HTTP`
	// *   `HTTPS`
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
}

func (s AddGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayDomainRequest) SetAcceptLanguage(v string) *AddGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayDomainRequest) SetCertIdentifier(v string) *AddGatewayDomainRequest {
	s.CertIdentifier = &v
	return s
}

func (s *AddGatewayDomainRequest) SetGatewayUniqueId(v string) *AddGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayDomainRequest) SetHttp2(v string) *AddGatewayDomainRequest {
	s.Http2 = &v
	return s
}

func (s *AddGatewayDomainRequest) SetMustHttps(v bool) *AddGatewayDomainRequest {
	s.MustHttps = &v
	return s
}

func (s *AddGatewayDomainRequest) SetName(v string) *AddGatewayDomainRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayDomainRequest) SetProtocol(v string) *AddGatewayDomainRequest {
	s.Protocol = &v
	return s
}

func (s *AddGatewayDomainRequest) SetTlsMax(v string) *AddGatewayDomainRequest {
	s.TlsMax = &v
	return s
}

func (s *AddGatewayDomainRequest) SetTlsMin(v string) *AddGatewayDomainRequest {
	s.TlsMin = &v
	return s
}

type AddGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayDomainResponseBody) SetCode(v int32) *AddGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetData(v int64) *AddGatewayDomainResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetHttpStatusCode(v int32) *AddGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetMessage(v string) *AddGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetRequestId(v string) *AddGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayDomainResponseBody) SetSuccess(v bool) *AddGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type AddGatewayDomainResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayDomainResponse) SetHeaders(v map[string]*string) *AddGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayDomainResponse) SetStatusCode(v int32) *AddGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayDomainResponse) SetBody(v *AddGatewayDomainResponseBody) *AddGatewayDomainResponse {
	s.Body = v
	return s
}

type AddGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The mock response configuration.
	DirectResponseJSON *AddGatewayRouteRequestDirectResponseJSON `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The list of domain names.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to enable Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServices []*AddGatewayRouteRequestFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rule.
	Predicates *AddGatewayRouteRequestPredicates `json:"Predicates,omitempty" xml:"Predicates,omitempty" type:"Struct"`
	// The configuration of the redirection.
	RedirectJSON *AddGatewayRouteRequestRedirectJSON `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty" type:"Struct"`
	// The sequence number of the route. (A small value indicates a high priority.)
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about services.
	Services []*AddGatewayRouteRequestServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequest) SetAcceptLanguage(v string) *AddGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayRouteRequest) SetDestinationType(v string) *AddGatewayRouteRequest {
	s.DestinationType = &v
	return s
}

func (s *AddGatewayRouteRequest) SetDirectResponseJSON(v *AddGatewayRouteRequestDirectResponseJSON) *AddGatewayRouteRequest {
	s.DirectResponseJSON = v
	return s
}

func (s *AddGatewayRouteRequest) SetDomainId(v int64) *AddGatewayRouteRequest {
	s.DomainId = &v
	return s
}

func (s *AddGatewayRouteRequest) SetDomainIdListJSON(v string) *AddGatewayRouteRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *AddGatewayRouteRequest) SetEnableWaf(v bool) *AddGatewayRouteRequest {
	s.EnableWaf = &v
	return s
}

func (s *AddGatewayRouteRequest) SetFallback(v bool) *AddGatewayRouteRequest {
	s.Fallback = &v
	return s
}

func (s *AddGatewayRouteRequest) SetFallbackServices(v []*AddGatewayRouteRequestFallbackServices) *AddGatewayRouteRequest {
	s.FallbackServices = v
	return s
}

func (s *AddGatewayRouteRequest) SetGatewayId(v int64) *AddGatewayRouteRequest {
	s.GatewayId = &v
	return s
}

func (s *AddGatewayRouteRequest) SetGatewayUniqueId(v string) *AddGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayRouteRequest) SetName(v string) *AddGatewayRouteRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteRequest) SetPredicates(v *AddGatewayRouteRequestPredicates) *AddGatewayRouteRequest {
	s.Predicates = v
	return s
}

func (s *AddGatewayRouteRequest) SetRedirectJSON(v *AddGatewayRouteRequestRedirectJSON) *AddGatewayRouteRequest {
	s.RedirectJSON = v
	return s
}

func (s *AddGatewayRouteRequest) SetRouteOrder(v int32) *AddGatewayRouteRequest {
	s.RouteOrder = &v
	return s
}

func (s *AddGatewayRouteRequest) SetServices(v []*AddGatewayRouteRequestServices) *AddGatewayRouteRequest {
	s.Services = v
	return s
}

type AddGatewayRouteRequestDirectResponseJSON struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The mock return code.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s AddGatewayRouteRequestDirectResponseJSON) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestDirectResponseJSON) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestDirectResponseJSON) SetBody(v string) *AddGatewayRouteRequestDirectResponseJSON {
	s.Body = &v
	return s
}

func (s *AddGatewayRouteRequestDirectResponseJSON) SetCode(v int64) *AddGatewayRouteRequestDirectResponseJSON {
	s.Code = &v
	return s
}

type AddGatewayRouteRequestFallbackServices struct {
	// The type of the protocol. Valid values:
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace in which the service resides.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s AddGatewayRouteRequestFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestFallbackServices) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestFallbackServices) SetAgreementType(v string) *AddGatewayRouteRequestFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetGroupName(v string) *AddGatewayRouteRequestFallbackServices {
	s.GroupName = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetName(v string) *AddGatewayRouteRequestFallbackServices {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetNamespace(v string) *AddGatewayRouteRequestFallbackServices {
	s.Namespace = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetPercent(v int32) *AddGatewayRouteRequestFallbackServices {
	s.Percent = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetServiceId(v int64) *AddGatewayRouteRequestFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetServicePort(v int32) *AddGatewayRouteRequestFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetSourceType(v string) *AddGatewayRouteRequestFallbackServices {
	s.SourceType = &v
	return s
}

func (s *AddGatewayRouteRequestFallbackServices) SetVersion(v string) *AddGatewayRouteRequestFallbackServices {
	s.Version = &v
	return s
}

type AddGatewayRouteRequestPredicates struct {
	// The information about header matching.
	HeaderPredicates []*AddGatewayRouteRequestPredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about route matching.
	PathPredicates *AddGatewayRouteRequestPredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The information about URL parameter matching.
	QueryPredicates []*AddGatewayRouteRequestPredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequestPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicates) SetHeaderPredicates(v []*AddGatewayRouteRequestPredicatesHeaderPredicates) *AddGatewayRouteRequestPredicates {
	s.HeaderPredicates = v
	return s
}

func (s *AddGatewayRouteRequestPredicates) SetMethodPredicates(v []*string) *AddGatewayRouteRequestPredicates {
	s.MethodPredicates = v
	return s
}

func (s *AddGatewayRouteRequestPredicates) SetPathPredicates(v *AddGatewayRouteRequestPredicatesPathPredicates) *AddGatewayRouteRequestPredicates {
	s.PathPredicates = v
	return s
}

func (s *AddGatewayRouteRequestPredicates) SetQueryPredicates(v []*AddGatewayRouteRequestPredicatesQueryPredicates) *AddGatewayRouteRequestPredicates {
	s.QueryPredicates = v
	return s
}

type AddGatewayRouteRequestPredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGatewayRouteRequestPredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicatesHeaderPredicates) SetKey(v string) *AddGatewayRouteRequestPredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesHeaderPredicates) SetType(v string) *AddGatewayRouteRequestPredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesHeaderPredicates) SetValue(v string) *AddGatewayRouteRequestPredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type AddGatewayRouteRequestPredicatesPathPredicates struct {
	// Specifies whether to perform case-insensitive matching.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The route matching type. Valid values:
	//
	// *   PRE: prefix matching
	// *   EQUAL: exact matching
	// *   REGULAR: regular expression matching
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddGatewayRouteRequestPredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicatesPathPredicates) SetIgnoreCase(v bool) *AddGatewayRouteRequestPredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesPathPredicates) SetPath(v string) *AddGatewayRouteRequestPredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesPathPredicates) SetType(v string) *AddGatewayRouteRequestPredicatesPathPredicates {
	s.Type = &v
	return s
}

type AddGatewayRouteRequestPredicatesQueryPredicates struct {
	// The name of the parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGatewayRouteRequestPredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestPredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestPredicatesQueryPredicates) SetKey(v string) *AddGatewayRouteRequestPredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesQueryPredicates) SetType(v string) *AddGatewayRouteRequestPredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *AddGatewayRouteRequestPredicatesQueryPredicates) SetValue(v string) *AddGatewayRouteRequestPredicatesQueryPredicates {
	s.Value = &v
	return s
}

type AddGatewayRouteRequestRedirectJSON struct {
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname to be redirected to.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path to be redirected to.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AddGatewayRouteRequestRedirectJSON) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestRedirectJSON) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestRedirectJSON) SetCode(v int32) *AddGatewayRouteRequestRedirectJSON {
	s.Code = &v
	return s
}

func (s *AddGatewayRouteRequestRedirectJSON) SetHost(v string) *AddGatewayRouteRequestRedirectJSON {
	s.Host = &v
	return s
}

func (s *AddGatewayRouteRequestRedirectJSON) SetPath(v string) *AddGatewayRouteRequestRedirectJSON {
	s.Path = &v
	return s
}

type AddGatewayRouteRequestServices struct {
	// The type of the protocol. Valid values:
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The transcoder of the Dubbo protocol.
	HttpDubboTranscoder *AddGatewayRouteRequestServicesHttpDubboTranscoder `json:"HttpDubboTranscoder,omitempty" xml:"HttpDubboTranscoder,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace in which the service resides.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s AddGatewayRouteRequestServices) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServices) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServices) SetAgreementType(v string) *AddGatewayRouteRequestServices {
	s.AgreementType = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetGroupName(v string) *AddGatewayRouteRequestServices {
	s.GroupName = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetHttpDubboTranscoder(v *AddGatewayRouteRequestServicesHttpDubboTranscoder) *AddGatewayRouteRequestServices {
	s.HttpDubboTranscoder = v
	return s
}

func (s *AddGatewayRouteRequestServices) SetName(v string) *AddGatewayRouteRequestServices {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetNamespace(v string) *AddGatewayRouteRequestServices {
	s.Namespace = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetPercent(v int32) *AddGatewayRouteRequestServices {
	s.Percent = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetServiceId(v int64) *AddGatewayRouteRequestServices {
	s.ServiceId = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetServicePort(v int32) *AddGatewayRouteRequestServices {
	s.ServicePort = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetSourceType(v string) *AddGatewayRouteRequestServices {
	s.SourceType = &v
	return s
}

func (s *AddGatewayRouteRequestServices) SetVersion(v string) *AddGatewayRouteRequestServices {
	s.Version = &v
	return s
}

type AddGatewayRouteRequestServicesHttpDubboTranscoder struct {
	// The service group.
	DubboServiceGroup *string `json:"DubboServiceGroup,omitempty" xml:"DubboServiceGroup,omitempty"`
	// The name of the Dubbo service.
	DubboServiceName *string `json:"DubboServiceName,omitempty" xml:"DubboServiceName,omitempty"`
	// The version of the Dubbo service.
	DubboServiceVersion *string `json:"DubboServiceVersion,omitempty" xml:"DubboServiceVersion,omitempty"`
	// The forwarding rules of the Dubbo service.
	MothedMapList []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList `json:"MothedMapList,omitempty" xml:"MothedMapList,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoder) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoder) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceGroup(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceGroup = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceName(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceName = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceVersion(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceVersion = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoder) SetMothedMapList(v []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) *AddGatewayRouteRequestServicesHttpDubboTranscoder {
	s.MothedMapList = v
	return s
}

type AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList struct {
	// The method name of the Dubbo service.
	DubboMothedName *string `json:"DubboMothedName,omitempty" xml:"DubboMothedName,omitempty"`
	// The HTTP method.
	//
	// > Valid values:
	//
	// *   ALL_GET
	//
	// *   ALL_POST
	//
	// *   ALL_PUT
	//
	// *   ALL_DELETE
	//
	// *   ALL_PATCH
	HttpMothed *string `json:"HttpMothed,omitempty" xml:"HttpMothed,omitempty"`
	// The path that is used to match a method.
	Mothedpath *string `json:"Mothedpath,omitempty" xml:"Mothedpath,omitempty"`
	// The information of parameter mappings.
	ParamMapsList []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList `json:"ParamMapsList,omitempty" xml:"ParamMapsList,omitempty" type:"Repeated"`
	// The pass-through type of the header.
	//
	// > Valid values:
	//
	// *   PASS_ALL: All headers are passed through.
	//
	// *   PASS_NOT: All headers are not passed through.
	//
	// *   PASS_ASSIGN: Specified headers are passed through.
	PassThroughAllHeaders *string `json:"PassThroughAllHeaders,omitempty" xml:"PassThroughAllHeaders,omitempty"`
	// The list of headers to be passed through.
	PassThroughList []*string `json:"PassThroughList,omitempty" xml:"PassThroughList,omitempty" type:"Repeated"`
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetDubboMothedName(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.DubboMothedName = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetHttpMothed(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.HttpMothed = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetMothedpath(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.Mothedpath = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetParamMapsList(v []*AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.ParamMapsList = v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughAllHeaders(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughAllHeaders = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughList(v []*string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughList = v
	return s
}

type AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList struct {
	// The key extracted from the input parameter.
	ExtractKey *string `json:"ExtractKey,omitempty" xml:"ExtractKey,omitempty"`
	// The position of the input parameter.
	//
	// > Valid values:
	//
	// *   `ALL_QUERY_PARAMETER`: request parameter
	//
	// *   `ALL_HEADER`: request header
	// *   `ALL_PATH`: request path
	// *   `ALL_BODY`: request body
	ExtractKeySpec *string `json:"ExtractKeySpec,omitempty" xml:"ExtractKeySpec,omitempty"`
	// The type of the backend service parameter.
	MappingType *string `json:"MappingType,omitempty" xml:"MappingType,omitempty"`
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKey(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKey = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKeySpec(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKeySpec = &v
	return s
}

func (s *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetMappingType(v string) *AddGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.MappingType = &v
	return s
}

type AddGatewayRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The mock response configuration.
	DirectResponseJSONShrink *string `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The list of domain names.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to enable Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServicesShrink *string `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rule.
	PredicatesShrink *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The configuration of the redirection.
	RedirectJSONShrink *string `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty"`
	// The sequence number of the route. (A small value indicates a high priority.)
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about services.
	ServicesShrink *string `json:"Services,omitempty" xml:"Services,omitempty"`
}

func (s AddGatewayRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteShrinkRequest) SetAcceptLanguage(v string) *AddGatewayRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDestinationType(v string) *AddGatewayRouteShrinkRequest {
	s.DestinationType = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDirectResponseJSONShrink(v string) *AddGatewayRouteShrinkRequest {
	s.DirectResponseJSONShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDomainId(v int64) *AddGatewayRouteShrinkRequest {
	s.DomainId = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetDomainIdListJSON(v string) *AddGatewayRouteShrinkRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetEnableWaf(v bool) *AddGatewayRouteShrinkRequest {
	s.EnableWaf = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetFallback(v bool) *AddGatewayRouteShrinkRequest {
	s.Fallback = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetFallbackServicesShrink(v string) *AddGatewayRouteShrinkRequest {
	s.FallbackServicesShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetGatewayId(v int64) *AddGatewayRouteShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetGatewayUniqueId(v string) *AddGatewayRouteShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetName(v string) *AddGatewayRouteShrinkRequest {
	s.Name = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetPredicatesShrink(v string) *AddGatewayRouteShrinkRequest {
	s.PredicatesShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetRedirectJSONShrink(v string) *AddGatewayRouteShrinkRequest {
	s.RedirectJSONShrink = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetRouteOrder(v int32) *AddGatewayRouteShrinkRequest {
	s.RouteOrder = &v
	return s
}

func (s *AddGatewayRouteShrinkRequest) SetServicesShrink(v string) *AddGatewayRouteShrinkRequest {
	s.ServicesShrink = &v
	return s
}

type AddGatewayRouteResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response data.
	Data      *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteResponseBody) SetCode(v int32) *AddGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetData(v int64) *AddGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetErrorCode(v string) *AddGatewayRouteResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetHttpStatusCode(v int32) *AddGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetMessage(v string) *AddGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetRequestId(v string) *AddGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayRouteResponseBody) SetSuccess(v bool) *AddGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type AddGatewayRouteResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayRouteResponse) SetHeaders(v map[string]*string) *AddGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayRouteResponse) SetStatusCode(v int32) *AddGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayRouteResponse) SetBody(v *AddGatewayRouteResponseBody) *AddGatewayRouteResponse {
	s.Body = v
	return s
}

type AddGatewayServiceVersionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty"`
}

func (s AddGatewayServiceVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayServiceVersionRequest) GoString() string {
	return s.String()
}

func (s *AddGatewayServiceVersionRequest) SetAcceptLanguage(v string) *AddGatewayServiceVersionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewayServiceVersionRequest) SetGatewayUniqueId(v string) *AddGatewayServiceVersionRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewayServiceVersionRequest) SetServiceId(v int64) *AddGatewayServiceVersionRequest {
	s.ServiceId = &v
	return s
}

func (s *AddGatewayServiceVersionRequest) SetServiceVersion(v string) *AddGatewayServiceVersionRequest {
	s.ServiceVersion = &v
	return s
}

type AddGatewayServiceVersionResponseBody struct {
	// The status code returned. The value 200 indicates that the request is successfully processed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the gateway service.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewayServiceVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayServiceVersionResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewayServiceVersionResponseBody) SetCode(v int32) *AddGatewayServiceVersionResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetData(v int64) *AddGatewayServiceVersionResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetHttpStatusCode(v int32) *AddGatewayServiceVersionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetMessage(v string) *AddGatewayServiceVersionResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetRequestId(v string) *AddGatewayServiceVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewayServiceVersionResponseBody) SetSuccess(v bool) *AddGatewayServiceVersionResponseBody {
	s.Success = &v
	return s
}

type AddGatewayServiceVersionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewayServiceVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewayServiceVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewayServiceVersionResponse) GoString() string {
	return s.String()
}

func (s *AddGatewayServiceVersionResponse) SetHeaders(v map[string]*string) *AddGatewayServiceVersionResponse {
	s.Headers = v
	return s
}

func (s *AddGatewayServiceVersionResponse) SetStatusCode(v int32) *AddGatewayServiceVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewayServiceVersionResponse) SetBody(v *AddGatewayServiceVersionResponseBody) *AddGatewayServiceVersionResponse {
	s.Body = v
	return s
}

type AddGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The HTTP port number (virtual service group).
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The HTTPS port number (virtual service group).
	HttpsPort *int32 `json:"HttpsPort,omitempty" xml:"HttpsPort,omitempty"`
	// The ID of the HTTPS virtual service group.
	HttpsVServerGroupId *string `json:"HttpsVServerGroupId,omitempty" xml:"HttpsVServerGroupId,omitempty"`
	// The service weight.
	ServiceWeight *int32 `json:"ServiceWeight,omitempty" xml:"ServiceWeight,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   PUB_NET: public network
	// *   PRIVATE_NET: private network
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the HTTP virtual service group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s AddGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbRequest) SetAcceptLanguage(v string) *AddGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddGatewaySlbRequest) SetGatewayUniqueId(v string) *AddGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddGatewaySlbRequest) SetHttpPort(v int32) *AddGatewaySlbRequest {
	s.HttpPort = &v
	return s
}

func (s *AddGatewaySlbRequest) SetHttpsPort(v int32) *AddGatewaySlbRequest {
	s.HttpsPort = &v
	return s
}

func (s *AddGatewaySlbRequest) SetHttpsVServerGroupId(v string) *AddGatewaySlbRequest {
	s.HttpsVServerGroupId = &v
	return s
}

func (s *AddGatewaySlbRequest) SetServiceWeight(v int32) *AddGatewaySlbRequest {
	s.ServiceWeight = &v
	return s
}

func (s *AddGatewaySlbRequest) SetSlbId(v string) *AddGatewaySlbRequest {
	s.SlbId = &v
	return s
}

func (s *AddGatewaySlbRequest) SetType(v string) *AddGatewaySlbRequest {
	s.Type = &v
	return s
}

func (s *AddGatewaySlbRequest) SetVServerGroupId(v string) *AddGatewaySlbRequest {
	s.VServerGroupId = &v
	return s
}

type AddGatewaySlbResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbResponseBody) SetCode(v int32) *AddGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetData(v string) *AddGatewaySlbResponseBody {
	s.Data = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetHttpStatusCode(v int32) *AddGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetMessage(v string) *AddGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetRequestId(v string) *AddGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGatewaySlbResponseBody) SetSuccess(v bool) *AddGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type AddGatewaySlbResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *AddGatewaySlbResponse) SetHeaders(v map[string]*string) *AddGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *AddGatewaySlbResponse) SetStatusCode(v int32) *AddGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGatewaySlbResponse) SetBody(v *AddGatewaySlbResponseBody) *AddGatewaySlbResponse {
	s.Body = v
	return s
}

type AddMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance.
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the task. You do not need to configure this parameter.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The source instance node address.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if the source instance is a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
}

func (s AddMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskRequest) SetAcceptLanguage(v string) *AddMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddMigrationTaskRequest) SetClusterType(v string) *AddMigrationTaskRequest {
	s.ClusterType = &v
	return s
}

func (s *AddMigrationTaskRequest) SetId(v string) *AddMigrationTaskRequest {
	s.Id = &v
	return s
}

func (s *AddMigrationTaskRequest) SetOriginInstanceAddress(v string) *AddMigrationTaskRequest {
	s.OriginInstanceAddress = &v
	return s
}

func (s *AddMigrationTaskRequest) SetOriginInstanceName(v string) *AddMigrationTaskRequest {
	s.OriginInstanceName = &v
	return s
}

func (s *AddMigrationTaskRequest) SetOriginInstanceNamespace(v string) *AddMigrationTaskRequest {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *AddMigrationTaskRequest) SetProjectDesc(v string) *AddMigrationTaskRequest {
	s.ProjectDesc = &v
	return s
}

func (s *AddMigrationTaskRequest) SetRequestPars(v string) *AddMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

func (s *AddMigrationTaskRequest) SetTargetClusterName(v string) *AddMigrationTaskRequest {
	s.TargetClusterName = &v
	return s
}

func (s *AddMigrationTaskRequest) SetTargetClusterUrl(v string) *AddMigrationTaskRequest {
	s.TargetClusterUrl = &v
	return s
}

func (s *AddMigrationTaskRequest) SetTargetInstanceId(v string) *AddMigrationTaskRequest {
	s.TargetInstanceId = &v
	return s
}

type AddMigrationTaskResponseBody struct {
	// The data structure.
	Data *AddMigrationTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskResponseBody) SetData(v *AddMigrationTaskResponseBodyData) *AddMigrationTaskResponseBody {
	s.Data = v
	return s
}

func (s *AddMigrationTaskResponseBody) SetErrorCode(v string) *AddMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddMigrationTaskResponseBody) SetHttpCode(v string) *AddMigrationTaskResponseBody {
	s.HttpCode = &v
	return s
}

func (s *AddMigrationTaskResponseBody) SetMessage(v string) *AddMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *AddMigrationTaskResponseBody) SetRequestId(v string) *AddMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddMigrationTaskResponseBody) SetSuccess(v bool) *AddMigrationTaskResponseBody {
	s.Success = &v
	return s
}

type AddMigrationTaskResponseBodyData struct {
	// The type of the instance.
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The source instance node address.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if the source instance is a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s AddMigrationTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskResponseBodyData) SetClusterType(v string) *AddMigrationTaskResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetGmtCreate(v string) *AddMigrationTaskResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetGmtModified(v string) *AddMigrationTaskResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetId(v string) *AddMigrationTaskResponseBodyData {
	s.Id = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetOriginInstanceAddress(v string) *AddMigrationTaskResponseBodyData {
	s.OriginInstanceAddress = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetOriginInstanceName(v string) *AddMigrationTaskResponseBodyData {
	s.OriginInstanceName = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetOriginInstanceNamespace(v string) *AddMigrationTaskResponseBodyData {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetProjectDesc(v string) *AddMigrationTaskResponseBodyData {
	s.ProjectDesc = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetTargetClusterName(v string) *AddMigrationTaskResponseBodyData {
	s.TargetClusterName = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetTargetClusterUrl(v string) *AddMigrationTaskResponseBodyData {
	s.TargetClusterUrl = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetTargetInstanceId(v string) *AddMigrationTaskResponseBodyData {
	s.TargetInstanceId = &v
	return s
}

func (s *AddMigrationTaskResponseBodyData) SetUserId(v string) *AddMigrationTaskResponseBodyData {
	s.UserId = &v
	return s
}

type AddMigrationTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s AddMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *AddMigrationTaskResponse) SetHeaders(v map[string]*string) *AddMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *AddMigrationTaskResponse) SetStatusCode(v int32) *AddMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *AddMigrationTaskResponse) SetBody(v *AddMigrationTaskResponseBody) *AddMigrationTaskResponse {
	s.Body = v
	return s
}

type AddMockRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the custom application.
	ConsumerAppIds *string `json:"ConsumerAppIds,omitempty" xml:"ConsumerAppIds,omitempty"`
	// The items in the recycle bin.
	DubboMockItems *string `json:"DubboMockItems,omitempty" xml:"DubboMockItems,omitempty"`
	// Specifies whether to enable the alert rule. Valid values:
	//
	// *   `true`: enables the alert rule.
	// *   `false`: disables the alert rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The description.
	ExtraJson *string `json:"ExtraJson,omitempty" xml:"ExtraJson,omitempty"`
	// The response time (RT) threshold of slow calls. Valid values:
	//
	// *   \- 15: 15 ms
	// *   \- 30: 30 ms
	// *   \- 60: 60 ms
	// *   \- 120: 120 ms
	MockType *int64 `json:"MockType,omitempty" xml:"MockType,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the service provider application.
	ProviderAppId *string `json:"ProviderAppId,omitempty" xml:"ProviderAppId,omitempty"`
	// The name of the service provider application.
	ProviderAppName *string `json:"ProviderAppName,omitempty" xml:"ProviderAppName,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The input parameters. The JSON format is supported.
	ScMockItems *string `json:"ScMockItems,omitempty" xml:"ScMockItems,omitempty"`
	// The rule source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s AddMockRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleRequest) GoString() string {
	return s.String()
}

func (s *AddMockRuleRequest) SetAcceptLanguage(v string) *AddMockRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddMockRuleRequest) SetConsumerAppIds(v string) *AddMockRuleRequest {
	s.ConsumerAppIds = &v
	return s
}

func (s *AddMockRuleRequest) SetDubboMockItems(v string) *AddMockRuleRequest {
	s.DubboMockItems = &v
	return s
}

func (s *AddMockRuleRequest) SetEnable(v bool) *AddMockRuleRequest {
	s.Enable = &v
	return s
}

func (s *AddMockRuleRequest) SetExtraJson(v string) *AddMockRuleRequest {
	s.ExtraJson = &v
	return s
}

func (s *AddMockRuleRequest) SetMockType(v int64) *AddMockRuleRequest {
	s.MockType = &v
	return s
}

func (s *AddMockRuleRequest) SetName(v string) *AddMockRuleRequest {
	s.Name = &v
	return s
}

func (s *AddMockRuleRequest) SetProviderAppId(v string) *AddMockRuleRequest {
	s.ProviderAppId = &v
	return s
}

func (s *AddMockRuleRequest) SetProviderAppName(v string) *AddMockRuleRequest {
	s.ProviderAppName = &v
	return s
}

func (s *AddMockRuleRequest) SetRegion(v string) *AddMockRuleRequest {
	s.Region = &v
	return s
}

func (s *AddMockRuleRequest) SetScMockItems(v string) *AddMockRuleRequest {
	s.ScMockItems = &v
	return s
}

func (s *AddMockRuleRequest) SetSource(v string) *AddMockRuleRequest {
	s.Source = &v
	return s
}

type AddMockRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *AddMockRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddMockRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleResponseBody) GoString() string {
	return s.String()
}

func (s *AddMockRuleResponseBody) SetCode(v int32) *AddMockRuleResponseBody {
	s.Code = &v
	return s
}

func (s *AddMockRuleResponseBody) SetData(v *AddMockRuleResponseBodyData) *AddMockRuleResponseBody {
	s.Data = v
	return s
}

func (s *AddMockRuleResponseBody) SetHttpStatusCode(v int32) *AddMockRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddMockRuleResponseBody) SetMessage(v string) *AddMockRuleResponseBody {
	s.Message = &v
	return s
}

func (s *AddMockRuleResponseBody) SetRequestId(v string) *AddMockRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddMockRuleResponseBody) SetSuccess(v bool) *AddMockRuleResponseBody {
	s.Success = &v
	return s
}

type AddMockRuleResponseBodyData struct {
	// The ID of the Alibaba Cloud account.
	AccountId *string `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the consumer application.
	ConsumerAppId *string `json:"ConsumerAppId,omitempty" xml:"ConsumerAppId,omitempty"`
	// The name of the consumer application.
	ConsumerAppName *string `json:"ConsumerAppName,omitempty" xml:"ConsumerAppName,omitempty"`
	// Indicates whether the mock rule is enabled.
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The description.
	ExtraJson *string `json:"ExtraJson,omitempty" xml:"ExtraJson,omitempty"`
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The mock type. Valid values:
	//
	// *   \- `[unk]0[unk]`: desktop client
	// *   \- `[unk]1[unk]`: mobile client
	MockType *int64 `json:"MockType,omitempty" xml:"MockType,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The ID of the service provider application.
	ProviderAppId *string `json:"ProviderAppId,omitempty" xml:"ProviderAppId,omitempty"`
	// The name of the service provider application.
	ProviderAppName *string `json:"ProviderAppName,omitempty" xml:"ProviderAppName,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The HTTP mock rule.
	ScMockItemJson *string `json:"ScMockItemJson,omitempty" xml:"ScMockItemJson,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s AddMockRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddMockRuleResponseBodyData) SetAccountId(v string) *AddMockRuleResponseBodyData {
	s.AccountId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetConsumerAppId(v string) *AddMockRuleResponseBodyData {
	s.ConsumerAppId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetConsumerAppName(v string) *AddMockRuleResponseBodyData {
	s.ConsumerAppName = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetEnable(v bool) *AddMockRuleResponseBodyData {
	s.Enable = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetExtraJson(v string) *AddMockRuleResponseBodyData {
	s.ExtraJson = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetId(v int64) *AddMockRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetMockType(v int64) *AddMockRuleResponseBodyData {
	s.MockType = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetName(v string) *AddMockRuleResponseBodyData {
	s.Name = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetNamespaceId(v string) *AddMockRuleResponseBodyData {
	s.NamespaceId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetProviderAppId(v string) *AddMockRuleResponseBodyData {
	s.ProviderAppId = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetProviderAppName(v string) *AddMockRuleResponseBodyData {
	s.ProviderAppName = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetRegion(v string) *AddMockRuleResponseBodyData {
	s.Region = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetScMockItemJson(v string) *AddMockRuleResponseBodyData {
	s.ScMockItemJson = &v
	return s
}

func (s *AddMockRuleResponseBodyData) SetSource(v string) *AddMockRuleResponseBodyData {
	s.Source = &v
	return s
}

type AddMockRuleResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddMockRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddMockRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddMockRuleResponse) GoString() string {
	return s.String()
}

func (s *AddMockRuleResponse) SetHeaders(v map[string]*string) *AddMockRuleResponse {
	s.Headers = v
	return s
}

func (s *AddMockRuleResponse) SetStatusCode(v int32) *AddMockRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddMockRuleResponse) SetBody(v *AddMockRuleResponseBody) *AddMockRuleResponse {
	s.Body = v
	return s
}

type AddSSLCertRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s AddSSLCertRequest) String() string {
	return tea.Prettify(s)
}

func (s AddSSLCertRequest) GoString() string {
	return s.String()
}

func (s *AddSSLCertRequest) SetAcceptLanguage(v string) *AddSSLCertRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddSSLCertRequest) SetCertIdentifier(v string) *AddSSLCertRequest {
	s.CertIdentifier = &v
	return s
}

func (s *AddSSLCertRequest) SetDomainId(v int64) *AddSSLCertRequest {
	s.DomainId = &v
	return s
}

func (s *AddSSLCertRequest) SetGatewayUniqueId(v string) *AddSSLCertRequest {
	s.GatewayUniqueId = &v
	return s
}

type AddSSLCertResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the association is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddSSLCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddSSLCertResponseBody) GoString() string {
	return s.String()
}

func (s *AddSSLCertResponseBody) SetCode(v int32) *AddSSLCertResponseBody {
	s.Code = &v
	return s
}

func (s *AddSSLCertResponseBody) SetData(v bool) *AddSSLCertResponseBody {
	s.Data = &v
	return s
}

func (s *AddSSLCertResponseBody) SetHttpStatusCode(v int32) *AddSSLCertResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddSSLCertResponseBody) SetMessage(v string) *AddSSLCertResponseBody {
	s.Message = &v
	return s
}

func (s *AddSSLCertResponseBody) SetRequestId(v string) *AddSSLCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddSSLCertResponseBody) SetSuccess(v bool) *AddSSLCertResponseBody {
	s.Success = &v
	return s
}

type AddSSLCertResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddSSLCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddSSLCertResponse) String() string {
	return tea.Prettify(s)
}

func (s AddSSLCertResponse) GoString() string {
	return s.String()
}

func (s *AddSSLCertResponse) SetHeaders(v map[string]*string) *AddSSLCertResponse {
	s.Headers = v
	return s
}

func (s *AddSSLCertResponse) SetStatusCode(v int32) *AddSSLCertResponse {
	s.StatusCode = &v
	return s
}

func (s *AddSSLCertResponse) SetBody(v *AddSSLCertResponseBody) *AddSSLCertResponse {
	s.Body = v
	return s
}

type AddSecurityGroupRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The range of port numbers.
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s AddSecurityGroupRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddSecurityGroupRuleRequest) GoString() string {
	return s.String()
}

func (s *AddSecurityGroupRuleRequest) SetAcceptLanguage(v string) *AddSecurityGroupRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetDescription(v string) *AddSecurityGroupRuleRequest {
	s.Description = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetGatewayUniqueId(v string) *AddSecurityGroupRuleRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetPortRange(v string) *AddSecurityGroupRuleRequest {
	s.PortRange = &v
	return s
}

func (s *AddSecurityGroupRuleRequest) SetSecurityGroupId(v string) *AddSecurityGroupRuleRequest {
	s.SecurityGroupId = &v
	return s
}

type AddSecurityGroupRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddSecurityGroupRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddSecurityGroupRuleResponseBody) GoString() string {
	return s.String()
}

func (s *AddSecurityGroupRuleResponseBody) SetCode(v int32) *AddSecurityGroupRuleResponseBody {
	s.Code = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetData(v string) *AddSecurityGroupRuleResponseBody {
	s.Data = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetHttpStatusCode(v int32) *AddSecurityGroupRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetMessage(v string) *AddSecurityGroupRuleResponseBody {
	s.Message = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetRequestId(v string) *AddSecurityGroupRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddSecurityGroupRuleResponseBody) SetSuccess(v bool) *AddSecurityGroupRuleResponseBody {
	s.Success = &v
	return s
}

type AddSecurityGroupRuleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddSecurityGroupRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddSecurityGroupRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddSecurityGroupRuleResponse) GoString() string {
	return s.String()
}

func (s *AddSecurityGroupRuleResponse) SetHeaders(v map[string]*string) *AddSecurityGroupRuleResponse {
	s.Headers = v
	return s
}

func (s *AddSecurityGroupRuleResponse) SetStatusCode(v int32) *AddSecurityGroupRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddSecurityGroupRuleResponse) SetBody(v *AddSecurityGroupRuleResponseBody) *AddSecurityGroupRuleResponse {
	s.Body = v
	return s
}

type AddServiceSourceRequest struct {
	// The language in which the returned information is displayed. Valid values:
	//
	// *   zh-CN: Chinese. This is the default value.
	// *   en-US: English.
	// *   ja: Japanese.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The list of service groups.
	GroupList []*string `json:"GroupList,omitempty" xml:"GroupList,omitempty" type:"Repeated"`
	// The configurations of Ingress resources.
	IngressOptionsRequest *AddServiceSourceRequestIngressOptionsRequest `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty" type:"Struct"`
	// The name.
	//
	// > The parameter definition varies based on the source type.
	//
	// *   If Type is set to K8S, this parameter specifies the name of the Kubernetes cluster.
	// *   If Type is set to NACOS, this parameter specifies the ID of the instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of service root paths.
	PathList []*string `json:"PathList,omitempty" xml:"PathList,omitempty" type:"Repeated"`
	// The service source. Valid values:
	//
	// *   K8S: Kubernetes cluster
	// *   MSE: Nacos instance
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   K8S: Kubernetes cluster
	// *   NACOS: Nacos instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *AddServiceSourceRequest) SetAcceptLanguage(v string) *AddServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddServiceSourceRequest) SetAddress(v string) *AddServiceSourceRequest {
	s.Address = &v
	return s
}

func (s *AddServiceSourceRequest) SetGatewayUniqueId(v string) *AddServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddServiceSourceRequest) SetGroupList(v []*string) *AddServiceSourceRequest {
	s.GroupList = v
	return s
}

func (s *AddServiceSourceRequest) SetIngressOptionsRequest(v *AddServiceSourceRequestIngressOptionsRequest) *AddServiceSourceRequest {
	s.IngressOptionsRequest = v
	return s
}

func (s *AddServiceSourceRequest) SetName(v string) *AddServiceSourceRequest {
	s.Name = &v
	return s
}

func (s *AddServiceSourceRequest) SetPathList(v []*string) *AddServiceSourceRequest {
	s.PathList = v
	return s
}

func (s *AddServiceSourceRequest) SetSource(v string) *AddServiceSourceRequest {
	s.Source = &v
	return s
}

func (s *AddServiceSourceRequest) SetType(v string) *AddServiceSourceRequest {
	s.Type = &v
	return s
}

type AddServiceSourceRequestIngressOptionsRequest struct {
	// Specifies whether to enable Ingress.
	EnableIngress *bool `json:"EnableIngress,omitempty" xml:"EnableIngress,omitempty"`
	// Specifies whether to update the Ingress status.
	EnableStatus *bool `json:"EnableStatus,omitempty" xml:"EnableStatus,omitempty"`
	// Specifies whether to monitor Ingress classes.
	IngressClass *string `json:"IngressClass,omitempty" xml:"IngressClass,omitempty"`
	// The namespace whose resources you want to monitor.
	WatchNamespace *string `json:"WatchNamespace,omitempty" xml:"WatchNamespace,omitempty"`
}

func (s AddServiceSourceRequestIngressOptionsRequest) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceRequestIngressOptionsRequest) GoString() string {
	return s.String()
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetEnableIngress(v bool) *AddServiceSourceRequestIngressOptionsRequest {
	s.EnableIngress = &v
	return s
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetEnableStatus(v bool) *AddServiceSourceRequestIngressOptionsRequest {
	s.EnableStatus = &v
	return s
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetIngressClass(v string) *AddServiceSourceRequestIngressOptionsRequest {
	s.IngressClass = &v
	return s
}

func (s *AddServiceSourceRequestIngressOptionsRequest) SetWatchNamespace(v string) *AddServiceSourceRequestIngressOptionsRequest {
	s.WatchNamespace = &v
	return s
}

type AddServiceSourceShrinkRequest struct {
	// The language in which the returned information is displayed. Valid values:
	//
	// *   zh-CN: Chinese. This is the default value.
	// *   en-US: English.
	// *   ja: Japanese.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The list of service groups.
	GroupListShrink *string `json:"GroupList,omitempty" xml:"GroupList,omitempty"`
	// The configurations of Ingress resources.
	IngressOptionsRequestShrink *string `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty"`
	// The name.
	//
	// > The parameter definition varies based on the source type.
	//
	// *   If Type is set to K8S, this parameter specifies the name of the Kubernetes cluster.
	// *   If Type is set to NACOS, this parameter specifies the ID of the instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of service root paths.
	PathListShrink *string `json:"PathList,omitempty" xml:"PathList,omitempty"`
	// The service source. Valid values:
	//
	// *   K8S: Kubernetes cluster
	// *   MSE: Nacos instance
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   K8S: Kubernetes cluster
	// *   NACOS: Nacos instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddServiceSourceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddServiceSourceShrinkRequest) SetAcceptLanguage(v string) *AddServiceSourceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetAddress(v string) *AddServiceSourceShrinkRequest {
	s.Address = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetGatewayUniqueId(v string) *AddServiceSourceShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetGroupListShrink(v string) *AddServiceSourceShrinkRequest {
	s.GroupListShrink = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetIngressOptionsRequestShrink(v string) *AddServiceSourceShrinkRequest {
	s.IngressOptionsRequestShrink = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetName(v string) *AddServiceSourceShrinkRequest {
	s.Name = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetPathListShrink(v string) *AddServiceSourceShrinkRequest {
	s.PathListShrink = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetSource(v string) *AddServiceSourceShrinkRequest {
	s.Source = &v
	return s
}

func (s *AddServiceSourceShrinkRequest) SetType(v string) *AddServiceSourceShrinkRequest {
	s.Type = &v
	return s
}

type AddServiceSourceResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *AddServiceSourceResponseBody) SetCode(v int32) *AddServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetData(v int64) *AddServiceSourceResponseBody {
	s.Data = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetHttpStatusCode(v int32) *AddServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetMessage(v string) *AddServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetRequestId(v string) *AddServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddServiceSourceResponseBody) SetSuccess(v bool) *AddServiceSourceResponseBody {
	s.Success = &v
	return s
}

type AddServiceSourceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *AddServiceSourceResponse) SetHeaders(v map[string]*string) *AddServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *AddServiceSourceResponse) SetStatusCode(v int32) *AddServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddServiceSourceResponse) SetBody(v *AddServiceSourceResponseBody) *AddServiceSourceResponse {
	s.Body = v
	return s
}

type ApplyGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *string `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s ApplyGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *ApplyGatewayRouteRequest) SetAcceptLanguage(v string) *ApplyGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ApplyGatewayRouteRequest) SetGatewayUniqueId(v string) *ApplyGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ApplyGatewayRouteRequest) SetRouteId(v string) *ApplyGatewayRouteRequest {
	s.RouteId = &v
	return s
}

type ApplyGatewayRouteResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ApplyGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyGatewayRouteResponseBody) SetCode(v int32) *ApplyGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetData(v bool) *ApplyGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetHttpStatusCode(v int32) *ApplyGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetMessage(v string) *ApplyGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetRequestId(v string) *ApplyGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApplyGatewayRouteResponseBody) SetSuccess(v bool) *ApplyGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type ApplyGatewayRouteResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *ApplyGatewayRouteResponse) SetHeaders(v map[string]*string) *ApplyGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *ApplyGatewayRouteResponse) SetStatusCode(v int32) *ApplyGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyGatewayRouteResponse) SetBody(v *ApplyGatewayRouteResponseBody) *ApplyGatewayRouteResponse {
	s.Body = v
	return s
}

type ApplyTagPoliciesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Specifies whether to enable the routing rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// Optional. The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The details of the routing rule.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ApplyTagPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesRequest) SetAcceptLanguage(v string) *ApplyTagPoliciesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetAppId(v string) *ApplyTagPoliciesRequest {
	s.AppId = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetEnable(v bool) *ApplyTagPoliciesRequest {
	s.Enable = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetNamespaceId(v string) *ApplyTagPoliciesRequest {
	s.NamespaceId = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetRegion(v string) *ApplyTagPoliciesRequest {
	s.Region = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetRules(v string) *ApplyTagPoliciesRequest {
	s.Rules = &v
	return s
}

func (s *ApplyTagPoliciesRequest) SetSource(v string) *ApplyTagPoliciesRequest {
	s.Source = &v
	return s
}

type ApplyTagPoliciesResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*ApplyTagPoliciesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ApplyTagPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesResponseBody) SetCode(v int32) *ApplyTagPoliciesResponseBody {
	s.Code = &v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetData(v []*ApplyTagPoliciesResponseBodyData) *ApplyTagPoliciesResponseBody {
	s.Data = v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetHttpStatusCode(v int32) *ApplyTagPoliciesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetMessage(v string) *ApplyTagPoliciesResponseBody {
	s.Message = &v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetRequestId(v string) *ApplyTagPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApplyTagPoliciesResponseBody) SetSuccess(v bool) *ApplyTagPoliciesResponseBody {
	s.Success = &v
	return s
}

type ApplyTagPoliciesResponseBodyData struct {
	// Indicates whether the field is the primary key.
	CarryData *bool `json:"CarryData,omitempty" xml:"CarryData,omitempty"`
	// Indicates whether the routing rule is enabled.
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the primary key.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The number of instances.
	InstanceNum *int32 `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	// The policy name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The rate.
	Rate *int32 `json:"Rate,omitempty" xml:"Rate,omitempty"`
	// Indicates whether the routing rule is deleted.
	Remove *bool `json:"Remove,omitempty" xml:"Remove,omitempty"`
	// The details of the routing rule.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ApplyTagPoliciesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesResponseBodyData) SetCarryData(v bool) *ApplyTagPoliciesResponseBodyData {
	s.CarryData = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetEnable(v bool) *ApplyTagPoliciesResponseBodyData {
	s.Enable = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetId(v int64) *ApplyTagPoliciesResponseBodyData {
	s.Id = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetInstanceNum(v int32) *ApplyTagPoliciesResponseBodyData {
	s.InstanceNum = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetName(v string) *ApplyTagPoliciesResponseBodyData {
	s.Name = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetRate(v int32) *ApplyTagPoliciesResponseBodyData {
	s.Rate = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetRemove(v bool) *ApplyTagPoliciesResponseBodyData {
	s.Remove = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetRules(v string) *ApplyTagPoliciesResponseBodyData {
	s.Rules = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetStatus(v int32) *ApplyTagPoliciesResponseBodyData {
	s.Status = &v
	return s
}

func (s *ApplyTagPoliciesResponseBodyData) SetTag(v string) *ApplyTagPoliciesResponseBodyData {
	s.Tag = &v
	return s
}

type ApplyTagPoliciesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyTagPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyTagPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyTagPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ApplyTagPoliciesResponse) SetHeaders(v map[string]*string) *ApplyTagPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ApplyTagPoliciesResponse) SetStatusCode(v int32) *ApplyTagPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyTagPoliciesResponse) SetBody(v *ApplyTagPoliciesResponseBody) *ApplyTagPoliciesResponse {
	s.Body = v
	return s
}

type CloneNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The IDs of configurations.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the source namespace.
	OriginNamespaceId *string `json:"OriginNamespaceId,omitempty" xml:"OriginNamespaceId,omitempty"`
	// The policy used when a write conflict occurs.
	//
	// *   ABORT
	// *   SKIP
	// *   OVERWRITE
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The ID of the destination namespace.
	TargetNamespaceId *string `json:"TargetNamespaceId,omitempty" xml:"TargetNamespaceId,omitempty"`
}

func (s CloneNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigRequest) SetAcceptLanguage(v string) *CloneNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CloneNacosConfigRequest) SetIds(v string) *CloneNacosConfigRequest {
	s.Ids = &v
	return s
}

func (s *CloneNacosConfigRequest) SetInstanceId(v string) *CloneNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *CloneNacosConfigRequest) SetOriginNamespaceId(v string) *CloneNacosConfigRequest {
	s.OriginNamespaceId = &v
	return s
}

func (s *CloneNacosConfigRequest) SetPolicy(v string) *CloneNacosConfigRequest {
	s.Policy = &v
	return s
}

func (s *CloneNacosConfigRequest) SetTargetNamespaceId(v string) *CloneNacosConfigRequest {
	s.TargetNamespaceId = &v
	return s
}

type CloneNacosConfigResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *CloneNacosConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CloneNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBody) SetCode(v int32) *CloneNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetData(v *CloneNacosConfigResponseBodyData) *CloneNacosConfigResponseBody {
	s.Data = v
	return s
}

func (s *CloneNacosConfigResponseBody) SetDynamicMessage(v string) *CloneNacosConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetErrorCode(v string) *CloneNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetHttpStatusCode(v int32) *CloneNacosConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetMessage(v string) *CloneNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetRequestId(v string) *CloneNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloneNacosConfigResponseBody) SetSuccess(v bool) *CloneNacosConfigResponseBody {
	s.Success = &v
	return s
}

type CloneNacosConfigResponseBodyData struct {
	// The details of the failed configurations.
	FailData []*CloneNacosConfigResponseBodyDataFailData `json:"FailData,omitempty" xml:"FailData,omitempty" type:"Repeated"`
	// The number of skipped operations.
	SkipCount *int32 `json:"SkipCount,omitempty" xml:"SkipCount,omitempty"`
	// The details of the skipped configurations.
	SkipData []*CloneNacosConfigResponseBodyDataSkipData `json:"SkipData,omitempty" xml:"SkipData,omitempty" type:"Repeated"`
	// The number of successful operations.
	SuccCount *int32 `json:"SuccCount,omitempty" xml:"SuccCount,omitempty"`
}

func (s CloneNacosConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBodyData) SetFailData(v []*CloneNacosConfigResponseBodyDataFailData) *CloneNacosConfigResponseBodyData {
	s.FailData = v
	return s
}

func (s *CloneNacosConfigResponseBodyData) SetSkipCount(v int32) *CloneNacosConfigResponseBodyData {
	s.SkipCount = &v
	return s
}

func (s *CloneNacosConfigResponseBodyData) SetSkipData(v []*CloneNacosConfigResponseBodyDataSkipData) *CloneNacosConfigResponseBodyData {
	s.SkipData = v
	return s
}

func (s *CloneNacosConfigResponseBodyData) SetSuccCount(v int32) *CloneNacosConfigResponseBodyData {
	s.SuccCount = &v
	return s
}

type CloneNacosConfigResponseBodyDataFailData struct {
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s CloneNacosConfigResponseBodyDataFailData) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBodyDataFailData) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBodyDataFailData) SetDataId(v string) *CloneNacosConfigResponseBodyDataFailData {
	s.DataId = &v
	return s
}

func (s *CloneNacosConfigResponseBodyDataFailData) SetGroup(v string) *CloneNacosConfigResponseBodyDataFailData {
	s.Group = &v
	return s
}

type CloneNacosConfigResponseBodyDataSkipData struct {
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s CloneNacosConfigResponseBodyDataSkipData) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponseBodyDataSkipData) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponseBodyDataSkipData) SetDataId(v string) *CloneNacosConfigResponseBodyDataSkipData {
	s.DataId = &v
	return s
}

func (s *CloneNacosConfigResponseBodyDataSkipData) SetGroup(v string) *CloneNacosConfigResponseBodyDataSkipData {
	s.Group = &v
	return s
}

type CloneNacosConfigResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloneNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloneNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CloneNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *CloneNacosConfigResponse) SetHeaders(v map[string]*string) *CloneNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *CloneNacosConfigResponse) SetStatusCode(v int32) *CloneNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *CloneNacosConfigResponse) SetBody(v *CloneNacosConfigResponseBody) *CloneNacosConfigResponse {
	s.Body = v
	return s
}

type CreateApplicationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The programming language of the application.
	Language  *string `json:"Language,omitempty" xml:"Language,omitempty"`
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region to which the application belongs.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Specifies whether to enable the Sentinel-compatible mode.
	SentinelEnable *string `json:"SentinelEnable,omitempty" xml:"SentinelEnable,omitempty"`
	// The service where the application is deployed. A value of ACK indicates Container Service for Kubernetes.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// Specifies whether to enable switching.
	SwitchEnable *string `json:"SwitchEnable,omitempty" xml:"SwitchEnable,omitempty"`
}

func (s CreateApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationRequest) GoString() string {
	return s.String()
}

func (s *CreateApplicationRequest) SetAcceptLanguage(v string) *CreateApplicationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateApplicationRequest) SetAppName(v string) *CreateApplicationRequest {
	s.AppName = &v
	return s
}

func (s *CreateApplicationRequest) SetLanguage(v string) *CreateApplicationRequest {
	s.Language = &v
	return s
}

func (s *CreateApplicationRequest) SetNamespace(v string) *CreateApplicationRequest {
	s.Namespace = &v
	return s
}

func (s *CreateApplicationRequest) SetRegion(v string) *CreateApplicationRequest {
	s.Region = &v
	return s
}

func (s *CreateApplicationRequest) SetSentinelEnable(v string) *CreateApplicationRequest {
	s.SentinelEnable = &v
	return s
}

func (s *CreateApplicationRequest) SetSource(v string) *CreateApplicationRequest {
	s.Source = &v
	return s
}

func (s *CreateApplicationRequest) SetSwitchEnable(v string) *CreateApplicationRequest {
	s.SwitchEnable = &v
	return s
}

type CreateApplicationResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *CreateApplicationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateApplicationResponseBody) SetCode(v int32) *CreateApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *CreateApplicationResponseBody) SetData(v *CreateApplicationResponseBodyData) *CreateApplicationResponseBody {
	s.Data = v
	return s
}

func (s *CreateApplicationResponseBody) SetHttpStatusCode(v int32) *CreateApplicationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateApplicationResponseBody) SetMessage(v string) *CreateApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *CreateApplicationResponseBody) SetRequestId(v string) *CreateApplicationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateApplicationResponseBody) SetSuccess(v string) *CreateApplicationResponseBody {
	s.Success = &v
	return s
}

type CreateApplicationResponseBodyData struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The creation time.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	Namespace  *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The service where the application is deployed. Valid values:
	//
	// *   \- ACK: Container Service for Kubernetes
	// *   \- Normal: another service
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status of the application. A value of 1 indicates that the application is in a normal state.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The update time.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId  *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s CreateApplicationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateApplicationResponseBodyData) SetAppId(v string) *CreateApplicationResponseBodyData {
	s.AppId = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetAppName(v string) *CreateApplicationResponseBodyData {
	s.AppName = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetCreateTime(v int64) *CreateApplicationResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetExtraInfo(v string) *CreateApplicationResponseBodyData {
	s.ExtraInfo = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetLanguage(v string) *CreateApplicationResponseBodyData {
	s.Language = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetLicenseKey(v string) *CreateApplicationResponseBodyData {
	s.LicenseKey = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetNamespace(v string) *CreateApplicationResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetRegionId(v string) *CreateApplicationResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetSource(v string) *CreateApplicationResponseBodyData {
	s.Source = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetStatus(v int32) *CreateApplicationResponseBodyData {
	s.Status = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetUpdateTime(v int64) *CreateApplicationResponseBodyData {
	s.UpdateTime = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetUserId(v string) *CreateApplicationResponseBodyData {
	s.UserId = &v
	return s
}

func (s *CreateApplicationResponseBodyData) SetVersion(v string) *CreateApplicationResponseBodyData {
	s.Version = &v
	return s
}

type CreateApplicationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationResponse) GoString() string {
	return s.String()
}

func (s *CreateApplicationResponse) SetHeaders(v map[string]*string) *CreateApplicationResponse {
	s.Headers = v
	return s
}

func (s *CreateApplicationResponse) SetStatusCode(v int32) *CreateApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateApplicationResponse) SetBody(v *CreateApplicationResponseBody) *CreateApplicationResponse {
	s.Body = v
	return s
}

type CreateClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The engine specifications. Valid values:
	//
	// \[Professional Edition]
	//
	// *   `MSE_SC_2_4_60_c`: 2 CPU cores and 4 GB of memory
	// *   `MSE_SC_1_2_60_c`: 1 CPU core and 2 GB of memory
	// *   `MSE_SC_4_8_60_c`: 4 CPU cores and 8 GB of memory
	// *   `MSE_SC_8_16_60_c`: 8 CPU cores and 16 GB of memory
	// *   `MSE_SC_16_32_60_c`: 16 CPU cores and 32 GB of memory
	//
	// \[Developer Edition]
	//
	// *   `MSE_SC_1_2_60_c`: 1 CPU core and 2 GB of memory
	// *   `MSE_SC_2_4_60_c`: 2 CPU cores and 4 GB of memory
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The type of the instance. Valid values: ZooKeeper and Nacos-Ans.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The engine version of the instance. Valid values:
	//
	// \[Professional version]
	//
	// *   `NACOS_2_0_0`: Nacos 2.0.0
	// *   `ZooKeeper_3_8_0`: ZooKeeper 3.8.0
	//
	// \[Developer Edition]
	//
	// *   `NACOS_2_0_0`: Nacos 2.0.0
	// *   `ZooKeeper_3_8_0`: ZooKeeper 3.8.0
	ClusterVersion *string `json:"ClusterVersion,omitempty" xml:"ClusterVersion,omitempty"`
	// The network connection type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	// The disk type of the MSE instance. Valid values:
	//
	// *   alicloud-disk-ssd
	// *   alicloud-disk-essd-pl1
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The number of nodes in the instance. Valid values: 1 to 9.
	//
	// \[Professional Edition]
	//
	// *   The number of nodes in an instance is greater than or equal to 3 and must be an odd number.
	//
	// \[Developer Edition]
	//
	// *   Only one node can be deployed for an instance.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The name of the MSE instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Configure this parameter unless otherwise specified. Valid values:
	//
	// *   `mse_pro`: Professional Edition
	// *   `mse_dev`: Developer Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The network type of the MSE instance. Valid values:
	//
	// *   `privatenet`: VPC
	// *   `pubnet`: Internet
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The specifications of the internal-facing SLB instance. Valid values:
	//
	// *   `slb.s1.small`
	// *   `slb.s3.medium`
	PrivateSlbSpecification *string `json:"PrivateSlbSpecification,omitempty" xml:"PrivateSlbSpecification,omitempty"`
	// The public bandwidth. Unit: Mbit/s.\
	// Valid values: 0 to 5000. The value 0 indicates no access to the Internet.
	PubNetworkFlow *string `json:"PubNetworkFlow,omitempty" xml:"PubNetworkFlow,omitempty"`
	// The specifications of the Internet-facing Server Load Balancer (SLB) instance. Valid values:
	//
	// *   `slb.s1.small`
	// *   `slb.s3.medium`
	PubSlbSpecification *string `json:"PubSlbSpecification,omitempty" xml:"PubSlbSpecification,omitempty"`
	// The region where the instance resides. Examples:
	//
	// *   `cn-hangzhou`: China (Hangzhou)
	// *   `cn-beijing`: China (Beijing)
	// *   `cn-shanghai`: China (Shanghai)
	// *   `cn-zhangjiakou`: China (Zhangjiakou)
	// *   `cn-shenzhen`: China (Shenzhen)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The ID of the resource group. For more information, see [View basic information of a resource group](~~457230~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of the tags that you want to add.
	Tag []*CreateClusterRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterRequest) GoString() string {
	return s.String()
}

func (s *CreateClusterRequest) SetAcceptLanguage(v string) *CreateClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateClusterRequest) SetClusterSpecification(v string) *CreateClusterRequest {
	s.ClusterSpecification = &v
	return s
}

func (s *CreateClusterRequest) SetClusterType(v string) *CreateClusterRequest {
	s.ClusterType = &v
	return s
}

func (s *CreateClusterRequest) SetClusterVersion(v string) *CreateClusterRequest {
	s.ClusterVersion = &v
	return s
}

func (s *CreateClusterRequest) SetConnectionType(v string) *CreateClusterRequest {
	s.ConnectionType = &v
	return s
}

func (s *CreateClusterRequest) SetDiskType(v string) *CreateClusterRequest {
	s.DiskType = &v
	return s
}

func (s *CreateClusterRequest) SetInstanceCount(v int32) *CreateClusterRequest {
	s.InstanceCount = &v
	return s
}

func (s *CreateClusterRequest) SetInstanceName(v string) *CreateClusterRequest {
	s.InstanceName = &v
	return s
}

func (s *CreateClusterRequest) SetMseVersion(v string) *CreateClusterRequest {
	s.MseVersion = &v
	return s
}

func (s *CreateClusterRequest) SetNetType(v string) *CreateClusterRequest {
	s.NetType = &v
	return s
}

func (s *CreateClusterRequest) SetPrivateSlbSpecification(v string) *CreateClusterRequest {
	s.PrivateSlbSpecification = &v
	return s
}

func (s *CreateClusterRequest) SetPubNetworkFlow(v string) *CreateClusterRequest {
	s.PubNetworkFlow = &v
	return s
}

func (s *CreateClusterRequest) SetPubSlbSpecification(v string) *CreateClusterRequest {
	s.PubSlbSpecification = &v
	return s
}

func (s *CreateClusterRequest) SetRegion(v string) *CreateClusterRequest {
	s.Region = &v
	return s
}

func (s *CreateClusterRequest) SetRequestPars(v string) *CreateClusterRequest {
	s.RequestPars = &v
	return s
}

func (s *CreateClusterRequest) SetResourceGroupId(v string) *CreateClusterRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateClusterRequest) SetTag(v []*CreateClusterRequestTag) *CreateClusterRequest {
	s.Tag = v
	return s
}

func (s *CreateClusterRequest) SetVSwitchId(v string) *CreateClusterRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateClusterRequest) SetVpcId(v string) *CreateClusterRequest {
	s.VpcId = &v
	return s
}

type CreateClusterRequestTag struct {
	// The key of a tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of a tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateClusterRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterRequestTag) GoString() string {
	return s.String()
}

func (s *CreateClusterRequestTag) SetKey(v string) *CreateClusterRequestTag {
	s.Key = &v
	return s
}

func (s *CreateClusterRequestTag) SetValue(v string) *CreateClusterRequestTag {
	s.Value = &v
	return s
}

type CreateClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterResponseBody) GoString() string {
	return s.String()
}

func (s *CreateClusterResponseBody) SetErrorCode(v string) *CreateClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateClusterResponseBody) SetInstanceId(v string) *CreateClusterResponseBody {
	s.InstanceId = &v
	return s
}

func (s *CreateClusterResponseBody) SetMessage(v string) *CreateClusterResponseBody {
	s.Message = &v
	return s
}

func (s *CreateClusterResponseBody) SetOrderId(v string) *CreateClusterResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateClusterResponseBody) SetRequestId(v string) *CreateClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateClusterResponseBody) SetSuccess(v bool) *CreateClusterResponseBody {
	s.Success = &v
	return s
}

type CreateClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateClusterResponse) GoString() string {
	return s.String()
}

func (s *CreateClusterResponse) SetHeaders(v map[string]*string) *CreateClusterResponse {
	s.Headers = v
	return s
}

func (s *CreateClusterResponse) SetStatusCode(v int32) *CreateClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateClusterResponse) SetBody(v *CreateClusterResponseBody) *CreateClusterResponse {
	s.Body = v
	return s
}

type CreateEngineNamespaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The description of the namespace.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The custom ID of the namespace. If you do not specify this parameter, the automatically generated Universally Unique Identifier (UUID) is returned.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The display name of the namespace.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The maximum number of services that can run in the namespace.
	ServiceCount *int32 `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
}

func (s CreateEngineNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceRequest) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceRequest) SetAcceptLanguage(v string) *CreateEngineNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetClusterId(v string) *CreateEngineNamespaceRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetDesc(v string) *CreateEngineNamespaceRequest {
	s.Desc = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetId(v string) *CreateEngineNamespaceRequest {
	s.Id = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetInstanceId(v string) *CreateEngineNamespaceRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetName(v string) *CreateEngineNamespaceRequest {
	s.Name = &v
	return s
}

func (s *CreateEngineNamespaceRequest) SetServiceCount(v int32) *CreateEngineNamespaceRequest {
	s.ServiceCount = &v
	return s
}

type CreateEngineNamespaceResponseBody struct {
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The details of the data.
	Data *CreateEngineNamespaceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEngineNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceResponseBody) SetClusterId(v string) *CreateEngineNamespaceResponseBody {
	s.ClusterId = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetData(v *CreateEngineNamespaceResponseBodyData) *CreateEngineNamespaceResponseBody {
	s.Data = v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetErrorCode(v string) *CreateEngineNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetMessage(v string) *CreateEngineNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetRequestId(v string) *CreateEngineNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEngineNamespaceResponseBody) SetSuccess(v bool) *CreateEngineNamespaceResponseBody {
	s.Success = &v
	return s
}

type CreateEngineNamespaceResponseBodyData struct {
	// The number of configurations.
	ConfigCount *int32 `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The display name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quota of configurations.
	Quota *int32 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The number of active services.
	ServiceCount *int32 `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   `0`: global configuration
	// *   `1`: default namespace
	// *   `2`: custom namespace
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEngineNamespaceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceResponseBodyData) SetConfigCount(v int32) *CreateEngineNamespaceResponseBodyData {
	s.ConfigCount = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetNamespace(v string) *CreateEngineNamespaceResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetNamespaceDesc(v string) *CreateEngineNamespaceResponseBodyData {
	s.NamespaceDesc = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetNamespaceShowName(v string) *CreateEngineNamespaceResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetQuota(v int32) *CreateEngineNamespaceResponseBodyData {
	s.Quota = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetServiceCount(v int32) *CreateEngineNamespaceResponseBodyData {
	s.ServiceCount = &v
	return s
}

func (s *CreateEngineNamespaceResponseBodyData) SetType(v int32) *CreateEngineNamespaceResponseBodyData {
	s.Type = &v
	return s
}

type CreateEngineNamespaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEngineNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEngineNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEngineNamespaceResponse) GoString() string {
	return s.String()
}

func (s *CreateEngineNamespaceResponse) SetHeaders(v map[string]*string) *CreateEngineNamespaceResponse {
	s.Headers = v
	return s
}

func (s *CreateEngineNamespaceResponse) SetStatusCode(v int32) *CreateEngineNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEngineNamespaceResponse) SetBody(v *CreateEngineNamespaceResponseBody) *CreateEngineNamespaceResponse {
	s.Body = v
	return s
}

type CreateMseServiceApplicationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The edition of the MSE instance that you want to purchase.
	//
	// *   mse_pro: Professional Edition
	// *   mse_dev: Developer Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the region where the instance resides. Examples:
	//
	// *   cn-hangzhou: China (Hangzhou)
	// *   cn-beijing: China (Beijing)
	// *   cn-shanghai: China (Shanghai)
	// *   cn-zhangjiakou: China (Zhangjiakou)
	// *   cn-shenzhen: China (Shenzhen)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Specifies whether to enable the Sentinel-compatible mode.
	SentinelEnable *string `json:"SentinelEnable,omitempty" xml:"SentinelEnable,omitempty"`
	// The source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// Specifies whether to enable switching.
	SwitchEnable *string `json:"SwitchEnable,omitempty" xml:"SwitchEnable,omitempty"`
}

func (s CreateMseServiceApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationRequest) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationRequest) SetAcceptLanguage(v string) *CreateMseServiceApplicationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetAppName(v string) *CreateMseServiceApplicationRequest {
	s.AppName = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetExtraInfo(v string) *CreateMseServiceApplicationRequest {
	s.ExtraInfo = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetLanguage(v string) *CreateMseServiceApplicationRequest {
	s.Language = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetMseVersion(v string) *CreateMseServiceApplicationRequest {
	s.MseVersion = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetRegion(v string) *CreateMseServiceApplicationRequest {
	s.Region = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetSentinelEnable(v string) *CreateMseServiceApplicationRequest {
	s.SentinelEnable = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetSource(v string) *CreateMseServiceApplicationRequest {
	s.Source = &v
	return s
}

func (s *CreateMseServiceApplicationRequest) SetSwitchEnable(v string) *CreateMseServiceApplicationRequest {
	s.SwitchEnable = &v
	return s
}

type CreateMseServiceApplicationResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *CreateMseServiceApplicationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateMseServiceApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationResponseBody) SetCode(v int32) *CreateMseServiceApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetData(v *CreateMseServiceApplicationResponseBodyData) *CreateMseServiceApplicationResponseBody {
	s.Data = v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetHttpStatusCode(v int32) *CreateMseServiceApplicationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetMessage(v string) *CreateMseServiceApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetRequestId(v string) *CreateMseServiceApplicationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBody) SetSuccess(v string) *CreateMseServiceApplicationResponseBody {
	s.Success = &v
	return s
}

type CreateMseServiceApplicationResponseBodyData struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The creation time.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The source type.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status. Valid values: 1: available; 2: deleted
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last modification time.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The version information.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s CreateMseServiceApplicationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationResponseBodyData) SetAppId(v string) *CreateMseServiceApplicationResponseBodyData {
	s.AppId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetAppName(v string) *CreateMseServiceApplicationResponseBodyData {
	s.AppName = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetCreateTime(v int64) *CreateMseServiceApplicationResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetExtraInfo(v string) *CreateMseServiceApplicationResponseBodyData {
	s.ExtraInfo = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetLanguage(v string) *CreateMseServiceApplicationResponseBodyData {
	s.Language = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetLicenseKey(v string) *CreateMseServiceApplicationResponseBodyData {
	s.LicenseKey = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetRegionId(v string) *CreateMseServiceApplicationResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetSource(v string) *CreateMseServiceApplicationResponseBodyData {
	s.Source = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetStatus(v int32) *CreateMseServiceApplicationResponseBodyData {
	s.Status = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetUpdateTime(v int64) *CreateMseServiceApplicationResponseBodyData {
	s.UpdateTime = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetUserId(v string) *CreateMseServiceApplicationResponseBodyData {
	s.UserId = &v
	return s
}

func (s *CreateMseServiceApplicationResponseBodyData) SetVersion(v string) *CreateMseServiceApplicationResponseBodyData {
	s.Version = &v
	return s
}

type CreateMseServiceApplicationResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateMseServiceApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateMseServiceApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMseServiceApplicationResponse) GoString() string {
	return s.String()
}

func (s *CreateMseServiceApplicationResponse) SetHeaders(v map[string]*string) *CreateMseServiceApplicationResponse {
	s.Headers = v
	return s
}

func (s *CreateMseServiceApplicationResponse) SetStatusCode(v int32) *CreateMseServiceApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateMseServiceApplicationResponse) SetBody(v *CreateMseServiceApplicationResponseBody) *CreateMseServiceApplicationResponse {
	s.Body = v
	return s
}

type CreateNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The list of IP addresses where the beta release of the configuration is performed.
	BetaIps *string `json:"BetaIps,omitempty" xml:"BetaIps,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The description of the configuration.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The tags of the configuration.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The format of the configuration. Supported formats include TEXT, JSON, and XML.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *CreateNacosConfigRequest) SetAcceptLanguage(v string) *CreateNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateNacosConfigRequest) SetAppName(v string) *CreateNacosConfigRequest {
	s.AppName = &v
	return s
}

func (s *CreateNacosConfigRequest) SetBetaIps(v string) *CreateNacosConfigRequest {
	s.BetaIps = &v
	return s
}

func (s *CreateNacosConfigRequest) SetContent(v string) *CreateNacosConfigRequest {
	s.Content = &v
	return s
}

func (s *CreateNacosConfigRequest) SetDataId(v string) *CreateNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *CreateNacosConfigRequest) SetDesc(v string) *CreateNacosConfigRequest {
	s.Desc = &v
	return s
}

func (s *CreateNacosConfigRequest) SetGroup(v string) *CreateNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *CreateNacosConfigRequest) SetInstanceId(v string) *CreateNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateNacosConfigRequest) SetNamespaceId(v string) *CreateNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *CreateNacosConfigRequest) SetTags(v string) *CreateNacosConfigRequest {
	s.Tags = &v
	return s
}

func (s *CreateNacosConfigRequest) SetType(v string) *CreateNacosConfigRequest {
	s.Type = &v
	return s
}

type CreateNacosConfigResponseBody struct {
	// The code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNacosConfigResponseBody) SetCode(v string) *CreateNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetErrorCode(v string) *CreateNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetHttpCode(v string) *CreateNacosConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetMessage(v string) *CreateNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetRequestId(v string) *CreateNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateNacosConfigResponseBody) SetSuccess(v bool) *CreateNacosConfigResponseBody {
	s.Success = &v
	return s
}

type CreateNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *CreateNacosConfigResponse) SetHeaders(v map[string]*string) *CreateNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *CreateNacosConfigResponse) SetStatusCode(v int32) *CreateNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNacosConfigResponse) SetBody(v *CreateNacosConfigResponseBody) *CreateNacosConfigResponse {
	s.Body = v
	return s
}

type CreateNacosInstanceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the Nacos instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Specifies whether to enable the service for the instance.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Specifies whether to mark the instance as a temporary node.
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the Nacos instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The metadata of the instance.
	Metadata *string `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port of the Nacos instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The weight. Valid values: 0 to 10000. The value must be an integer. A larger value indicates a higher frequency at which the instance is accessed.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateNacosInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateNacosInstanceRequest) SetAcceptLanguage(v string) *CreateNacosInstanceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetClusterName(v string) *CreateNacosInstanceRequest {
	s.ClusterName = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetEnabled(v bool) *CreateNacosInstanceRequest {
	s.Enabled = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetEphemeral(v bool) *CreateNacosInstanceRequest {
	s.Ephemeral = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetGroupName(v string) *CreateNacosInstanceRequest {
	s.GroupName = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetInstanceId(v string) *CreateNacosInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetIp(v string) *CreateNacosInstanceRequest {
	s.Ip = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetMetadata(v string) *CreateNacosInstanceRequest {
	s.Metadata = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetNamespaceId(v string) *CreateNacosInstanceRequest {
	s.NamespaceId = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetPort(v int32) *CreateNacosInstanceRequest {
	s.Port = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetServiceName(v string) *CreateNacosInstanceRequest {
	s.ServiceName = &v
	return s
}

func (s *CreateNacosInstanceRequest) SetWeight(v string) *CreateNacosInstanceRequest {
	s.Weight = &v
	return s
}

type CreateNacosInstanceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateNacosInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNacosInstanceResponseBody) SetCode(v int32) *CreateNacosInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetData(v string) *CreateNacosInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetHttpStatusCode(v int32) *CreateNacosInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetMessage(v string) *CreateNacosInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetRequestId(v string) *CreateNacosInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateNacosInstanceResponseBody) SetSuccess(v bool) *CreateNacosInstanceResponseBody {
	s.Success = &v
	return s
}

type CreateNacosInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNacosInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNacosInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateNacosInstanceResponse) SetHeaders(v map[string]*string) *CreateNacosInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateNacosInstanceResponse) SetStatusCode(v int32) *CreateNacosInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNacosInstanceResponse) SetBody(v *CreateNacosInstanceResponseBody) *CreateNacosInstanceResponse {
	s.Body = v
	return s
}

type CreateNacosServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Specifies whether the instance is marked as a temporary node. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The protection threshold.
	ProtectThreshold *string `json:"ProtectThreshold,omitempty" xml:"ProtectThreshold,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s CreateNacosServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosServiceRequest) GoString() string {
	return s.String()
}

func (s *CreateNacosServiceRequest) SetAcceptLanguage(v string) *CreateNacosServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateNacosServiceRequest) SetClusterId(v string) *CreateNacosServiceRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateNacosServiceRequest) SetEphemeral(v bool) *CreateNacosServiceRequest {
	s.Ephemeral = &v
	return s
}

func (s *CreateNacosServiceRequest) SetGroupName(v string) *CreateNacosServiceRequest {
	s.GroupName = &v
	return s
}

func (s *CreateNacosServiceRequest) SetInstanceId(v string) *CreateNacosServiceRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateNacosServiceRequest) SetNamespaceId(v string) *CreateNacosServiceRequest {
	s.NamespaceId = &v
	return s
}

func (s *CreateNacosServiceRequest) SetProtectThreshold(v string) *CreateNacosServiceRequest {
	s.ProtectThreshold = &v
	return s
}

func (s *CreateNacosServiceRequest) SetServiceName(v string) *CreateNacosServiceRequest {
	s.ServiceName = &v
	return s
}

type CreateNacosServiceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateNacosServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNacosServiceResponseBody) SetCode(v int32) *CreateNacosServiceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetData(v string) *CreateNacosServiceResponseBody {
	s.Data = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetHttpStatusCode(v int32) *CreateNacosServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetMessage(v string) *CreateNacosServiceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetRequestId(v string) *CreateNacosServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateNacosServiceResponseBody) SetSuccess(v bool) *CreateNacosServiceResponseBody {
	s.Success = &v
	return s
}

type CreateNacosServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNacosServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNacosServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNacosServiceResponse) GoString() string {
	return s.String()
}

func (s *CreateNacosServiceResponse) SetHeaders(v map[string]*string) *CreateNacosServiceResponse {
	s.Headers = v
	return s
}

func (s *CreateNacosServiceResponse) SetStatusCode(v int32) *CreateNacosServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNacosServiceResponse) SetBody(v *CreateNacosServiceResponseBody) *CreateNacosServiceResponse {
	s.Body = v
	return s
}

type CreateOrUpdateSwimmingLaneRequest struct {
	// The language of the response. Valid values:****
	//
	// *   **zh-CN**: Chinese
	// *   **en-US**: English.
	//
	// > Default value: **zh-CN**.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable a lane.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// Specifies whether to set a routing rule for the lane. If an Ingress gateway is used, this parameter is not required.
	EnableRules *bool `json:"EnableRules,omitempty" xml:"EnableRules,omitempty"`
	// The JSON string.
	EntryRule *string `json:"EntryRule,omitempty" xml:"EntryRule,omitempty"`
	// The lane.
	EntryRules                   []*CreateOrUpdateSwimmingLaneRequestEntryRules                 `json:"EntryRules,omitempty" xml:"EntryRules,omitempty" type:"Repeated"`
	GatewaySwimmingLaneRouteJson *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson `json:"GatewaySwimmingLaneRouteJson,omitempty" xml:"GatewaySwimmingLaneRouteJson,omitempty" type:"Struct"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The group to which the lane belongs.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the primary key. A value -1 specifies a request that is used to create a lane. A value greater than 0 specifies a request that is used to modify a lane.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	// The name of the lane.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The service source. Valid value: edasmsc.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The value 0 indicates that the lane is disabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The Alibaba Cloud account. The format is a number, such as 136246975637\*\*\*\*. You can leave this parameter empty.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetAcceptLanguage(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEnable(v bool) *CreateOrUpdateSwimmingLaneRequest {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEnableRules(v bool) *CreateOrUpdateSwimmingLaneRequest {
	s.EnableRules = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEntryRule(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.EntryRule = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetEntryRules(v []*CreateOrUpdateSwimmingLaneRequestEntryRules) *CreateOrUpdateSwimmingLaneRequest {
	s.EntryRules = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetGatewaySwimmingLaneRouteJson(v *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) *CreateOrUpdateSwimmingLaneRequest {
	s.GatewaySwimmingLaneRouteJson = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetGmtCreate(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.GmtCreate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetGmtModified(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.GmtModified = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetGroupId(v int64) *CreateOrUpdateSwimmingLaneRequest {
	s.GroupId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetId(v int64) *CreateOrUpdateSwimmingLaneRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetLicenseKey(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.LicenseKey = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetName(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetRegionId(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetSource(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.Source = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetStatus(v int32) *CreateOrUpdateSwimmingLaneRequest {
	s.Status = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetTag(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.Tag = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequest) SetUserId(v string) *CreateOrUpdateSwimmingLaneRequest {
	s.UserId = &v
	return s
}

type CreateOrUpdateSwimmingLaneRequestEntryRules struct {
	// The common parameters in the JSON format.
	Condition *string `json:"Condition,omitempty" xml:"Condition,omitempty"`
	// Specifies whether to enable the rule. Valid values:
	//
	// *   `true`: enables the rule.
	// *   `false`: disables the rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The list of paths.
	Paths []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The priority. A smaller value of this parameter indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The information about the rule for the REST method.
	RestItems []*CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems `json:"RestItems,omitempty" xml:"RestItems,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRules) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRules) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetCondition(v string) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Condition = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetEnable(v bool) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetPath(v string) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Path = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetPaths(v []*string) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Paths = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetPriority(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.Priority = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRules) SetRestItems(v []*CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) *CreateOrUpdateSwimmingLaneRequestEntryRules {
	s.RestItems = v
	return s
}

type CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems struct {
	// The expression. =, >, <, >=, <=
	Cond *string `json:"Cond,omitempty" xml:"Cond,omitempty"`
	// The base value used for the rawvalue operator.
	Datum *string `json:"Datum,omitempty" xml:"Datum,omitempty"`
	// The divisor used for the mod operator.
	Divisor *int32 `json:"Divisor,omitempty" xml:"Divisor,omitempty"`
	// The name of the rule. This parameter corresponds to the key of the Type parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The list of names.
	NameList []*string `json:"NameList,omitempty" xml:"NameList,omitempty" type:"Repeated"`
	// The operator type. Valid values: mod, list, rawvalue, and rate.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The rate.
	Rate *int32 `json:"Rate,omitempty" xml:"Rate,omitempty"`
	// The remainder used for the mod operator.
	Remainder *int32 `json:"Remainder,omitempty" xml:"Remainder,omitempty"`
	// The type of the rule. Valid values: cookie, param, and header.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The content of the rule.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetCond(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Cond = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetDatum(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Datum = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetDivisor(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Divisor = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetName(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetNameList(v []*string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.NameList = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetOperator(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetRate(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Rate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetRemainder(v int32) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Remainder = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetType(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Type = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems) SetValue(v string) *CreateOrUpdateSwimmingLaneRequestEntryRulesRestItems {
	s.Value = &v
	return s
}

type CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson struct {
	Conditions      []*CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions `json:"Conditions,omitempty" xml:"Conditions,omitempty" type:"Repeated"`
	GatewayId       *int64                                                                     `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	GatewayUniqueId *string                                                                    `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	RouteIdList     []*int64                                                                   `json:"RouteIdList,omitempty" xml:"RouteIdList,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetConditions(v []*CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.Conditions = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetGatewayId(v int64) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.GatewayId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetGatewayUniqueId(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.GatewayUniqueId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson) SetRouteIdList(v []*int64) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJson {
	s.RouteIdList = v
	return s
}

type CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions struct {
	Cond  *string `json:"Cond,omitempty" xml:"Cond,omitempty"`
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type  *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetCond(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Cond = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetName(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetType(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Type = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions) SetValue(v string) *CreateOrUpdateSwimmingLaneRequestGatewaySwimmingLaneRouteJsonConditions {
	s.Value = &v
	return s
}

type CreateOrUpdateSwimmingLaneShrinkRequest struct {
	// The language of the response. Valid values:****
	//
	// *   **zh-CN**: Chinese
	// *   **en-US**: English.
	//
	// > Default value: **zh-CN**.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable a lane.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// Specifies whether to set a routing rule for the lane. If an Ingress gateway is used, this parameter is not required.
	EnableRules *bool `json:"EnableRules,omitempty" xml:"EnableRules,omitempty"`
	// The JSON string.
	EntryRule *string `json:"EntryRule,omitempty" xml:"EntryRule,omitempty"`
	// The lane.
	EntryRules                         []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRules `json:"EntryRules,omitempty" xml:"EntryRules,omitempty" type:"Repeated"`
	GatewaySwimmingLaneRouteJsonShrink *string                                              `json:"GatewaySwimmingLaneRouteJson,omitempty" xml:"GatewaySwimmingLaneRouteJson,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The group to which the lane belongs.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the primary key. A value -1 specifies a request that is used to create a lane. A value greater than 0 specifies a request that is used to modify a lane.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	// The name of the lane.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The service source. Valid value: edasmsc.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The value 0 indicates that the lane is disabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The Alibaba Cloud account. The format is a number, such as 136246975637\*\*\*\*. You can leave this parameter empty.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetAcceptLanguage(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEnable(v bool) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEnableRules(v bool) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.EnableRules = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEntryRule(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.EntryRule = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetEntryRules(v []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.EntryRules = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetGatewaySwimmingLaneRouteJsonShrink(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.GatewaySwimmingLaneRouteJsonShrink = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetGmtCreate(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.GmtCreate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetGmtModified(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.GmtModified = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetGroupId(v int64) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.GroupId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetId(v int64) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetLicenseKey(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.LicenseKey = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetName(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetRegionId(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetSource(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Source = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetStatus(v int32) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Status = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetTag(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.Tag = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequest) SetUserId(v string) *CreateOrUpdateSwimmingLaneShrinkRequest {
	s.UserId = &v
	return s
}

type CreateOrUpdateSwimmingLaneShrinkRequestEntryRules struct {
	// The common parameters in the JSON format.
	Condition *string `json:"Condition,omitempty" xml:"Condition,omitempty"`
	// Specifies whether to enable the rule. Valid values:
	//
	// *   `true`: enables the rule.
	// *   `false`: disables the rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The list of paths.
	Paths []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The priority. A smaller value of this parameter indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The information about the rule for the REST method.
	RestItems []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems `json:"RestItems,omitempty" xml:"RestItems,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetCondition(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Condition = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetEnable(v bool) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetPath(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Path = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetPaths(v []*string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Paths = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetPriority(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.Priority = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules) SetRestItems(v []*CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRules {
	s.RestItems = v
	return s
}

type CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems struct {
	// The expression. =, >, <, >=, <=
	Cond *string `json:"Cond,omitempty" xml:"Cond,omitempty"`
	// The base value used for the rawvalue operator.
	Datum *string `json:"Datum,omitempty" xml:"Datum,omitempty"`
	// The divisor used for the mod operator.
	Divisor *int32 `json:"Divisor,omitempty" xml:"Divisor,omitempty"`
	// The name of the rule. This parameter corresponds to the key of the Type parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The list of names.
	NameList []*string `json:"NameList,omitempty" xml:"NameList,omitempty" type:"Repeated"`
	// The operator type. Valid values: mod, list, rawvalue, and rate.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The rate.
	Rate *int32 `json:"Rate,omitempty" xml:"Rate,omitempty"`
	// The remainder used for the mod operator.
	Remainder *int32 `json:"Remainder,omitempty" xml:"Remainder,omitempty"`
	// The type of the rule. Valid values: cookie, param, and header.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The content of the rule.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetCond(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Cond = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetDatum(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Datum = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetDivisor(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Divisor = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetName(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetNameList(v []*string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.NameList = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetOperator(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetRate(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Rate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetRemainder(v int32) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Remainder = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetType(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Type = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems) SetValue(v string) *CreateOrUpdateSwimmingLaneShrinkRequestEntryRulesRestItems {
	s.Value = &v
	return s
}

type CreateOrUpdateSwimmingLaneResponseBody struct {
	// The status code. The value 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetCode(v int32) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetData(v interface{}) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetDynamicMessage(v string) *CreateOrUpdateSwimmingLaneResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetErrorCode(v string) *CreateOrUpdateSwimmingLaneResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetHttpStatusCode(v int32) *CreateOrUpdateSwimmingLaneResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetMessage(v string) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetRequestId(v string) *CreateOrUpdateSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponseBody) SetSuccess(v bool) *CreateOrUpdateSwimmingLaneResponseBody {
	s.Success = &v
	return s
}

type CreateOrUpdateSwimmingLaneResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneResponse) SetHeaders(v map[string]*string) *CreateOrUpdateSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponse) SetStatusCode(v int32) *CreateOrUpdateSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneResponse) SetBody(v *CreateOrUpdateSwimmingLaneResponseBody) *CreateOrUpdateSwimmingLaneResponse {
	s.Body = v
	return s
}

type CreateOrUpdateSwimmingLaneGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The IDs of applications. Separate application IDs with commas (,).
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	// Specifies whether to enable database canary release.
	DbGrayEnable *bool `json:"DbGrayEnable,omitempty" xml:"DbGrayEnable,omitempty"`
	// Specifies whether to enable a lane group.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ingress application.
	EntryApp *string `json:"EntryApp,omitempty" xml:"EntryApp,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the primary key. The primary key is auto-increment.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	MessageQueueFilterSide *string `json:"MessageQueueFilterSide,omitempty" xml:"MessageQueueFilterSide,omitempty"`
	// Specifies whether to enable canary release for messaging.
	MessageQueueGrayEnable *bool `json:"MessageQueueGrayEnable,omitempty" xml:"MessageQueueGrayEnable,omitempty"`
	// The name.
	Name      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The service source. Valid value: edasmsc.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status of the lane group. The value 0 specifies that the lane group is disabled. The value 1 specifies that the lane group is enabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The Alibaba Cloud account. The value is a number, such as 136246\*\*\*\*\*\*809. You can leave this parameter empty.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetAcceptLanguage(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetAppIds(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.AppIds = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetDbGrayEnable(v bool) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.DbGrayEnable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetEnable(v bool) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Enable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetEntryApp(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.EntryApp = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetGmtCreate(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.GmtCreate = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetGmtModified(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.GmtModified = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetId(v int64) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetLicenseKey(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.LicenseKey = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetMessageQueueFilterSide(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.MessageQueueFilterSide = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetMessageQueueGrayEnable(v bool) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.MessageQueueGrayEnable = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetName(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetNamespace(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Namespace = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetRegion(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Region = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetSource(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Source = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetStatus(v int32) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.Status = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupRequest) SetUserId(v string) *CreateOrUpdateSwimmingLaneGroupRequest {
	s.UserId = &v
	return s
}

type CreateOrUpdateSwimmingLaneGroupResponseBody struct {
	// The status code. The value 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful. false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOrUpdateSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetCode(v int32) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetData(v interface{}) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetDynamicMessage(v string) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetErrorCode(v string) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetHttpStatusCode(v int32) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetMessage(v string) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetRequestId(v string) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponseBody) SetSuccess(v bool) *CreateOrUpdateSwimmingLaneGroupResponseBody {
	s.Success = &v
	return s
}

type CreateOrUpdateSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *CreateOrUpdateSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponse) SetStatusCode(v int32) *CreateOrUpdateSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateSwimmingLaneGroupResponse) SetBody(v *CreateOrUpdateSwimmingLaneGroupResponseBody) *CreateOrUpdateSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type CreateZnodeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s CreateZnodeRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeRequest) GoString() string {
	return s.String()
}

func (s *CreateZnodeRequest) SetAcceptLanguage(v string) *CreateZnodeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *CreateZnodeRequest) SetClusterId(v string) *CreateZnodeRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateZnodeRequest) SetData(v string) *CreateZnodeRequest {
	s.Data = &v
	return s
}

func (s *CreateZnodeRequest) SetPath(v string) *CreateZnodeRequest {
	s.Path = &v
	return s
}

type CreateZnodeResponseBody struct {
	// The details of the data.
	Data *CreateZnodeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateZnodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeResponseBody) GoString() string {
	return s.String()
}

func (s *CreateZnodeResponseBody) SetData(v *CreateZnodeResponseBodyData) *CreateZnodeResponseBody {
	s.Data = v
	return s
}

func (s *CreateZnodeResponseBody) SetErrorCode(v string) *CreateZnodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateZnodeResponseBody) SetHttpCode(v string) *CreateZnodeResponseBody {
	s.HttpCode = &v
	return s
}

func (s *CreateZnodeResponseBody) SetMessage(v string) *CreateZnodeResponseBody {
	s.Message = &v
	return s
}

func (s *CreateZnodeResponseBody) SetRequestId(v string) *CreateZnodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateZnodeResponseBody) SetSuccess(v bool) *CreateZnodeResponseBody {
	s.Success = &v
	return s
}

type CreateZnodeResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s CreateZnodeResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateZnodeResponseBodyData) SetData(v string) *CreateZnodeResponseBodyData {
	s.Data = &v
	return s
}

func (s *CreateZnodeResponseBodyData) SetDir(v bool) *CreateZnodeResponseBodyData {
	s.Dir = &v
	return s
}

func (s *CreateZnodeResponseBodyData) SetName(v string) *CreateZnodeResponseBodyData {
	s.Name = &v
	return s
}

func (s *CreateZnodeResponseBodyData) SetPath(v string) *CreateZnodeResponseBodyData {
	s.Path = &v
	return s
}

type CreateZnodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateZnodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateZnodeResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateZnodeResponse) GoString() string {
	return s.String()
}

func (s *CreateZnodeResponse) SetHeaders(v map[string]*string) *CreateZnodeResponse {
	s.Headers = v
	return s
}

func (s *CreateZnodeResponse) SetStatusCode(v int32) *CreateZnodeResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateZnodeResponse) SetBody(v *CreateZnodeResponseBody) *CreateZnodeResponse {
	s.Body = v
	return s
}

type DeleteAuthResourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The destination ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteAuthResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceRequest) SetAcceptLanguage(v string) *DeleteAuthResourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteAuthResourceRequest) SetGatewayUniqueId(v string) *DeleteAuthResourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteAuthResourceRequest) SetId(v int64) *DeleteAuthResourceRequest {
	s.Id = &v
	return s
}

type DeleteAuthResourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteAuthResourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAuthResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceResponseBody) SetCode(v int32) *DeleteAuthResourceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetData(v *DeleteAuthResourceResponseBodyData) *DeleteAuthResourceResponseBody {
	s.Data = v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetHttpStatusCode(v int32) *DeleteAuthResourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetMessage(v string) *DeleteAuthResourceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetRequestId(v string) *DeleteAuthResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAuthResourceResponseBody) SetSuccess(v bool) *DeleteAuthResourceResponseBody {
	s.Success = &v
	return s
}

type DeleteAuthResourceResponseBodyData struct {
	// The authentication ID.
	AuthId *int64 `json:"AuthId,omitempty" xml:"AuthId,omitempty"`
	// The ID of the domain name.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the primary key.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the whitelist mode is enabled.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DeleteAuthResourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceResponseBodyData) SetAuthId(v int64) *DeleteAuthResourceResponseBodyData {
	s.AuthId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetDomainId(v int64) *DeleteAuthResourceResponseBodyData {
	s.DomainId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetDomainName(v string) *DeleteAuthResourceResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGatewayId(v int64) *DeleteAuthResourceResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGatewayUniqueId(v string) *DeleteAuthResourceResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGmtCreate(v string) *DeleteAuthResourceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetGmtModified(v string) *DeleteAuthResourceResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetId(v int64) *DeleteAuthResourceResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetIsWhite(v bool) *DeleteAuthResourceResponseBodyData {
	s.IsWhite = &v
	return s
}

func (s *DeleteAuthResourceResponseBodyData) SetPath(v string) *DeleteAuthResourceResponseBodyData {
	s.Path = &v
	return s
}

type DeleteAuthResourceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAuthResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAuthResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthResourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteAuthResourceResponse) SetHeaders(v map[string]*string) *DeleteAuthResourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteAuthResourceResponse) SetStatusCode(v int32) *DeleteAuthResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAuthResourceResponse) SetBody(v *DeleteAuthResourceResponseBody) *DeleteAuthResourceResponse {
	s.Body = v
	return s
}

type DeleteClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DeleteClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterRequest) GoString() string {
	return s.String()
}

func (s *DeleteClusterRequest) SetAcceptLanguage(v string) *DeleteClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteClusterRequest) SetInstanceId(v string) *DeleteClusterRequest {
	s.InstanceId = &v
	return s
}

type DeleteClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteClusterResponseBody) SetErrorCode(v string) *DeleteClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteClusterResponseBody) SetHttpCode(v string) *DeleteClusterResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteClusterResponseBody) SetMessage(v string) *DeleteClusterResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteClusterResponseBody) SetRequestId(v string) *DeleteClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteClusterResponseBody) SetSuccess(v bool) *DeleteClusterResponseBody {
	s.Success = &v
	return s
}

type DeleteClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterResponse) GoString() string {
	return s.String()
}

func (s *DeleteClusterResponse) SetHeaders(v map[string]*string) *DeleteClusterResponse {
	s.Headers = v
	return s
}

func (s *DeleteClusterResponse) SetStatusCode(v int32) *DeleteClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteClusterResponse) SetBody(v *DeleteClusterResponseBody) *DeleteClusterResponse {
	s.Body = v
	return s
}

type DeleteEngineNamespaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the namespace.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DeleteEngineNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEngineNamespaceRequest) GoString() string {
	return s.String()
}

func (s *DeleteEngineNamespaceRequest) SetAcceptLanguage(v string) *DeleteEngineNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteEngineNamespaceRequest) SetClusterId(v string) *DeleteEngineNamespaceRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteEngineNamespaceRequest) SetId(v string) *DeleteEngineNamespaceRequest {
	s.Id = &v
	return s
}

func (s *DeleteEngineNamespaceRequest) SetInstanceId(v string) *DeleteEngineNamespaceRequest {
	s.InstanceId = &v
	return s
}

type DeleteEngineNamespaceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteEngineNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEngineNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEngineNamespaceResponseBody) SetErrorCode(v string) *DeleteEngineNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetHttpCode(v string) *DeleteEngineNamespaceResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetMessage(v string) *DeleteEngineNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetRequestId(v string) *DeleteEngineNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteEngineNamespaceResponseBody) SetSuccess(v bool) *DeleteEngineNamespaceResponseBody {
	s.Success = &v
	return s
}

type DeleteEngineNamespaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEngineNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEngineNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEngineNamespaceResponse) GoString() string {
	return s.String()
}

func (s *DeleteEngineNamespaceResponse) SetHeaders(v map[string]*string) *DeleteEngineNamespaceResponse {
	s.Headers = v
	return s
}

func (s *DeleteEngineNamespaceResponse) SetStatusCode(v int32) *DeleteEngineNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEngineNamespaceResponse) SetBody(v *DeleteEngineNamespaceResponseBody) *DeleteEngineNamespaceResponse {
	s.Body = v
	return s
}

type DeleteGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to delete the SLB instance purchased for the gateway when you delete the gateway.
	DeleteSlb *bool `json:"DeleteSlb,omitempty" xml:"DeleteSlb,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s DeleteGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRequest) SetAcceptLanguage(v string) *DeleteGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayRequest) SetDeleteSlb(v bool) *DeleteGatewayRequest {
	s.DeleteSlb = &v
	return s
}

func (s *DeleteGatewayRequest) SetGatewayUniqueId(v string) *DeleteGatewayRequest {
	s.GatewayUniqueId = &v
	return s
}

type DeleteGatewayResponseBody struct {
	// The status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *DeleteGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayResponseBody) SetCode(v int32) *DeleteGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetData(v *DeleteGatewayResponseBodyData) *DeleteGatewayResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetMessage(v string) *DeleteGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetRequestId(v string) *DeleteGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayResponseBody) SetSuccess(v bool) *DeleteGatewayResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayResponseBodyData struct {
	// The unique ID of the gateway. The ID is automatically generated by the system.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the gateway was last updated.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the primary key.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The information about the user.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of gateway replicas.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The ID of the security group.
	SecurityGroup *string `json:"SecurityGroup,omitempty" xml:"SecurityGroup,omitempty"`
	// The specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the gateway. Valid values: 0: The gateway is being created. 1: The gateway fails to be created. 2: The gateway is running. 3: The gateway is changing. 4: The gateway is scaling down. 6: The gateway is scaling up. 8: The gateway is being deleted. 10: The gateway is restarting. 11: The gateway is being rebuilt. 12: The gateway is updating. 13: The gateway fails to be updated.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the virtual private cloud (VPC) where the gateway resides.
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
	// The ID of the vSwitch.
	Vswitch *string `json:"Vswitch,omitempty" xml:"Vswitch,omitempty"`
}

func (s DeleteGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetGmtCreate(v string) *DeleteGatewayResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetGmtModified(v string) *DeleteGatewayResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetId(v int64) *DeleteGatewayResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetName(v string) *DeleteGatewayResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetPrimaryUser(v string) *DeleteGatewayResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetRegion(v string) *DeleteGatewayResponseBodyData {
	s.Region = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetReplica(v int32) *DeleteGatewayResponseBodyData {
	s.Replica = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetSecurityGroup(v string) *DeleteGatewayResponseBodyData {
	s.SecurityGroup = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetSpec(v string) *DeleteGatewayResponseBodyData {
	s.Spec = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetStatus(v int32) *DeleteGatewayResponseBodyData {
	s.Status = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetVpc(v string) *DeleteGatewayResponseBodyData {
	s.Vpc = &v
	return s
}

func (s *DeleteGatewayResponseBodyData) SetVswitch(v string) *DeleteGatewayResponseBodyData {
	s.Vswitch = &v
	return s
}

type DeleteGatewayResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayResponse) SetHeaders(v map[string]*string) *DeleteGatewayResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayResponse) SetStatusCode(v int32) *DeleteGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayResponse) SetBody(v *DeleteGatewayResponseBody) *DeleteGatewayResponse {
	s.Body = v
	return s
}

type DeleteGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The domain ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainRequest) SetAcceptLanguage(v string) *DeleteGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayDomainRequest) SetGatewayUniqueId(v string) *DeleteGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayDomainRequest) SetId(v string) *DeleteGatewayDomainRequest {
	s.Id = &v
	return s
}

type DeleteGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteGatewayDomainResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainResponseBody) SetCode(v int32) *DeleteGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetData(v *DeleteGatewayDomainResponseBodyData) *DeleteGatewayDomainResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetMessage(v string) *DeleteGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetRequestId(v string) *DeleteGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayDomainResponseBody) SetSuccess(v bool) *DeleteGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayDomainResponseBodyData struct {
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the domain name was added.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The domain ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether HTTP probing is allowed.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DeleteGatewayDomainResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainResponseBodyData) SetCertIdentifier(v string) *DeleteGatewayDomainResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGatewayId(v int64) *DeleteGatewayDomainResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayDomainResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGmtCreate(v string) *DeleteGatewayDomainResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetGmtModified(v string) *DeleteGatewayDomainResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetId(v int64) *DeleteGatewayDomainResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetMustHttps(v bool) *DeleteGatewayDomainResponseBodyData {
	s.MustHttps = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetName(v string) *DeleteGatewayDomainResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayDomainResponseBodyData) SetProtocol(v string) *DeleteGatewayDomainResponseBodyData {
	s.Protocol = &v
	return s
}

type DeleteGatewayDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayDomainResponse) SetHeaders(v map[string]*string) *DeleteGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayDomainResponse) SetStatusCode(v int32) *DeleteGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayDomainResponse) SetBody(v *DeleteGatewayDomainResponseBody) *DeleteGatewayDomainResponse {
	s.Body = v
	return s
}

type DeleteGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *string `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s DeleteGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteRequest) SetAcceptLanguage(v string) *DeleteGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayRouteRequest) SetGatewayUniqueId(v string) *DeleteGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayRouteRequest) SetRouteId(v string) *DeleteGatewayRouteRequest {
	s.RouteId = &v
	return s
}

type DeleteGatewayRouteResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteGatewayRouteResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteResponseBody) SetCode(v int32) *DeleteGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetData(v *DeleteGatewayRouteResponseBodyData) *DeleteGatewayRouteResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetMessage(v string) *DeleteGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetRequestId(v string) *DeleteGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBody) SetSuccess(v bool) *DeleteGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayRouteResponseBodyData struct {
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rules.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The status of the route. Valid values:
	//
	// *   0: unpublished
	// *   2: publishing
	// *   3: published
	// *   4: editing (updated but not published)
	// *   5: unpublishing
	// *   6: unavailable
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DeleteGatewayRouteResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteResponseBodyData) SetDefaultServiceId(v int64) *DeleteGatewayRouteResponseBodyData {
	s.DefaultServiceId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGatewayId(v int64) *DeleteGatewayRouteResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayRouteResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGmtCreate(v string) *DeleteGatewayRouteResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetGmtModified(v string) *DeleteGatewayRouteResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetId(v int64) *DeleteGatewayRouteResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetName(v string) *DeleteGatewayRouteResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetPredicates(v string) *DeleteGatewayRouteResponseBodyData {
	s.Predicates = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetRouteOrder(v int32) *DeleteGatewayRouteResponseBodyData {
	s.RouteOrder = &v
	return s
}

func (s *DeleteGatewayRouteResponseBodyData) SetStatus(v int32) *DeleteGatewayRouteResponseBodyData {
	s.Status = &v
	return s
}

type DeleteGatewayRouteResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayRouteResponse) SetHeaders(v map[string]*string) *DeleteGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayRouteResponse) SetStatusCode(v int32) *DeleteGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayRouteResponse) SetBody(v *DeleteGatewayRouteResponseBody) *DeleteGatewayRouteResponse {
	s.Body = v
	return s
}

type DeleteGatewayServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s DeleteGatewayServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceRequest) SetAcceptLanguage(v string) *DeleteGatewayServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayServiceRequest) SetGatewayId(v int64) *DeleteGatewayServiceRequest {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayServiceRequest) SetGatewayUniqueId(v string) *DeleteGatewayServiceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayServiceRequest) SetServiceId(v string) *DeleteGatewayServiceRequest {
	s.ServiceId = &v
	return s
}

type DeleteGatewayServiceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteGatewayServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The unique ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceResponseBody) SetCode(v int32) *DeleteGatewayServiceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetData(v *DeleteGatewayServiceResponseBodyData) *DeleteGatewayServiceResponseBody {
	s.Data = v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetMessage(v string) *DeleteGatewayServiceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetRequestId(v string) *DeleteGatewayServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBody) SetSuccess(v bool) *DeleteGatewayServiceResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayServiceResponseBodyData struct {
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the service was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the service.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// IP
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The basic information about the service.
	MetaInfo *string `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the service registered with the service registry.
	ServiceNameInRegistry *string `json:"ServiceNameInRegistry,omitempty" xml:"ServiceNameInRegistry,omitempty"`
	// The ID of the service source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The source type of the service.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s DeleteGatewayServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceResponseBodyData) SetGatewayId(v int64) *DeleteGatewayServiceResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGatewayUniqueId(v string) *DeleteGatewayServiceResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGmtCreate(v string) *DeleteGatewayServiceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGmtModified(v string) *DeleteGatewayServiceResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetGroupName(v string) *DeleteGatewayServiceResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetId(v int64) *DeleteGatewayServiceResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetIps(v []*string) *DeleteGatewayServiceResponseBodyData {
	s.Ips = v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetMetaInfo(v string) *DeleteGatewayServiceResponseBodyData {
	s.MetaInfo = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetName(v string) *DeleteGatewayServiceResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetNamespace(v string) *DeleteGatewayServiceResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetServiceNameInRegistry(v string) *DeleteGatewayServiceResponseBodyData {
	s.ServiceNameInRegistry = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetSourceId(v int64) *DeleteGatewayServiceResponseBodyData {
	s.SourceId = &v
	return s
}

func (s *DeleteGatewayServiceResponseBodyData) SetSourceType(v string) *DeleteGatewayServiceResponseBodyData {
	s.SourceType = &v
	return s
}

type DeleteGatewayServiceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceResponse) SetHeaders(v map[string]*string) *DeleteGatewayServiceResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayServiceResponse) SetStatusCode(v int32) *DeleteGatewayServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayServiceResponse) SetBody(v *DeleteGatewayServiceResponseBody) *DeleteGatewayServiceResponse {
	s.Body = v
	return s
}

type DeleteGatewayServiceVersionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty"`
}

func (s DeleteGatewayServiceVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceVersionRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceVersionRequest) SetAcceptLanguage(v string) *DeleteGatewayServiceVersionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewayServiceVersionRequest) SetGatewayUniqueId(v string) *DeleteGatewayServiceVersionRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewayServiceVersionRequest) SetServiceId(v int64) *DeleteGatewayServiceVersionRequest {
	s.ServiceId = &v
	return s
}

func (s *DeleteGatewayServiceVersionRequest) SetServiceVersion(v string) *DeleteGatewayServiceVersionRequest {
	s.ServiceVersion = &v
	return s
}

type DeleteGatewayServiceVersionResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewayServiceVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceVersionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceVersionResponseBody) SetCode(v int32) *DeleteGatewayServiceVersionResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetData(v int64) *DeleteGatewayServiceVersionResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetHttpStatusCode(v int32) *DeleteGatewayServiceVersionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetMessage(v string) *DeleteGatewayServiceVersionResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetRequestId(v string) *DeleteGatewayServiceVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponseBody) SetSuccess(v bool) *DeleteGatewayServiceVersionResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewayServiceVersionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewayServiceVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewayServiceVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewayServiceVersionResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewayServiceVersionResponse) SetHeaders(v map[string]*string) *DeleteGatewayServiceVersionResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewayServiceVersionResponse) SetStatusCode(v int32) *DeleteGatewayServiceVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewayServiceVersionResponse) SetBody(v *DeleteGatewayServiceVersionResponseBody) *DeleteGatewayServiceVersionResponse {
	s.Body = v
	return s
}

type DeleteGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to delete the SLB instance purchased for the gateway when you delete the gateway.
	DeleteSlb *bool `json:"DeleteSlb,omitempty" xml:"DeleteSlb,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *DeleteGatewaySlbRequest) SetAcceptLanguage(v string) *DeleteGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteGatewaySlbRequest) SetDeleteSlb(v bool) *DeleteGatewaySlbRequest {
	s.DeleteSlb = &v
	return s
}

func (s *DeleteGatewaySlbRequest) SetGatewayUniqueId(v string) *DeleteGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteGatewaySlbRequest) SetId(v string) *DeleteGatewaySlbRequest {
	s.Id = &v
	return s
}

type DeleteGatewaySlbResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The deletion result.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGatewaySlbResponseBody) SetCode(v int32) *DeleteGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetData(v string) *DeleteGatewaySlbResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetHttpStatusCode(v int32) *DeleteGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetMessage(v string) *DeleteGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetRequestId(v string) *DeleteGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGatewaySlbResponseBody) SetSuccess(v bool) *DeleteGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type DeleteGatewaySlbResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *DeleteGatewaySlbResponse) SetHeaders(v map[string]*string) *DeleteGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *DeleteGatewaySlbResponse) SetStatusCode(v int32) *DeleteGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGatewaySlbResponse) SetBody(v *DeleteGatewaySlbResponseBody) *DeleteGatewaySlbResponse {
	s.Body = v
	return s
}

type DeleteMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s DeleteMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteMigrationTaskRequest) SetAcceptLanguage(v string) *DeleteMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteMigrationTaskRequest) SetId(v string) *DeleteMigrationTaskRequest {
	s.Id = &v
	return s
}

func (s *DeleteMigrationTaskRequest) SetRequestPars(v string) *DeleteMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

type DeleteMigrationTaskResponseBody struct {
	// The deletion result.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMigrationTaskResponseBody) SetData(v bool) *DeleteMigrationTaskResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetErrorCode(v string) *DeleteMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetHttpCode(v string) *DeleteMigrationTaskResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetMessage(v string) *DeleteMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetRequestId(v string) *DeleteMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMigrationTaskResponseBody) SetSuccess(v bool) *DeleteMigrationTaskResponseBody {
	s.Success = &v
	return s
}

type DeleteMigrationTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteMigrationTaskResponse) SetHeaders(v map[string]*string) *DeleteMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteMigrationTaskResponse) SetStatusCode(v int32) *DeleteMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMigrationTaskResponse) SetBody(v *DeleteMigrationTaskResponseBody) *DeleteMigrationTaskResponse {
	s.Body = v
	return s
}

type DeleteNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to perform a beta release. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Beta *bool `json:"Beta,omitempty" xml:"Beta,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The type of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s DeleteNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigRequest) SetAcceptLanguage(v string) *DeleteNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetBeta(v bool) *DeleteNacosConfigRequest {
	s.Beta = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetDataId(v string) *DeleteNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetGroup(v string) *DeleteNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetInstanceId(v string) *DeleteNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosConfigRequest) SetNamespaceId(v string) *DeleteNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

type DeleteNacosConfigResponseBody struct {
	// The status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigResponseBody) SetCode(v string) *DeleteNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetErrorCode(v string) *DeleteNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetHttpCode(v string) *DeleteNacosConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetMessage(v string) *DeleteNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetRequestId(v string) *DeleteNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosConfigResponseBody) SetSuccess(v bool) *DeleteNacosConfigResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigResponse) SetHeaders(v map[string]*string) *DeleteNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosConfigResponse) SetStatusCode(v int32) *DeleteNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosConfigResponse) SetBody(v *DeleteNacosConfigResponseBody) *DeleteNacosConfigResponse {
	s.Body = v
	return s
}

type DeleteNacosConfigsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The IDs of configurations.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s DeleteNacosConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigsRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigsRequest) SetAcceptLanguage(v string) *DeleteNacosConfigsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosConfigsRequest) SetIds(v string) *DeleteNacosConfigsRequest {
	s.Ids = &v
	return s
}

func (s *DeleteNacosConfigsRequest) SetInstanceId(v string) *DeleteNacosConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosConfigsRequest) SetNamespaceId(v string) *DeleteNacosConfigsRequest {
	s.NamespaceId = &v
	return s
}

type DeleteNacosConfigsResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigsResponseBody) SetCode(v int32) *DeleteNacosConfigsResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetErrorCode(v string) *DeleteNacosConfigsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetHttpCode(v string) *DeleteNacosConfigsResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetMessage(v string) *DeleteNacosConfigsResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetRequestId(v string) *DeleteNacosConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosConfigsResponseBody) SetSuccess(v bool) *DeleteNacosConfigsResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosConfigsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosConfigsResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosConfigsResponse) SetHeaders(v map[string]*string) *DeleteNacosConfigsResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosConfigsResponse) SetStatusCode(v int32) *DeleteNacosConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosConfigsResponse) SetBody(v *DeleteNacosConfigsResponseBody) *DeleteNacosConfigsResponse {
	s.Body = v
	return s
}

type DeleteNacosInstanceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The alias of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Specifies whether the instance is marked as a temporary node. Valid values:
	//
	// *   `true`: monitors the task status.
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the Nacos instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port of the Nacos instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s DeleteNacosInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosInstanceRequest) SetAcceptLanguage(v string) *DeleteNacosInstanceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetClusterName(v string) *DeleteNacosInstanceRequest {
	s.ClusterName = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetEphemeral(v bool) *DeleteNacosInstanceRequest {
	s.Ephemeral = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetGroupName(v string) *DeleteNacosInstanceRequest {
	s.GroupName = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetInstanceId(v string) *DeleteNacosInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetIp(v string) *DeleteNacosInstanceRequest {
	s.Ip = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetNamespaceId(v string) *DeleteNacosInstanceRequest {
	s.NamespaceId = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetPort(v int32) *DeleteNacosInstanceRequest {
	s.Port = &v
	return s
}

func (s *DeleteNacosInstanceRequest) SetServiceName(v string) *DeleteNacosInstanceRequest {
	s.ServiceName = &v
	return s
}

type DeleteNacosInstanceResponseBody struct {
	// The status code. The value 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosInstanceResponseBody) SetCode(v int32) *DeleteNacosInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetData(v string) *DeleteNacosInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetDynamicMessage(v string) *DeleteNacosInstanceResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetErrorCode(v string) *DeleteNacosInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetHttpStatusCode(v int32) *DeleteNacosInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetMessage(v string) *DeleteNacosInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetRequestId(v string) *DeleteNacosInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosInstanceResponseBody) SetSuccess(v bool) *DeleteNacosInstanceResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosInstanceResponse) SetHeaders(v map[string]*string) *DeleteNacosInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosInstanceResponse) SetStatusCode(v int32) *DeleteNacosInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosInstanceResponse) SetBody(v *DeleteNacosInstanceResponseBody) *DeleteNacosInstanceResponse {
	s.Body = v
	return s
}

type DeleteNacosServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s DeleteNacosServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosServiceRequest) GoString() string {
	return s.String()
}

func (s *DeleteNacosServiceRequest) SetAcceptLanguage(v string) *DeleteNacosServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetGroupName(v string) *DeleteNacosServiceRequest {
	s.GroupName = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetInstanceId(v string) *DeleteNacosServiceRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetNamespaceId(v string) *DeleteNacosServiceRequest {
	s.NamespaceId = &v
	return s
}

func (s *DeleteNacosServiceRequest) SetServiceName(v string) *DeleteNacosServiceRequest {
	s.ServiceName = &v
	return s
}

type DeleteNacosServiceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The deletion result.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteNacosServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNacosServiceResponseBody) SetCode(v int32) *DeleteNacosServiceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetData(v string) *DeleteNacosServiceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetHttpStatusCode(v int32) *DeleteNacosServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetMessage(v string) *DeleteNacosServiceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetRequestId(v string) *DeleteNacosServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteNacosServiceResponseBody) SetSuccess(v bool) *DeleteNacosServiceResponseBody {
	s.Success = &v
	return s
}

type DeleteNacosServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNacosServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNacosServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNacosServiceResponse) GoString() string {
	return s.String()
}

func (s *DeleteNacosServiceResponse) SetHeaders(v map[string]*string) *DeleteNacosServiceResponse {
	s.Headers = v
	return s
}

func (s *DeleteNacosServiceResponse) SetStatusCode(v int32) *DeleteNacosServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNacosServiceResponse) SetBody(v *DeleteNacosServiceResponseBody) *DeleteNacosServiceResponse {
	s.Body = v
	return s
}

type DeleteSecurityGroupRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The destination ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteSecurityGroupRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleRequest) SetAcceptLanguage(v string) *DeleteSecurityGroupRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteSecurityGroupRuleRequest) SetGatewayUniqueId(v string) *DeleteSecurityGroupRuleRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteSecurityGroupRuleRequest) SetId(v int64) *DeleteSecurityGroupRuleRequest {
	s.Id = &v
	return s
}

type DeleteSecurityGroupRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *DeleteSecurityGroupRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSecurityGroupRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleResponseBody) SetCode(v int32) *DeleteSecurityGroupRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetData(v *DeleteSecurityGroupRuleResponseBodyData) *DeleteSecurityGroupRuleResponseBody {
	s.Data = v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetHttpStatusCode(v int32) *DeleteSecurityGroupRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetMessage(v string) *DeleteSecurityGroupRuleResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetRequestId(v string) *DeleteSecurityGroupRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBody) SetSuccess(v bool) *DeleteSecurityGroupRuleResponseBody {
	s.Success = &v
	return s
}

type DeleteSecurityGroupRuleResponseBodyData struct {
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The transport layer protocol. The value of this parameter is case-insensitive. Valid values:
	//
	// *   icmp
	// *   gre
	// *   tcp
	// *   udp
	// *   all: All protocols are supported.
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The range of ports for the transport layer protocol in the destination security group. Valid values:
	//
	// *   When the IpProtocol parameter is set to tcp or udp, the port number range is 1 to 65535. The start port number and the end port number are separated by a forward slash (/). Example: 1/200.
	// *   If the IpProtocol parameter is set to icmp, the port number range is -1/-1, which indicates all ports.
	// *   If the IpProtocol parameter is set to gre, the port number range is -1/-1, which indicates all ports.
	// *   If the IpProtocol parameter is set to all, the port number range is -1/-1, which indicates all ports.
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s DeleteSecurityGroupRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetDescription(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.Description = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGatewayId(v int64) *DeleteSecurityGroupRuleResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGatewayUniqueId(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGmtCreate(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetGmtModified(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetId(v int64) *DeleteSecurityGroupRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetIpProtocol(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.IpProtocol = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetPortRange(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.PortRange = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponseBodyData) SetSecurityGroupId(v string) *DeleteSecurityGroupRuleResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

type DeleteSecurityGroupRuleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSecurityGroupRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSecurityGroupRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSecurityGroupRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteSecurityGroupRuleResponse) SetHeaders(v map[string]*string) *DeleteSecurityGroupRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteSecurityGroupRuleResponse) SetStatusCode(v int32) *DeleteSecurityGroupRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSecurityGroupRuleResponse) SetBody(v *DeleteSecurityGroupRuleResponseBody) *DeleteSecurityGroupRuleResponse {
	s.Body = v
	return s
}

type DeleteServiceSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the data source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
}

func (s DeleteServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteServiceSourceRequest) SetAcceptLanguage(v string) *DeleteServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteServiceSourceRequest) SetGatewayUniqueId(v string) *DeleteServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *DeleteServiceSourceRequest) SetSourceId(v int64) *DeleteServiceSourceRequest {
	s.SourceId = &v
	return s
}

type DeleteServiceSourceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteServiceSourceResponseBody) SetCode(v int32) *DeleteServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetHttpStatusCode(v int32) *DeleteServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetMessage(v string) *DeleteServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetRequestId(v string) *DeleteServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteServiceSourceResponseBody) SetSuccess(v bool) *DeleteServiceSourceResponseBody {
	s.Success = &v
	return s
}

type DeleteServiceSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteServiceSourceResponse) SetHeaders(v map[string]*string) *DeleteServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteServiceSourceResponse) SetStatusCode(v int32) *DeleteServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteServiceSourceResponse) SetBody(v *DeleteServiceSourceResponseBody) *DeleteServiceSourceResponse {
	s.Body = v
	return s
}

type DeleteSwimmingLaneRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
}

func (s DeleteSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneRequest) SetAcceptLanguage(v string) *DeleteSwimmingLaneRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteSwimmingLaneRequest) SetLaneId(v int64) *DeleteSwimmingLaneRequest {
	s.LaneId = &v
	return s
}

type DeleteSwimmingLaneResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneResponseBody) SetCode(v int32) *DeleteSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetData(v interface{}) *DeleteSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetDynamicMessage(v string) *DeleteSwimmingLaneResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetErrorCode(v string) *DeleteSwimmingLaneResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetHttpStatusCode(v int32) *DeleteSwimmingLaneResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetMessage(v string) *DeleteSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetRequestId(v string) *DeleteSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetSuccess(v bool) *DeleteSwimmingLaneResponseBody {
	s.Success = &v
	return s
}

type DeleteSwimmingLaneResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneResponse) SetHeaders(v map[string]*string) *DeleteSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *DeleteSwimmingLaneResponse) SetStatusCode(v int32) *DeleteSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSwimmingLaneResponse) SetBody(v *DeleteSwimmingLaneResponseBody) *DeleteSwimmingLaneResponse {
	s.Body = v
	return s
}

type DeleteSwimmingLaneGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s DeleteSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneGroupRequest) SetAcceptLanguage(v string) *DeleteSwimmingLaneGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteSwimmingLaneGroupRequest) SetGroupId(v int64) *DeleteSwimmingLaneGroupRequest {
	s.GroupId = &v
	return s
}

type DeleteSwimmingLaneGroupResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetCode(v int32) *DeleteSwimmingLaneGroupResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetData(v interface{}) *DeleteSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetDynamicMessage(v string) *DeleteSwimmingLaneGroupResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetErrorCode(v string) *DeleteSwimmingLaneGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetHttpStatusCode(v int32) *DeleteSwimmingLaneGroupResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetMessage(v string) *DeleteSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetRequestId(v string) *DeleteSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponseBody) SetSuccess(v bool) *DeleteSwimmingLaneGroupResponseBody {
	s.Success = &v
	return s
}

type DeleteSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *DeleteSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteSwimmingLaneGroupResponse) SetStatusCode(v int32) *DeleteSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSwimmingLaneGroupResponse) SetBody(v *DeleteSwimmingLaneGroupResponseBody) *DeleteSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type DeleteZnodeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s DeleteZnodeRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeRequest) GoString() string {
	return s.String()
}

func (s *DeleteZnodeRequest) SetAcceptLanguage(v string) *DeleteZnodeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DeleteZnodeRequest) SetClusterId(v string) *DeleteZnodeRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteZnodeRequest) SetPath(v string) *DeleteZnodeRequest {
	s.Path = &v
	return s
}

func (s *DeleteZnodeRequest) SetRequestPars(v string) *DeleteZnodeRequest {
	s.RequestPars = &v
	return s
}

type DeleteZnodeResponseBody struct {
	// The details of the data.
	Data *DeleteZnodeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteZnodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteZnodeResponseBody) SetData(v *DeleteZnodeResponseBodyData) *DeleteZnodeResponseBody {
	s.Data = v
	return s
}

func (s *DeleteZnodeResponseBody) SetErrorCode(v string) *DeleteZnodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetHttpCode(v string) *DeleteZnodeResponseBody {
	s.HttpCode = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetMessage(v string) *DeleteZnodeResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetRequestId(v string) *DeleteZnodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteZnodeResponseBody) SetSuccess(v bool) *DeleteZnodeResponseBody {
	s.Success = &v
	return s
}

type DeleteZnodeResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DeleteZnodeResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteZnodeResponseBodyData) SetData(v string) *DeleteZnodeResponseBodyData {
	s.Data = &v
	return s
}

func (s *DeleteZnodeResponseBodyData) SetDir(v bool) *DeleteZnodeResponseBodyData {
	s.Dir = &v
	return s
}

func (s *DeleteZnodeResponseBodyData) SetName(v string) *DeleteZnodeResponseBodyData {
	s.Name = &v
	return s
}

func (s *DeleteZnodeResponseBodyData) SetPath(v string) *DeleteZnodeResponseBodyData {
	s.Path = &v
	return s
}

type DeleteZnodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteZnodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteZnodeResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteZnodeResponse) GoString() string {
	return s.String()
}

func (s *DeleteZnodeResponse) SetHeaders(v map[string]*string) *DeleteZnodeResponse {
	s.Headers = v
	return s
}

func (s *DeleteZnodeResponse) SetStatusCode(v int32) *DeleteZnodeResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteZnodeResponse) SetBody(v *DeleteZnodeResponseBody) *DeleteZnodeResponse {
	s.Body = v
	return s
}

type ExportNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The tag of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the data that you want to export.
	//
	// >
	//
	// *   Multiple export methods are supported.
	// *   If you want to export a single configuration, you must leave the Ids parameter empty and specify the DataID and Group parameters.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the primary key of a configuration item.
	//
	// >  - Multiple export methods are supported. You must specify this parameter if you want to export multiple configurations. - You can obtain the value of this parameter by calling the ListNacosConfigs operation. - If you specify this parameter, multiple configurations are exported. The DataId and Group parameters are invalid.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s ExportNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigRequest) SetAcceptLanguage(v string) *ExportNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ExportNacosConfigRequest) SetAppName(v string) *ExportNacosConfigRequest {
	s.AppName = &v
	return s
}

func (s *ExportNacosConfigRequest) SetDataId(v string) *ExportNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *ExportNacosConfigRequest) SetGroup(v string) *ExportNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *ExportNacosConfigRequest) SetIds(v string) *ExportNacosConfigRequest {
	s.Ids = &v
	return s
}

func (s *ExportNacosConfigRequest) SetInstanceId(v string) *ExportNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *ExportNacosConfigRequest) SetNamespaceId(v string) *ExportNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

type ExportNacosConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ExportNacosConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace **%s** in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExportNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigResponseBody) SetCode(v int32) *ExportNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetData(v *ExportNacosConfigResponseBodyData) *ExportNacosConfigResponseBody {
	s.Data = v
	return s
}

func (s *ExportNacosConfigResponseBody) SetDynamicMessage(v string) *ExportNacosConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetErrorCode(v string) *ExportNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetHttpStatusCode(v int32) *ExportNacosConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetMessage(v string) *ExportNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetRequestId(v string) *ExportNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportNacosConfigResponseBody) SetSuccess(v bool) *ExportNacosConfigResponseBody {
	s.Success = &v
	return s
}

type ExportNacosConfigResponseBodyData struct {
	// The URL that is used to download the exported configurations.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ExportNacosConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigResponseBodyData) SetUrl(v string) *ExportNacosConfigResponseBodyData {
	s.Url = &v
	return s
}

type ExportNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExportNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *ExportNacosConfigResponse) SetHeaders(v map[string]*string) *ExportNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *ExportNacosConfigResponse) SetStatusCode(v int32) *ExportNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportNacosConfigResponse) SetBody(v *ExportNacosConfigResponseBody) *ExportNacosConfigResponse {
	s.Body = v
	return s
}

type ExportZookeeperDataRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the object that you want to export. Valid values:
	//
	// *   transactionLog: transaction logs
	// *   snapshot: snapshots
	ExportType *string `json:"ExportType,omitempty" xml:"ExportType,omitempty"`
	// The instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ExportZookeeperDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataRequest) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataRequest) SetAcceptLanguage(v string) *ExportZookeeperDataRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetExportType(v string) *ExportZookeeperDataRequest {
	s.ExportType = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetInstanceId(v string) *ExportZookeeperDataRequest {
	s.InstanceId = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetRegionId(v string) *ExportZookeeperDataRequest {
	s.RegionId = &v
	return s
}

func (s *ExportZookeeperDataRequest) SetRequestPars(v string) *ExportZookeeperDataRequest {
	s.RequestPars = &v
	return s
}

type ExportZookeeperDataResponseBody struct {
	// The details of the data.
	Data *ExportZookeeperDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExportZookeeperDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataResponseBody) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataResponseBody) SetData(v *ExportZookeeperDataResponseBodyData) *ExportZookeeperDataResponseBody {
	s.Data = v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetDynamicMessage(v string) *ExportZookeeperDataResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetErrorCode(v string) *ExportZookeeperDataResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetHttpStatusCode(v string) *ExportZookeeperDataResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetMessage(v string) *ExportZookeeperDataResponseBody {
	s.Message = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetRequestId(v string) *ExportZookeeperDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportZookeeperDataResponseBody) SetSuccess(v bool) *ExportZookeeperDataResponseBody {
	s.Success = &v
	return s
}

type ExportZookeeperDataResponseBodyData struct {
	// The content of the task.
	ContentMap map[string]interface{} `json:"ContentMap,omitempty" xml:"ContentMap,omitempty"`
	// The time when the task was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The type of the object that is exported. Valid values:
	//
	// *   transactionLog: transaction logs
	// *   snapshot: snapshots
	ExportType *string `json:"ExportType,omitempty" xml:"ExportType,omitempty"`
	// The extended information.
	Extend *string `json:"Extend,omitempty" xml:"Extend,omitempty"`
	// The ID of the task.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the associated task at the underlying layer. This parameter is used only to troubleshoot failures.
	KubeoneTaskIds *string `json:"KubeoneTaskIds,omitempty" xml:"KubeoneTaskIds,omitempty"`
	// The task status. Valid values:
	//
	// *   CREATE: The task is being created.
	// *   RUNNING: The task is being executed.
	// *   FINISH: The task is completed.
	// *   FAILED: The task failed.
	// *   EXPIRE: The task has expired.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last modification time.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ExportZookeeperDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataResponseBodyData) SetContentMap(v map[string]interface{}) *ExportZookeeperDataResponseBodyData {
	s.ContentMap = v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetCreateTime(v int64) *ExportZookeeperDataResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetExportType(v string) *ExportZookeeperDataResponseBodyData {
	s.ExportType = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetExtend(v string) *ExportZookeeperDataResponseBodyData {
	s.Extend = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetId(v int32) *ExportZookeeperDataResponseBodyData {
	s.Id = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetInstanceId(v string) *ExportZookeeperDataResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetKubeoneTaskIds(v string) *ExportZookeeperDataResponseBodyData {
	s.KubeoneTaskIds = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetStatus(v string) *ExportZookeeperDataResponseBodyData {
	s.Status = &v
	return s
}

func (s *ExportZookeeperDataResponseBodyData) SetUpdateTime(v int64) *ExportZookeeperDataResponseBodyData {
	s.UpdateTime = &v
	return s
}

type ExportZookeeperDataResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExportZookeeperDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportZookeeperDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportZookeeperDataResponse) GoString() string {
	return s.String()
}

func (s *ExportZookeeperDataResponse) SetHeaders(v map[string]*string) *ExportZookeeperDataResponse {
	s.Headers = v
	return s
}

func (s *ExportZookeeperDataResponse) SetStatusCode(v int32) *ExportZookeeperDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportZookeeperDataResponse) SetBody(v *ExportZookeeperDataResponseBody) *ExportZookeeperDataResponse {
	s.Body = v
	return s
}

type FetchLosslessRuleListRequest struct {
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	AppId          *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName        *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	Namespace      *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	PageNumber     *int64  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId       *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Source         *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s FetchLosslessRuleListRequest) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListRequest) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListRequest) SetAcceptLanguage(v string) *FetchLosslessRuleListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetAppId(v string) *FetchLosslessRuleListRequest {
	s.AppId = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetAppName(v string) *FetchLosslessRuleListRequest {
	s.AppName = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetNamespace(v string) *FetchLosslessRuleListRequest {
	s.Namespace = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetPageNumber(v int64) *FetchLosslessRuleListRequest {
	s.PageNumber = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetPageSize(v int64) *FetchLosslessRuleListRequest {
	s.PageSize = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetRegionId(v string) *FetchLosslessRuleListRequest {
	s.RegionId = &v
	return s
}

func (s *FetchLosslessRuleListRequest) SetSource(v string) *FetchLosslessRuleListRequest {
	s.Source = &v
	return s
}

type FetchLosslessRuleListResponseBody struct {
	Code      *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *FetchLosslessRuleListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	HttpCode  *string                                `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	Message   *string                                `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s FetchLosslessRuleListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponseBody) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponseBody) SetCode(v string) *FetchLosslessRuleListResponseBody {
	s.Code = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetData(v *FetchLosslessRuleListResponseBodyData) *FetchLosslessRuleListResponseBody {
	s.Data = v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetHttpCode(v string) *FetchLosslessRuleListResponseBody {
	s.HttpCode = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetMessage(v string) *FetchLosslessRuleListResponseBody {
	s.Message = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetRequestId(v string) *FetchLosslessRuleListResponseBody {
	s.RequestId = &v
	return s
}

func (s *FetchLosslessRuleListResponseBody) SetSuccess(v bool) *FetchLosslessRuleListResponseBody {
	s.Success = &v
	return s
}

type FetchLosslessRuleListResponseBodyData struct {
	PageNumber *int64                                          `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64                                          `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Results    []*FetchLosslessRuleListResponseBodyDataResults `json:"Results,omitempty" xml:"Results,omitempty" type:"Repeated"`
	TotalSize  *int64                                          `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s FetchLosslessRuleListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponseBodyData) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponseBodyData) SetPageNumber(v int64) *FetchLosslessRuleListResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyData) SetPageSize(v int64) *FetchLosslessRuleListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyData) SetResults(v []*FetchLosslessRuleListResponseBodyDataResults) *FetchLosslessRuleListResponseBodyData {
	s.Results = v
	return s
}

func (s *FetchLosslessRuleListResponseBodyData) SetTotalSize(v int64) *FetchLosslessRuleListResponseBodyData {
	s.TotalSize = &v
	return s
}

type FetchLosslessRuleListResponseBodyDataResults struct {
	Aligned             *bool   `json:"Aligned,omitempty" xml:"Aligned,omitempty"`
	AppId               *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName             *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	Count               *int64  `json:"Count,omitempty" xml:"Count,omitempty"`
	DelayTime           *int64  `json:"DelayTime,omitempty" xml:"DelayTime,omitempty"`
	Enable              *bool   `json:"Enable,omitempty" xml:"Enable,omitempty"`
	FuncType            *int64  `json:"FuncType,omitempty" xml:"FuncType,omitempty"`
	LossLessDetail      *bool   `json:"LossLessDetail,omitempty" xml:"LossLessDetail,omitempty"`
	Notice              *bool   `json:"Notice,omitempty" xml:"Notice,omitempty"`
	Related             *bool   `json:"Related,omitempty" xml:"Related,omitempty"`
	ShutdownWaitSeconds *int32  `json:"ShutdownWaitSeconds,omitempty" xml:"ShutdownWaitSeconds,omitempty"`
	WarmupTime          *int64  `json:"WarmupTime,omitempty" xml:"WarmupTime,omitempty"`
}

func (s FetchLosslessRuleListResponseBodyDataResults) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponseBodyDataResults) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetAligned(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Aligned = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetAppId(v string) *FetchLosslessRuleListResponseBodyDataResults {
	s.AppId = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetAppName(v string) *FetchLosslessRuleListResponseBodyDataResults {
	s.AppName = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetCount(v int64) *FetchLosslessRuleListResponseBodyDataResults {
	s.Count = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetDelayTime(v int64) *FetchLosslessRuleListResponseBodyDataResults {
	s.DelayTime = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetEnable(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Enable = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetFuncType(v int64) *FetchLosslessRuleListResponseBodyDataResults {
	s.FuncType = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetLossLessDetail(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.LossLessDetail = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetNotice(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Notice = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetRelated(v bool) *FetchLosslessRuleListResponseBodyDataResults {
	s.Related = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetShutdownWaitSeconds(v int32) *FetchLosslessRuleListResponseBodyDataResults {
	s.ShutdownWaitSeconds = &v
	return s
}

func (s *FetchLosslessRuleListResponseBodyDataResults) SetWarmupTime(v int64) *FetchLosslessRuleListResponseBodyDataResults {
	s.WarmupTime = &v
	return s
}

type FetchLosslessRuleListResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *FetchLosslessRuleListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s FetchLosslessRuleListResponse) String() string {
	return tea.Prettify(s)
}

func (s FetchLosslessRuleListResponse) GoString() string {
	return s.String()
}

func (s *FetchLosslessRuleListResponse) SetHeaders(v map[string]*string) *FetchLosslessRuleListResponse {
	s.Headers = v
	return s
}

func (s *FetchLosslessRuleListResponse) SetStatusCode(v int32) *FetchLosslessRuleListResponse {
	s.StatusCode = &v
	return s
}

func (s *FetchLosslessRuleListResponse) SetBody(v *FetchLosslessRuleListResponseBody) *FetchLosslessRuleListResponse {
	s.Body = v
	return s
}

type GetAppMessageQueueRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The region where the instance resides. Examples:
	//
	// *   `cn-hangzhou`: China (Hangzhou)
	// *   `cn-beijing`: China (Beijing)
	// *   `cn-shanghai`: China (Shanghai)
	// *   `cn-zhangjiakou`: China (Zhangjiakou)
	// *   `cn-shenzhen`: China (Shenzhen)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s GetAppMessageQueueRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteRequest) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteRequest) SetAcceptLanguage(v string) *GetAppMessageQueueRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetAppMessageQueueRouteRequest) SetAppId(v string) *GetAppMessageQueueRouteRequest {
	s.AppId = &v
	return s
}

func (s *GetAppMessageQueueRouteRequest) SetRegion(v string) *GetAppMessageQueueRouteRequest {
	s.Region = &v
	return s
}

type GetAppMessageQueueRouteResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetAppMessageQueueRouteResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true and false. The value true indicates that the request was successful. The value false indicates that the request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetAppMessageQueueRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteResponseBody) SetCode(v int32) *GetAppMessageQueueRouteResponseBody {
	s.Code = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetData(v *GetAppMessageQueueRouteResponseBodyData) *GetAppMessageQueueRouteResponseBody {
	s.Data = v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetHttpStatusCode(v int32) *GetAppMessageQueueRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetMessage(v string) *GetAppMessageQueueRouteResponseBody {
	s.Message = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetRequestId(v string) *GetAppMessageQueueRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBody) SetSuccess(v bool) *GetAppMessageQueueRouteResponseBody {
	s.Success = &v
	return s
}

type GetAppMessageQueueRouteResponseBodyData struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Indicates whether the canary release for messaging feature is enabled.
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	FilterSide *string `json:"FilterSide,omitempty" xml:"FilterSide,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The tags used to ignore message consumption for nodes in untagged environments.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetAppMessageQueueRouteResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetAppId(v string) *GetAppMessageQueueRouteResponseBodyData {
	s.AppId = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetEnable(v bool) *GetAppMessageQueueRouteResponseBodyData {
	s.Enable = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetFilterSide(v string) *GetAppMessageQueueRouteResponseBodyData {
	s.FilterSide = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetRegion(v string) *GetAppMessageQueueRouteResponseBodyData {
	s.Region = &v
	return s
}

func (s *GetAppMessageQueueRouteResponseBodyData) SetTags(v []*string) *GetAppMessageQueueRouteResponseBodyData {
	s.Tags = v
	return s
}

type GetAppMessageQueueRouteResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAppMessageQueueRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAppMessageQueueRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppMessageQueueRouteResponse) GoString() string {
	return s.String()
}

func (s *GetAppMessageQueueRouteResponse) SetHeaders(v map[string]*string) *GetAppMessageQueueRouteResponse {
	s.Headers = v
	return s
}

func (s *GetAppMessageQueueRouteResponse) SetStatusCode(v int32) *GetAppMessageQueueRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppMessageQueueRouteResponse) SetBody(v *GetAppMessageQueueRouteResponseBody) *GetAppMessageQueueRouteResponse {
	s.Body = v
	return s
}

type GetApplicationListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of an application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of an application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The programming language of the application, such as Java and Go.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The microservice namespace to which the application belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Specifies whether to enable the Sentinel-compatible mode.
	SentinelEnable *bool `json:"SentinelEnable,omitempty" xml:"SentinelEnable,omitempty"`
	// The source of the application. The value is fixed as edasmsc.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// Specifies whether to enable switching.
	SwitchEnable *bool `json:"SwitchEnable,omitempty" xml:"SwitchEnable,omitempty"`
}

func (s GetApplicationListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListRequest) GoString() string {
	return s.String()
}

func (s *GetApplicationListRequest) SetAcceptLanguage(v string) *GetApplicationListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetApplicationListRequest) SetAppId(v string) *GetApplicationListRequest {
	s.AppId = &v
	return s
}

func (s *GetApplicationListRequest) SetAppName(v string) *GetApplicationListRequest {
	s.AppName = &v
	return s
}

func (s *GetApplicationListRequest) SetLanguage(v string) *GetApplicationListRequest {
	s.Language = &v
	return s
}

func (s *GetApplicationListRequest) SetNamespace(v string) *GetApplicationListRequest {
	s.Namespace = &v
	return s
}

func (s *GetApplicationListRequest) SetPageNumber(v int32) *GetApplicationListRequest {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationListRequest) SetPageSize(v int32) *GetApplicationListRequest {
	s.PageSize = &v
	return s
}

func (s *GetApplicationListRequest) SetRegion(v string) *GetApplicationListRequest {
	s.Region = &v
	return s
}

func (s *GetApplicationListRequest) SetSentinelEnable(v bool) *GetApplicationListRequest {
	s.SentinelEnable = &v
	return s
}

func (s *GetApplicationListRequest) SetSource(v string) *GetApplicationListRequest {
	s.Source = &v
	return s
}

func (s *GetApplicationListRequest) SetSwitchEnable(v bool) *GetApplicationListRequest {
	s.SwitchEnable = &v
	return s
}

type GetApplicationListResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *GetApplicationListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetApplicationListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponseBody) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponseBody) SetCode(v int32) *GetApplicationListResponseBody {
	s.Code = &v
	return s
}

func (s *GetApplicationListResponseBody) SetData(v *GetApplicationListResponseBodyData) *GetApplicationListResponseBody {
	s.Data = v
	return s
}

func (s *GetApplicationListResponseBody) SetHttpStatusCode(v int32) *GetApplicationListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetApplicationListResponseBody) SetMessage(v string) *GetApplicationListResponseBody {
	s.Message = &v
	return s
}

func (s *GetApplicationListResponseBody) SetRequestId(v string) *GetApplicationListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetApplicationListResponseBody) SetSuccess(v bool) *GetApplicationListResponseBody {
	s.Success = &v
	return s
}

type GetApplicationListResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned information.
	Result []*GetApplicationListResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetApplicationListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponseBodyData) SetPageNumber(v int32) *GetApplicationListResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationListResponseBodyData) SetPageSize(v int32) *GetApplicationListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetApplicationListResponseBodyData) SetResult(v []*GetApplicationListResponseBodyDataResult) *GetApplicationListResponseBodyData {
	s.Result = v
	return s
}

func (s *GetApplicationListResponseBodyData) SetTotalSize(v int32) *GetApplicationListResponseBodyData {
	s.TotalSize = &v
	return s
}

type GetApplicationListResponseBodyDataResult struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The number of instances.
	InstancesNumber *int32 `json:"InstancesNumber,omitempty" xml:"InstancesNumber,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	Namespace  *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The source of the application.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status.
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetApplicationListResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponseBodyDataResult) SetAppId(v string) *GetApplicationListResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetAppName(v string) *GetApplicationListResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetExtraInfo(v string) *GetApplicationListResponseBodyDataResult {
	s.ExtraInfo = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetInstancesNumber(v int32) *GetApplicationListResponseBodyDataResult {
	s.InstancesNumber = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetLanguage(v string) *GetApplicationListResponseBodyDataResult {
	s.Language = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetLicenseKey(v string) *GetApplicationListResponseBodyDataResult {
	s.LicenseKey = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetNamespace(v string) *GetApplicationListResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetRegionId(v string) *GetApplicationListResponseBodyDataResult {
	s.RegionId = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetSource(v string) *GetApplicationListResponseBodyDataResult {
	s.Source = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetStatus(v int64) *GetApplicationListResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *GetApplicationListResponseBodyDataResult) SetUserId(v string) *GetApplicationListResponseBodyDataResult {
	s.UserId = &v
	return s
}

type GetApplicationListResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetApplicationListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetApplicationListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListResponse) GoString() string {
	return s.String()
}

func (s *GetApplicationListResponse) SetHeaders(v map[string]*string) *GetApplicationListResponse {
	s.Headers = v
	return s
}

func (s *GetApplicationListResponse) SetStatusCode(v int32) *GetApplicationListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetApplicationListResponse) SetBody(v *GetApplicationListResponseBody) *GetApplicationListResponse {
	s.Body = v
	return s
}

type GetApplicationListWithMetircsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName   *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the instance resides. Examples:
	//
	// *   cn-hangzhou: China (Hangzhou)
	// *   cn-beijing: China (Beijing)
	// *   cn-shanghai: China (Shanghai)
	// *   cn-zhangjiakou: China (Zhangjiakou)
	// *   cn-shenzhen: China (Shenzhen)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s GetApplicationListWithMetircsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListWithMetircsRequest) GoString() string {
	return s.String()
}

func (s *GetApplicationListWithMetircsRequest) SetAcceptLanguage(v string) *GetApplicationListWithMetircsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetApplicationListWithMetircsRequest) SetAppId(v string) *GetApplicationListWithMetircsRequest {
	s.AppId = &v
	return s
}

func (s *GetApplicationListWithMetircsRequest) SetAppName(v string) *GetApplicationListWithMetircsRequest {
	s.AppName = &v
	return s
}

func (s *GetApplicationListWithMetircsRequest) SetNamespace(v string) *GetApplicationListWithMetircsRequest {
	s.Namespace = &v
	return s
}

func (s *GetApplicationListWithMetircsRequest) SetPageNumber(v int32) *GetApplicationListWithMetircsRequest {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationListWithMetircsRequest) SetPageSize(v int32) *GetApplicationListWithMetircsRequest {
	s.PageSize = &v
	return s
}

func (s *GetApplicationListWithMetircsRequest) SetRegion(v string) *GetApplicationListWithMetircsRequest {
	s.Region = &v
	return s
}

func (s *GetApplicationListWithMetircsRequest) SetSource(v string) *GetApplicationListWithMetircsRequest {
	s.Source = &v
	return s
}

type GetApplicationListWithMetircsResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GetApplicationListWithMetircsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetApplicationListWithMetircsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListWithMetircsResponseBody) GoString() string {
	return s.String()
}

func (s *GetApplicationListWithMetircsResponseBody) SetCode(v int32) *GetApplicationListWithMetircsResponseBody {
	s.Code = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBody) SetData(v *GetApplicationListWithMetircsResponseBodyData) *GetApplicationListWithMetircsResponseBody {
	s.Data = v
	return s
}

func (s *GetApplicationListWithMetircsResponseBody) SetHttpStatusCode(v int32) *GetApplicationListWithMetircsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBody) SetMessage(v string) *GetApplicationListWithMetircsResponseBody {
	s.Message = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBody) SetRequestId(v string) *GetApplicationListWithMetircsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBody) SetSuccess(v bool) *GetApplicationListWithMetircsResponseBody {
	s.Success = &v
	return s
}

type GetApplicationListWithMetircsResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned information.
	Result []*GetApplicationListWithMetircsResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetApplicationListWithMetircsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListWithMetircsResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetApplicationListWithMetircsResponseBodyData) SetPageNumber(v int32) *GetApplicationListWithMetircsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyData) SetPageSize(v int32) *GetApplicationListWithMetircsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyData) SetResult(v []*GetApplicationListWithMetircsResponseBodyDataResult) *GetApplicationListWithMetircsResponseBodyData {
	s.Result = v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyData) SetTotalSize(v int32) *GetApplicationListWithMetircsResponseBodyData {
	s.TotalSize = &v
	return s
}

type GetApplicationListWithMetircsResponseBodyDataResult struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The metric about the application.
	CurMetrics []*GetApplicationListWithMetircsResponseBodyDataResultCurMetrics `json:"CurMetrics,omitempty" xml:"CurMetrics,omitempty" type:"Repeated"`
	// The sum of metrics about the application.
	CurMetricsFm *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm `json:"CurMetricsFm,omitempty" xml:"CurMetricsFm,omitempty" type:"Struct"`
	// The additional information.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The number of instances.
	InstancesNumber *int32 `json:"InstancesNumber,omitempty" xml:"InstancesNumber,omitempty"`
	// The programming language of the application.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The license key in use.
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	Namespace  *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the region where the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The status.
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetApplicationListWithMetircsResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListWithMetircsResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetAppId(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetAppName(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetCurMetrics(v []*GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.CurMetrics = v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetCurMetricsFm(v *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.CurMetricsFm = v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetExtraInfo(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.ExtraInfo = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetInstancesNumber(v int32) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.InstancesNumber = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetLanguage(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.Language = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetLicenseKey(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.LicenseKey = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetNamespace(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetRegionId(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.RegionId = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetSource(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.Source = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetStatus(v int64) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetTags(v []*string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.Tags = v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResult) SetUserId(v string) *GetApplicationListWithMetircsResponseBodyDataResult {
	s.UserId = &v
	return s
}

type GetApplicationListWithMetircsResponseBodyDataResultCurMetrics struct {
	// The number of blocked QPS.
	BlockQps *float64 `json:"BlockQps,omitempty" xml:"BlockQps,omitempty"`
	// The number of abnormal QPS.
	ExpQps *float64 `json:"ExpQps,omitempty" xml:"ExpQps,omitempty"`
	// The number of passed QPS.
	PassQps *float64 `json:"PassQps,omitempty" xml:"PassQps,omitempty"`
	// The number of queries per second (QPS).
	Qps *float64 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The response time (RT).
	Rt *float64 `json:"Rt,omitempty" xml:"Rt,omitempty"`
	// The number of threads.
	Thread *float64 `json:"Thread,omitempty" xml:"Thread,omitempty"`
	// The timestamp.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) GoString() string {
	return s.String()
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) SetBlockQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics {
	s.BlockQps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) SetExpQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics {
	s.ExpQps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) SetPassQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics {
	s.PassQps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) SetQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics {
	s.Qps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) SetRt(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics {
	s.Rt = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) SetThread(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics {
	s.Thread = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics) SetTimestamp(v int64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetrics {
	s.Timestamp = &v
	return s
}

type GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm struct {
	// The number of blocked QPS.
	BlockQps *float64 `json:"BlockQps,omitempty" xml:"BlockQps,omitempty"`
	// The number of abnormal QPS.
	ExpQps *float64 `json:"ExpQps,omitempty" xml:"ExpQps,omitempty"`
	// The number of passed QPS.
	PassQps *float64 `json:"PassQps,omitempty" xml:"PassQps,omitempty"`
	// The QPS.
	Qps *float64 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The RT.
	Rt *float64 `json:"Rt,omitempty" xml:"Rt,omitempty"`
	// The number of concurrent threads.
	Thread *float64 `json:"Thread,omitempty" xml:"Thread,omitempty"`
	// The timestamp.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) GoString() string {
	return s.String()
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) SetBlockQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm {
	s.BlockQps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) SetExpQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm {
	s.ExpQps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) SetPassQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm {
	s.PassQps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) SetQps(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm {
	s.Qps = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) SetRt(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm {
	s.Rt = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) SetThread(v float64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm {
	s.Thread = &v
	return s
}

func (s *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm) SetTimestamp(v int64) *GetApplicationListWithMetircsResponseBodyDataResultCurMetricsFm {
	s.Timestamp = &v
	return s
}

type GetApplicationListWithMetircsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetApplicationListWithMetircsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetApplicationListWithMetircsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationListWithMetircsResponse) GoString() string {
	return s.String()
}

func (s *GetApplicationListWithMetircsResponse) SetHeaders(v map[string]*string) *GetApplicationListWithMetircsResponse {
	s.Headers = v
	return s
}

func (s *GetApplicationListWithMetircsResponse) SetStatusCode(v int32) *GetApplicationListWithMetircsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetApplicationListWithMetircsResponse) SetBody(v *GetApplicationListWithMetircsResponseBody) *GetApplicationListWithMetircsResponse {
	s.Body = v
	return s
}

type GetBlackWhiteListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to enable the whitelist.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetBlackWhiteListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListRequest) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListRequest) SetAcceptLanguage(v string) *GetBlackWhiteListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetGatewayUniqueId(v string) *GetBlackWhiteListRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetIsWhite(v bool) *GetBlackWhiteListRequest {
	s.IsWhite = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetResourceType(v string) *GetBlackWhiteListRequest {
	s.ResourceType = &v
	return s
}

func (s *GetBlackWhiteListRequest) SetType(v string) *GetBlackWhiteListRequest {
	s.Type = &v
	return s
}

type GetBlackWhiteListResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *GetBlackWhiteListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetBlackWhiteListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListResponseBody) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListResponseBody) SetCode(v int32) *GetBlackWhiteListResponseBody {
	s.Code = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetData(v *GetBlackWhiteListResponseBodyData) *GetBlackWhiteListResponseBody {
	s.Data = v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetHttpStatusCode(v int32) *GetBlackWhiteListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetMessage(v string) *GetBlackWhiteListResponseBody {
	s.Message = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetRequestId(v string) *GetBlackWhiteListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBlackWhiteListResponseBody) SetSuccess(v bool) *GetBlackWhiteListResponseBody {
	s.Success = &v
	return s
}

type GetBlackWhiteListResponseBodyData struct {
	// The content of the blacklist.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the whitelist is enabled.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The ID of the resource.
	ResourceId *int64 `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of a resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the blacklist or whitelist.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetBlackWhiteListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListResponseBodyData) SetContent(v string) *GetBlackWhiteListResponseBodyData {
	s.Content = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGatewayId(v int64) *GetBlackWhiteListResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGatewayUniqueId(v string) *GetBlackWhiteListResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGmtCreate(v string) *GetBlackWhiteListResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetGmtModified(v string) *GetBlackWhiteListResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetId(v int64) *GetBlackWhiteListResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetIsWhite(v bool) *GetBlackWhiteListResponseBodyData {
	s.IsWhite = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetResourceId(v int64) *GetBlackWhiteListResponseBodyData {
	s.ResourceId = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetResourceType(v string) *GetBlackWhiteListResponseBodyData {
	s.ResourceType = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetStatus(v string) *GetBlackWhiteListResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetBlackWhiteListResponseBodyData) SetType(v string) *GetBlackWhiteListResponseBodyData {
	s.Type = &v
	return s
}

type GetBlackWhiteListResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBlackWhiteListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBlackWhiteListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBlackWhiteListResponse) GoString() string {
	return s.String()
}

func (s *GetBlackWhiteListResponse) SetHeaders(v map[string]*string) *GetBlackWhiteListResponse {
	s.Headers = v
	return s
}

func (s *GetBlackWhiteListResponse) SetStatusCode(v int32) *GetBlackWhiteListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBlackWhiteListResponse) SetBody(v *GetBlackWhiteListResponseBody) *GetBlackWhiteListResponse {
	s.Body = v
	return s
}

type GetEngineNamepaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The destination ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s GetEngineNamepaceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEngineNamepaceRequest) GoString() string {
	return s.String()
}

func (s *GetEngineNamepaceRequest) SetAcceptLanguage(v string) *GetEngineNamepaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetEngineNamepaceRequest) SetClusterId(v string) *GetEngineNamepaceRequest {
	s.ClusterId = &v
	return s
}

func (s *GetEngineNamepaceRequest) SetId(v string) *GetEngineNamepaceRequest {
	s.Id = &v
	return s
}

func (s *GetEngineNamepaceRequest) SetInstanceId(v string) *GetEngineNamepaceRequest {
	s.InstanceId = &v
	return s
}

type GetEngineNamepaceResponseBody struct {
	// The number of configurations.
	ConfigCount *string `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The display name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quota of configurations.
	Quota *string `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   0: global configuration
	// *   1: default namespace
	// *   2: custom namespace
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetEngineNamepaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEngineNamepaceResponseBody) GoString() string {
	return s.String()
}

func (s *GetEngineNamepaceResponseBody) SetConfigCount(v string) *GetEngineNamepaceResponseBody {
	s.ConfigCount = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetErrorCode(v string) *GetEngineNamepaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetHttpCode(v string) *GetEngineNamepaceResponseBody {
	s.HttpCode = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetMessage(v string) *GetEngineNamepaceResponseBody {
	s.Message = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetNamespace(v string) *GetEngineNamepaceResponseBody {
	s.Namespace = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetNamespaceDesc(v string) *GetEngineNamepaceResponseBody {
	s.NamespaceDesc = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetNamespaceShowName(v string) *GetEngineNamepaceResponseBody {
	s.NamespaceShowName = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetQuota(v string) *GetEngineNamepaceResponseBody {
	s.Quota = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetRequestId(v string) *GetEngineNamepaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetSuccess(v bool) *GetEngineNamepaceResponseBody {
	s.Success = &v
	return s
}

func (s *GetEngineNamepaceResponseBody) SetType(v string) *GetEngineNamepaceResponseBody {
	s.Type = &v
	return s
}

type GetEngineNamepaceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEngineNamepaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEngineNamepaceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEngineNamepaceResponse) GoString() string {
	return s.String()
}

func (s *GetEngineNamepaceResponse) SetHeaders(v map[string]*string) *GetEngineNamepaceResponse {
	s.Headers = v
	return s
}

func (s *GetEngineNamepaceResponse) SetStatusCode(v int32) *GetEngineNamepaceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEngineNamepaceResponse) SetBody(v *GetEngineNamepaceResponseBody) *GetEngineNamepaceResponse {
	s.Body = v
	return s
}

type GetGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s GetGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayRequest) SetAcceptLanguage(v string) *GetGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayRequest) SetGatewayUniqueId(v string) *GetGatewayRequest {
	s.GatewayUniqueId = &v
	return s
}

type GetGatewayResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the gateway.
	Data *GetGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBody) SetCode(v int32) *GetGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayResponseBody) SetData(v *GetGatewayResponseBodyData) *GetGatewayResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayResponseBody) SetHttpStatusCode(v int32) *GetGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayResponseBody) SetMessage(v string) *GetGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayResponseBody) SetRequestId(v string) *GetGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayResponseBody) SetSuccess(v bool) *GetGatewayResponseBody {
	s.Success = &v
	return s
}

type GetGatewayResponseBodyData struct {
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the gateway expires.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the gateway was created. The time is displayed in GMT. The time is the local time of the region in which the gateway resides.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the gateway was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the gateway.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The log configuration.
	LogConfigDetails *GetGatewayResponseBodyDataLogConfigDetails `json:"LogConfigDetails,omitempty" xml:"LogConfigDetails,omitempty" type:"Struct"`
	// The tag of the resource.
	MseTag *string `json:"MseTag,omitempty" xml:"MseTag,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The Alibaba Cloud account ID of the user who created the gateway.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of gateway replicas.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the security group.
	SecurityGroup *string `json:"SecurityGroup,omitempty" xml:"SecurityGroup,omitempty"`
	// The specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the gateway. Valid values: 0: The gateway is being created. 1: The gateway fails to be created. 2: The gateway is running. 3: The gateway is changing. 4: The gateway is scaling down. 6: The gateway is scaling up. 8: The gateway is being deleted. 10: The gateway is restarting. 11: The gateway is being rebuilt. 12: The gateway is updating. 13: The gateway fails to be updated.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The ID of the VPC.
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
	// The ID of the vSwitch.
	Vswitch *string `json:"Vswitch,omitempty" xml:"Vswitch,omitempty"`
	// The ID of the secondary vSwitch.
	Vswitch2 *string `json:"Vswitch2,omitempty" xml:"Vswitch2,omitempty"`
	// The details of Tracing Analysis.
	XtraceDetails *GetGatewayResponseBodyDataXtraceDetails `json:"XtraceDetails,omitempty" xml:"XtraceDetails,omitempty" type:"Struct"`
}

func (s GetGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyData) SetChargeType(v string) *GetGatewayResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetEndDate(v string) *GetGatewayResponseBodyData {
	s.EndDate = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetGmtCreate(v string) *GetGatewayResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetGmtModified(v string) *GetGatewayResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetId(v int64) *GetGatewayResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetInstanceId(v string) *GetGatewayResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetLogConfigDetails(v *GetGatewayResponseBodyDataLogConfigDetails) *GetGatewayResponseBodyData {
	s.LogConfigDetails = v
	return s
}

func (s *GetGatewayResponseBodyData) SetMseTag(v string) *GetGatewayResponseBodyData {
	s.MseTag = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetName(v string) *GetGatewayResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetPrimaryUser(v string) *GetGatewayResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetRegion(v string) *GetGatewayResponseBodyData {
	s.Region = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetReplica(v int32) *GetGatewayResponseBodyData {
	s.Replica = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetResourceGroupId(v string) *GetGatewayResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetSecurityGroup(v string) *GetGatewayResponseBodyData {
	s.SecurityGroup = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetSpec(v string) *GetGatewayResponseBodyData {
	s.Spec = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetStatus(v int32) *GetGatewayResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetStatusDesc(v string) *GetGatewayResponseBodyData {
	s.StatusDesc = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetVpc(v string) *GetGatewayResponseBodyData {
	s.Vpc = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetVswitch(v string) *GetGatewayResponseBodyData {
	s.Vswitch = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetVswitch2(v string) *GetGatewayResponseBodyData {
	s.Vswitch2 = &v
	return s
}

func (s *GetGatewayResponseBodyData) SetXtraceDetails(v *GetGatewayResponseBodyDataXtraceDetails) *GetGatewayResponseBodyData {
	s.XtraceDetails = v
	return s
}

type GetGatewayResponseBodyDataLogConfigDetails struct {
	// Indicates whether Log Service is activated.
	LogEnabled *bool `json:"LogEnabled,omitempty" xml:"LogEnabled,omitempty"`
	// The name of the Logstore.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	// The name of the project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s GetGatewayResponseBodyDataLogConfigDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyDataLogConfigDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyDataLogConfigDetails) SetLogEnabled(v bool) *GetGatewayResponseBodyDataLogConfigDetails {
	s.LogEnabled = &v
	return s
}

func (s *GetGatewayResponseBodyDataLogConfigDetails) SetLogStoreName(v string) *GetGatewayResponseBodyDataLogConfigDetails {
	s.LogStoreName = &v
	return s
}

func (s *GetGatewayResponseBodyDataLogConfigDetails) SetProjectName(v string) *GetGatewayResponseBodyDataLogConfigDetails {
	s.ProjectName = &v
	return s
}

type GetGatewayResponseBodyDataXtraceDetails struct {
	// The sampling rate of Tracing Analysis.
	Sample *int32 `json:"Sample,omitempty" xml:"Sample,omitempty"`
	// Indicates whether sampling by using Tracing Analysis is enabled.
	TraceOn *bool `json:"TraceOn,omitempty" xml:"TraceOn,omitempty"`
}

func (s GetGatewayResponseBodyDataXtraceDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponseBodyDataXtraceDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayResponseBodyDataXtraceDetails) SetSample(v int32) *GetGatewayResponseBodyDataXtraceDetails {
	s.Sample = &v
	return s
}

func (s *GetGatewayResponseBodyDataXtraceDetails) SetTraceOn(v bool) *GetGatewayResponseBodyDataXtraceDetails {
	s.TraceOn = &v
	return s
}

type GetGatewayResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayResponse) SetHeaders(v map[string]*string) *GetGatewayResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayResponse) SetStatusCode(v int32) *GetGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayResponse) SetBody(v *GetGatewayResponseBody) *GetGatewayResponse {
	s.Body = v
	return s
}

type GetGatewayDomainDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The domain ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s GetGatewayDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailRequest) SetAcceptLanguage(v string) *GetGatewayDomainDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayDomainDetailRequest) SetGatewayUniqueId(v string) *GetGatewayDomainDetailRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayDomainDetailRequest) SetId(v string) *GetGatewayDomainDetailRequest {
	s.Id = &v
	return s
}

type GetGatewayDomainDetailResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetGatewayDomainDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailResponseBody) SetCode(v int32) *GetGatewayDomainDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetData(v *GetGatewayDomainDetailResponseBodyData) *GetGatewayDomainDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetHttpStatusCode(v int32) *GetGatewayDomainDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetMessage(v string) *GetGatewayDomainDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetRequestId(v string) *GetGatewayDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBody) SetSuccess(v bool) *GetGatewayDomainDetailResponseBody {
	s.Success = &v
	return s
}

type GetGatewayDomainDetailResponseBodyData struct {
	// The start time.
	AfterDate *int64 `json:"AfterDate,omitempty" xml:"AfterDate,omitempty"`
	// The algorithm.
	Algorithm *string `json:"Algorithm,omitempty" xml:"Algorithm,omitempty"`
	// The expiration time.
	BeforeDate *int64 `json:"BeforeDate,omitempty" xml:"BeforeDate,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The public domain name.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The start time.
	GmtAfter *string `json:"GmtAfter,omitempty" xml:"GmtAfter,omitempty"`
	// The expiration time.
	GmtBefore *string `json:"GmtBefore,omitempty" xml:"GmtBefore,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// Indicates whether `HTTP/2` is enabled.
	//
	// *   `open`: `HTTP/2` is enabled.
	// *   `close`: `HTTP/2` is disabled.
	// *   `globalConfig`: Global configurations are used.
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The issuer.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// Indicates whether HTTPS is forcibly used.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The domain name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol of the gateway.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The name of the extended field.
	Sans *string `json:"Sans,omitempty" xml:"Sans,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
}

func (s GetGatewayDomainDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailResponseBodyData) SetAfterDate(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.AfterDate = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetAlgorithm(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Algorithm = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetBeforeDate(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.BeforeDate = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetCertIdentifier(v string) *GetGatewayDomainDetailResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetCertName(v string) *GetGatewayDomainDetailResponseBodyData {
	s.CertName = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetCommonName(v string) *GetGatewayDomainDetailResponseBodyData {
	s.CommonName = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGatewayId(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtAfter(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtAfter = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtBefore(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtBefore = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtCreate(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetGmtModified(v string) *GetGatewayDomainDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetHttp2(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Http2 = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetId(v int64) *GetGatewayDomainDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetIssuer(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Issuer = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetMustHttps(v bool) *GetGatewayDomainDetailResponseBodyData {
	s.MustHttps = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetName(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetProtocol(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Protocol = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetSans(v string) *GetGatewayDomainDetailResponseBodyData {
	s.Sans = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetTlsMax(v string) *GetGatewayDomainDetailResponseBodyData {
	s.TlsMax = &v
	return s
}

func (s *GetGatewayDomainDetailResponseBodyData) SetTlsMin(v string) *GetGatewayDomainDetailResponseBodyData {
	s.TlsMin = &v
	return s
}

type GetGatewayDomainDetailResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayDomainDetailResponse) SetHeaders(v map[string]*string) *GetGatewayDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayDomainDetailResponse) SetStatusCode(v int32) *GetGatewayDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayDomainDetailResponse) SetBody(v *GetGatewayDomainDetailResponseBody) *GetGatewayDomainDetailResponse {
	s.Body = v
	return s
}

type GetGatewayOptionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s GetGatewayOptionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayOptionRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayOptionRequest) SetAcceptLanguage(v string) *GetGatewayOptionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayOptionRequest) SetGatewayId(v int64) *GetGatewayOptionRequest {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayOptionRequest) SetGatewayUniqueId(v string) *GetGatewayOptionRequest {
	s.GatewayUniqueId = &v
	return s
}

type GetGatewayOptionResponseBody struct {
	// The status code returned. The value 200 indicates that the request is successfully processed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The detailed configurations of the gateway.
	//
	// *   **TraceDetails**: the sampling description of Tracing Analysis. Content: TraceEnabled indicates whether Tracing Analysis is activated. Sample indicates the sampling rate of Tracing Analysis.
	// *   **LogConfigDetails**: the description of Log Service. Content: LogEnabled indicates whether Log Service is activated. ProjectName indicates the Log Service project to which logs are delivered. LogStoreName indicates the name of the Logstore.
	// *   **EnableHardwareAcceleration**: indicates whether hardware acceleration is enabled.
	// *   **DisableHttp2Alpn**: indicates whether the HTTP/2 protocol is disabled.
	// *   **EnableWaf**: indicates whether Web Application Firewall (WAF) is enabled.
	Data *GatewayOption `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayOptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayOptionResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayOptionResponseBody) SetCode(v int32) *GetGatewayOptionResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetData(v *GatewayOption) *GetGatewayOptionResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayOptionResponseBody) SetHttpStatusCode(v int32) *GetGatewayOptionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetMessage(v string) *GetGatewayOptionResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetRequestId(v string) *GetGatewayOptionResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayOptionResponseBody) SetSuccess(v bool) *GetGatewayOptionResponseBody {
	s.Success = &v
	return s
}

type GetGatewayOptionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayOptionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayOptionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayOptionResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayOptionResponse) SetHeaders(v map[string]*string) *GetGatewayOptionResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayOptionResponse) SetStatusCode(v int32) *GetGatewayOptionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayOptionResponse) SetBody(v *GetGatewayOptionResponseBody) *GetGatewayOptionResponse {
	s.Body = v
	return s
}

type GetGatewayRouteDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *int64 `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s GetGatewayRouteDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailRequest) SetAcceptLanguage(v string) *GetGatewayRouteDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayRouteDetailRequest) SetGatewayUniqueId(v string) *GetGatewayRouteDetailRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayRouteDetailRequest) SetRouteId(v int64) *GetGatewayRouteDetailRequest {
	s.RouteId = &v
	return s
}

type GetGatewayRouteDetailResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetGatewayRouteDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayRouteDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBody) SetCode(v int32) *GetGatewayRouteDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetData(v *GetGatewayRouteDetailResponseBodyData) *GetGatewayRouteDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetHttpStatusCode(v int32) *GetGatewayRouteDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetMessage(v string) *GetGatewayRouteDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetRequestId(v string) *GetGatewayRouteDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBody) SetSuccess(v bool) *GetGatewayRouteDetailResponseBody {
	s.Success = &v
	return s
}

type GetGatewayRouteDetailResponseBodyData struct {
	// The status of Application High Availability Service (AHAS).
	AhasStatus *int32 `json:"AhasStatus,omitempty" xml:"AhasStatus,omitempty"`
	// The configuration for cross-origin resource sharing (CORS).
	Cors *GetGatewayRouteDetailResponseBodyDataCors `json:"Cors,omitempty" xml:"Cors,omitempty" type:"Struct"`
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The default service name.
	DefaultServiceName *string `json:"DefaultServiceName,omitempty" xml:"DefaultServiceName,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponse *GetGatewayRouteDetailResponseBodyDataDirectResponse `json:"DirectResponse,omitempty" xml:"DirectResponse,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The IDs of domains.
	DomainIdList []*int64 `json:"DomainIdList,omitempty" xml:"DomainIdList,omitempty" type:"Repeated"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The list of domain names.
	DomainNameList []*string `json:"DomainNameList,omitempty" xml:"DomainNameList,omitempty" type:"Repeated"`
	// Indicates whether Web Application Firewall (WAF) is activated.
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Indicates whether the Fallback service is enabled.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information of the Fallback service.
	FallbackServices []*GetGatewayRouteDetailResponseBodyDataFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The information about the rewrite policy.
	HTTPRewrite *GetGatewayRouteDetailResponseBodyDataHTTPRewrite `json:"HTTPRewrite,omitempty" xml:"HTTPRewrite,omitempty" type:"Struct"`
	// The header settings.
	HeaderOp *GetGatewayRouteDetailResponseBodyDataHeaderOp `json:"HeaderOp,omitempty" xml:"HeaderOp,omitempty" type:"Struct"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching conditions.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The configuration of the redirection.
	Redirect *GetGatewayRouteDetailResponseBodyDataRedirect `json:"Redirect,omitempty" xml:"Redirect,omitempty" type:"Struct"`
	// The retry configuration.
	Retry *GetGatewayRouteDetailResponseBodyDataRetry `json:"Retry,omitempty" xml:"Retry,omitempty" type:"Struct"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about route matching.
	RoutePredicates *GetGatewayRouteDetailResponseBodyDataRoutePredicates `json:"RoutePredicates,omitempty" xml:"RoutePredicates,omitempty" type:"Struct"`
	// The information about services.
	RouteServices []*GetGatewayRouteDetailResponseBodyDataRouteServices `json:"RouteServices,omitempty" xml:"RouteServices,omitempty" type:"Repeated"`
	// The configurations of services.
	Services *string `json:"Services,omitempty" xml:"Services,omitempty"`
	// The status of the route. Valid values:
	//
	// *   0: unpublished
	// *   2: publishing
	// *   3: published
	// *   4: editing (updated but not published)
	// *   5: unpublishing
	// *   6: unavailable
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The timeout configuration.
	Timeout *GetGatewayRouteDetailResponseBodyDataTimeout `json:"Timeout,omitempty" xml:"Timeout,omitempty" type:"Struct"`
}

func (s GetGatewayRouteDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyData) SetAhasStatus(v int32) *GetGatewayRouteDetailResponseBodyData {
	s.AhasStatus = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetCors(v *GetGatewayRouteDetailResponseBodyDataCors) *GetGatewayRouteDetailResponseBodyData {
	s.Cors = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDefaultServiceId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.DefaultServiceId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDefaultServiceName(v string) *GetGatewayRouteDetailResponseBodyData {
	s.DefaultServiceName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDestinationType(v string) *GetGatewayRouteDetailResponseBodyData {
	s.DestinationType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDirectResponse(v *GetGatewayRouteDetailResponseBodyDataDirectResponse) *GetGatewayRouteDetailResponseBodyData {
	s.DirectResponse = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.DomainId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainIdList(v []*int64) *GetGatewayRouteDetailResponseBodyData {
	s.DomainIdList = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainName(v string) *GetGatewayRouteDetailResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetDomainNameList(v []*string) *GetGatewayRouteDetailResponseBodyData {
	s.DomainNameList = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetEnableWaf(v bool) *GetGatewayRouteDetailResponseBodyData {
	s.EnableWaf = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetFallback(v bool) *GetGatewayRouteDetailResponseBodyData {
	s.Fallback = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetFallbackServices(v []*GetGatewayRouteDetailResponseBodyDataFallbackServices) *GetGatewayRouteDetailResponseBodyData {
	s.FallbackServices = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGatewayId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayRouteDetailResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGmtCreate(v string) *GetGatewayRouteDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetGmtModified(v string) *GetGatewayRouteDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetHTTPRewrite(v *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) *GetGatewayRouteDetailResponseBodyData {
	s.HTTPRewrite = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetHeaderOp(v *GetGatewayRouteDetailResponseBodyDataHeaderOp) *GetGatewayRouteDetailResponseBodyData {
	s.HeaderOp = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetId(v int64) *GetGatewayRouteDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetName(v string) *GetGatewayRouteDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetPredicates(v string) *GetGatewayRouteDetailResponseBodyData {
	s.Predicates = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRedirect(v *GetGatewayRouteDetailResponseBodyDataRedirect) *GetGatewayRouteDetailResponseBodyData {
	s.Redirect = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRetry(v *GetGatewayRouteDetailResponseBodyDataRetry) *GetGatewayRouteDetailResponseBodyData {
	s.Retry = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRouteOrder(v int32) *GetGatewayRouteDetailResponseBodyData {
	s.RouteOrder = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRoutePredicates(v *GetGatewayRouteDetailResponseBodyDataRoutePredicates) *GetGatewayRouteDetailResponseBodyData {
	s.RoutePredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetRouteServices(v []*GetGatewayRouteDetailResponseBodyDataRouteServices) *GetGatewayRouteDetailResponseBodyData {
	s.RouteServices = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetServices(v string) *GetGatewayRouteDetailResponseBodyData {
	s.Services = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetStatus(v int32) *GetGatewayRouteDetailResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyData) SetTimeout(v *GetGatewayRouteDetailResponseBodyDataTimeout) *GetGatewayRouteDetailResponseBodyData {
	s.Timeout = v
	return s
}

type GetGatewayRouteDetailResponseBodyDataCors struct {
	// The credentials allowed.
	AllowCredentials *bool `json:"AllowCredentials,omitempty" xml:"AllowCredentials,omitempty"`
	// The headers allowed.
	AllowHeaders *string `json:"AllowHeaders,omitempty" xml:"AllowHeaders,omitempty"`
	// The methods allowed.
	AllowMethods *string `json:"AllowMethods,omitempty" xml:"AllowMethods,omitempty"`
	// The origins allowed.
	AllowOrigins *string `json:"AllowOrigins,omitempty" xml:"AllowOrigins,omitempty"`
	// The response headers.
	ExposeHeaders *string `json:"ExposeHeaders,omitempty" xml:"ExposeHeaders,omitempty"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int64 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataCors) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataCors) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowCredentials(v bool) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowCredentials = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowHeaders(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowHeaders = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowMethods(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowMethods = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetAllowOrigins(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.AllowOrigins = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetExposeHeaders(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.ExposeHeaders = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetTimeUnit(v string) *GetGatewayRouteDetailResponseBodyDataCors {
	s.TimeUnit = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataCors) SetUnitNum(v int64) *GetGatewayRouteDetailResponseBodyDataCors {
	s.UnitNum = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataDirectResponse struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataDirectResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataDirectResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataDirectResponse) SetBody(v string) *GetGatewayRouteDetailResponseBodyDataDirectResponse {
	s.Body = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataDirectResponse) SetCode(v int32) *GetGatewayRouteDetailResponseBodyDataDirectResponse {
	s.Code = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataFallbackServices struct {
	// The type of the protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the service belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataFallbackServices) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetAgreementType(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetGroupName(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.GroupName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetName(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Name = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetNamespace(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Namespace = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetPercent(v int32) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Percent = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetServiceId(v int64) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetServiceName(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.ServiceName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetServicePort(v int32) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetSourceType(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.SourceType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataFallbackServices) SetVersion(v string) *GetGatewayRouteDetailResponseBodyDataFallbackServices {
	s.Version = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataHTTPRewrite struct {
	// The hostname of the gateway.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The rewrite type.
	PathType *string `json:"PathType,omitempty" xml:"PathType,omitempty"`
	// The matching pattern.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The replacement.
	Substitution *string `json:"Substitution,omitempty" xml:"Substitution,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataHTTPRewrite) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataHTTPRewrite) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetHost(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Host = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetPath(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Path = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetPathType(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.PathType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetPattern(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Pattern = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHTTPRewrite) SetSubstitution(v string) *GetGatewayRouteDetailResponseBodyDataHTTPRewrite {
	s.Substitution = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataHeaderOp struct {
	// The information about headers.
	HeaderOpItems []*GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems `json:"HeaderOpItems,omitempty" xml:"HeaderOpItems,omitempty" type:"Repeated"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOp) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOp) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOp) SetHeaderOpItems(v []*GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) *GetGatewayRouteDetailResponseBodyDataHeaderOp {
	s.HeaderOpItems = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOp) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOp {
	s.Status = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems struct {
	// The request or response.
	DirectionType *string `json:"DirectionType,omitempty" xml:"DirectionType,omitempty"`
	// The header key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The operation type.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The header value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetDirectionType(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.DirectionType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetKey(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.Key = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetOpType(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.OpType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems) SetValue(v string) *GetGatewayRouteDetailResponseBodyDataHeaderOpHeaderOpItems {
	s.Value = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRedirect struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRedirect) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRedirect) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRedirect) SetCode(v int32) *GetGatewayRouteDetailResponseBodyDataRedirect {
	s.Code = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRedirect) SetHost(v string) *GetGatewayRouteDetailResponseBodyDataRedirect {
	s.Host = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRedirect) SetPath(v string) *GetGatewayRouteDetailResponseBodyDataRedirect {
	s.Path = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRetry struct {
	// The number of retries allowed.
	Attempts *int32 `json:"Attempts,omitempty" xml:"Attempts,omitempty"`
	// The HTTP status codes.
	HttpCodes []*string `json:"HttpCodes,omitempty" xml:"HttpCodes,omitempty" type:"Repeated"`
	// The retry condition.
	RetryOn []*string `json:"RetryOn,omitempty" xml:"RetryOn,omitempty" type:"Repeated"`
	// The retry status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRetry) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRetry) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetAttempts(v int32) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.Attempts = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetHttpCodes(v []*string) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.HttpCodes = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetRetryOn(v []*string) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.RetryOn = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRetry) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataRetry {
	s.Status = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicates struct {
	// The information about header matching.
	HeaderPredicates []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about route matching.
	PathPredicates *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The information about parameter matching.
	QueryPredicates []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetHeaderPredicates(v []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.HeaderPredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetMethodPredicates(v []*string) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.MethodPredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetPathPredicates(v *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.PathPredicates = v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicates) SetQueryPredicates(v []*GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) *GetGatewayRouteDetailResponseBodyDataRoutePredicates {
	s.QueryPredicates = v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) SetKey(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) SetType(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates) SetValue(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates struct {
	// Indicates whether case sensitivity is ignored.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) SetIgnoreCase(v bool) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) SetPath(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates) SetType(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesPathPredicates {
	s.Type = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates struct {
	// The name of the parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) SetKey(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) SetType(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates) SetValue(v string) *GetGatewayRouteDetailResponseBodyDataRoutePredicatesQueryPredicates {
	s.Value = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataRouteServices struct {
	// The type of the protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataRouteServices) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataRouteServices) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetAgreementType(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.AgreementType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetGroupName(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.GroupName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetName(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Name = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetNamespace(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Namespace = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetPercent(v int32) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Percent = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetServiceId(v int64) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.ServiceId = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetServiceName(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.ServiceName = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetServicePort(v int32) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.ServicePort = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetSourceType(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.SourceType = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataRouteServices) SetVersion(v string) *GetGatewayRouteDetailResponseBodyDataRouteServices {
	s.Version = &v
	return s
}

type GetGatewayRouteDetailResponseBodyDataTimeout struct {
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int32 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s GetGatewayRouteDetailResponseBodyDataTimeout) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponseBodyDataTimeout) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponseBodyDataTimeout) SetStatus(v string) *GetGatewayRouteDetailResponseBodyDataTimeout {
	s.Status = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataTimeout) SetTimeUnit(v string) *GetGatewayRouteDetailResponseBodyDataTimeout {
	s.TimeUnit = &v
	return s
}

func (s *GetGatewayRouteDetailResponseBodyDataTimeout) SetUnitNum(v int32) *GetGatewayRouteDetailResponseBodyDataTimeout {
	s.UnitNum = &v
	return s
}

type GetGatewayRouteDetailResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayRouteDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayRouteDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayRouteDetailResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayRouteDetailResponse) SetHeaders(v map[string]*string) *GetGatewayRouteDetailResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayRouteDetailResponse) SetStatusCode(v int32) *GetGatewayRouteDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayRouteDetailResponse) SetBody(v *GetGatewayRouteDetailResponseBody) *GetGatewayRouteDetailResponse {
	s.Body = v
	return s
}

type GetGatewayServiceDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s GetGatewayServiceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailRequest) SetAcceptLanguage(v string) *GetGatewayServiceDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGatewayServiceDetailRequest) SetGatewayUniqueId(v string) *GetGatewayServiceDetailRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayServiceDetailRequest) SetServiceId(v int64) *GetGatewayServiceDetailRequest {
	s.ServiceId = &v
	return s
}

type GetGatewayServiceDetailResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GetGatewayServiceDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayServiceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBody) SetCode(v int32) *GetGatewayServiceDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetData(v *GetGatewayServiceDetailResponseBodyData) *GetGatewayServiceDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetHttpStatusCode(v int32) *GetGatewayServiceDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetMessage(v string) *GetGatewayServiceDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetRequestId(v string) *GetGatewayServiceDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBody) SetSuccess(v bool) *GetGatewayServiceDetailResponseBody {
	s.Success = &v
	return s
}

type GetGatewayServiceDetailResponseBodyData struct {
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic policy of the service.
	GatewayTrafficPolicy *TrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// Indicates whether the health check is enabled.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The status of the health check. Valid values:
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The ID of the service.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The IP address of the service.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The details of the tag.
	LabelDetails []*GetGatewayServiceDetailResponseBodyDataLabelDetails `json:"LabelDetails,omitempty" xml:"LabelDetails,omitempty" type:"Repeated"`
	// The basic information about the service.
	MetaInfo *string `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The traffic policy of service ports.
	PortTrafficPolicyList []*GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList `json:"PortTrafficPolicyList,omitempty" xml:"PortTrafficPolicyList,omitempty" type:"Repeated"`
	// The array of service ports.
	Ports []*int32 `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// The name of the service registered with the service registry.
	ServiceNameInRegistry *string `json:"ServiceNameInRegistry,omitempty" xml:"ServiceNameInRegistry,omitempty"`
	// The protocol of the service.
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
	// The ID of the service source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The source type of the service.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The details of versions.
	VersionDetails []*GetGatewayServiceDetailResponseBodyDataVersionDetails `json:"VersionDetails,omitempty" xml:"VersionDetails,omitempty" type:"Repeated"`
	// The version of the service.
	Versions []*GetGatewayServiceDetailResponseBodyDataVersions `json:"Versions,omitempty" xml:"Versions,omitempty" type:"Repeated"`
}

func (s GetGatewayServiceDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGatewayId(v int64) *GetGatewayServiceDetailResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGatewayTrafficPolicy(v *TrafficPolicy) *GetGatewayServiceDetailResponseBodyData {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGatewayUniqueId(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGmtCreate(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGmtModified(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetGroupName(v string) *GetGatewayServiceDetailResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetHealthCheck(v string) *GetGatewayServiceDetailResponseBodyData {
	s.HealthCheck = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetHealthStatus(v string) *GetGatewayServiceDetailResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetId(v int64) *GetGatewayServiceDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetIps(v []*string) *GetGatewayServiceDetailResponseBodyData {
	s.Ips = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetLabelDetails(v []*GetGatewayServiceDetailResponseBodyDataLabelDetails) *GetGatewayServiceDetailResponseBodyData {
	s.LabelDetails = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetMetaInfo(v string) *GetGatewayServiceDetailResponseBodyData {
	s.MetaInfo = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetName(v string) *GetGatewayServiceDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetNamespace(v string) *GetGatewayServiceDetailResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetPortTrafficPolicyList(v []*GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) *GetGatewayServiceDetailResponseBodyData {
	s.PortTrafficPolicyList = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetPorts(v []*int32) *GetGatewayServiceDetailResponseBodyData {
	s.Ports = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetServiceNameInRegistry(v string) *GetGatewayServiceDetailResponseBodyData {
	s.ServiceNameInRegistry = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetServiceProtocol(v string) *GetGatewayServiceDetailResponseBodyData {
	s.ServiceProtocol = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetSourceId(v int64) *GetGatewayServiceDetailResponseBodyData {
	s.SourceId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetSourceType(v string) *GetGatewayServiceDetailResponseBodyData {
	s.SourceType = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetVersionDetails(v []*GetGatewayServiceDetailResponseBodyDataVersionDetails) *GetGatewayServiceDetailResponseBodyData {
	s.VersionDetails = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyData) SetVersions(v []*GetGatewayServiceDetailResponseBodyDataVersions) *GetGatewayServiceDetailResponseBodyData {
	s.Versions = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataLabelDetails struct {
	// The tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The key of the tag.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s GetGatewayServiceDetailResponseBodyDataLabelDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataLabelDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataLabelDetails) SetKey(v string) *GetGatewayServiceDetailResponseBodyDataLabelDetails {
	s.Key = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataLabelDetails) SetValues(v []*string) *GetGatewayServiceDetailResponseBodyDataLabelDetails {
	s.Values = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList struct {
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the port configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The traffic policy.
	TrafficPolicy *TrafficPolicy `json:"TrafficPolicy,omitempty" xml:"TrafficPolicy,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetGatewayUniqueId(v string) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetGmtCreate(v string) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetGmtModified(v string) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.GmtModified = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetId(v int64) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.Id = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetServiceId(v int64) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.ServiceId = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetServicePort(v int32) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.ServicePort = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList) SetTrafficPolicy(v *TrafficPolicy) *GetGatewayServiceDetailResponseBodyDataPortTrafficPolicyList {
	s.TrafficPolicy = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersionDetails struct {
	// The number of instances.
	EndpointNum *int32 `json:"EndpointNum,omitempty" xml:"EndpointNum,omitempty"`
	// The percentage of instances.
	EndpointNumPercent *string `json:"EndpointNumPercent,omitempty" xml:"EndpointNumPercent,omitempty"`
	// The version of the service.
	ServiceVersion *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty" type:"Struct"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetails) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetails) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetails) SetEndpointNum(v int32) *GetGatewayServiceDetailResponseBodyDataVersionDetails {
	s.EndpointNum = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetails) SetEndpointNumPercent(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetails {
	s.EndpointNumPercent = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetails) SetServiceVersion(v *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) *GetGatewayServiceDetailResponseBodyDataVersionDetails {
	s.ServiceVersion = v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion struct {
	// The tag.
	Labels []*GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The version number.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) SetLabels(v []*GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion {
	s.Labels = v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion) SetName(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersion {
	s.Name = &v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels struct {
	// The tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The key of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) SetKey(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels {
	s.Key = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels) SetValue(v string) *GetGatewayServiceDetailResponseBodyDataVersionDetailsServiceVersionLabels {
	s.Value = &v
	return s
}

type GetGatewayServiceDetailResponseBodyDataVersions struct {
	// The tag.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The key of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetGatewayServiceDetailResponseBodyDataVersions) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponseBodyDataVersions) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponseBodyDataVersions) SetLabel(v string) *GetGatewayServiceDetailResponseBodyDataVersions {
	s.Label = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersions) SetType(v string) *GetGatewayServiceDetailResponseBodyDataVersions {
	s.Type = &v
	return s
}

func (s *GetGatewayServiceDetailResponseBodyDataVersions) SetValue(v string) *GetGatewayServiceDetailResponseBodyDataVersions {
	s.Value = &v
	return s
}

type GetGatewayServiceDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayServiceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayServiceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayServiceDetailResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayServiceDetailResponse) SetHeaders(v map[string]*string) *GetGatewayServiceDetailResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayServiceDetailResponse) SetStatusCode(v int32) *GetGatewayServiceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayServiceDetailResponse) SetBody(v *GetGatewayServiceDetailResponseBody) *GetGatewayServiceDetailResponse {
	s.Body = v
	return s
}

type GetGovernanceKubernetesClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetGovernanceKubernetesClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterRequest) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterRequest) SetAcceptLanguage(v string) *GetGovernanceKubernetesClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetGovernanceKubernetesClusterRequest) SetClusterId(v string) *GetGovernanceKubernetesClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *GetGovernanceKubernetesClusterRequest) SetRegionId(v string) *GetGovernanceKubernetesClusterRequest {
	s.RegionId = &v
	return s
}

type GetGovernanceKubernetesClusterResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GetGovernanceKubernetesClusterResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGovernanceKubernetesClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponseBody) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetCode(v int32) *GetGovernanceKubernetesClusterResponseBody {
	s.Code = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetData(v *GetGovernanceKubernetesClusterResponseBodyData) *GetGovernanceKubernetesClusterResponseBody {
	s.Data = v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetHttpStatusCode(v int32) *GetGovernanceKubernetesClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetMessage(v string) *GetGovernanceKubernetesClusterResponseBody {
	s.Message = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetRequestId(v string) *GetGovernanceKubernetesClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBody) SetSuccess(v bool) *GetGovernanceKubernetesClusterResponseBody {
	s.Success = &v
	return s
}

type GetGovernanceKubernetesClusterResponseBodyData struct {
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The version of Kubernetes.
	K8sVersion *string `json:"K8sVersion,omitempty" xml:"K8sVersion,omitempty"`
	// The information of the namespace.
	NamespaceInfos *string `json:"NamespaceInfos,omitempty" xml:"NamespaceInfos,omitempty"`
	// The list of namespaces.
	Namespaces []*GetGovernanceKubernetesClusterResponseBodyDataNamespaces `json:"Namespaces,omitempty" xml:"Namespaces,omitempty" type:"Repeated"`
	// The time when the ack-onepilot component was started.
	PilotStartTime *string `json:"PilotStartTime,omitempty" xml:"PilotStartTime,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The time of the last modification.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s GetGovernanceKubernetesClusterResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetClusterId(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetClusterName(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetK8sVersion(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.K8sVersion = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetNamespaceInfos(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.NamespaceInfos = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetNamespaces(v []*GetGovernanceKubernetesClusterResponseBodyDataNamespaces) *GetGovernanceKubernetesClusterResponseBodyData {
	s.Namespaces = v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetPilotStartTime(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.PilotStartTime = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetRegion(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.Region = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyData) SetUpdateTime(v string) *GetGovernanceKubernetesClusterResponseBodyData {
	s.UpdateTime = &v
	return s
}

type GetGovernanceKubernetesClusterResponseBodyDataNamespaces struct {
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The tags.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s GetGovernanceKubernetesClusterResponseBodyDataNamespaces) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponseBodyDataNamespaces) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponseBodyDataNamespaces) SetName(v string) *GetGovernanceKubernetesClusterResponseBodyDataNamespaces {
	s.Name = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponseBodyDataNamespaces) SetTags(v string) *GetGovernanceKubernetesClusterResponseBodyDataNamespaces {
	s.Tags = &v
	return s
}

type GetGovernanceKubernetesClusterResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGovernanceKubernetesClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGovernanceKubernetesClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGovernanceKubernetesClusterResponse) GoString() string {
	return s.String()
}

func (s *GetGovernanceKubernetesClusterResponse) SetHeaders(v map[string]*string) *GetGovernanceKubernetesClusterResponse {
	s.Headers = v
	return s
}

func (s *GetGovernanceKubernetesClusterResponse) SetStatusCode(v int32) *GetGovernanceKubernetesClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGovernanceKubernetesClusterResponse) SetBody(v *GetGovernanceKubernetesClusterResponseBody) *GetGovernanceKubernetesClusterResponse {
	s.Body = v
	return s
}

type GetImageRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The version number of the current instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s GetImageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImageRequest) GoString() string {
	return s.String()
}

func (s *GetImageRequest) SetAcceptLanguage(v string) *GetImageRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetImageRequest) SetVersionCode(v string) *GetImageRequest {
	s.VersionCode = &v
	return s
}

type GetImageResponseBody struct {
	// The details of the data.
	Data *GetImageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImageResponseBody) GoString() string {
	return s.String()
}

func (s *GetImageResponseBody) SetData(v *GetImageResponseBodyData) *GetImageResponseBody {
	s.Data = v
	return s
}

func (s *GetImageResponseBody) SetErrorCode(v string) *GetImageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetImageResponseBody) SetHttpCode(v string) *GetImageResponseBody {
	s.HttpCode = &v
	return s
}

func (s *GetImageResponseBody) SetMessage(v string) *GetImageResponseBody {
	s.Message = &v
	return s
}

func (s *GetImageResponseBody) SetRequestId(v string) *GetImageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetImageResponseBody) SetSuccess(v bool) *GetImageResponseBody {
	s.Success = &v
	return s
}

type GetImageResponseBodyData struct {
	// The full version number of the current instance image. The parameter is in the X.X.X.X format.
	CurrentVersionFullShowName *string `json:"CurrentVersionFullShowName,omitempty" xml:"CurrentVersionFullShowName,omitempty"`
	// The URL of the changelog for the maximum version to which the current version can be upgraded.
	MaxVersionChangelogUrl *string `json:"MaxVersionChangelogUrl,omitempty" xml:"MaxVersionChangelogUrl,omitempty"`
	// The code of the maximum version to which the current version can be upgraded.
	MaxVersionCode *string `json:"MaxVersionCode,omitempty" xml:"MaxVersionCode,omitempty"`
	// The full number of the maximum version to which the current version can be upgraded.
	MaxVersionFullShowName *string `json:"MaxVersionFullShowName,omitempty" xml:"MaxVersionFullShowName,omitempty"`
}

func (s GetImageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetImageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetImageResponseBodyData) SetCurrentVersionFullShowName(v string) *GetImageResponseBodyData {
	s.CurrentVersionFullShowName = &v
	return s
}

func (s *GetImageResponseBodyData) SetMaxVersionChangelogUrl(v string) *GetImageResponseBodyData {
	s.MaxVersionChangelogUrl = &v
	return s
}

func (s *GetImageResponseBodyData) SetMaxVersionCode(v string) *GetImageResponseBodyData {
	s.MaxVersionCode = &v
	return s
}

func (s *GetImageResponseBodyData) SetMaxVersionFullShowName(v string) *GetImageResponseBodyData {
	s.MaxVersionFullShowName = &v
	return s
}

type GetImageResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetImageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImageResponse) GoString() string {
	return s.String()
}

func (s *GetImageResponse) SetHeaders(v map[string]*string) *GetImageResponse {
	s.Headers = v
	return s
}

func (s *GetImageResponse) SetStatusCode(v int32) *GetImageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImageResponse) SetBody(v *GetImageResponseBody) *GetImageResponse {
	s.Body = v
	return s
}

type GetImportFileUrlRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The file type.
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s GetImportFileUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlRequest) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlRequest) SetAcceptLanguage(v string) *GetImportFileUrlRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetImportFileUrlRequest) SetContentType(v string) *GetImportFileUrlRequest {
	s.ContentType = &v
	return s
}

func (s *GetImportFileUrlRequest) SetInstanceId(v string) *GetImportFileUrlRequest {
	s.InstanceId = &v
	return s
}

func (s *GetImportFileUrlRequest) SetNamespaceId(v string) *GetImportFileUrlRequest {
	s.NamespaceId = &v
	return s
}

type GetImportFileUrlResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GetImportFileUrlResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetImportFileUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlResponseBody) SetCode(v int32) *GetImportFileUrlResponseBody {
	s.Code = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetData(v *GetImportFileUrlResponseBodyData) *GetImportFileUrlResponseBody {
	s.Data = v
	return s
}

func (s *GetImportFileUrlResponseBody) SetDynamicMessage(v string) *GetImportFileUrlResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetErrorCode(v string) *GetImportFileUrlResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetHttpStatusCode(v int32) *GetImportFileUrlResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetMessage(v string) *GetImportFileUrlResponseBody {
	s.Message = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetRequestId(v string) *GetImportFileUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetImportFileUrlResponseBody) SetSuccess(v bool) *GetImportFileUrlResponseBody {
	s.Success = &v
	return s
}

type GetImportFileUrlResponseBodyData struct {
	// The URL that is used to upload the configuration file.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetImportFileUrlResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlResponseBodyData) SetUrl(v string) *GetImportFileUrlResponseBodyData {
	s.Url = &v
	return s
}

type GetImportFileUrlResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetImportFileUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetImportFileUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImportFileUrlResponse) GoString() string {
	return s.String()
}

func (s *GetImportFileUrlResponse) SetHeaders(v map[string]*string) *GetImportFileUrlResponse {
	s.Headers = v
	return s
}

func (s *GetImportFileUrlResponse) SetStatusCode(v int32) *GetImportFileUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImportFileUrlResponse) SetBody(v *GetImportFileUrlResponseBody) *GetImportFileUrlResponse {
	s.Body = v
	return s
}

type GetKubernetesSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetKubernetesSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceRequest) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceRequest) SetAcceptLanguage(v string) *GetKubernetesSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetKubernetesSourceRequest) SetGatewayUniqueId(v string) *GetKubernetesSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetKubernetesSourceRequest) SetVpcId(v string) *GetKubernetesSourceRequest {
	s.VpcId = &v
	return s
}

type GetKubernetesSourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*GetKubernetesSourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetKubernetesSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceResponseBody) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceResponseBody) SetCode(v int32) *GetKubernetesSourceResponseBody {
	s.Code = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetData(v []*GetKubernetesSourceResponseBodyData) *GetKubernetesSourceResponseBody {
	s.Data = v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetHttpStatusCode(v int32) *GetKubernetesSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetMessage(v string) *GetKubernetesSourceResponseBody {
	s.Message = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetRequestId(v string) *GetKubernetesSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetKubernetesSourceResponseBody) SetSuccess(v bool) *GetKubernetesSourceResponseBody {
	s.Success = &v
	return s
}

type GetKubernetesSourceResponseBodyData struct {
	// The ID of the ACK cluster.
	Cluster *string `json:"Cluster,omitempty" xml:"Cluster,omitempty"`
	// The name of the ACK cluster.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetKubernetesSourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceResponseBodyData) SetCluster(v string) *GetKubernetesSourceResponseBodyData {
	s.Cluster = &v
	return s
}

func (s *GetKubernetesSourceResponseBodyData) SetName(v string) *GetKubernetesSourceResponseBodyData {
	s.Name = &v
	return s
}

type GetKubernetesSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetKubernetesSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetKubernetesSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetKubernetesSourceResponse) GoString() string {
	return s.String()
}

func (s *GetKubernetesSourceResponse) SetHeaders(v map[string]*string) *GetKubernetesSourceResponse {
	s.Headers = v
	return s
}

func (s *GetKubernetesSourceResponse) SetStatusCode(v int32) *GetKubernetesSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetKubernetesSourceResponse) SetBody(v *GetKubernetesSourceResponseBody) *GetKubernetesSourceResponse {
	s.Body = v
	return s
}

type GetMseFeatureSwitchRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s GetMseFeatureSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMseFeatureSwitchRequest) GoString() string {
	return s.String()
}

func (s *GetMseFeatureSwitchRequest) SetAcceptLanguage(v string) *GetMseFeatureSwitchRequest {
	s.AcceptLanguage = &v
	return s
}

type GetMseFeatureSwitchResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result map[string]interface{} `json:"Result,omitempty" xml:"Result,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMseFeatureSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMseFeatureSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *GetMseFeatureSwitchResponseBody) SetErrorCode(v string) *GetMseFeatureSwitchResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetMessage(v string) *GetMseFeatureSwitchResponseBody {
	s.Message = &v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetRequestId(v string) *GetMseFeatureSwitchResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetResult(v map[string]interface{}) *GetMseFeatureSwitchResponseBody {
	s.Result = v
	return s
}

func (s *GetMseFeatureSwitchResponseBody) SetSuccess(v bool) *GetMseFeatureSwitchResponseBody {
	s.Success = &v
	return s
}

type GetMseFeatureSwitchResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMseFeatureSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMseFeatureSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMseFeatureSwitchResponse) GoString() string {
	return s.String()
}

func (s *GetMseFeatureSwitchResponse) SetHeaders(v map[string]*string) *GetMseFeatureSwitchResponse {
	s.Headers = v
	return s
}

func (s *GetMseFeatureSwitchResponse) SetStatusCode(v int32) *GetMseFeatureSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMseFeatureSwitchResponse) SetBody(v *GetMseFeatureSwitchResponseBody) *GetMseFeatureSwitchResponse {
	s.Body = v
	return s
}

type GetMseSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The MSE engine type. Valid values:
	//
	// *   NACOS
	// *   ZOOKEEPER
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMseSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceRequest) GoString() string {
	return s.String()
}

func (s *GetMseSourceRequest) SetAcceptLanguage(v string) *GetMseSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetMseSourceRequest) SetGatewayUniqueId(v string) *GetMseSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetMseSourceRequest) SetType(v string) *GetMseSourceRequest {
	s.Type = &v
	return s
}

type GetMseSourceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*GetMseSourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMseSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceResponseBody) GoString() string {
	return s.String()
}

func (s *GetMseSourceResponseBody) SetCode(v int32) *GetMseSourceResponseBody {
	s.Code = &v
	return s
}

func (s *GetMseSourceResponseBody) SetData(v []*GetMseSourceResponseBodyData) *GetMseSourceResponseBody {
	s.Data = v
	return s
}

func (s *GetMseSourceResponseBody) SetHttpStatusCode(v int32) *GetMseSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMseSourceResponseBody) SetMessage(v string) *GetMseSourceResponseBody {
	s.Message = &v
	return s
}

func (s *GetMseSourceResponseBody) SetRequestId(v string) *GetMseSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMseSourceResponseBody) SetSuccess(v bool) *GetMseSourceResponseBody {
	s.Success = &v
	return s
}

type GetMseSourceResponseBodyData struct {
	// The endpoint of the instance.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMseSourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMseSourceResponseBodyData) SetAddress(v string) *GetMseSourceResponseBodyData {
	s.Address = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetClusterId(v string) *GetMseSourceResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetInstanceId(v string) *GetMseSourceResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetName(v string) *GetMseSourceResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetMseSourceResponseBodyData) SetType(v string) *GetMseSourceResponseBodyData {
	s.Type = &v
	return s
}

type GetMseSourceResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMseSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMseSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMseSourceResponse) GoString() string {
	return s.String()
}

func (s *GetMseSourceResponse) SetHeaders(v map[string]*string) *GetMseSourceResponse {
	s.Headers = v
	return s
}

func (s *GetMseSourceResponse) SetStatusCode(v int32) *GetMseSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMseSourceResponse) SetBody(v *GetMseSourceResponseBody) *GetMseSourceResponse {
	s.Body = v
	return s
}

type GetNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to perform a beta release. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Beta *bool `json:"Beta,omitempty" xml:"Beta,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s GetNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *GetNacosConfigRequest) SetAcceptLanguage(v string) *GetNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetNacosConfigRequest) SetBeta(v bool) *GetNacosConfigRequest {
	s.Beta = &v
	return s
}

func (s *GetNacosConfigRequest) SetDataId(v string) *GetNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *GetNacosConfigRequest) SetGroup(v string) *GetNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *GetNacosConfigRequest) SetInstanceId(v string) *GetNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *GetNacosConfigRequest) SetNamespaceId(v string) *GetNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

type GetNacosConfigResponseBody struct {
	// The configuration information.
	Configuration *GetNacosConfigResponseBodyConfiguration `json:"Configuration,omitempty" xml:"Configuration,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetNacosConfigResponseBody) SetConfiguration(v *GetNacosConfigResponseBodyConfiguration) *GetNacosConfigResponseBody {
	s.Configuration = v
	return s
}

func (s *GetNacosConfigResponseBody) SetErrorCode(v string) *GetNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNacosConfigResponseBody) SetMessage(v string) *GetNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetNacosConfigResponseBody) SetRequestId(v string) *GetNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNacosConfigResponseBody) SetSuccess(v bool) *GetNacosConfigResponseBody {
	s.Success = &v
	return s
}

type GetNacosConfigResponseBodyConfiguration struct {
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The list of IP addresses where the beta release of the configuration is performed.
	BetaIps *string `json:"BetaIps,omitempty" xml:"BetaIps,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The description of the configuration.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The encryption key.
	EncryptedDataKey *string `json:"EncryptedDataKey,omitempty" xml:"EncryptedDataKey,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The MD5 value of the configuration.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The tags of the configuration.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The format of the configuration.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetNacosConfigResponseBodyConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigResponseBodyConfiguration) GoString() string {
	return s.String()
}

func (s *GetNacosConfigResponseBodyConfiguration) SetAppName(v string) *GetNacosConfigResponseBodyConfiguration {
	s.AppName = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetBetaIps(v string) *GetNacosConfigResponseBodyConfiguration {
	s.BetaIps = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetContent(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Content = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetDataId(v string) *GetNacosConfigResponseBodyConfiguration {
	s.DataId = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetDesc(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Desc = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetEncryptedDataKey(v string) *GetNacosConfigResponseBodyConfiguration {
	s.EncryptedDataKey = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetGroup(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Group = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetMd5(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Md5 = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetTags(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Tags = &v
	return s
}

func (s *GetNacosConfigResponseBodyConfiguration) SetType(v string) *GetNacosConfigResponseBodyConfiguration {
	s.Type = &v
	return s
}

type GetNacosConfigResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *GetNacosConfigResponse) SetHeaders(v map[string]*string) *GetNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *GetNacosConfigResponse) SetStatusCode(v int32) *GetNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNacosConfigResponse) SetBody(v *GetNacosConfigResponseBody) *GetNacosConfigResponse {
	s.Body = v
	return s
}

type GetNacosHistoryConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The version ID of the configuration.
	Nid *string `json:"Nid,omitempty" xml:"Nid,omitempty"`
}

func (s GetNacosHistoryConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigRequest) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigRequest) SetAcceptLanguage(v string) *GetNacosHistoryConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetDataId(v string) *GetNacosHistoryConfigRequest {
	s.DataId = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetGroup(v string) *GetNacosHistoryConfigRequest {
	s.Group = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetInstanceId(v string) *GetNacosHistoryConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetNamespaceId(v string) *GetNacosHistoryConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *GetNacosHistoryConfigRequest) SetNid(v string) *GetNacosHistoryConfigRequest {
	s.Nid = &v
	return s
}

type GetNacosHistoryConfigResponseBody struct {
	// The configuration information.
	Configuration *GetNacosHistoryConfigResponseBodyConfiguration `json:"Configuration,omitempty" xml:"Configuration,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNacosHistoryConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigResponseBody) SetConfiguration(v *GetNacosHistoryConfigResponseBodyConfiguration) *GetNacosHistoryConfigResponseBody {
	s.Configuration = v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetErrorCode(v string) *GetNacosHistoryConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetMessage(v string) *GetNacosHistoryConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetRequestId(v string) *GetNacosHistoryConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBody) SetSuccess(v bool) *GetNacosHistoryConfigResponseBody {
	s.Success = &v
	return s
}

type GetNacosHistoryConfigResponseBodyConfiguration struct {
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The encryption key.
	EncryptedDataKey *string `json:"EncryptedDataKey,omitempty" xml:"EncryptedDataKey,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The MD5 value of the configuration.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The configuration type.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
}

func (s GetNacosHistoryConfigResponseBodyConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigResponseBodyConfiguration) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetAppName(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.AppName = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetContent(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.Content = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetDataId(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.DataId = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetEncryptedDataKey(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.EncryptedDataKey = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetGroup(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.Group = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetMd5(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.Md5 = &v
	return s
}

func (s *GetNacosHistoryConfigResponseBodyConfiguration) SetOpType(v string) *GetNacosHistoryConfigResponseBodyConfiguration {
	s.OpType = &v
	return s
}

type GetNacosHistoryConfigResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetNacosHistoryConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetNacosHistoryConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNacosHistoryConfigResponse) GoString() string {
	return s.String()
}

func (s *GetNacosHistoryConfigResponse) SetHeaders(v map[string]*string) *GetNacosHistoryConfigResponse {
	s.Headers = v
	return s
}

func (s *GetNacosHistoryConfigResponse) SetStatusCode(v int32) *GetNacosHistoryConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNacosHistoryConfigResponse) SetBody(v *GetNacosHistoryConfigResponseBody) *GetNacosHistoryConfigResponse {
	s.Body = v
	return s
}

type GetOverviewRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The subscription period of the instance. Unit: months. Valid values: 1, 2, 3, 6, and 12.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s GetOverviewRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOverviewRequest) GoString() string {
	return s.String()
}

func (s *GetOverviewRequest) SetAcceptLanguage(v string) *GetOverviewRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetOverviewRequest) SetPeriod(v int32) *GetOverviewRequest {
	s.Period = &v
	return s
}

func (s *GetOverviewRequest) SetRegion(v string) *GetOverviewRequest {
	s.Region = &v
	return s
}

type GetOverviewResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetOverviewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOverviewResponseBody) GoString() string {
	return s.String()
}

func (s *GetOverviewResponseBody) SetCode(v int32) *GetOverviewResponseBody {
	s.Code = &v
	return s
}

func (s *GetOverviewResponseBody) SetData(v string) *GetOverviewResponseBody {
	s.Data = &v
	return s
}

func (s *GetOverviewResponseBody) SetHttpStatusCode(v int32) *GetOverviewResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetOverviewResponseBody) SetMessage(v string) *GetOverviewResponseBody {
	s.Message = &v
	return s
}

func (s *GetOverviewResponseBody) SetRequestId(v string) *GetOverviewResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOverviewResponseBody) SetSuccess(v string) *GetOverviewResponseBody {
	s.Success = &v
	return s
}

type GetOverviewResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOverviewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOverviewResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOverviewResponse) GoString() string {
	return s.String()
}

func (s *GetOverviewResponse) SetHeaders(v map[string]*string) *GetOverviewResponse {
	s.Headers = v
	return s
}

func (s *GetOverviewResponse) SetStatusCode(v int32) *GetOverviewResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOverviewResponse) SetBody(v *GetOverviewResponseBody) *GetOverviewResponse {
	s.Body = v
	return s
}

type GetPluginConfigRequest struct {
	// The language of the response. Valid values:
	//
	// zh: Chinese en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the gateway plug-in.
	PluginId *int64 `json:"PluginId,omitempty" xml:"PluginId,omitempty"`
}

func (s GetPluginConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigRequest) GoString() string {
	return s.String()
}

func (s *GetPluginConfigRequest) SetAcceptLanguage(v string) *GetPluginConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetPluginConfigRequest) SetGatewayUniqueId(v string) *GetPluginConfigRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetPluginConfigRequest) SetPluginId(v int64) *GetPluginConfigRequest {
	s.PluginId = &v
	return s
}

type GetPluginConfigResponseBody struct {
	// Code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetPluginConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic error code.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetPluginConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponseBody) SetCode(v int32) *GetPluginConfigResponseBody {
	s.Code = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetData(v *GetPluginConfigResponseBodyData) *GetPluginConfigResponseBody {
	s.Data = v
	return s
}

func (s *GetPluginConfigResponseBody) SetDynamicCode(v string) *GetPluginConfigResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetDynamicMessage(v string) *GetPluginConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetErrorCode(v string) *GetPluginConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetHttpStatusCode(v int32) *GetPluginConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetMessage(v string) *GetPluginConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetRequestId(v string) *GetPluginConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPluginConfigResponseBody) SetSuccess(v bool) *GetPluginConfigResponseBody {
	s.Success = &v
	return s
}

type GetPluginConfigResponseBodyData struct {
	// The category of the plug-in.
	//
	// 0: custom
	//
	// 1: permission authorization
	//
	// 2: security protection
	//
	// 3: transmission protocol
	//
	// 4: traffic control
	//
	// 5: traffic observation
	Category *int32 `json:"Category,omitempty" xml:"Category,omitempty"`
	// The information about the plug-in configuration used for checking.
	ConfigCheck *string `json:"ConfigCheck,omitempty" xml:"ConfigCheck,omitempty"`
	// The list of gateway plug-in configurations.
	GatewayConfigList []*GetPluginConfigResponseBodyDataGatewayConfigList `json:"GatewayConfigList,omitempty" xml:"GatewayConfigList,omitempty" type:"Repeated"`
	// The ID of the plug-in.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the image.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The mode.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the plug-in.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The execution stage of the plug-in.
	//
	// 0: default stage
	//
	// 1: authorization stage
	//
	// 2: authentication stage
	//
	// 3: statistics stage
	Phase *int32 `json:"Phase,omitempty" xml:"Phase,omitempty"`
	// The ID of the creator.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The execution priority of the plug-in. A larger value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The publish status.
	PublishState *int32 `json:"PublishState,omitempty" xml:"PublishState,omitempty"`
	// The description of the README file.
	Readme *string `json:"Readme,omitempty" xml:"Readme,omitempty"`
	// The description of the README file that is edited in English.
	ReadmeEn *string `json:"ReadmeEn,omitempty" xml:"ReadmeEn,omitempty"`
	// Indicates whether the plug-in is enabled.
	//
	// 0: disabled
	//
	// 1: enabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The summary of the plug-in.
	Summary *string `json:"Summary,omitempty" xml:"Summary,omitempty"`
	// The type.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
	// The version of the plug-in.
	Version     *string `json:"Version,omitempty" xml:"Version,omitempty"`
	VersionJson *string `json:"VersionJson,omitempty" xml:"VersionJson,omitempty"`
	// The WebAssembly language.
	//
	// 0: C++
	//
	// 1: TinyGo
	//
	// 2: Rust
	//
	// 3: AssemblyScript
	//
	// 4: Zig
	WasmLang *int32 `json:"WasmLang,omitempty" xml:"WasmLang,omitempty"`
}

func (s GetPluginConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponseBodyData) SetCategory(v int32) *GetPluginConfigResponseBodyData {
	s.Category = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetConfigCheck(v string) *GetPluginConfigResponseBodyData {
	s.ConfigCheck = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetGatewayConfigList(v []*GetPluginConfigResponseBodyDataGatewayConfigList) *GetPluginConfigResponseBodyData {
	s.GatewayConfigList = v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetId(v int64) *GetPluginConfigResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetImageName(v string) *GetPluginConfigResponseBodyData {
	s.ImageName = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetMode(v int32) *GetPluginConfigResponseBodyData {
	s.Mode = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetName(v string) *GetPluginConfigResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPhase(v int32) *GetPluginConfigResponseBodyData {
	s.Phase = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPrimaryUser(v string) *GetPluginConfigResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPriority(v int32) *GetPluginConfigResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetPublishState(v int32) *GetPluginConfigResponseBodyData {
	s.PublishState = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetReadme(v string) *GetPluginConfigResponseBodyData {
	s.Readme = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetReadmeEn(v string) *GetPluginConfigResponseBodyData {
	s.ReadmeEn = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetStatus(v string) *GetPluginConfigResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetSummary(v string) *GetPluginConfigResponseBodyData {
	s.Summary = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetType(v int32) *GetPluginConfigResponseBodyData {
	s.Type = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetVersion(v string) *GetPluginConfigResponseBodyData {
	s.Version = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetVersionJson(v string) *GetPluginConfigResponseBodyData {
	s.VersionJson = &v
	return s
}

func (s *GetPluginConfigResponseBodyData) SetWasmLang(v int32) *GetPluginConfigResponseBodyData {
	s.WasmLang = &v
	return s
}

type GetPluginConfigResponseBodyDataGatewayConfigList struct {
	// The plug-in configuration.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The application scope of the plug-in.
	//
	// 0: global
	//
	// 1: domain names
	//
	// 2: routes
	ConfigLevel *int32 `json:"ConfigLevel,omitempty" xml:"ConfigLevel,omitempty"`
	// Indicates whether the plug-in is enabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the plug-in configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the gateway plug-in.
	PluginId *int64 `json:"PluginId,omitempty" xml:"PluginId,omitempty"`
}

func (s GetPluginConfigResponseBodyDataGatewayConfigList) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponseBodyDataGatewayConfigList) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetConfig(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.Config = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetConfigLevel(v int32) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.ConfigLevel = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetEnable(v bool) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.Enable = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGatewayId(v int64) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GatewayId = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGatewayUniqueId(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGmtCreate(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GmtCreate = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetGmtModified(v string) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.GmtModified = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetId(v int64) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.Id = &v
	return s
}

func (s *GetPluginConfigResponseBodyDataGatewayConfigList) SetPluginId(v int64) *GetPluginConfigResponseBodyDataGatewayConfigList {
	s.PluginId = &v
	return s
}

type GetPluginConfigResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPluginConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPluginConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPluginConfigResponse) GoString() string {
	return s.String()
}

func (s *GetPluginConfigResponse) SetHeaders(v map[string]*string) *GetPluginConfigResponse {
	s.Headers = v
	return s
}

func (s *GetPluginConfigResponse) SetStatusCode(v int32) *GetPluginConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPluginConfigResponse) SetBody(v *GetPluginConfigResponseBody) *GetPluginConfigResponse {
	s.Body = v
	return s
}

type GetPluginsRequest struct {
	// The language of the response. Valid values:
	//
	// zh: Chinese en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the plug-in. Valid values:
	//
	// *   0: custom
	// *   1: permission authorization
	// *   2: security protection
	// *   3: transmission protocol
	// *   4: traffic control
	// *   5: traffic observation
	Category *int32 `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to enable the plug-in.
	EnableOnly *bool `json:"EnableOnly,omitempty" xml:"EnableOnly,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the plug-in.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetPluginsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsRequest) GoString() string {
	return s.String()
}

func (s *GetPluginsRequest) SetAcceptLanguage(v string) *GetPluginsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetPluginsRequest) SetCategory(v int32) *GetPluginsRequest {
	s.Category = &v
	return s
}

func (s *GetPluginsRequest) SetEnableOnly(v bool) *GetPluginsRequest {
	s.EnableOnly = &v
	return s
}

func (s *GetPluginsRequest) SetGatewayUniqueId(v string) *GetPluginsRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *GetPluginsRequest) SetName(v string) *GetPluginsRequest {
	s.Name = &v
	return s
}

type GetPluginsResponseBody struct {
	// Code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*GetPluginsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetPluginsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsResponseBody) GoString() string {
	return s.String()
}

func (s *GetPluginsResponseBody) SetCode(v int32) *GetPluginsResponseBody {
	s.Code = &v
	return s
}

func (s *GetPluginsResponseBody) SetData(v []*GetPluginsResponseBodyData) *GetPluginsResponseBody {
	s.Data = v
	return s
}

func (s *GetPluginsResponseBody) SetDynamicCode(v string) *GetPluginsResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *GetPluginsResponseBody) SetDynamicMessage(v string) *GetPluginsResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetPluginsResponseBody) SetErrorCode(v string) *GetPluginsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetPluginsResponseBody) SetHttpStatusCode(v int32) *GetPluginsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetPluginsResponseBody) SetMessage(v string) *GetPluginsResponseBody {
	s.Message = &v
	return s
}

func (s *GetPluginsResponseBody) SetRequestId(v string) *GetPluginsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPluginsResponseBody) SetSuccess(v bool) *GetPluginsResponseBody {
	s.Success = &v
	return s
}

type GetPluginsResponseBodyData struct {
	// The type of the plug-in. Valid values:
	//
	// 0: custom
	//
	// 1: permission authorization
	//
	// 2: security protection
	//
	// 3: transmission protocol
	//
	// 4: traffic control
	//
	// 5: traffic observation
	Category *int32 `json:"Category,omitempty" xml:"Category,omitempty"`
	// The information about the plug-in configuration used for checking.
	ConfigCheck *string `json:"ConfigCheck,omitempty" xml:"ConfigCheck,omitempty"`
	// The ID of the plug-in.
	Id         *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	MaxVersion *string `json:"MaxVersion,omitempty" xml:"MaxVersion,omitempty"`
	Mode       *int32  `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the plug-in.
	Name                     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	NewVersionPublishingFlag *bool   `json:"NewVersionPublishingFlag,omitempty" xml:"NewVersionPublishingFlag,omitempty"`
	// The execution stage of the plug-in.
	//
	// *   0: default stage
	// *   1: authorization stage
	// *   2: authentication stage
	// *   3: statistics stage
	Phase *int32 `json:"Phase,omitempty" xml:"Phase,omitempty"`
	// The ID of the creator.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The execution priority of the plug-in. A larger value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The publish status.
	PublishState *int32 `json:"PublishState,omitempty" xml:"PublishState,omitempty"`
	// Indicates whether the plug-in is enabled.
	//
	// *   0: disabled
	// *   1: enabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The summary of the plug-in.
	Summary *string `json:"Summary,omitempty" xml:"Summary,omitempty"`
	// The version of the plug-in.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
	// The URL of the Object Storage Service (OSS) bucket that stores the WebAssembly plug-in.
	WasmFile *string `json:"WasmFile,omitempty" xml:"WasmFile,omitempty"`
	// The WebAssembly language. Valid values:
	//
	// *   0: C++
	// *   1: TinyGo
	// *   2: Rust
	// *   3: AssemblyScript
	// *   4: Zig
	WasmLang *int32 `json:"WasmLang,omitempty" xml:"WasmLang,omitempty"`
}

func (s GetPluginsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPluginsResponseBodyData) SetCategory(v int32) *GetPluginsResponseBodyData {
	s.Category = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetConfigCheck(v string) *GetPluginsResponseBodyData {
	s.ConfigCheck = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetId(v int64) *GetPluginsResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetMaxVersion(v string) *GetPluginsResponseBodyData {
	s.MaxVersion = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetMode(v int32) *GetPluginsResponseBodyData {
	s.Mode = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetName(v string) *GetPluginsResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetNewVersionPublishingFlag(v bool) *GetPluginsResponseBodyData {
	s.NewVersionPublishingFlag = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPhase(v int32) *GetPluginsResponseBodyData {
	s.Phase = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPrimaryUser(v string) *GetPluginsResponseBodyData {
	s.PrimaryUser = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPriority(v int32) *GetPluginsResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetPublishState(v int32) *GetPluginsResponseBodyData {
	s.PublishState = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetStatus(v string) *GetPluginsResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetSummary(v string) *GetPluginsResponseBodyData {
	s.Summary = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetVersion(v string) *GetPluginsResponseBodyData {
	s.Version = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetWasmFile(v string) *GetPluginsResponseBodyData {
	s.WasmFile = &v
	return s
}

func (s *GetPluginsResponseBodyData) SetWasmLang(v int32) *GetPluginsResponseBodyData {
	s.WasmLang = &v
	return s
}

type GetPluginsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPluginsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPluginsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPluginsResponse) GoString() string {
	return s.String()
}

func (s *GetPluginsResponse) SetHeaders(v map[string]*string) *GetPluginsResponse {
	s.Headers = v
	return s
}

func (s *GetPluginsResponse) SetStatusCode(v int32) *GetPluginsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPluginsResponse) SetBody(v *GetPluginsResponseBody) *GetPluginsResponse {
	s.Body = v
	return s
}

type GetServiceListRequest struct {
	// The language of the response.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The type of the framework.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
}

func (s GetServiceListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListRequest) GoString() string {
	return s.String()
}

func (s *GetServiceListRequest) SetAcceptLanguage(v string) *GetServiceListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetServiceListRequest) SetAppId(v string) *GetServiceListRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceListRequest) SetIp(v string) *GetServiceListRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceListRequest) SetRegion(v string) *GetServiceListRequest {
	s.Region = &v
	return s
}

func (s *GetServiceListRequest) SetServiceName(v string) *GetServiceListRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceListRequest) SetServiceType(v string) *GetServiceListRequest {
	s.ServiceType = &v
	return s
}

type GetServiceListResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*GetServiceListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceListResponseBody) SetCode(v int32) *GetServiceListResponseBody {
	s.Code = &v
	return s
}

func (s *GetServiceListResponseBody) SetData(v []*GetServiceListResponseBodyData) *GetServiceListResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceListResponseBody) SetHttpStatusCode(v int32) *GetServiceListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetServiceListResponseBody) SetMessage(v string) *GetServiceListResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceListResponseBody) SetRequestId(v string) *GetServiceListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetServiceListResponseBody) SetSuccess(v bool) *GetServiceListResponseBody {
	s.Success = &v
	return s
}

type GetServiceListResponseBodyData struct {
	// The name of the Dubbo application.
	DubboApplicationName *string `json:"DubboApplicationName,omitempty" xml:"DubboApplicationName,omitempty"`
	// The name of the application.
	EdasAppName *string `json:"EdasAppName,omitempty" xml:"EdasAppName,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The metadata.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The methods.
	Methods []*GetServiceListResponseBodyDataMethods `json:"Methods,omitempty" xml:"Methods,omitempty" type:"Repeated"`
	// The type of the service registry.
	RegistryType *string `json:"RegistryType,omitempty" xml:"RegistryType,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The type of the service.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	// The name of the Spring application.
	SpringApplicationName *string `json:"SpringApplicationName,omitempty" xml:"SpringApplicationName,omitempty"`
	// The version information.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetServiceListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceListResponseBodyData) SetDubboApplicationName(v string) *GetServiceListResponseBodyData {
	s.DubboApplicationName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetEdasAppName(v string) *GetServiceListResponseBodyData {
	s.EdasAppName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetGroup(v string) *GetServiceListResponseBodyData {
	s.Group = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetMetadata(v map[string]interface{}) *GetServiceListResponseBodyData {
	s.Metadata = v
	return s
}

func (s *GetServiceListResponseBodyData) SetMethods(v []*GetServiceListResponseBodyDataMethods) *GetServiceListResponseBodyData {
	s.Methods = v
	return s
}

func (s *GetServiceListResponseBodyData) SetRegistryType(v string) *GetServiceListResponseBodyData {
	s.RegistryType = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetServiceName(v string) *GetServiceListResponseBodyData {
	s.ServiceName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetServiceType(v string) *GetServiceListResponseBodyData {
	s.ServiceType = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetSpringApplicationName(v string) *GetServiceListResponseBodyData {
	s.SpringApplicationName = &v
	return s
}

func (s *GetServiceListResponseBodyData) SetVersion(v string) *GetServiceListResponseBodyData {
	s.Version = &v
	return s
}

type GetServiceListResponseBodyDataMethods struct {
	// The controller of the method.
	MethodController *string `json:"MethodController,omitempty" xml:"MethodController,omitempty"`
	// The name of the method.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The data types of the parameters.
	ParameterTypes []*string `json:"ParameterTypes,omitempty" xml:"ParameterTypes,omitempty" type:"Repeated"`
	// The paths.
	Paths []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The methods.
	RequestMethods []*string `json:"RequestMethods,omitempty" xml:"RequestMethods,omitempty" type:"Repeated"`
	// The type of the return value.
	ReturnType *string `json:"ReturnType,omitempty" xml:"ReturnType,omitempty"`
}

func (s GetServiceListResponseBodyDataMethods) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponseBodyDataMethods) GoString() string {
	return s.String()
}

func (s *GetServiceListResponseBodyDataMethods) SetMethodController(v string) *GetServiceListResponseBodyDataMethods {
	s.MethodController = &v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetName(v string) *GetServiceListResponseBodyDataMethods {
	s.Name = &v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetParameterTypes(v []*string) *GetServiceListResponseBodyDataMethods {
	s.ParameterTypes = v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetPaths(v []*string) *GetServiceListResponseBodyDataMethods {
	s.Paths = v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetRequestMethods(v []*string) *GetServiceListResponseBodyDataMethods {
	s.RequestMethods = v
	return s
}

func (s *GetServiceListResponseBodyDataMethods) SetReturnType(v string) *GetServiceListResponseBodyDataMethods {
	s.ReturnType = &v
	return s
}

type GetServiceListResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetServiceListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetServiceListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListResponse) GoString() string {
	return s.String()
}

func (s *GetServiceListResponse) SetHeaders(v map[string]*string) *GetServiceListResponse {
	s.Headers = v
	return s
}

func (s *GetServiceListResponse) SetStatusCode(v int32) *GetServiceListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceListResponse) SetBody(v *GetServiceListResponseBody) *GetServiceListResponse {
	s.Body = v
	return s
}

type GetServiceListenersRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the MSE instance to which the service belongs.
	//
	// > You must specify InstanceId or ClusterId.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster to which the service belongs.
	//
	// > The cluster is a concept for Nacos services and does not refer to a Microservices Engine (MSE) instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// A reserved parameter.
	HasIpCount *string `json:"HasIpCount,omitempty" xml:"HasIpCount,omitempty"`
	// The ID of the instance to which the service belongs.
	//
	// > You must specify InstanceId or ClusterId.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The namespace to which the service belongs.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service whose listeners you want to query.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s GetServiceListenersRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersRequest) GoString() string {
	return s.String()
}

func (s *GetServiceListenersRequest) SetAcceptLanguage(v string) *GetServiceListenersRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetServiceListenersRequest) SetClusterId(v string) *GetServiceListenersRequest {
	s.ClusterId = &v
	return s
}

func (s *GetServiceListenersRequest) SetClusterName(v string) *GetServiceListenersRequest {
	s.ClusterName = &v
	return s
}

func (s *GetServiceListenersRequest) SetGroupName(v string) *GetServiceListenersRequest {
	s.GroupName = &v
	return s
}

func (s *GetServiceListenersRequest) SetHasIpCount(v string) *GetServiceListenersRequest {
	s.HasIpCount = &v
	return s
}

func (s *GetServiceListenersRequest) SetInstanceId(v string) *GetServiceListenersRequest {
	s.InstanceId = &v
	return s
}

func (s *GetServiceListenersRequest) SetNamespaceId(v string) *GetServiceListenersRequest {
	s.NamespaceId = &v
	return s
}

func (s *GetServiceListenersRequest) SetPageNum(v int32) *GetServiceListenersRequest {
	s.PageNum = &v
	return s
}

func (s *GetServiceListenersRequest) SetPageSize(v int32) *GetServiceListenersRequest {
	s.PageSize = &v
	return s
}

func (s *GetServiceListenersRequest) SetRegionId(v string) *GetServiceListenersRequest {
	s.RegionId = &v
	return s
}

func (s *GetServiceListenersRequest) SetRequestPars(v string) *GetServiceListenersRequest {
	s.RequestPars = &v
	return s
}

func (s *GetServiceListenersRequest) SetServiceName(v string) *GetServiceListenersRequest {
	s.ServiceName = &v
	return s
}

type GetServiceListenersResponseBody struct {
	// The returned data.
	Data []*GetServiceListenersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of listeners that are queried.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetServiceListenersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceListenersResponseBody) SetData(v []*GetServiceListenersResponseBodyData) *GetServiceListenersResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceListenersResponseBody) SetErrorCode(v string) *GetServiceListenersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetHttpCode(v string) *GetServiceListenersResponseBody {
	s.HttpCode = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetMessage(v string) *GetServiceListenersResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetPageNumber(v int32) *GetServiceListenersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetPageSize(v int32) *GetServiceListenersResponseBody {
	s.PageSize = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetRequestId(v string) *GetServiceListenersResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetSuccess(v bool) *GetServiceListenersResponseBody {
	s.Success = &v
	return s
}

func (s *GetServiceListenersResponseBody) SetTotalCount(v int32) *GetServiceListenersResponseBody {
	s.TotalCount = &v
	return s
}

type GetServiceListenersResponseBodyData struct {
	// The address of the listener.
	Addr *string `json:"Addr,omitempty" xml:"Addr,omitempty"`
	// The listener client version.
	Agent *string `json:"Agent,omitempty" xml:"Agent,omitempty"`
	// The application name of the listener.
	App *string `json:"App,omitempty" xml:"App,omitempty"`
	// The name of the cluster to which the monitored service belongs.
	Cluster *string `json:"Cluster,omitempty" xml:"Cluster,omitempty"`
	// The IP address of the monitored service.
	IP *string `json:"IP,omitempty" xml:"IP,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port number of the monitored service.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the monitored service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s GetServiceListenersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceListenersResponseBodyData) SetAddr(v string) *GetServiceListenersResponseBodyData {
	s.Addr = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetAgent(v string) *GetServiceListenersResponseBodyData {
	s.Agent = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetApp(v string) *GetServiceListenersResponseBodyData {
	s.App = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetCluster(v string) *GetServiceListenersResponseBodyData {
	s.Cluster = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetIP(v string) *GetServiceListenersResponseBodyData {
	s.IP = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetNamespaceId(v string) *GetServiceListenersResponseBodyData {
	s.NamespaceId = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetPort(v string) *GetServiceListenersResponseBodyData {
	s.Port = &v
	return s
}

func (s *GetServiceListenersResponseBodyData) SetServiceName(v string) *GetServiceListenersResponseBodyData {
	s.ServiceName = &v
	return s
}

type GetServiceListenersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetServiceListenersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetServiceListenersResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListenersResponse) GoString() string {
	return s.String()
}

func (s *GetServiceListenersResponse) SetHeaders(v map[string]*string) *GetServiceListenersResponse {
	s.Headers = v
	return s
}

func (s *GetServiceListenersResponse) SetStatusCode(v int32) *GetServiceListenersResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceListenersResponse) SetBody(v *GetServiceListenersResponseBody) *GetServiceListenersResponse {
	s.Body = v
	return s
}

type GetTagsBySwimmingLaneGroupIdRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s GetTagsBySwimmingLaneGroupIdRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTagsBySwimmingLaneGroupIdRequest) GoString() string {
	return s.String()
}

func (s *GetTagsBySwimmingLaneGroupIdRequest) SetAcceptLanguage(v string) *GetTagsBySwimmingLaneGroupIdRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdRequest) SetGroupId(v int64) *GetTagsBySwimmingLaneGroupIdRequest {
	s.GroupId = &v
	return s
}

type GetTagsBySwimmingLaneGroupIdResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetTagsBySwimmingLaneGroupIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTagsBySwimmingLaneGroupIdResponseBody) GoString() string {
	return s.String()
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetCode(v int32) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.Code = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetData(v interface{}) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.Data = v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetDynamicMessage(v string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetErrorCode(v string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetHttpStatusCode(v int32) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetMessage(v string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.Message = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetRequestId(v string) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponseBody) SetSuccess(v bool) *GetTagsBySwimmingLaneGroupIdResponseBody {
	s.Success = &v
	return s
}

type GetTagsBySwimmingLaneGroupIdResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTagsBySwimmingLaneGroupIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTagsBySwimmingLaneGroupIdResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTagsBySwimmingLaneGroupIdResponse) GoString() string {
	return s.String()
}

func (s *GetTagsBySwimmingLaneGroupIdResponse) SetHeaders(v map[string]*string) *GetTagsBySwimmingLaneGroupIdResponse {
	s.Headers = v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponse) SetStatusCode(v int32) *GetTagsBySwimmingLaneGroupIdResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTagsBySwimmingLaneGroupIdResponse) SetBody(v *GetTagsBySwimmingLaneGroupIdResponseBody) *GetTagsBySwimmingLaneGroupIdResponse {
	s.Body = v
	return s
}

type GetZookeeperDataImportUrlRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the file.
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s GetZookeeperDataImportUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlRequest) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlRequest) SetAcceptLanguage(v string) *GetZookeeperDataImportUrlRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *GetZookeeperDataImportUrlRequest) SetContentType(v string) *GetZookeeperDataImportUrlRequest {
	s.ContentType = &v
	return s
}

func (s *GetZookeeperDataImportUrlRequest) SetInstanceId(v string) *GetZookeeperDataImportUrlRequest {
	s.InstanceId = &v
	return s
}

type GetZookeeperDataImportUrlResponseBody struct {
	// The status code. A value of 200 is returned if the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetZookeeperDataImportUrlResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetZookeeperDataImportUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlResponseBody) SetCode(v int32) *GetZookeeperDataImportUrlResponseBody {
	s.Code = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetData(v *GetZookeeperDataImportUrlResponseBodyData) *GetZookeeperDataImportUrlResponseBody {
	s.Data = v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetDynamicCode(v string) *GetZookeeperDataImportUrlResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetDynamicMessage(v string) *GetZookeeperDataImportUrlResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetErrorCode(v string) *GetZookeeperDataImportUrlResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetHttpStatusCode(v int32) *GetZookeeperDataImportUrlResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetMessage(v string) *GetZookeeperDataImportUrlResponseBody {
	s.Message = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetRequestId(v string) *GetZookeeperDataImportUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBody) SetSuccess(v bool) *GetZookeeperDataImportUrlResponseBody {
	s.Success = &v
	return s
}

type GetZookeeperDataImportUrlResponseBodyData struct {
	// The maximum size of a file that can be uploaded each time. Unit: MB.
	MaxSize *string `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The URL that is used to upload the configuration file.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetZookeeperDataImportUrlResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlResponseBodyData) SetMaxSize(v string) *GetZookeeperDataImportUrlResponseBodyData {
	s.MaxSize = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponseBodyData) SetUrl(v string) *GetZookeeperDataImportUrlResponseBodyData {
	s.Url = &v
	return s
}

type GetZookeeperDataImportUrlResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetZookeeperDataImportUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetZookeeperDataImportUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetZookeeperDataImportUrlResponse) GoString() string {
	return s.String()
}

func (s *GetZookeeperDataImportUrlResponse) SetHeaders(v map[string]*string) *GetZookeeperDataImportUrlResponse {
	s.Headers = v
	return s
}

func (s *GetZookeeperDataImportUrlResponse) SetStatusCode(v int32) *GetZookeeperDataImportUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetZookeeperDataImportUrlResponse) SetBody(v *GetZookeeperDataImportUrlResponseBody) *GetZookeeperDataImportUrlResponse {
	s.Body = v
	return s
}

type ImportNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The URL that is used to download the configuration file.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The policy.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
}

func (s ImportNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigRequest) SetAcceptLanguage(v string) *ImportNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportNacosConfigRequest) SetFileUrl(v string) *ImportNacosConfigRequest {
	s.FileUrl = &v
	return s
}

func (s *ImportNacosConfigRequest) SetInstanceId(v string) *ImportNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *ImportNacosConfigRequest) SetNamespaceId(v string) *ImportNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *ImportNacosConfigRequest) SetPolicy(v string) *ImportNacosConfigRequest {
	s.Policy = &v
	return s
}

type ImportNacosConfigResponseBody struct {
	// The code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ImportNacosConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace **%s** in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBody) SetCode(v int32) *ImportNacosConfigResponseBody {
	s.Code = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetData(v *ImportNacosConfigResponseBodyData) *ImportNacosConfigResponseBody {
	s.Data = v
	return s
}

func (s *ImportNacosConfigResponseBody) SetDynamicMessage(v string) *ImportNacosConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetErrorCode(v string) *ImportNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetHttpStatusCode(v int32) *ImportNacosConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetMessage(v string) *ImportNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetRequestId(v string) *ImportNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportNacosConfigResponseBody) SetSuccess(v bool) *ImportNacosConfigResponseBody {
	s.Success = &v
	return s
}

type ImportNacosConfigResponseBodyData struct {
	// The information about configurations that are failed to be imported.
	FailData []*ImportNacosConfigResponseBodyDataFailData `json:"FailData,omitempty" xml:"FailData,omitempty" type:"Repeated"`
	// The number of configurations that are skipped.
	SkipCount *int32 `json:"SkipCount,omitempty" xml:"SkipCount,omitempty"`
	// The information about skipped configurations.
	SkipData []*ImportNacosConfigResponseBodyDataSkipData `json:"SkipData,omitempty" xml:"SkipData,omitempty" type:"Repeated"`
	// The number of configurations that are imported.
	SuccCount *int32 `json:"SuccCount,omitempty" xml:"SuccCount,omitempty"`
}

func (s ImportNacosConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBodyData) SetFailData(v []*ImportNacosConfigResponseBodyDataFailData) *ImportNacosConfigResponseBodyData {
	s.FailData = v
	return s
}

func (s *ImportNacosConfigResponseBodyData) SetSkipCount(v int32) *ImportNacosConfigResponseBodyData {
	s.SkipCount = &v
	return s
}

func (s *ImportNacosConfigResponseBodyData) SetSkipData(v []*ImportNacosConfigResponseBodyDataSkipData) *ImportNacosConfigResponseBodyData {
	s.SkipData = v
	return s
}

func (s *ImportNacosConfigResponseBodyData) SetSuccCount(v int32) *ImportNacosConfigResponseBodyData {
	s.SuccCount = &v
	return s
}

type ImportNacosConfigResponseBodyDataFailData struct {
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s ImportNacosConfigResponseBodyDataFailData) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBodyDataFailData) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBodyDataFailData) SetDataId(v string) *ImportNacosConfigResponseBodyDataFailData {
	s.DataId = &v
	return s
}

func (s *ImportNacosConfigResponseBodyDataFailData) SetGroup(v string) *ImportNacosConfigResponseBodyDataFailData {
	s.Group = &v
	return s
}

type ImportNacosConfigResponseBodyDataSkipData struct {
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
}

func (s ImportNacosConfigResponseBodyDataSkipData) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponseBodyDataSkipData) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponseBodyDataSkipData) SetDataId(v string) *ImportNacosConfigResponseBodyDataSkipData {
	s.DataId = &v
	return s
}

func (s *ImportNacosConfigResponseBodyDataSkipData) SetGroup(v string) *ImportNacosConfigResponseBodyDataSkipData {
	s.Group = &v
	return s
}

type ImportNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *ImportNacosConfigResponse) SetHeaders(v map[string]*string) *ImportNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *ImportNacosConfigResponse) SetStatusCode(v int32) *ImportNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportNacosConfigResponse) SetBody(v *ImportNacosConfigResponseBody) *ImportNacosConfigResponse {
	s.Body = v
	return s
}

type ImportServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The information about services.
	ServiceList []*ImportServicesRequestServiceList `json:"ServiceList,omitempty" xml:"ServiceList,omitempty" type:"Repeated"`
	// The service source. Valid values:
	//
	// *   MSE: MSE Nacos instance
	// *   K8s: ACK cluster
	// *   VIP: fixed address
	// *   DNS: DNS domain
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The Transport Layer Security (TLS) settings. Valid values:
	//
	// *   mode: TLS mode
	// *   certId: certificate ID
	// *   caCertId: CA certificate ID
	// *   caCertContent: CA certificate public key
	// *   sni: service name identification
	TlsSetting *string `json:"TlsSetting,omitempty" xml:"TlsSetting,omitempty"`
}

func (s ImportServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesRequest) GoString() string {
	return s.String()
}

func (s *ImportServicesRequest) SetAcceptLanguage(v string) *ImportServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportServicesRequest) SetGatewayUniqueId(v string) *ImportServicesRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ImportServicesRequest) SetServiceList(v []*ImportServicesRequestServiceList) *ImportServicesRequest {
	s.ServiceList = v
	return s
}

func (s *ImportServicesRequest) SetSourceType(v string) *ImportServicesRequest {
	s.SourceType = &v
	return s
}

func (s *ImportServicesRequest) SetTlsSetting(v string) *ImportServicesRequest {
	s.TlsSetting = &v
	return s
}

type ImportServicesRequestServiceList struct {
	// The group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The IP addresses of the service.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The port of the service.
	ServicePort *int64 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The protocol of the service.
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
}

func (s ImportServicesRequestServiceList) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesRequestServiceList) GoString() string {
	return s.String()
}

func (s *ImportServicesRequestServiceList) SetGroupName(v string) *ImportServicesRequestServiceList {
	s.GroupName = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetIps(v []*string) *ImportServicesRequestServiceList {
	s.Ips = v
	return s
}

func (s *ImportServicesRequestServiceList) SetName(v string) *ImportServicesRequestServiceList {
	s.Name = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetNamespace(v string) *ImportServicesRequestServiceList {
	s.Namespace = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetServicePort(v int64) *ImportServicesRequestServiceList {
	s.ServicePort = &v
	return s
}

func (s *ImportServicesRequestServiceList) SetServiceProtocol(v string) *ImportServicesRequestServiceList {
	s.ServiceProtocol = &v
	return s
}

type ImportServicesShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The information about services.
	ServiceListShrink *string `json:"ServiceList,omitempty" xml:"ServiceList,omitempty"`
	// The service source. Valid values:
	//
	// *   MSE: MSE Nacos instance
	// *   K8s: ACK cluster
	// *   VIP: fixed address
	// *   DNS: DNS domain
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The Transport Layer Security (TLS) settings. Valid values:
	//
	// *   mode: TLS mode
	// *   certId: certificate ID
	// *   caCertId: CA certificate ID
	// *   caCertContent: CA certificate public key
	// *   sni: service name identification
	TlsSetting *string `json:"TlsSetting,omitempty" xml:"TlsSetting,omitempty"`
}

func (s ImportServicesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesShrinkRequest) GoString() string {
	return s.String()
}

func (s *ImportServicesShrinkRequest) SetAcceptLanguage(v string) *ImportServicesShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetGatewayUniqueId(v string) *ImportServicesShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetServiceListShrink(v string) *ImportServicesShrinkRequest {
	s.ServiceListShrink = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetSourceType(v string) *ImportServicesShrinkRequest {
	s.SourceType = &v
	return s
}

func (s *ImportServicesShrinkRequest) SetTlsSetting(v string) *ImportServicesShrinkRequest {
	s.TlsSetting = &v
	return s
}

type ImportServicesResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ImportServicesResponseBody) SetCode(v int32) *ImportServicesResponseBody {
	s.Code = &v
	return s
}

func (s *ImportServicesResponseBody) SetData(v bool) *ImportServicesResponseBody {
	s.Data = &v
	return s
}

func (s *ImportServicesResponseBody) SetHttpStatusCode(v int32) *ImportServicesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ImportServicesResponseBody) SetMessage(v string) *ImportServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ImportServicesResponseBody) SetRequestId(v string) *ImportServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportServicesResponseBody) SetSuccess(v bool) *ImportServicesResponseBody {
	s.Success = &v
	return s
}

type ImportServicesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportServicesResponse) GoString() string {
	return s.String()
}

func (s *ImportServicesResponse) SetHeaders(v map[string]*string) *ImportServicesResponse {
	s.Headers = v
	return s
}

func (s *ImportServicesResponse) SetStatusCode(v int32) *ImportServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportServicesResponse) SetBody(v *ImportServicesResponseBody) *ImportServicesResponse {
	s.Body = v
	return s
}

type ImportZookeeperDataRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the file that you want to import.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The URL of the source data.
	//
	// > You must use the URL that is generated by calling the GetZookeeperDataImportUrl operation.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region where the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ImportZookeeperDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportZookeeperDataRequest) GoString() string {
	return s.String()
}

func (s *ImportZookeeperDataRequest) SetAcceptLanguage(v string) *ImportZookeeperDataRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetFileName(v string) *ImportZookeeperDataRequest {
	s.FileName = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetFileUrl(v string) *ImportZookeeperDataRequest {
	s.FileUrl = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetInstanceId(v string) *ImportZookeeperDataRequest {
	s.InstanceId = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetRegionId(v string) *ImportZookeeperDataRequest {
	s.RegionId = &v
	return s
}

func (s *ImportZookeeperDataRequest) SetRequestPars(v string) *ImportZookeeperDataRequest {
	s.RequestPars = &v
	return s
}

type ImportZookeeperDataResponseBody struct {
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportZookeeperDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportZookeeperDataResponseBody) GoString() string {
	return s.String()
}

func (s *ImportZookeeperDataResponseBody) SetData(v interface{}) *ImportZookeeperDataResponseBody {
	s.Data = v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetErrorCode(v string) *ImportZookeeperDataResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetHttpCode(v string) *ImportZookeeperDataResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetMessage(v string) *ImportZookeeperDataResponseBody {
	s.Message = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetRequestId(v string) *ImportZookeeperDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportZookeeperDataResponseBody) SetSuccess(v bool) *ImportZookeeperDataResponseBody {
	s.Success = &v
	return s
}

type ImportZookeeperDataResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportZookeeperDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportZookeeperDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportZookeeperDataResponse) GoString() string {
	return s.String()
}

func (s *ImportZookeeperDataResponse) SetHeaders(v map[string]*string) *ImportZookeeperDataResponse {
	s.Headers = v
	return s
}

func (s *ImportZookeeperDataResponse) SetStatusCode(v int32) *ImportZookeeperDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportZookeeperDataResponse) SetBody(v *ImportZookeeperDataResponseBody) *ImportZookeeperDataResponse {
	s.Body = v
	return s
}

type ListAnsInstancesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The alias of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The name of the contact group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	//
	// >  This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListAnsInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesRequest) SetAcceptLanguage(v string) *ListAnsInstancesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAnsInstancesRequest) SetClusterId(v string) *ListAnsInstancesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListAnsInstancesRequest) SetClusterName(v string) *ListAnsInstancesRequest {
	s.ClusterName = &v
	return s
}

func (s *ListAnsInstancesRequest) SetGroupName(v string) *ListAnsInstancesRequest {
	s.GroupName = &v
	return s
}

func (s *ListAnsInstancesRequest) SetInstanceId(v string) *ListAnsInstancesRequest {
	s.InstanceId = &v
	return s
}

func (s *ListAnsInstancesRequest) SetNamespaceId(v string) *ListAnsInstancesRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListAnsInstancesRequest) SetPageNum(v int32) *ListAnsInstancesRequest {
	s.PageNum = &v
	return s
}

func (s *ListAnsInstancesRequest) SetPageSize(v int32) *ListAnsInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *ListAnsInstancesRequest) SetRequestPars(v string) *ListAnsInstancesRequest {
	s.RequestPars = &v
	return s
}

func (s *ListAnsInstancesRequest) SetServiceName(v string) *ListAnsInstancesRequest {
	s.ServiceName = &v
	return s
}

type ListAnsInstancesResponseBody struct {
	// The details of the data.
	Data []*ListAnsInstancesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAnsInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesResponseBody) SetData(v []*ListAnsInstancesResponseBodyData) *ListAnsInstancesResponseBody {
	s.Data = v
	return s
}

func (s *ListAnsInstancesResponseBody) SetErrorCode(v string) *ListAnsInstancesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetHttpCode(v string) *ListAnsInstancesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetMessage(v string) *ListAnsInstancesResponseBody {
	s.Message = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetPageNumber(v int32) *ListAnsInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetPageSize(v int32) *ListAnsInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetRequestId(v string) *ListAnsInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetSuccess(v bool) *ListAnsInstancesResponseBody {
	s.Success = &v
	return s
}

func (s *ListAnsInstancesResponseBody) SetTotalCount(v int32) *ListAnsInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type ListAnsInstancesResponseBodyData struct {
	// The name of the application.
	App *string `json:"App,omitempty" xml:"App,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The reference key.
	DatumKey *string `json:"DatumKey,omitempty" xml:"DatumKey,omitempty"`
	// The default key.
	DefaultKey *string `json:"DefaultKey,omitempty" xml:"DefaultKey,omitempty"`
	// The effective status of the instance. Valid values:
	//
	// *   `true`: The instance takes effect.
	// *   `false`: The instance does not take effect.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether the information about the temporary node is obtained. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The number of failed checks.
	FailCount *int32 `json:"FailCount,omitempty" xml:"FailCount,omitempty"`
	// The health status of the instance. Valid values:
	//
	// *   `true`: The instance is healthy.
	// *   `false`: The instance is unhealthy.
	Healthy *bool `json:"Healthy,omitempty" xml:"Healthy,omitempty"`
	// The heartbeat interval of the instance. Unit: seconds.
	InstanceHeartBeatInterval *int32 `json:"InstanceHeartBeatInterval,omitempty" xml:"InstanceHeartBeatInterval,omitempty"`
	// The timeout period of the instance heartbeat.
	InstanceHeartBeatTimeOut *int32 `json:"InstanceHeartBeatTimeOut,omitempty" xml:"InstanceHeartBeatTimeOut,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The public IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The timeout period for removing an IP address.
	IpDeleteTimeout *int32 `json:"IpDeleteTimeout,omitempty" xml:"IpDeleteTimeout,omitempty"`
	// The last heartbeat time.
	LastBeat *int64 `json:"LastBeat,omitempty" xml:"LastBeat,omitempty"`
	// Indicates whether the instance was marked. Valid values:
	//
	// *   `true`: The instance marking was successful.
	// *   `false`: The instance marking failed.
	Marked *bool `json:"Marked,omitempty" xml:"Marked,omitempty"`
	// The metadata.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The number of successful checks.
	OkCount *int32 `json:"OkCount,omitempty" xml:"OkCount,omitempty"`
	// The port number.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The weight.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ListAnsInstancesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesResponseBodyData) SetApp(v string) *ListAnsInstancesResponseBodyData {
	s.App = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetClusterName(v string) *ListAnsInstancesResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetDatumKey(v string) *ListAnsInstancesResponseBodyData {
	s.DatumKey = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetDefaultKey(v string) *ListAnsInstancesResponseBodyData {
	s.DefaultKey = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetEnabled(v bool) *ListAnsInstancesResponseBodyData {
	s.Enabled = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetEphemeral(v bool) *ListAnsInstancesResponseBodyData {
	s.Ephemeral = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetFailCount(v int32) *ListAnsInstancesResponseBodyData {
	s.FailCount = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetHealthy(v bool) *ListAnsInstancesResponseBodyData {
	s.Healthy = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetInstanceHeartBeatInterval(v int32) *ListAnsInstancesResponseBodyData {
	s.InstanceHeartBeatInterval = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetInstanceHeartBeatTimeOut(v int32) *ListAnsInstancesResponseBodyData {
	s.InstanceHeartBeatTimeOut = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetInstanceId(v string) *ListAnsInstancesResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetIp(v string) *ListAnsInstancesResponseBodyData {
	s.Ip = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetIpDeleteTimeout(v int32) *ListAnsInstancesResponseBodyData {
	s.IpDeleteTimeout = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetLastBeat(v int64) *ListAnsInstancesResponseBodyData {
	s.LastBeat = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetMarked(v bool) *ListAnsInstancesResponseBodyData {
	s.Marked = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetMetadata(v map[string]interface{}) *ListAnsInstancesResponseBodyData {
	s.Metadata = v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetOkCount(v int32) *ListAnsInstancesResponseBodyData {
	s.OkCount = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetPort(v int32) *ListAnsInstancesResponseBodyData {
	s.Port = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetServiceName(v string) *ListAnsInstancesResponseBodyData {
	s.ServiceName = &v
	return s
}

func (s *ListAnsInstancesResponseBodyData) SetWeight(v int32) *ListAnsInstancesResponseBodyData {
	s.Weight = &v
	return s
}

type ListAnsInstancesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAnsInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAnsInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnsInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListAnsInstancesResponse) SetHeaders(v map[string]*string) *ListAnsInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListAnsInstancesResponse) SetStatusCode(v int32) *ListAnsInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnsInstancesResponse) SetBody(v *ListAnsInstancesResponseBody) *ListAnsInstancesResponse {
	s.Body = v
	return s
}

type ListAnsServiceClustersRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the MSE cluster.
	//
	// > The MSE cluster is different from the cluster of the Nacos service.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The alias of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListAnsServiceClustersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersRequest) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersRequest) SetAcceptLanguage(v string) *ListAnsServiceClustersRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetClusterId(v string) *ListAnsServiceClustersRequest {
	s.ClusterId = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetClusterName(v string) *ListAnsServiceClustersRequest {
	s.ClusterName = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetGroupName(v string) *ListAnsServiceClustersRequest {
	s.GroupName = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetInstanceId(v string) *ListAnsServiceClustersRequest {
	s.InstanceId = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetNamespaceId(v string) *ListAnsServiceClustersRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetPageNum(v int32) *ListAnsServiceClustersRequest {
	s.PageNum = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetPageSize(v int32) *ListAnsServiceClustersRequest {
	s.PageSize = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetRequestPars(v string) *ListAnsServiceClustersRequest {
	s.RequestPars = &v
	return s
}

func (s *ListAnsServiceClustersRequest) SetServiceName(v string) *ListAnsServiceClustersRequest {
	s.ServiceName = &v
	return s
}

type ListAnsServiceClustersResponseBody struct {
	// The details of the data.
	Data *ListAnsServiceClustersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAnsServiceClustersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponseBody) SetData(v *ListAnsServiceClustersResponseBodyData) *ListAnsServiceClustersResponseBody {
	s.Data = v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetErrorCode(v string) *ListAnsServiceClustersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetMessage(v string) *ListAnsServiceClustersResponseBody {
	s.Message = &v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetRequestId(v string) *ListAnsServiceClustersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAnsServiceClustersResponseBody) SetSuccess(v bool) *ListAnsServiceClustersResponseBody {
	s.Success = &v
	return s
}

type ListAnsServiceClustersResponseBodyData struct {
	// The information about the clusters.
	Clusters []*ListAnsServiceClustersResponseBodyDataClusters `json:"Clusters,omitempty" xml:"Clusters,omitempty" type:"Repeated"`
	// Indicates whether the service is a temporary service. Valid values:
	//
	// *   `true`: The service is a temporary service.
	// *   `false`: The service is not a temporary service.
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the contact group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The metadata of the service.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protection threshold.
	ProtectThreshold *float32 `json:"ProtectThreshold,omitempty" xml:"ProtectThreshold,omitempty"`
	// The election mode.
	SelectorType *string `json:"SelectorType,omitempty" xml:"SelectorType,omitempty"`
}

func (s ListAnsServiceClustersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponseBodyData) SetClusters(v []*ListAnsServiceClustersResponseBodyDataClusters) *ListAnsServiceClustersResponseBodyData {
	s.Clusters = v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetEphemeral(v bool) *ListAnsServiceClustersResponseBodyData {
	s.Ephemeral = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetGroupName(v string) *ListAnsServiceClustersResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetMetadata(v map[string]interface{}) *ListAnsServiceClustersResponseBodyData {
	s.Metadata = v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetName(v string) *ListAnsServiceClustersResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetProtectThreshold(v float32) *ListAnsServiceClustersResponseBodyData {
	s.ProtectThreshold = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyData) SetSelectorType(v string) *ListAnsServiceClustersResponseBodyData {
	s.SelectorType = &v
	return s
}

type ListAnsServiceClustersResponseBodyDataClusters struct {
	// The default port used for a health check.
	DefaultCheckPort *int32 `json:"DefaultCheckPort,omitempty" xml:"DefaultCheckPort,omitempty"`
	// The default port.
	DefaultPort *int32 `json:"DefaultPort,omitempty" xml:"DefaultPort,omitempty"`
	// The type of health checks.
	HealthCheckerType *string `json:"HealthCheckerType,omitempty" xml:"HealthCheckerType,omitempty"`
	// The metadata of the cluster.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The name of the cluster.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The complete name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// Indicates whether the health check is initiated by the server. This parameter is valid only when the service is a temporary service.
	UseIPPort4Check *bool `json:"UseIPPort4Check,omitempty" xml:"UseIPPort4Check,omitempty"`
}

func (s ListAnsServiceClustersResponseBodyDataClusters) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponseBodyDataClusters) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetDefaultCheckPort(v int32) *ListAnsServiceClustersResponseBodyDataClusters {
	s.DefaultCheckPort = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetDefaultPort(v int32) *ListAnsServiceClustersResponseBodyDataClusters {
	s.DefaultPort = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetHealthCheckerType(v string) *ListAnsServiceClustersResponseBodyDataClusters {
	s.HealthCheckerType = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetMetadata(v map[string]interface{}) *ListAnsServiceClustersResponseBodyDataClusters {
	s.Metadata = v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetName(v string) *ListAnsServiceClustersResponseBodyDataClusters {
	s.Name = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetServiceName(v string) *ListAnsServiceClustersResponseBodyDataClusters {
	s.ServiceName = &v
	return s
}

func (s *ListAnsServiceClustersResponseBodyDataClusters) SetUseIPPort4Check(v bool) *ListAnsServiceClustersResponseBodyDataClusters {
	s.UseIPPort4Check = &v
	return s
}

type ListAnsServiceClustersResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAnsServiceClustersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAnsServiceClustersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServiceClustersResponse) GoString() string {
	return s.String()
}

func (s *ListAnsServiceClustersResponse) SetHeaders(v map[string]*string) *ListAnsServiceClustersResponse {
	s.Headers = v
	return s
}

func (s *ListAnsServiceClustersResponse) SetStatusCode(v int32) *ListAnsServiceClustersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnsServiceClustersResponse) SetBody(v *ListAnsServiceClustersResponseBody) *ListAnsServiceClustersResponse {
	s.Body = v
	return s
}

type ListAnsServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the contact group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// Specifies whether to query the number of instances that are used for the service.
	HasIpCount *string `json:"HasIpCount,omitempty" xml:"HasIpCount,omitempty"`
	// The ID of the instance.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListAnsServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesRequest) GoString() string {
	return s.String()
}

func (s *ListAnsServicesRequest) SetAcceptLanguage(v string) *ListAnsServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAnsServicesRequest) SetClusterId(v string) *ListAnsServicesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListAnsServicesRequest) SetGroupName(v string) *ListAnsServicesRequest {
	s.GroupName = &v
	return s
}

func (s *ListAnsServicesRequest) SetHasIpCount(v string) *ListAnsServicesRequest {
	s.HasIpCount = &v
	return s
}

func (s *ListAnsServicesRequest) SetInstanceId(v string) *ListAnsServicesRequest {
	s.InstanceId = &v
	return s
}

func (s *ListAnsServicesRequest) SetNamespaceId(v string) *ListAnsServicesRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListAnsServicesRequest) SetPageNum(v int32) *ListAnsServicesRequest {
	s.PageNum = &v
	return s
}

func (s *ListAnsServicesRequest) SetPageSize(v int32) *ListAnsServicesRequest {
	s.PageSize = &v
	return s
}

func (s *ListAnsServicesRequest) SetRequestPars(v string) *ListAnsServicesRequest {
	s.RequestPars = &v
	return s
}

func (s *ListAnsServicesRequest) SetServiceName(v string) *ListAnsServicesRequest {
	s.ServiceName = &v
	return s
}

type ListAnsServicesResponseBody struct {
	// The details of the data.
	Data []*ListAnsServicesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAnsServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnsServicesResponseBody) SetData(v []*ListAnsServicesResponseBodyData) *ListAnsServicesResponseBody {
	s.Data = v
	return s
}

func (s *ListAnsServicesResponseBody) SetErrorCode(v string) *ListAnsServicesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetHttpCode(v string) *ListAnsServicesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetMessage(v string) *ListAnsServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetPageNumber(v int32) *ListAnsServicesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetPageSize(v int32) *ListAnsServicesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetRequestId(v string) *ListAnsServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetSuccess(v bool) *ListAnsServicesResponseBody {
	s.Success = &v
	return s
}

func (s *ListAnsServicesResponseBody) SetTotalCount(v int32) *ListAnsServicesResponseBody {
	s.TotalCount = &v
	return s
}

type ListAnsServicesResponseBodyData struct {
	// The total number of clusters.
	ClusterCount *int32 `json:"ClusterCount,omitempty" xml:"ClusterCount,omitempty"`
	// The name of the contact group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The total number of instances with healthy heartbeats.
	HealthyInstanceCount *int32 `json:"HealthyInstanceCount,omitempty" xml:"HealthyInstanceCount,omitempty"`
	// The total number of instances that are used for the current service.
	IpCount *int32 `json:"IpCount,omitempty" xml:"IpCount,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListAnsServicesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAnsServicesResponseBodyData) SetClusterCount(v int32) *ListAnsServicesResponseBodyData {
	s.ClusterCount = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetGroupName(v string) *ListAnsServicesResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetHealthyInstanceCount(v int32) *ListAnsServicesResponseBodyData {
	s.HealthyInstanceCount = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetIpCount(v int32) *ListAnsServicesResponseBodyData {
	s.IpCount = &v
	return s
}

func (s *ListAnsServicesResponseBodyData) SetName(v string) *ListAnsServicesResponseBodyData {
	s.Name = &v
	return s
}

type ListAnsServicesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAnsServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAnsServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnsServicesResponse) GoString() string {
	return s.String()
}

func (s *ListAnsServicesResponse) SetHeaders(v map[string]*string) *ListAnsServicesResponse {
	s.Headers = v
	return s
}

func (s *ListAnsServicesResponse) SetStatusCode(v int32) *ListAnsServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnsServicesResponse) SetBody(v *ListAnsServicesResponseBody) *ListAnsServicesResponse {
	s.Body = v
	return s
}

type ListAppBySwimmingLaneGroupTagRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ListAppBySwimmingLaneGroupTagRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagRequest) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagRequest) SetAcceptLanguage(v string) *ListAppBySwimmingLaneGroupTagRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagRequest) SetGroupId(v int64) *ListAppBySwimmingLaneGroupTagRequest {
	s.GroupId = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagRequest) SetTag(v string) *ListAppBySwimmingLaneGroupTagRequest {
	s.Tag = &v
	return s
}

type ListAppBySwimmingLaneGroupTagResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAppBySwimmingLaneGroupTagResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagResponseBody) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetCode(v int32) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.Code = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetData(v interface{}) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.Data = v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetDynamicMessage(v string) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetErrorCode(v string) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetHttpStatusCode(v int32) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetMessage(v string) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.Message = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetRequestId(v string) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponseBody) SetSuccess(v bool) *ListAppBySwimmingLaneGroupTagResponseBody {
	s.Success = &v
	return s
}

type ListAppBySwimmingLaneGroupTagResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAppBySwimmingLaneGroupTagResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAppBySwimmingLaneGroupTagResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppBySwimmingLaneGroupTagResponse) GoString() string {
	return s.String()
}

func (s *ListAppBySwimmingLaneGroupTagResponse) SetHeaders(v map[string]*string) *ListAppBySwimmingLaneGroupTagResponse {
	s.Headers = v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponse) SetStatusCode(v int32) *ListAppBySwimmingLaneGroupTagResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAppBySwimmingLaneGroupTagResponse) SetBody(v *ListAppBySwimmingLaneGroupTagResponseBody) *ListAppBySwimmingLaneGroupTagResponse {
	s.Body = v
	return s
}

type ListApplicationsWithTagRulesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The source of the routing rule. Default value: edasmsc.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ListApplicationsWithTagRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesRequest) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesRequest) SetAcceptLanguage(v string) *ListApplicationsWithTagRulesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetAppId(v string) *ListApplicationsWithTagRulesRequest {
	s.AppId = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetAppName(v string) *ListApplicationsWithTagRulesRequest {
	s.AppName = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetPageNumber(v int32) *ListApplicationsWithTagRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetPageSize(v int32) *ListApplicationsWithTagRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetRegion(v string) *ListApplicationsWithTagRulesRequest {
	s.Region = &v
	return s
}

func (s *ListApplicationsWithTagRulesRequest) SetSource(v string) *ListApplicationsWithTagRulesRequest {
	s.Source = &v
	return s
}

type ListApplicationsWithTagRulesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ListApplicationsWithTagRulesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The returned message.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBody) SetCode(v int32) *ListApplicationsWithTagRulesResponseBody {
	s.Code = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetData(v *ListApplicationsWithTagRulesResponseBodyData) *ListApplicationsWithTagRulesResponseBody {
	s.Data = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetHttpStatusCode(v int32) *ListApplicationsWithTagRulesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetMessage(v string) *ListApplicationsWithTagRulesResponseBody {
	s.Message = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetRequestId(v string) *ListApplicationsWithTagRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBody) SetSuccess(v bool) *ListApplicationsWithTagRulesResponseBody {
	s.Success = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data structure.
	Result []*ListApplicationsWithTagRulesResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetPageNumber(v int32) *ListApplicationsWithTagRulesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetPageSize(v int32) *ListApplicationsWithTagRulesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetResult(v []*ListApplicationsWithTagRulesResponseBodyDataResult) *ListApplicationsWithTagRulesResponseBodyData {
	s.Result = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyData) SetTotalSize(v int32) *ListApplicationsWithTagRulesResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResult struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The information about the rules.
	RouteRules []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRules `json:"RouteRules,omitempty" xml:"RouteRules,omitempty" type:"Repeated"`
	// The status of the route. Valid values: -0: disabled. -1: enabled.
	RouteStatus *int64 `json:"RouteStatus,omitempty" xml:"RouteStatus,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetAppId(v string) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.AppId = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetAppName(v string) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.AppName = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetRouteRules(v []*ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.RouteRules = v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResult) SetRouteStatus(v int64) *ListApplicationsWithTagRulesResponseBodyDataResult {
	s.RouteStatus = &v
	return s
}

type ListApplicationsWithTagRulesResponseBodyDataResultRouteRules struct {
	// Indicates whether the field is a primary key.
	CarryData *bool `json:"CarryData,omitempty" xml:"CarryData,omitempty"`
	// Indicates whether the alert rule is enabled. Valid value:
	//
	// *   `true`: enabled.
	// *   `false`: disabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The number of instances.
	InstanceNum *int32 `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The rate.
	Rate *int32 `json:"Rate,omitempty" xml:"Rate,omitempty"`
	// Indicates whether the routing rule is deleted.
	Remove *bool `json:"Remove,omitempty" xml:"Remove,omitempty"`
	// The details of the routing rule.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetCarryData(v bool) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.CarryData = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetEnable(v bool) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Enable = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetGmtModified(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.GmtModified = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetId(v int64) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Id = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetInstanceNum(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.InstanceNum = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetName(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Name = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetRate(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Rate = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetRemove(v bool) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Remove = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetRules(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Rules = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetStatus(v int32) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Status = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules) SetTag(v string) *ListApplicationsWithTagRulesResponseBodyDataResultRouteRules {
	s.Tag = &v
	return s
}

type ListApplicationsWithTagRulesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListApplicationsWithTagRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListApplicationsWithTagRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationsWithTagRulesResponse) GoString() string {
	return s.String()
}

func (s *ListApplicationsWithTagRulesResponse) SetHeaders(v map[string]*string) *ListApplicationsWithTagRulesResponse {
	s.Headers = v
	return s
}

func (s *ListApplicationsWithTagRulesResponse) SetStatusCode(v int32) *ListApplicationsWithTagRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListApplicationsWithTagRulesResponse) SetBody(v *ListApplicationsWithTagRulesResponseBody) *ListApplicationsWithTagRulesResponse {
	s.Body = v
	return s
}

type ListClusterConnectionTypesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s ListClusterConnectionTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesRequest) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesRequest) SetAcceptLanguage(v string) *ListClusterConnectionTypesRequest {
	s.AcceptLanguage = &v
	return s
}

type ListClusterConnectionTypesResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*ListClusterConnectionTypesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message. This parameter is used to replace the **%s** variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterConnectionTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesResponseBody) SetCode(v int32) *ListClusterConnectionTypesResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetData(v []*ListClusterConnectionTypesResponseBodyData) *ListClusterConnectionTypesResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetDynamicMessage(v string) *ListClusterConnectionTypesResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetErrorCode(v string) *ListClusterConnectionTypesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetHttpStatusCode(v int32) *ListClusterConnectionTypesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetMessage(v string) *ListClusterConnectionTypesResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetRequestId(v string) *ListClusterConnectionTypesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterConnectionTypesResponseBody) SetSuccess(v bool) *ListClusterConnectionTypesResponseBody {
	s.Success = &v
	return s
}

type ListClusterConnectionTypesResponseBodyData struct {
	// The connection type.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
}

func (s ListClusterConnectionTypesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesResponseBodyData) SetShowName(v string) *ListClusterConnectionTypesResponseBodyData {
	s.ShowName = &v
	return s
}

type ListClusterConnectionTypesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterConnectionTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterConnectionTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterConnectionTypesResponse) GoString() string {
	return s.String()
}

func (s *ListClusterConnectionTypesResponse) SetHeaders(v map[string]*string) *ListClusterConnectionTypesResponse {
	s.Headers = v
	return s
}

func (s *ListClusterConnectionTypesResponse) SetStatusCode(v int32) *ListClusterConnectionTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterConnectionTypesResponse) SetBody(v *ListClusterConnectionTypesResponseBody) *ListClusterConnectionTypesResponse {
	s.Body = v
	return s
}

type ListClusterHealthCheckTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region in which the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListClusterHealthCheckTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskRequest) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskRequest) SetAcceptLanguage(v string) *ListClusterHealthCheckTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetInstanceId(v string) *ListClusterHealthCheckTaskRequest {
	s.InstanceId = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetPageNum(v int32) *ListClusterHealthCheckTaskRequest {
	s.PageNum = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetPageSize(v int32) *ListClusterHealthCheckTaskRequest {
	s.PageSize = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetRegionId(v string) *ListClusterHealthCheckTaskRequest {
	s.RegionId = &v
	return s
}

func (s *ListClusterHealthCheckTaskRequest) SetRequestPars(v string) *ListClusterHealthCheckTaskRequest {
	s.RequestPars = &v
	return s
}

type ListClusterHealthCheckTaskResponseBody struct {
	// The status code. A value of 200 is returned if the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *ListClusterHealthCheckTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed. Take note of the following rules:
	//
	// *   The **ErrorCode** parameter is not returned if the request succeeds.
	// *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section in this topic.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBody) SetCode(v int32) *ListClusterHealthCheckTaskResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetData(v *ListClusterHealthCheckTaskResponseBodyData) *ListClusterHealthCheckTaskResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetDynamicCode(v string) *ListClusterHealthCheckTaskResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetDynamicMessage(v string) *ListClusterHealthCheckTaskResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetErrorCode(v string) *ListClusterHealthCheckTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetHttpStatusCode(v int32) *ListClusterHealthCheckTaskResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetMessage(v string) *ListClusterHealthCheckTaskResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetRequestId(v string) *ListClusterHealthCheckTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBody) SetSuccess(v bool) *ListClusterHealthCheckTaskResponseBody {
	s.Success = &v
	return s
}

type ListClusterHealthCheckTaskResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The list of health check tasks.
	Result []*ListClusterHealthCheckTaskResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of returned entries.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetPageNumber(v int32) *ListClusterHealthCheckTaskResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetPageSize(v int32) *ListClusterHealthCheckTaskResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetResult(v []*ListClusterHealthCheckTaskResponseBodyDataResult) *ListClusterHealthCheckTaskResponseBodyData {
	s.Result = v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyData) SetTotalSize(v int32) *ListClusterHealthCheckTaskResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListClusterHealthCheckTaskResponseBodyDataResult struct {
	// The complete version number.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The type of the instance.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The time when the task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// A redundant parameter.
	ImageVersion *string `json:"ImageVersion,omitempty" xml:"ImageVersion,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the user to which the instance belongs.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The number of nodes in the instance.
	Replica *string `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The list of risk items.
	RiskList []*ListClusterHealthCheckTaskResponseBodyDataResultRiskList `json:"RiskList,omitempty" xml:"RiskList,omitempty" type:"Repeated"`
	// The total score.
	Score *int32 `json:"Score,omitempty" xml:"Score,omitempty"`
	// The specifications.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the task.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total number of check items.
	TotalItem *int32 `json:"TotalItem,omitempty" xml:"TotalItem,omitempty"`
	// The total number of risk items.
	TotalRisk *int32 `json:"TotalRisk,omitempty" xml:"TotalRisk,omitempty"`
	// A redundant parameter.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time of the last modification.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The version number.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetAppVersion(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.AppVersion = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetChargeType(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.ChargeType = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetClusterType(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.ClusterType = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetCreateTime(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.CreateTime = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetId(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetImageVersion(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.ImageVersion = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetInstanceId(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.InstanceId = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetPrimaryUser(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.PrimaryUser = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetReplica(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Replica = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetRiskList(v []*ListClusterHealthCheckTaskResponseBodyDataResultRiskList) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.RiskList = v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetScore(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Score = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetSpec(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Spec = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetStatus(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetTotalItem(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.TotalItem = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetTotalRisk(v int32) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.TotalRisk = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetType(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.Type = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetUpdateTime(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.UpdateTime = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResult) SetVersionCode(v string) *ListClusterHealthCheckTaskResponseBodyDataResult {
	s.VersionCode = &v
	return s
}

type ListClusterHealthCheckTaskResponseBodyDataResultRiskList struct {
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// A redundant parameter.
	Module *string `json:"Module,omitempty" xml:"Module,omitempty"`
	// Indicates whether the risk item notification feature is disabled.
	//
	// *   true: disabled
	// *   false: enabled
	Mute *bool `json:"Mute,omitempty" xml:"Mute,omitempty"`
	// A redundant parameter.
	NoticeFeature *bool `json:"NoticeFeature,omitempty" xml:"NoticeFeature,omitempty"`
	// The ID of the user to which the instance belongs.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The risk code.
	RiskCode *string `json:"RiskCode,omitempty" xml:"RiskCode,omitempty"`
	// The severity of the risk. Valid values:
	//
	// *   HIGH: high risk
	// *   MID: medium risk
	// *   LOW: low risk
	RiskLevel *string `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The name of the risk.
	RiskName *string `json:"RiskName,omitempty" xml:"RiskName,omitempty"`
	// The type of the risk.
	RiskType *string `json:"RiskType,omitempty" xml:"RiskType,omitempty"`
	// The situation.
	Situation *string `json:"Situation,omitempty" xml:"Situation,omitempty"`
	// The suggestion.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The ID of the associated parent task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// A redundant parameter.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
	// A redundant parameter.
	Values *string `json:"Values,omitempty" xml:"Values,omitempty"`
}

func (s ListClusterHealthCheckTaskResponseBodyDataResultRiskList) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponseBodyDataResultRiskList) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetDescription(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Description = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetId(v int32) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Id = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetModule(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Module = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetMute(v bool) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Mute = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetNoticeFeature(v bool) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.NoticeFeature = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetPrimaryUser(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.PrimaryUser = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskCode(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskLevel(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskLevel = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskName(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskName = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetRiskType(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.RiskType = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetSituation(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Situation = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetSuggestion(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Suggestion = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetTaskId(v int64) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.TaskId = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetType(v int32) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Type = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponseBodyDataResultRiskList) SetValues(v string) *ListClusterHealthCheckTaskResponseBodyDataResultRiskList {
	s.Values = &v
	return s
}

type ListClusterHealthCheckTaskResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterHealthCheckTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterHealthCheckTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterHealthCheckTaskResponse) GoString() string {
	return s.String()
}

func (s *ListClusterHealthCheckTaskResponse) SetHeaders(v map[string]*string) *ListClusterHealthCheckTaskResponse {
	s.Headers = v
	return s
}

func (s *ListClusterHealthCheckTaskResponse) SetStatusCode(v int32) *ListClusterHealthCheckTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterHealthCheckTaskResponse) SetBody(v *ListClusterHealthCheckTaskResponseBody) *ListClusterHealthCheckTaskResponse {
	s.Body = v
	return s
}

type ListClusterTypesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The network type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectType *string `json:"ConnectType,omitempty" xml:"ConnectType,omitempty"`
	// The edition of the MSE instance that you want to purchase.
	//
	// *   mse_pro: Professional Edition
	// *   mse_dev: Developer Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListClusterTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesRequest) GoString() string {
	return s.String()
}

func (s *ListClusterTypesRequest) SetAcceptLanguage(v string) *ListClusterTypesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClusterTypesRequest) SetConnectType(v string) *ListClusterTypesRequest {
	s.ConnectType = &v
	return s
}

func (s *ListClusterTypesRequest) SetMseVersion(v string) *ListClusterTypesRequest {
	s.MseVersion = &v
	return s
}

func (s *ListClusterTypesRequest) SetRegionId(v string) *ListClusterTypesRequest {
	s.RegionId = &v
	return s
}

type ListClusterTypesResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*ListClusterTypesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterTypesResponseBody) SetCode(v int32) *ListClusterTypesResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetData(v []*ListClusterTypesResponseBodyData) *ListClusterTypesResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterTypesResponseBody) SetDynamicMessage(v string) *ListClusterTypesResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetErrorCode(v string) *ListClusterTypesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetHttpStatusCode(v int32) *ListClusterTypesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetMessage(v string) *ListClusterTypesResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetRequestId(v string) *ListClusterTypesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterTypesResponseBody) SetSuccess(v bool) *ListClusterTypesResponseBody {
	s.Success = &v
	return s
}

type ListClusterTypesResponseBodyData struct {
	// The type of the MSE engine that can be activated.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
}

func (s ListClusterTypesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterTypesResponseBodyData) SetShowName(v string) *ListClusterTypesResponseBodyData {
	s.ShowName = &v
	return s
}

type ListClusterTypesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterTypesResponse) GoString() string {
	return s.String()
}

func (s *ListClusterTypesResponse) SetHeaders(v map[string]*string) *ListClusterTypesResponse {
	s.Headers = v
	return s
}

func (s *ListClusterTypesResponse) SetStatusCode(v int32) *ListClusterTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterTypesResponse) SetBody(v *ListClusterTypesResponseBody) *ListClusterTypesResponse {
	s.Body = v
	return s
}

type ListClusterVersionsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// Valid values:
	//
	// *   `mse_dev`: Developer Edition.
	// *   `mse_pro`: Professional Edition. This is the default value.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
}

func (s ListClusterVersionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsRequest) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsRequest) SetAcceptLanguage(v string) *ListClusterVersionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClusterVersionsRequest) SetClusterType(v string) *ListClusterVersionsRequest {
	s.ClusterType = &v
	return s
}

func (s *ListClusterVersionsRequest) SetMseVersion(v string) *ListClusterVersionsRequest {
	s.MseVersion = &v
	return s
}

type ListClusterVersionsResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*ListClusterVersionsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListClusterVersionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsResponseBody) SetCode(v int32) *ListClusterVersionsResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetData(v []*ListClusterVersionsResponseBodyData) *ListClusterVersionsResponseBody {
	s.Data = v
	return s
}

func (s *ListClusterVersionsResponseBody) SetDynamicMessage(v string) *ListClusterVersionsResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetErrorCode(v string) *ListClusterVersionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetHttpStatusCode(v int32) *ListClusterVersionsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetMessage(v string) *ListClusterVersionsResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetRequestId(v string) *ListClusterVersionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClusterVersionsResponseBody) SetSuccess(v bool) *ListClusterVersionsResponseBody {
	s.Success = &v
	return s
}

type ListClusterVersionsResponseBodyData struct {
	// The type of the instance.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The code of the instance type.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The version of the instance.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
}

func (s ListClusterVersionsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsResponseBodyData) SetClusterType(v string) *ListClusterVersionsResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *ListClusterVersionsResponseBodyData) SetCode(v string) *ListClusterVersionsResponseBodyData {
	s.Code = &v
	return s
}

func (s *ListClusterVersionsResponseBodyData) SetShowName(v string) *ListClusterVersionsResponseBodyData {
	s.ShowName = &v
	return s
}

type ListClusterVersionsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterVersionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterVersionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterVersionsResponse) GoString() string {
	return s.String()
}

func (s *ListClusterVersionsResponse) SetHeaders(v map[string]*string) *ListClusterVersionsResponse {
	s.Headers = v
	return s
}

func (s *ListClusterVersionsResponse) SetStatusCode(v int32) *ListClusterVersionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterVersionsResponse) SetBody(v *ListClusterVersionsResponseBody) *ListClusterVersionsResponse {
	s.Body = v
	return s
}

type ListClustersRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The alias of the instance. Fuzzy match is supported.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by MSE.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The ID of the resource group to which the instance belongs. For more information about resource groups, see the topic "View basic information of a resource group."
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of tags. A maximum number of 20 tags are supported.
	Tag []*ListClustersRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListClustersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClustersRequest) GoString() string {
	return s.String()
}

func (s *ListClustersRequest) SetAcceptLanguage(v string) *ListClustersRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListClustersRequest) SetClusterAliasName(v string) *ListClustersRequest {
	s.ClusterAliasName = &v
	return s
}

func (s *ListClustersRequest) SetPageNum(v int32) *ListClustersRequest {
	s.PageNum = &v
	return s
}

func (s *ListClustersRequest) SetPageSize(v int32) *ListClustersRequest {
	s.PageSize = &v
	return s
}

func (s *ListClustersRequest) SetRegionId(v string) *ListClustersRequest {
	s.RegionId = &v
	return s
}

func (s *ListClustersRequest) SetRequestPars(v string) *ListClustersRequest {
	s.RequestPars = &v
	return s
}

func (s *ListClustersRequest) SetResourceGroupId(v string) *ListClustersRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListClustersRequest) SetTag(v []*ListClustersRequestTag) *ListClustersRequest {
	s.Tag = v
	return s
}

type ListClustersRequestTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListClustersRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListClustersRequestTag) GoString() string {
	return s.String()
}

func (s *ListClustersRequestTag) SetKey(v string) *ListClustersRequestTag {
	s.Key = &v
	return s
}

func (s *ListClustersRequestTag) SetValue(v string) *ListClustersRequestTag {
	s.Value = &v
	return s
}

type ListClustersResponseBody struct {
	// The details of the data.
	Data []*ListClustersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListClustersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClustersResponseBody) GoString() string {
	return s.String()
}

func (s *ListClustersResponseBody) SetData(v []*ListClustersResponseBodyData) *ListClustersResponseBody {
	s.Data = v
	return s
}

func (s *ListClustersResponseBody) SetErrorCode(v string) *ListClustersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClustersResponseBody) SetHttpCode(v string) *ListClustersResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListClustersResponseBody) SetMessage(v string) *ListClustersResponseBody {
	s.Message = &v
	return s
}

func (s *ListClustersResponseBody) SetPageNumber(v int32) *ListClustersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListClustersResponseBody) SetPageSize(v int32) *ListClustersResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListClustersResponseBody) SetRequestId(v string) *ListClustersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClustersResponseBody) SetSuccess(v bool) *ListClustersResponseBody {
	s.Success = &v
	return s
}

func (s *ListClustersResponseBody) SetTotalCount(v int32) *ListClustersResponseBody {
	s.TotalCount = &v
	return s
}

type ListClustersResponseBodyData struct {
	// The application version.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// Indicates whether the instance can be upgraded.
	CanUpdate *bool `json:"CanUpdate,omitempty" xml:"CanUpdate,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The alias of the instance.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the instance expires.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The initial status of the instance.
	InitStatus *string `json:"InitStatus,omitempty" xml:"InitStatus,omitempty"`
	// The number of instances.
	InstanceCount *int64 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The public IP address of the instance.
	InternetAddress *string `json:"InternetAddress,omitempty" xml:"InternetAddress,omitempty"`
	// The public endpoint of the instance.
	InternetDomain *string `json:"InternetDomain,omitempty" xml:"InternetDomain,omitempty"`
	// The internal IP address of the instance.
	IntranetAddress *string `json:"IntranetAddress,omitempty" xml:"IntranetAddress,omitempty"`
	// The internal endpoint of the instance.
	IntranetDomain *string `json:"IntranetDomain,omitempty" xml:"IntranetDomain,omitempty"`
	// The edition of the instance.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags that are attached to the instance.
	Tags map[string]interface{} `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The version information.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s ListClustersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListClustersResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListClustersResponseBodyData) SetAppVersion(v string) *ListClustersResponseBodyData {
	s.AppVersion = &v
	return s
}

func (s *ListClustersResponseBodyData) SetCanUpdate(v bool) *ListClustersResponseBodyData {
	s.CanUpdate = &v
	return s
}

func (s *ListClustersResponseBodyData) SetChargeType(v string) *ListClustersResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *ListClustersResponseBodyData) SetClusterAliasName(v string) *ListClustersResponseBodyData {
	s.ClusterAliasName = &v
	return s
}

func (s *ListClustersResponseBodyData) SetClusterName(v string) *ListClustersResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *ListClustersResponseBodyData) SetClusterType(v string) *ListClustersResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *ListClustersResponseBodyData) SetCreateTime(v string) *ListClustersResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ListClustersResponseBodyData) SetEndDate(v string) *ListClustersResponseBodyData {
	s.EndDate = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInitStatus(v string) *ListClustersResponseBodyData {
	s.InitStatus = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInstanceCount(v int64) *ListClustersResponseBodyData {
	s.InstanceCount = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInstanceId(v string) *ListClustersResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInternetAddress(v string) *ListClustersResponseBodyData {
	s.InternetAddress = &v
	return s
}

func (s *ListClustersResponseBodyData) SetInternetDomain(v string) *ListClustersResponseBodyData {
	s.InternetDomain = &v
	return s
}

func (s *ListClustersResponseBodyData) SetIntranetAddress(v string) *ListClustersResponseBodyData {
	s.IntranetAddress = &v
	return s
}

func (s *ListClustersResponseBodyData) SetIntranetDomain(v string) *ListClustersResponseBodyData {
	s.IntranetDomain = &v
	return s
}

func (s *ListClustersResponseBodyData) SetMseVersion(v string) *ListClustersResponseBodyData {
	s.MseVersion = &v
	return s
}

func (s *ListClustersResponseBodyData) SetResourceGroupId(v string) *ListClustersResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *ListClustersResponseBodyData) SetTags(v map[string]interface{}) *ListClustersResponseBodyData {
	s.Tags = v
	return s
}

func (s *ListClustersResponseBodyData) SetVersionCode(v string) *ListClustersResponseBodyData {
	s.VersionCode = &v
	return s
}

type ListClustersResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClustersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClustersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClustersResponse) GoString() string {
	return s.String()
}

func (s *ListClustersResponse) SetHeaders(v map[string]*string) *ListClustersResponse {
	s.Headers = v
	return s
}

func (s *ListClustersResponse) SetStatusCode(v int32) *ListClustersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClustersResponse) SetBody(v *ListClustersResponseBody) *ListClustersResponse {
	s.Body = v
	return s
}

type ListConfigTrackRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The end timestamp. Unit: seconds.
	EndTs *int64 `json:"EndTs,omitempty" xml:"EndTs,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the listener.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// Specifies whether entries are sorted in reverse chronological order.
	//
	// *   true
	// *   false
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The start timestamp. Unit: seconds.
	StartTs *int64 `json:"StartTs,omitempty" xml:"StartTs,omitempty"`
}

func (s ListConfigTrackRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackRequest) GoString() string {
	return s.String()
}

func (s *ListConfigTrackRequest) SetAcceptLanguage(v string) *ListConfigTrackRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListConfigTrackRequest) SetDataId(v string) *ListConfigTrackRequest {
	s.DataId = &v
	return s
}

func (s *ListConfigTrackRequest) SetEndTs(v int64) *ListConfigTrackRequest {
	s.EndTs = &v
	return s
}

func (s *ListConfigTrackRequest) SetGroup(v string) *ListConfigTrackRequest {
	s.Group = &v
	return s
}

func (s *ListConfigTrackRequest) SetInstanceId(v string) *ListConfigTrackRequest {
	s.InstanceId = &v
	return s
}

func (s *ListConfigTrackRequest) SetIp(v string) *ListConfigTrackRequest {
	s.Ip = &v
	return s
}

func (s *ListConfigTrackRequest) SetNamespaceId(v string) *ListConfigTrackRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListConfigTrackRequest) SetPageNum(v int64) *ListConfigTrackRequest {
	s.PageNum = &v
	return s
}

func (s *ListConfigTrackRequest) SetPageSize(v int64) *ListConfigTrackRequest {
	s.PageSize = &v
	return s
}

func (s *ListConfigTrackRequest) SetRequestPars(v string) *ListConfigTrackRequest {
	s.RequestPars = &v
	return s
}

func (s *ListConfigTrackRequest) SetReverse(v bool) *ListConfigTrackRequest {
	s.Reverse = &v
	return s
}

func (s *ListConfigTrackRequest) SetStartTs(v int64) *ListConfigTrackRequest {
	s.StartTs = &v
	return s
}

type ListConfigTrackResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The data information.
	Traces []*ListConfigTrackResponseBodyTraces `json:"Traces,omitempty" xml:"Traces,omitempty" type:"Repeated"`
}

func (s ListConfigTrackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigTrackResponseBody) SetErrorCode(v string) *ListConfigTrackResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetHttpCode(v string) *ListConfigTrackResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetMessage(v string) *ListConfigTrackResponseBody {
	s.Message = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetPageNumber(v int64) *ListConfigTrackResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetPageSize(v int64) *ListConfigTrackResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetRequestId(v string) *ListConfigTrackResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetSuccess(v bool) *ListConfigTrackResponseBody {
	s.Success = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetTotalCount(v int64) *ListConfigTrackResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListConfigTrackResponseBody) SetTraces(v []*ListConfigTrackResponseBodyTraces) *ListConfigTrackResponseBody {
	s.Traces = v
	return s
}

type ListConfigTrackResponseBodyTraces struct {
	// Indicates whether the request is sent from the client.
	//
	// *   true
	// *   false
	Client *bool `json:"Client,omitempty" xml:"Client,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The response latency. Unit: ms.
	Delay *string `json:"Delay,omitempty" xml:"Delay,omitempty"`
	// The event. Valid values:
	//
	// *   pull: configuration acquisition events.
	// *   persist: persistence events.
	Event *string `json:"Event,omitempty" xml:"Event,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The log time.
	LogDate *string `json:"LogDate,omitempty" xml:"LogDate,omitempty"`
	// The MD5 value.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// Indicates whether messages are pushed by a server.
	//
	// *   true
	// *   false
	Push *bool `json:"Push,omitempty" xml:"Push,omitempty"`
	// The source IP address of the request.
	RequestIp *string `json:"RequestIp,omitempty" xml:"RequestIp,omitempty"`
	// The response node.
	ResponseIp *string `json:"ResponseIp,omitempty" xml:"ResponseIp,omitempty"`
	// The returned message.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
	// The timestamp that indicates the time when the metric value is collected.
	//
	// Unit: seconds.
	Ts *string `json:"Ts,omitempty" xml:"Ts,omitempty"`
	// The release type. Valid values:
	//
	// *   beta: beta release.
	// *   tag: canary release.
	// *   batch: batch release.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListConfigTrackResponseBodyTraces) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackResponseBodyTraces) GoString() string {
	return s.String()
}

func (s *ListConfigTrackResponseBodyTraces) SetClient(v bool) *ListConfigTrackResponseBodyTraces {
	s.Client = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetDataId(v string) *ListConfigTrackResponseBodyTraces {
	s.DataId = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetDelay(v string) *ListConfigTrackResponseBodyTraces {
	s.Delay = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetEvent(v string) *ListConfigTrackResponseBodyTraces {
	s.Event = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetGroup(v string) *ListConfigTrackResponseBodyTraces {
	s.Group = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetLogDate(v string) *ListConfigTrackResponseBodyTraces {
	s.LogDate = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetMd5(v string) *ListConfigTrackResponseBodyTraces {
	s.Md5 = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetPush(v bool) *ListConfigTrackResponseBodyTraces {
	s.Push = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetRequestIp(v string) *ListConfigTrackResponseBodyTraces {
	s.RequestIp = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetResponseIp(v string) *ListConfigTrackResponseBodyTraces {
	s.ResponseIp = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetResult(v string) *ListConfigTrackResponseBodyTraces {
	s.Result = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetTs(v string) *ListConfigTrackResponseBodyTraces {
	s.Ts = &v
	return s
}

func (s *ListConfigTrackResponseBodyTraces) SetType(v string) *ListConfigTrackResponseBodyTraces {
	s.Type = &v
	return s
}

type ListConfigTrackResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListConfigTrackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListConfigTrackResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTrackResponse) GoString() string {
	return s.String()
}

func (s *ListConfigTrackResponse) SetHeaders(v map[string]*string) *ListConfigTrackResponse {
	s.Headers = v
	return s
}

func (s *ListConfigTrackResponse) SetStatusCode(v int32) *ListConfigTrackResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigTrackResponse) SetBody(v *ListConfigTrackResponseBody) *ListConfigTrackResponse {
	s.Body = v
	return s
}

type ListEngineNamespacesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ListEngineNamespacesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesRequest) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesRequest) SetAcceptLanguage(v string) *ListEngineNamespacesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListEngineNamespacesRequest) SetInstanceId(v string) *ListEngineNamespacesRequest {
	s.InstanceId = &v
	return s
}

type ListEngineNamespacesResponseBody struct {
	// The details of the data.
	Data []*ListEngineNamespacesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListEngineNamespacesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesResponseBody) SetData(v []*ListEngineNamespacesResponseBodyData) *ListEngineNamespacesResponseBody {
	s.Data = v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetErrorCode(v string) *ListEngineNamespacesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetHttpCode(v string) *ListEngineNamespacesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetMessage(v string) *ListEngineNamespacesResponseBody {
	s.Message = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetPageNumber(v int32) *ListEngineNamespacesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetPageSize(v int32) *ListEngineNamespacesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetRequestId(v string) *ListEngineNamespacesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetSuccess(v bool) *ListEngineNamespacesResponseBody {
	s.Success = &v
	return s
}

func (s *ListEngineNamespacesResponseBody) SetTotalCount(v int32) *ListEngineNamespacesResponseBody {
	s.TotalCount = &v
	return s
}

type ListEngineNamespacesResponseBodyData struct {
	// The quota value.
	ConfigCount *int32 `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quotas.
	Quota *int32 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The number of active services.
	ServiceCount *string `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
	// The source from which the namespace was created.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   `0`: global configuration
	// *   `1`: default namespace
	// *   `2`: custom namespace
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListEngineNamespacesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesResponseBodyData) SetConfigCount(v int32) *ListEngineNamespacesResponseBodyData {
	s.ConfigCount = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetNamespace(v string) *ListEngineNamespacesResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetNamespaceDesc(v string) *ListEngineNamespacesResponseBodyData {
	s.NamespaceDesc = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetNamespaceShowName(v string) *ListEngineNamespacesResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetQuota(v int32) *ListEngineNamespacesResponseBodyData {
	s.Quota = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetServiceCount(v string) *ListEngineNamespacesResponseBodyData {
	s.ServiceCount = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetSourceType(v string) *ListEngineNamespacesResponseBodyData {
	s.SourceType = &v
	return s
}

func (s *ListEngineNamespacesResponseBodyData) SetType(v int32) *ListEngineNamespacesResponseBodyData {
	s.Type = &v
	return s
}

type ListEngineNamespacesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEngineNamespacesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEngineNamespacesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEngineNamespacesResponse) GoString() string {
	return s.String()
}

func (s *ListEngineNamespacesResponse) SetHeaders(v map[string]*string) *ListEngineNamespacesResponse {
	s.Headers = v
	return s
}

func (s *ListEngineNamespacesResponse) SetStatusCode(v int32) *ListEngineNamespacesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEngineNamespacesResponse) SetBody(v *ListEngineNamespacesResponseBody) *ListEngineNamespacesResponse {
	s.Body = v
	return s
}

type ListEurekaInstancesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListEurekaInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesRequest) SetAcceptLanguage(v string) *ListEurekaInstancesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetClusterId(v string) *ListEurekaInstancesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetPageNum(v int32) *ListEurekaInstancesRequest {
	s.PageNum = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetPageSize(v int32) *ListEurekaInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetRequestPars(v string) *ListEurekaInstancesRequest {
	s.RequestPars = &v
	return s
}

func (s *ListEurekaInstancesRequest) SetServiceName(v string) *ListEurekaInstancesRequest {
	s.ServiceName = &v
	return s
}

type ListEurekaInstancesResponseBody struct {
	// The details of the data.
	Data []*ListEurekaInstancesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListEurekaInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesResponseBody) SetData(v []*ListEurekaInstancesResponseBodyData) *ListEurekaInstancesResponseBody {
	s.Data = v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetErrorCode(v string) *ListEurekaInstancesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetHttpCode(v string) *ListEurekaInstancesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetMessage(v string) *ListEurekaInstancesResponseBody {
	s.Message = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetPageNumber(v int32) *ListEurekaInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetPageSize(v int32) *ListEurekaInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetRequestId(v string) *ListEurekaInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetSuccess(v bool) *ListEurekaInstancesResponseBody {
	s.Success = &v
	return s
}

func (s *ListEurekaInstancesResponseBody) SetTotalCount(v int32) *ListEurekaInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type ListEurekaInstancesResponseBodyData struct {
	// The name of the application.
	App *string `json:"App,omitempty" xml:"App,omitempty"`
	// The timeout period of the instance.\
	// After the specified timeout period expires, the service is unavailable by default and is deleted.
	DurationInSecs *int32 `json:"DurationInSecs,omitempty" xml:"DurationInSecs,omitempty"`
	// The URL of the homepage.
	HomePageUrl *string `json:"HomePageUrl,omitempty" xml:"HomePageUrl,omitempty"`
	// The hostname.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The time when the instance was last modified.
	LastDirtyTimestamp *int64 `json:"LastDirtyTimestamp,omitempty" xml:"LastDirtyTimestamp,omitempty"`
	// The time when the instance heartbeat was last checked.
	LastUpdatedTimestamp *int64 `json:"LastUpdatedTimestamp,omitempty" xml:"LastUpdatedTimestamp,omitempty"`
	// The metadata.
	Metadata map[string]interface{} `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The service port number.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The maximum interval between two heartbeat checks after a heartbeat check times out.\
	// Default value: 10.
	RenewalIntervalInSecs *int32 `json:"RenewalIntervalInSecs,omitempty" xml:"RenewalIntervalInSecs,omitempty"`
	// The security port.
	SecurePort *int32 `json:"SecurePort,omitempty" xml:"SecurePort,omitempty"`
	// The number of service providers. The value is in the following format: Number of healthy instances/Total number of instances.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The virtual IP address (VIP).
	VipAddress *string `json:"VipAddress,omitempty" xml:"VipAddress,omitempty"`
}

func (s ListEurekaInstancesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesResponseBodyData) SetApp(v string) *ListEurekaInstancesResponseBodyData {
	s.App = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetDurationInSecs(v int32) *ListEurekaInstancesResponseBodyData {
	s.DurationInSecs = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetHomePageUrl(v string) *ListEurekaInstancesResponseBodyData {
	s.HomePageUrl = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetHostName(v string) *ListEurekaInstancesResponseBodyData {
	s.HostName = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetInstanceId(v string) *ListEurekaInstancesResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetIpAddr(v string) *ListEurekaInstancesResponseBodyData {
	s.IpAddr = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetLastDirtyTimestamp(v int64) *ListEurekaInstancesResponseBodyData {
	s.LastDirtyTimestamp = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetLastUpdatedTimestamp(v int64) *ListEurekaInstancesResponseBodyData {
	s.LastUpdatedTimestamp = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetMetadata(v map[string]interface{}) *ListEurekaInstancesResponseBodyData {
	s.Metadata = v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetPort(v int32) *ListEurekaInstancesResponseBodyData {
	s.Port = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetRenewalIntervalInSecs(v int32) *ListEurekaInstancesResponseBodyData {
	s.RenewalIntervalInSecs = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetSecurePort(v int32) *ListEurekaInstancesResponseBodyData {
	s.SecurePort = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetStatus(v string) *ListEurekaInstancesResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListEurekaInstancesResponseBodyData) SetVipAddress(v string) *ListEurekaInstancesResponseBodyData {
	s.VipAddress = &v
	return s
}

type ListEurekaInstancesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEurekaInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEurekaInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListEurekaInstancesResponse) SetHeaders(v map[string]*string) *ListEurekaInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListEurekaInstancesResponse) SetStatusCode(v int32) *ListEurekaInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEurekaInstancesResponse) SetBody(v *ListEurekaInstancesResponseBody) *ListEurekaInstancesResponse {
	s.Body = v
	return s
}

type ListEurekaServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListEurekaServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesRequest) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesRequest) SetAcceptLanguage(v string) *ListEurekaServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListEurekaServicesRequest) SetClusterId(v string) *ListEurekaServicesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListEurekaServicesRequest) SetPageNum(v int32) *ListEurekaServicesRequest {
	s.PageNum = &v
	return s
}

func (s *ListEurekaServicesRequest) SetPageSize(v int32) *ListEurekaServicesRequest {
	s.PageSize = &v
	return s
}

func (s *ListEurekaServicesRequest) SetRegionId(v string) *ListEurekaServicesRequest {
	s.RegionId = &v
	return s
}

func (s *ListEurekaServicesRequest) SetRequestPars(v string) *ListEurekaServicesRequest {
	s.RequestPars = &v
	return s
}

type ListEurekaServicesResponseBody struct {
	// The details of the data.
	Data []*ListEurekaServicesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListEurekaServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesResponseBody) SetData(v []*ListEurekaServicesResponseBodyData) *ListEurekaServicesResponseBody {
	s.Data = v
	return s
}

func (s *ListEurekaServicesResponseBody) SetErrorCode(v string) *ListEurekaServicesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetHttpCode(v string) *ListEurekaServicesResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetMessage(v string) *ListEurekaServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetPageNumber(v int32) *ListEurekaServicesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetPageSize(v int32) *ListEurekaServicesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetRequestId(v string) *ListEurekaServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetSuccess(v bool) *ListEurekaServicesResponseBody {
	s.Success = &v
	return s
}

func (s *ListEurekaServicesResponseBody) SetTotalCount(v int32) *ListEurekaServicesResponseBody {
	s.TotalCount = &v
	return s
}

type ListEurekaServicesResponseBodyData struct {
	// The details of the instance.
	InstancesId []*string `json:"InstancesId,omitempty" xml:"InstancesId,omitempty" type:"Repeated"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of service providers. The value is in the following format: Number of healthy instances/Total number of instances.
	UpStatus *string `json:"UpStatus,omitempty" xml:"UpStatus,omitempty"`
}

func (s ListEurekaServicesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesResponseBodyData) SetInstancesId(v []*string) *ListEurekaServicesResponseBodyData {
	s.InstancesId = v
	return s
}

func (s *ListEurekaServicesResponseBodyData) SetName(v string) *ListEurekaServicesResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListEurekaServicesResponseBodyData) SetUpStatus(v string) *ListEurekaServicesResponseBodyData {
	s.UpStatus = &v
	return s
}

type ListEurekaServicesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEurekaServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEurekaServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEurekaServicesResponse) GoString() string {
	return s.String()
}

func (s *ListEurekaServicesResponse) SetHeaders(v map[string]*string) *ListEurekaServicesResponse {
	s.Headers = v
	return s
}

func (s *ListEurekaServicesResponse) SetStatusCode(v int32) *ListEurekaServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEurekaServicesResponse) SetBody(v *ListEurekaServicesResponseBody) *ListEurekaServicesResponse {
	s.Body = v
	return s
}

type ListExportZookeeperDataRequest struct {
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	InstanceId     *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	PageNumber     *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListExportZookeeperDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataRequest) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataRequest) SetAcceptLanguage(v string) *ListExportZookeeperDataRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListExportZookeeperDataRequest) SetInstanceId(v string) *ListExportZookeeperDataRequest {
	s.InstanceId = &v
	return s
}

func (s *ListExportZookeeperDataRequest) SetPageNumber(v int32) *ListExportZookeeperDataRequest {
	s.PageNumber = &v
	return s
}

func (s *ListExportZookeeperDataRequest) SetPageSize(v int32) *ListExportZookeeperDataRequest {
	s.PageSize = &v
	return s
}

type ListExportZookeeperDataResponseBody struct {
	Data           []*ListExportZookeeperDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	DynamicMessage *string                                    `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	ErrorCode      *string                                    `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	HttpStatusCode *string                                    `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	Message        *string                                    `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId      *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListExportZookeeperDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataResponseBody) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataResponseBody) SetData(v []*ListExportZookeeperDataResponseBodyData) *ListExportZookeeperDataResponseBody {
	s.Data = v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetDynamicMessage(v string) *ListExportZookeeperDataResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetErrorCode(v string) *ListExportZookeeperDataResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetHttpStatusCode(v string) *ListExportZookeeperDataResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetMessage(v string) *ListExportZookeeperDataResponseBody {
	s.Message = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetRequestId(v string) *ListExportZookeeperDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListExportZookeeperDataResponseBody) SetSuccess(v bool) *ListExportZookeeperDataResponseBody {
	s.Success = &v
	return s
}

type ListExportZookeeperDataResponseBodyData struct {
	ContentMap     *string `json:"ContentMap,omitempty" xml:"ContentMap,omitempty"`
	CreateTime     *int64  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	ExportType     *string `json:"ExportType,omitempty" xml:"ExportType,omitempty"`
	Extend         *string `json:"Extend,omitempty" xml:"Extend,omitempty"`
	Id             *int32  `json:"Id,omitempty" xml:"Id,omitempty"`
	InstanceId     *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	KubeoneTaskIds *string `json:"KubeoneTaskIds,omitempty" xml:"KubeoneTaskIds,omitempty"`
	Status         *string `json:"Status,omitempty" xml:"Status,omitempty"`
	UpdateTime     *int64  `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ListExportZookeeperDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataResponseBodyData) SetContentMap(v string) *ListExportZookeeperDataResponseBodyData {
	s.ContentMap = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetCreateTime(v int64) *ListExportZookeeperDataResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetExportType(v string) *ListExportZookeeperDataResponseBodyData {
	s.ExportType = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetExtend(v string) *ListExportZookeeperDataResponseBodyData {
	s.Extend = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetId(v int32) *ListExportZookeeperDataResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetInstanceId(v string) *ListExportZookeeperDataResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetKubeoneTaskIds(v string) *ListExportZookeeperDataResponseBodyData {
	s.KubeoneTaskIds = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetStatus(v string) *ListExportZookeeperDataResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListExportZookeeperDataResponseBodyData) SetUpdateTime(v int64) *ListExportZookeeperDataResponseBodyData {
	s.UpdateTime = &v
	return s
}

type ListExportZookeeperDataResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListExportZookeeperDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListExportZookeeperDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ListExportZookeeperDataResponse) GoString() string {
	return s.String()
}

func (s *ListExportZookeeperDataResponse) SetHeaders(v map[string]*string) *ListExportZookeeperDataResponse {
	s.Headers = v
	return s
}

func (s *ListExportZookeeperDataResponse) SetStatusCode(v int32) *ListExportZookeeperDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ListExportZookeeperDataResponse) SetBody(v *ListExportZookeeperDataResponseBody) *ListExportZookeeperDataResponse {
	s.Body = v
	return s
}

type ListGatewayRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the sorting feature. This feature is not available.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The details of parameters.
	FilterParams *ListGatewayRequestFilterParams `json:"FilterParams,omitempty" xml:"FilterParams,omitempty" type:"Struct"`
	// The order information.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRequest) SetAcceptLanguage(v string) *ListGatewayRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayRequest) SetDescSort(v bool) *ListGatewayRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayRequest) SetFilterParams(v *ListGatewayRequestFilterParams) *ListGatewayRequest {
	s.FilterParams = v
	return s
}

func (s *ListGatewayRequest) SetOrderItem(v string) *ListGatewayRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayRequest) SetPageNumber(v int32) *ListGatewayRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRequest) SetPageSize(v int32) *ListGatewayRequest {
	s.PageSize = &v
	return s
}

type ListGatewayRequestFilterParams struct {
	// The type of the gateway.
	GatewayType *string `json:"GatewayType,omitempty" xml:"GatewayType,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The tag of the instance.
	MseTag *string `json:"MseTag,omitempty" xml:"MseTag,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	Vpc *string `json:"Vpc,omitempty" xml:"Vpc,omitempty"`
}

func (s ListGatewayRequestFilterParams) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRequestFilterParams) GoString() string {
	return s.String()
}

func (s *ListGatewayRequestFilterParams) SetGatewayType(v string) *ListGatewayRequestFilterParams {
	s.GatewayType = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetGatewayUniqueId(v string) *ListGatewayRequestFilterParams {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetInstanceId(v string) *ListGatewayRequestFilterParams {
	s.InstanceId = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetMseTag(v string) *ListGatewayRequestFilterParams {
	s.MseTag = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetName(v string) *ListGatewayRequestFilterParams {
	s.Name = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetResourceGroupId(v string) *ListGatewayRequestFilterParams {
	s.ResourceGroupId = &v
	return s
}

func (s *ListGatewayRequestFilterParams) SetVpc(v string) *ListGatewayRequestFilterParams {
	s.Vpc = &v
	return s
}

type ListGatewayShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable the sorting feature. This feature is not available.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The details of parameters.
	FilterParamsShrink *string `json:"FilterParams,omitempty" xml:"FilterParams,omitempty"`
	// The order information.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayShrinkRequest) SetAcceptLanguage(v string) *ListGatewayShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetDescSort(v bool) *ListGatewayShrinkRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetFilterParamsShrink(v string) *ListGatewayShrinkRequest {
	s.FilterParamsShrink = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetOrderItem(v string) *ListGatewayShrinkRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetPageNumber(v int32) *ListGatewayShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayShrinkRequest) SetPageSize(v int32) *ListGatewayShrinkRequest {
	s.PageSize = &v
	return s
}

type ListGatewayResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *ListGatewayResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBody) SetCode(v int32) *ListGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayResponseBody) SetData(v *ListGatewayResponseBodyData) *ListGatewayResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayResponseBody) SetHttpStatusCode(v int32) *ListGatewayResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayResponseBody) SetMessage(v string) *ListGatewayResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayResponseBody) SetRequestId(v string) *ListGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayResponseBody) SetSuccess(v bool) *ListGatewayResponseBody {
	s.Success = &v
	return s
}

type ListGatewayResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data entries returned.
	Result []*ListGatewayResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyData) SetPageNumber(v int32) *ListGatewayResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayResponseBodyData) SetPageSize(v int32) *ListGatewayResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayResponseBodyData) SetResult(v []*ListGatewayResponseBodyDataResult) *ListGatewayResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayResponseBodyData) SetTotalSize(v int64) *ListGatewayResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayResponseBodyDataResult struct {
	// Indicates whether Application High Availability Service (AHAS) is activated.
	AhasOn *bool `json:"AhasOn,omitempty" xml:"AhasOn,omitempty"`
	// The version of the application.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// Indicates whether Application Real-Time Monitoring Service (ARMS) is activated.
	ArmsOn *bool `json:"ArmsOn,omitempty" xml:"ArmsOn,omitempty"`
	// The billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The current version of the gateway.
	CurrentVersion *string `json:"CurrentVersion,omitempty" xml:"CurrentVersion,omitempty"`
	// The time when the subscription gateway expires.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The type of the gateway.
	GatewayType *string `json:"GatewayType,omitempty" xml:"GatewayType,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The version of the gateway.
	GatewayVersion *string `json:"GatewayVersion,omitempty" xml:"GatewayVersion,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the gateway.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The configurations.
	InitConfig *ListGatewayResponseBodyDataResultInitConfig `json:"InitConfig,omitempty" xml:"InitConfig,omitempty" type:"Struct"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The details of the Internet-facing SLB instances.
	InternetSlb []*ListGatewayResponseBodyDataResultInternetSlb `json:"InternetSlb,omitempty" xml:"InternetSlb,omitempty" type:"Repeated"`
	// The latest version of the gateway.
	LatestVersion *string `json:"LatestVersion,omitempty" xml:"LatestVersion,omitempty"`
	// The tag of the instance.
	MseTag *string `json:"MseTag,omitempty" xml:"MseTag,omitempty"`
	// Indicates whether the gateway can be forcefully updated.
	MustUpgrade *bool `json:"MustUpgrade,omitempty" xml:"MustUpgrade,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The information about the user.
	PrimaryUser *string `json:"PrimaryUser,omitempty" xml:"PrimaryUser,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The number of replicas.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether rollbacks are allowed.
	RollBack *bool `json:"RollBack,omitempty" xml:"RollBack,omitempty"`
	// The details of the Server Load Balancer (SLB) instances.
	Slb []*ListGatewayResponseBodyDataResultSlb `json:"Slb,omitempty" xml:"Slb,omitempty" type:"Repeated"`
	// The specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The gateway status.
	//
	// *   0: The gateway is being created.
	// *   1: The gateway fails to be created.
	// *   2: The gateway is running.
	// *   3: The gateway is changing.
	// *   4: The gateway is scaling down.
	// *   6: The gateway is scaling up.
	// *   8: The gateway is being deleted.
	// *   9: The gateway is suspended and to be released.
	// *   10: The gateway is restarting.
	// *   11: The gateway is being rebuilt.
	// *   12: The gateway is updating.
	// *   13: The gateway fails to be updated.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// Indicates whether WebAssembly (Wasm) is supported.
	SupportWasm *bool `json:"SupportWasm,omitempty" xml:"SupportWasm,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// Indicates whether the gateway can be updated.
	Upgrade *bool `json:"Upgrade,omitempty" xml:"Upgrade,omitempty"`
	// The ID of the secondary vSwitch.
	Vswitch2 *string `json:"Vswitch2,omitempty" xml:"Vswitch2,omitempty"`
}

func (s ListGatewayResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResult) SetAhasOn(v bool) *ListGatewayResponseBodyDataResult {
	s.AhasOn = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetAppVersion(v string) *ListGatewayResponseBodyDataResult {
	s.AppVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetArmsOn(v bool) *ListGatewayResponseBodyDataResult {
	s.ArmsOn = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetChargeType(v string) *ListGatewayResponseBodyDataResult {
	s.ChargeType = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetCurrentVersion(v string) *ListGatewayResponseBodyDataResult {
	s.CurrentVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetEndDate(v string) *ListGatewayResponseBodyDataResult {
	s.EndDate = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGatewayType(v string) *ListGatewayResponseBodyDataResult {
	s.GatewayType = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGatewayVersion(v string) *ListGatewayResponseBodyDataResult {
	s.GatewayVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetGmtModified(v string) *ListGatewayResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetId(v int64) *ListGatewayResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetInitConfig(v *ListGatewayResponseBodyDataResultInitConfig) *ListGatewayResponseBodyDataResult {
	s.InitConfig = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetInstanceId(v string) *ListGatewayResponseBodyDataResult {
	s.InstanceId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetInternetSlb(v []*ListGatewayResponseBodyDataResultInternetSlb) *ListGatewayResponseBodyDataResult {
	s.InternetSlb = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetLatestVersion(v string) *ListGatewayResponseBodyDataResult {
	s.LatestVersion = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetMseTag(v string) *ListGatewayResponseBodyDataResult {
	s.MseTag = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetMustUpgrade(v bool) *ListGatewayResponseBodyDataResult {
	s.MustUpgrade = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetName(v string) *ListGatewayResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetPrimaryUser(v string) *ListGatewayResponseBodyDataResult {
	s.PrimaryUser = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetRegion(v string) *ListGatewayResponseBodyDataResult {
	s.Region = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetReplica(v int32) *ListGatewayResponseBodyDataResult {
	s.Replica = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetResourceGroupId(v string) *ListGatewayResponseBodyDataResult {
	s.ResourceGroupId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetRollBack(v bool) *ListGatewayResponseBodyDataResult {
	s.RollBack = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetSlb(v []*ListGatewayResponseBodyDataResultSlb) *ListGatewayResponseBodyDataResult {
	s.Slb = v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetSpec(v string) *ListGatewayResponseBodyDataResult {
	s.Spec = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetStatus(v int32) *ListGatewayResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetStatusDesc(v string) *ListGatewayResponseBodyDataResult {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetSupportWasm(v bool) *ListGatewayResponseBodyDataResult {
	s.SupportWasm = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetTag(v string) *ListGatewayResponseBodyDataResult {
	s.Tag = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetUpgrade(v bool) *ListGatewayResponseBodyDataResult {
	s.Upgrade = &v
	return s
}

func (s *ListGatewayResponseBodyDataResult) SetVswitch2(v string) *ListGatewayResponseBodyDataResult {
	s.Vswitch2 = &v
	return s
}

type ListGatewayResponseBodyDataResultInitConfig struct {
	// Indicates whether Web Application Firewall (WAF) is enabled.
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Indicates whether WAF is supported.
	SupportWaf *bool `json:"SupportWaf,omitempty" xml:"SupportWaf,omitempty"`
}

func (s ListGatewayResponseBodyDataResultInitConfig) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultInitConfig) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultInitConfig) SetEnableWaf(v bool) *ListGatewayResponseBodyDataResultInitConfig {
	s.EnableWaf = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInitConfig) SetSupportWaf(v bool) *ListGatewayResponseBodyDataResultInitConfig {
	s.SupportWaf = &v
	return s
}

type ListGatewayResponseBodyDataResultInternetSlb struct {
	// The mode of the SLB instance.
	GatewaySlbMode *string `json:"GatewaySlbMode,omitempty" xml:"GatewaySlbMode,omitempty"`
	// The status of the SLB instance.
	GatewaySlbStatus *string `json:"GatewaySlbStatus,omitempty" xml:"GatewaySlbStatus,omitempty"`
	// The traffic of the gateway.
	InternetNetworkFlow *string `json:"InternetNetworkFlow,omitempty" xml:"InternetNetworkFlow,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The port number of the SLB instance.
	SlbPort *string `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The specifications of the SLB instance.
	SlbSpec *string `json:"SlbSpec,omitempty" xml:"SlbSpec,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayResponseBodyDataResultInternetSlb) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultInternetSlb) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetGatewaySlbMode(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.GatewaySlbMode = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetGatewaySlbStatus(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.GatewaySlbStatus = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetInternetNetworkFlow(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.InternetNetworkFlow = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbId(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbIp(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbIp = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbPort(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbPort = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetSlbSpec(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.SlbSpec = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetStatusDesc(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultInternetSlb) SetType(v string) *ListGatewayResponseBodyDataResultInternetSlb {
	s.Type = &v
	return s
}

type ListGatewayResponseBodyDataResultSlb struct {
	// The mode of the SLB instance.
	GatewaySlbMode *string `json:"GatewaySlbMode,omitempty" xml:"GatewaySlbMode,omitempty"`
	// The status of the SLB instance.
	GatewaySlbStatus *string `json:"GatewaySlbStatus,omitempty" xml:"GatewaySlbStatus,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The port number of the SLB instance.
	SlbPort *string `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The specifications of the SLB instance.
	SlbSpec *string `json:"SlbSpec,omitempty" xml:"SlbSpec,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayResponseBodyDataResultSlb) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponseBodyDataResultSlb) GoString() string {
	return s.String()
}

func (s *ListGatewayResponseBodyDataResultSlb) SetGatewaySlbMode(v string) *ListGatewayResponseBodyDataResultSlb {
	s.GatewaySlbMode = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetGatewaySlbStatus(v string) *ListGatewayResponseBodyDataResultSlb {
	s.GatewaySlbStatus = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbId(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbId = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbIp(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbIp = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbPort(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbPort = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetSlbSpec(v string) *ListGatewayResponseBodyDataResultSlb {
	s.SlbSpec = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetStatusDesc(v string) *ListGatewayResponseBodyDataResultSlb {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewayResponseBodyDataResultSlb) SetType(v string) *ListGatewayResponseBodyDataResultSlb {
	s.Type = &v
	return s
}

type ListGatewayResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayResponse) SetHeaders(v map[string]*string) *ListGatewayResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayResponse) SetStatusCode(v int32) *ListGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayResponse) SetBody(v *ListGatewayResponseBody) *ListGatewayResponse {
	s.Body = v
	return s
}

type ListGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The type of the domain name.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainRequest) SetAcceptLanguage(v string) *ListGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayDomainRequest) SetGatewayUniqueId(v string) *ListGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayDomainRequest) SetType(v string) *ListGatewayDomainRequest {
	s.Type = &v
	return s
}

type ListGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data []*ListGatewayDomainResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponseBody) SetCode(v int32) *ListGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetData(v []*ListGatewayDomainResponseBodyData) *ListGatewayDomainResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayDomainResponseBody) SetHttpStatusCode(v int32) *ListGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetMessage(v string) *ListGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetRequestId(v string) *ListGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayDomainResponseBody) SetSuccess(v bool) *ListGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type ListGatewayDomainResponseBodyData struct {
	// The expiration time.
	CertBeforeDate *string `json:"CertBeforeDate,omitempty" xml:"CertBeforeDate,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The route comment (ingress).
	Comment *ListGatewayDomainResponseBodyDataComment `json:"Comment,omitempty" xml:"Comment,omitempty" type:"Struct"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// Indicates whether `HTTP/2` is enabled.
	//
	// *   `open`: `HTTP/2` is enabled.
	// *   `close`: `HTTP/2` is disabled.
	// *   `globalConfig`: Global configurations are used.
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// The domain ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether HTTPS is forcefully used.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The domain name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The status of the domain name. Valid values:
	//
	// *   0: unpublish
	// *   2: publishing
	// *   3: published
	// *   4: editing
	// *   5: unpublishing
	// *   6: unavailable
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayDomainResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponseBodyData) SetCertBeforeDate(v string) *ListGatewayDomainResponseBodyData {
	s.CertBeforeDate = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetCertIdentifier(v string) *ListGatewayDomainResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetComment(v *ListGatewayDomainResponseBodyDataComment) *ListGatewayDomainResponseBodyData {
	s.Comment = v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetGatewayId(v int64) *ListGatewayDomainResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetGmtCreate(v string) *ListGatewayDomainResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetGmtModified(v string) *ListGatewayDomainResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetHttp2(v string) *ListGatewayDomainResponseBodyData {
	s.Http2 = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetId(v int64) *ListGatewayDomainResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetMustHttps(v bool) *ListGatewayDomainResponseBodyData {
	s.MustHttps = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetName(v string) *ListGatewayDomainResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetProtocol(v string) *ListGatewayDomainResponseBodyData {
	s.Protocol = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetStatus(v int32) *ListGatewayDomainResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetTlsMax(v string) *ListGatewayDomainResponseBodyData {
	s.TlsMax = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetTlsMin(v string) *ListGatewayDomainResponseBodyData {
	s.TlsMin = &v
	return s
}

func (s *ListGatewayDomainResponseBodyData) SetType(v string) *ListGatewayDomainResponseBodyData {
	s.Type = &v
	return s
}

type ListGatewayDomainResponseBodyDataComment struct {
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListGatewayDomainResponseBodyDataComment) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponseBodyDataComment) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponseBodyDataComment) SetStatus(v string) *ListGatewayDomainResponseBodyDataComment {
	s.Status = &v
	return s
}

type ListGatewayDomainResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayDomainResponse) SetHeaders(v map[string]*string) *ListGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayDomainResponse) SetStatusCode(v int32) *ListGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayDomainResponse) SetBody(v *ListGatewayDomainResponseBody) *ListGatewayDomainResponse {
	s.Body = v
	return s
}

type ListGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting. This parameter is taken offline and is unavailable.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that specify filter conditions. The parameters are in the format of {"key1":"value1"}.
	FilterParams *ListGatewayRouteRequestFilterParams `json:"FilterParams,omitempty" xml:"FilterParams,omitempty" type:"Struct"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteRequest) SetAcceptLanguage(v string) *ListGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayRouteRequest) SetDescSort(v bool) *ListGatewayRouteRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayRouteRequest) SetFilterParams(v *ListGatewayRouteRequestFilterParams) *ListGatewayRouteRequest {
	s.FilterParams = v
	return s
}

func (s *ListGatewayRouteRequest) SetOrderItem(v string) *ListGatewayRouteRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayRouteRequest) SetPageNumber(v int32) *ListGatewayRouteRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRouteRequest) SetPageSize(v int32) *ListGatewayRouteRequest {
	s.PageSize = &v
	return s
}

type ListGatewayRouteRequestFilterParams struct {
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The associated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The order.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListGatewayRouteRequestFilterParams) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteRequestFilterParams) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteRequestFilterParams) SetDefaultServiceId(v int64) *ListGatewayRouteRequestFilterParams {
	s.DefaultServiceId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetDomainId(v int64) *ListGatewayRouteRequestFilterParams {
	s.DomainId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetDomainName(v string) *ListGatewayRouteRequestFilterParams {
	s.DomainName = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetGatewayId(v int64) *ListGatewayRouteRequestFilterParams {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetGatewayUniqueId(v string) *ListGatewayRouteRequestFilterParams {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetName(v string) *ListGatewayRouteRequestFilterParams {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetRouteOrder(v int32) *ListGatewayRouteRequestFilterParams {
	s.RouteOrder = &v
	return s
}

func (s *ListGatewayRouteRequestFilterParams) SetStatus(v int32) *ListGatewayRouteRequestFilterParams {
	s.Status = &v
	return s
}

type ListGatewayRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting. This parameter is taken offline and is unavailable.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that specify filter conditions. The parameters are in the format of {"key1":"value1"}.
	FilterParamsShrink *string `json:"FilterParams,omitempty" xml:"FilterParams,omitempty"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteShrinkRequest) SetAcceptLanguage(v string) *ListGatewayRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetDescSort(v bool) *ListGatewayRouteShrinkRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetFilterParamsShrink(v string) *ListGatewayRouteShrinkRequest {
	s.FilterParamsShrink = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetOrderItem(v string) *ListGatewayRouteShrinkRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetPageNumber(v int32) *ListGatewayRouteShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRouteShrinkRequest) SetPageSize(v int32) *ListGatewayRouteShrinkRequest {
	s.PageSize = &v
	return s
}

type ListGatewayRouteResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *ListGatewayRouteResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBody) SetCode(v int32) *ListGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetData(v *ListGatewayRouteResponseBodyData) *ListGatewayRouteResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayRouteResponseBody) SetHttpStatusCode(v int32) *ListGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetMessage(v string) *ListGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetRequestId(v string) *ListGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayRouteResponseBody) SetSuccess(v bool) *ListGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type ListGatewayRouteResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data structure.
	Result []*ListGatewayRouteResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayRouteResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyData) SetPageNumber(v int32) *ListGatewayRouteResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayRouteResponseBodyData) SetPageSize(v int32) *ListGatewayRouteResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayRouteResponseBodyData) SetResult(v []*ListGatewayRouteResponseBodyDataResult) *ListGatewayRouteResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayRouteResponseBodyData) SetTotalSize(v int64) *ListGatewayRouteResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayRouteResponseBodyDataResult struct {
	// The route comment (ingress).
	Comment *ListGatewayRouteResponseBodyDataResultComment `json:"Comment,omitempty" xml:"Comment,omitempty" type:"Struct"`
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The default service name.
	DefaultServiceName *string `json:"DefaultServiceName,omitempty" xml:"DefaultServiceName,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponse *ListGatewayRouteResponseBodyDataResultDirectResponse `json:"DirectResponse,omitempty" xml:"DirectResponse,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The IDs of domains.
	DomainIdList []*int64 `json:"DomainIdList,omitempty" xml:"DomainIdList,omitempty" type:"Repeated"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The names of domains.
	DomainNameList []*string `json:"DomainNameList,omitempty" xml:"DomainNameList,omitempty" type:"Repeated"`
	// Indicates whether Web Application Firewall (WAF) is activated.
	EnableWaf *string `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Indicates whether the Fallback service is enabled.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information of the Fallback service.
	FallbackServices []*ListGatewayRouteResponseBodyDataResultFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rules.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The information about redirection.
	Redirect *ListGatewayRouteResponseBodyDataResultRedirect `json:"Redirect,omitempty" xml:"Redirect,omitempty" type:"Struct"`
	// The order.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The matching rules.
	RoutePredicates *ListGatewayRouteResponseBodyDataResultRoutePredicates `json:"RoutePredicates,omitempty" xml:"RoutePredicates,omitempty" type:"Struct"`
	// The services.
	RouteServices []*ListGatewayRouteResponseBodyDataResultRouteServices `json:"RouteServices,omitempty" xml:"RouteServices,omitempty" type:"Repeated"`
	// The information about services.
	Services *string `json:"Services,omitempty" xml:"Services,omitempty"`
	// The status.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The route type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResult) SetComment(v *ListGatewayRouteResponseBodyDataResultComment) *ListGatewayRouteResponseBodyDataResult {
	s.Comment = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDefaultServiceId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.DefaultServiceId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDefaultServiceName(v string) *ListGatewayRouteResponseBodyDataResult {
	s.DefaultServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDestinationType(v string) *ListGatewayRouteResponseBodyDataResult {
	s.DestinationType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDirectResponse(v *ListGatewayRouteResponseBodyDataResultDirectResponse) *ListGatewayRouteResponseBodyDataResult {
	s.DirectResponse = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.DomainId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainIdList(v []*int64) *ListGatewayRouteResponseBodyDataResult {
	s.DomainIdList = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainName(v string) *ListGatewayRouteResponseBodyDataResult {
	s.DomainName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetDomainNameList(v []*string) *ListGatewayRouteResponseBodyDataResult {
	s.DomainNameList = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetEnableWaf(v string) *ListGatewayRouteResponseBodyDataResult {
	s.EnableWaf = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetFallback(v bool) *ListGatewayRouteResponseBodyDataResult {
	s.Fallback = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetFallbackServices(v []*ListGatewayRouteResponseBodyDataResultFallbackServices) *ListGatewayRouteResponseBodyDataResult {
	s.FallbackServices = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGatewayId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayRouteResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayRouteResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetGmtModified(v string) *ListGatewayRouteResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetId(v int64) *ListGatewayRouteResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetName(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetPredicates(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Predicates = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRedirect(v *ListGatewayRouteResponseBodyDataResultRedirect) *ListGatewayRouteResponseBodyDataResult {
	s.Redirect = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRouteOrder(v int32) *ListGatewayRouteResponseBodyDataResult {
	s.RouteOrder = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRoutePredicates(v *ListGatewayRouteResponseBodyDataResultRoutePredicates) *ListGatewayRouteResponseBodyDataResult {
	s.RoutePredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetRouteServices(v []*ListGatewayRouteResponseBodyDataResultRouteServices) *ListGatewayRouteResponseBodyDataResult {
	s.RouteServices = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetServices(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Services = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetStatus(v int32) *ListGatewayRouteResponseBodyDataResult {
	s.Status = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResult) SetType(v string) *ListGatewayRouteResponseBodyDataResult {
	s.Type = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultComment struct {
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultComment) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultComment) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultComment) SetStatus(v string) *ListGatewayRouteResponseBodyDataResultComment {
	s.Status = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultDirectResponse struct {
	// The return value for service mocking.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultDirectResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultDirectResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultDirectResponse) SetBody(v string) *ListGatewayRouteResponseBodyDataResultDirectResponse {
	s.Body = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultDirectResponse) SetCode(v int32) *ListGatewayRouteResponseBodyDataResultDirectResponse {
	s.Code = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultFallbackServices struct {
	// The protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the service belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of a service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of a service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultFallbackServices) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetAgreementType(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetGroupName(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.GroupName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetName(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetNamespace(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Namespace = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetPercent(v int32) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Percent = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetServiceId(v int64) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetServiceName(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.ServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetServicePort(v int32) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetSourceType(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.SourceType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultFallbackServices) SetVersion(v string) *ListGatewayRouteResponseBodyDataResultFallbackServices {
	s.Version = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRedirect struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname to be redirected to.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRedirect) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRedirect) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRedirect) SetCode(v int32) *ListGatewayRouteResponseBodyDataResultRedirect {
	s.Code = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRedirect) SetHost(v string) *ListGatewayRouteResponseBodyDataResultRedirect {
	s.Host = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRedirect) SetPath(v string) *ListGatewayRouteResponseBodyDataResultRedirect {
	s.Path = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicates struct {
	// The headers used for route matching.
	HeaderPredicates []*ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The HTTP methods used for route matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The path used for route matching.
	PathPredicates *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The parameters used for route matching.
	QueryPredicates []*ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetHeaderPredicates(v []*ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.HeaderPredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetMethodPredicates(v []*string) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.MethodPredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetPathPredicates(v *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.PathPredicates = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicates) SetQueryPredicates(v []*ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) *ListGatewayRouteResponseBodyDataResultRoutePredicates {
	s.QueryPredicates = v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates struct {
	// Header KEY
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) SetKey(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) SetType(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates) SetValue(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates struct {
	// Indicates whether case sensitivity is ignored.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) SetIgnoreCase(v bool) *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) SetPath(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates) SetType(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesPathPredicates {
	s.Type = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates struct {
	// The key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) SetKey(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) SetType(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates) SetValue(v string) *ListGatewayRouteResponseBodyDataResultRoutePredicatesQueryPredicates {
	s.Value = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServices struct {
	// The protocol.
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The transcoder of the Dubbo protocol.
	HttpDubboTranscoder *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder `json:"HttpDubboTranscoder,omitempty" xml:"HttpDubboTranscoder,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The Dubbo port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServices) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServices) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetAgreementType(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.AgreementType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetGroupName(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.GroupName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetHttpDubboTranscoder(v *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.HttpDubboTranscoder = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetName(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Name = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetNamespace(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Namespace = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetPercent(v int32) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Percent = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetServiceId(v int64) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.ServiceId = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetServiceName(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.ServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetServicePort(v int32) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.ServicePort = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetSourceType(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.SourceType = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServices) SetVersion(v string) *ListGatewayRouteResponseBodyDataResultRouteServices {
	s.Version = &v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder struct {
	// The Dubbo service group.
	DubboServiceGroup *string `json:"DubboServiceGroup,omitempty" xml:"DubboServiceGroup,omitempty"`
	// The name of the Dubbo service.
	DubboServiceName *string `json:"DubboServiceName,omitempty" xml:"DubboServiceName,omitempty"`
	// The version of the Dubbo service.
	DubboServiceVersion *string `json:"DubboServiceVersion,omitempty" xml:"DubboServiceVersion,omitempty"`
	// The forwarding rules of the Dubbo service.
	MothedMapList []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList `json:"MothedMapList,omitempty" xml:"MothedMapList,omitempty" type:"Repeated"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetDubboServiceGroup(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.DubboServiceGroup = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetDubboServiceName(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.DubboServiceName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetDubboServiceVersion(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.DubboServiceVersion = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder) SetMothedMapList(v []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoder {
	s.MothedMapList = v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList struct {
	// The method name of the Dubbo service.
	DubboMothedName *string `json:"DubboMothedName,omitempty" xml:"DubboMothedName,omitempty"`
	// The HTTP method.
	//
	// > Valid values:
	//
	// *   ALL_GET
	//
	// *   ALL_POST
	//
	// *   ALL_PUT
	//
	// *   ALL_DELETE
	//
	// *   ALL_PATCH
	HttpMothed *string `json:"HttpMothed,omitempty" xml:"HttpMothed,omitempty"`
	// The path used for method matching.
	Mothedpath *string `json:"Mothedpath,omitempty" xml:"Mothedpath,omitempty"`
	// The information about parameter mappings.
	ParamMapsList []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList `json:"ParamMapsList,omitempty" xml:"ParamMapsList,omitempty" type:"Repeated"`
	// The pass-through type of the header.
	//
	// > Valid values:
	//
	// *   PASS_ALL: All headers are passed through.
	//
	// *   PASS_NOT: All headers are not passed through.
	//
	// *   PASS_ASSIGN: Specified headers are passed through.
	PassThroughAllHeaders *string `json:"PassThroughAllHeaders,omitempty" xml:"PassThroughAllHeaders,omitempty"`
	// The list of headers to be passed through.
	PassThroughList []*string `json:"PassThroughList,omitempty" xml:"PassThroughList,omitempty" type:"Repeated"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetDubboMothedName(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.DubboMothedName = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetHttpMothed(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.HttpMothed = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetMothedpath(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.Mothedpath = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetParamMapsList(v []*ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.ParamMapsList = v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetPassThroughAllHeaders(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughAllHeaders = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList) SetPassThroughList(v []*string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughList = v
	return s
}

type ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList struct {
	// The key extracted from the input parameter.
	ExtractKey *string `json:"ExtractKey,omitempty" xml:"ExtractKey,omitempty"`
	// The position of the input parameter.
	//
	// > Valid values:
	//
	// *   `ALL_QUERY_PARAMETER`: request parameter
	//
	// *   `ALL_HEADER`: request header
	//
	// *   `ALL_PATH`: request path
	//
	// *   `ALL_BODY`: request body
	ExtractKeySpec *string `json:"ExtractKeySpec,omitempty" xml:"ExtractKeySpec,omitempty"`
	// The type of the backend service parameter.
	MappingType *string `json:"MappingType,omitempty" xml:"MappingType,omitempty"`
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKey(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKey = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKeySpec(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKeySpec = &v
	return s
}

func (s *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList) SetMappingType(v string) *ListGatewayRouteResponseBodyDataResultRouteServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.MappingType = &v
	return s
}

type ListGatewayRouteResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayRouteResponse) SetHeaders(v map[string]*string) *ListGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayRouteResponse) SetStatusCode(v int32) *ListGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayRouteResponse) SetBody(v *ListGatewayRouteResponseBody) *ListGatewayRouteResponse {
	s.Body = v
	return s
}

type ListGatewayServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that specify filter conditions, which are in the format of {"key1":"value1"}.
	FilterParams *ListGatewayServiceRequestFilterParams `json:"FilterParams,omitempty" xml:"FilterParams,omitempty" type:"Struct"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceRequest) SetAcceptLanguage(v string) *ListGatewayServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayServiceRequest) SetDescSort(v bool) *ListGatewayServiceRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayServiceRequest) SetFilterParams(v *ListGatewayServiceRequestFilterParams) *ListGatewayServiceRequest {
	s.FilterParams = v
	return s
}

func (s *ListGatewayServiceRequest) SetOrderItem(v string) *ListGatewayServiceRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayServiceRequest) SetPageNumber(v int32) *ListGatewayServiceRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayServiceRequest) SetPageSize(v int32) *ListGatewayServiceRequest {
	s.PageSize = &v
	return s
}

type ListGatewayServiceRequestFilterParams struct {
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The protocol of the service.
	//
	// *   HTTP
	// *   HTTPS
	// *   HTTP2
	// *   GRPC
	// *   DUBBO
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s ListGatewayServiceRequestFilterParams) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceRequestFilterParams) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceRequestFilterParams) SetGatewayUniqueId(v string) *ListGatewayServiceRequestFilterParams {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetGroupName(v string) *ListGatewayServiceRequestFilterParams {
	s.GroupName = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetName(v string) *ListGatewayServiceRequestFilterParams {
	s.Name = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetNamespace(v string) *ListGatewayServiceRequestFilterParams {
	s.Namespace = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetServiceProtocol(v string) *ListGatewayServiceRequestFilterParams {
	s.ServiceProtocol = &v
	return s
}

func (s *ListGatewayServiceRequestFilterParams) SetSourceType(v string) *ListGatewayServiceRequestFilterParams {
	s.SourceType = &v
	return s
}

type ListGatewayServiceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to enable sorting.
	DescSort *bool `json:"DescSort,omitempty" xml:"DescSort,omitempty"`
	// The parameters that specify filter conditions, which are in the format of {"key1":"value1"}.
	FilterParamsShrink *string `json:"FilterParams,omitempty" xml:"FilterParams,omitempty"`
	// The item based on which entries are sorted.
	OrderItem *string `json:"OrderItem,omitempty" xml:"OrderItem,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListGatewayServiceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceShrinkRequest) SetAcceptLanguage(v string) *ListGatewayServiceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetDescSort(v bool) *ListGatewayServiceShrinkRequest {
	s.DescSort = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetFilterParamsShrink(v string) *ListGatewayServiceShrinkRequest {
	s.FilterParamsShrink = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetOrderItem(v string) *ListGatewayServiceShrinkRequest {
	s.OrderItem = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetPageNumber(v int32) *ListGatewayServiceShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayServiceShrinkRequest) SetPageSize(v int32) *ListGatewayServiceShrinkRequest {
	s.PageSize = &v
	return s
}

type ListGatewayServiceResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *ListGatewayServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewayServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBody) SetCode(v int32) *ListGatewayServiceResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetData(v *ListGatewayServiceResponseBodyData) *ListGatewayServiceResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewayServiceResponseBody) SetHttpStatusCode(v int32) *ListGatewayServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetMessage(v string) *ListGatewayServiceResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetRequestId(v string) *ListGatewayServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewayServiceResponseBody) SetSuccess(v bool) *ListGatewayServiceResponseBody {
	s.Success = &v
	return s
}

type ListGatewayServiceResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned information.
	Result []*ListGatewayServiceResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListGatewayServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyData) SetPageNumber(v int32) *ListGatewayServiceResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListGatewayServiceResponseBodyData) SetPageSize(v int32) *ListGatewayServiceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListGatewayServiceResponseBodyData) SetResult(v []*ListGatewayServiceResponseBodyDataResult) *ListGatewayServiceResponseBodyData {
	s.Result = v
	return s
}

func (s *ListGatewayServiceResponseBodyData) SetTotalSize(v int64) *ListGatewayServiceResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListGatewayServiceResponseBodyDataResult struct {
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic management policy.
	GatewayTrafficPolicy *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty" type:"Struct"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The time when the service was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the service was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The health status.
	//
	// *   Health
	// *   Unhealthy
	// *   Unknown
	HealehStatus *string `json:"HealehStatus,omitempty" xml:"HealehStatus,omitempty"`
	// Indicates whether health checks are performed.
	HealthCheck *bool `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The information about health checks.
	HealthCheckInfo *ListGatewayServiceResponseBodyDataResultHealthCheckInfo `json:"HealthCheckInfo,omitempty" xml:"HealthCheckInfo,omitempty" type:"Struct"`
	// The health status.
	//
	// *   Health
	// *   Unhealthy
	// *   Unknown
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The IP addresses of the service.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The metadata or IP addresses of the service.
	MetaInfo *string `json:"MetaInfo,omitempty" xml:"MetaInfo,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The port array.
	Ports []*int32 `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// The name of the service registered with the service registry.
	ServiceNameInRegistry *string `json:"ServiceNameInRegistry,omitempty" xml:"ServiceNameInRegistry,omitempty"`
	// The service port.
	ServicePort *int64 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The protocol of the service.
	ServiceProtocol *string `json:"ServiceProtocol,omitempty" xml:"ServiceProtocol,omitempty"`
	// The ID of the service source.
	SourceId *int64 `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The array of unhealthy endpoints.
	UnhealthyEndpoints []*string `json:"UnhealthyEndpoints,omitempty" xml:"UnhealthyEndpoints,omitempty" type:"Repeated"`
	// The version of the service.
	Versions []*ListGatewayServiceResponseBodyDataResultVersions `json:"Versions,omitempty" xml:"Versions,omitempty" type:"Repeated"`
}

func (s ListGatewayServiceResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGatewayId(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.GatewayId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGatewayTrafficPolicy(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) *ListGatewayServiceResponseBodyDataResult {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGatewayUniqueId(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGmtCreate(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGmtModified(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetGroupName(v string) *ListGatewayServiceResponseBodyDataResult {
	s.GroupName = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealehStatus(v string) *ListGatewayServiceResponseBodyDataResult {
	s.HealehStatus = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealthCheck(v bool) *ListGatewayServiceResponseBodyDataResult {
	s.HealthCheck = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealthCheckInfo(v *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) *ListGatewayServiceResponseBodyDataResult {
	s.HealthCheckInfo = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetHealthStatus(v string) *ListGatewayServiceResponseBodyDataResult {
	s.HealthStatus = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetId(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetIps(v []*string) *ListGatewayServiceResponseBodyDataResult {
	s.Ips = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetMetaInfo(v string) *ListGatewayServiceResponseBodyDataResult {
	s.MetaInfo = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetName(v string) *ListGatewayServiceResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetNamespace(v string) *ListGatewayServiceResponseBodyDataResult {
	s.Namespace = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetPorts(v []*int32) *ListGatewayServiceResponseBodyDataResult {
	s.Ports = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetServiceNameInRegistry(v string) *ListGatewayServiceResponseBodyDataResult {
	s.ServiceNameInRegistry = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetServicePort(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.ServicePort = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetServiceProtocol(v string) *ListGatewayServiceResponseBodyDataResult {
	s.ServiceProtocol = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetSourceId(v int64) *ListGatewayServiceResponseBodyDataResult {
	s.SourceId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetSourceType(v string) *ListGatewayServiceResponseBodyDataResult {
	s.SourceType = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetUnhealthyEndpoints(v []*string) *ListGatewayServiceResponseBodyDataResult {
	s.UnhealthyEndpoints = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResult) SetVersions(v []*ListGatewayServiceResponseBodyDataResultVersions) *ListGatewayServiceResponseBodyDataResult {
	s.Versions = v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy struct {
	// The load balancing settings.
	LoadBalancerSettings *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings `json:"LoadBalancerSettings,omitempty" xml:"LoadBalancerSettings,omitempty" type:"Struct"`
	// The Transport Layer Security (TLS).
	Tls *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls `json:"Tls,omitempty" xml:"Tls,omitempty" type:"Struct"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) SetLoadBalancerSettings(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy {
	s.LoadBalancerSettings = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy) SetTls(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicy {
	s.Tls = v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings struct {
	// The consistent hashing settings.
	ConsistentHashLBConfig *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig `json:"ConsistentHashLBConfig,omitempty" xml:"ConsistentHashLBConfig,omitempty" type:"Struct"`
	// The load balancing type.
	//
	// *   ROUND_ROBIN
	// *   LEAST_CONN
	// *   RANDOM
	// *   CONSISTENT_HASH
	LoadbalancerType *string `json:"LoadbalancerType,omitempty" xml:"LoadbalancerType,omitempty"`
	// The prefetch time of the least connection load balancing.
	WarmupDuration *int32 `json:"WarmupDuration,omitempty" xml:"WarmupDuration,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) SetConsistentHashLBConfig(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings {
	s.ConsistentHashLBConfig = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) SetLoadbalancerType(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings {
	s.LoadbalancerType = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings) SetWarmupDuration(v int32) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettings {
	s.WarmupDuration = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig struct {
	// The type based on which consistent hashing load balancing is performed.
	//
	// *   HEADER
	// *   COOKIE
	// *   SOURCE_IP
	// *   QUERY_PARAMETER
	ConsistentHashLBType *string `json:"ConsistentHashLBType,omitempty" xml:"ConsistentHashLBType,omitempty"`
	// The cookie-based load balancing parameters.
	HttpCookie *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie `json:"HttpCookie,omitempty" xml:"HttpCookie,omitempty" type:"Struct"`
	// The minimum value of the hash ring.
	MinimumRingSize *int64 `json:"MinimumRingSize,omitempty" xml:"MinimumRingSize,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetConsistentHashLBType(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ConsistentHashLBType = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetHttpCookie(v *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.HttpCookie = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetMinimumRingSize(v int64) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.MinimumRingSize = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig) SetParameterName(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfig {
	s.ParameterName = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie struct {
	// The name of the cookie.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the cookie.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The lifecycle of the cookie.
	Ttl *string `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetName(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Name = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetPath(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Path = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie) SetTtl(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyLoadBalancerSettingsConsistentHashLBConfigHttpCookie {
	s.Ttl = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls struct {
	// The public key of the CA certificate .
	CaCertContent *string `json:"CaCertContent,omitempty" xml:"CaCertContent,omitempty"`
	// The ID of the certification authority (CA) certificate.
	CaCertId *string `json:"CaCertId,omitempty" xml:"CaCertId,omitempty"`
	// The ID of the certificate.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The TLS mode.
	//
	// *   DISABLE
	// *   SIMPLE
	// *   MUTUAL
	// *   ISTIO_MUTUAL
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The Server Name Indication (SNI) value.
	Sni *string `json:"Sni,omitempty" xml:"Sni,omitempty"`
	// The array of subject aliases.
	SubjectAltNames []*string `json:"SubjectAltNames,omitempty" xml:"SubjectAltNames,omitempty" type:"Repeated"`
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetCaCertContent(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.CaCertContent = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetCaCertId(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.CaCertId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetCertId(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.CertId = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetMode(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.Mode = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetSni(v string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.Sni = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls) SetSubjectAltNames(v []*string) *ListGatewayServiceResponseBodyDataResultGatewayTrafficPolicyTls {
	s.SubjectAltNames = v
	return s
}

type ListGatewayServiceResponseBodyDataResultHealthCheckInfo struct {
	// Indicates whether checks are performed.
	Check *bool `json:"Check,omitempty" xml:"Check,omitempty"`
	// The expected status of the health check.
	ExpectedStatuses []*int32 `json:"ExpectedStatuses,omitempty" xml:"ExpectedStatuses,omitempty" type:"Repeated"`
	// The threshold for healthy instances.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The URL of the HTTP request for the health check.
	HttpHost *string `json:"HttpHost,omitempty" xml:"HttpHost,omitempty"`
	// The path to which the HTTP request for the health check is sent.
	HttpPath *string `json:"HttpPath,omitempty" xml:"HttpPath,omitempty"`
	// The health check interval.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The network protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The timeout period.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The threshold for unhealthy instances.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultHealthCheckInfo) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultHealthCheckInfo) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetCheck(v bool) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Check = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetExpectedStatuses(v []*int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.ExpectedStatuses = v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetHealthyThreshold(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.HealthyThreshold = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetHttpHost(v string) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.HttpHost = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetHttpPath(v string) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.HttpPath = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetInterval(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Interval = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetProtocol(v string) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Protocol = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetTimeout(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.Timeout = &v
	return s
}

func (s *ListGatewayServiceResponseBodyDataResultHealthCheckInfo) SetUnhealthyThreshold(v int32) *ListGatewayServiceResponseBodyDataResultHealthCheckInfo {
	s.UnhealthyThreshold = &v
	return s
}

type ListGatewayServiceResponseBodyDataResultVersions struct {
	// The version number.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListGatewayServiceResponseBodyDataResultVersions) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponseBodyDataResultVersions) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponseBodyDataResultVersions) SetName(v string) *ListGatewayServiceResponseBodyDataResultVersions {
	s.Name = &v
	return s
}

type ListGatewayServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewayServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewayServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewayServiceResponse) GoString() string {
	return s.String()
}

func (s *ListGatewayServiceResponse) SetHeaders(v map[string]*string) *ListGatewayServiceResponse {
	s.Headers = v
	return s
}

func (s *ListGatewayServiceResponse) SetStatusCode(v int32) *ListGatewayServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewayServiceResponse) SetBody(v *ListGatewayServiceResponseBody) *ListGatewayServiceResponse {
	s.Body = v
	return s
}

type ListGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbRequest) SetAcceptLanguage(v string) *ListGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListGatewaySlbRequest) SetGatewayUniqueId(v string) *ListGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListGatewaySlbResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*ListGatewaySlbResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbResponseBody) SetCode(v int32) *ListGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetData(v []*ListGatewaySlbResponseBodyData) *ListGatewaySlbResponseBody {
	s.Data = v
	return s
}

func (s *ListGatewaySlbResponseBody) SetHttpStatusCode(v int32) *ListGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetMessage(v string) *ListGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetRequestId(v string) *ListGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGatewaySlbResponseBody) SetSuccess(v bool) *ListGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type ListGatewaySlbResponseBodyData struct {
	// Indicates whether the edit operation is supported.
	EditEnable *bool `json:"EditEnable,omitempty" xml:"EditEnable,omitempty"`
	// The ID of the gateway.
	GatewayId *string `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The mode of the SLB instance.
	GatewaySlbMode *string `json:"GatewaySlbMode,omitempty" xml:"GatewaySlbMode,omitempty"`
	// The association status.
	GatewaySlbStatus *string `json:"GatewaySlbStatus,omitempty" xml:"GatewaySlbStatus,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The port number of the HTTP virtual service group.
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The port number of the HTTPS virtual service group.
	HttpsPort *int32 `json:"HttpsPort,omitempty" xml:"HttpsPort,omitempty"`
	// The ID of the HTTPS virtual service group.
	HttpsVServerGroupId *string `json:"HttpsVServerGroupId,omitempty" xml:"HttpsVServerGroupId,omitempty"`
	// ID
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The service weight.
	ServiceWeight *int32 `json:"ServiceWeight,omitempty" xml:"ServiceWeight,omitempty"`
	// SLB ID
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// SLB IP
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The port number of the SLB instance.
	SlbPort *string `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the HTTP virtual service group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s ListGatewaySlbResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbResponseBodyData) SetEditEnable(v bool) *ListGatewaySlbResponseBodyData {
	s.EditEnable = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGatewayId(v string) *ListGatewaySlbResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGatewaySlbMode(v string) *ListGatewaySlbResponseBodyData {
	s.GatewaySlbMode = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGatewaySlbStatus(v string) *ListGatewaySlbResponseBodyData {
	s.GatewaySlbStatus = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetGmtCreate(v string) *ListGatewaySlbResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetHttpPort(v int32) *ListGatewaySlbResponseBodyData {
	s.HttpPort = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetHttpsPort(v int32) *ListGatewaySlbResponseBodyData {
	s.HttpsPort = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetHttpsVServerGroupId(v string) *ListGatewaySlbResponseBodyData {
	s.HttpsVServerGroupId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetId(v string) *ListGatewaySlbResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetServiceWeight(v int32) *ListGatewaySlbResponseBodyData {
	s.ServiceWeight = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetSlbId(v string) *ListGatewaySlbResponseBodyData {
	s.SlbId = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetSlbIp(v string) *ListGatewaySlbResponseBodyData {
	s.SlbIp = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetSlbPort(v string) *ListGatewaySlbResponseBodyData {
	s.SlbPort = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetStatusDesc(v string) *ListGatewaySlbResponseBodyData {
	s.StatusDesc = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetType(v string) *ListGatewaySlbResponseBodyData {
	s.Type = &v
	return s
}

func (s *ListGatewaySlbResponseBodyData) SetVServerGroupId(v string) *ListGatewaySlbResponseBodyData {
	s.VServerGroupId = &v
	return s
}

type ListGatewaySlbResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *ListGatewaySlbResponse) SetHeaders(v map[string]*string) *ListGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *ListGatewaySlbResponse) SetStatusCode(v int32) *ListGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGatewaySlbResponse) SetBody(v *ListGatewaySlbResponseBody) *ListGatewaySlbResponse {
	s.Body = v
	return s
}

type ListInstanceCountRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values: ZooKeeper and Nacos-Ans.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The edition type of the instance. Valid values:
	//
	// *   `mse_dev`: Developer Edition
	// *   `mse_pro`: Professional Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The ID of the region where the instance resides. Examples:
	//
	// *   cn-hangzhou: China (Hangzhou)
	// *   cn-beijing: China (Beijing)
	// *   cn-shanghai: China (Shanghai)
	// *   cn-zhangjiakou: China (Zhangjiakou)
	// *   cn-shenzhen: China (Shenzhen)
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListInstanceCountRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceCountRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceCountRequest) SetAcceptLanguage(v string) *ListInstanceCountRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListInstanceCountRequest) SetClusterType(v string) *ListInstanceCountRequest {
	s.ClusterType = &v
	return s
}

func (s *ListInstanceCountRequest) SetMseVersion(v string) *ListInstanceCountRequest {
	s.MseVersion = &v
	return s
}

func (s *ListInstanceCountRequest) SetRegionId(v string) *ListInstanceCountRequest {
	s.RegionId = &v
	return s
}

func (s *ListInstanceCountRequest) SetRequestPars(v string) *ListInstanceCountRequest {
	s.RequestPars = &v
	return s
}

type ListInstanceCountResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*int32 `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace `%s` in the `ErrMessage` parameter.
	//
	// > If the return value of the `ErrMessage` parameter is `The Value of Input Parameter %s is not valid` and the return value of the `DynamicMessage` parameter is `DtsJobId`, the specified `DtsJobId` parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed. If the request failed, the ErrorCode parameter is returned. For more information, see the [Error codes](~~456441~~) section of this topic.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned. If the request is successful, a success message is returned. If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListInstanceCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceCountResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceCountResponseBody) SetCode(v int32) *ListInstanceCountResponseBody {
	s.Code = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetData(v []*int32) *ListInstanceCountResponseBody {
	s.Data = v
	return s
}

func (s *ListInstanceCountResponseBody) SetDynamicCode(v string) *ListInstanceCountResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetDynamicMessage(v string) *ListInstanceCountResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetErrorCode(v string) *ListInstanceCountResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetHttpStatusCode(v int32) *ListInstanceCountResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetMessage(v string) *ListInstanceCountResponseBody {
	s.Message = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetRequestId(v string) *ListInstanceCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceCountResponseBody) SetSuccess(v bool) *ListInstanceCountResponseBody {
	s.Success = &v
	return s
}

type ListInstanceCountResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListInstanceCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListInstanceCountResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceCountResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceCountResponse) SetHeaders(v map[string]*string) *ListInstanceCountResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceCountResponse) SetStatusCode(v int32) *ListInstanceCountResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceCountResponse) SetBody(v *ListInstanceCountResponseBody) *ListInstanceCountResponse {
	s.Body = v
	return s
}

type ListListenersByConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListListenersByConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigRequest) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigRequest) SetAcceptLanguage(v string) *ListListenersByConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListListenersByConfigRequest) SetDataId(v string) *ListListenersByConfigRequest {
	s.DataId = &v
	return s
}

func (s *ListListenersByConfigRequest) SetGroup(v string) *ListListenersByConfigRequest {
	s.Group = &v
	return s
}

func (s *ListListenersByConfigRequest) SetInstanceId(v string) *ListListenersByConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *ListListenersByConfigRequest) SetNamespaceId(v string) *ListListenersByConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListListenersByConfigRequest) SetRequestPars(v string) *ListListenersByConfigRequest {
	s.RequestPars = &v
	return s
}

type ListListenersByConfigResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The information about listeners.
	Listeners []*ListListenersByConfigResponseBodyListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Repeated"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListListenersByConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigResponseBody) SetErrorCode(v string) *ListListenersByConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetHttpCode(v string) *ListListenersByConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetListeners(v []*ListListenersByConfigResponseBodyListeners) *ListListenersByConfigResponseBody {
	s.Listeners = v
	return s
}

func (s *ListListenersByConfigResponseBody) SetMessage(v string) *ListListenersByConfigResponseBody {
	s.Message = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetPageNumber(v int32) *ListListenersByConfigResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetPageSize(v int32) *ListListenersByConfigResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetRequestId(v string) *ListListenersByConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetSuccess(v bool) *ListListenersByConfigResponseBody {
	s.Success = &v
	return s
}

func (s *ListListenersByConfigResponseBody) SetTotalCount(v int32) *ListListenersByConfigResponseBody {
	s.TotalCount = &v
	return s
}

type ListListenersByConfigResponseBodyListeners struct {
	// The IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The verification string.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListListenersByConfigResponseBodyListeners) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigResponseBodyListeners) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigResponseBodyListeners) SetIp(v string) *ListListenersByConfigResponseBodyListeners {
	s.Ip = &v
	return s
}

func (s *ListListenersByConfigResponseBodyListeners) SetMd5(v string) *ListListenersByConfigResponseBodyListeners {
	s.Md5 = &v
	return s
}

func (s *ListListenersByConfigResponseBodyListeners) SetStatus(v string) *ListListenersByConfigResponseBodyListeners {
	s.Status = &v
	return s
}

type ListListenersByConfigResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListListenersByConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListListenersByConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByConfigResponse) GoString() string {
	return s.String()
}

func (s *ListListenersByConfigResponse) SetHeaders(v map[string]*string) *ListListenersByConfigResponse {
	s.Headers = v
	return s
}

func (s *ListListenersByConfigResponse) SetStatusCode(v int32) *ListListenersByConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ListListenersByConfigResponse) SetBody(v *ListListenersByConfigResponseBody) *ListListenersByConfigResponse {
	s.Body = v
	return s
}

type ListListenersByIpRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the listener.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListListenersByIpRequest) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpRequest) GoString() string {
	return s.String()
}

func (s *ListListenersByIpRequest) SetAcceptLanguage(v string) *ListListenersByIpRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListListenersByIpRequest) SetInstanceId(v string) *ListListenersByIpRequest {
	s.InstanceId = &v
	return s
}

func (s *ListListenersByIpRequest) SetIp(v string) *ListListenersByIpRequest {
	s.Ip = &v
	return s
}

func (s *ListListenersByIpRequest) SetNamespaceId(v string) *ListListenersByIpRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListListenersByIpRequest) SetRequestPars(v string) *ListListenersByIpRequest {
	s.RequestPars = &v
	return s
}

type ListListenersByIpResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The information about listeners.
	Listeners []*ListListenersByIpResponseBodyListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Repeated"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListListenersByIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpResponseBody) GoString() string {
	return s.String()
}

func (s *ListListenersByIpResponseBody) SetErrorCode(v string) *ListListenersByIpResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetHttpCode(v string) *ListListenersByIpResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetListeners(v []*ListListenersByIpResponseBodyListeners) *ListListenersByIpResponseBody {
	s.Listeners = v
	return s
}

func (s *ListListenersByIpResponseBody) SetMessage(v string) *ListListenersByIpResponseBody {
	s.Message = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetPageNumber(v int32) *ListListenersByIpResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetPageSize(v int32) *ListListenersByIpResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetRequestId(v string) *ListListenersByIpResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetSuccess(v bool) *ListListenersByIpResponseBody {
	s.Success = &v
	return s
}

func (s *ListListenersByIpResponseBody) SetTotalCount(v int32) *ListListenersByIpResponseBody {
	s.TotalCount = &v
	return s
}

type ListListenersByIpResponseBodyListeners struct {
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The verification string.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
}

func (s ListListenersByIpResponseBodyListeners) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpResponseBodyListeners) GoString() string {
	return s.String()
}

func (s *ListListenersByIpResponseBodyListeners) SetDataId(v string) *ListListenersByIpResponseBodyListeners {
	s.DataId = &v
	return s
}

func (s *ListListenersByIpResponseBodyListeners) SetGroup(v string) *ListListenersByIpResponseBodyListeners {
	s.Group = &v
	return s
}

func (s *ListListenersByIpResponseBodyListeners) SetMd5(v string) *ListListenersByIpResponseBodyListeners {
	s.Md5 = &v
	return s
}

type ListListenersByIpResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListListenersByIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListListenersByIpResponse) String() string {
	return tea.Prettify(s)
}

func (s ListListenersByIpResponse) GoString() string {
	return s.String()
}

func (s *ListListenersByIpResponse) SetHeaders(v map[string]*string) *ListListenersByIpResponse {
	s.Headers = v
	return s
}

func (s *ListListenersByIpResponse) SetStatusCode(v int32) *ListListenersByIpResponse {
	s.StatusCode = &v
	return s
}

func (s *ListListenersByIpResponse) SetBody(v *ListListenersByIpResponseBody) *ListListenersByIpResponse {
	s.Body = v
	return s
}

type ListMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskRequest) SetAcceptLanguage(v string) *ListMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListMigrationTaskRequest) SetOriginInstanceName(v string) *ListMigrationTaskRequest {
	s.OriginInstanceName = &v
	return s
}

func (s *ListMigrationTaskRequest) SetPageNum(v int64) *ListMigrationTaskRequest {
	s.PageNum = &v
	return s
}

func (s *ListMigrationTaskRequest) SetPageSize(v int64) *ListMigrationTaskRequest {
	s.PageSize = &v
	return s
}

func (s *ListMigrationTaskRequest) SetRequestPars(v string) *ListMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

type ListMigrationTaskResponseBody struct {
	// The array structure.
	Data []*ListMigrationTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskResponseBody) SetData(v []*ListMigrationTaskResponseBodyData) *ListMigrationTaskResponseBody {
	s.Data = v
	return s
}

func (s *ListMigrationTaskResponseBody) SetErrorCode(v string) *ListMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetHttpCode(v string) *ListMigrationTaskResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetMessage(v string) *ListMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetPageNumber(v int64) *ListMigrationTaskResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetPageSize(v int64) *ListMigrationTaskResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetRequestId(v string) *ListMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetSuccess(v bool) *ListMigrationTaskResponseBody {
	s.Success = &v
	return s
}

func (s *ListMigrationTaskResponseBody) SetTotalCount(v int64) *ListMigrationTaskResponseBody {
	s.TotalCount = &v
	return s
}

type ListMigrationTaskResponseBodyData struct {
	// The type of the instance.
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the task.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The address of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListMigrationTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskResponseBodyData) SetClusterType(v string) *ListMigrationTaskResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetGmtCreate(v string) *ListMigrationTaskResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetGmtModified(v string) *ListMigrationTaskResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetId(v int64) *ListMigrationTaskResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetOriginInstanceAddress(v string) *ListMigrationTaskResponseBodyData {
	s.OriginInstanceAddress = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetOriginInstanceName(v string) *ListMigrationTaskResponseBodyData {
	s.OriginInstanceName = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetOriginInstanceNamespace(v string) *ListMigrationTaskResponseBodyData {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetProjectDesc(v string) *ListMigrationTaskResponseBodyData {
	s.ProjectDesc = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetTargetClusterName(v string) *ListMigrationTaskResponseBodyData {
	s.TargetClusterName = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetTargetClusterUrl(v string) *ListMigrationTaskResponseBodyData {
	s.TargetClusterUrl = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetTargetInstanceId(v string) *ListMigrationTaskResponseBodyData {
	s.TargetInstanceId = &v
	return s
}

func (s *ListMigrationTaskResponseBodyData) SetUserId(v string) *ListMigrationTaskResponseBodyData {
	s.UserId = &v
	return s
}

type ListMigrationTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *ListMigrationTaskResponse) SetHeaders(v map[string]*string) *ListMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *ListMigrationTaskResponse) SetStatusCode(v int32) *ListMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMigrationTaskResponse) SetBody(v *ListMigrationTaskResponseBody) *ListMigrationTaskResponse {
	s.Body = v
	return s
}

type ListNacosConfigsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the group. Default value: `default`
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters. The JSON format is supported.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The tags.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListNacosConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsRequest) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsRequest) SetAcceptLanguage(v string) *ListNacosConfigsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListNacosConfigsRequest) SetAppName(v string) *ListNacosConfigsRequest {
	s.AppName = &v
	return s
}

func (s *ListNacosConfigsRequest) SetDataId(v string) *ListNacosConfigsRequest {
	s.DataId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetGroup(v string) *ListNacosConfigsRequest {
	s.Group = &v
	return s
}

func (s *ListNacosConfigsRequest) SetInstanceId(v string) *ListNacosConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetNamespaceId(v string) *ListNacosConfigsRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetPageNum(v int32) *ListNacosConfigsRequest {
	s.PageNum = &v
	return s
}

func (s *ListNacosConfigsRequest) SetPageSize(v int32) *ListNacosConfigsRequest {
	s.PageSize = &v
	return s
}

func (s *ListNacosConfigsRequest) SetRegionId(v string) *ListNacosConfigsRequest {
	s.RegionId = &v
	return s
}

func (s *ListNacosConfigsRequest) SetRequestPars(v string) *ListNacosConfigsRequest {
	s.RequestPars = &v
	return s
}

func (s *ListNacosConfigsRequest) SetTags(v string) *ListNacosConfigsRequest {
	s.Tags = &v
	return s
}

type ListNacosConfigsResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The configurations.
	Configurations []*ListNacosConfigsResponseBodyConfigurations `json:"Configurations,omitempty" xml:"Configurations,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListNacosConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsResponseBody) SetCode(v int32) *ListNacosConfigsResponseBody {
	s.Code = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetConfigurations(v []*ListNacosConfigsResponseBodyConfigurations) *ListNacosConfigsResponseBody {
	s.Configurations = v
	return s
}

func (s *ListNacosConfigsResponseBody) SetErrorCode(v string) *ListNacosConfigsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetHttpCode(v string) *ListNacosConfigsResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetMessage(v string) *ListNacosConfigsResponseBody {
	s.Message = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetPageNumber(v int32) *ListNacosConfigsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetPageSize(v int32) *ListNacosConfigsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetRequestId(v string) *ListNacosConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetSuccess(v bool) *ListNacosConfigsResponseBody {
	s.Success = &v
	return s
}

func (s *ListNacosConfigsResponseBody) SetTotalCount(v int32) *ListNacosConfigsResponseBody {
	s.TotalCount = &v
	return s
}

type ListNacosConfigsResponseBodyConfigurations struct {
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the configuration.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The ID of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the application.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s ListNacosConfigsResponseBodyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsResponseBodyConfigurations) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetAppName(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.AppName = &v
	return s
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetDataId(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.DataId = &v
	return s
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetGroup(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.Group = &v
	return s
}

func (s *ListNacosConfigsResponseBodyConfigurations) SetId(v string) *ListNacosConfigsResponseBodyConfigurations {
	s.Id = &v
	return s
}

type ListNacosConfigsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNacosConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNacosConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNacosConfigsResponse) GoString() string {
	return s.String()
}

func (s *ListNacosConfigsResponse) SetHeaders(v map[string]*string) *ListNacosConfigsResponse {
	s.Headers = v
	return s
}

func (s *ListNacosConfigsResponse) SetStatusCode(v int32) *ListNacosConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNacosConfigsResponse) SetBody(v *ListNacosConfigsResponseBody) *ListNacosConfigsResponse {
	s.Body = v
	return s
}

type ListNacosHistoryConfigsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the configuration group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region in which the instance resides. The region is supported by Microservices Engine (MSE).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s ListNacosHistoryConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsRequest) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsRequest) SetAcceptLanguage(v string) *ListNacosHistoryConfigsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetDataId(v string) *ListNacosHistoryConfigsRequest {
	s.DataId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetGroup(v string) *ListNacosHistoryConfigsRequest {
	s.Group = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetInstanceId(v string) *ListNacosHistoryConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetNamespaceId(v string) *ListNacosHistoryConfigsRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetPageNum(v int32) *ListNacosHistoryConfigsRequest {
	s.PageNum = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetPageSize(v int32) *ListNacosHistoryConfigsRequest {
	s.PageSize = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetRegionId(v string) *ListNacosHistoryConfigsRequest {
	s.RegionId = &v
	return s
}

func (s *ListNacosHistoryConfigsRequest) SetRequestPars(v string) *ListNacosHistoryConfigsRequest {
	s.RequestPars = &v
	return s
}

type ListNacosHistoryConfigsResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The configuration items.
	HistoryItems []*ListNacosHistoryConfigsResponseBodyHistoryItems `json:"HistoryItems,omitempty" xml:"HistoryItems,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListNacosHistoryConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsResponseBody) SetErrorCode(v string) *ListNacosHistoryConfigsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetHistoryItems(v []*ListNacosHistoryConfigsResponseBodyHistoryItems) *ListNacosHistoryConfigsResponseBody {
	s.HistoryItems = v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetHttpCode(v string) *ListNacosHistoryConfigsResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetMessage(v string) *ListNacosHistoryConfigsResponseBody {
	s.Message = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetPageNumber(v int32) *ListNacosHistoryConfigsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetPageSize(v int32) *ListNacosHistoryConfigsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetRequestId(v string) *ListNacosHistoryConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetSuccess(v bool) *ListNacosHistoryConfigsResponseBody {
	s.Success = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBody) SetTotalCount(v int32) *ListNacosHistoryConfigsResponseBody {
	s.TotalCount = &v
	return s
}

type ListNacosHistoryConfigsResponseBodyHistoryItems struct {
	// The tags of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the data.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The name of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timestamp when the configuration was last modified.
	LastModifiedTime *int64 `json:"LastModifiedTime,omitempty" xml:"LastModifiedTime,omitempty"`
	// The type of the configuration file.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
}

func (s ListNacosHistoryConfigsResponseBodyHistoryItems) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsResponseBodyHistoryItems) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetAppName(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.AppName = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetDataId(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.DataId = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetGroup(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.Group = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetId(v int64) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.Id = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetLastModifiedTime(v int64) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.LastModifiedTime = &v
	return s
}

func (s *ListNacosHistoryConfigsResponseBodyHistoryItems) SetOpType(v string) *ListNacosHistoryConfigsResponseBodyHistoryItems {
	s.OpType = &v
	return s
}

type ListNacosHistoryConfigsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNacosHistoryConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNacosHistoryConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNacosHistoryConfigsResponse) GoString() string {
	return s.String()
}

func (s *ListNacosHistoryConfigsResponse) SetHeaders(v map[string]*string) *ListNacosHistoryConfigsResponse {
	s.Headers = v
	return s
}

func (s *ListNacosHistoryConfigsResponse) SetStatusCode(v int32) *ListNacosHistoryConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNacosHistoryConfigsResponse) SetBody(v *ListNacosHistoryConfigsResponseBody) *ListNacosHistoryConfigsResponse {
	s.Body = v
	return s
}

type ListNamingTrackRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The end timestamp. Unit: seconds.
	EndTs *int64 `json:"EndTs,omitempty" xml:"EndTs,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the client.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
	//
	// *   `true`: sorts the query results in reverse chronological order.
	// *   `false`: sorts the query results in chronological order.
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The start timestamp. Unit: seconds.
	StartTs *int64 `json:"StartTs,omitempty" xml:"StartTs,omitempty"`
}

func (s ListNamingTrackRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackRequest) GoString() string {
	return s.String()
}

func (s *ListNamingTrackRequest) SetAcceptLanguage(v string) *ListNamingTrackRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListNamingTrackRequest) SetEndTs(v int64) *ListNamingTrackRequest {
	s.EndTs = &v
	return s
}

func (s *ListNamingTrackRequest) SetGroup(v string) *ListNamingTrackRequest {
	s.Group = &v
	return s
}

func (s *ListNamingTrackRequest) SetInstanceId(v string) *ListNamingTrackRequest {
	s.InstanceId = &v
	return s
}

func (s *ListNamingTrackRequest) SetIp(v string) *ListNamingTrackRequest {
	s.Ip = &v
	return s
}

func (s *ListNamingTrackRequest) SetNamespaceId(v string) *ListNamingTrackRequest {
	s.NamespaceId = &v
	return s
}

func (s *ListNamingTrackRequest) SetPageNum(v int64) *ListNamingTrackRequest {
	s.PageNum = &v
	return s
}

func (s *ListNamingTrackRequest) SetPageSize(v int64) *ListNamingTrackRequest {
	s.PageSize = &v
	return s
}

func (s *ListNamingTrackRequest) SetRequestPars(v string) *ListNamingTrackRequest {
	s.RequestPars = &v
	return s
}

func (s *ListNamingTrackRequest) SetReverse(v bool) *ListNamingTrackRequest {
	s.Reverse = &v
	return s
}

func (s *ListNamingTrackRequest) SetServiceName(v string) *ListNamingTrackRequest {
	s.ServiceName = &v
	return s
}

func (s *ListNamingTrackRequest) SetStartTs(v int64) *ListNamingTrackRequest {
	s.StartTs = &v
	return s
}

type ListNamingTrackResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned entries.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The data information.
	Traces []*ListNamingTrackResponseBodyTraces `json:"Traces,omitempty" xml:"Traces,omitempty" type:"Repeated"`
}

func (s ListNamingTrackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackResponseBody) GoString() string {
	return s.String()
}

func (s *ListNamingTrackResponseBody) SetErrorCode(v string) *ListNamingTrackResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetHttpCode(v string) *ListNamingTrackResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetMessage(v string) *ListNamingTrackResponseBody {
	s.Message = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetPageNumber(v int64) *ListNamingTrackResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetPageSize(v int64) *ListNamingTrackResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetRequestId(v string) *ListNamingTrackResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetSuccess(v bool) *ListNamingTrackResponseBody {
	s.Success = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetTotalCount(v int64) *ListNamingTrackResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListNamingTrackResponseBody) SetTraces(v []*ListNamingTrackResponseBodyTraces) *ListNamingTrackResponseBody {
	s.Traces = v
	return s
}

type ListNamingTrackResponseBodyTraces struct {
	// The IP address of the client.
	ClientIp *string `json:"ClientIp,omitempty" xml:"ClientIp,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The number of instances.
	InstanceSize *string `json:"InstanceSize,omitempty" xml:"InstanceSize,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The push time.
	PushTime *string `json:"PushTime,omitempty" xml:"PushTime,omitempty"`
	// The total push time.
	PushTimeAll *string `json:"PushTimeAll,omitempty" xml:"PushTimeAll,omitempty"`
	// The push time for the network.
	PushTimeNetwork *string `json:"PushTimeNetwork,omitempty" xml:"PushTimeNetwork,omitempty"`
	// The name of the service.
	ServerName *string `json:"ServerName,omitempty" xml:"ServerName,omitempty"`
	// The duration that is specified in the service-level agreement (SLA).
	SlaTime *string `json:"SlaTime,omitempty" xml:"SlaTime,omitempty"`
}

func (s ListNamingTrackResponseBodyTraces) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackResponseBodyTraces) GoString() string {
	return s.String()
}

func (s *ListNamingTrackResponseBodyTraces) SetClientIp(v string) *ListNamingTrackResponseBodyTraces {
	s.ClientIp = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetGroup(v string) *ListNamingTrackResponseBodyTraces {
	s.Group = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetInstanceSize(v string) *ListNamingTrackResponseBodyTraces {
	s.InstanceSize = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetNodeName(v string) *ListNamingTrackResponseBodyTraces {
	s.NodeName = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetPushTime(v string) *ListNamingTrackResponseBodyTraces {
	s.PushTime = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetPushTimeAll(v string) *ListNamingTrackResponseBodyTraces {
	s.PushTimeAll = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetPushTimeNetwork(v string) *ListNamingTrackResponseBodyTraces {
	s.PushTimeNetwork = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetServerName(v string) *ListNamingTrackResponseBodyTraces {
	s.ServerName = &v
	return s
}

func (s *ListNamingTrackResponseBodyTraces) SetSlaTime(v string) *ListNamingTrackResponseBodyTraces {
	s.SlaTime = &v
	return s
}

type ListNamingTrackResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNamingTrackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNamingTrackResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNamingTrackResponse) GoString() string {
	return s.String()
}

func (s *ListNamingTrackResponse) SetHeaders(v map[string]*string) *ListNamingTrackResponse {
	s.Headers = v
	return s
}

func (s *ListNamingTrackResponse) SetStatusCode(v int32) *ListNamingTrackResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNamingTrackResponse) SetBody(v *ListNamingTrackResponseBody) *ListNamingTrackResponse {
	s.Body = v
	return s
}

type ListSSLCertRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListSSLCertRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertRequest) GoString() string {
	return s.String()
}

func (s *ListSSLCertRequest) SetAcceptLanguage(v string) *ListSSLCertRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListSSLCertRequest) SetGatewayUniqueId(v string) *ListSSLCertRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListSSLCertResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*ListSSLCertResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSSLCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertResponseBody) GoString() string {
	return s.String()
}

func (s *ListSSLCertResponseBody) SetCode(v int32) *ListSSLCertResponseBody {
	s.Code = &v
	return s
}

func (s *ListSSLCertResponseBody) SetData(v []*ListSSLCertResponseBodyData) *ListSSLCertResponseBody {
	s.Data = v
	return s
}

func (s *ListSSLCertResponseBody) SetHttpStatusCode(v int32) *ListSSLCertResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListSSLCertResponseBody) SetMessage(v string) *ListSSLCertResponseBody {
	s.Message = &v
	return s
}

func (s *ListSSLCertResponseBody) SetRequestId(v string) *ListSSLCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSSLCertResponseBody) SetSuccess(v bool) *ListSSLCertResponseBody {
	s.Success = &v
	return s
}

type ListSSLCertResponseBodyData struct {
	// The validation time.
	AfterDate *string `json:"AfterDate,omitempty" xml:"AfterDate,omitempty"`
	// The algorithm.
	Algorithm *string `json:"Algorithm,omitempty" xml:"Algorithm,omitempty"`
	// The expiration time.
	BeforeDate *string `json:"BeforeDate,omitempty" xml:"BeforeDate,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The domain name with which the certificate is associated.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The validation time.
	GmtAfter *string `json:"GmtAfter,omitempty" xml:"GmtAfter,omitempty"`
	// The expiration time.
	GmtBefore *string `json:"GmtBefore,omitempty" xml:"GmtBefore,omitempty"`
	// The issuer.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The SSL certificate.
	Sans *string `json:"Sans,omitempty" xml:"Sans,omitempty"`
}

func (s ListSSLCertResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSSLCertResponseBodyData) SetAfterDate(v string) *ListSSLCertResponseBodyData {
	s.AfterDate = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetAlgorithm(v string) *ListSSLCertResponseBodyData {
	s.Algorithm = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetBeforeDate(v string) *ListSSLCertResponseBodyData {
	s.BeforeDate = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetCertIdentifier(v string) *ListSSLCertResponseBodyData {
	s.CertIdentifier = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetCertName(v string) *ListSSLCertResponseBodyData {
	s.CertName = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetCommonName(v string) *ListSSLCertResponseBodyData {
	s.CommonName = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetGmtAfter(v string) *ListSSLCertResponseBodyData {
	s.GmtAfter = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetGmtBefore(v string) *ListSSLCertResponseBodyData {
	s.GmtBefore = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetIssuer(v string) *ListSSLCertResponseBodyData {
	s.Issuer = &v
	return s
}

func (s *ListSSLCertResponseBodyData) SetSans(v string) *ListSSLCertResponseBodyData {
	s.Sans = &v
	return s
}

type ListSSLCertResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSSLCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSSLCertResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSSLCertResponse) GoString() string {
	return s.String()
}

func (s *ListSSLCertResponse) SetHeaders(v map[string]*string) *ListSSLCertResponse {
	s.Headers = v
	return s
}

func (s *ListSSLCertResponse) SetStatusCode(v int32) *ListSSLCertResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSSLCertResponse) SetBody(v *ListSSLCertResponseBody) *ListSSLCertResponse {
	s.Body = v
	return s
}

type ListSecurityGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListSecurityGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRequest) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRequest) SetAcceptLanguage(v string) *ListSecurityGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListSecurityGroupRequest) SetGatewayUniqueId(v string) *ListSecurityGroupRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListSecurityGroupResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*ListSecurityGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSecurityGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupResponseBody) SetCode(v int32) *ListSecurityGroupResponseBody {
	s.Code = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetData(v []*ListSecurityGroupResponseBodyData) *ListSecurityGroupResponseBody {
	s.Data = v
	return s
}

func (s *ListSecurityGroupResponseBody) SetHttpStatusCode(v int32) *ListSecurityGroupResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetMessage(v string) *ListSecurityGroupResponseBody {
	s.Message = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetRequestId(v string) *ListSecurityGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSecurityGroupResponseBody) SetSuccess(v bool) *ListSecurityGroupResponseBody {
	s.Success = &v
	return s
}

type ListSecurityGroupResponseBodyData struct {
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The name of the security group.
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
	// The type of the security group. Valid values:
	//
	// *   normal: basic security group
	// *   enterprise: advanced security group. For more information, see [Advanced security groups](~~120621~~).
	SecurityGroupType *string `json:"SecurityGroupType,omitempty" xml:"SecurityGroupType,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListSecurityGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupResponseBodyData) SetSecurityGroupId(v string) *ListSecurityGroupResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

func (s *ListSecurityGroupResponseBodyData) SetSecurityGroupName(v string) *ListSecurityGroupResponseBodyData {
	s.SecurityGroupName = &v
	return s
}

func (s *ListSecurityGroupResponseBodyData) SetSecurityGroupType(v string) *ListSecurityGroupResponseBodyData {
	s.SecurityGroupType = &v
	return s
}

func (s *ListSecurityGroupResponseBodyData) SetVpcId(v string) *ListSecurityGroupResponseBodyData {
	s.VpcId = &v
	return s
}

type ListSecurityGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSecurityGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSecurityGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupResponse) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupResponse) SetHeaders(v map[string]*string) *ListSecurityGroupResponse {
	s.Headers = v
	return s
}

func (s *ListSecurityGroupResponse) SetStatusCode(v int32) *ListSecurityGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSecurityGroupResponse) SetBody(v *ListSecurityGroupResponseBody) *ListSecurityGroupResponse {
	s.Body = v
	return s
}

type ListSecurityGroupRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListSecurityGroupRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleRequest) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleRequest) SetAcceptLanguage(v string) *ListSecurityGroupRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListSecurityGroupRuleRequest) SetGatewayUniqueId(v string) *ListSecurityGroupRuleRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListSecurityGroupRuleResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*ListSecurityGroupRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSecurityGroupRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleResponseBody) SetCode(v int32) *ListSecurityGroupRuleResponseBody {
	s.Code = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetData(v []*ListSecurityGroupRuleResponseBodyData) *ListSecurityGroupRuleResponseBody {
	s.Data = v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetHttpStatusCode(v int32) *ListSecurityGroupRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetMessage(v string) *ListSecurityGroupRuleResponseBody {
	s.Message = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetRequestId(v string) *ListSecurityGroupRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBody) SetSuccess(v bool) *ListSecurityGroupRuleResponseBody {
	s.Success = &v
	return s
}

type ListSecurityGroupRuleResponseBodyData struct {
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last modification time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The protocol type.
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The port range.
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
}

func (s ListSecurityGroupRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleResponseBodyData) SetDescription(v string) *ListSecurityGroupRuleResponseBodyData {
	s.Description = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGatewayId(v int64) *ListSecurityGroupRuleResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGatewayUniqueId(v string) *ListSecurityGroupRuleResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGmtCreate(v string) *ListSecurityGroupRuleResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetGmtModified(v string) *ListSecurityGroupRuleResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetId(v string) *ListSecurityGroupRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetIpProtocol(v string) *ListSecurityGroupRuleResponseBodyData {
	s.IpProtocol = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetPortRange(v string) *ListSecurityGroupRuleResponseBodyData {
	s.PortRange = &v
	return s
}

func (s *ListSecurityGroupRuleResponseBodyData) SetSecurityGroupId(v string) *ListSecurityGroupRuleResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

type ListSecurityGroupRuleResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSecurityGroupRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSecurityGroupRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSecurityGroupRuleResponse) GoString() string {
	return s.String()
}

func (s *ListSecurityGroupRuleResponse) SetHeaders(v map[string]*string) *ListSecurityGroupRuleResponse {
	s.Headers = v
	return s
}

func (s *ListSecurityGroupRuleResponse) SetStatusCode(v int32) *ListSecurityGroupRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSecurityGroupRuleResponse) SetBody(v *ListSecurityGroupRuleResponseBody) *ListSecurityGroupRuleResponse {
	s.Body = v
	return s
}

type ListServiceSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s ListServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *ListServiceSourceRequest) SetAcceptLanguage(v string) *ListServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListServiceSourceRequest) SetGatewayUniqueId(v string) *ListServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

type ListServiceSourceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*ListServiceSourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponseBody) SetCode(v int32) *ListServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetData(v []*ListServiceSourceResponseBodyData) *ListServiceSourceResponseBody {
	s.Data = v
	return s
}

func (s *ListServiceSourceResponseBody) SetHttpStatusCode(v int32) *ListServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetMessage(v string) *ListServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetRequestId(v string) *ListServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListServiceSourceResponseBody) SetSuccess(v bool) *ListServiceSourceResponseBody {
	s.Success = &v
	return s
}

type ListServiceSourceResponseBodyData struct {
	// The ID of the Container Service for Kubernetes (ACK) cluster or the endpoint of the Microservices Engine (MSE) registry.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// Indicates whether the service source is associated with the gateway. The value 1 indicates that the service source is associated with the gateway.
	BindingWithGateway *int32 `json:"BindingWithGateway,omitempty" xml:"BindingWithGateway,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The array of service groups.
	GroupList []*string `json:"GroupList,omitempty" xml:"GroupList,omitempty" type:"Repeated"`
	// The ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether Ingress is supported for applications.
	IngressOptions *ListServiceSourceResponseBodyDataIngressOptions `json:"IngressOptions,omitempty" xml:"IngressOptions,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The array of root paths of service lists.
	PathList []*string `json:"PathList,omitempty" xml:"PathList,omitempty" type:"Repeated"`
	// The type of the service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The unique ID of the service source.
	SourceUniqueId *string `json:"SourceUniqueId,omitempty" xml:"SourceUniqueId,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListServiceSourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponseBodyData) SetAddress(v string) *ListServiceSourceResponseBodyData {
	s.Address = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetBindingWithGateway(v int32) *ListServiceSourceResponseBodyData {
	s.BindingWithGateway = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGatewayId(v int64) *ListServiceSourceResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGatewayUniqueId(v string) *ListServiceSourceResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGmtCreate(v string) *ListServiceSourceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGmtModified(v string) *ListServiceSourceResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetGroupList(v []*string) *ListServiceSourceResponseBodyData {
	s.GroupList = v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetId(v int64) *ListServiceSourceResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetIngressOptions(v *ListServiceSourceResponseBodyDataIngressOptions) *ListServiceSourceResponseBodyData {
	s.IngressOptions = v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetName(v string) *ListServiceSourceResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetPathList(v []*string) *ListServiceSourceResponseBodyData {
	s.PathList = v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetSource(v string) *ListServiceSourceResponseBodyData {
	s.Source = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetSourceUniqueId(v string) *ListServiceSourceResponseBodyData {
	s.SourceUniqueId = &v
	return s
}

func (s *ListServiceSourceResponseBodyData) SetType(v string) *ListServiceSourceResponseBodyData {
	s.Type = &v
	return s
}

type ListServiceSourceResponseBodyDataIngressOptions struct {
	// Indicates whether Ingress is enabled.
	EnableIngress *bool `json:"EnableIngress,omitempty" xml:"EnableIngress,omitempty"`
	// Indicates whether the Ingress status is updated.
	EnableStatus *bool `json:"EnableStatus,omitempty" xml:"EnableStatus,omitempty"`
	// The Ingress class.
	IngressClass *string `json:"IngressClass,omitempty" xml:"IngressClass,omitempty"`
	// The namespace that you want to monitor.
	WatchNamespace *string `json:"WatchNamespace,omitempty" xml:"WatchNamespace,omitempty"`
}

func (s ListServiceSourceResponseBodyDataIngressOptions) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponseBodyDataIngressOptions) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetEnableIngress(v bool) *ListServiceSourceResponseBodyDataIngressOptions {
	s.EnableIngress = &v
	return s
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetEnableStatus(v bool) *ListServiceSourceResponseBodyDataIngressOptions {
	s.EnableStatus = &v
	return s
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetIngressClass(v string) *ListServiceSourceResponseBodyDataIngressOptions {
	s.IngressClass = &v
	return s
}

func (s *ListServiceSourceResponseBodyDataIngressOptions) SetWatchNamespace(v string) *ListServiceSourceResponseBodyDataIngressOptions {
	s.WatchNamespace = &v
	return s
}

type ListServiceSourceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *ListServiceSourceResponse) SetHeaders(v map[string]*string) *ListServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *ListServiceSourceResponse) SetStatusCode(v int32) *ListServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListServiceSourceResponse) SetBody(v *ListServiceSourceResponseBody) *ListServiceSourceResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The token that is required for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs. You can specify a maximum of 50 resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resources. Valid values:
	//
	// *   CLUSTER: MSE instance
	// *   GATEWAY: cloud-native gateway
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tags. You can specify a maximum of 20 tags.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetAcceptLanguage(v string) *ListTagResourcesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The key of a tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of a tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The token that is required for the next query. If the NextToken parameter is empty, no subsequent query is required.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The list of resources.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetErrorCode(v string) *ListTagResourcesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetMessage(v string) *ListTagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetSuccess(v bool) *ListTagResourcesResponseBody {
	s.Success = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of a resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of a resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of a tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of a tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListZkTrackRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The end timestamp. Unit: seconds.
	EndTs *int64 `json:"EndTs,omitempty" xml:"EndTs,omitempty"`
	// The instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return.
	PageNum *int64 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The request parameters.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// Specifies whether to enable reverse ordering.
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The session ID.
	SessionId *string `json:"SessionId,omitempty" xml:"SessionId,omitempty"`
	// The start timestamp. Unit: seconds.
	StartTs *int64 `json:"StartTs,omitempty" xml:"StartTs,omitempty"`
}

func (s ListZkTrackRequest) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackRequest) GoString() string {
	return s.String()
}

func (s *ListZkTrackRequest) SetAcceptLanguage(v string) *ListZkTrackRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListZkTrackRequest) SetEndTs(v int64) *ListZkTrackRequest {
	s.EndTs = &v
	return s
}

func (s *ListZkTrackRequest) SetInstanceId(v string) *ListZkTrackRequest {
	s.InstanceId = &v
	return s
}

func (s *ListZkTrackRequest) SetPageNum(v int64) *ListZkTrackRequest {
	s.PageNum = &v
	return s
}

func (s *ListZkTrackRequest) SetPageSize(v int64) *ListZkTrackRequest {
	s.PageSize = &v
	return s
}

func (s *ListZkTrackRequest) SetPath(v string) *ListZkTrackRequest {
	s.Path = &v
	return s
}

func (s *ListZkTrackRequest) SetRequestPars(v string) *ListZkTrackRequest {
	s.RequestPars = &v
	return s
}

func (s *ListZkTrackRequest) SetReverse(v bool) *ListZkTrackRequest {
	s.Reverse = &v
	return s
}

func (s *ListZkTrackRequest) SetSessionId(v string) *ListZkTrackRequest {
	s.SessionId = &v
	return s
}

func (s *ListZkTrackRequest) SetStartTs(v int64) *ListZkTrackRequest {
	s.StartTs = &v
	return s
}

type ListZkTrackResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The track data.
	Traces []*ListZkTrackResponseBodyTraces `json:"Traces,omitempty" xml:"Traces,omitempty" type:"Repeated"`
}

func (s ListZkTrackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackResponseBody) GoString() string {
	return s.String()
}

func (s *ListZkTrackResponseBody) SetErrorCode(v string) *ListZkTrackResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListZkTrackResponseBody) SetHttpCode(v string) *ListZkTrackResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ListZkTrackResponseBody) SetMessage(v string) *ListZkTrackResponseBody {
	s.Message = &v
	return s
}

func (s *ListZkTrackResponseBody) SetPageNumber(v int64) *ListZkTrackResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListZkTrackResponseBody) SetPageSize(v int64) *ListZkTrackResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListZkTrackResponseBody) SetRequestId(v string) *ListZkTrackResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListZkTrackResponseBody) SetSuccess(v bool) *ListZkTrackResponseBody {
	s.Success = &v
	return s
}

func (s *ListZkTrackResponseBody) SetTotalCount(v int64) *ListZkTrackResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListZkTrackResponseBody) SetTraces(v []*ListZkTrackResponseBodyTraces) *ListZkTrackResponseBody {
	s.Traces = v
	return s
}

type ListZkTrackResponseBodyTraces struct {
	// The access control list (ACL).
	Acl *string `json:"Acl,omitempty" xml:"Acl,omitempty"`
	// The data type. Valid values:
	//
	// *   persist
	// *   ephemeral
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The type of the event. For tracks of the Notify type:
	//
	// *   NodeCreated
	// *   NodeDeleted
	// *   NodeDataChanged
	// *   NodeChildrenChanged
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// Indicates whether the transaction ended.
	Finished *bool `json:"Finished,omitempty" xml:"Finished,omitempty"`
	// The logging time.
	LogDate *string `json:"LogDate,omitempty" xml:"LogDate,omitempty"`
	// The transaction size.
	MultiSize *int64 `json:"MultiSize,omitempty" xml:"MultiSize,omitempty"`
	// The operation type. For tracks of the Push type:
	//
	// *   Create
	// *   Update
	// *   Delete
	// *   SetAcl
	// *   Multi
	//
	// For tracks of the Pull type:
	//
	// *   GetData
	// *   GetChild
	// *   GetStat
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The result.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
	// The session ID.
	SessionId *string `json:"SessionId,omitempty" xml:"SessionId,omitempty"`
	// The timestamp (not available).
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The type of the track. Valid values:
	//
	// *   Push
	// *   Pull
	// *   Notify
	TraceType *string `json:"TraceType,omitempty" xml:"TraceType,omitempty"`
	// The time to live (TTL).
	Ttl *int64 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// Indicates whether to enable the monitoring feature.
	Watch *bool `json:"Watch,omitempty" xml:"Watch,omitempty"`
}

func (s ListZkTrackResponseBodyTraces) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackResponseBodyTraces) GoString() string {
	return s.String()
}

func (s *ListZkTrackResponseBodyTraces) SetAcl(v string) *ListZkTrackResponseBodyTraces {
	s.Acl = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetDataType(v string) *ListZkTrackResponseBodyTraces {
	s.DataType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetEventType(v string) *ListZkTrackResponseBodyTraces {
	s.EventType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetFinished(v bool) *ListZkTrackResponseBodyTraces {
	s.Finished = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetLogDate(v string) *ListZkTrackResponseBodyTraces {
	s.LogDate = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetMultiSize(v int64) *ListZkTrackResponseBodyTraces {
	s.MultiSize = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetOpType(v string) *ListZkTrackResponseBodyTraces {
	s.OpType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetPath(v string) *ListZkTrackResponseBodyTraces {
	s.Path = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetResult(v string) *ListZkTrackResponseBodyTraces {
	s.Result = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetSessionId(v string) *ListZkTrackResponseBodyTraces {
	s.SessionId = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetTimestamp(v string) *ListZkTrackResponseBodyTraces {
	s.Timestamp = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetTraceType(v string) *ListZkTrackResponseBodyTraces {
	s.TraceType = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetTtl(v int64) *ListZkTrackResponseBodyTraces {
	s.Ttl = &v
	return s
}

func (s *ListZkTrackResponseBodyTraces) SetWatch(v bool) *ListZkTrackResponseBodyTraces {
	s.Watch = &v
	return s
}

type ListZkTrackResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListZkTrackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListZkTrackResponse) String() string {
	return tea.Prettify(s)
}

func (s ListZkTrackResponse) GoString() string {
	return s.String()
}

func (s *ListZkTrackResponse) SetHeaders(v map[string]*string) *ListZkTrackResponse {
	s.Headers = v
	return s
}

func (s *ListZkTrackResponse) SetStatusCode(v int32) *ListZkTrackResponse {
	s.StatusCode = &v
	return s
}

func (s *ListZkTrackResponse) SetBody(v *ListZkTrackResponseBody) *ListZkTrackResponse {
	s.Body = v
	return s
}

type ListZnodeChildrenRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListZnodeChildrenRequest) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenRequest) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenRequest) SetAcceptLanguage(v string) *ListZnodeChildrenRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ListZnodeChildrenRequest) SetClusterId(v string) *ListZnodeChildrenRequest {
	s.ClusterId = &v
	return s
}

func (s *ListZnodeChildrenRequest) SetPath(v string) *ListZnodeChildrenRequest {
	s.Path = &v
	return s
}

type ListZnodeChildrenResponseBody struct {
	// The details of the data.
	Data []*ListZnodeChildrenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListZnodeChildrenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenResponseBody) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenResponseBody) SetData(v []*ListZnodeChildrenResponseBodyData) *ListZnodeChildrenResponseBody {
	s.Data = v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetErrorCode(v string) *ListZnodeChildrenResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetMessage(v string) *ListZnodeChildrenResponseBody {
	s.Message = &v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetRequestId(v string) *ListZnodeChildrenResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListZnodeChildrenResponseBody) SetSuccess(v bool) *ListZnodeChildrenResponseBody {
	s.Success = &v
	return s
}

type ListZnodeChildrenResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListZnodeChildrenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenResponseBodyData) SetData(v string) *ListZnodeChildrenResponseBodyData {
	s.Data = &v
	return s
}

func (s *ListZnodeChildrenResponseBodyData) SetDir(v bool) *ListZnodeChildrenResponseBodyData {
	s.Dir = &v
	return s
}

func (s *ListZnodeChildrenResponseBodyData) SetName(v string) *ListZnodeChildrenResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListZnodeChildrenResponseBodyData) SetPath(v string) *ListZnodeChildrenResponseBodyData {
	s.Path = &v
	return s
}

type ListZnodeChildrenResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListZnodeChildrenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListZnodeChildrenResponse) String() string {
	return tea.Prettify(s)
}

func (s ListZnodeChildrenResponse) GoString() string {
	return s.String()
}

func (s *ListZnodeChildrenResponse) SetHeaders(v map[string]*string) *ListZnodeChildrenResponse {
	s.Headers = v
	return s
}

func (s *ListZnodeChildrenResponse) SetStatusCode(v int32) *ListZnodeChildrenResponse {
	s.StatusCode = &v
	return s
}

func (s *ListZnodeChildrenResponse) SetBody(v *ListZnodeChildrenResponseBody) *ListZnodeChildrenResponse {
	s.Body = v
	return s
}

type ModifyGovernanceKubernetesClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The information about the namespaces of the cluster.
	NamespaceInfos *string `json:"NamespaceInfos,omitempty" xml:"NamespaceInfos,omitempty"`
	// The region in which the cluster resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyGovernanceKubernetesClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterRequest) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetAcceptLanguage(v string) *ModifyGovernanceKubernetesClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetClusterId(v string) *ModifyGovernanceKubernetesClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetNamespaceInfos(v string) *ModifyGovernanceKubernetesClusterRequest {
	s.NamespaceInfos = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterRequest) SetRegionId(v string) *ModifyGovernanceKubernetesClusterRequest {
	s.RegionId = &v
	return s
}

type ModifyGovernanceKubernetesClusterResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyGovernanceKubernetesClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetCode(v int32) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetData(v bool) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Data = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetHttpStatusCode(v int32) *ModifyGovernanceKubernetesClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetMessage(v string) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetRequestId(v string) *ModifyGovernanceKubernetesClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponseBody) SetSuccess(v bool) *ModifyGovernanceKubernetesClusterResponseBody {
	s.Success = &v
	return s
}

type ModifyGovernanceKubernetesClusterResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyGovernanceKubernetesClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyGovernanceKubernetesClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyGovernanceKubernetesClusterResponse) GoString() string {
	return s.String()
}

func (s *ModifyGovernanceKubernetesClusterResponse) SetHeaders(v map[string]*string) *ModifyGovernanceKubernetesClusterResponse {
	s.Headers = v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponse) SetStatusCode(v int32) *ModifyGovernanceKubernetesClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyGovernanceKubernetesClusterResponse) SetBody(v *ModifyGovernanceKubernetesClusterResponseBody) *ModifyGovernanceKubernetesClusterResponse {
	s.Body = v
	return s
}

type ModifyLosslessRuleRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to align the lifecycle of the application in the Kubernetes cluster with that of the microservice.
	Aligned *bool `json:"Aligned,omitempty" xml:"Aligned,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The registration latency.
	DelayTime *int64 `json:"DelayTime,omitempty" xml:"DelayTime,omitempty"`
	// Specifies whether to enable the alert rule. Valid values:
	//
	// *   `true`: enables the rule.
	// *   `false`: disables the rule.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The slope of the prefetching curve.
	FuncType *int64 `json:"FuncType,omitempty" xml:"FuncType,omitempty"`
	// Specifies whether to display online and offline processing details.
	LossLessDetail *bool `json:"LossLessDetail,omitempty" xml:"LossLessDetail,omitempty"`
	// The microservice namespace to which the rule applies.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Specifies whether to enable notification.
	Notice *bool `json:"Notice,omitempty" xml:"Notice,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to associate with service prefetching.
	Related *bool `json:"Related,omitempty" xml:"Related,omitempty"`
	// The cooldown duration. Unit: seconds.
	ShutdownWaitSeconds *int32 `json:"ShutdownWaitSeconds,omitempty" xml:"ShutdownWaitSeconds,omitempty"`
	// The service source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The prefetching duration.
	WarmupTime *int64 `json:"WarmupTime,omitempty" xml:"WarmupTime,omitempty"`
}

func (s ModifyLosslessRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLosslessRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyLosslessRuleRequest) SetAcceptLanguage(v string) *ModifyLosslessRuleRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetAligned(v bool) *ModifyLosslessRuleRequest {
	s.Aligned = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetAppId(v string) *ModifyLosslessRuleRequest {
	s.AppId = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetAppName(v string) *ModifyLosslessRuleRequest {
	s.AppName = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetDelayTime(v int64) *ModifyLosslessRuleRequest {
	s.DelayTime = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetEnable(v bool) *ModifyLosslessRuleRequest {
	s.Enable = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetFuncType(v int64) *ModifyLosslessRuleRequest {
	s.FuncType = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetLossLessDetail(v bool) *ModifyLosslessRuleRequest {
	s.LossLessDetail = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetNamespace(v string) *ModifyLosslessRuleRequest {
	s.Namespace = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetNotice(v bool) *ModifyLosslessRuleRequest {
	s.Notice = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetRegionId(v string) *ModifyLosslessRuleRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetRelated(v bool) *ModifyLosslessRuleRequest {
	s.Related = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetShutdownWaitSeconds(v int32) *ModifyLosslessRuleRequest {
	s.ShutdownWaitSeconds = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetSource(v string) *ModifyLosslessRuleRequest {
	s.Source = &v
	return s
}

func (s *ModifyLosslessRuleRequest) SetWarmupTime(v int64) *ModifyLosslessRuleRequest {
	s.WarmupTime = &v
	return s
}

type ModifyLosslessRuleResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyLosslessRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLosslessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLosslessRuleResponseBody) SetErrorCode(v string) *ModifyLosslessRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetHttpCode(v string) *ModifyLosslessRuleResponseBody {
	s.HttpCode = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetMessage(v string) *ModifyLosslessRuleResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetRequestId(v string) *ModifyLosslessRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyLosslessRuleResponseBody) SetSuccess(v bool) *ModifyLosslessRuleResponseBody {
	s.Success = &v
	return s
}

type ModifyLosslessRuleResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLosslessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLosslessRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLosslessRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyLosslessRuleResponse) SetHeaders(v map[string]*string) *ModifyLosslessRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyLosslessRuleResponse) SetStatusCode(v int32) *ModifyLosslessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLosslessRuleResponse) SetBody(v *ModifyLosslessRuleResponseBody) *ModifyLosslessRuleResponse {
	s.Body = v
	return s
}

type OfflineGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *string `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s OfflineGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s OfflineGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *OfflineGatewayRouteRequest) SetAcceptLanguage(v string) *OfflineGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *OfflineGatewayRouteRequest) SetGatewayUniqueId(v string) *OfflineGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *OfflineGatewayRouteRequest) SetRouteId(v string) *OfflineGatewayRouteRequest {
	s.RouteId = &v
	return s
}

type OfflineGatewayRouteResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the route is unpublished.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s OfflineGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OfflineGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *OfflineGatewayRouteResponseBody) SetCode(v int32) *OfflineGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetData(v bool) *OfflineGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetHttpStatusCode(v int32) *OfflineGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetMessage(v string) *OfflineGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetRequestId(v string) *OfflineGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *OfflineGatewayRouteResponseBody) SetSuccess(v bool) *OfflineGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type OfflineGatewayRouteResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OfflineGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OfflineGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s OfflineGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *OfflineGatewayRouteResponse) SetHeaders(v map[string]*string) *OfflineGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *OfflineGatewayRouteResponse) SetStatusCode(v int32) *OfflineGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *OfflineGatewayRouteResponse) SetBody(v *OfflineGatewayRouteResponseBody) *OfflineGatewayRouteResponse {
	s.Body = v
	return s
}

type OrderClusterHealthCheckRiskNoticeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether to disable the risk item notification feature.
	//
	// *   true: disabled
	// *   false: enabled
	Mute *bool `json:"Mute,omitempty" xml:"Mute,omitempty"`
	// A reserved parameter.
	NoticeType *string `json:"NoticeType,omitempty" xml:"NoticeType,omitempty"`
	// The region in which the cluster resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The code of the risk.
	RiskCode *string `json:"RiskCode,omitempty" xml:"RiskCode,omitempty"`
}

func (s OrderClusterHealthCheckRiskNoticeRequest) String() string {
	return tea.Prettify(s)
}

func (s OrderClusterHealthCheckRiskNoticeRequest) GoString() string {
	return s.String()
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetAcceptLanguage(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetInstanceId(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.InstanceId = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetMute(v bool) *OrderClusterHealthCheckRiskNoticeRequest {
	s.Mute = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetNoticeType(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.NoticeType = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetRegionId(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.RegionId = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetRequestPars(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.RequestPars = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeRequest) SetRiskCode(v string) *OrderClusterHealthCheckRiskNoticeRequest {
	s.RiskCode = &v
	return s
}

type OrderClusterHealthCheckRiskNoticeResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s OrderClusterHealthCheckRiskNoticeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OrderClusterHealthCheckRiskNoticeResponseBody) GoString() string {
	return s.String()
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetCode(v int32) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Code = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetData(v bool) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Data = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetDynamicCode(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetDynamicMessage(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetErrorCode(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetHttpStatusCode(v int32) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetMessage(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Message = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetRequestId(v string) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.RequestId = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponseBody) SetSuccess(v bool) *OrderClusterHealthCheckRiskNoticeResponseBody {
	s.Success = &v
	return s
}

type OrderClusterHealthCheckRiskNoticeResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OrderClusterHealthCheckRiskNoticeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OrderClusterHealthCheckRiskNoticeResponse) String() string {
	return tea.Prettify(s)
}

func (s OrderClusterHealthCheckRiskNoticeResponse) GoString() string {
	return s.String()
}

func (s *OrderClusterHealthCheckRiskNoticeResponse) SetHeaders(v map[string]*string) *OrderClusterHealthCheckRiskNoticeResponse {
	s.Headers = v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponse) SetStatusCode(v int32) *OrderClusterHealthCheckRiskNoticeResponse {
	s.StatusCode = &v
	return s
}

func (s *OrderClusterHealthCheckRiskNoticeResponse) SetBody(v *OrderClusterHealthCheckRiskNoticeResponseBody) *OrderClusterHealthCheckRiskNoticeResponse {
	s.Body = v
	return s
}

type PullServicesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s PullServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s PullServicesRequest) GoString() string {
	return s.String()
}

func (s *PullServicesRequest) SetAcceptLanguage(v string) *PullServicesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *PullServicesRequest) SetGatewayUniqueId(v string) *PullServicesRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *PullServicesRequest) SetNamespace(v string) *PullServicesRequest {
	s.Namespace = &v
	return s
}

func (s *PullServicesRequest) SetSourceType(v string) *PullServicesRequest {
	s.SourceType = &v
	return s
}

type PullServicesResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*PullServicesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PullServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponseBody) GoString() string {
	return s.String()
}

func (s *PullServicesResponseBody) SetCode(v int32) *PullServicesResponseBody {
	s.Code = &v
	return s
}

func (s *PullServicesResponseBody) SetData(v []*PullServicesResponseBodyData) *PullServicesResponseBody {
	s.Data = v
	return s
}

func (s *PullServicesResponseBody) SetHttpStatusCode(v int32) *PullServicesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *PullServicesResponseBody) SetMessage(v string) *PullServicesResponseBody {
	s.Message = &v
	return s
}

func (s *PullServicesResponseBody) SetRequestId(v string) *PullServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *PullServicesResponseBody) SetSuccess(v bool) *PullServicesResponseBody {
	s.Success = &v
	return s
}

type PullServicesResponseBodyData struct {
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The alias of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The information about services.
	Services []*PullServicesResponseBodyDataServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s PullServicesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponseBodyData) GoString() string {
	return s.String()
}

func (s *PullServicesResponseBodyData) SetGroupName(v string) *PullServicesResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *PullServicesResponseBodyData) SetNamespace(v string) *PullServicesResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *PullServicesResponseBodyData) SetNamespaceShowName(v string) *PullServicesResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *PullServicesResponseBodyData) SetServices(v []*PullServicesResponseBodyDataServices) *PullServicesResponseBodyData {
	s.Services = v
	return s
}

type PullServicesResponseBodyDataServices struct {
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the service source.
	SourceId *string `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The type of the service source.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s PullServicesResponseBodyDataServices) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponseBodyDataServices) GoString() string {
	return s.String()
}

func (s *PullServicesResponseBodyDataServices) SetGroupName(v string) *PullServicesResponseBodyDataServices {
	s.GroupName = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetName(v string) *PullServicesResponseBodyDataServices {
	s.Name = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetNamespace(v string) *PullServicesResponseBodyDataServices {
	s.Namespace = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetSourceId(v string) *PullServicesResponseBodyDataServices {
	s.SourceId = &v
	return s
}

func (s *PullServicesResponseBodyDataServices) SetSourceType(v string) *PullServicesResponseBodyDataServices {
	s.SourceType = &v
	return s
}

type PullServicesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PullServicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PullServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s PullServicesResponse) GoString() string {
	return s.String()
}

func (s *PullServicesResponse) SetHeaders(v map[string]*string) *PullServicesResponse {
	s.Headers = v
	return s
}

func (s *PullServicesResponse) SetStatusCode(v int32) *PullServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *PullServicesResponse) SetBody(v *PullServicesResponseBody) *PullServicesResponse {
	s.Body = v
	return s
}

type PutClusterHealthCheckTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s PutClusterHealthCheckTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s PutClusterHealthCheckTaskRequest) GoString() string {
	return s.String()
}

func (s *PutClusterHealthCheckTaskRequest) SetAcceptLanguage(v string) *PutClusterHealthCheckTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *PutClusterHealthCheckTaskRequest) SetInstanceId(v string) *PutClusterHealthCheckTaskRequest {
	s.InstanceId = &v
	return s
}

type PutClusterHealthCheckTaskResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicCode *string `json:"DynamicCode,omitempty" xml:"DynamicCode,omitempty"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// > If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned, such as the "TaskId not found" message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PutClusterHealthCheckTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PutClusterHealthCheckTaskResponseBody) GoString() string {
	return s.String()
}

func (s *PutClusterHealthCheckTaskResponseBody) SetCode(v int32) *PutClusterHealthCheckTaskResponseBody {
	s.Code = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetData(v bool) *PutClusterHealthCheckTaskResponseBody {
	s.Data = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetDynamicCode(v string) *PutClusterHealthCheckTaskResponseBody {
	s.DynamicCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetDynamicMessage(v string) *PutClusterHealthCheckTaskResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetErrorCode(v string) *PutClusterHealthCheckTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetHttpStatusCode(v int32) *PutClusterHealthCheckTaskResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetMessage(v string) *PutClusterHealthCheckTaskResponseBody {
	s.Message = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetRequestId(v string) *PutClusterHealthCheckTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponseBody) SetSuccess(v bool) *PutClusterHealthCheckTaskResponseBody {
	s.Success = &v
	return s
}

type PutClusterHealthCheckTaskResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PutClusterHealthCheckTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PutClusterHealthCheckTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s PutClusterHealthCheckTaskResponse) GoString() string {
	return s.String()
}

func (s *PutClusterHealthCheckTaskResponse) SetHeaders(v map[string]*string) *PutClusterHealthCheckTaskResponse {
	s.Headers = v
	return s
}

func (s *PutClusterHealthCheckTaskResponse) SetStatusCode(v int32) *PutClusterHealthCheckTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *PutClusterHealthCheckTaskResponse) SetBody(v *PutClusterHealthCheckTaskResponseBody) *PutClusterHealthCheckTaskResponse {
	s.Body = v
	return s
}

type QueryAllSwimmingLaneRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s QueryAllSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneRequest) SetAcceptLanguage(v string) *QueryAllSwimmingLaneRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryAllSwimmingLaneRequest) SetGroupId(v int64) *QueryAllSwimmingLaneRequest {
	s.GroupId = &v
	return s
}

type QueryAllSwimmingLaneResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryAllSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneResponseBody) SetCode(v int32) *QueryAllSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetData(v interface{}) *QueryAllSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetDynamicMessage(v string) *QueryAllSwimmingLaneResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetErrorCode(v string) *QueryAllSwimmingLaneResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetHttpStatusCode(v int32) *QueryAllSwimmingLaneResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetMessage(v string) *QueryAllSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetRequestId(v string) *QueryAllSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryAllSwimmingLaneResponseBody) SetSuccess(v bool) *QueryAllSwimmingLaneResponseBody {
	s.Success = &v
	return s
}

type QueryAllSwimmingLaneResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryAllSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryAllSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneResponse) SetHeaders(v map[string]*string) *QueryAllSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *QueryAllSwimmingLaneResponse) SetStatusCode(v int32) *QueryAllSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryAllSwimmingLaneResponse) SetBody(v *QueryAllSwimmingLaneResponseBody) *QueryAllSwimmingLaneResponse {
	s.Body = v
	return s
}

type QueryAllSwimmingLaneGroupRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	Namespace      *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s QueryAllSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneGroupRequest) SetAcceptLanguage(v string) *QueryAllSwimmingLaneGroupRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupRequest) SetNamespace(v string) *QueryAllSwimmingLaneGroupRequest {
	s.Namespace = &v
	return s
}

type QueryAllSwimmingLaneGroupResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryAllSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetCode(v int32) *QueryAllSwimmingLaneGroupResponseBody {
	s.Code = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetData(v interface{}) *QueryAllSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetDynamicMessage(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetErrorCode(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetHttpStatusCode(v int32) *QueryAllSwimmingLaneGroupResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetMessage(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetRequestId(v string) *QueryAllSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponseBody) SetSuccess(v bool) *QueryAllSwimmingLaneGroupResponseBody {
	s.Success = &v
	return s
}

type QueryAllSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryAllSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryAllSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryAllSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *QueryAllSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *QueryAllSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponse) SetStatusCode(v int32) *QueryAllSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryAllSwimmingLaneGroupResponse) SetBody(v *QueryAllSwimmingLaneGroupResponseBody) *QueryAllSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type QueryBusinessLocationsRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QueryBusinessLocationsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsRequest) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsRequest) SetAcceptLanguage(v string) *QueryBusinessLocationsRequest {
	s.AcceptLanguage = &v
	return s
}

type QueryBusinessLocationsResponseBody struct {
	// The details of the data.
	Data []*QueryBusinessLocationsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The result of the request.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryBusinessLocationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsResponseBody) SetData(v []*QueryBusinessLocationsResponseBodyData) *QueryBusinessLocationsResponseBody {
	s.Data = v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetErrorCode(v string) *QueryBusinessLocationsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetMessage(v string) *QueryBusinessLocationsResponseBody {
	s.Message = &v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetRequestId(v string) *QueryBusinessLocationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryBusinessLocationsResponseBody) SetSuccess(v string) *QueryBusinessLocationsResponseBody {
	s.Success = &v
	return s
}

type QueryBusinessLocationsResponseBodyData struct {
	// The Chinese name of the region.
	CnName *string `json:"CnName,omitempty" xml:"CnName,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The Chinese name of the district.
	DistrictCnName *string `json:"DistrictCnName,omitempty" xml:"DistrictCnName,omitempty"`
	// The English name of the district.
	DistrictEnName *string `json:"DistrictEnName,omitempty" xml:"DistrictEnName,omitempty"`
	// The ID of the region.
	DistrictId *string `json:"DistrictId,omitempty" xml:"DistrictId,omitempty"`
	// The ordering information of the district.
	DistrictOrdering *int32 `json:"DistrictOrdering,omitempty" xml:"DistrictOrdering,omitempty"`
	// The display name of the district.
	DistrictShowName *string `json:"DistrictShowName,omitempty" xml:"DistrictShowName,omitempty"`
	// The complete description of the region.
	EnDescription *string `json:"EnDescription,omitempty" xml:"EnDescription,omitempty"`
	// The English name of the region.
	EnName *string `json:"EnName,omitempty" xml:"EnName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ordering information.
	Ordering *int32 `json:"Ordering,omitempty" xml:"Ordering,omitempty"`
	// The display name.
	ShowName *string `json:"ShowName,omitempty" xml:"ShowName,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryBusinessLocationsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsResponseBodyData) SetCnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.CnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDescription(v string) *QueryBusinessLocationsResponseBodyData {
	s.Description = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictCnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictCnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictEnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictEnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictId(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictId = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictOrdering(v int32) *QueryBusinessLocationsResponseBodyData {
	s.DistrictOrdering = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetDistrictShowName(v string) *QueryBusinessLocationsResponseBodyData {
	s.DistrictShowName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetEnDescription(v string) *QueryBusinessLocationsResponseBodyData {
	s.EnDescription = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetEnName(v string) *QueryBusinessLocationsResponseBodyData {
	s.EnName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetName(v string) *QueryBusinessLocationsResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetOrdering(v int32) *QueryBusinessLocationsResponseBodyData {
	s.Ordering = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetShowName(v string) *QueryBusinessLocationsResponseBodyData {
	s.ShowName = &v
	return s
}

func (s *QueryBusinessLocationsResponseBodyData) SetType(v string) *QueryBusinessLocationsResponseBodyData {
	s.Type = &v
	return s
}

type QueryBusinessLocationsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryBusinessLocationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryBusinessLocationsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryBusinessLocationsResponse) GoString() string {
	return s.String()
}

func (s *QueryBusinessLocationsResponse) SetHeaders(v map[string]*string) *QueryBusinessLocationsResponse {
	s.Headers = v
	return s
}

func (s *QueryBusinessLocationsResponse) SetStatusCode(v int32) *QueryBusinessLocationsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryBusinessLocationsResponse) SetBody(v *QueryBusinessLocationsResponseBody) *QueryBusinessLocationsResponse {
	s.Body = v
	return s
}

type QueryClusterDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to query access control lists (ACLs).
	AclSwitch *bool `json:"AclSwitch,omitempty" xml:"AclSwitch,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
}

func (s QueryClusterDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailRequest) SetAcceptLanguage(v string) *QueryClusterDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterDetailRequest) SetAclSwitch(v bool) *QueryClusterDetailRequest {
	s.AclSwitch = &v
	return s
}

func (s *QueryClusterDetailRequest) SetInstanceId(v string) *QueryClusterDetailRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterDetailRequest) SetOrderId(v string) *QueryClusterDetailRequest {
	s.OrderId = &v
	return s
}

type QueryClusterDetailResponseBody struct {
	// The details of the data.
	Data *QueryClusterDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponseBody) SetData(v *QueryClusterDetailResponseBodyData) *QueryClusterDetailResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterDetailResponseBody) SetErrorCode(v string) *QueryClusterDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterDetailResponseBody) SetMessage(v string) *QueryClusterDetailResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterDetailResponseBody) SetRequestId(v string) *QueryClusterDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterDetailResponseBody) SetSuccess(v bool) *QueryClusterDetailResponseBody {
	s.Success = &v
	return s
}

type QueryClusterDetailResponseBodyData struct {
	// The whitelist.
	AclEntryList *string `json:"AclEntryList,omitempty" xml:"AclEntryList,omitempty"`
	// The ID of the whitelist.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The application version.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The alias of the instance.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The engine specifications.
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The version of the instance.
	ClusterVersion *string `json:"ClusterVersion,omitempty" xml:"ClusterVersion,omitempty"`
	// The network connection type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	// The number of vCPUs.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The capacity of the disk. Unit: GB.
	DiskCapacity *int64 `json:"DiskCapacity,omitempty" xml:"DiskCapacity,omitempty"`
	// The type of the disk.
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The health status of the instance.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The amount of time taken to create the instance. Unit: milliseconds.
	InitCostTime *int64 `json:"InitCostTime,omitempty" xml:"InitCostTime,omitempty"`
	// The creation status of the instance.
	InitStatus *string `json:"InitStatus,omitempty" xml:"InitStatus,omitempty"`
	// The number of instance nodes.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The list of instance nodes.
	InstanceModels []*QueryClusterDetailResponseBodyDataInstanceModels `json:"InstanceModels,omitempty" xml:"InstanceModels,omitempty" type:"Repeated"`
	// The public IP address of the instance.
	InternetAddress *string `json:"InternetAddress,omitempty" xml:"InternetAddress,omitempty"`
	// The public endpoint of the instance.
	InternetDomain *string `json:"InternetDomain,omitempty" xml:"InternetDomain,omitempty"`
	// The private port number.
	InternetPort *string `json:"InternetPort,omitempty" xml:"InternetPort,omitempty"`
	// The internal IP address.
	IntranetAddress *string `json:"IntranetAddress,omitempty" xml:"IntranetAddress,omitempty"`
	// The internal endpoint of the instance.
	IntranetDomain *string `json:"IntranetDomain,omitempty" xml:"IntranetDomain,omitempty"`
	// The private port number.
	IntranetPort *string `json:"IntranetPort,omitempty" xml:"IntranetPort,omitempty"`
	// The size of the memory. Unit: GB.
	MemoryCapacity *int64 `json:"MemoryCapacity,omitempty" xml:"MemoryCapacity,omitempty"`
	// The edition of Microservices Engine (MSE).
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The network type of the instance. Valid values:
	//
	// *   `privatenet`: VPC
	// *   `pubnet`: Internet
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The version number of the original order.
	OrderClusterVersion *string `json:"OrderClusterVersion,omitempty" xml:"OrderClusterVersion,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	PayInfo *string `json:"PayInfo,omitempty" xml:"PayInfo,omitempty"`
	// The public bandwidth. Unit: Mbit/s.\
	// Valid values: 0 to 5000. The value 0 indicates no access to the Internet.
	PubNetworkFlow *string `json:"PubNetworkFlow,omitempty" xml:"PubNetworkFlow,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags that are attached to the instance.
	Tags map[string]interface{} `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s QueryClusterDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponseBodyData) SetAclEntryList(v string) *QueryClusterDetailResponseBodyData {
	s.AclEntryList = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetAclId(v string) *QueryClusterDetailResponseBodyData {
	s.AclId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetAppVersion(v string) *QueryClusterDetailResponseBodyData {
	s.AppVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetChargeType(v string) *QueryClusterDetailResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterAliasName(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterAliasName = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterName(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterSpecification(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterSpecification = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterType(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetClusterVersion(v string) *QueryClusterDetailResponseBodyData {
	s.ClusterVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetConnectionType(v string) *QueryClusterDetailResponseBodyData {
	s.ConnectionType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetCpu(v int32) *QueryClusterDetailResponseBodyData {
	s.Cpu = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetCreateTime(v string) *QueryClusterDetailResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetDiskCapacity(v int64) *QueryClusterDetailResponseBodyData {
	s.DiskCapacity = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetDiskType(v string) *QueryClusterDetailResponseBodyData {
	s.DiskType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetHealthStatus(v string) *QueryClusterDetailResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInitCostTime(v int64) *QueryClusterDetailResponseBodyData {
	s.InitCostTime = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInitStatus(v string) *QueryClusterDetailResponseBodyData {
	s.InitStatus = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInstanceCount(v int32) *QueryClusterDetailResponseBodyData {
	s.InstanceCount = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInstanceId(v string) *QueryClusterDetailResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInstanceModels(v []*QueryClusterDetailResponseBodyDataInstanceModels) *QueryClusterDetailResponseBodyData {
	s.InstanceModels = v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInternetAddress(v string) *QueryClusterDetailResponseBodyData {
	s.InternetAddress = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInternetDomain(v string) *QueryClusterDetailResponseBodyData {
	s.InternetDomain = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetInternetPort(v string) *QueryClusterDetailResponseBodyData {
	s.InternetPort = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetIntranetAddress(v string) *QueryClusterDetailResponseBodyData {
	s.IntranetAddress = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetIntranetDomain(v string) *QueryClusterDetailResponseBodyData {
	s.IntranetDomain = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetIntranetPort(v string) *QueryClusterDetailResponseBodyData {
	s.IntranetPort = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetMemoryCapacity(v int64) *QueryClusterDetailResponseBodyData {
	s.MemoryCapacity = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetMseVersion(v string) *QueryClusterDetailResponseBodyData {
	s.MseVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetNetType(v string) *QueryClusterDetailResponseBodyData {
	s.NetType = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetOrderClusterVersion(v string) *QueryClusterDetailResponseBodyData {
	s.OrderClusterVersion = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetPayInfo(v string) *QueryClusterDetailResponseBodyData {
	s.PayInfo = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetPubNetworkFlow(v string) *QueryClusterDetailResponseBodyData {
	s.PubNetworkFlow = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetRegionId(v string) *QueryClusterDetailResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetResourceGroupId(v string) *QueryClusterDetailResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetTags(v map[string]interface{}) *QueryClusterDetailResponseBodyData {
	s.Tags = v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetVSwitchId(v string) *QueryClusterDetailResponseBodyData {
	s.VSwitchId = &v
	return s
}

func (s *QueryClusterDetailResponseBodyData) SetVpcId(v string) *QueryClusterDetailResponseBodyData {
	s.VpcId = &v
	return s
}

type QueryClusterDetailResponseBodyDataInstanceModels struct {
	// The timestamp when the instance node was created.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// The health status of the instance node.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The public IP address.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The IP address of the node.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The name of the pod.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// The role.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The single-thread IP address.
	SingleTunnelVip *string `json:"SingleTunnelVip,omitempty" xml:"SingleTunnelVip,omitempty"`
	// The zone.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s QueryClusterDetailResponseBodyDataInstanceModels) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponseBodyDataInstanceModels) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetCreationTimestamp(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.CreationTimestamp = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetHealthStatus(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetInternetIp(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.InternetIp = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetIp(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.Ip = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetPodName(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.PodName = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetRole(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.Role = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetSingleTunnelVip(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.SingleTunnelVip = &v
	return s
}

func (s *QueryClusterDetailResponseBodyDataInstanceModels) SetZone(v string) *QueryClusterDetailResponseBodyDataInstanceModels {
	s.Zone = &v
	return s
}

type QueryClusterDetailResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDetailResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterDetailResponse) SetHeaders(v map[string]*string) *QueryClusterDetailResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterDetailResponse) SetStatusCode(v int32) *QueryClusterDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterDetailResponse) SetBody(v *QueryClusterDetailResponseBody) *QueryClusterDetailResponse {
	s.Body = v
	return s
}

type QueryClusterDiskSpecificationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
}

func (s QueryClusterDiskSpecificationRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationRequest) SetAcceptLanguage(v string) *QueryClusterDiskSpecificationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterDiskSpecificationRequest) SetClusterType(v string) *QueryClusterDiskSpecificationRequest {
	s.ClusterType = &v
	return s
}

type QueryClusterDiskSpecificationResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *QueryClusterDiskSpecificationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The dynamic part in the error message. This parameter is used to replace the \*\*%s\*\* variable in the **ErrMessage** parameter.
	//
	// >  If the return value of the **ErrMessage** parameter is **The Value of Input Parameter %s is not valid** and the return value of the **DynamicMessage** parameter is **DtsJobId**, the specified **DtsJobId** parameter is invalid.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterDiskSpecificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationResponseBody) SetCode(v int32) *QueryClusterDiskSpecificationResponseBody {
	s.Code = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetData(v *QueryClusterDiskSpecificationResponseBodyData) *QueryClusterDiskSpecificationResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetDynamicMessage(v string) *QueryClusterDiskSpecificationResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetErrorCode(v string) *QueryClusterDiskSpecificationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetHttpStatusCode(v int32) *QueryClusterDiskSpecificationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetMessage(v string) *QueryClusterDiskSpecificationResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetRequestId(v string) *QueryClusterDiskSpecificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBody) SetSuccess(v bool) *QueryClusterDiskSpecificationResponseBody {
	s.Success = &v
	return s
}

type QueryClusterDiskSpecificationResponseBodyData struct {
	// The maximum disk capacity. Unit: GB.
	Max *int32 `json:"Max,omitempty" xml:"Max,omitempty"`
	// The minimum disk capacity. Unit: GB.
	Min *int32 `json:"Min,omitempty" xml:"Min,omitempty"`
	// The step size of the disk capacity.
	Step *int32 `json:"Step,omitempty" xml:"Step,omitempty"`
}

func (s QueryClusterDiskSpecificationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationResponseBodyData) SetMax(v int32) *QueryClusterDiskSpecificationResponseBodyData {
	s.Max = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBodyData) SetMin(v int32) *QueryClusterDiskSpecificationResponseBodyData {
	s.Min = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponseBodyData) SetStep(v int32) *QueryClusterDiskSpecificationResponseBodyData {
	s.Step = &v
	return s
}

type QueryClusterDiskSpecificationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterDiskSpecificationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterDiskSpecificationResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterDiskSpecificationResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterDiskSpecificationResponse) SetHeaders(v map[string]*string) *QueryClusterDiskSpecificationResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterDiskSpecificationResponse) SetStatusCode(v int32) *QueryClusterDiskSpecificationResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterDiskSpecificationResponse) SetBody(v *QueryClusterDiskSpecificationResponseBody) *QueryClusterDiskSpecificationResponse {
	s.Body = v
	return s
}

type QueryClusterInfoRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to query the configuration of a public IP address whitelist.
	AclSwitch *bool `json:"AclSwitch,omitempty" xml:"AclSwitch,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryClusterInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoRequest) SetAcceptLanguage(v string) *QueryClusterInfoRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterInfoRequest) SetAclSwitch(v bool) *QueryClusterInfoRequest {
	s.AclSwitch = &v
	return s
}

func (s *QueryClusterInfoRequest) SetClusterId(v string) *QueryClusterInfoRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetInstanceId(v string) *QueryClusterInfoRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetOrderId(v string) *QueryClusterInfoRequest {
	s.OrderId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetRegionId(v string) *QueryClusterInfoRequest {
	s.RegionId = &v
	return s
}

func (s *QueryClusterInfoRequest) SetRequestPars(v string) *QueryClusterInfoRequest {
	s.RequestPars = &v
	return s
}

type QueryClusterInfoResponseBody struct {
	// The details of the data.
	Data *QueryClusterInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponseBody) SetData(v *QueryClusterInfoResponseBodyData) *QueryClusterInfoResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterInfoResponseBody) SetErrorCode(v string) *QueryClusterInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterInfoResponseBody) SetMessage(v string) *QueryClusterInfoResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterInfoResponseBody) SetRequestId(v string) *QueryClusterInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterInfoResponseBody) SetSuccess(v bool) *QueryClusterInfoResponseBody {
	s.Success = &v
	return s
}

type QueryClusterInfoResponseBodyData struct {
	// The public IP address whitelist.
	AclEntryList *string `json:"AclEntryList,omitempty" xml:"AclEntryList,omitempty"`
	// The ID of the instance in the public IP address whitelist.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The version of the instance.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The billing method, such as subscription or pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The alias of the instance.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The full name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The engine specifications.
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The type of the instance. Valid values: ZooKeeper, Nacos-Ans, and Eureka.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The version of the order.
	ClusterVersion *string `json:"ClusterVersion,omitempty" xml:"ClusterVersion,omitempty"`
	// A deprecated parameter.
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	// A deprecated parameter.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// A deprecated parameter.
	DiskCapacity *int64 `json:"DiskCapacity,omitempty" xml:"DiskCapacity,omitempty"`
	// A deprecated parameter.
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The status of the instance.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The time that is required to initialize the instance. Unit: milliseconds.
	InitCostTime *int64 `json:"InitCostTime,omitempty" xml:"InitCostTime,omitempty"`
	// The initial status of the instance.
	InitStatus *string `json:"InitStatus,omitempty" xml:"InitStatus,omitempty"`
	// The number of instance nodes.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The reserved structure.
	InstanceModels []*QueryClusterInfoResponseBodyDataInstanceModels `json:"InstanceModels,omitempty" xml:"InstanceModels,omitempty" type:"Repeated"`
	// A reserved parameter.
	InternetAddress *string `json:"InternetAddress,omitempty" xml:"InternetAddress,omitempty"`
	// The public endpoint.
	InternetDomain *string `json:"InternetDomain,omitempty" xml:"InternetDomain,omitempty"`
	// The instance port that is accessible over the Internet.
	InternetPort *string `json:"InternetPort,omitempty" xml:"InternetPort,omitempty"`
	// A reserved parameter.
	IntranetAddress *string `json:"IntranetAddress,omitempty" xml:"IntranetAddress,omitempty"`
	// The internal endpoint.
	IntranetDomain *string `json:"IntranetDomain,omitempty" xml:"IntranetDomain,omitempty"`
	// The instance port that is accessible over an internal network.
	IntranetPort *string `json:"IntranetPort,omitempty" xml:"IntranetPort,omitempty"`
	// A deprecated parameter.
	MemoryCapacity *int64 `json:"MemoryCapacity,omitempty" xml:"MemoryCapacity,omitempty"`
	// The version of the instance.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
	// The network connection type of the instance.
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The billing method. Valid values:
	PayInfo *string `json:"PayInfo,omitempty" xml:"PayInfo,omitempty"`
	// The public bandwidth. Unit: Mbit/s.\
	// Valid values: 0 to 5000. The value 0 indicates no access to the Internet.
	PubNetworkFlow *string `json:"PubNetworkFlow,omitempty" xml:"PubNetworkFlow,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The tag.
	Tags map[string]interface{} `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC where the instance resides.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s QueryClusterInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponseBodyData) SetAclEntryList(v string) *QueryClusterInfoResponseBodyData {
	s.AclEntryList = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetAclId(v string) *QueryClusterInfoResponseBodyData {
	s.AclId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetAppVersion(v string) *QueryClusterInfoResponseBodyData {
	s.AppVersion = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetChargeType(v string) *QueryClusterInfoResponseBodyData {
	s.ChargeType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterAliasName(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterAliasName = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterName(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterSpecification(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterSpecification = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterType(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetClusterVersion(v string) *QueryClusterInfoResponseBodyData {
	s.ClusterVersion = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetConnectionType(v string) *QueryClusterInfoResponseBodyData {
	s.ConnectionType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetCpu(v int32) *QueryClusterInfoResponseBodyData {
	s.Cpu = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetCreateTime(v string) *QueryClusterInfoResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetDiskCapacity(v int64) *QueryClusterInfoResponseBodyData {
	s.DiskCapacity = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetDiskType(v string) *QueryClusterInfoResponseBodyData {
	s.DiskType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetHealthStatus(v string) *QueryClusterInfoResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInitCostTime(v int64) *QueryClusterInfoResponseBodyData {
	s.InitCostTime = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInitStatus(v string) *QueryClusterInfoResponseBodyData {
	s.InitStatus = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInstanceCount(v int32) *QueryClusterInfoResponseBodyData {
	s.InstanceCount = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInstanceId(v string) *QueryClusterInfoResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInstanceModels(v []*QueryClusterInfoResponseBodyDataInstanceModels) *QueryClusterInfoResponseBodyData {
	s.InstanceModels = v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInternetAddress(v string) *QueryClusterInfoResponseBodyData {
	s.InternetAddress = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInternetDomain(v string) *QueryClusterInfoResponseBodyData {
	s.InternetDomain = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetInternetPort(v string) *QueryClusterInfoResponseBodyData {
	s.InternetPort = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetIntranetAddress(v string) *QueryClusterInfoResponseBodyData {
	s.IntranetAddress = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetIntranetDomain(v string) *QueryClusterInfoResponseBodyData {
	s.IntranetDomain = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetIntranetPort(v string) *QueryClusterInfoResponseBodyData {
	s.IntranetPort = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetMemoryCapacity(v int64) *QueryClusterInfoResponseBodyData {
	s.MemoryCapacity = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetMseVersion(v string) *QueryClusterInfoResponseBodyData {
	s.MseVersion = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetNetType(v string) *QueryClusterInfoResponseBodyData {
	s.NetType = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetPayInfo(v string) *QueryClusterInfoResponseBodyData {
	s.PayInfo = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetPubNetworkFlow(v string) *QueryClusterInfoResponseBodyData {
	s.PubNetworkFlow = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetRegionId(v string) *QueryClusterInfoResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetTags(v map[string]interface{}) *QueryClusterInfoResponseBodyData {
	s.Tags = v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetVSwitchId(v string) *QueryClusterInfoResponseBodyData {
	s.VSwitchId = &v
	return s
}

func (s *QueryClusterInfoResponseBodyData) SetVpcId(v string) *QueryClusterInfoResponseBodyData {
	s.VpcId = &v
	return s
}

type QueryClusterInfoResponseBodyDataInstanceModels struct {
	// A reserved parameter.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// A reserved parameter.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// A reserved parameter.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// A reserved parameter.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// A reserved parameter.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// A reserved parameter.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// A reserved parameter.
	SingleTunnelVip *string `json:"SingleTunnelVip,omitempty" xml:"SingleTunnelVip,omitempty"`
	// A reserved parameter.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s QueryClusterInfoResponseBodyDataInstanceModels) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponseBodyDataInstanceModels) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetCreationTimestamp(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.CreationTimestamp = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetHealthStatus(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.HealthStatus = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetInternetIp(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.InternetIp = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetIp(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.Ip = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetPodName(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.PodName = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetRole(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.Role = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetSingleTunnelVip(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.SingleTunnelVip = &v
	return s
}

func (s *QueryClusterInfoResponseBodyDataInstanceModels) SetZone(v string) *QueryClusterInfoResponseBodyDataInstanceModels {
	s.Zone = &v
	return s
}

type QueryClusterInfoResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterInfoResponse) SetHeaders(v map[string]*string) *QueryClusterInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterInfoResponse) SetStatusCode(v int32) *QueryClusterInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterInfoResponse) SetBody(v *QueryClusterInfoResponseBody) *QueryClusterInfoResponse {
	s.Body = v
	return s
}

type QueryClusterSpecificationRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The network type. Valid values:
	//
	// *   slb
	// *   eni
	ConnectType *string `json:"ConnectType,omitempty" xml:"ConnectType,omitempty"`
	// The edition of the MSE instance that you want to purchase.
	//
	// *   mse_pro: Professional Edition
	// *   mse_dev: Developer Edition
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
}

func (s QueryClusterSpecificationRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationRequest) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationRequest) SetAcceptLanguage(v string) *QueryClusterSpecificationRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryClusterSpecificationRequest) SetConnectType(v string) *QueryClusterSpecificationRequest {
	s.ConnectType = &v
	return s
}

func (s *QueryClusterSpecificationRequest) SetMseVersion(v string) *QueryClusterSpecificationRequest {
	s.MseVersion = &v
	return s
}

type QueryClusterSpecificationResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data []*QueryClusterSpecificationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClusterSpecificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationResponseBody) SetCode(v int32) *QueryClusterSpecificationResponseBody {
	s.Code = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetData(v []*QueryClusterSpecificationResponseBodyData) *QueryClusterSpecificationResponseBody {
	s.Data = v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetErrorCode(v string) *QueryClusterSpecificationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetHttpStatusCode(v int32) *QueryClusterSpecificationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetMessage(v string) *QueryClusterSpecificationResponseBody {
	s.Message = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetRequestId(v string) *QueryClusterSpecificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClusterSpecificationResponseBody) SetSuccess(v bool) *QueryClusterSpecificationResponseBody {
	s.Success = &v
	return s
}

type QueryClusterSpecificationResponseBodyData struct {
	// The engine specifications that can be used.
	ClusterSpecificationName *string `json:"ClusterSpecificationName,omitempty" xml:"ClusterSpecificationName,omitempty"`
	// The number of vCPUs in the specifications.
	CpuCapacity *string `json:"CpuCapacity,omitempty" xml:"CpuCapacity,omitempty"`
	// The memory size in the specifications. Unit: GB.
	MemoryCapacity *string `json:"MemoryCapacity,omitempty" xml:"MemoryCapacity,omitempty"`
}

func (s QueryClusterSpecificationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationResponseBodyData) SetClusterSpecificationName(v string) *QueryClusterSpecificationResponseBodyData {
	s.ClusterSpecificationName = &v
	return s
}

func (s *QueryClusterSpecificationResponseBodyData) SetCpuCapacity(v string) *QueryClusterSpecificationResponseBodyData {
	s.CpuCapacity = &v
	return s
}

func (s *QueryClusterSpecificationResponseBodyData) SetMemoryCapacity(v string) *QueryClusterSpecificationResponseBodyData {
	s.MemoryCapacity = &v
	return s
}

type QueryClusterSpecificationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClusterSpecificationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClusterSpecificationResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClusterSpecificationResponse) GoString() string {
	return s.String()
}

func (s *QueryClusterSpecificationResponse) SetHeaders(v map[string]*string) *QueryClusterSpecificationResponse {
	s.Headers = v
	return s
}

func (s *QueryClusterSpecificationResponse) SetStatusCode(v int32) *QueryClusterSpecificationResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClusterSpecificationResponse) SetBody(v *QueryClusterSpecificationResponseBody) *QueryClusterSpecificationResponse {
	s.Body = v
	return s
}

type QueryConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// A reserved parameter.
	ConfigType *string `json:"ConfigType,omitempty" xml:"ConfigType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether runtime configurations are required.
	NeedRunningConf *bool `json:"NeedRunningConf,omitempty" xml:"NeedRunningConf,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigRequest) GoString() string {
	return s.String()
}

func (s *QueryConfigRequest) SetAcceptLanguage(v string) *QueryConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryConfigRequest) SetClusterId(v string) *QueryConfigRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryConfigRequest) SetConfigType(v string) *QueryConfigRequest {
	s.ConfigType = &v
	return s
}

func (s *QueryConfigRequest) SetInstanceId(v string) *QueryConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryConfigRequest) SetNeedRunningConf(v bool) *QueryConfigRequest {
	s.NeedRunningConf = &v
	return s
}

func (s *QueryConfigRequest) SetRequestPars(v string) *QueryConfigRequest {
	s.RequestPars = &v
	return s
}

type QueryConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *QueryConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponseBody) GoString() string {
	return s.String()
}

func (s *QueryConfigResponseBody) SetCode(v int32) *QueryConfigResponseBody {
	s.Code = &v
	return s
}

func (s *QueryConfigResponseBody) SetData(v *QueryConfigResponseBodyData) *QueryConfigResponseBody {
	s.Data = v
	return s
}

func (s *QueryConfigResponseBody) SetHttpStatusCode(v int32) *QueryConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryConfigResponseBody) SetMessage(v string) *QueryConfigResponseBody {
	s.Message = &v
	return s
}

func (s *QueryConfigResponseBody) SetRequestId(v string) *QueryConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryConfigResponseBody) SetSuccess(v bool) *QueryConfigResponseBody {
	s.Success = &v
	return s
}

type QueryConfigResponseBodyData struct {
	// A reserved parameter.
	AutopurgePurgeInterval *string `json:"AutopurgePurgeInterval,omitempty" xml:"AutopurgePurgeInterval,omitempty"`
	// A reserved parameter.
	AutopurgeSnapRetainCount *string `json:"AutopurgeSnapRetainCount,omitempty" xml:"AutopurgeSnapRetainCount,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Indicates whether RAM authorization of a configuration center is enabled. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	ConfigAuthEnabled *bool `json:"ConfigAuthEnabled,omitempty" xml:"ConfigAuthEnabled,omitempty"`
	// Indicates whether RAM authorization is supported by a configuration center of the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported
	// *   `false`: not supported
	ConfigAuthSupported *bool `json:"ConfigAuthSupported,omitempty" xml:"ConfigAuthSupported,omitempty"`
	// The maximum size of a configuration. Unit: KB.
	ConfigContentLimit *int64 `json:"ConfigContentLimit,omitempty" xml:"ConfigContentLimit,omitempty"`
	// Indicates whether configuration encryption of a configuration center is enabled by the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	ConfigSecretEnabled *bool `json:"ConfigSecretEnabled,omitempty" xml:"ConfigSecretEnabled,omitempty"`
	// Indicates whether configuration encryption of a configuration center is supported by the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported
	// *   `false`: not supported
	ConfigSecretSupported *bool `json:"ConfigSecretSupported,omitempty" xml:"ConfigSecretSupported,omitempty"`
	// Indicates whether the time to live (TTL) configuration is enabled. This parameter is valid for ZooKeeper instances.
	ExtendedTypesEnable *bool `json:"ExtendedTypesEnable,omitempty" xml:"ExtendedTypesEnable,omitempty"`
	// The maximum connection duration of the instance. Unit: seconds. This parameter is valid for ZooKeeper instances.
	InitLimit *string `json:"InitLimit,omitempty" xml:"InitLimit,omitempty"`
	// The maximum amount of data on each node. This parameter is valid for ZooKeeper instances. Unit: bytes.
	JuteMaxbuffer *string `json:"JuteMaxbuffer,omitempty" xml:"JuteMaxbuffer,omitempty"`
	// A reserved parameter.
	JvmFlagsCustom *string `json:"JvmFlagsCustom,omitempty" xml:"JvmFlagsCustom,omitempty"`
	// Indicates whether Mesh Configuration Protocol (MCP) is enabled. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	MCPEnabled *bool `json:"MCPEnabled,omitempty" xml:"MCPEnabled,omitempty"`
	// Indicates whether MCP is supported. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported
	// *   `false`: not supported
	MCPSupported *bool `json:"MCPSupported,omitempty" xml:"MCPSupported,omitempty"`
	// The number of connections between a client and a server. This parameter is valid for ZooKeeper instances.\
	// If this parameter is set to 0, no limits are imposed on the number of connections.
	MaxClientCnxns *string `json:"MaxClientCnxns,omitempty" xml:"MaxClientCnxns,omitempty"`
	// The maximum timeout period. This parameter is valid for ZooKeeper instances.
	MaxSessionTimeout *string `json:"MaxSessionTimeout,omitempty" xml:"MaxSessionTimeout,omitempty"`
	// The minimum timeout period. This parameter is valid for ZooKeeper instances.
	MinSessionTimeout *string `json:"MinSessionTimeout,omitempty" xml:"MinSessionTimeout,omitempty"`
	// The runtime configuration of the Nacos instance.
	NacosRunningEnv *QueryConfigResponseBodyDataNacosRunningEnv `json:"NacosRunningEnv,omitempty" xml:"NacosRunningEnv,omitempty" type:"Struct"`
	// Indicates whether RAM authorization of a registry is enabled. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	NamingAuthEnabled *bool `json:"NamingAuthEnabled,omitempty" xml:"NamingAuthEnabled,omitempty"`
	// Indicates whether RAM authorization of services is supported by the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported
	// *   `false`: not supported
	NamingAuthSupported *bool `json:"NamingAuthSupported,omitempty" xml:"NamingAuthSupported,omitempty"`
	// Indicates whether service creation is supported for the instance. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: supported
	// *   `false`: not supported
	NamingCreateServiceSupported *bool `json:"NamingCreateServiceSupported,omitempty" xml:"NamingCreateServiceSupported,omitempty"`
	// Indicates whether super permissions are enabled. This parameter is valid for ZooKeeper instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	OpenSuperAcl *bool `json:"OpenSuperAcl,omitempty" xml:"OpenSuperAcl,omitempty"`
	// The user password. This parameter is valid only if OpenSuperAcl is set to true.
	PassWord *string `json:"PassWord,omitempty" xml:"PassWord,omitempty"`
	// Indicates whether the instance was restarted and new configurations have taken effect. Valid values:
	//
	// *   `true`: The restart was successful.
	// *   `false`: The restart failed.
	RestartFlag *bool `json:"RestartFlag,omitempty" xml:"RestartFlag,omitempty"`
	// The frequency for generating snapshots. This parameter is valid for ZooKeeper instances.
	SnapshotCount *string `json:"SnapshotCount,omitempty" xml:"SnapshotCount,omitempty"`
	// The connection timeout period of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
	SyncLimit *string `json:"SyncLimit,omitempty" xml:"SyncLimit,omitempty"`
	// The time unit of the engine. This parameter is valid for ZooKeeper instances. Default value: 2000. Unit: milliseconds.
	TickTime *string `json:"TickTime,omitempty" xml:"TickTime,omitempty"`
	// The username. This parameter is valid only if OpenSuperAcl is set to true.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s QueryConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryConfigResponseBodyData) SetAutopurgePurgeInterval(v string) *QueryConfigResponseBodyData {
	s.AutopurgePurgeInterval = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetAutopurgeSnapRetainCount(v string) *QueryConfigResponseBodyData {
	s.AutopurgeSnapRetainCount = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetClusterName(v string) *QueryConfigResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigAuthEnabled(v bool) *QueryConfigResponseBodyData {
	s.ConfigAuthEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigAuthSupported(v bool) *QueryConfigResponseBodyData {
	s.ConfigAuthSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigContentLimit(v int64) *QueryConfigResponseBodyData {
	s.ConfigContentLimit = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigSecretEnabled(v bool) *QueryConfigResponseBodyData {
	s.ConfigSecretEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetConfigSecretSupported(v bool) *QueryConfigResponseBodyData {
	s.ConfigSecretSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetExtendedTypesEnable(v bool) *QueryConfigResponseBodyData {
	s.ExtendedTypesEnable = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetInitLimit(v string) *QueryConfigResponseBodyData {
	s.InitLimit = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetJuteMaxbuffer(v string) *QueryConfigResponseBodyData {
	s.JuteMaxbuffer = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetJvmFlagsCustom(v string) *QueryConfigResponseBodyData {
	s.JvmFlagsCustom = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMCPEnabled(v bool) *QueryConfigResponseBodyData {
	s.MCPEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMCPSupported(v bool) *QueryConfigResponseBodyData {
	s.MCPSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMaxClientCnxns(v string) *QueryConfigResponseBodyData {
	s.MaxClientCnxns = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMaxSessionTimeout(v string) *QueryConfigResponseBodyData {
	s.MaxSessionTimeout = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetMinSessionTimeout(v string) *QueryConfigResponseBodyData {
	s.MinSessionTimeout = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetNacosRunningEnv(v *QueryConfigResponseBodyDataNacosRunningEnv) *QueryConfigResponseBodyData {
	s.NacosRunningEnv = v
	return s
}

func (s *QueryConfigResponseBodyData) SetNamingAuthEnabled(v bool) *QueryConfigResponseBodyData {
	s.NamingAuthEnabled = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetNamingAuthSupported(v bool) *QueryConfigResponseBodyData {
	s.NamingAuthSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetNamingCreateServiceSupported(v bool) *QueryConfigResponseBodyData {
	s.NamingCreateServiceSupported = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetOpenSuperAcl(v bool) *QueryConfigResponseBodyData {
	s.OpenSuperAcl = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetPassWord(v string) *QueryConfigResponseBodyData {
	s.PassWord = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetRestartFlag(v bool) *QueryConfigResponseBodyData {
	s.RestartFlag = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetSnapshotCount(v string) *QueryConfigResponseBodyData {
	s.SnapshotCount = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetSyncLimit(v string) *QueryConfigResponseBodyData {
	s.SyncLimit = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetTickTime(v string) *QueryConfigResponseBodyData {
	s.TickTime = &v
	return s
}

func (s *QueryConfigResponseBodyData) SetUserName(v string) *QueryConfigResponseBodyData {
	s.UserName = &v
	return s
}

type QueryConfigResponseBodyDataNacosRunningEnv struct {
	// Indicates whether empty list protection is enabled.
	EmptyProtect *bool `json:"emptyProtect,omitempty" xml:"emptyProtect,omitempty"`
}

func (s QueryConfigResponseBodyDataNacosRunningEnv) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponseBodyDataNacosRunningEnv) GoString() string {
	return s.String()
}

func (s *QueryConfigResponseBodyDataNacosRunningEnv) SetEmptyProtect(v bool) *QueryConfigResponseBodyDataNacosRunningEnv {
	s.EmptyProtect = &v
	return s
}

type QueryConfigResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryConfigResponse) GoString() string {
	return s.String()
}

func (s *QueryConfigResponse) SetHeaders(v map[string]*string) *QueryConfigResponse {
	s.Headers = v
	return s
}

func (s *QueryConfigResponse) SetStatusCode(v int32) *QueryConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryConfigResponse) SetBody(v *QueryConfigResponseBody) *QueryConfigResponse {
	s.Body = v
	return s
}

type QueryGatewayRegionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QueryGatewayRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayRegionRequest) GoString() string {
	return s.String()
}

func (s *QueryGatewayRegionRequest) SetAcceptLanguage(v string) *QueryGatewayRegionRequest {
	s.AcceptLanguage = &v
	return s
}

type QueryGatewayRegionResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data []*string `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryGatewayRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayRegionResponseBody) GoString() string {
	return s.String()
}

func (s *QueryGatewayRegionResponseBody) SetCode(v int32) *QueryGatewayRegionResponseBody {
	s.Code = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetData(v []*string) *QueryGatewayRegionResponseBody {
	s.Data = v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetHttpStatusCode(v int32) *QueryGatewayRegionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetMessage(v string) *QueryGatewayRegionResponseBody {
	s.Message = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetRequestId(v string) *QueryGatewayRegionResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryGatewayRegionResponseBody) SetSuccess(v bool) *QueryGatewayRegionResponseBody {
	s.Success = &v
	return s
}

type QueryGatewayRegionResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryGatewayRegionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryGatewayRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayRegionResponse) GoString() string {
	return s.String()
}

func (s *QueryGatewayRegionResponse) SetHeaders(v map[string]*string) *QueryGatewayRegionResponse {
	s.Headers = v
	return s
}

func (s *QueryGatewayRegionResponse) SetStatusCode(v int32) *QueryGatewayRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryGatewayRegionResponse) SetBody(v *QueryGatewayRegionResponseBody) *QueryGatewayRegionResponse {
	s.Body = v
	return s
}

type QueryGatewayTypeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QueryGatewayTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayTypeRequest) GoString() string {
	return s.String()
}

func (s *QueryGatewayTypeRequest) SetAcceptLanguage(v string) *QueryGatewayTypeRequest {
	s.AcceptLanguage = &v
	return s
}

type QueryGatewayTypeResponseBody struct {
	// The status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the gateway type. The data type of this parameter is List.
	Data []*string `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned. If the request is successful, a success message is returned. If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryGatewayTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayTypeResponseBody) GoString() string {
	return s.String()
}

func (s *QueryGatewayTypeResponseBody) SetCode(v int32) *QueryGatewayTypeResponseBody {
	s.Code = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetData(v []*string) *QueryGatewayTypeResponseBody {
	s.Data = v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetHttpStatusCode(v int32) *QueryGatewayTypeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetMessage(v string) *QueryGatewayTypeResponseBody {
	s.Message = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetRequestId(v string) *QueryGatewayTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryGatewayTypeResponseBody) SetSuccess(v bool) *QueryGatewayTypeResponseBody {
	s.Success = &v
	return s
}

type QueryGatewayTypeResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryGatewayTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryGatewayTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryGatewayTypeResponse) GoString() string {
	return s.String()
}

func (s *QueryGatewayTypeResponse) SetHeaders(v map[string]*string) *QueryGatewayTypeResponse {
	s.Headers = v
	return s
}

func (s *QueryGatewayTypeResponse) SetStatusCode(v int32) *QueryGatewayTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryGatewayTypeResponse) SetBody(v *QueryGatewayTypeResponseBody) *QueryGatewayTypeResponse {
	s.Body = v
	return s
}

type QueryGovernanceKubernetesClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the Kubernetes cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The page number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryGovernanceKubernetesClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterRequest) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterRequest) SetAcceptLanguage(v string) *QueryGovernanceKubernetesClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetClusterId(v string) *QueryGovernanceKubernetesClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetClusterName(v string) *QueryGovernanceKubernetesClusterRequest {
	s.ClusterName = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetPageNumber(v int32) *QueryGovernanceKubernetesClusterRequest {
	s.PageNumber = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterRequest) SetPageSize(v int32) *QueryGovernanceKubernetesClusterRequest {
	s.PageSize = &v
	return s
}

type QueryGovernanceKubernetesClusterResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response data.
	Data *QueryGovernanceKubernetesClusterResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryGovernanceKubernetesClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponseBody) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetCode(v int32) *QueryGovernanceKubernetesClusterResponseBody {
	s.Code = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetData(v *QueryGovernanceKubernetesClusterResponseBodyData) *QueryGovernanceKubernetesClusterResponseBody {
	s.Data = v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetHttpStatusCode(v int32) *QueryGovernanceKubernetesClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetMessage(v string) *QueryGovernanceKubernetesClusterResponseBody {
	s.Message = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetRequestId(v string) *QueryGovernanceKubernetesClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBody) SetSuccess(v bool) *QueryGovernanceKubernetesClusterResponseBody {
	s.Success = &v
	return s
}

type QueryGovernanceKubernetesClusterResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data structure.
	Result []*QueryGovernanceKubernetesClusterResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of clusters.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s QueryGovernanceKubernetesClusterResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetPageNumber(v int32) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetPageSize(v int32) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetResult(v []*QueryGovernanceKubernetesClusterResponseBodyDataResult) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.Result = v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyData) SetTotalSize(v int32) *QueryGovernanceKubernetesClusterResponseBodyData {
	s.TotalSize = &v
	return s
}

type QueryGovernanceKubernetesClusterResponseBodyDataResult struct {
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The Kubernetes version of the instance.
	K8sVersion *string `json:"K8sVersion,omitempty" xml:"K8sVersion,omitempty"`
	// The information of the namespace.
	NamespaceInfos *string `json:"NamespaceInfos,omitempty" xml:"NamespaceInfos,omitempty"`
	// The time when the ack-onepilot component was started.
	PilotStartTime *string `json:"PilotStartTime,omitempty" xml:"PilotStartTime,omitempty"`
	// The region where the cluster resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s QueryGovernanceKubernetesClusterResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetClusterId(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.ClusterId = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetClusterName(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.ClusterName = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetK8sVersion(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.K8sVersion = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetNamespaceInfos(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.NamespaceInfos = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetPilotStartTime(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.PilotStartTime = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponseBodyDataResult) SetRegion(v string) *QueryGovernanceKubernetesClusterResponseBodyDataResult {
	s.Region = &v
	return s
}

type QueryGovernanceKubernetesClusterResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryGovernanceKubernetesClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryGovernanceKubernetesClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryGovernanceKubernetesClusterResponse) GoString() string {
	return s.String()
}

func (s *QueryGovernanceKubernetesClusterResponse) SetHeaders(v map[string]*string) *QueryGovernanceKubernetesClusterResponse {
	s.Headers = v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponse) SetStatusCode(v int32) *QueryGovernanceKubernetesClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryGovernanceKubernetesClusterResponse) SetBody(v *QueryGovernanceKubernetesClusterResponseBody) *QueryGovernanceKubernetesClusterResponse {
	s.Body = v
	return s
}

type QueryInstancesInfoRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the region where the instance is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryInstancesInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoRequest) SetAcceptLanguage(v string) *QueryInstancesInfoRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetClusterId(v string) *QueryInstancesInfoRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetInstanceId(v string) *QueryInstancesInfoRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetOrderId(v string) *QueryInstancesInfoRequest {
	s.OrderId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetRegionId(v string) *QueryInstancesInfoRequest {
	s.RegionId = &v
	return s
}

func (s *QueryInstancesInfoRequest) SetRequestPars(v string) *QueryInstancesInfoRequest {
	s.RequestPars = &v
	return s
}

type QueryInstancesInfoResponseBody struct {
	// The details of the data.
	Data []*QueryInstancesInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryInstancesInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoResponseBody) SetData(v []*QueryInstancesInfoResponseBodyData) *QueryInstancesInfoResponseBody {
	s.Data = v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetErrorCode(v string) *QueryInstancesInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetHttpCode(v string) *QueryInstancesInfoResponseBody {
	s.HttpCode = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetMessage(v string) *QueryInstancesInfoResponseBody {
	s.Message = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetRequestId(v string) *QueryInstancesInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryInstancesInfoResponseBody) SetSuccess(v bool) *QueryInstancesInfoResponseBody {
	s.Success = &v
	return s
}

type QueryInstancesInfoResponseBodyData struct {
	// The enabled port.
	ClientPort *string `json:"ClientPort,omitempty" xml:"ClientPort,omitempty"`
	// The creation time of the TIMESTAMP type.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// A reserved parameter.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The public IP address.
	InternetIp *string `json:"InternetIp,omitempty" xml:"InternetIp,omitempty"`
	// The IP address of the pod.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The name of the pod.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// A reserved parameter.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The internal IP address.
	SingleTunnelVip *string `json:"SingleTunnelVip,omitempty" xml:"SingleTunnelVip,omitempty"`
	// The zone.
	Zone *string `json:"Zone,omitempty" xml:"Zone,omitempty"`
}

func (s QueryInstancesInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoResponseBodyData) SetClientPort(v string) *QueryInstancesInfoResponseBodyData {
	s.ClientPort = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetCreationTimestamp(v string) *QueryInstancesInfoResponseBodyData {
	s.CreationTimestamp = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetHealthStatus(v string) *QueryInstancesInfoResponseBodyData {
	s.HealthStatus = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetInternetIp(v string) *QueryInstancesInfoResponseBodyData {
	s.InternetIp = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetIp(v string) *QueryInstancesInfoResponseBodyData {
	s.Ip = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetPodName(v string) *QueryInstancesInfoResponseBodyData {
	s.PodName = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetRole(v string) *QueryInstancesInfoResponseBodyData {
	s.Role = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetSingleTunnelVip(v string) *QueryInstancesInfoResponseBodyData {
	s.SingleTunnelVip = &v
	return s
}

func (s *QueryInstancesInfoResponseBodyData) SetZone(v string) *QueryInstancesInfoResponseBodyData {
	s.Zone = &v
	return s
}

type QueryInstancesInfoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryInstancesInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryInstancesInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryInstancesInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryInstancesInfoResponse) SetHeaders(v map[string]*string) *QueryInstancesInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryInstancesInfoResponse) SetStatusCode(v int32) *QueryInstancesInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryInstancesInfoResponse) SetBody(v *QueryInstancesInfoResponseBody) *QueryInstancesInfoResponse {
	s.Body = v
	return s
}

type QueryMonitorRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The timestamp when the monitoring ends.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The metric type. The following metric types are supported:
	//
	// \[Basic system metrics]
	//
	// *   cpuUsage
	// *   memoryUsage
	// *   diskUsage
	// *   gcCount
	// *   gcTime
	//
	// \[Nacos registry]
	//
	// *   serviceCount
	// *   writeCostTime
	// *   readCostTime
	// *   TPS regCenterTps
	// *   QPS regCenterQps
	//
	// \[Nacos configuration center]
	//
	// *   publish
	// *   getConfig
	//
	// \[zookeeper]
	//
	// *   TPS zk_TpsCount
	// *   QPS zk_QpsCount
	// *   zookeeper_AvgRequestLatency
	MonitorType *string `json:"MonitorType,omitempty" xml:"MonitorType,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The timestamp when the monitoring starts.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The interval between data points. Unit: seconds.
	Step *int64 `json:"Step,omitempty" xml:"Step,omitempty"`
}

func (s QueryMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorRequest) GoString() string {
	return s.String()
}

func (s *QueryMonitorRequest) SetAcceptLanguage(v string) *QueryMonitorRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryMonitorRequest) SetEndTime(v int64) *QueryMonitorRequest {
	s.EndTime = &v
	return s
}

func (s *QueryMonitorRequest) SetInstanceId(v string) *QueryMonitorRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryMonitorRequest) SetMonitorType(v string) *QueryMonitorRequest {
	s.MonitorType = &v
	return s
}

func (s *QueryMonitorRequest) SetRequestPars(v string) *QueryMonitorRequest {
	s.RequestPars = &v
	return s
}

func (s *QueryMonitorRequest) SetStartTime(v int64) *QueryMonitorRequest {
	s.StartTime = &v
	return s
}

func (s *QueryMonitorRequest) SetStep(v int64) *QueryMonitorRequest {
	s.Step = &v
	return s
}

type QueryMonitorResponseBody struct {
	// The details of the data.
	Data []*QueryMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *QueryMonitorResponseBody) SetData(v []*QueryMonitorResponseBodyData) *QueryMonitorResponseBody {
	s.Data = v
	return s
}

func (s *QueryMonitorResponseBody) SetErrorCode(v string) *QueryMonitorResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryMonitorResponseBody) SetMessage(v string) *QueryMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *QueryMonitorResponseBody) SetRequestId(v string) *QueryMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryMonitorResponseBody) SetSuccess(v bool) *QueryMonitorResponseBody {
	s.Success = &v
	return s
}

type QueryMonitorResponseBodyData struct {
	// The prefix of the name.
	ClusterNamePrefix *string `json:"clusterNamePrefix,omitempty" xml:"clusterNamePrefix,omitempty"`
	// The name of the pod.
	PodName *string `json:"podName,omitempty" xml:"podName,omitempty"`
	// The details of the data.
	Values []map[string]interface{} `json:"values,omitempty" xml:"values,omitempty" type:"Repeated"`
}

func (s QueryMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryMonitorResponseBodyData) SetClusterNamePrefix(v string) *QueryMonitorResponseBodyData {
	s.ClusterNamePrefix = &v
	return s
}

func (s *QueryMonitorResponseBodyData) SetPodName(v string) *QueryMonitorResponseBodyData {
	s.PodName = &v
	return s
}

func (s *QueryMonitorResponseBodyData) SetValues(v []map[string]interface{}) *QueryMonitorResponseBodyData {
	s.Values = v
	return s
}

type QueryMonitorResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryMonitorResponse) GoString() string {
	return s.String()
}

func (s *QueryMonitorResponse) SetHeaders(v map[string]*string) *QueryMonitorResponse {
	s.Headers = v
	return s
}

func (s *QueryMonitorResponse) SetStatusCode(v int32) *QueryMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryMonitorResponse) SetBody(v *QueryMonitorResponseBody) *QueryMonitorResponse {
	s.Body = v
	return s
}

type QuerySlbSpecRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
}

func (s QuerySlbSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecRequest) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecRequest) SetAcceptLanguage(v string) *QuerySlbSpecRequest {
	s.AcceptLanguage = &v
	return s
}

type QuerySlbSpecResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data entries returned.
	Data []*QuerySlbSpecResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned. If the request is successful, a success message is returned. If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySlbSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecResponseBody) SetCode(v int32) *QuerySlbSpecResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetData(v []*QuerySlbSpecResponseBodyData) *QuerySlbSpecResponseBody {
	s.Data = v
	return s
}

func (s *QuerySlbSpecResponseBody) SetHttpStatusCode(v int32) *QuerySlbSpecResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetMessage(v string) *QuerySlbSpecResponseBody {
	s.Message = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetRequestId(v string) *QuerySlbSpecResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySlbSpecResponseBody) SetSuccess(v bool) *QuerySlbSpecResponseBody {
	s.Success = &v
	return s
}

type QuerySlbSpecResponseBodyData struct {
	// The ID of the returned data.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The maximum number of connections.
	MaxConnection *string `json:"MaxConnection,omitempty" xml:"MaxConnection,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The maximum connections per second (CPS).
	NewConnectionPerSecond *string `json:"NewConnectionPerSecond,omitempty" xml:"NewConnectionPerSecond,omitempty"`
	// The number of queries per second (QPS).
	Qps *string `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The specifications.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s QuerySlbSpecResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecResponseBodyData) SetId(v int32) *QuerySlbSpecResponseBodyData {
	s.Id = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetMaxConnection(v string) *QuerySlbSpecResponseBodyData {
	s.MaxConnection = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetName(v string) *QuerySlbSpecResponseBodyData {
	s.Name = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetNewConnectionPerSecond(v string) *QuerySlbSpecResponseBodyData {
	s.NewConnectionPerSecond = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetQps(v string) *QuerySlbSpecResponseBodyData {
	s.Qps = &v
	return s
}

func (s *QuerySlbSpecResponseBodyData) SetSpec(v string) *QuerySlbSpecResponseBodyData {
	s.Spec = &v
	return s
}

type QuerySlbSpecResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySlbSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySlbSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySlbSpecResponse) GoString() string {
	return s.String()
}

func (s *QuerySlbSpecResponse) SetHeaders(v map[string]*string) *QuerySlbSpecResponse {
	s.Headers = v
	return s
}

func (s *QuerySlbSpecResponse) SetStatusCode(v int32) *QuerySlbSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySlbSpecResponse) SetBody(v *QuerySlbSpecResponseBody) *QuerySlbSpecResponse {
	s.Body = v
	return s
}

type QuerySwimmingLaneByIdRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
}

func (s QuerySwimmingLaneByIdRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdRequest) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdRequest) SetAcceptLanguage(v string) *QuerySwimmingLaneByIdRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QuerySwimmingLaneByIdRequest) SetLaneId(v int64) *QuerySwimmingLaneByIdRequest {
	s.LaneId = &v
	return s
}

type QuerySwimmingLaneByIdResponseBody struct {
	// The status code. A value of 200 is returned if the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySwimmingLaneByIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdResponseBody) SetCode(v int32) *QuerySwimmingLaneByIdResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetData(v interface{}) *QuerySwimmingLaneByIdResponseBody {
	s.Data = v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetDynamicMessage(v string) *QuerySwimmingLaneByIdResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetErrorCode(v string) *QuerySwimmingLaneByIdResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetHttpStatusCode(v int32) *QuerySwimmingLaneByIdResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetMessage(v string) *QuerySwimmingLaneByIdResponseBody {
	s.Message = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetRequestId(v string) *QuerySwimmingLaneByIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponseBody) SetSuccess(v bool) *QuerySwimmingLaneByIdResponseBody {
	s.Success = &v
	return s
}

type QuerySwimmingLaneByIdResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySwimmingLaneByIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySwimmingLaneByIdResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySwimmingLaneByIdResponse) GoString() string {
	return s.String()
}

func (s *QuerySwimmingLaneByIdResponse) SetHeaders(v map[string]*string) *QuerySwimmingLaneByIdResponse {
	s.Headers = v
	return s
}

func (s *QuerySwimmingLaneByIdResponse) SetStatusCode(v int32) *QuerySwimmingLaneByIdResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySwimmingLaneByIdResponse) SetBody(v *QuerySwimmingLaneByIdResponseBody) *QuerySwimmingLaneByIdResponse {
	s.Body = v
	return s
}

type QueryZnodeDetailRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s QueryZnodeDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailRequest) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailRequest) SetAcceptLanguage(v string) *QueryZnodeDetailRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetClusterId(v string) *QueryZnodeDetailRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetInstanceId(v string) *QueryZnodeDetailRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetPath(v string) *QueryZnodeDetailRequest {
	s.Path = &v
	return s
}

func (s *QueryZnodeDetailRequest) SetRequestPars(v string) *QueryZnodeDetailRequest {
	s.RequestPars = &v
	return s
}

type QueryZnodeDetailResponseBody struct {
	// The details of the data.
	Data *QueryZnodeDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryZnodeDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailResponseBody) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailResponseBody) SetData(v *QueryZnodeDetailResponseBodyData) *QueryZnodeDetailResponseBody {
	s.Data = v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetErrorCode(v string) *QueryZnodeDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetMessage(v string) *QueryZnodeDetailResponseBody {
	s.Message = &v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetRequestId(v string) *QueryZnodeDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryZnodeDetailResponseBody) SetSuccess(v string) *QueryZnodeDetailResponseBody {
	s.Success = &v
	return s
}

type QueryZnodeDetailResponseBodyData struct {
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the node information was returned. Valid values:
	//
	// *   `true`: The node information was returned.
	// *   `false`: The node information failed to be returned.
	Dir *bool `json:"Dir,omitempty" xml:"Dir,omitempty"`
	// The name of the node.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s QueryZnodeDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailResponseBodyData) SetData(v string) *QueryZnodeDetailResponseBodyData {
	s.Data = &v
	return s
}

func (s *QueryZnodeDetailResponseBodyData) SetDir(v bool) *QueryZnodeDetailResponseBodyData {
	s.Dir = &v
	return s
}

func (s *QueryZnodeDetailResponseBodyData) SetName(v string) *QueryZnodeDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryZnodeDetailResponseBodyData) SetPath(v string) *QueryZnodeDetailResponseBodyData {
	s.Path = &v
	return s
}

type QueryZnodeDetailResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryZnodeDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryZnodeDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryZnodeDetailResponse) GoString() string {
	return s.String()
}

func (s *QueryZnodeDetailResponse) SetHeaders(v map[string]*string) *QueryZnodeDetailResponse {
	s.Headers = v
	return s
}

func (s *QueryZnodeDetailResponse) SetStatusCode(v int32) *QueryZnodeDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryZnodeDetailResponse) SetBody(v *QueryZnodeDetailResponseBody) *QueryZnodeDetailResponse {
	s.Body = v
	return s
}

type RestartClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The names of pods. You can specify the names of multiple pods at a time. Separate multiple pod names with commas (,). Example: mse-a8aba010-1629719288255-reg-center-0-1,mse-a8aba010-1629719288255-reg-center-0-2.
	//
	// The specified pods must belong to the current cluster and be associated with the specified instance. Otherwise, a restart exception occurs.
	PodNameList *string `json:"PodNameList,omitempty" xml:"PodNameList,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s RestartClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartClusterRequest) GoString() string {
	return s.String()
}

func (s *RestartClusterRequest) SetAcceptLanguage(v string) *RestartClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *RestartClusterRequest) SetClusterId(v string) *RestartClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *RestartClusterRequest) SetInstanceId(v string) *RestartClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *RestartClusterRequest) SetPodNameList(v string) *RestartClusterRequest {
	s.PodNameList = &v
	return s
}

func (s *RestartClusterRequest) SetRequestPars(v string) *RestartClusterRequest {
	s.RequestPars = &v
	return s
}

type RestartClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RestartClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartClusterResponseBody) GoString() string {
	return s.String()
}

func (s *RestartClusterResponseBody) SetErrorCode(v string) *RestartClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RestartClusterResponseBody) SetMessage(v string) *RestartClusterResponseBody {
	s.Message = &v
	return s
}

func (s *RestartClusterResponseBody) SetRequestId(v string) *RestartClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartClusterResponseBody) SetSuccess(v bool) *RestartClusterResponseBody {
	s.Success = &v
	return s
}

type RestartClusterResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestartClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestartClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartClusterResponse) GoString() string {
	return s.String()
}

func (s *RestartClusterResponse) SetHeaders(v map[string]*string) *RestartClusterResponse {
	s.Headers = v
	return s
}

func (s *RestartClusterResponse) SetStatusCode(v int32) *RestartClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartClusterResponse) SetBody(v *RestartClusterResponseBody) *RestartClusterResponse {
	s.Body = v
	return s
}

type RetryClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s RetryClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s RetryClusterRequest) GoString() string {
	return s.String()
}

func (s *RetryClusterRequest) SetAcceptLanguage(v string) *RetryClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *RetryClusterRequest) SetInstanceId(v string) *RetryClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *RetryClusterRequest) SetRequestPars(v string) *RetryClusterRequest {
	s.RequestPars = &v
	return s
}

type RetryClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RetryClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RetryClusterResponseBody) GoString() string {
	return s.String()
}

func (s *RetryClusterResponseBody) SetErrorCode(v string) *RetryClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RetryClusterResponseBody) SetMessage(v string) *RetryClusterResponseBody {
	s.Message = &v
	return s
}

func (s *RetryClusterResponseBody) SetRequestId(v string) *RetryClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *RetryClusterResponseBody) SetSuccess(v bool) *RetryClusterResponseBody {
	s.Success = &v
	return s
}

type RetryClusterResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RetryClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RetryClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s RetryClusterResponse) GoString() string {
	return s.String()
}

func (s *RetryClusterResponse) SetHeaders(v map[string]*string) *RetryClusterResponse {
	s.Headers = v
	return s
}

func (s *RetryClusterResponse) SetStatusCode(v int32) *RetryClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *RetryClusterResponse) SetBody(v *RetryClusterResponseBody) *RetryClusterResponse {
	s.Body = v
	return s
}

type SelectGatewaySlbRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the SLB instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the SLB instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SelectGatewaySlbRequest) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbRequest) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbRequest) SetAcceptLanguage(v string) *SelectGatewaySlbRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *SelectGatewaySlbRequest) SetGatewayUniqueId(v string) *SelectGatewaySlbRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *SelectGatewaySlbRequest) SetName(v string) *SelectGatewaySlbRequest {
	s.Name = &v
	return s
}

func (s *SelectGatewaySlbRequest) SetType(v string) *SelectGatewaySlbRequest {
	s.Type = &v
	return s
}

type SelectGatewaySlbResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data []*SelectGatewaySlbResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SelectGatewaySlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbResponseBody) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbResponseBody) SetCode(v int32) *SelectGatewaySlbResponseBody {
	s.Code = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetData(v []*SelectGatewaySlbResponseBodyData) *SelectGatewaySlbResponseBody {
	s.Data = v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetHttpStatusCode(v int32) *SelectGatewaySlbResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetMessage(v string) *SelectGatewaySlbResponseBody {
	s.Message = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetRequestId(v string) *SelectGatewaySlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *SelectGatewaySlbResponseBody) SetSuccess(v bool) *SelectGatewaySlbResponseBody {
	s.Success = &v
	return s
}

type SelectGatewaySlbResponseBodyData struct {
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The name of the SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
}

func (s SelectGatewaySlbResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbResponseBodyData) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbResponseBodyData) SetSlbId(v string) *SelectGatewaySlbResponseBodyData {
	s.SlbId = &v
	return s
}

func (s *SelectGatewaySlbResponseBodyData) SetSlbName(v string) *SelectGatewaySlbResponseBodyData {
	s.SlbName = &v
	return s
}

type SelectGatewaySlbResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SelectGatewaySlbResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SelectGatewaySlbResponse) String() string {
	return tea.Prettify(s)
}

func (s SelectGatewaySlbResponse) GoString() string {
	return s.String()
}

func (s *SelectGatewaySlbResponse) SetHeaders(v map[string]*string) *SelectGatewaySlbResponse {
	s.Headers = v
	return s
}

func (s *SelectGatewaySlbResponse) SetStatusCode(v int32) *SelectGatewaySlbResponse {
	s.StatusCode = &v
	return s
}

func (s *SelectGatewaySlbResponse) SetBody(v *SelectGatewaySlbResponseBody) *SelectGatewaySlbResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The instance ID.
	//
	// > This parameter specifies the instance ID that is passed. Examples:
	//
	// *   **ResourceId.1** specifies that the first instance ID is passed.
	// *   **ResourceId.2** specifies that the second instance ID is passed.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resources. Valid values:
	//
	// *   CLUSTER: Microservices Engine (MSE) instance
	// *   GATEWAY: cloud-native gateway
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tags. You can specify a maximum of 20 tags.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetAcceptLanguage(v string) *TagResourcesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The key of a tag that you want to attach to the specified resource. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key must be 1 to 128 characters in length. The tag key cannot start with acs: or aliyun or contain [http:// or https://.](http://https://。)
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of a tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetErrorCode(v string) *TagResourcesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *TagResourcesResponseBody) SetMessage(v string) *TagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *TagResourcesResponseBody) SetSuccess(v bool) *TagResourcesResponseBody {
	s.Success = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs. A maximum of 50 resource IDs can be specified.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resources. Valid values:
	//
	// *   CLUSTER: MSE instance
	// *   GATEWAY: cloud-native gateway
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag keys. A maximum of 20 tag keys are supported.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAcceptLanguage(v string) *UntagResourcesRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetErrorCode(v string) *UntagResourcesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UntagResourcesResponseBody) SetMessage(v string) *UntagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UntagResourcesResponseBody) SetSuccess(v bool) *UntagResourcesResponseBody {
	s.Success = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAclRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The IP addresses or CIDR blocks in the IP address whitelist.
	AclEntryList *string `json:"AclEntryList,omitempty" xml:"AclEntryList,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s UpdateAclRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclRequest) GoString() string {
	return s.String()
}

func (s *UpdateAclRequest) SetAcceptLanguage(v string) *UpdateAclRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateAclRequest) SetAclEntryList(v string) *UpdateAclRequest {
	s.AclEntryList = &v
	return s
}

func (s *UpdateAclRequest) SetInstanceId(v string) *UpdateAclRequest {
	s.InstanceId = &v
	return s
}

type UpdateAclResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAclResponseBody) SetErrorCode(v string) *UpdateAclResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateAclResponseBody) SetMessage(v string) *UpdateAclResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateAclResponseBody) SetRequestId(v string) *UpdateAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAclResponseBody) SetSuccess(v bool) *UpdateAclResponseBody {
	s.Success = &v
	return s
}

type UpdateAclResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAclResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclResponse) GoString() string {
	return s.String()
}

func (s *UpdateAclResponse) SetHeaders(v map[string]*string) *UpdateAclResponse {
	s.Headers = v
	return s
}

func (s *UpdateAclResponse) SetStatusCode(v int32) *UpdateAclResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAclResponse) SetBody(v *UpdateAclResponseBody) *UpdateAclResponse {
	s.Body = v
	return s
}

type UpdateBlackWhiteListRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The content of the blacklist.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the blacklist.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Specifies whether to modify the whitelist.
	IsWhite *bool `json:"IsWhite,omitempty" xml:"IsWhite,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The description.
	Note *string `json:"Note,omitempty" xml:"Note,omitempty"`
	// The resource IDs in the JSON format.
	ResourceIdJsonList *string `json:"ResourceIdJsonList,omitempty" xml:"ResourceIdJsonList,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Specifies whether to enable the blacklist or whitelist.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the blacklist or whitelist.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateBlackWhiteListRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackWhiteListRequest) GoString() string {
	return s.String()
}

func (s *UpdateBlackWhiteListRequest) SetAcceptLanguage(v string) *UpdateBlackWhiteListRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetContent(v string) *UpdateBlackWhiteListRequest {
	s.Content = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetGatewayUniqueId(v string) *UpdateBlackWhiteListRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetId(v int64) *UpdateBlackWhiteListRequest {
	s.Id = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetIsWhite(v bool) *UpdateBlackWhiteListRequest {
	s.IsWhite = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetName(v string) *UpdateBlackWhiteListRequest {
	s.Name = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetNote(v string) *UpdateBlackWhiteListRequest {
	s.Note = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetResourceIdJsonList(v string) *UpdateBlackWhiteListRequest {
	s.ResourceIdJsonList = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetResourceType(v string) *UpdateBlackWhiteListRequest {
	s.ResourceType = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetStatus(v string) *UpdateBlackWhiteListRequest {
	s.Status = &v
	return s
}

func (s *UpdateBlackWhiteListRequest) SetType(v string) *UpdateBlackWhiteListRequest {
	s.Type = &v
	return s
}

type UpdateBlackWhiteListResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the record.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// Request
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateBlackWhiteListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackWhiteListResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBlackWhiteListResponseBody) SetCode(v int32) *UpdateBlackWhiteListResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetData(v int64) *UpdateBlackWhiteListResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetHttpStatusCode(v int32) *UpdateBlackWhiteListResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetMessage(v string) *UpdateBlackWhiteListResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetRequestId(v string) *UpdateBlackWhiteListResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateBlackWhiteListResponseBody) SetSuccess(v bool) *UpdateBlackWhiteListResponseBody {
	s.Success = &v
	return s
}

type UpdateBlackWhiteListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBlackWhiteListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBlackWhiteListResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackWhiteListResponse) GoString() string {
	return s.String()
}

func (s *UpdateBlackWhiteListResponse) SetHeaders(v map[string]*string) *UpdateBlackWhiteListResponse {
	s.Headers = v
	return s
}

func (s *UpdateBlackWhiteListResponse) SetStatusCode(v int32) *UpdateBlackWhiteListResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBlackWhiteListResponse) SetBody(v *UpdateBlackWhiteListResponseBody) *UpdateBlackWhiteListResponse {
	s.Body = v
	return s
}

type UpdateClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The alias of the instance.
	ClusterAliasName *string `json:"ClusterAliasName,omitempty" xml:"ClusterAliasName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s UpdateClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterRequest) GoString() string {
	return s.String()
}

func (s *UpdateClusterRequest) SetAcceptLanguage(v string) *UpdateClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateClusterRequest) SetClusterAliasName(v string) *UpdateClusterRequest {
	s.ClusterAliasName = &v
	return s
}

func (s *UpdateClusterRequest) SetInstanceId(v string) *UpdateClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateClusterRequest) SetRequestPars(v string) *UpdateClusterRequest {
	s.RequestPars = &v
	return s
}

type UpdateClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateClusterResponseBody) SetErrorCode(v string) *UpdateClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateClusterResponseBody) SetHttpStatusCode(v string) *UpdateClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateClusterResponseBody) SetMessage(v string) *UpdateClusterResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateClusterResponseBody) SetRequestId(v string) *UpdateClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateClusterResponseBody) SetSuccess(v bool) *UpdateClusterResponseBody {
	s.Success = &v
	return s
}

type UpdateClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterResponse) GoString() string {
	return s.String()
}

func (s *UpdateClusterResponse) SetHeaders(v map[string]*string) *UpdateClusterResponse {
	s.Headers = v
	return s
}

func (s *UpdateClusterResponse) SetStatusCode(v int32) *UpdateClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateClusterResponse) SetBody(v *UpdateClusterResponseBody) *UpdateClusterResponse {
	s.Body = v
	return s
}

type UpdateClusterSpecRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The destination engine specifications.
	ClusterSpecification *string `json:"ClusterSpecification,omitempty" xml:"ClusterSpecification,omitempty"`
	// The number of destination nodes.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The ID of the instance
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The MSE version.
	MseVersion *string `json:"MseVersion,omitempty" xml:"MseVersion,omitempty"`
}

func (s UpdateClusterSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterSpecRequest) GoString() string {
	return s.String()
}

func (s *UpdateClusterSpecRequest) SetAcceptLanguage(v string) *UpdateClusterSpecRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetClusterId(v string) *UpdateClusterSpecRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetClusterSpecification(v string) *UpdateClusterSpecRequest {
	s.ClusterSpecification = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetInstanceCount(v int32) *UpdateClusterSpecRequest {
	s.InstanceCount = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetInstanceId(v string) *UpdateClusterSpecRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateClusterSpecRequest) SetMseVersion(v string) *UpdateClusterSpecRequest {
	s.MseVersion = &v
	return s
}

type UpdateClusterSpecResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// A reserved parameter.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed. Take note of the following rules:
	//
	// *   The **ErrorCode** parameter is not returned if the request succeeds.
	// *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section in this topic.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateClusterSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterSpecResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateClusterSpecResponseBody) SetCode(v int32) *UpdateClusterSpecResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetData(v string) *UpdateClusterSpecResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetErrorCode(v string) *UpdateClusterSpecResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetHttpStatusCode(v int32) *UpdateClusterSpecResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetMessage(v string) *UpdateClusterSpecResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetRequestId(v string) *UpdateClusterSpecResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateClusterSpecResponseBody) SetSuccess(v bool) *UpdateClusterSpecResponseBody {
	s.Success = &v
	return s
}

type UpdateClusterSpecResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateClusterSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateClusterSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateClusterSpecResponse) GoString() string {
	return s.String()
}

func (s *UpdateClusterSpecResponse) SetHeaders(v map[string]*string) *UpdateClusterSpecResponse {
	s.Headers = v
	return s
}

func (s *UpdateClusterSpecResponse) SetStatusCode(v int32) *UpdateClusterSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateClusterSpecResponse) SetBody(v *UpdateClusterSpecResponseBody) *UpdateClusterSpecResponse {
	s.Body = v
	return s
}

type UpdateConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// A reserved parameter.
	AutopurgePurgeInterval *string `json:"AutopurgePurgeInterval,omitempty" xml:"AutopurgePurgeInterval,omitempty"`
	// A reserved parameter.
	AutopurgeSnapRetainCount *string `json:"AutopurgeSnapRetainCount,omitempty" xml:"AutopurgeSnapRetainCount,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Specifies whether to enable RAM authorization for a configuration center. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the ConfigAuthSupported parameter value to check whether the instance supports this feature.
	ConfigAuthEnabled *bool `json:"ConfigAuthEnabled,omitempty" xml:"ConfigAuthEnabled,omitempty"`
	// Specifies whether to enable configuration encryption for a configuration center. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the ConfigSecretSupported parameter value to check whether the instance supports this feature.
	ConfigSecretEnabled *bool `json:"ConfigSecretEnabled,omitempty" xml:"ConfigSecretEnabled,omitempty"`
	// The format of the configuration. Supported formats include TEXT, JSON, XML, and HTML.
	ConfigType      *string `json:"ConfigType,omitempty" xml:"ConfigType,omitempty"`
	EurekaSupported *bool   `json:"EurekaSupported,omitempty" xml:"EurekaSupported,omitempty"`
	// Specifies whether to enable the time to live (TTL) configuration.
	ExtendedTypesEnable *string `json:"ExtendedTypesEnable,omitempty" xml:"ExtendedTypesEnable,omitempty"`
	// The maximum connection duration of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
	InitLimit *string `json:"InitLimit,omitempty" xml:"InitLimit,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The maximum amount of data on each node. This parameter is valid for ZooKeeper instances. The default maximum data amount on each node is 1 megabyte. Unit: bytes.
	JuteMaxbuffer *string `json:"JuteMaxbuffer,omitempty" xml:"JuteMaxbuffer,omitempty"`
	// Specifies whether to enable Mesh Configuration Protocol (MCP). This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the MCPSupported parameter value to check whether the instance supports this feature.
	MCPEnabled *bool `json:"MCPEnabled,omitempty" xml:"MCPEnabled,omitempty"`
	// The number of connections between a client and a server. This parameter is valid for ZooKeeper instances.\
	// If this parameter is set to 0, no limits are imposed on the number of connections.
	MaxClientCnxns *string `json:"MaxClientCnxns,omitempty" xml:"MaxClientCnxns,omitempty"`
	// The maximum timeout period. This parameter is valid for ZooKeeper instances. Unit: seconds.
	MaxSessionTimeout *string `json:"MaxSessionTimeout,omitempty" xml:"MaxSessionTimeout,omitempty"`
	// The minimum timeout period. This parameter is valid for ZooKeeper instances. Unit: seconds.
	MinSessionTimeout *string `json:"MinSessionTimeout,omitempty" xml:"MinSessionTimeout,omitempty"`
	// Specifies whether to enable RAM authorization for a registry. This parameter is valid for Nacos instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	//
	// > Before you configure this parameter, you must call the QueryConfig operation to obtain the NamingAuthSupporte parameter value to check whether the instance supports this feature.
	NamingAuthEnabled *bool `json:"NamingAuthEnabled,omitempty" xml:"NamingAuthEnabled,omitempty"`
	// Specifies whether to enable super permissions. This parameter is valid for ZooKeeper instances. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	OpenSuperAcl *string `json:"OpenSuperAcl,omitempty" xml:"OpenSuperAcl,omitempty"`
	// The password that corresponds to the username.
	//
	// > You must specify this parameter if OpenSuperAcl is set to true.
	PassWord *string `json:"PassWord,omitempty" xml:"PassWord,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The frequency for generating snapshots. This parameter is valid for ZooKeeper instances.
	SnapshotCount *string `json:"SnapshotCount,omitempty" xml:"SnapshotCount,omitempty"`
	// The connection timeout period of the instance. This parameter is valid for ZooKeeper instances. Unit: seconds.
	SyncLimit *string `json:"SyncLimit,omitempty" xml:"SyncLimit,omitempty"`
	// The time unit. This parameter is valid for ZooKeeper instances. Default value: 2000. Unit: milliseconds.
	TickTime *string `json:"TickTime,omitempty" xml:"TickTime,omitempty"`
	// The name of the user.
	//
	// > You must specify this parameter if OpenSuperAcl is set to true.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s UpdateConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigRequest) SetAcceptLanguage(v string) *UpdateConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateConfigRequest) SetAutopurgePurgeInterval(v string) *UpdateConfigRequest {
	s.AutopurgePurgeInterval = &v
	return s
}

func (s *UpdateConfigRequest) SetAutopurgeSnapRetainCount(v string) *UpdateConfigRequest {
	s.AutopurgeSnapRetainCount = &v
	return s
}

func (s *UpdateConfigRequest) SetClusterId(v string) *UpdateConfigRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateConfigRequest) SetConfigAuthEnabled(v bool) *UpdateConfigRequest {
	s.ConfigAuthEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetConfigSecretEnabled(v bool) *UpdateConfigRequest {
	s.ConfigSecretEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetConfigType(v string) *UpdateConfigRequest {
	s.ConfigType = &v
	return s
}

func (s *UpdateConfigRequest) SetEurekaSupported(v bool) *UpdateConfigRequest {
	s.EurekaSupported = &v
	return s
}

func (s *UpdateConfigRequest) SetExtendedTypesEnable(v string) *UpdateConfigRequest {
	s.ExtendedTypesEnable = &v
	return s
}

func (s *UpdateConfigRequest) SetInitLimit(v string) *UpdateConfigRequest {
	s.InitLimit = &v
	return s
}

func (s *UpdateConfigRequest) SetInstanceId(v string) *UpdateConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateConfigRequest) SetJuteMaxbuffer(v string) *UpdateConfigRequest {
	s.JuteMaxbuffer = &v
	return s
}

func (s *UpdateConfigRequest) SetMCPEnabled(v bool) *UpdateConfigRequest {
	s.MCPEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetMaxClientCnxns(v string) *UpdateConfigRequest {
	s.MaxClientCnxns = &v
	return s
}

func (s *UpdateConfigRequest) SetMaxSessionTimeout(v string) *UpdateConfigRequest {
	s.MaxSessionTimeout = &v
	return s
}

func (s *UpdateConfigRequest) SetMinSessionTimeout(v string) *UpdateConfigRequest {
	s.MinSessionTimeout = &v
	return s
}

func (s *UpdateConfigRequest) SetNamingAuthEnabled(v bool) *UpdateConfigRequest {
	s.NamingAuthEnabled = &v
	return s
}

func (s *UpdateConfigRequest) SetOpenSuperAcl(v string) *UpdateConfigRequest {
	s.OpenSuperAcl = &v
	return s
}

func (s *UpdateConfigRequest) SetPassWord(v string) *UpdateConfigRequest {
	s.PassWord = &v
	return s
}

func (s *UpdateConfigRequest) SetRequestPars(v string) *UpdateConfigRequest {
	s.RequestPars = &v
	return s
}

func (s *UpdateConfigRequest) SetSnapshotCount(v string) *UpdateConfigRequest {
	s.SnapshotCount = &v
	return s
}

func (s *UpdateConfigRequest) SetSyncLimit(v string) *UpdateConfigRequest {
	s.SyncLimit = &v
	return s
}

func (s *UpdateConfigRequest) SetTickTime(v string) *UpdateConfigRequest {
	s.TickTime = &v
	return s
}

func (s *UpdateConfigRequest) SetUserName(v string) *UpdateConfigRequest {
	s.UserName = &v
	return s
}

type UpdateConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConfigResponseBody) SetCode(v int32) *UpdateConfigResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateConfigResponseBody) SetHttpStatusCode(v int32) *UpdateConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateConfigResponseBody) SetMessage(v string) *UpdateConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateConfigResponseBody) SetRequestId(v string) *UpdateConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateConfigResponseBody) SetSuccess(v bool) *UpdateConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateConfigResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateConfigResponse) SetHeaders(v map[string]*string) *UpdateConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateConfigResponse) SetStatusCode(v int32) *UpdateConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConfigResponse) SetBody(v *UpdateConfigResponseBody) *UpdateConfigResponse {
	s.Body = v
	return s
}

type UpdateEngineNamespaceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The description of the cluster.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The ID of the namespace.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the cluster.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of active services.
	ServiceCount *int32 `json:"ServiceCount,omitempty" xml:"ServiceCount,omitempty"`
}

func (s UpdateEngineNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceRequest) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceRequest) SetAcceptLanguage(v string) *UpdateEngineNamespaceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetClusterId(v string) *UpdateEngineNamespaceRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetDesc(v string) *UpdateEngineNamespaceRequest {
	s.Desc = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetId(v string) *UpdateEngineNamespaceRequest {
	s.Id = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetInstanceId(v string) *UpdateEngineNamespaceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetName(v string) *UpdateEngineNamespaceRequest {
	s.Name = &v
	return s
}

func (s *UpdateEngineNamespaceRequest) SetServiceCount(v int32) *UpdateEngineNamespaceRequest {
	s.ServiceCount = &v
	return s
}

type UpdateEngineNamespaceResponseBody struct {
	// The details of the data.
	Data *UpdateEngineNamespaceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateEngineNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceResponseBody) SetData(v *UpdateEngineNamespaceResponseBodyData) *UpdateEngineNamespaceResponseBody {
	s.Data = v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetErrorCode(v string) *UpdateEngineNamespaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetMessage(v string) *UpdateEngineNamespaceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetRequestId(v string) *UpdateEngineNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBody) SetSuccess(v bool) *UpdateEngineNamespaceResponseBody {
	s.Success = &v
	return s
}

type UpdateEngineNamespaceResponseBodyData struct {
	// The quota value.
	ConfigCount *int32 `json:"ConfigCount,omitempty" xml:"ConfigCount,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the namespace.
	NamespaceDesc *string `json:"NamespaceDesc,omitempty" xml:"NamespaceDesc,omitempty"`
	// The display name of the namespace.
	NamespaceShowName *string `json:"NamespaceShowName,omitempty" xml:"NamespaceShowName,omitempty"`
	// The quota of configurations.
	Quota *int32 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The type of the namespace. Valid values:
	//
	// *   `0`: global configuration
	// *   `1`: default namespace
	// *   `2`: custom namespace
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateEngineNamespaceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceResponseBodyData) SetConfigCount(v int32) *UpdateEngineNamespaceResponseBodyData {
	s.ConfigCount = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetNamespace(v string) *UpdateEngineNamespaceResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetNamespaceDesc(v string) *UpdateEngineNamespaceResponseBodyData {
	s.NamespaceDesc = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetNamespaceShowName(v string) *UpdateEngineNamespaceResponseBodyData {
	s.NamespaceShowName = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetQuota(v int32) *UpdateEngineNamespaceResponseBodyData {
	s.Quota = &v
	return s
}

func (s *UpdateEngineNamespaceResponseBodyData) SetType(v int32) *UpdateEngineNamespaceResponseBodyData {
	s.Type = &v
	return s
}

type UpdateEngineNamespaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEngineNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEngineNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEngineNamespaceResponse) GoString() string {
	return s.String()
}

func (s *UpdateEngineNamespaceResponse) SetHeaders(v map[string]*string) *UpdateEngineNamespaceResponse {
	s.Headers = v
	return s
}

func (s *UpdateEngineNamespaceResponse) SetStatusCode(v int32) *UpdateEngineNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEngineNamespaceResponse) SetBody(v *UpdateEngineNamespaceResponseBody) *UpdateEngineNamespaceResponse {
	s.Body = v
	return s
}

type UpdateGatewayDomainRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// Specifies whether to enable `HTTP/2`.
	//
	// *   `open`: `HTTP/2` is enabled.
	// *   `close`: `HTTP/2` is disabled.
	// *   `globalConfig`: Global configurations are used.
	Http2 *string `json:"Http2,omitempty" xml:"Http2,omitempty"`
	// The ID of the domain name that you want to update.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Specifies whether to forcibly use HTTPS.
	MustHttps *bool `json:"MustHttps,omitempty" xml:"MustHttps,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   HTTPS
	// *   HTTP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The maximum version of Transport Layer Security (TLS).
	TlsMax *string `json:"TlsMax,omitempty" xml:"TlsMax,omitempty"`
	// The minimum version of TLS.
	TlsMin *string `json:"TlsMin,omitempty" xml:"TlsMin,omitempty"`
}

func (s UpdateGatewayDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayDomainRequest) SetAcceptLanguage(v string) *UpdateGatewayDomainRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetCertIdentifier(v string) *UpdateGatewayDomainRequest {
	s.CertIdentifier = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetGatewayUniqueId(v string) *UpdateGatewayDomainRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetHttp2(v string) *UpdateGatewayDomainRequest {
	s.Http2 = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetId(v int64) *UpdateGatewayDomainRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetMustHttps(v bool) *UpdateGatewayDomainRequest {
	s.MustHttps = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetProtocol(v string) *UpdateGatewayDomainRequest {
	s.Protocol = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetTlsMax(v string) *UpdateGatewayDomainRequest {
	s.TlsMax = &v
	return s
}

func (s *UpdateGatewayDomainRequest) SetTlsMin(v string) *UpdateGatewayDomainRequest {
	s.TlsMin = &v
	return s
}

type UpdateGatewayDomainResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayDomainResponseBody) SetCode(v int32) *UpdateGatewayDomainResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetData(v int64) *UpdateGatewayDomainResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayDomainResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetMessage(v string) *UpdateGatewayDomainResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetRequestId(v string) *UpdateGatewayDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayDomainResponseBody) SetSuccess(v bool) *UpdateGatewayDomainResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayDomainResponse) SetHeaders(v map[string]*string) *UpdateGatewayDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayDomainResponse) SetStatusCode(v int32) *UpdateGatewayDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayDomainResponse) SetBody(v *UpdateGatewayDomainResponseBody) *UpdateGatewayDomainResponse {
	s.Body = v
	return s
}

type UpdateGatewayNameRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The name of the gateway.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateGatewayNameRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayNameRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayNameRequest) SetAcceptLanguage(v string) *UpdateGatewayNameRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayNameRequest) SetGatewayUniqueId(v string) *UpdateGatewayNameRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayNameRequest) SetName(v string) *UpdateGatewayNameRequest {
	s.Name = &v
	return s
}

type UpdateGatewayNameResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayNameResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayNameResponseBody) SetCode(v int32) *UpdateGatewayNameResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetData(v string) *UpdateGatewayNameResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayNameResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetMessage(v string) *UpdateGatewayNameResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetRequestId(v string) *UpdateGatewayNameResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayNameResponseBody) SetSuccess(v bool) *UpdateGatewayNameResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayNameResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayNameResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayNameResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayNameResponse) SetHeaders(v map[string]*string) *UpdateGatewayNameResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayNameResponse) SetStatusCode(v int32) *UpdateGatewayNameResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayNameResponse) SetBody(v *UpdateGatewayNameResponseBody) *UpdateGatewayNameResponse {
	s.Body = v
	return s
}

type UpdateGatewayOptionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The detailed configurations of the gateway.
	//
	// *   **TraceDetails**: the sampling description of Tracing Analysis. Content: TraceEnabled specifies whether to activate Tracing Analysis. Sample specifies the sampling rate of Tracing Analysis.
	// *   **LogConfigDetails**: the description of Log Service. Content: LogEnabled specifies whether to activate Log Service. ProjectName specifies the Log Service project to which logs are delivered. LogStoreName specifies the name of the Logstore.
	// *   **EnableHardwareAcceleration**: specifies whether to enable hardware acceleration.
	// *   **DisableHttp2Alpn**: specifies whether to disable the HTTP/2 protocol.
	// *   **EnableWaf**: specifies whether to activate Web Application Firewall (WAF).
	GatewayOption *GatewayOption `json:"GatewayOption,omitempty" xml:"GatewayOption,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s UpdateGatewayOptionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionRequest) SetAcceptLanguage(v string) *UpdateGatewayOptionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayOptionRequest) SetGatewayId(v int64) *UpdateGatewayOptionRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayOptionRequest) SetGatewayOption(v *GatewayOption) *UpdateGatewayOptionRequest {
	s.GatewayOption = v
	return s
}

func (s *UpdateGatewayOptionRequest) SetGatewayUniqueId(v string) *UpdateGatewayOptionRequest {
	s.GatewayUniqueId = &v
	return s
}

type UpdateGatewayOptionShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The detailed configurations of the gateway.
	//
	// *   **TraceDetails**: the sampling description of Tracing Analysis. Content: TraceEnabled specifies whether to activate Tracing Analysis. Sample specifies the sampling rate of Tracing Analysis.
	// *   **LogConfigDetails**: the description of Log Service. Content: LogEnabled specifies whether to activate Log Service. ProjectName specifies the Log Service project to which logs are delivered. LogStoreName specifies the name of the Logstore.
	// *   **EnableHardwareAcceleration**: specifies whether to enable hardware acceleration.
	// *   **DisableHttp2Alpn**: specifies whether to disable the HTTP/2 protocol.
	// *   **EnableWaf**: specifies whether to activate Web Application Firewall (WAF).
	GatewayOptionShrink *string `json:"GatewayOption,omitempty" xml:"GatewayOption,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s UpdateGatewayOptionShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayOptionShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayOptionShrinkRequest) SetGatewayId(v int64) *UpdateGatewayOptionShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayOptionShrinkRequest) SetGatewayOptionShrink(v string) *UpdateGatewayOptionShrinkRequest {
	s.GatewayOptionShrink = &v
	return s
}

func (s *UpdateGatewayOptionShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayOptionShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

type UpdateGatewayOptionResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GatewayOption `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayOptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionResponseBody) SetCode(v int32) *UpdateGatewayOptionResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetData(v *GatewayOption) *UpdateGatewayOptionResponseBody {
	s.Data = v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayOptionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetMessage(v string) *UpdateGatewayOptionResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetRequestId(v string) *UpdateGatewayOptionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayOptionResponseBody) SetSuccess(v bool) *UpdateGatewayOptionResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayOptionResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayOptionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayOptionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayOptionResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayOptionResponse) SetHeaders(v map[string]*string) *UpdateGatewayOptionResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayOptionResponse) SetStatusCode(v int32) *UpdateGatewayOptionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayOptionResponse) SetBody(v *UpdateGatewayOptionResponseBody) *UpdateGatewayOptionResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponseJSON *UpdateGatewayRouteRequestDirectResponseJSON `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty" type:"Struct"`
	// The associated domain name.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to enable Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServices []*UpdateGatewayRouteRequestFallbackServices `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty" type:"Repeated"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The route matching conditions.
	Predicates *UpdateGatewayRouteRequestPredicates `json:"Predicates,omitempty" xml:"Predicates,omitempty" type:"Struct"`
	// The information about redirection.
	RedirectJSON *UpdateGatewayRouteRequestRedirectJSON `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty" type:"Struct"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about destination services.
	Services []*UpdateGatewayRouteRequestServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetDestinationType(v string) *UpdateGatewayRouteRequest {
	s.DestinationType = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetDirectResponseJSON(v *UpdateGatewayRouteRequestDirectResponseJSON) *UpdateGatewayRouteRequest {
	s.DirectResponseJSON = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetDomainIdListJSON(v string) *UpdateGatewayRouteRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetEnableWaf(v bool) *UpdateGatewayRouteRequest {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetFallback(v bool) *UpdateGatewayRouteRequest {
	s.Fallback = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetFallbackServices(v []*UpdateGatewayRouteRequestFallbackServices) *UpdateGatewayRouteRequest {
	s.FallbackServices = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetGatewayId(v int64) *UpdateGatewayRouteRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetId(v int64) *UpdateGatewayRouteRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetName(v string) *UpdateGatewayRouteRequest {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetPredicates(v *UpdateGatewayRouteRequestPredicates) *UpdateGatewayRouteRequest {
	s.Predicates = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetRedirectJSON(v *UpdateGatewayRouteRequestRedirectJSON) *UpdateGatewayRouteRequest {
	s.RedirectJSON = v
	return s
}

func (s *UpdateGatewayRouteRequest) SetRouteOrder(v int32) *UpdateGatewayRouteRequest {
	s.RouteOrder = &v
	return s
}

func (s *UpdateGatewayRouteRequest) SetServices(v []*UpdateGatewayRouteRequestServices) *UpdateGatewayRouteRequest {
	s.Services = v
	return s
}

type UpdateGatewayRouteRequestDirectResponseJSON struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The mock return code.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s UpdateGatewayRouteRequestDirectResponseJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestDirectResponseJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestDirectResponseJSON) SetBody(v string) *UpdateGatewayRouteRequestDirectResponseJSON {
	s.Body = &v
	return s
}

func (s *UpdateGatewayRouteRequestDirectResponseJSON) SetCode(v int64) *UpdateGatewayRouteRequestDirectResponseJSON {
	s.Code = &v
	return s
}

type UpdateGatewayRouteRequestFallbackServices struct {
	// The type of the protocol. Valid values:
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace in which the service resides.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight in the form of a percentage value.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The service port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s UpdateGatewayRouteRequestFallbackServices) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestFallbackServices) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetAgreementType(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.AgreementType = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetGroupName(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.GroupName = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetName(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetNamespace(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.Namespace = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetPercent(v int32) *UpdateGatewayRouteRequestFallbackServices {
	s.Percent = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetServiceId(v int64) *UpdateGatewayRouteRequestFallbackServices {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetServicePort(v int32) *UpdateGatewayRouteRequestFallbackServices {
	s.ServicePort = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetSourceType(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.SourceType = &v
	return s
}

func (s *UpdateGatewayRouteRequestFallbackServices) SetVersion(v string) *UpdateGatewayRouteRequestFallbackServices {
	s.Version = &v
	return s
}

type UpdateGatewayRouteRequestPredicates struct {
	// The information about header matching.
	HeaderPredicates []*UpdateGatewayRouteRequestPredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about path matching.
	PathPredicates *UpdateGatewayRouteRequestPredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The information about parameter matching.
	QueryPredicates []*UpdateGatewayRouteRequestPredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequestPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicates) SetHeaderPredicates(v []*UpdateGatewayRouteRequestPredicatesHeaderPredicates) *UpdateGatewayRouteRequestPredicates {
	s.HeaderPredicates = v
	return s
}

func (s *UpdateGatewayRouteRequestPredicates) SetMethodPredicates(v []*string) *UpdateGatewayRouteRequestPredicates {
	s.MethodPredicates = v
	return s
}

func (s *UpdateGatewayRouteRequestPredicates) SetPathPredicates(v *UpdateGatewayRouteRequestPredicatesPathPredicates) *UpdateGatewayRouteRequestPredicates {
	s.PathPredicates = v
	return s
}

func (s *UpdateGatewayRouteRequestPredicates) SetQueryPredicates(v []*UpdateGatewayRouteRequestPredicatesQueryPredicates) *UpdateGatewayRouteRequestPredicates {
	s.QueryPredicates = v
	return s
}

type UpdateGatewayRouteRequestPredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteRequestPredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicatesHeaderPredicates) SetKey(v string) *UpdateGatewayRouteRequestPredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesHeaderPredicates) SetType(v string) *UpdateGatewayRouteRequestPredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesHeaderPredicates) SetValue(v string) *UpdateGatewayRouteRequestPredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteRequestPredicatesPathPredicates struct {
	// Specifies whether to perform case-insensitive matching.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path used for route matching.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateGatewayRouteRequestPredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicatesPathPredicates) SetIgnoreCase(v bool) *UpdateGatewayRouteRequestPredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesPathPredicates) SetPath(v string) *UpdateGatewayRouteRequestPredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesPathPredicates) SetType(v string) *UpdateGatewayRouteRequestPredicatesPathPredicates {
	s.Type = &v
	return s
}

type UpdateGatewayRouteRequestPredicatesQueryPredicates struct {
	// The name of the parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteRequestPredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestPredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestPredicatesQueryPredicates) SetKey(v string) *UpdateGatewayRouteRequestPredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesQueryPredicates) SetType(v string) *UpdateGatewayRouteRequestPredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteRequestPredicatesQueryPredicates) SetValue(v string) *UpdateGatewayRouteRequestPredicatesQueryPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteRequestRedirectJSON struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname to be redirected to.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path to be redirected to.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s UpdateGatewayRouteRequestRedirectJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestRedirectJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestRedirectJSON) SetCode(v int32) *UpdateGatewayRouteRequestRedirectJSON {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteRequestRedirectJSON) SetHost(v string) *UpdateGatewayRouteRequestRedirectJSON {
	s.Host = &v
	return s
}

func (s *UpdateGatewayRouteRequestRedirectJSON) SetPath(v string) *UpdateGatewayRouteRequestRedirectJSON {
	s.Path = &v
	return s
}

type UpdateGatewayRouteRequestServices struct {
	// The type of the protocol. Valid values:
	AgreementType *string `json:"AgreementType,omitempty" xml:"AgreementType,omitempty"`
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The transcoder of the Dubbo protocol.
	HttpDubboTranscoder *UpdateGatewayRouteRequestServicesHttpDubboTranscoder `json:"HttpDubboTranscoder,omitempty" xml:"HttpDubboTranscoder,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace in which the service resides.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The percentage.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The Dubbo port number.
	ServicePort *int32 `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s UpdateGatewayRouteRequestServices) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServices) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServices) SetAgreementType(v string) *UpdateGatewayRouteRequestServices {
	s.AgreementType = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetGroupName(v string) *UpdateGatewayRouteRequestServices {
	s.GroupName = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetHttpDubboTranscoder(v *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) *UpdateGatewayRouteRequestServices {
	s.HttpDubboTranscoder = v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetName(v string) *UpdateGatewayRouteRequestServices {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetNamespace(v string) *UpdateGatewayRouteRequestServices {
	s.Namespace = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetPercent(v int32) *UpdateGatewayRouteRequestServices {
	s.Percent = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetServiceId(v int64) *UpdateGatewayRouteRequestServices {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetServicePort(v int32) *UpdateGatewayRouteRequestServices {
	s.ServicePort = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetSourceType(v string) *UpdateGatewayRouteRequestServices {
	s.SourceType = &v
	return s
}

func (s *UpdateGatewayRouteRequestServices) SetVersion(v string) *UpdateGatewayRouteRequestServices {
	s.Version = &v
	return s
}

type UpdateGatewayRouteRequestServicesHttpDubboTranscoder struct {
	// The Dubbo service group.
	DubboServiceGroup *string `json:"DubboServiceGroup,omitempty" xml:"DubboServiceGroup,omitempty"`
	// The name of the Dubbo service.
	DubboServiceName *string `json:"DubboServiceName,omitempty" xml:"DubboServiceName,omitempty"`
	// The version of the Dubbo service.
	DubboServiceVersion *string `json:"DubboServiceVersion,omitempty" xml:"DubboServiceVersion,omitempty"`
	// The forwarding rules of the Dubbo service.
	MothedMapList []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList `json:"MothedMapList,omitempty" xml:"MothedMapList,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoder) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoder) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceGroup(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceGroup = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceName(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceName = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetDubboServiceVersion(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.DubboServiceVersion = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoder) SetMothedMapList(v []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) *UpdateGatewayRouteRequestServicesHttpDubboTranscoder {
	s.MothedMapList = v
	return s
}

type UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList struct {
	// The method name of the Dubbo service.
	DubboMothedName *string `json:"DubboMothedName,omitempty" xml:"DubboMothedName,omitempty"`
	// The HTTP method.
	//
	// > Valid values:
	//
	// *   ALL_GET
	//
	// *   ALL_POST
	//
	// *   ALL_PUT
	//
	// *   ALL_DELETE
	//
	// *   ALL_PATCH
	HttpMothed *string `json:"HttpMothed,omitempty" xml:"HttpMothed,omitempty"`
	// The path that is used to match a method.
	Mothedpath *string `json:"Mothedpath,omitempty" xml:"Mothedpath,omitempty"`
	// The information of parameter mappings.
	ParamMapsList []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList `json:"ParamMapsList,omitempty" xml:"ParamMapsList,omitempty" type:"Repeated"`
	// The pass-through type of the header.
	//
	// > Valid values:
	//
	// *   PASS_ALL: All headers are passed through.
	//
	// *   PASS_NOT: All headers are not passed through.
	//
	// *   PASS_ASSIGN: Specified headers are passed through.
	PassThroughAllHeaders *string `json:"PassThroughAllHeaders,omitempty" xml:"PassThroughAllHeaders,omitempty"`
	// The list of headers to be passed through.
	PassThroughList []*string `json:"PassThroughList,omitempty" xml:"PassThroughList,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetDubboMothedName(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.DubboMothedName = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetHttpMothed(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.HttpMothed = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetMothedpath(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.Mothedpath = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetParamMapsList(v []*UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.ParamMapsList = v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughAllHeaders(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughAllHeaders = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList) SetPassThroughList(v []*string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapList {
	s.PassThroughList = v
	return s
}

type UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList struct {
	// The key extracted from the input parameter.
	ExtractKey *string `json:"ExtractKey,omitempty" xml:"ExtractKey,omitempty"`
	// The position of the input parameter.
	//
	// > Valid values:
	//
	// *   `ALL_QUERY_PARAMETER`: request parameter
	//
	// *   `ALL_HEADER`: request header
	//
	// *   `ALL_PATH`: request path
	//
	// *   `ALL_BODY`: request body
	ExtractKeySpec *string `json:"ExtractKeySpec,omitempty" xml:"ExtractKeySpec,omitempty"`
	// The type of the backend service parameter.
	MappingType *string `json:"MappingType,omitempty" xml:"MappingType,omitempty"`
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKey(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKey = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetExtractKeySpec(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.ExtractKeySpec = &v
	return s
}

func (s *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList) SetMappingType(v string) *UpdateGatewayRouteRequestServicesHttpDubboTranscoderMothedMapListParamMapsList {
	s.MappingType = &v
	return s
}

type UpdateGatewayRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponseJSONShrink *string `json:"DirectResponseJSON,omitempty" xml:"DirectResponseJSON,omitempty"`
	// The associated domain name.
	DomainIdListJSON *string `json:"DomainIdListJSON,omitempty" xml:"DomainIdListJSON,omitempty"`
	// Specifies whether to enable Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// Specifies whether to enable the Fallback service.
	Fallback *bool `json:"Fallback,omitempty" xml:"Fallback,omitempty"`
	// The information about the Fallback service.
	FallbackServicesShrink *string `json:"FallbackServices,omitempty" xml:"FallbackServices,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The route matching conditions.
	PredicatesShrink *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The information about redirection.
	RedirectJSONShrink *string `json:"RedirectJSON,omitempty" xml:"RedirectJSON,omitempty"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about destination services.
	ServicesShrink *string `json:"Services,omitempty" xml:"Services,omitempty"`
}

func (s UpdateGatewayRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetDestinationType(v string) *UpdateGatewayRouteShrinkRequest {
	s.DestinationType = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetDirectResponseJSONShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.DirectResponseJSONShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetDomainIdListJSON(v string) *UpdateGatewayRouteShrinkRequest {
	s.DomainIdListJSON = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetEnableWaf(v bool) *UpdateGatewayRouteShrinkRequest {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetFallback(v bool) *UpdateGatewayRouteShrinkRequest {
	s.Fallback = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetFallbackServicesShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.FallbackServicesShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetId(v int64) *UpdateGatewayRouteShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetName(v string) *UpdateGatewayRouteShrinkRequest {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetPredicatesShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.PredicatesShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetRedirectJSONShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.RedirectJSONShrink = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetRouteOrder(v int32) *UpdateGatewayRouteShrinkRequest {
	s.RouteOrder = &v
	return s
}

func (s *UpdateGatewayRouteShrinkRequest) SetServicesShrink(v string) *UpdateGatewayRouteShrinkRequest {
	s.ServicesShrink = &v
	return s
}

type UpdateGatewayRouteResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteResponseBody) SetCode(v int32) *UpdateGatewayRouteResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetData(v int64) *UpdateGatewayRouteResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetErrorCode(v string) *UpdateGatewayRouteResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetMessage(v string) *UpdateGatewayRouteResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetRequestId(v string) *UpdateGatewayRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteResponseBody) SetSuccess(v bool) *UpdateGatewayRouteResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteResponse) SetStatusCode(v int32) *UpdateGatewayRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteResponse) SetBody(v *UpdateGatewayRouteResponseBody) *UpdateGatewayRouteResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteCORSRequest struct {
	// The language of the response. In compliance with [RFC 7231](https://tools.ietf.org/html/rfc7231), the backend service must return a response based on the language used by the user.
	//
	// *   No default value
	// *   zh-CN: Chinese
	// *   en-US: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The information about the CORS policy.
	CorsJSON *UpdateGatewayRouteCORSRequestCorsJSON `json:"CorsJSON,omitempty" xml:"CorsJSON,omitempty" type:"Struct"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteCORSRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteCORSRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetCorsJSON(v *UpdateGatewayRouteCORSRequestCorsJSON) *UpdateGatewayRouteCORSRequest {
	s.CorsJSON = v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetGatewayId(v int64) *UpdateGatewayRouteCORSRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteCORSRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequest) SetId(v int64) *UpdateGatewayRouteCORSRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteCORSRequestCorsJSON struct {
	// The credentials allowed.
	AllowCredentials *bool `json:"AllowCredentials,omitempty" xml:"AllowCredentials,omitempty"`
	// The request headers allowed.
	AllowHeaders *string `json:"AllowHeaders,omitempty" xml:"AllowHeaders,omitempty"`
	// The HTTP methods allowed.
	AllowMethods *string `json:"AllowMethods,omitempty" xml:"AllowMethods,omitempty"`
	// The origins from which access is allowed.
	AllowOrigins *string `json:"AllowOrigins,omitempty" xml:"AllowOrigins,omitempty"`
	// The response headers allowed.
	ExposeHeaders *string `json:"ExposeHeaders,omitempty" xml:"ExposeHeaders,omitempty"`
	// The status of the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The unit of time.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The value of time.
	UnitNum *int64 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteCORSRequestCorsJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSRequestCorsJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowCredentials(v bool) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowCredentials = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowHeaders(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowHeaders = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowMethods(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowMethods = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetAllowOrigins(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.AllowOrigins = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetExposeHeaders(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.ExposeHeaders = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetStatus(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetTimeUnit(v string) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteCORSRequestCorsJSON) SetUnitNum(v int64) *UpdateGatewayRouteCORSRequestCorsJSON {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteCORSShrinkRequest struct {
	// The language of the response. In compliance with [RFC 7231](https://tools.ietf.org/html/rfc7231), the backend service must return a response based on the language used by the user.
	//
	// *   No default value
	// *   zh-CN: Chinese
	// *   en-US: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The information about the CORS policy.
	CorsJSONShrink *string `json:"CorsJSON,omitempty" xml:"CorsJSON,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteCORSShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteCORSShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetCorsJSONShrink(v string) *UpdateGatewayRouteCORSShrinkRequest {
	s.CorsJSONShrink = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteCORSShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteCORSShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteCORSShrinkRequest) SetId(v int64) *UpdateGatewayRouteCORSShrinkRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteCORSResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteCORSResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSResponseBody) SetCode(v int32) *UpdateGatewayRouteCORSResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetData(v int64) *UpdateGatewayRouteCORSResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteCORSResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetMessage(v string) *UpdateGatewayRouteCORSResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetRequestId(v string) *UpdateGatewayRouteCORSResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponseBody) SetSuccess(v bool) *UpdateGatewayRouteCORSResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteCORSResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteCORSResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteCORSResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteCORSResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteCORSResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteCORSResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteCORSResponse) SetStatusCode(v int32) *UpdateGatewayRouteCORSResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteCORSResponse) SetBody(v *UpdateGatewayRouteCORSResponseBody) *UpdateGatewayRouteCORSResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteHTTPRewriteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The information about the rewrite policy. The JSON format is supported.
	HttpRewriteJSON *string `json:"HttpRewriteJSON,omitempty" xml:"HttpRewriteJSON,omitempty"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteHTTPRewriteRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHTTPRewriteRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteHTTPRewriteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetGatewayId(v int64) *UpdateGatewayRouteHTTPRewriteRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteHTTPRewriteRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetHttpRewriteJSON(v string) *UpdateGatewayRouteHTTPRewriteRequest {
	s.HttpRewriteJSON = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteRequest) SetId(v int64) *UpdateGatewayRouteHTTPRewriteRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteHTTPRewriteResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteHTTPRewriteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHTTPRewriteResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetCode(v int32) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetData(v int64) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetMessage(v string) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetRequestId(v string) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponseBody) SetSuccess(v bool) *UpdateGatewayRouteHTTPRewriteResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteHTTPRewriteResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteHTTPRewriteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteHTTPRewriteResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHTTPRewriteResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHTTPRewriteResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteHTTPRewriteResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponse) SetStatusCode(v int32) *UpdateGatewayRouteHTTPRewriteResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHTTPRewriteResponse) SetBody(v *UpdateGatewayRouteHTTPRewriteResponseBody) *UpdateGatewayRouteHTTPRewriteResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteHeaderOpRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The information about the header configuration policy.
	HeaderOpJSON *string `json:"HeaderOpJSON,omitempty" xml:"HeaderOpJSON,omitempty"`
	// The ID of the record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateGatewayRouteHeaderOpRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHeaderOpRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteHeaderOpRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetGatewayId(v int64) *UpdateGatewayRouteHeaderOpRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteHeaderOpRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetHeaderOpJSON(v string) *UpdateGatewayRouteHeaderOpRequest {
	s.HeaderOpJSON = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpRequest) SetId(v int64) *UpdateGatewayRouteHeaderOpRequest {
	s.Id = &v
	return s
}

type UpdateGatewayRouteHeaderOpResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteHeaderOpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHeaderOpResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetCode(v int32) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetData(v int64) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteHeaderOpResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetMessage(v string) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetRequestId(v string) *UpdateGatewayRouteHeaderOpResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponseBody) SetSuccess(v bool) *UpdateGatewayRouteHeaderOpResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteHeaderOpResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteHeaderOpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteHeaderOpResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteHeaderOpResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteHeaderOpResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteHeaderOpResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponse) SetStatusCode(v int32) *UpdateGatewayRouteHeaderOpResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteHeaderOpResponse) SetBody(v *UpdateGatewayRouteHeaderOpResponseBody) *UpdateGatewayRouteHeaderOpResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteRetryRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The information about the retry policy.
	RetryJSON *UpdateGatewayRouteRetryRequestRetryJSON `json:"RetryJSON,omitempty" xml:"RetryJSON,omitempty" type:"Struct"`
}

func (s UpdateGatewayRouteRetryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteRetryRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetGatewayId(v int64) *UpdateGatewayRouteRetryRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteRetryRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetId(v int64) *UpdateGatewayRouteRetryRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequest) SetRetryJSON(v *UpdateGatewayRouteRetryRequestRetryJSON) *UpdateGatewayRouteRetryRequest {
	s.RetryJSON = v
	return s
}

type UpdateGatewayRouteRetryRequestRetryJSON struct {
	// The number of retries.
	Attempts *int32 `json:"Attempts,omitempty" xml:"Attempts,omitempty"`
	// The HTTP status codes.
	HttpCodes []*string `json:"HttpCodes,omitempty" xml:"HttpCodes,omitempty" type:"Repeated"`
	// The retry conditions.
	RetryOn []*string `json:"RetryOn,omitempty" xml:"RetryOn,omitempty" type:"Repeated"`
	// The status of the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateGatewayRouteRetryRequestRetryJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryRequestRetryJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetAttempts(v int32) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.Attempts = &v
	return s
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetHttpCodes(v []*string) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.HttpCodes = v
	return s
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetRetryOn(v []*string) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.RetryOn = v
	return s
}

func (s *UpdateGatewayRouteRetryRequestRetryJSON) SetStatus(v string) *UpdateGatewayRouteRetryRequestRetryJSON {
	s.Status = &v
	return s
}

type UpdateGatewayRouteRetryShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The information about the retry policy.
	RetryJSONShrink *string `json:"RetryJSON,omitempty" xml:"RetryJSON,omitempty"`
}

func (s UpdateGatewayRouteRetryShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteRetryShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteRetryShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteRetryShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetId(v int64) *UpdateGatewayRouteRetryShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteRetryShrinkRequest) SetRetryJSONShrink(v string) *UpdateGatewayRouteRetryShrinkRequest {
	s.RetryJSONShrink = &v
	return s
}

type UpdateGatewayRouteRetryResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteRetryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryResponseBody) SetCode(v int32) *UpdateGatewayRouteRetryResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetData(v int64) *UpdateGatewayRouteRetryResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteRetryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetMessage(v string) *UpdateGatewayRouteRetryResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetRequestId(v string) *UpdateGatewayRouteRetryResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponseBody) SetSuccess(v bool) *UpdateGatewayRouteRetryResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteRetryResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteRetryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteRetryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteRetryResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteRetryResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteRetryResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteRetryResponse) SetStatusCode(v int32) *UpdateGatewayRouteRetryResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteRetryResponse) SetBody(v *UpdateGatewayRouteRetryResponseBody) *UpdateGatewayRouteRetryResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteTimeoutRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period.
	TimeoutJSON *UpdateGatewayRouteTimeoutRequestTimeoutJSON `json:"TimeoutJSON,omitempty" xml:"TimeoutJSON,omitempty" type:"Struct"`
}

func (s UpdateGatewayRouteTimeoutRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteTimeoutRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetGatewayId(v int64) *UpdateGatewayRouteTimeoutRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteTimeoutRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetId(v int64) *UpdateGatewayRouteTimeoutRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequest) SetTimeoutJSON(v *UpdateGatewayRouteTimeoutRequestTimeoutJSON) *UpdateGatewayRouteTimeoutRequest {
	s.TimeoutJSON = v
	return s
}

type UpdateGatewayRouteTimeoutRequestTimeoutJSON struct {
	// The status of the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The unit of time. A value of s indicates seconds.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The value of the timeout period.
	UnitNum *int32 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteTimeoutRequestTimeoutJSON) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutRequestTimeoutJSON) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutRequestTimeoutJSON) SetStatus(v string) *UpdateGatewayRouteTimeoutRequestTimeoutJSON {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequestTimeoutJSON) SetTimeUnit(v string) *UpdateGatewayRouteTimeoutRequestTimeoutJSON {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutRequestTimeoutJSON) SetUnitNum(v int32) *UpdateGatewayRouteTimeoutRequestTimeoutJSON {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteTimeoutShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the associated record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period.
	TimeoutJSONShrink *string `json:"TimeoutJSON,omitempty" xml:"TimeoutJSON,omitempty"`
}

func (s UpdateGatewayRouteTimeoutShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetGatewayId(v int64) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetId(v int64) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutShrinkRequest) SetTimeoutJSONShrink(v string) *UpdateGatewayRouteTimeoutShrinkRequest {
	s.TimeoutJSONShrink = &v
	return s
}

type UpdateGatewayRouteTimeoutResponseBody struct {
	// The return value.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. true: The request was successful. false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteTimeoutResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetCode(v int32) *UpdateGatewayRouteTimeoutResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetData(v int64) *UpdateGatewayRouteTimeoutResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteTimeoutResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetMessage(v string) *UpdateGatewayRouteTimeoutResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetRequestId(v string) *UpdateGatewayRouteTimeoutResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponseBody) SetSuccess(v bool) *UpdateGatewayRouteTimeoutResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteTimeoutResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteTimeoutResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteTimeoutResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteTimeoutResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteTimeoutResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteTimeoutResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponse) SetStatusCode(v int32) *UpdateGatewayRouteTimeoutResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteTimeoutResponse) SetBody(v *UpdateGatewayRouteTimeoutResponseBody) *UpdateGatewayRouteTimeoutResponse {
	s.Body = v
	return s
}

type UpdateGatewayRouteWafStatusRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// Specifies whether to activate Web Application Firewall (WAF).
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the route.
	RouteId *int64 `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s UpdateGatewayRouteWafStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusRequest) SetAcceptLanguage(v string) *UpdateGatewayRouteWafStatusRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusRequest) SetEnableWaf(v bool) *UpdateGatewayRouteWafStatusRequest {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusRequest) SetGatewayUniqueId(v string) *UpdateGatewayRouteWafStatusRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusRequest) SetRouteId(v int64) *UpdateGatewayRouteWafStatusRequest {
	s.RouteId = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBody struct {
	// The status code returned. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *UpdateGatewayRouteWafStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetCode(v int32) *UpdateGatewayRouteWafStatusResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetData(v *UpdateGatewayRouteWafStatusResponseBodyData) *UpdateGatewayRouteWafStatusResponseBody {
	s.Data = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayRouteWafStatusResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetMessage(v string) *UpdateGatewayRouteWafStatusResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetRequestId(v string) *UpdateGatewayRouteWafStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBody) SetSuccess(v bool) *UpdateGatewayRouteWafStatusResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyData struct {
	// The configuration for cross-origin resource sharing (CORS).
	Cors *UpdateGatewayRouteWafStatusResponseBodyDataCors `json:"Cors,omitempty" xml:"Cors,omitempty" type:"Struct"`
	// The default service ID.
	DefaultServiceId *int64 `json:"DefaultServiceId,omitempty" xml:"DefaultServiceId,omitempty"`
	// The default service name.
	DefaultServiceName *string `json:"DefaultServiceName,omitempty" xml:"DefaultServiceName,omitempty"`
	// The destination service type.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The information about service mocking.
	DirectResponse *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse `json:"DirectResponse,omitempty" xml:"DirectResponse,omitempty" type:"Struct"`
	// The domain ID.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The IDs of domains.
	DomainIdList []*int64 `json:"DomainIdList,omitempty" xml:"DomainIdList,omitempty" type:"Repeated"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The names of domains.
	DomainNameList []*string `json:"DomainNameList,omitempty" xml:"DomainNameList,omitempty" type:"Repeated"`
	// Indicates whether WAF is activated.
	EnableWaf *bool `json:"EnableWaf,omitempty" xml:"EnableWaf,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The information about the rewrite policy.
	HTTPRewrite *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite `json:"HTTPRewrite,omitempty" xml:"HTTPRewrite,omitempty" type:"Struct"`
	// The header settings.
	HeaderOp *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp `json:"HeaderOp,omitempty" xml:"HeaderOp,omitempty" type:"Struct"`
	// The ID of the route.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The matching rule.
	Predicates *string `json:"Predicates,omitempty" xml:"Predicates,omitempty"`
	// The configuration of the redirection.
	Redirect *UpdateGatewayRouteWafStatusResponseBodyDataRedirect `json:"Redirect,omitempty" xml:"Redirect,omitempty" type:"Struct"`
	// The retry configuration.
	Retry *UpdateGatewayRouteWafStatusResponseBodyDataRetry `json:"Retry,omitempty" xml:"Retry,omitempty" type:"Struct"`
	// The sequence number of the route.
	RouteOrder *int32 `json:"RouteOrder,omitempty" xml:"RouteOrder,omitempty"`
	// The information about route matching.
	RoutePredicates *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates `json:"RoutePredicates,omitempty" xml:"RoutePredicates,omitempty" type:"Struct"`
	// The information about services.
	RouteServices []*UpdateGatewayRouteWafStatusResponseBodyDataRouteServices `json:"RouteServices,omitempty" xml:"RouteServices,omitempty" type:"Repeated"`
	// The information about services.
	Services *string `json:"Services,omitempty" xml:"Services,omitempty"`
	// The status of the route.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The timeout configuration.
	Timeout *UpdateGatewayRouteWafStatusResponseBodyDataTimeout `json:"Timeout,omitempty" xml:"Timeout,omitempty" type:"Struct"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetCors(v *UpdateGatewayRouteWafStatusResponseBodyDataCors) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Cors = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDefaultServiceId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DefaultServiceId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDefaultServiceName(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DefaultServiceName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDestinationType(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DestinationType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDirectResponse(v *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DirectResponse = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainIdList(v []*int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainIdList = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainName(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetDomainNameList(v []*string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.DomainNameList = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetEnableWaf(v bool) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.EnableWaf = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGatewayId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGatewayUniqueId(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGmtCreate(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetGmtModified(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetHTTPRewrite(v *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.HTTPRewrite = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetHeaderOp(v *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.HeaderOp = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetId(v int64) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetName(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetPredicates(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Predicates = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRedirect(v *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Redirect = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRetry(v *UpdateGatewayRouteWafStatusResponseBodyDataRetry) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Retry = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRouteOrder(v int32) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.RouteOrder = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRoutePredicates(v *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.RoutePredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetRouteServices(v []*UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.RouteServices = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetServices(v string) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Services = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetStatus(v int32) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyData) SetTimeout(v *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) *UpdateGatewayRouteWafStatusResponseBodyData {
	s.Timeout = v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataCors struct {
	// The credentials allowed.
	AllowCredentials *bool `json:"AllowCredentials,omitempty" xml:"AllowCredentials,omitempty"`
	// The headers allowed.
	AllowHeaders *string `json:"AllowHeaders,omitempty" xml:"AllowHeaders,omitempty"`
	// The methods allowed.
	AllowMethods *string `json:"AllowMethods,omitempty" xml:"AllowMethods,omitempty"`
	// The origins allowed.
	AllowOrigins *string `json:"AllowOrigins,omitempty" xml:"AllowOrigins,omitempty"`
	// The response headers.
	ExposeHeaders *string `json:"ExposeHeaders,omitempty" xml:"ExposeHeaders,omitempty"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int64 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataCors) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataCors) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowCredentials(v bool) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowCredentials = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowHeaders(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowHeaders = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowMethods(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowMethods = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetAllowOrigins(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.AllowOrigins = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetExposeHeaders(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.ExposeHeaders = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetTimeUnit(v string) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataCors) SetUnitNum(v int64) *UpdateGatewayRouteWafStatusResponseBodyDataCors {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse struct {
	// The mock return value.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) SetBody(v string) *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse {
	s.Body = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse) SetCode(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataDirectResponse {
	s.Code = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite struct {
	// The domain name.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The HTTP request path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The path type of the HTTP request.
	PathType *string `json:"PathType,omitempty" xml:"PathType,omitempty"`
	// The matching pattern.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
	// The HTTP status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The replacement.
	Substitution *string `json:"Substitution,omitempty" xml:"Substitution,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetHost(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Host = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetPath(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Path = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetPathType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.PathType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetPattern(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Pattern = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite) SetSubstitution(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHTTPRewrite {
	s.Substitution = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp struct {
	// The policy.
	HeaderOpItems []*UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems `json:"HeaderOpItems,omitempty" xml:"HeaderOpItems,omitempty" type:"Repeated"`
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) SetHeaderOpItems(v []*UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp {
	s.HeaderOpItems = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOp {
	s.Status = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems struct {
	// The request or response.
	DirectionType *string `json:"DirectionType,omitempty" xml:"DirectionType,omitempty"`
	// The header key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The operation type.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The header value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetDirectionType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.DirectionType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetKey(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetOpType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.OpType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems) SetValue(v string) *UpdateGatewayRouteWafStatusResponseBodyDataHeaderOpHeaderOpItems {
	s.Value = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRedirect struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The hostname.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRedirect) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRedirect) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) SetCode(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataRedirect {
	s.Code = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) SetHost(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRedirect {
	s.Host = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRedirect) SetPath(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRedirect {
	s.Path = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRetry struct {
	// The number of retries allowed for a request.
	Attempts *int32 `json:"Attempts,omitempty" xml:"Attempts,omitempty"`
	// The HTTP status codes.
	HttpCodes []*string `json:"HttpCodes,omitempty" xml:"HttpCodes,omitempty" type:"Repeated"`
	// The retry condition.
	RetryOn []*string `json:"RetryOn,omitempty" xml:"RetryOn,omitempty" type:"Repeated"`
	// The retry status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRetry) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRetry) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetAttempts(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.Attempts = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetHttpCodes(v []*string) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.HttpCodes = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetRetryOn(v []*string) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.RetryOn = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRetry) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRetry {
	s.Status = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates struct {
	// The information about matching based on request headers.
	HeaderPredicates []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates `json:"HeaderPredicates,omitempty" xml:"HeaderPredicates,omitempty" type:"Repeated"`
	// The information about method matching.
	MethodPredicates []*string `json:"MethodPredicates,omitempty" xml:"MethodPredicates,omitempty" type:"Repeated"`
	// The information about route matching.
	PathPredicates *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates `json:"PathPredicates,omitempty" xml:"PathPredicates,omitempty" type:"Struct"`
	// The information about parameter matching.
	QueryPredicates []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates `json:"QueryPredicates,omitempty" xml:"QueryPredicates,omitempty" type:"Repeated"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetHeaderPredicates(v []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.HeaderPredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetMethodPredicates(v []*string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.MethodPredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetPathPredicates(v *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.PathPredicates = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates) SetQueryPredicates(v []*UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicates {
	s.QueryPredicates = v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates struct {
	// The key of the request header.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the request header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) SetKey(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) SetType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates) SetValue(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesHeaderPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates struct {
	// Indicates whether case sensitivity is ignored.
	IgnoreCase *bool `json:"IgnoreCase,omitempty" xml:"IgnoreCase,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The matching type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) SetIgnoreCase(v bool) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates {
	s.IgnoreCase = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) SetPath(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates {
	s.Path = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates) SetType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesPathPredicates {
	s.Type = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates struct {
	// The name of the parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) SetKey(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates {
	s.Key = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) SetType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates {
	s.Type = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates) SetValue(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRoutePredicatesQueryPredicates {
	s.Value = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataRouteServices struct {
	// The name of the group to which the service belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The weight.
	Percent *int32 `json:"Percent,omitempty" xml:"Percent,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The source type.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version of the service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetGroupName(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.GroupName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetName(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Name = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetNamespace(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Namespace = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetPercent(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Percent = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetServiceId(v int64) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetServiceName(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.ServiceName = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetSourceType(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.SourceType = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices) SetVersion(v string) *UpdateGatewayRouteWafStatusResponseBodyDataRouteServices {
	s.Version = &v
	return s
}

type UpdateGatewayRouteWafStatusResponseBodyDataTimeout struct {
	// The status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time unit.
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
	// The unit number.
	UnitNum *int32 `json:"UnitNum,omitempty" xml:"UnitNum,omitempty"`
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataTimeout) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponseBodyDataTimeout) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) SetStatus(v string) *UpdateGatewayRouteWafStatusResponseBodyDataTimeout {
	s.Status = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) SetTimeUnit(v string) *UpdateGatewayRouteWafStatusResponseBodyDataTimeout {
	s.TimeUnit = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponseBodyDataTimeout) SetUnitNum(v int32) *UpdateGatewayRouteWafStatusResponseBodyDataTimeout {
	s.UnitNum = &v
	return s
}

type UpdateGatewayRouteWafStatusResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayRouteWafStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayRouteWafStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayRouteWafStatusResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayRouteWafStatusResponse) SetHeaders(v map[string]*string) *UpdateGatewayRouteWafStatusResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponse) SetStatusCode(v int32) *UpdateGatewayRouteWafStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayRouteWafStatusResponse) SetBody(v *UpdateGatewayRouteWafStatusResponseBody) *UpdateGatewayRouteWafStatusResponse {
	s.Body = v
	return s
}

type UpdateGatewayServiceTrafficPolicyRequest struct {
	// The language of the response. Valid values:
	//
	// *   **zh-CN**: Chinese. This is the default value.
	// *   **en-US**: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic policy of the service.
	GatewayTrafficPolicy *TrafficPolicy `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s UpdateGatewayServiceTrafficPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceTrafficPolicyRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetGatewayId(v int64) *UpdateGatewayServiceTrafficPolicyRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetGatewayTrafficPolicy(v *TrafficPolicy) *UpdateGatewayServiceTrafficPolicyRequest {
	s.GatewayTrafficPolicy = v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceTrafficPolicyRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyRequest) SetServiceId(v int64) *UpdateGatewayServiceTrafficPolicyRequest {
	s.ServiceId = &v
	return s
}

type UpdateGatewayServiceTrafficPolicyShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   **zh-CN**: Chinese. This is the default value.
	// *   **en-US**: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The traffic policy of the service.
	GatewayTrafficPolicyShrink *string `json:"GatewayTrafficPolicy,omitempty" xml:"GatewayTrafficPolicy,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
}

func (s UpdateGatewayServiceTrafficPolicyShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetGatewayId(v int64) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetGatewayTrafficPolicyShrink(v string) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.GatewayTrafficPolicyShrink = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyShrinkRequest) SetServiceId(v int64) *UpdateGatewayServiceTrafficPolicyShrinkRequest {
	s.ServiceId = &v
	return s
}

type UpdateGatewayServiceTrafficPolicyResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *GatewayService `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayServiceTrafficPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetCode(v int32) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetData(v *GatewayService) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Data = v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetMessage(v string) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetRequestId(v string) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponseBody) SetSuccess(v bool) *UpdateGatewayServiceTrafficPolicyResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayServiceTrafficPolicyResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayServiceTrafficPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayServiceTrafficPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceTrafficPolicyResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceTrafficPolicyResponse) SetHeaders(v map[string]*string) *UpdateGatewayServiceTrafficPolicyResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponse) SetStatusCode(v int32) *UpdateGatewayServiceTrafficPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayServiceTrafficPolicyResponse) SetBody(v *UpdateGatewayServiceTrafficPolicyResponseBody) *UpdateGatewayServiceTrafficPolicyResponse {
	s.Body = v
	return s
}

type UpdateGatewayServiceVersionRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service.
	ServiceId *int64 `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"ServiceVersion,omitempty" xml:"ServiceVersion,omitempty"`
}

func (s UpdateGatewayServiceVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceVersionRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceVersionRequest) SetAcceptLanguage(v string) *UpdateGatewayServiceVersionRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewayServiceVersionRequest) SetGatewayUniqueId(v string) *UpdateGatewayServiceVersionRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewayServiceVersionRequest) SetServiceId(v int64) *UpdateGatewayServiceVersionRequest {
	s.ServiceId = &v
	return s
}

func (s *UpdateGatewayServiceVersionRequest) SetServiceVersion(v string) *UpdateGatewayServiceVersionRequest {
	s.ServiceVersion = &v
	return s
}

type UpdateGatewayServiceVersionResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewayServiceVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceVersionResponseBody) SetCode(v int32) *UpdateGatewayServiceVersionResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetData(v int64) *UpdateGatewayServiceVersionResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetHttpStatusCode(v int32) *UpdateGatewayServiceVersionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetMessage(v string) *UpdateGatewayServiceVersionResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetRequestId(v string) *UpdateGatewayServiceVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponseBody) SetSuccess(v bool) *UpdateGatewayServiceVersionResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewayServiceVersionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewayServiceVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewayServiceVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewayServiceVersionResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewayServiceVersionResponse) SetHeaders(v map[string]*string) *UpdateGatewayServiceVersionResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewayServiceVersionResponse) SetStatusCode(v int32) *UpdateGatewayServiceVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewayServiceVersionResponse) SetBody(v *UpdateGatewayServiceVersionResponseBody) *UpdateGatewayServiceVersionResponse {
	s.Body = v
	return s
}

type UpdateGatewaySpecRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The number of nodes.
	Replica *int32 `json:"Replica,omitempty" xml:"Replica,omitempty"`
	// The node specifications of the gateway.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s UpdateGatewaySpecRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewaySpecRequest) GoString() string {
	return s.String()
}

func (s *UpdateGatewaySpecRequest) SetAcceptLanguage(v string) *UpdateGatewaySpecRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateGatewaySpecRequest) SetGatewayUniqueId(v string) *UpdateGatewaySpecRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateGatewaySpecRequest) SetReplica(v int32) *UpdateGatewaySpecRequest {
	s.Replica = &v
	return s
}

func (s *UpdateGatewaySpecRequest) SetSpec(v string) *UpdateGatewaySpecRequest {
	s.Spec = &v
	return s
}

type UpdateGatewaySpecResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateGatewaySpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewaySpecResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGatewaySpecResponseBody) SetCode(v int32) *UpdateGatewaySpecResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetData(v string) *UpdateGatewaySpecResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetHttpStatusCode(v int32) *UpdateGatewaySpecResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetMessage(v string) *UpdateGatewaySpecResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetRequestId(v string) *UpdateGatewaySpecResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGatewaySpecResponseBody) SetSuccess(v bool) *UpdateGatewaySpecResponseBody {
	s.Success = &v
	return s
}

type UpdateGatewaySpecResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGatewaySpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGatewaySpecResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGatewaySpecResponse) GoString() string {
	return s.String()
}

func (s *UpdateGatewaySpecResponse) SetHeaders(v map[string]*string) *UpdateGatewaySpecResponse {
	s.Headers = v
	return s
}

func (s *UpdateGatewaySpecResponse) SetStatusCode(v int32) *UpdateGatewaySpecResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGatewaySpecResponse) SetBody(v *UpdateGatewaySpecResponseBody) *UpdateGatewaySpecResponse {
	s.Body = v
	return s
}

type UpdateImageRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The destination version number.
	//
	// > You must call the GetImage operation to obtain the maximum destination version number that corresponds to MaxVersionCode.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s UpdateImageRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageRequest) GoString() string {
	return s.String()
}

func (s *UpdateImageRequest) SetAcceptLanguage(v string) *UpdateImageRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateImageRequest) SetClusterId(v string) *UpdateImageRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateImageRequest) SetVersionCode(v string) *UpdateImageRequest {
	s.VersionCode = &v
	return s
}

type UpdateImageResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateImageResponseBody) SetErrorCode(v string) *UpdateImageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateImageResponseBody) SetMessage(v string) *UpdateImageResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateImageResponseBody) SetRequestId(v string) *UpdateImageResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateImageResponseBody) SetSuccess(v bool) *UpdateImageResponseBody {
	s.Success = &v
	return s
}

type UpdateImageResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateImageResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageResponse) GoString() string {
	return s.String()
}

func (s *UpdateImageResponse) SetHeaders(v map[string]*string) *UpdateImageResponse {
	s.Headers = v
	return s
}

func (s *UpdateImageResponse) SetStatusCode(v int32) *UpdateImageResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateImageResponse) SetBody(v *UpdateImageResponseBody) *UpdateImageResponse {
	s.Body = v
	return s
}

type UpdateMessageQueueRouteRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId   *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether the canary release for messaging feature is enabled for the application. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	FilterSide *string `json:"FilterSide,omitempty" xml:"FilterSide,omitempty"`
	Namespace  *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The tag that is negligible for the untagged environment of the application.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s UpdateMessageQueueRouteRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteRequest) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteRequest) SetAcceptLanguage(v string) *UpdateMessageQueueRouteRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetAppId(v string) *UpdateMessageQueueRouteRequest {
	s.AppId = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetAppName(v string) *UpdateMessageQueueRouteRequest {
	s.AppName = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetEnable(v bool) *UpdateMessageQueueRouteRequest {
	s.Enable = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetFilterSide(v string) *UpdateMessageQueueRouteRequest {
	s.FilterSide = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetNamespace(v string) *UpdateMessageQueueRouteRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetRegion(v string) *UpdateMessageQueueRouteRequest {
	s.Region = &v
	return s
}

func (s *UpdateMessageQueueRouteRequest) SetTags(v []*string) *UpdateMessageQueueRouteRequest {
	s.Tags = v
	return s
}

type UpdateMessageQueueRouteShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the application.
	AppId   *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Specifies whether the canary release for messaging feature is enabled for the application. Valid values:
	//
	// *   `true`: enabled
	// *   `false`: disabled
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The side for message filtering when the canary release for messaging feature is enabled.
	FilterSide *string `json:"FilterSide,omitempty" xml:"FilterSide,omitempty"`
	Namespace  *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The tag that is negligible for the untagged environment of the application.
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s UpdateMessageQueueRouteShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetAcceptLanguage(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetAppId(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.AppId = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetAppName(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.AppName = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetEnable(v bool) *UpdateMessageQueueRouteShrinkRequest {
	s.Enable = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetFilterSide(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.FilterSide = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetNamespace(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetRegion(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.Region = &v
	return s
}

func (s *UpdateMessageQueueRouteShrinkRequest) SetTagsShrink(v string) *UpdateMessageQueueRouteShrinkRequest {
	s.TagsShrink = &v
	return s
}

type UpdateMessageQueueRouteResponseBody struct {
	// The status code returned. The value 200 indicates that the request was successful. Other values indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateMessageQueueRouteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteResponseBody) SetCode(v int32) *UpdateMessageQueueRouteResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetData(v string) *UpdateMessageQueueRouteResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetHttpStatusCode(v int32) *UpdateMessageQueueRouteResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetMessage(v string) *UpdateMessageQueueRouteResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetRequestId(v string) *UpdateMessageQueueRouteResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMessageQueueRouteResponseBody) SetSuccess(v bool) *UpdateMessageQueueRouteResponseBody {
	s.Success = &v
	return s
}

type UpdateMessageQueueRouteResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateMessageQueueRouteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMessageQueueRouteResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMessageQueueRouteResponse) GoString() string {
	return s.String()
}

func (s *UpdateMessageQueueRouteResponse) SetHeaders(v map[string]*string) *UpdateMessageQueueRouteResponse {
	s.Headers = v
	return s
}

func (s *UpdateMessageQueueRouteResponse) SetStatusCode(v int32) *UpdateMessageQueueRouteResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMessageQueueRouteResponse) SetBody(v *UpdateMessageQueueRouteResponseBody) *UpdateMessageQueueRouteResponse {
	s.Body = v
	return s
}

type UpdateMigrationTaskRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The type of the instance. Valid values:
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The address of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if you want to migrate applications from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
}

func (s UpdateMigrationTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskRequest) SetAcceptLanguage(v string) *UpdateMigrationTaskRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetClusterType(v string) *UpdateMigrationTaskRequest {
	s.ClusterType = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetId(v string) *UpdateMigrationTaskRequest {
	s.Id = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetOriginInstanceAddress(v string) *UpdateMigrationTaskRequest {
	s.OriginInstanceAddress = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetOriginInstanceName(v string) *UpdateMigrationTaskRequest {
	s.OriginInstanceName = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetOriginInstanceNamespace(v string) *UpdateMigrationTaskRequest {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetProjectDesc(v string) *UpdateMigrationTaskRequest {
	s.ProjectDesc = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetRequestPars(v string) *UpdateMigrationTaskRequest {
	s.RequestPars = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetTargetClusterName(v string) *UpdateMigrationTaskRequest {
	s.TargetClusterName = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetTargetClusterUrl(v string) *UpdateMigrationTaskRequest {
	s.TargetClusterUrl = &v
	return s
}

func (s *UpdateMigrationTaskRequest) SetTargetInstanceId(v string) *UpdateMigrationTaskRequest {
	s.TargetInstanceId = &v
	return s
}

type UpdateMigrationTaskResponseBody struct {
	// The data structure.
	Data *UpdateMigrationTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateMigrationTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskResponseBody) SetData(v *UpdateMigrationTaskResponseBodyData) *UpdateMigrationTaskResponseBody {
	s.Data = v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetErrorCode(v string) *UpdateMigrationTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetHttpCode(v string) *UpdateMigrationTaskResponseBody {
	s.HttpCode = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetMessage(v string) *UpdateMigrationTaskResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetRequestId(v string) *UpdateMigrationTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMigrationTaskResponseBody) SetSuccess(v bool) *UpdateMigrationTaskResponseBody {
	s.Success = &v
	return s
}

type UpdateMigrationTaskResponseBodyData struct {
	// The type of the instance.
	//
	// *   Nacos-Ans
	// *   ZooKeeper
	// *   Eureka
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The time when the migration task was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the migration task was updated.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the task.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The address of the source instance node.
	OriginInstanceAddress *string `json:"OriginInstanceAddress,omitempty" xml:"OriginInstanceAddress,omitempty"`
	// The name of the source instance.
	OriginInstanceName *string `json:"OriginInstanceName,omitempty" xml:"OriginInstanceName,omitempty"`
	// The list of namespaces. This parameter is optional if applications are migrated from a Nacos instance.
	OriginInstanceNamespace *string `json:"OriginInstanceNamespace,omitempty" xml:"OriginInstanceNamespace,omitempty"`
	// The description.
	ProjectDesc *string `json:"ProjectDesc,omitempty" xml:"ProjectDesc,omitempty"`
	// The name of the destination instance.
	TargetClusterName *string `json:"TargetClusterName,omitempty" xml:"TargetClusterName,omitempty"`
	// The URL of the destination instance.
	TargetClusterUrl *string `json:"TargetClusterUrl,omitempty" xml:"TargetClusterUrl,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s UpdateMigrationTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskResponseBodyData) SetClusterType(v string) *UpdateMigrationTaskResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetGmtCreate(v string) *UpdateMigrationTaskResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetGmtModified(v string) *UpdateMigrationTaskResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetId(v string) *UpdateMigrationTaskResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetOriginInstanceAddress(v string) *UpdateMigrationTaskResponseBodyData {
	s.OriginInstanceAddress = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetOriginInstanceName(v string) *UpdateMigrationTaskResponseBodyData {
	s.OriginInstanceName = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetOriginInstanceNamespace(v string) *UpdateMigrationTaskResponseBodyData {
	s.OriginInstanceNamespace = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetProjectDesc(v string) *UpdateMigrationTaskResponseBodyData {
	s.ProjectDesc = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetTargetClusterName(v string) *UpdateMigrationTaskResponseBodyData {
	s.TargetClusterName = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetTargetClusterUrl(v string) *UpdateMigrationTaskResponseBodyData {
	s.TargetClusterUrl = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetTargetInstanceId(v string) *UpdateMigrationTaskResponseBodyData {
	s.TargetInstanceId = &v
	return s
}

func (s *UpdateMigrationTaskResponseBodyData) SetUserId(v string) *UpdateMigrationTaskResponseBodyData {
	s.UserId = &v
	return s
}

type UpdateMigrationTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateMigrationTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMigrationTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMigrationTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateMigrationTaskResponse) SetHeaders(v map[string]*string) *UpdateMigrationTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateMigrationTaskResponse) SetStatusCode(v int32) *UpdateMigrationTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMigrationTaskResponse) SetBody(v *UpdateMigrationTaskResponseBody) *UpdateMigrationTaskResponse {
	s.Body = v
	return s
}

type UpdateNacosClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The port used for health checks.
	CheckPort *int32 `json:"CheckPort,omitempty" xml:"CheckPort,omitempty"`
	// The name of the Nacos cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the health check.
	HealthChecker *string `json:"HealthChecker,omitempty" xml:"HealthChecker,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// Specifies whether to use the port of the instance for a health check.
	UseInstancePortForCheck *bool `json:"UseInstancePortForCheck,omitempty" xml:"UseInstancePortForCheck,omitempty"`
}

func (s UpdateNacosClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosClusterRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosClusterRequest) SetAcceptLanguage(v string) *UpdateNacosClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetCheckPort(v int32) *UpdateNacosClusterRequest {
	s.CheckPort = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetClusterName(v string) *UpdateNacosClusterRequest {
	s.ClusterName = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetGroupName(v string) *UpdateNacosClusterRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetHealthChecker(v string) *UpdateNacosClusterRequest {
	s.HealthChecker = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetInstanceId(v string) *UpdateNacosClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetNamespaceId(v string) *UpdateNacosClusterRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetServiceName(v string) *UpdateNacosClusterRequest {
	s.ServiceName = &v
	return s
}

func (s *UpdateNacosClusterRequest) SetUseInstancePortForCheck(v bool) *UpdateNacosClusterRequest {
	s.UseInstancePortForCheck = &v
	return s
}

type UpdateNacosClusterResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosClusterResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosClusterResponseBody) SetCode(v int32) *UpdateNacosClusterResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetData(v string) *UpdateNacosClusterResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetHttpStatusCode(v int32) *UpdateNacosClusterResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetMessage(v string) *UpdateNacosClusterResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetRequestId(v string) *UpdateNacosClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosClusterResponseBody) SetSuccess(v bool) *UpdateNacosClusterResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosClusterResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosClusterResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosClusterResponse) SetHeaders(v map[string]*string) *UpdateNacosClusterResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosClusterResponse) SetStatusCode(v int32) *UpdateNacosClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosClusterResponse) SetBody(v *UpdateNacosClusterResponseBody) *UpdateNacosClusterResponse {
	s.Body = v
	return s
}

type UpdateNacosConfigRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The list of IP addresses where the beta release of the configuration is performed.
	BetaIps *string `json:"BetaIps,omitempty" xml:"BetaIps,omitempty"`
	// The content of the configuration.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the configuration file.
	DataId *string `json:"DataId,omitempty" xml:"DataId,omitempty"`
	// The description of the configuration.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The encryption key.
	EncryptedDataKey *string `json:"EncryptedDataKey,omitempty" xml:"EncryptedDataKey,omitempty"`
	// The name of the group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The MD5 value of the configuration.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The list of tags.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The format of the configuration. Supported formats include TEXT, JSON, XML, and HTML.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateNacosConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosConfigRequest) SetAcceptLanguage(v string) *UpdateNacosConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetAppName(v string) *UpdateNacosConfigRequest {
	s.AppName = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetBetaIps(v string) *UpdateNacosConfigRequest {
	s.BetaIps = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetContent(v string) *UpdateNacosConfigRequest {
	s.Content = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetDataId(v string) *UpdateNacosConfigRequest {
	s.DataId = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetDesc(v string) *UpdateNacosConfigRequest {
	s.Desc = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetEncryptedDataKey(v string) *UpdateNacosConfigRequest {
	s.EncryptedDataKey = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetGroup(v string) *UpdateNacosConfigRequest {
	s.Group = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetInstanceId(v string) *UpdateNacosConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetMd5(v string) *UpdateNacosConfigRequest {
	s.Md5 = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetNamespaceId(v string) *UpdateNacosConfigRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetTags(v string) *UpdateNacosConfigRequest {
	s.Tags = &v
	return s
}

func (s *UpdateNacosConfigRequest) SetType(v string) *UpdateNacosConfigRequest {
	s.Type = &v
	return s
}

type UpdateNacosConfigResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosConfigResponseBody) SetErrorCode(v string) *UpdateNacosConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetHttpCode(v string) *UpdateNacosConfigResponseBody {
	s.HttpCode = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetMessage(v string) *UpdateNacosConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetRequestId(v string) *UpdateNacosConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosConfigResponseBody) SetSuccess(v bool) *UpdateNacosConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosConfigResponse) SetHeaders(v map[string]*string) *UpdateNacosConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosConfigResponse) SetStatusCode(v int32) *UpdateNacosConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosConfigResponse) SetBody(v *UpdateNacosConfigResponseBody) *UpdateNacosConfigResponse {
	s.Body = v
	return s
}

type UpdateNacosInstanceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The name of the Nacos instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Specifies whether to disable this service. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Specifies whether the node is a non-persistent node. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Ephemeral *bool `json:"Ephemeral,omitempty" xml:"Ephemeral,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the Nacos instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The metadata of the instance.
	Metadata *string `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The port number of the Nacos instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The weight. Valid values: 0 to 10000. The value must be an integer. A larger value indicates a higher frequency at which the instance is accessed.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s UpdateNacosInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosInstanceRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosInstanceRequest) SetAcceptLanguage(v string) *UpdateNacosInstanceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetClusterName(v string) *UpdateNacosInstanceRequest {
	s.ClusterName = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetEnabled(v bool) *UpdateNacosInstanceRequest {
	s.Enabled = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetEphemeral(v bool) *UpdateNacosInstanceRequest {
	s.Ephemeral = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetGroupName(v string) *UpdateNacosInstanceRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetInstanceId(v string) *UpdateNacosInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetIp(v string) *UpdateNacosInstanceRequest {
	s.Ip = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetMetadata(v string) *UpdateNacosInstanceRequest {
	s.Metadata = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetNamespaceId(v string) *UpdateNacosInstanceRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetPort(v int32) *UpdateNacosInstanceRequest {
	s.Port = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetServiceName(v string) *UpdateNacosInstanceRequest {
	s.ServiceName = &v
	return s
}

func (s *UpdateNacosInstanceRequest) SetWeight(v string) *UpdateNacosInstanceRequest {
	s.Weight = &v
	return s
}

type UpdateNacosInstanceResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the modification.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosInstanceResponseBody) SetCode(v int32) *UpdateNacosInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetData(v string) *UpdateNacosInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetHttpStatusCode(v int32) *UpdateNacosInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetMessage(v string) *UpdateNacosInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetRequestId(v string) *UpdateNacosInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosInstanceResponseBody) SetSuccess(v bool) *UpdateNacosInstanceResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosInstanceResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosInstanceResponse) SetHeaders(v map[string]*string) *UpdateNacosInstanceResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosInstanceResponse) SetStatusCode(v int32) *UpdateNacosInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosInstanceResponse) SetBody(v *UpdateNacosInstanceResponseBody) *UpdateNacosInstanceResponse {
	s.Body = v
	return s
}

type UpdateNacosServiceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the cluster.
	//
	// > This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance.
	//
	// >  This operation contains both the InstanceId and ClusterId parameters. You must specify one of them.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The protection threshold.
	ProtectThreshold *string `json:"ProtectThreshold,omitempty" xml:"ProtectThreshold,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s UpdateNacosServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosServiceRequest) GoString() string {
	return s.String()
}

func (s *UpdateNacosServiceRequest) SetAcceptLanguage(v string) *UpdateNacosServiceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetClusterId(v string) *UpdateNacosServiceRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetGroupName(v string) *UpdateNacosServiceRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetInstanceId(v string) *UpdateNacosServiceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetNamespaceId(v string) *UpdateNacosServiceRequest {
	s.NamespaceId = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetProtectThreshold(v string) *UpdateNacosServiceRequest {
	s.ProtectThreshold = &v
	return s
}

func (s *UpdateNacosServiceRequest) SetServiceName(v string) *UpdateNacosServiceRequest {
	s.ServiceName = &v
	return s
}

type UpdateNacosServiceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNacosServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosServiceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNacosServiceResponseBody) SetCode(v int32) *UpdateNacosServiceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetData(v string) *UpdateNacosServiceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetHttpStatusCode(v int32) *UpdateNacosServiceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetMessage(v string) *UpdateNacosServiceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetRequestId(v string) *UpdateNacosServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNacosServiceResponseBody) SetSuccess(v bool) *UpdateNacosServiceResponseBody {
	s.Success = &v
	return s
}

type UpdateNacosServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateNacosServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateNacosServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNacosServiceResponse) GoString() string {
	return s.String()
}

func (s *UpdateNacosServiceResponse) SetHeaders(v map[string]*string) *UpdateNacosServiceResponse {
	s.Headers = v
	return s
}

func (s *UpdateNacosServiceResponse) SetStatusCode(v int32) *UpdateNacosServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNacosServiceResponse) SetBody(v *UpdateNacosServiceResponseBody) *UpdateNacosServiceResponse {
	s.Body = v
	return s
}

type UpdatePluginConfigRequest struct {
	// The language of the response. Valid values:
	//
	// zh: Chinese en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The plug-in configuration.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The application scope of the plug-in.
	//
	// *   0: global
	// *   1: route
	// *   2: domain name
	ConfigLevel *int32 `json:"ConfigLevel,omitempty" xml:"ConfigLevel,omitempty"`
	// Specifies whether to enable the plug-in.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The creation time.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The update time.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the plug-in configuration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the gateway plug-in.
	PluginId *int64 `json:"PluginId,omitempty" xml:"PluginId,omitempty"`
}

func (s UpdatePluginConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePluginConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdatePluginConfigRequest) SetAcceptLanguage(v string) *UpdatePluginConfigRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetConfig(v string) *UpdatePluginConfigRequest {
	s.Config = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetConfigLevel(v int32) *UpdatePluginConfigRequest {
	s.ConfigLevel = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetEnable(v bool) *UpdatePluginConfigRequest {
	s.Enable = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGatewayId(v int64) *UpdatePluginConfigRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGatewayUniqueId(v string) *UpdatePluginConfigRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGmtCreate(v string) *UpdatePluginConfigRequest {
	s.GmtCreate = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetGmtModified(v string) *UpdatePluginConfigRequest {
	s.GmtModified = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetId(v int64) *UpdatePluginConfigRequest {
	s.Id = &v
	return s
}

func (s *UpdatePluginConfigRequest) SetPluginId(v int64) *UpdatePluginConfigRequest {
	s.PluginId = &v
	return s
}

type UpdatePluginConfigResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the plug-in configuration.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The dynamic part in the error message.
	DynamicMessage *string `json:"DynamicMessage,omitempty" xml:"DynamicMessage,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdatePluginConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePluginConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePluginConfigResponseBody) SetCode(v int32) *UpdatePluginConfigResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetData(v int64) *UpdatePluginConfigResponseBody {
	s.Data = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetDynamicMessage(v string) *UpdatePluginConfigResponseBody {
	s.DynamicMessage = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetErrorCode(v string) *UpdatePluginConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetHttpStatusCode(v int32) *UpdatePluginConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetMessage(v string) *UpdatePluginConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetRequestId(v string) *UpdatePluginConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePluginConfigResponseBody) SetSuccess(v bool) *UpdatePluginConfigResponseBody {
	s.Success = &v
	return s
}

type UpdatePluginConfigResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePluginConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePluginConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePluginConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdatePluginConfigResponse) SetHeaders(v map[string]*string) *UpdatePluginConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdatePluginConfigResponse) SetStatusCode(v int32) *UpdatePluginConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePluginConfigResponse) SetBody(v *UpdatePluginConfigResponseBody) *UpdatePluginConfigResponse {
	s.Body = v
	return s
}

type UpdateSSLCertRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The ID of the domain name.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
}

func (s UpdateSSLCertRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSSLCertRequest) GoString() string {
	return s.String()
}

func (s *UpdateSSLCertRequest) SetAcceptLanguage(v string) *UpdateSSLCertRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateSSLCertRequest) SetCertIdentifier(v string) *UpdateSSLCertRequest {
	s.CertIdentifier = &v
	return s
}

func (s *UpdateSSLCertRequest) SetDomainId(v int64) *UpdateSSLCertRequest {
	s.DomainId = &v
	return s
}

func (s *UpdateSSLCertRequest) SetGatewayUniqueId(v string) *UpdateSSLCertRequest {
	s.GatewayUniqueId = &v
	return s
}

type UpdateSSLCertResponseBody struct {
	// The response code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the update is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSSLCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSSLCertResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSSLCertResponseBody) SetCode(v int32) *UpdateSSLCertResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetData(v bool) *UpdateSSLCertResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetHttpStatusCode(v int32) *UpdateSSLCertResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetMessage(v string) *UpdateSSLCertResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetRequestId(v string) *UpdateSSLCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSSLCertResponseBody) SetSuccess(v bool) *UpdateSSLCertResponseBody {
	s.Success = &v
	return s
}

type UpdateSSLCertResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSSLCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSSLCertResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSSLCertResponse) GoString() string {
	return s.String()
}

func (s *UpdateSSLCertResponse) SetHeaders(v map[string]*string) *UpdateSSLCertResponse {
	s.Headers = v
	return s
}

func (s *UpdateSSLCertResponse) SetStatusCode(v int32) *UpdateSSLCertResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSSLCertResponse) SetBody(v *UpdateSSLCertResponseBody) *UpdateSSLCertResponse {
	s.Body = v
	return s
}

type UpdateServiceSourceRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service source.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The configurations of Ingress resources.
	IngressOptionsRequest *UpdateServiceSourceRequestIngressOptionsRequest `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty" type:"Struct"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of service root paths.
	PathList []*string `json:"PathList,omitempty" xml:"PathList,omitempty" type:"Repeated"`
	// The service source. Valid values:
	//
	// *   K8S: ACK cluster
	// *   MSE: Nacos instance
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   K8S: ACK cluster
	// *   NACOS: Nacos instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateServiceSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceRequest) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceRequest) SetAcceptLanguage(v string) *UpdateServiceSourceRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetAddress(v string) *UpdateServiceSourceRequest {
	s.Address = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetGatewayId(v int64) *UpdateServiceSourceRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetGatewayUniqueId(v string) *UpdateServiceSourceRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetId(v int64) *UpdateServiceSourceRequest {
	s.Id = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetIngressOptionsRequest(v *UpdateServiceSourceRequestIngressOptionsRequest) *UpdateServiceSourceRequest {
	s.IngressOptionsRequest = v
	return s
}

func (s *UpdateServiceSourceRequest) SetName(v string) *UpdateServiceSourceRequest {
	s.Name = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetPathList(v []*string) *UpdateServiceSourceRequest {
	s.PathList = v
	return s
}

func (s *UpdateServiceSourceRequest) SetSource(v string) *UpdateServiceSourceRequest {
	s.Source = &v
	return s
}

func (s *UpdateServiceSourceRequest) SetType(v string) *UpdateServiceSourceRequest {
	s.Type = &v
	return s
}

type UpdateServiceSourceRequestIngressOptionsRequest struct {
	// Specifies whether to enable Ingress.
	EnableIngress *bool `json:"EnableIngress,omitempty" xml:"EnableIngress,omitempty"`
	// Specifies whether to update the Ingress status.
	EnableStatus *bool `json:"EnableStatus,omitempty" xml:"EnableStatus,omitempty"`
	// Specifies whether to monitor Ingress classes.
	IngressClass *string `json:"IngressClass,omitempty" xml:"IngressClass,omitempty"`
	// The namespace whose resources you want to monitor.
	WatchNamespace *string `json:"WatchNamespace,omitempty" xml:"WatchNamespace,omitempty"`
}

func (s UpdateServiceSourceRequestIngressOptionsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceRequestIngressOptionsRequest) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetEnableIngress(v bool) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.EnableIngress = &v
	return s
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetEnableStatus(v bool) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.EnableStatus = &v
	return s
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetIngressClass(v string) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.IngressClass = &v
	return s
}

func (s *UpdateServiceSourceRequestIngressOptionsRequest) SetWatchNamespace(v string) *UpdateServiceSourceRequestIngressOptionsRequest {
	s.WatchNamespace = &v
	return s
}

type UpdateServiceSourceShrinkRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The address.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the gateway.
	GatewayId *int64 `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The unique ID of the gateway.
	GatewayUniqueId *string `json:"GatewayUniqueId,omitempty" xml:"GatewayUniqueId,omitempty"`
	// The ID of the service source.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The configurations of Ingress resources.
	IngressOptionsRequestShrink *string `json:"IngressOptionsRequest,omitempty" xml:"IngressOptionsRequest,omitempty"`
	// The name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of service root paths.
	PathListShrink *string `json:"PathList,omitempty" xml:"PathList,omitempty"`
	// The service source. Valid values:
	//
	// *   K8S: ACK cluster
	// *   MSE: Nacos instance
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The type of the service source. Valid values:
	//
	// *   K8S: ACK cluster
	// *   NACOS: Nacos instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateServiceSourceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceShrinkRequest) SetAcceptLanguage(v string) *UpdateServiceSourceShrinkRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetAddress(v string) *UpdateServiceSourceShrinkRequest {
	s.Address = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetGatewayId(v int64) *UpdateServiceSourceShrinkRequest {
	s.GatewayId = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetGatewayUniqueId(v string) *UpdateServiceSourceShrinkRequest {
	s.GatewayUniqueId = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetId(v int64) *UpdateServiceSourceShrinkRequest {
	s.Id = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetIngressOptionsRequestShrink(v string) *UpdateServiceSourceShrinkRequest {
	s.IngressOptionsRequestShrink = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetName(v string) *UpdateServiceSourceShrinkRequest {
	s.Name = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetPathListShrink(v string) *UpdateServiceSourceShrinkRequest {
	s.PathListShrink = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetSource(v string) *UpdateServiceSourceShrinkRequest {
	s.Source = &v
	return s
}

func (s *UpdateServiceSourceShrinkRequest) SetType(v string) *UpdateServiceSourceShrinkRequest {
	s.Type = &v
	return s
}

type UpdateServiceSourceResponseBody struct {
	// The status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateServiceSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceResponseBody) SetCode(v int32) *UpdateServiceSourceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetData(v int64) *UpdateServiceSourceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetHttpStatusCode(v int32) *UpdateServiceSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetMessage(v string) *UpdateServiceSourceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetRequestId(v string) *UpdateServiceSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateServiceSourceResponseBody) SetSuccess(v bool) *UpdateServiceSourceResponseBody {
	s.Success = &v
	return s
}

type UpdateServiceSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateServiceSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateServiceSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceSourceResponse) GoString() string {
	return s.String()
}

func (s *UpdateServiceSourceResponse) SetHeaders(v map[string]*string) *UpdateServiceSourceResponse {
	s.Headers = v
	return s
}

func (s *UpdateServiceSourceResponse) SetStatusCode(v int32) *UpdateServiceSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateServiceSourceResponse) SetBody(v *UpdateServiceSourceResponseBody) *UpdateServiceSourceResponse {
	s.Body = v
	return s
}

type UpdateZnodeRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The path of the node.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
}

func (s UpdateZnodeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateZnodeRequest) GoString() string {
	return s.String()
}

func (s *UpdateZnodeRequest) SetAcceptLanguage(v string) *UpdateZnodeRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpdateZnodeRequest) SetClusterId(v string) *UpdateZnodeRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateZnodeRequest) SetData(v string) *UpdateZnodeRequest {
	s.Data = &v
	return s
}

func (s *UpdateZnodeRequest) SetPath(v string) *UpdateZnodeRequest {
	s.Path = &v
	return s
}

func (s *UpdateZnodeRequest) SetRequestPars(v string) *UpdateZnodeRequest {
	s.RequestPars = &v
	return s
}

type UpdateZnodeResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateZnodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateZnodeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateZnodeResponseBody) SetErrorCode(v string) *UpdateZnodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateZnodeResponseBody) SetMessage(v string) *UpdateZnodeResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateZnodeResponseBody) SetRequestId(v string) *UpdateZnodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateZnodeResponseBody) SetSuccess(v bool) *UpdateZnodeResponseBody {
	s.Success = &v
	return s
}

type UpdateZnodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateZnodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateZnodeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateZnodeResponse) GoString() string {
	return s.String()
}

func (s *UpdateZnodeResponse) SetHeaders(v map[string]*string) *UpdateZnodeResponse {
	s.Headers = v
	return s
}

func (s *UpdateZnodeResponse) SetStatusCode(v int32) *UpdateZnodeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateZnodeResponse) SetBody(v *UpdateZnodeResponseBody) *UpdateZnodeResponse {
	s.Body = v
	return s
}

type UpgradeClusterRequest struct {
	// The language of the response. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The extended request parameters in the JSON format.
	RequestPars *string `json:"RequestPars,omitempty" xml:"RequestPars,omitempty"`
	// The destination version.
	UpgradeVersion *string `json:"UpgradeVersion,omitempty" xml:"UpgradeVersion,omitempty"`
}

func (s UpgradeClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeClusterRequest) GoString() string {
	return s.String()
}

func (s *UpgradeClusterRequest) SetAcceptLanguage(v string) *UpgradeClusterRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *UpgradeClusterRequest) SetInstanceId(v string) *UpgradeClusterRequest {
	s.InstanceId = &v
	return s
}

func (s *UpgradeClusterRequest) SetRequestPars(v string) *UpgradeClusterRequest {
	s.RequestPars = &v
	return s
}

func (s *UpgradeClusterRequest) SetUpgradeVersion(v string) *UpgradeClusterRequest {
	s.UpgradeVersion = &v
	return s
}

type UpgradeClusterResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The response code returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The message returned.
	//
	// *   If the request is successful, a success message is returned.
	// *   If the request fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpgradeClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeClusterResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeClusterResponseBody) SetErrorCode(v string) *UpgradeClusterResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetHttpCode(v string) *UpgradeClusterResponseBody {
	s.HttpCode = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetMessage(v string) *UpgradeClusterResponseBody {
	s.Message = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetRequestId(v string) *UpgradeClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeClusterResponseBody) SetSuccess(v bool) *UpgradeClusterResponseBody {
	s.Success = &v
	return s
}

type UpgradeClusterResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeClusterResponse) GoString() string {
	return s.String()
}

func (s *UpgradeClusterResponse) SetHeaders(v map[string]*string) *UpgradeClusterResponse {
	s.Headers = v
	return s
}

func (s *UpgradeClusterResponse) SetStatusCode(v int32) *UpgradeClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeClusterResponse) SetBody(v *UpgradeClusterResponseBody) *UpgradeClusterResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.SignatureAlgorithm = tea.String("v2")
	client.EndpointRule = tea.String("regional")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("mse"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddAuthResourceWithOptions(tmpReq *AddAuthResourceRequest, runtime *util.RuntimeOptions) (_result *AddAuthResourceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddAuthResourceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AuthResourceHeaderList)) {
		request.AuthResourceHeaderListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AuthResourceHeaderList, tea.String("AuthResourceHeaderList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AuthId)) {
		query["AuthId"] = request.AuthId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthResourceHeaderListShrink)) {
		query["AuthResourceHeaderList"] = request.AuthResourceHeaderListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreCase)) {
		query["IgnoreCase"] = request.IgnoreCase
	}

	if !tea.BoolValue(util.IsUnset(request.MatchType)) {
		query["MatchType"] = request.MatchType
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAuthResource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAuthResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddAuthResource(request *AddAuthResourceRequest) (_result *AddAuthResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAuthResourceResponse{}
	_body, _err := client.AddAuthResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddBlackWhiteListWithOptions(request *AddBlackWhiteListRequest, runtime *util.RuntimeOptions) (_result *AddBlackWhiteListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IsWhite)) {
		query["IsWhite"] = request.IsWhite
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Note)) {
		query["Note"] = request.Note
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIdJsonList)) {
		query["ResourceIdJsonList"] = request.ResourceIdJsonList
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddBlackWhiteList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddBlackWhiteListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddBlackWhiteList(request *AddBlackWhiteListRequest) (_result *AddBlackWhiteListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddBlackWhiteListResponse{}
	_body, _err := client.AddBlackWhiteListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayWithOptions(request *AddGatewayRequest, runtime *util.RuntimeOptions) (_result *AddGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.EnableHardwareAcceleration)) {
		query["EnableHardwareAcceleration"] = request.EnableHardwareAcceleration
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSls)) {
		query["EnableSls"] = request.EnableSls
	}

	if !tea.BoolValue(util.IsUnset(request.EnableXtrace)) {
		query["EnableXtrace"] = request.EnableXtrace
	}

	if !tea.BoolValue(util.IsUnset(request.EnterpriseSecurityGroup)) {
		query["EnterpriseSecurityGroup"] = request.EnterpriseSecurityGroup
	}

	if !tea.BoolValue(util.IsUnset(request.InternetSlbSpec)) {
		query["InternetSlbSpec"] = request.InternetSlbSpec
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Replica)) {
		query["Replica"] = request.Replica
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SlbSpec)) {
		query["SlbSpec"] = request.SlbSpec
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId2)) {
		query["VSwitchId2"] = request.VSwitchId2
	}

	if !tea.BoolValue(util.IsUnset(request.Vpc)) {
		query["Vpc"] = request.Vpc
	}

	if !tea.BoolValue(util.IsUnset(request.XtraceRatio)) {
		query["XtraceRatio"] = request.XtraceRatio
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGateway(request *AddGatewayRequest) (_result *AddGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayResponse{}
	_body, _err := client.AddGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayDomainWithOptions(request *AddGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *AddGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Http2)) {
		query["Http2"] = request.Http2
	}

	if !tea.BoolValue(util.IsUnset(request.MustHttps)) {
		query["MustHttps"] = request.MustHttps
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMax)) {
		query["TlsMax"] = request.TlsMax
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMin)) {
		query["TlsMin"] = request.TlsMin
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewayDomain(request *AddGatewayDomainRequest) (_result *AddGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayDomainResponse{}
	_body, _err := client.AddGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayRouteWithOptions(tmpReq *AddGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *AddGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddGatewayRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DirectResponseJSON)) {
		request.DirectResponseJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DirectResponseJSON, tea.String("DirectResponseJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FallbackServices)) {
		request.FallbackServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FallbackServices, tea.String("FallbackServices"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Predicates)) {
		request.PredicatesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Predicates, tea.String("Predicates"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RedirectJSON)) {
		request.RedirectJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RedirectJSON, tea.String("RedirectJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Services)) {
		request.ServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Services, tea.String("Services"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationType)) {
		query["DestinationType"] = request.DestinationType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectResponseJSONShrink)) {
		query["DirectResponseJSON"] = request.DirectResponseJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainIdListJSON)) {
		query["DomainIdListJSON"] = request.DomainIdListJSON
	}

	if !tea.BoolValue(util.IsUnset(request.EnableWaf)) {
		query["EnableWaf"] = request.EnableWaf
	}

	if !tea.BoolValue(util.IsUnset(request.Fallback)) {
		query["Fallback"] = request.Fallback
	}

	if !tea.BoolValue(util.IsUnset(request.FallbackServicesShrink)) {
		query["FallbackServices"] = request.FallbackServicesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PredicatesShrink)) {
		query["Predicates"] = request.PredicatesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RedirectJSONShrink)) {
		query["RedirectJSON"] = request.RedirectJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RouteOrder)) {
		query["RouteOrder"] = request.RouteOrder
	}

	if !tea.BoolValue(util.IsUnset(request.ServicesShrink)) {
		query["Services"] = request.ServicesShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewayRoute(request *AddGatewayRouteRequest) (_result *AddGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayRouteResponse{}
	_body, _err := client.AddGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewayServiceVersionWithOptions(request *AddGatewayServiceVersionRequest, runtime *util.RuntimeOptions) (_result *AddGatewayServiceVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["ServiceVersion"] = request.ServiceVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewayServiceVersion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewayServiceVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewayServiceVersion(request *AddGatewayServiceVersionRequest) (_result *AddGatewayServiceVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewayServiceVersionResponse{}
	_body, _err := client.AddGatewayServiceVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGatewaySlbWithOptions(request *AddGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *AddGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.HttpPort)) {
		query["HttpPort"] = request.HttpPort
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsPort)) {
		query["HttpsPort"] = request.HttpsPort
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsVServerGroupId)) {
		query["HttpsVServerGroupId"] = request.HttpsVServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceWeight)) {
		query["ServiceWeight"] = request.ServiceWeight
	}

	if !tea.BoolValue(util.IsUnset(request.SlbId)) {
		query["SlbId"] = request.SlbId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGatewaySlb(request *AddGatewaySlbRequest) (_result *AddGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGatewaySlbResponse{}
	_body, _err := client.AddGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddMigrationTaskWithOptions(request *AddMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *AddMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceAddress)) {
		query["OriginInstanceAddress"] = request.OriginInstanceAddress
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceName)) {
		query["OriginInstanceName"] = request.OriginInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceNamespace)) {
		query["OriginInstanceNamespace"] = request.OriginInstanceNamespace
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectDesc)) {
		query["ProjectDesc"] = request.ProjectDesc
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterName)) {
		query["TargetClusterName"] = request.TargetClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterUrl)) {
		query["TargetClusterUrl"] = request.TargetClusterUrl
	}

	if !tea.BoolValue(util.IsUnset(request.TargetInstanceId)) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddMigrationTask(request *AddMigrationTaskRequest) (_result *AddMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddMigrationTaskResponse{}
	_body, _err := client.AddMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddMockRuleWithOptions(request *AddMockRuleRequest, runtime *util.RuntimeOptions) (_result *AddMockRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConsumerAppIds)) {
		query["ConsumerAppIds"] = request.ConsumerAppIds
	}

	if !tea.BoolValue(util.IsUnset(request.DubboMockItems)) {
		query["DubboMockItems"] = request.DubboMockItems
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.ExtraJson)) {
		query["ExtraJson"] = request.ExtraJson
	}

	if !tea.BoolValue(util.IsUnset(request.MockType)) {
		query["MockType"] = request.MockType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProviderAppId)) {
		query["ProviderAppId"] = request.ProviderAppId
	}

	if !tea.BoolValue(util.IsUnset(request.ProviderAppName)) {
		query["ProviderAppName"] = request.ProviderAppName
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ScMockItems)) {
		query["ScMockItems"] = request.ScMockItems
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddMockRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddMockRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddMockRule(request *AddMockRuleRequest) (_result *AddMockRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddMockRuleResponse{}
	_body, _err := client.AddMockRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddSSLCertWithOptions(request *AddSSLCertRequest, runtime *util.RuntimeOptions) (_result *AddSSLCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddSSLCert"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddSSLCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddSSLCert(request *AddSSLCertRequest) (_result *AddSSLCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddSSLCertResponse{}
	_body, _err := client.AddSSLCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddSecurityGroupRuleWithOptions(request *AddSecurityGroupRuleRequest, runtime *util.RuntimeOptions) (_result *AddSecurityGroupRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.PortRange)) {
		query["PortRange"] = request.PortRange
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddSecurityGroupRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddSecurityGroupRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddSecurityGroupRule(request *AddSecurityGroupRuleRequest) (_result *AddSecurityGroupRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddSecurityGroupRuleResponse{}
	_body, _err := client.AddSecurityGroupRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddServiceSourceWithOptions(tmpReq *AddServiceSourceRequest, runtime *util.RuntimeOptions) (_result *AddServiceSourceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddServiceSourceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GroupList)) {
		request.GroupListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GroupList, tea.String("GroupList"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.IngressOptionsRequest)) {
		request.IngressOptionsRequestShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.IngressOptionsRequest, tea.String("IngressOptionsRequest"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.PathList)) {
		request.PathListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.PathList, tea.String("PathList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupListShrink)) {
		query["GroupList"] = request.GroupListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.IngressOptionsRequestShrink)) {
		query["IngressOptionsRequest"] = request.IngressOptionsRequestShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PathListShrink)) {
		query["PathList"] = request.PathListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddServiceSource(request *AddServiceSourceRequest) (_result *AddServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddServiceSourceResponse{}
	_body, _err := client.AddServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyGatewayRouteWithOptions(request *ApplyGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *ApplyGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyGatewayRoute(request *ApplyGatewayRouteRequest) (_result *ApplyGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyGatewayRouteResponse{}
	_body, _err := client.ApplyGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyTagPoliciesWithOptions(request *ApplyTagPoliciesRequest, runtime *util.RuntimeOptions) (_result *ApplyTagPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Rules)) {
		query["Rules"] = request.Rules
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyTagPolicies"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyTagPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyTagPolicies(request *ApplyTagPoliciesRequest) (_result *ApplyTagPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyTagPoliciesResponse{}
	_body, _err := client.ApplyTagPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CloneNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloneNacosConfigResponse
 */
func (client *Client) CloneNacosConfigWithOptions(request *CloneNacosConfigRequest, runtime *util.RuntimeOptions) (_result *CloneNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OriginNamespaceId)) {
		query["OriginNamespaceId"] = request.OriginNamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Policy)) {
		query["Policy"] = request.Policy
	}

	if !tea.BoolValue(util.IsUnset(request.TargetNamespaceId)) {
		query["TargetNamespaceId"] = request.TargetNamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloneNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloneNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CloneNacosConfigRequest
 * @return CloneNacosConfigResponse
 */
func (client *Client) CloneNacosConfig(request *CloneNacosConfigRequest) (_result *CloneNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloneNacosConfigResponse{}
	_body, _err := client.CloneNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateApplicationWithOptions(request *CreateApplicationRequest, runtime *util.RuntimeOptions) (_result *CreateApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SentinelEnable)) {
		query["SentinelEnable"] = request.SentinelEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchEnable)) {
		query["SwitchEnable"] = request.SwitchEnable
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateApplication"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateApplication(request *CreateApplicationRequest) (_result *CreateApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateApplicationResponse{}
	_body, _err := client.CreateApplicationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this API operation, you must make sure that you fully understand the billing method and pricing of MSE.
 *
 * @param request CreateClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateClusterResponse
 */
func (client *Client) CreateClusterWithOptions(request *CreateClusterRequest, runtime *util.RuntimeOptions) (_result *CreateClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterSpecification)) {
		query["ClusterSpecification"] = request.ClusterSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterVersion)) {
		query["ClusterVersion"] = request.ClusterVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionType)) {
		query["ConnectionType"] = request.ConnectionType
	}

	if !tea.BoolValue(util.IsUnset(request.DiskType)) {
		query["DiskType"] = request.DiskType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceCount)) {
		query["InstanceCount"] = request.InstanceCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.NetType)) {
		query["NetType"] = request.NetType
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateSlbSpecification)) {
		query["PrivateSlbSpecification"] = request.PrivateSlbSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.PubNetworkFlow)) {
		query["PubNetworkFlow"] = request.PubNetworkFlow
	}

	if !tea.BoolValue(util.IsUnset(request.PubSlbSpecification)) {
		query["PubSlbSpecification"] = request.PubSlbSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this API operation, you must make sure that you fully understand the billing method and pricing of MSE.
 *
 * @param request CreateClusterRequest
 * @return CreateClusterResponse
 */
func (client *Client) CreateCluster(request *CreateClusterRequest) (_result *CreateClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateClusterResponse{}
	_body, _err := client.CreateClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEngineNamespaceWithOptions(request *CreateEngineNamespaceRequest, runtime *util.RuntimeOptions) (_result *CreateEngineNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceCount)) {
		query["ServiceCount"] = request.ServiceCount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEngineNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEngineNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEngineNamespace(request *CreateEngineNamespaceRequest) (_result *CreateEngineNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEngineNamespaceResponse{}
	_body, _err := client.CreateEngineNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : CreateMseServiceApplication is deprecated, please use mse::2019-05-31::CreateApplication instead.
 *
 * @param request CreateMseServiceApplicationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMseServiceApplicationResponse
 */
// Deprecated
func (client *Client) CreateMseServiceApplicationWithOptions(request *CreateMseServiceApplicationRequest, runtime *util.RuntimeOptions) (_result *CreateMseServiceApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.ExtraInfo)) {
		query["ExtraInfo"] = request.ExtraInfo
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SentinelEnable)) {
		query["SentinelEnable"] = request.SentinelEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchEnable)) {
		query["SwitchEnable"] = request.SwitchEnable
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMseServiceApplication"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateMseServiceApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : CreateMseServiceApplication is deprecated, please use mse::2019-05-31::CreateApplication instead.
 *
 * @param request CreateMseServiceApplicationRequest
 * @return CreateMseServiceApplicationResponse
 */
// Deprecated
func (client *Client) CreateMseServiceApplication(request *CreateMseServiceApplicationRequest) (_result *CreateMseServiceApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateMseServiceApplicationResponse{}
	_body, _err := client.CreateMseServiceApplicationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNacosConfigResponse
 */
func (client *Client) CreateNacosConfigWithOptions(request *CreateNacosConfigRequest, runtime *util.RuntimeOptions) (_result *CreateNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.BetaIps)) {
		query["BetaIps"] = request.BetaIps
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosConfigRequest
 * @return CreateNacosConfigResponse
 */
func (client *Client) CreateNacosConfig(request *CreateNacosConfigRequest) (_result *CreateNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNacosConfigResponse{}
	_body, _err := client.CreateNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNacosInstanceResponse
 */
func (client *Client) CreateNacosInstanceWithOptions(request *CreateNacosInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateNacosInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Metadata)) {
		body["Metadata"] = request.Metadata
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNacosInstance"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNacosInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosInstanceRequest
 * @return CreateNacosInstanceResponse
 */
func (client *Client) CreateNacosInstance(request *CreateNacosInstanceRequest) (_result *CreateNacosInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNacosInstanceResponse{}
	_body, _err := client.CreateNacosInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNacosServiceResponse
 */
func (client *Client) CreateNacosServiceWithOptions(request *CreateNacosServiceRequest, runtime *util.RuntimeOptions) (_result *CreateNacosServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectThreshold)) {
		query["ProtectThreshold"] = request.ProtectThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNacosService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNacosServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request CreateNacosServiceRequest
 * @return CreateNacosServiceResponse
 */
func (client *Client) CreateNacosService(request *CreateNacosServiceRequest) (_result *CreateNacosServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNacosServiceResponse{}
	_body, _err := client.CreateNacosServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLaneWithOptions(tmpReq *CreateOrUpdateSwimmingLaneRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateOrUpdateSwimmingLaneShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GatewaySwimmingLaneRouteJson)) {
		request.GatewaySwimmingLaneRouteJsonShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GatewaySwimmingLaneRouteJson, tea.String("GatewaySwimmingLaneRouteJson"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.EnableRules)) {
		query["EnableRules"] = request.EnableRules
	}

	if !tea.BoolValue(util.IsUnset(request.EntryRule)) {
		query["EntryRule"] = request.EntryRule
	}

	if !tea.BoolValue(util.IsUnset(request.EntryRules)) {
		query["EntryRules"] = request.EntryRules
	}

	if !tea.BoolValue(util.IsUnset(request.GatewaySwimmingLaneRouteJsonShrink)) {
		query["GatewaySwimmingLaneRouteJson"] = request.GatewaySwimmingLaneRouteJsonShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GmtCreate)) {
		query["GmtCreate"] = request.GmtCreate
	}

	if !tea.BoolValue(util.IsUnset(request.GmtModified)) {
		query["GmtModified"] = request.GmtModified
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseKey)) {
		query["LicenseKey"] = request.LicenseKey
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateSwimmingLane"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLane(request *CreateOrUpdateSwimmingLaneRequest) (_result *CreateOrUpdateSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateSwimmingLaneResponse{}
	_body, _err := client.CreateOrUpdateSwimmingLaneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLaneGroupWithOptions(request *CreateOrUpdateSwimmingLaneGroupRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	if !tea.BoolValue(util.IsUnset(request.DbGrayEnable)) {
		query["DbGrayEnable"] = request.DbGrayEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.EntryApp)) {
		query["EntryApp"] = request.EntryApp
	}

	if !tea.BoolValue(util.IsUnset(request.GmtCreate)) {
		query["GmtCreate"] = request.GmtCreate
	}

	if !tea.BoolValue(util.IsUnset(request.GmtModified)) {
		query["GmtModified"] = request.GmtModified
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseKey)) {
		query["LicenseKey"] = request.LicenseKey
	}

	if !tea.BoolValue(util.IsUnset(request.MessageQueueFilterSide)) {
		query["MessageQueueFilterSide"] = request.MessageQueueFilterSide
	}

	if !tea.BoolValue(util.IsUnset(request.MessageQueueGrayEnable)) {
		query["MessageQueueGrayEnable"] = request.MessageQueueGrayEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateSwimmingLaneGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateSwimmingLaneGroup(request *CreateOrUpdateSwimmingLaneGroupRequest) (_result *CreateOrUpdateSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateSwimmingLaneGroupResponse{}
	_body, _err := client.CreateOrUpdateSwimmingLaneGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateZnodeWithOptions(request *CreateZnodeRequest, runtime *util.RuntimeOptions) (_result *CreateZnodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		query["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateZnode"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateZnodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateZnode(request *CreateZnodeRequest) (_result *CreateZnodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateZnodeResponse{}
	_body, _err := client.CreateZnodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAuthResourceWithOptions(request *DeleteAuthResourceRequest, runtime *util.RuntimeOptions) (_result *DeleteAuthResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAuthResource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAuthResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAuthResource(request *DeleteAuthResourceRequest) (_result *DeleteAuthResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAuthResourceResponse{}
	_body, _err := client.DeleteAuthResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteClusterWithOptions(request *DeleteClusterRequest, runtime *util.RuntimeOptions) (_result *DeleteClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCluster(request *DeleteClusterRequest) (_result *DeleteClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteClusterResponse{}
	_body, _err := client.DeleteClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEngineNamespaceWithOptions(request *DeleteEngineNamespaceRequest, runtime *util.RuntimeOptions) (_result *DeleteEngineNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEngineNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEngineNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEngineNamespace(request *DeleteEngineNamespaceRequest) (_result *DeleteEngineNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEngineNamespaceResponse{}
	_body, _err := client.DeleteEngineNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayWithOptions(request *DeleteGatewayRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteSlb)) {
		query["DeleteSlb"] = request.DeleteSlb
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGateway(request *DeleteGatewayRequest) (_result *DeleteGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayResponse{}
	_body, _err := client.DeleteGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayDomainWithOptions(request *DeleteGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayDomain(request *DeleteGatewayDomainRequest) (_result *DeleteGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayDomainResponse{}
	_body, _err := client.DeleteGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayRouteWithOptions(request *DeleteGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayRoute(request *DeleteGatewayRouteRequest) (_result *DeleteGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayRouteResponse{}
	_body, _err := client.DeleteGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayServiceWithOptions(request *DeleteGatewayServiceRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayService(request *DeleteGatewayServiceRequest) (_result *DeleteGatewayServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayServiceResponse{}
	_body, _err := client.DeleteGatewayServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewayServiceVersionWithOptions(request *DeleteGatewayServiceVersionRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewayServiceVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["ServiceVersion"] = request.ServiceVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewayServiceVersion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewayServiceVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewayServiceVersion(request *DeleteGatewayServiceVersionRequest) (_result *DeleteGatewayServiceVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewayServiceVersionResponse{}
	_body, _err := client.DeleteGatewayServiceVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGatewaySlbWithOptions(request *DeleteGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *DeleteGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteSlb)) {
		query["DeleteSlb"] = request.DeleteSlb
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGatewaySlb(request *DeleteGatewaySlbRequest) (_result *DeleteGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGatewaySlbResponse{}
	_body, _err := client.DeleteGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteMigrationTaskWithOptions(request *DeleteMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteMigrationTask(request *DeleteMigrationTaskRequest) (_result *DeleteMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMigrationTaskResponse{}
	_body, _err := client.DeleteMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNacosConfigResponse
 */
func (client *Client) DeleteNacosConfigWithOptions(request *DeleteNacosConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Beta)) {
		query["Beta"] = request.Beta
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosConfigRequest
 * @return DeleteNacosConfigResponse
 */
func (client *Client) DeleteNacosConfig(request *DeleteNacosConfigRequest) (_result *DeleteNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosConfigResponse{}
	_body, _err := client.DeleteNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNacosConfigsResponse
 */
func (client *Client) DeleteNacosConfigsWithOptions(request *DeleteNacosConfigsRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosConfigs"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosConfigsRequest
 * @return DeleteNacosConfigsResponse
 */
func (client *Client) DeleteNacosConfigs(request *DeleteNacosConfigsRequest) (_result *DeleteNacosConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosConfigsResponse{}
	_body, _err := client.DeleteNacosConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNacosInstanceResponse
 */
func (client *Client) DeleteNacosInstanceWithOptions(request *DeleteNacosInstanceRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosInstance"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosInstanceRequest
 * @return DeleteNacosInstanceResponse
 */
func (client *Client) DeleteNacosInstance(request *DeleteNacosInstanceRequest) (_result *DeleteNacosInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosInstanceResponse{}
	_body, _err := client.DeleteNacosInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNacosServiceResponse
 */
func (client *Client) DeleteNacosServiceWithOptions(request *DeleteNacosServiceRequest, runtime *util.RuntimeOptions) (_result *DeleteNacosServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNacosService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNacosServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request DeleteNacosServiceRequest
 * @return DeleteNacosServiceResponse
 */
func (client *Client) DeleteNacosService(request *DeleteNacosServiceRequest) (_result *DeleteNacosServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNacosServiceResponse{}
	_body, _err := client.DeleteNacosServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSecurityGroupRuleWithOptions(request *DeleteSecurityGroupRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteSecurityGroupRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSecurityGroupRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSecurityGroupRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSecurityGroupRule(request *DeleteSecurityGroupRuleRequest) (_result *DeleteSecurityGroupRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSecurityGroupRuleResponse{}
	_body, _err := client.DeleteSecurityGroupRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteServiceSourceWithOptions(request *DeleteServiceSourceRequest, runtime *util.RuntimeOptions) (_result *DeleteServiceSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceId)) {
		query["SourceId"] = request.SourceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteServiceSource(request *DeleteServiceSourceRequest) (_result *DeleteServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteServiceSourceResponse{}
	_body, _err := client.DeleteServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSwimmingLaneWithOptions(request *DeleteSwimmingLaneRequest, runtime *util.RuntimeOptions) (_result *DeleteSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.LaneId)) {
		query["LaneId"] = request.LaneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSwimmingLane"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSwimmingLane(request *DeleteSwimmingLaneRequest) (_result *DeleteSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSwimmingLaneResponse{}
	_body, _err := client.DeleteSwimmingLaneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSwimmingLaneGroupWithOptions(request *DeleteSwimmingLaneGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSwimmingLaneGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSwimmingLaneGroup(request *DeleteSwimmingLaneGroupRequest) (_result *DeleteSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSwimmingLaneGroupResponse{}
	_body, _err := client.DeleteSwimmingLaneGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteZnodeWithOptions(request *DeleteZnodeRequest, runtime *util.RuntimeOptions) (_result *DeleteZnodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteZnode"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteZnodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteZnode(request *DeleteZnodeRequest) (_result *DeleteZnodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteZnodeResponse{}
	_body, _err := client.DeleteZnodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ExportNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportNacosConfigResponse
 */
func (client *Client) ExportNacosConfigWithOptions(request *ExportNacosConfigRequest, runtime *util.RuntimeOptions) (_result *ExportNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ExportNacosConfigRequest
 * @return ExportNacosConfigResponse
 */
func (client *Client) ExportNacosConfig(request *ExportNacosConfigRequest) (_result *ExportNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportNacosConfigResponse{}
	_body, _err := client.ExportNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Only one task can run at a time.
 *
 * @param request ExportZookeeperDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportZookeeperDataResponse
 */
func (client *Client) ExportZookeeperDataWithOptions(request *ExportZookeeperDataRequest, runtime *util.RuntimeOptions) (_result *ExportZookeeperDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ExportType)) {
		query["ExportType"] = request.ExportType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportZookeeperData"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportZookeeperDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Only one task can run at a time.
 *
 * @param request ExportZookeeperDataRequest
 * @return ExportZookeeperDataResponse
 */
func (client *Client) ExportZookeeperData(request *ExportZookeeperDataRequest) (_result *ExportZookeeperDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportZookeeperDataResponse{}
	_body, _err := client.ExportZookeeperDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) FetchLosslessRuleListWithOptions(request *FetchLosslessRuleListRequest, runtime *util.RuntimeOptions) (_result *FetchLosslessRuleListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("FetchLosslessRuleList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &FetchLosslessRuleListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) FetchLosslessRuleList(request *FetchLosslessRuleListRequest) (_result *FetchLosslessRuleListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &FetchLosslessRuleListResponse{}
	_body, _err := client.FetchLosslessRuleListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAppMessageQueueRouteWithOptions(request *GetAppMessageQueueRouteRequest, runtime *util.RuntimeOptions) (_result *GetAppMessageQueueRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppMessageQueueRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppMessageQueueRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAppMessageQueueRoute(request *GetAppMessageQueueRouteRequest) (_result *GetAppMessageQueueRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAppMessageQueueRouteResponse{}
	_body, _err := client.GetAppMessageQueueRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetApplicationListWithOptions(request *GetApplicationListRequest, runtime *util.RuntimeOptions) (_result *GetApplicationListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SentinelEnable)) {
		query["SentinelEnable"] = request.SentinelEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchEnable)) {
		query["SwitchEnable"] = request.SwitchEnable
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetApplicationList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetApplicationListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetApplicationList(request *GetApplicationListRequest) (_result *GetApplicationListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetApplicationListResponse{}
	_body, _err := client.GetApplicationListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetApplicationListWithMetircsWithOptions(request *GetApplicationListWithMetircsRequest, runtime *util.RuntimeOptions) (_result *GetApplicationListWithMetircsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetApplicationListWithMetircs"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetApplicationListWithMetircsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetApplicationListWithMetircs(request *GetApplicationListWithMetircsRequest) (_result *GetApplicationListWithMetircsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetApplicationListWithMetircsResponse{}
	_body, _err := client.GetApplicationListWithMetircsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBlackWhiteListWithOptions(request *GetBlackWhiteListRequest, runtime *util.RuntimeOptions) (_result *GetBlackWhiteListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.IsWhite)) {
		query["IsWhite"] = request.IsWhite
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBlackWhiteList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBlackWhiteListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBlackWhiteList(request *GetBlackWhiteListRequest) (_result *GetBlackWhiteListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBlackWhiteListResponse{}
	_body, _err := client.GetBlackWhiteListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetEngineNamepaceWithOptions(request *GetEngineNamepaceRequest, runtime *util.RuntimeOptions) (_result *GetEngineNamepaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEngineNamepace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEngineNamepaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetEngineNamepace(request *GetEngineNamepaceRequest) (_result *GetEngineNamepaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEngineNamepaceResponse{}
	_body, _err := client.GetEngineNamepaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayWithOptions(request *GetGatewayRequest, runtime *util.RuntimeOptions) (_result *GetGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGateway(request *GetGatewayRequest) (_result *GetGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayResponse{}
	_body, _err := client.GetGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayDomainDetailWithOptions(request *GetGatewayDomainDetailRequest, runtime *util.RuntimeOptions) (_result *GetGatewayDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayDomainDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayDomainDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayDomainDetail(request *GetGatewayDomainDetailRequest) (_result *GetGatewayDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayDomainDetailResponse{}
	_body, _err := client.GetGatewayDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayOptionWithOptions(request *GetGatewayOptionRequest, runtime *util.RuntimeOptions) (_result *GetGatewayOptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayOption"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayOptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayOption(request *GetGatewayOptionRequest) (_result *GetGatewayOptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayOptionResponse{}
	_body, _err := client.GetGatewayOptionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayRouteDetailWithOptions(request *GetGatewayRouteDetailRequest, runtime *util.RuntimeOptions) (_result *GetGatewayRouteDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayRouteDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayRouteDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayRouteDetail(request *GetGatewayRouteDetailRequest) (_result *GetGatewayRouteDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayRouteDetailResponse{}
	_body, _err := client.GetGatewayRouteDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGatewayServiceDetailWithOptions(request *GetGatewayServiceDetailRequest, runtime *util.RuntimeOptions) (_result *GetGatewayServiceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayServiceDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayServiceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGatewayServiceDetail(request *GetGatewayServiceDetailRequest) (_result *GetGatewayServiceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayServiceDetailResponse{}
	_body, _err := client.GetGatewayServiceDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGovernanceKubernetesClusterWithOptions(request *GetGovernanceKubernetesClusterRequest, runtime *util.RuntimeOptions) (_result *GetGovernanceKubernetesClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGovernanceKubernetesCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGovernanceKubernetesClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGovernanceKubernetesCluster(request *GetGovernanceKubernetesClusterRequest) (_result *GetGovernanceKubernetesClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGovernanceKubernetesClusterResponse{}
	_body, _err := client.GetGovernanceKubernetesClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetImageWithOptions(request *GetImageRequest, runtime *util.RuntimeOptions) (_result *GetImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.VersionCode)) {
		query["VersionCode"] = request.VersionCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImage"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetImage(request *GetImageRequest) (_result *GetImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImageResponse{}
	_body, _err := client.GetImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetImportFileUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImportFileUrlResponse
 */
func (client *Client) GetImportFileUrlWithOptions(request *GetImportFileUrlRequest, runtime *util.RuntimeOptions) (_result *GetImportFileUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ContentType)) {
		query["ContentType"] = request.ContentType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImportFileUrl"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetImportFileUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetImportFileUrlRequest
 * @return GetImportFileUrlResponse
 */
func (client *Client) GetImportFileUrl(request *GetImportFileUrlRequest) (_result *GetImportFileUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImportFileUrlResponse{}
	_body, _err := client.GetImportFileUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetKubernetesSourceWithOptions(request *GetKubernetesSourceRequest, runtime *util.RuntimeOptions) (_result *GetKubernetesSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetKubernetesSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetKubernetesSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetKubernetesSource(request *GetKubernetesSourceRequest) (_result *GetKubernetesSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetKubernetesSourceResponse{}
	_body, _err := client.GetKubernetesSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMseFeatureSwitchWithOptions(request *GetMseFeatureSwitchRequest, runtime *util.RuntimeOptions) (_result *GetMseFeatureSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMseFeatureSwitch"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMseFeatureSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMseFeatureSwitch(request *GetMseFeatureSwitchRequest) (_result *GetMseFeatureSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMseFeatureSwitchResponse{}
	_body, _err := client.GetMseFeatureSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMseSourceWithOptions(request *GetMseSourceRequest, runtime *util.RuntimeOptions) (_result *GetMseSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMseSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMseSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMseSource(request *GetMseSourceRequest) (_result *GetMseSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMseSourceResponse{}
	_body, _err := client.GetMseSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNacosConfigResponse
 */
func (client *Client) GetNacosConfigWithOptions(request *GetNacosConfigRequest, runtime *util.RuntimeOptions) (_result *GetNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Beta)) {
		query["Beta"] = request.Beta
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosConfigRequest
 * @return GetNacosConfigResponse
 */
func (client *Client) GetNacosConfig(request *GetNacosConfigRequest) (_result *GetNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNacosConfigResponse{}
	_body, _err := client.GetNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosHistoryConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNacosHistoryConfigResponse
 */
func (client *Client) GetNacosHistoryConfigWithOptions(request *GetNacosHistoryConfigRequest, runtime *util.RuntimeOptions) (_result *GetNacosHistoryConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Nid)) {
		query["Nid"] = request.Nid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNacosHistoryConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNacosHistoryConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request GetNacosHistoryConfigRequest
 * @return GetNacosHistoryConfigResponse
 */
func (client *Client) GetNacosHistoryConfig(request *GetNacosHistoryConfigRequest) (_result *GetNacosHistoryConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNacosHistoryConfigResponse{}
	_body, _err := client.GetNacosHistoryConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOverviewWithOptions(request *GetOverviewRequest, runtime *util.RuntimeOptions) (_result *GetOverviewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOverview"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOverviewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOverview(request *GetOverviewRequest) (_result *GetOverviewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOverviewResponse{}
	_body, _err := client.GetOverviewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPluginConfigWithOptions(request *GetPluginConfigRequest, runtime *util.RuntimeOptions) (_result *GetPluginConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.PluginId)) {
		query["PluginId"] = request.PluginId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPluginConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPluginConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPluginConfig(request *GetPluginConfigRequest) (_result *GetPluginConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPluginConfigResponse{}
	_body, _err := client.GetPluginConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPluginsWithOptions(request *GetPluginsRequest, runtime *util.RuntimeOptions) (_result *GetPluginsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Category)) {
		query["Category"] = request.Category
	}

	if !tea.BoolValue(util.IsUnset(request.EnableOnly)) {
		query["EnableOnly"] = request.EnableOnly
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPlugins"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPluginsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPlugins(request *GetPluginsRequest) (_result *GetPluginsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPluginsResponse{}
	_body, _err := client.GetPluginsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceListWithOptions(request *GetServiceListRequest, runtime *util.RuntimeOptions) (_result *GetServiceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceList(request *GetServiceListRequest) (_result *GetServiceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetServiceListResponse{}
	_body, _err := client.GetServiceListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceListenersWithOptions(request *GetServiceListenersRequest, runtime *util.RuntimeOptions) (_result *GetServiceListenersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.HasIpCount)) {
		query["HasIpCount"] = request.HasIpCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceListeners"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceListenersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceListeners(request *GetServiceListenersRequest) (_result *GetServiceListenersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetServiceListenersResponse{}
	_body, _err := client.GetServiceListenersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTagsBySwimmingLaneGroupIdWithOptions(request *GetTagsBySwimmingLaneGroupIdRequest, runtime *util.RuntimeOptions) (_result *GetTagsBySwimmingLaneGroupIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTagsBySwimmingLaneGroupId"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTagsBySwimmingLaneGroupIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTagsBySwimmingLaneGroupId(request *GetTagsBySwimmingLaneGroupIdRequest) (_result *GetTagsBySwimmingLaneGroupIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTagsBySwimmingLaneGroupIdResponse{}
	_body, _err := client.GetTagsBySwimmingLaneGroupIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetZookeeperDataImportUrlWithOptions(request *GetZookeeperDataImportUrlRequest, runtime *util.RuntimeOptions) (_result *GetZookeeperDataImportUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ContentType)) {
		query["ContentType"] = request.ContentType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetZookeeperDataImportUrl"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetZookeeperDataImportUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetZookeeperDataImportUrl(request *GetZookeeperDataImportUrlRequest) (_result *GetZookeeperDataImportUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetZookeeperDataImportUrlResponse{}
	_body, _err := client.GetZookeeperDataImportUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ImportNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportNacosConfigResponse
 */
func (client *Client) ImportNacosConfigWithOptions(request *ImportNacosConfigRequest, runtime *util.RuntimeOptions) (_result *ImportNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.FileUrl)) {
		query["FileUrl"] = request.FileUrl
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Policy)) {
		query["Policy"] = request.Policy
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ImportNacosConfigRequest
 * @return ImportNacosConfigResponse
 */
func (client *Client) ImportNacosConfig(request *ImportNacosConfigRequest) (_result *ImportNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportNacosConfigResponse{}
	_body, _err := client.ImportNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ImportServicesWithOptions(tmpReq *ImportServicesRequest, runtime *util.RuntimeOptions) (_result *ImportServicesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ImportServicesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ServiceList)) {
		request.ServiceListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ServiceList, tea.String("ServiceList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceListShrink)) {
		query["ServiceList"] = request.ServiceListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TlsSetting)) {
		query["TlsSetting"] = request.TlsSetting
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ImportServices(request *ImportServicesRequest) (_result *ImportServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportServicesResponse{}
	_body, _err := client.ImportServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **
 * **Danger** This operation clears existing data. Exercise caution when you call this API operation.
 *
 * @param request ImportZookeeperDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportZookeeperDataResponse
 */
func (client *Client) ImportZookeeperDataWithOptions(request *ImportZookeeperDataRequest, runtime *util.RuntimeOptions) (_result *ImportZookeeperDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileUrl)) {
		query["FileUrl"] = request.FileUrl
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportZookeeperData"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportZookeeperDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **
 * **Danger** This operation clears existing data. Exercise caution when you call this API operation.
 *
 * @param request ImportZookeeperDataRequest
 * @return ImportZookeeperDataResponse
 */
func (client *Client) ImportZookeeperData(request *ImportZookeeperDataRequest) (_result *ImportZookeeperDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportZookeeperDataResponse{}
	_body, _err := client.ImportZookeeperDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnsInstancesResponse
 */
func (client *Client) ListAnsInstancesWithOptions(request *ListAnsInstancesRequest, runtime *util.RuntimeOptions) (_result *ListAnsInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnsInstances"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnsInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsInstancesRequest
 * @return ListAnsInstancesResponse
 */
func (client *Client) ListAnsInstances(request *ListAnsInstancesRequest) (_result *ListAnsInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAnsInstancesResponse{}
	_body, _err := client.ListAnsInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServiceClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnsServiceClustersResponse
 */
func (client *Client) ListAnsServiceClustersWithOptions(request *ListAnsServiceClustersRequest, runtime *util.RuntimeOptions) (_result *ListAnsServiceClustersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnsServiceClusters"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnsServiceClustersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServiceClustersRequest
 * @return ListAnsServiceClustersResponse
 */
func (client *Client) ListAnsServiceClusters(request *ListAnsServiceClustersRequest) (_result *ListAnsServiceClustersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAnsServiceClustersResponse{}
	_body, _err := client.ListAnsServiceClustersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnsServicesResponse
 */
func (client *Client) ListAnsServicesWithOptions(request *ListAnsServicesRequest, runtime *util.RuntimeOptions) (_result *ListAnsServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnsServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnsServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListAnsServicesRequest
 * @return ListAnsServicesResponse
 */
func (client *Client) ListAnsServices(request *ListAnsServicesRequest) (_result *ListAnsServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAnsServicesResponse{}
	_body, _err := client.ListAnsServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAppBySwimmingLaneGroupTagWithOptions(request *ListAppBySwimmingLaneGroupTagRequest, runtime *util.RuntimeOptions) (_result *ListAppBySwimmingLaneGroupTagResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAppBySwimmingLaneGroupTag"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAppBySwimmingLaneGroupTagResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAppBySwimmingLaneGroupTag(request *ListAppBySwimmingLaneGroupTagRequest) (_result *ListAppBySwimmingLaneGroupTagResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAppBySwimmingLaneGroupTagResponse{}
	_body, _err := client.ListAppBySwimmingLaneGroupTagWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListApplicationsWithTagRulesWithOptions(request *ListApplicationsWithTagRulesRequest, runtime *util.RuntimeOptions) (_result *ListApplicationsWithTagRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListApplicationsWithTagRules"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListApplicationsWithTagRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListApplicationsWithTagRules(request *ListApplicationsWithTagRulesRequest) (_result *ListApplicationsWithTagRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListApplicationsWithTagRulesResponse{}
	_body, _err := client.ListApplicationsWithTagRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterConnectionTypesWithOptions(request *ListClusterConnectionTypesRequest, runtime *util.RuntimeOptions) (_result *ListClusterConnectionTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterConnectionTypes"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterConnectionTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterConnectionTypes(request *ListClusterConnectionTypesRequest) (_result *ListClusterConnectionTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterConnectionTypesResponse{}
	_body, _err := client.ListClusterConnectionTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterHealthCheckTaskWithOptions(request *ListClusterHealthCheckTaskRequest, runtime *util.RuntimeOptions) (_result *ListClusterHealthCheckTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterHealthCheckTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterHealthCheckTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterHealthCheckTask(request *ListClusterHealthCheckTaskRequest) (_result *ListClusterHealthCheckTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterHealthCheckTaskResponse{}
	_body, _err := client.ListClusterHealthCheckTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterTypesWithOptions(request *ListClusterTypesRequest, runtime *util.RuntimeOptions) (_result *ListClusterTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectType)) {
		query["ConnectType"] = request.ConnectType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterTypes"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterTypes(request *ListClusterTypesRequest) (_result *ListClusterTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterTypesResponse{}
	_body, _err := client.ListClusterTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterVersionsWithOptions(request *ListClusterVersionsRequest, runtime *util.RuntimeOptions) (_result *ListClusterVersionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterVersions"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterVersionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterVersions(request *ListClusterVersionsRequest) (_result *ListClusterVersionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterVersionsResponse{}
	_body, _err := client.ListClusterVersionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClustersWithOptions(request *ListClustersRequest, runtime *util.RuntimeOptions) (_result *ListClustersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusters"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClustersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusters(request *ListClustersRequest) (_result *ListClustersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClustersResponse{}
	_body, _err := client.ListClustersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListConfigTrackWithOptions(request *ListConfigTrackRequest, runtime *util.RuntimeOptions) (_result *ListConfigTrackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConfigTrack"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigTrackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListConfigTrack(request *ListConfigTrackRequest) (_result *ListConfigTrackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListConfigTrackResponse{}
	_body, _err := client.ListConfigTrackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEngineNamespacesWithOptions(request *ListEngineNamespacesRequest, runtime *util.RuntimeOptions) (_result *ListEngineNamespacesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEngineNamespaces"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEngineNamespacesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEngineNamespaces(request *ListEngineNamespacesRequest) (_result *ListEngineNamespacesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEngineNamespacesResponse{}
	_body, _err := client.ListEngineNamespacesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEurekaInstancesWithOptions(request *ListEurekaInstancesRequest, runtime *util.RuntimeOptions) (_result *ListEurekaInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEurekaInstances"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEurekaInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEurekaInstances(request *ListEurekaInstancesRequest) (_result *ListEurekaInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEurekaInstancesResponse{}
	_body, _err := client.ListEurekaInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEurekaServicesWithOptions(request *ListEurekaServicesRequest, runtime *util.RuntimeOptions) (_result *ListEurekaServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEurekaServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEurekaServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEurekaServices(request *ListEurekaServicesRequest) (_result *ListEurekaServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEurekaServicesResponse{}
	_body, _err := client.ListEurekaServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListExportZookeeperDataWithOptions(request *ListExportZookeeperDataRequest, runtime *util.RuntimeOptions) (_result *ListExportZookeeperDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListExportZookeeperData"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListExportZookeeperDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListExportZookeeperData(request *ListExportZookeeperDataRequest) (_result *ListExportZookeeperDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListExportZookeeperDataResponse{}
	_body, _err := client.ListExportZookeeperDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayWithOptions(tmpReq *ListGatewayRequest, runtime *util.RuntimeOptions) (_result *ListGatewayResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListGatewayShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FilterParams)) {
		request.FilterParamsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterParams, tea.String("FilterParams"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DescSort)) {
		query["DescSort"] = request.DescSort
	}

	if !tea.BoolValue(util.IsUnset(request.FilterParamsShrink)) {
		query["FilterParams"] = request.FilterParamsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderItem)) {
		query["OrderItem"] = request.OrderItem
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGateway"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGateway(request *ListGatewayRequest) (_result *ListGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayResponse{}
	_body, _err := client.ListGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayDomainWithOptions(request *ListGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *ListGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayDomain(request *ListGatewayDomainRequest) (_result *ListGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayDomainResponse{}
	_body, _err := client.ListGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayRouteWithOptions(tmpReq *ListGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *ListGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListGatewayRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FilterParams)) {
		request.FilterParamsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterParams, tea.String("FilterParams"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DescSort)) {
		query["DescSort"] = request.DescSort
	}

	if !tea.BoolValue(util.IsUnset(request.FilterParamsShrink)) {
		query["FilterParams"] = request.FilterParamsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderItem)) {
		query["OrderItem"] = request.OrderItem
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayRoute(request *ListGatewayRouteRequest) (_result *ListGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayRouteResponse{}
	_body, _err := client.ListGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewayServiceWithOptions(tmpReq *ListGatewayServiceRequest, runtime *util.RuntimeOptions) (_result *ListGatewayServiceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListGatewayServiceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FilterParams)) {
		request.FilterParamsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterParams, tea.String("FilterParams"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DescSort)) {
		query["DescSort"] = request.DescSort
	}

	if !tea.BoolValue(util.IsUnset(request.FilterParamsShrink)) {
		query["FilterParams"] = request.FilterParamsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderItem)) {
		query["OrderItem"] = request.OrderItem
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewayService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewayServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewayService(request *ListGatewayServiceRequest) (_result *ListGatewayServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewayServiceResponse{}
	_body, _err := client.ListGatewayServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGatewaySlbWithOptions(request *ListGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *ListGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGatewaySlb(request *ListGatewaySlbRequest) (_result *ListGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGatewaySlbResponse{}
	_body, _err := client.ListGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstanceCountWithOptions(request *ListInstanceCountRequest, runtime *util.RuntimeOptions) (_result *ListInstanceCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceCount"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstanceCount(request *ListInstanceCountRequest) (_result *ListInstanceCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstanceCountResponse{}
	_body, _err := client.ListInstanceCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListListenersByConfigResponse
 */
func (client *Client) ListListenersByConfigWithOptions(request *ListListenersByConfigRequest, runtime *util.RuntimeOptions) (_result *ListListenersByConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListListenersByConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListListenersByConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByConfigRequest
 * @return ListListenersByConfigResponse
 */
func (client *Client) ListListenersByConfig(request *ListListenersByConfigRequest) (_result *ListListenersByConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListListenersByConfigResponse{}
	_body, _err := client.ListListenersByConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListListenersByIpResponse
 */
func (client *Client) ListListenersByIpWithOptions(request *ListListenersByIpRequest, runtime *util.RuntimeOptions) (_result *ListListenersByIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListListenersByIp"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListListenersByIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListListenersByIpRequest
 * @return ListListenersByIpResponse
 */
func (client *Client) ListListenersByIp(request *ListListenersByIpRequest) (_result *ListListenersByIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListListenersByIpResponse{}
	_body, _err := client.ListListenersByIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListMigrationTaskWithOptions(request *ListMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *ListMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListMigrationTask(request *ListMigrationTaskRequest) (_result *ListMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListMigrationTaskResponse{}
	_body, _err := client.ListMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNacosConfigsResponse
 */
func (client *Client) ListNacosConfigsWithOptions(request *ListNacosConfigsRequest, runtime *util.RuntimeOptions) (_result *ListNacosConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNacosConfigs"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNacosConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosConfigsRequest
 * @return ListNacosConfigsResponse
 */
func (client *Client) ListNacosConfigs(request *ListNacosConfigsRequest) (_result *ListNacosConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNacosConfigsResponse{}
	_body, _err := client.ListNacosConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosHistoryConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNacosHistoryConfigsResponse
 */
func (client *Client) ListNacosHistoryConfigsWithOptions(request *ListNacosHistoryConfigsRequest, runtime *util.RuntimeOptions) (_result *ListNacosHistoryConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNacosHistoryConfigs"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNacosHistoryConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request ListNacosHistoryConfigsRequest
 * @return ListNacosHistoryConfigsResponse
 */
func (client *Client) ListNacosHistoryConfigs(request *ListNacosHistoryConfigsRequest) (_result *ListNacosHistoryConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNacosHistoryConfigsResponse{}
	_body, _err := client.ListNacosHistoryConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNamingTrackWithOptions(request *ListNamingTrackRequest, runtime *util.RuntimeOptions) (_result *ListNamingTrackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNamingTrack"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNamingTrackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNamingTrack(request *ListNamingTrackRequest) (_result *ListNamingTrackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNamingTrackResponse{}
	_body, _err := client.ListNamingTrackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSSLCertWithOptions(request *ListSSLCertRequest, runtime *util.RuntimeOptions) (_result *ListSSLCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSSLCert"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSSLCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSSLCert(request *ListSSLCertRequest) (_result *ListSSLCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSSLCertResponse{}
	_body, _err := client.ListSSLCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSecurityGroupWithOptions(request *ListSecurityGroupRequest, runtime *util.RuntimeOptions) (_result *ListSecurityGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSecurityGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSecurityGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSecurityGroup(request *ListSecurityGroupRequest) (_result *ListSecurityGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSecurityGroupResponse{}
	_body, _err := client.ListSecurityGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSecurityGroupRuleWithOptions(request *ListSecurityGroupRuleRequest, runtime *util.RuntimeOptions) (_result *ListSecurityGroupRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSecurityGroupRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSecurityGroupRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSecurityGroupRule(request *ListSecurityGroupRuleRequest) (_result *ListSecurityGroupRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSecurityGroupRuleResponse{}
	_body, _err := client.ListSecurityGroupRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListServiceSourceWithOptions(request *ListServiceSourceRequest, runtime *util.RuntimeOptions) (_result *ListServiceSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListServiceSource(request *ListServiceSourceRequest) (_result *ListServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListServiceSourceResponse{}
	_body, _err := client.ListServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListZkTrackWithOptions(request *ListZkTrackRequest, runtime *util.RuntimeOptions) (_result *ListZkTrackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListZkTrack"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListZkTrackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListZkTrack(request *ListZkTrackRequest) (_result *ListZkTrackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListZkTrackResponse{}
	_body, _err := client.ListZkTrackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListZnodeChildrenWithOptions(request *ListZnodeChildrenRequest, runtime *util.RuntimeOptions) (_result *ListZnodeChildrenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListZnodeChildren"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListZnodeChildrenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListZnodeChildren(request *ListZnodeChildrenRequest) (_result *ListZnodeChildrenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListZnodeChildrenResponse{}
	_body, _err := client.ListZnodeChildrenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyGovernanceKubernetesClusterWithOptions(request *ModifyGovernanceKubernetesClusterRequest, runtime *util.RuntimeOptions) (_result *ModifyGovernanceKubernetesClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceInfos)) {
		query["NamespaceInfos"] = request.NamespaceInfos
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyGovernanceKubernetesCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyGovernanceKubernetesClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyGovernanceKubernetesCluster(request *ModifyGovernanceKubernetesClusterRequest) (_result *ModifyGovernanceKubernetesClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyGovernanceKubernetesClusterResponse{}
	_body, _err := client.ModifyGovernanceKubernetesClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyLosslessRuleWithOptions(request *ModifyLosslessRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyLosslessRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Aligned)) {
		query["Aligned"] = request.Aligned
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DelayTime)) {
		query["DelayTime"] = request.DelayTime
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.FuncType)) {
		query["FuncType"] = request.FuncType
	}

	if !tea.BoolValue(util.IsUnset(request.LossLessDetail)) {
		query["LossLessDetail"] = request.LossLessDetail
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Notice)) {
		query["Notice"] = request.Notice
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Related)) {
		query["Related"] = request.Related
	}

	if !tea.BoolValue(util.IsUnset(request.ShutdownWaitSeconds)) {
		query["ShutdownWaitSeconds"] = request.ShutdownWaitSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.WarmupTime)) {
		query["WarmupTime"] = request.WarmupTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLosslessRule"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLosslessRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyLosslessRule(request *ModifyLosslessRuleRequest) (_result *ModifyLosslessRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLosslessRuleResponse{}
	_body, _err := client.ModifyLosslessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OfflineGatewayRouteWithOptions(request *OfflineGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *OfflineGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OfflineGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OfflineGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OfflineGatewayRoute(request *OfflineGatewayRouteRequest) (_result *OfflineGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OfflineGatewayRouteResponse{}
	_body, _err := client.OfflineGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OrderClusterHealthCheckRiskNoticeWithOptions(request *OrderClusterHealthCheckRiskNoticeRequest, runtime *util.RuntimeOptions) (_result *OrderClusterHealthCheckRiskNoticeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Mute)) {
		query["Mute"] = request.Mute
	}

	if !tea.BoolValue(util.IsUnset(request.NoticeType)) {
		query["NoticeType"] = request.NoticeType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.RiskCode)) {
		query["RiskCode"] = request.RiskCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OrderClusterHealthCheckRiskNotice"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OrderClusterHealthCheckRiskNoticeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OrderClusterHealthCheckRiskNotice(request *OrderClusterHealthCheckRiskNoticeRequest) (_result *OrderClusterHealthCheckRiskNoticeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OrderClusterHealthCheckRiskNoticeResponse{}
	_body, _err := client.OrderClusterHealthCheckRiskNoticeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PullServicesWithOptions(request *PullServicesRequest, runtime *util.RuntimeOptions) (_result *PullServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PullServices"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PullServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PullServices(request *PullServicesRequest) (_result *PullServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PullServicesResponse{}
	_body, _err := client.PullServicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PutClusterHealthCheckTaskWithOptions(request *PutClusterHealthCheckTaskRequest, runtime *util.RuntimeOptions) (_result *PutClusterHealthCheckTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PutClusterHealthCheckTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PutClusterHealthCheckTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PutClusterHealthCheckTask(request *PutClusterHealthCheckTaskRequest) (_result *PutClusterHealthCheckTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PutClusterHealthCheckTaskResponse{}
	_body, _err := client.PutClusterHealthCheckTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryAllSwimmingLaneWithOptions(request *QueryAllSwimmingLaneRequest, runtime *util.RuntimeOptions) (_result *QueryAllSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryAllSwimmingLane"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryAllSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryAllSwimmingLane(request *QueryAllSwimmingLaneRequest) (_result *QueryAllSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryAllSwimmingLaneResponse{}
	_body, _err := client.QueryAllSwimmingLaneWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryAllSwimmingLaneGroupWithOptions(request *QueryAllSwimmingLaneGroupRequest, runtime *util.RuntimeOptions) (_result *QueryAllSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryAllSwimmingLaneGroup"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryAllSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryAllSwimmingLaneGroup(request *QueryAllSwimmingLaneGroupRequest) (_result *QueryAllSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryAllSwimmingLaneGroupResponse{}
	_body, _err := client.QueryAllSwimmingLaneGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryBusinessLocationsWithOptions(request *QueryBusinessLocationsRequest, runtime *util.RuntimeOptions) (_result *QueryBusinessLocationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryBusinessLocations"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryBusinessLocationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryBusinessLocations(request *QueryBusinessLocationsRequest) (_result *QueryBusinessLocationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryBusinessLocationsResponse{}
	_body, _err := client.QueryBusinessLocationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterDetailWithOptions(request *QueryClusterDetailRequest, runtime *util.RuntimeOptions) (_result *QueryClusterDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AclSwitch)) {
		query["AclSwitch"] = request.AclSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterDetail(request *QueryClusterDetailRequest) (_result *QueryClusterDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterDetailResponse{}
	_body, _err := client.QueryClusterDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterDiskSpecificationWithOptions(request *QueryClusterDiskSpecificationRequest, runtime *util.RuntimeOptions) (_result *QueryClusterDiskSpecificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterDiskSpecification"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterDiskSpecificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterDiskSpecification(request *QueryClusterDiskSpecificationRequest) (_result *QueryClusterDiskSpecificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterDiskSpecificationResponse{}
	_body, _err := client.QueryClusterDiskSpecificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterInfoWithOptions(request *QueryClusterInfoRequest, runtime *util.RuntimeOptions) (_result *QueryClusterInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AclSwitch)) {
		query["AclSwitch"] = request.AclSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterInfo"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterInfo(request *QueryClusterInfoRequest) (_result *QueryClusterInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterInfoResponse{}
	_body, _err := client.QueryClusterInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryClusterSpecificationWithOptions(request *QueryClusterSpecificationRequest, runtime *util.RuntimeOptions) (_result *QueryClusterSpecificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectType)) {
		query["ConnectType"] = request.ConnectType
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClusterSpecification"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClusterSpecificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryClusterSpecification(request *QueryClusterSpecificationRequest) (_result *QueryClusterSpecificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClusterSpecificationResponse{}
	_body, _err := client.QueryClusterSpecificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryConfigWithOptions(request *QueryConfigRequest, runtime *util.RuntimeOptions) (_result *QueryConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryConfig(request *QueryConfigRequest) (_result *QueryConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryConfigResponse{}
	_body, _err := client.QueryConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryGatewayRegionWithOptions(request *QueryGatewayRegionRequest, runtime *util.RuntimeOptions) (_result *QueryGatewayRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryGatewayRegion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryGatewayRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryGatewayRegion(request *QueryGatewayRegionRequest) (_result *QueryGatewayRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryGatewayRegionResponse{}
	_body, _err := client.QueryGatewayRegionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryGatewayTypeWithOptions(request *QueryGatewayTypeRequest, runtime *util.RuntimeOptions) (_result *QueryGatewayTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryGatewayType"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryGatewayTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryGatewayType(request *QueryGatewayTypeRequest) (_result *QueryGatewayTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryGatewayTypeResponse{}
	_body, _err := client.QueryGatewayTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryGovernanceKubernetesClusterWithOptions(request *QueryGovernanceKubernetesClusterRequest, runtime *util.RuntimeOptions) (_result *QueryGovernanceKubernetesClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryGovernanceKubernetesCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryGovernanceKubernetesClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryGovernanceKubernetesCluster(request *QueryGovernanceKubernetesClusterRequest) (_result *QueryGovernanceKubernetesClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryGovernanceKubernetesClusterResponse{}
	_body, _err := client.QueryGovernanceKubernetesClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryInstancesInfoWithOptions(request *QueryInstancesInfoRequest, runtime *util.RuntimeOptions) (_result *QueryInstancesInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryInstancesInfo"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryInstancesInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryInstancesInfo(request *QueryInstancesInfoRequest) (_result *QueryInstancesInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryInstancesInfoResponse{}
	_body, _err := client.QueryInstancesInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryMonitorWithOptions(request *QueryMonitorRequest, runtime *util.RuntimeOptions) (_result *QueryMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryMonitor"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryMonitor(request *QueryMonitorRequest) (_result *QueryMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryMonitorResponse{}
	_body, _err := client.QueryMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySlbSpecWithOptions(request *QuerySlbSpecRequest, runtime *util.RuntimeOptions) (_result *QuerySlbSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySlbSpec"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySlbSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySlbSpec(request *QuerySlbSpecRequest) (_result *QuerySlbSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySlbSpecResponse{}
	_body, _err := client.QuerySlbSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySwimmingLaneByIdWithOptions(request *QuerySwimmingLaneByIdRequest, runtime *util.RuntimeOptions) (_result *QuerySwimmingLaneByIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.LaneId)) {
		query["LaneId"] = request.LaneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySwimmingLaneById"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySwimmingLaneByIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySwimmingLaneById(request *QuerySwimmingLaneByIdRequest) (_result *QuerySwimmingLaneByIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySwimmingLaneByIdResponse{}
	_body, _err := client.QuerySwimmingLaneByIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryZnodeDetailWithOptions(request *QueryZnodeDetailRequest, runtime *util.RuntimeOptions) (_result *QueryZnodeDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryZnodeDetail"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryZnodeDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryZnodeDetail(request *QueryZnodeDetailRequest) (_result *QueryZnodeDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryZnodeDetailResponse{}
	_body, _err := client.QueryZnodeDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestartClusterWithOptions(request *RestartClusterRequest, runtime *util.RuntimeOptions) (_result *RestartClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PodNameList)) {
		query["PodNameList"] = request.PodNameList
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestartCluster(request *RestartClusterRequest) (_result *RestartClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestartClusterResponse{}
	_body, _err := client.RestartClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RetryClusterWithOptions(request *RetryClusterRequest, runtime *util.RuntimeOptions) (_result *RetryClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RetryCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RetryClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RetryCluster(request *RetryClusterRequest) (_result *RetryClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RetryClusterResponse{}
	_body, _err := client.RetryClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SelectGatewaySlbWithOptions(request *SelectGatewaySlbRequest, runtime *util.RuntimeOptions) (_result *SelectGatewaySlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SelectGatewaySlb"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SelectGatewaySlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SelectGatewaySlb(request *SelectGatewaySlbRequest) (_result *SelectGatewaySlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SelectGatewaySlbResponse{}
	_body, _err := client.SelectGatewaySlbWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAclWithOptions(request *UpdateAclRequest, runtime *util.RuntimeOptions) (_result *UpdateAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AclEntryList)) {
		query["AclEntryList"] = request.AclEntryList
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAcl"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAcl(request *UpdateAclRequest) (_result *UpdateAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAclResponse{}
	_body, _err := client.UpdateAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateBlackWhiteListWithOptions(request *UpdateBlackWhiteListRequest, runtime *util.RuntimeOptions) (_result *UpdateBlackWhiteListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.IsWhite)) {
		query["IsWhite"] = request.IsWhite
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Note)) {
		query["Note"] = request.Note
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIdJsonList)) {
		query["ResourceIdJsonList"] = request.ResourceIdJsonList
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBlackWhiteList"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBlackWhiteListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateBlackWhiteList(request *UpdateBlackWhiteListRequest) (_result *UpdateBlackWhiteListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBlackWhiteListResponse{}
	_body, _err := client.UpdateBlackWhiteListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateClusterWithOptions(request *UpdateClusterRequest, runtime *util.RuntimeOptions) (_result *UpdateClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterAliasName)) {
		query["ClusterAliasName"] = request.ClusterAliasName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateCluster(request *UpdateClusterRequest) (_result *UpdateClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateClusterResponse{}
	_body, _err := client.UpdateClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to update the number or specifications of nodes in a pay-as-you-go MSE instance. You are charged when you add nodes or upgrade node specifications. For more information, see \\[Pricing] (`~~1806469~~`).
 *
 * @param request UpdateClusterSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateClusterSpecResponse
 */
func (client *Client) UpdateClusterSpecWithOptions(request *UpdateClusterSpecRequest, runtime *util.RuntimeOptions) (_result *UpdateClusterSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterSpecification)) {
		query["ClusterSpecification"] = request.ClusterSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceCount)) {
		query["InstanceCount"] = request.InstanceCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MseVersion)) {
		query["MseVersion"] = request.MseVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateClusterSpec"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateClusterSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to update the number or specifications of nodes in a pay-as-you-go MSE instance. You are charged when you add nodes or upgrade node specifications. For more information, see \\[Pricing] (`~~1806469~~`).
 *
 * @param request UpdateClusterSpecRequest
 * @return UpdateClusterSpecResponse
 */
func (client *Client) UpdateClusterSpec(request *UpdateClusterSpecRequest) (_result *UpdateClusterSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateClusterSpecResponse{}
	_body, _err := client.UpdateClusterSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateConfigWithOptions(request *UpdateConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AutopurgePurgeInterval)) {
		query["AutopurgePurgeInterval"] = request.AutopurgePurgeInterval
	}

	if !tea.BoolValue(util.IsUnset(request.AutopurgeSnapRetainCount)) {
		query["AutopurgeSnapRetainCount"] = request.AutopurgeSnapRetainCount
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigAuthEnabled)) {
		query["ConfigAuthEnabled"] = request.ConfigAuthEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigSecretEnabled)) {
		query["ConfigSecretEnabled"] = request.ConfigSecretEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigType)) {
		query["ConfigType"] = request.ConfigType
	}

	if !tea.BoolValue(util.IsUnset(request.EurekaSupported)) {
		query["EurekaSupported"] = request.EurekaSupported
	}

	if !tea.BoolValue(util.IsUnset(request.ExtendedTypesEnable)) {
		query["ExtendedTypesEnable"] = request.ExtendedTypesEnable
	}

	if !tea.BoolValue(util.IsUnset(request.InitLimit)) {
		query["InitLimit"] = request.InitLimit
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JuteMaxbuffer)) {
		query["JuteMaxbuffer"] = request.JuteMaxbuffer
	}

	if !tea.BoolValue(util.IsUnset(request.MCPEnabled)) {
		query["MCPEnabled"] = request.MCPEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.MaxClientCnxns)) {
		query["MaxClientCnxns"] = request.MaxClientCnxns
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSessionTimeout)) {
		query["MaxSessionTimeout"] = request.MaxSessionTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.MinSessionTimeout)) {
		query["MinSessionTimeout"] = request.MinSessionTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.NamingAuthEnabled)) {
		query["NamingAuthEnabled"] = request.NamingAuthEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.PassWord)) {
		query["PassWord"] = request.PassWord
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotCount)) {
		query["SnapshotCount"] = request.SnapshotCount
	}

	if !tea.BoolValue(util.IsUnset(request.SyncLimit)) {
		query["SyncLimit"] = request.SyncLimit
	}

	if !tea.BoolValue(util.IsUnset(request.TickTime)) {
		query["TickTime"] = request.TickTime
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		query["UserName"] = request.UserName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OpenSuperAcl)) {
		body["OpenSuperAcl"] = request.OpenSuperAcl
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateConfig(request *UpdateConfigRequest) (_result *UpdateConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateConfigResponse{}
	_body, _err := client.UpdateConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEngineNamespaceWithOptions(request *UpdateEngineNamespaceRequest, runtime *util.RuntimeOptions) (_result *UpdateEngineNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceCount)) {
		query["ServiceCount"] = request.ServiceCount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEngineNamespace"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEngineNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEngineNamespace(request *UpdateEngineNamespaceRequest) (_result *UpdateEngineNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEngineNamespaceResponse{}
	_body, _err := client.UpdateEngineNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayDomainWithOptions(request *UpdateGatewayDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Http2)) {
		query["Http2"] = request.Http2
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.MustHttps)) {
		query["MustHttps"] = request.MustHttps
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMax)) {
		query["TlsMax"] = request.TlsMax
	}

	if !tea.BoolValue(util.IsUnset(request.TlsMin)) {
		query["TlsMin"] = request.TlsMin
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayDomain"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayDomain(request *UpdateGatewayDomainRequest) (_result *UpdateGatewayDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayDomainResponse{}
	_body, _err := client.UpdateGatewayDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayNameWithOptions(request *UpdateGatewayNameRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayName"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayName(request *UpdateGatewayNameRequest) (_result *UpdateGatewayNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayNameResponse{}
	_body, _err := client.UpdateGatewayNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayOptionWithOptions(tmpReq *UpdateGatewayOptionRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayOptionResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayOptionShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GatewayOption)) {
		request.GatewayOptionShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GatewayOption, tea.String("GatewayOption"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayOptionShrink)) {
		query["GatewayOption"] = request.GatewayOptionShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayOption"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayOptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayOption(request *UpdateGatewayOptionRequest) (_result *UpdateGatewayOptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayOptionResponse{}
	_body, _err := client.UpdateGatewayOptionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteWithOptions(tmpReq *UpdateGatewayRouteRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DirectResponseJSON)) {
		request.DirectResponseJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DirectResponseJSON, tea.String("DirectResponseJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FallbackServices)) {
		request.FallbackServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FallbackServices, tea.String("FallbackServices"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Predicates)) {
		request.PredicatesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Predicates, tea.String("Predicates"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RedirectJSON)) {
		request.RedirectJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RedirectJSON, tea.String("RedirectJSON"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Services)) {
		request.ServicesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Services, tea.String("Services"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationType)) {
		query["DestinationType"] = request.DestinationType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectResponseJSONShrink)) {
		query["DirectResponseJSON"] = request.DirectResponseJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DomainIdListJSON)) {
		query["DomainIdListJSON"] = request.DomainIdListJSON
	}

	if !tea.BoolValue(util.IsUnset(request.EnableWaf)) {
		query["EnableWaf"] = request.EnableWaf
	}

	if !tea.BoolValue(util.IsUnset(request.Fallback)) {
		query["Fallback"] = request.Fallback
	}

	if !tea.BoolValue(util.IsUnset(request.FallbackServicesShrink)) {
		query["FallbackServices"] = request.FallbackServicesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PredicatesShrink)) {
		query["Predicates"] = request.PredicatesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RedirectJSONShrink)) {
		query["RedirectJSON"] = request.RedirectJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RouteOrder)) {
		query["RouteOrder"] = request.RouteOrder
	}

	if !tea.BoolValue(util.IsUnset(request.ServicesShrink)) {
		query["Services"] = request.ServicesShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRoute(request *UpdateGatewayRouteRequest) (_result *UpdateGatewayRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteResponse{}
	_body, _err := client.UpdateGatewayRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteCORSWithOptions(tmpReq *UpdateGatewayRouteCORSRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteCORSResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteCORSShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.CorsJSON)) {
		request.CorsJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CorsJSON, tea.String("CorsJSON"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CorsJSONShrink)) {
		query["CorsJSON"] = request.CorsJSONShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteCORS"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteCORSResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteCORS(request *UpdateGatewayRouteCORSRequest) (_result *UpdateGatewayRouteCORSResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteCORSResponse{}
	_body, _err := client.UpdateGatewayRouteCORSWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHTTPRewriteWithOptions(request *UpdateGatewayRouteHTTPRewriteRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteHTTPRewriteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.HttpRewriteJSON)) {
		query["HttpRewriteJSON"] = request.HttpRewriteJSON
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteHTTPRewrite"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteHTTPRewriteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHTTPRewrite(request *UpdateGatewayRouteHTTPRewriteRequest) (_result *UpdateGatewayRouteHTTPRewriteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteHTTPRewriteResponse{}
	_body, _err := client.UpdateGatewayRouteHTTPRewriteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHeaderOpWithOptions(request *UpdateGatewayRouteHeaderOpRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteHeaderOpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.HeaderOpJSON)) {
		query["HeaderOpJSON"] = request.HeaderOpJSON
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteHeaderOp"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteHeaderOpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteHeaderOp(request *UpdateGatewayRouteHeaderOpRequest) (_result *UpdateGatewayRouteHeaderOpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteHeaderOpResponse{}
	_body, _err := client.UpdateGatewayRouteHeaderOpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteRetryWithOptions(tmpReq *UpdateGatewayRouteRetryRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteRetryResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteRetryShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.RetryJSON)) {
		request.RetryJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RetryJSON, tea.String("RetryJSON"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.RetryJSONShrink)) {
		query["RetryJSON"] = request.RetryJSONShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteRetry"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteRetryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteRetry(request *UpdateGatewayRouteRetryRequest) (_result *UpdateGatewayRouteRetryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteRetryResponse{}
	_body, _err := client.UpdateGatewayRouteRetryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteTimeoutWithOptions(tmpReq *UpdateGatewayRouteTimeoutRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteTimeoutResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayRouteTimeoutShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.TimeoutJSON)) {
		request.TimeoutJSONShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TimeoutJSON, tea.String("TimeoutJSON"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.TimeoutJSONShrink)) {
		query["TimeoutJSON"] = request.TimeoutJSONShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteTimeout"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteTimeoutResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteTimeout(request *UpdateGatewayRouteTimeoutRequest) (_result *UpdateGatewayRouteTimeoutResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteTimeoutResponse{}
	_body, _err := client.UpdateGatewayRouteTimeoutWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayRouteWafStatusWithOptions(request *UpdateGatewayRouteWafStatusRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayRouteWafStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.EnableWaf)) {
		query["EnableWaf"] = request.EnableWaf
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayRouteWafStatus"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayRouteWafStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayRouteWafStatus(request *UpdateGatewayRouteWafStatusRequest) (_result *UpdateGatewayRouteWafStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayRouteWafStatusResponse{}
	_body, _err := client.UpdateGatewayRouteWafStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayServiceTrafficPolicyWithOptions(tmpReq *UpdateGatewayServiceTrafficPolicyRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayServiceTrafficPolicyResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateGatewayServiceTrafficPolicyShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.GatewayTrafficPolicy)) {
		request.GatewayTrafficPolicyShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.GatewayTrafficPolicy, tea.String("GatewayTrafficPolicy"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayTrafficPolicyShrink)) {
		query["GatewayTrafficPolicy"] = request.GatewayTrafficPolicyShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayServiceTrafficPolicy"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayServiceTrafficPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayServiceTrafficPolicy(request *UpdateGatewayServiceTrafficPolicyRequest) (_result *UpdateGatewayServiceTrafficPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayServiceTrafficPolicyResponse{}
	_body, _err := client.UpdateGatewayServiceTrafficPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGatewayServiceVersionWithOptions(request *UpdateGatewayServiceVersionRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewayServiceVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["ServiceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["ServiceVersion"] = request.ServiceVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewayServiceVersion"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewayServiceVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGatewayServiceVersion(request *UpdateGatewayServiceVersionRequest) (_result *UpdateGatewayServiceVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewayServiceVersionResponse{}
	_body, _err := client.UpdateGatewayServiceVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to update the number or specifications of nodes in a pay-as-you-go cloud-native gateway. You are charged when you add nodes or upgrade node specifications. For more information, see [Pricing](~~250950~~).
 *
 * @param request UpdateGatewaySpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGatewaySpecResponse
 */
func (client *Client) UpdateGatewaySpecWithOptions(request *UpdateGatewaySpecRequest, runtime *util.RuntimeOptions) (_result *UpdateGatewaySpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Replica)) {
		query["Replica"] = request.Replica
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGatewaySpec"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGatewaySpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to update the number or specifications of nodes in a pay-as-you-go cloud-native gateway. You are charged when you add nodes or upgrade node specifications. For more information, see [Pricing](~~250950~~).
 *
 * @param request UpdateGatewaySpecRequest
 * @return UpdateGatewaySpecResponse
 */
func (client *Client) UpdateGatewaySpec(request *UpdateGatewaySpecRequest) (_result *UpdateGatewaySpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGatewaySpecResponse{}
	_body, _err := client.UpdateGatewaySpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateImageWithOptions(request *UpdateImageRequest, runtime *util.RuntimeOptions) (_result *UpdateImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.VersionCode)) {
		query["VersionCode"] = request.VersionCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateImage"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateImage(request *UpdateImageRequest) (_result *UpdateImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateImageResponse{}
	_body, _err := client.UpdateImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMessageQueueRouteWithOptions(tmpReq *UpdateMessageQueueRouteRequest, runtime *util.RuntimeOptions) (_result *UpdateMessageQueueRouteResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateMessageQueueRouteShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.FilterSide)) {
		query["FilterSide"] = request.FilterSide
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMessageQueueRoute"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMessageQueueRouteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMessageQueueRoute(request *UpdateMessageQueueRouteRequest) (_result *UpdateMessageQueueRouteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMessageQueueRouteResponse{}
	_body, _err := client.UpdateMessageQueueRouteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMigrationTaskWithOptions(request *UpdateMigrationTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateMigrationTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceAddress)) {
		query["OriginInstanceAddress"] = request.OriginInstanceAddress
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceName)) {
		query["OriginInstanceName"] = request.OriginInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.OriginInstanceNamespace)) {
		query["OriginInstanceNamespace"] = request.OriginInstanceNamespace
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectDesc)) {
		query["ProjectDesc"] = request.ProjectDesc
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterName)) {
		query["TargetClusterName"] = request.TargetClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterUrl)) {
		query["TargetClusterUrl"] = request.TargetClusterUrl
	}

	if !tea.BoolValue(util.IsUnset(request.TargetInstanceId)) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMigrationTask"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMigrationTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMigrationTask(request *UpdateMigrationTaskRequest) (_result *UpdateMigrationTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMigrationTaskResponse{}
	_body, _err := client.UpdateMigrationTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateNacosClusterWithOptions(request *UpdateNacosClusterRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CheckPort)) {
		query["CheckPort"] = request.CheckPort
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.HealthChecker)) {
		query["HealthChecker"] = request.HealthChecker
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.UseInstancePortForCheck)) {
		query["UseInstancePortForCheck"] = request.UseInstancePortForCheck
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateNacosCluster(request *UpdateNacosClusterRequest) (_result *UpdateNacosClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosClusterResponse{}
	_body, _err := client.UpdateNacosClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNacosConfigResponse
 */
func (client *Client) UpdateNacosConfigWithOptions(request *UpdateNacosConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.BetaIps)) {
		query["BetaIps"] = request.BetaIps
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.DataId)) {
		query["DataId"] = request.DataId
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptedDataKey)) {
		query["EncryptedDataKey"] = request.EncryptedDataKey
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Md5)) {
		query["Md5"] = request.Md5
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosConfigRequest
 * @return UpdateNacosConfigResponse
 */
func (client *Client) UpdateNacosConfig(request *UpdateNacosConfigRequest) (_result *UpdateNacosConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosConfigResponse{}
	_body, _err := client.UpdateNacosConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNacosInstanceResponse
 */
func (client *Client) UpdateNacosInstanceWithOptions(request *UpdateNacosInstanceRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.Ephemeral)) {
		query["Ephemeral"] = request.Ephemeral
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Metadata)) {
		body["Metadata"] = request.Metadata
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosInstance"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosInstanceRequest
 * @return UpdateNacosInstanceResponse
 */
func (client *Client) UpdateNacosInstance(request *UpdateNacosInstanceRequest) (_result *UpdateNacosInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosInstanceResponse{}
	_body, _err := client.UpdateNacosInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNacosServiceResponse
 */
func (client *Client) UpdateNacosServiceWithOptions(request *UpdateNacosServiceRequest, runtime *util.RuntimeOptions) (_result *UpdateNacosServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectThreshold)) {
		query["ProtectThreshold"] = request.ProtectThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNacosService"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNacosServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > The operation is not provided in Nacos SDKs. For information about Nacos SDKs, see the [official documentation](https://nacos.io/zh-cn/docs/sdk.html).
 *
 * @param request UpdateNacosServiceRequest
 * @return UpdateNacosServiceResponse
 */
func (client *Client) UpdateNacosService(request *UpdateNacosServiceRequest) (_result *UpdateNacosServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNacosServiceResponse{}
	_body, _err := client.UpdateNacosServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePluginConfigWithOptions(request *UpdatePluginConfigRequest, runtime *util.RuntimeOptions) (_result *UpdatePluginConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigLevel)) {
		query["ConfigLevel"] = request.ConfigLevel
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.GmtCreate)) {
		query["GmtCreate"] = request.GmtCreate
	}

	if !tea.BoolValue(util.IsUnset(request.GmtModified)) {
		query["GmtModified"] = request.GmtModified
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.PluginId)) {
		query["PluginId"] = request.PluginId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePluginConfig"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePluginConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePluginConfig(request *UpdatePluginConfigRequest) (_result *UpdatePluginConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePluginConfigResponse{}
	_body, _err := client.UpdatePluginConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSSLCertWithOptions(request *UpdateSSLCertRequest, runtime *util.RuntimeOptions) (_result *UpdateSSLCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		query["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSSLCert"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSSLCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSSLCert(request *UpdateSSLCertRequest) (_result *UpdateSSLCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSSLCertResponse{}
	_body, _err := client.UpdateSSLCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateServiceSourceWithOptions(tmpReq *UpdateServiceSourceRequest, runtime *util.RuntimeOptions) (_result *UpdateServiceSourceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateServiceSourceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.IngressOptionsRequest)) {
		request.IngressOptionsRequestShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.IngressOptionsRequest, tea.String("IngressOptionsRequest"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.PathList)) {
		request.PathListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.PathList, tea.String("PathList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayId)) {
		query["GatewayId"] = request.GatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.GatewayUniqueId)) {
		query["GatewayUniqueId"] = request.GatewayUniqueId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.IngressOptionsRequestShrink)) {
		query["IngressOptionsRequest"] = request.IngressOptionsRequestShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PathListShrink)) {
		query["PathList"] = request.PathListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateServiceSource"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateServiceSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateServiceSource(request *UpdateServiceSourceRequest) (_result *UpdateServiceSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateServiceSourceResponse{}
	_body, _err := client.UpdateServiceSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateZnodeWithOptions(request *UpdateZnodeRequest, runtime *util.RuntimeOptions) (_result *UpdateZnodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		query["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateZnode"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateZnodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateZnode(request *UpdateZnodeRequest) (_result *UpdateZnodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateZnodeResponse{}
	_body, _err := client.UpdateZnodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpgradeClusterWithOptions(request *UpgradeClusterRequest, runtime *util.RuntimeOptions) (_result *UpgradeClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestPars)) {
		query["RequestPars"] = request.RequestPars
	}

	if !tea.BoolValue(util.IsUnset(request.UpgradeVersion)) {
		query["UpgradeVersion"] = request.UpgradeVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeCluster"),
		Version:     tea.String("2019-05-31"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpgradeCluster(request *UpgradeClusterRequest) (_result *UpgradeClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeClusterResponse{}
	_body, _err := client.UpgradeClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
