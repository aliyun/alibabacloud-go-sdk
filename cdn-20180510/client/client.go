// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddCdnDomainRequest struct {
	// The workload type of the accelerated domain name. Valid values:
	//
	// *   **web**: images and small files
	// *   **download**: large files
	// *   **video**: on-demand video and audio streaming
	CdnType *string `json:"CdnType,omitempty" xml:"CdnType,omitempty"`
	// The URL that is used to check the accessibility of the origin server.
	CheckUrl *string `json:"CheckUrl,omitempty" xml:"CheckUrl,omitempty"`
	// The domain name that you want to add to Alibaba Cloud CDN.
	//
	// A wildcard domain that starts with a period (.) is supported, such as .example.com.
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	//
	// If you do not set this parameter, the system uses the ID of the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The acceleration region. Default value: domestic. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: global (excluding the Chinese mainland)
	// *   **global**: global
	Scope         *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// Details about the tags. You can specify up to 20 tags.
	Tag []*AddCdnDomainRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The top-level domain.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s AddCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *AddCdnDomainRequest) SetCdnType(v string) *AddCdnDomainRequest {
	s.CdnType = &v
	return s
}

func (s *AddCdnDomainRequest) SetCheckUrl(v string) *AddCdnDomainRequest {
	s.CheckUrl = &v
	return s
}

func (s *AddCdnDomainRequest) SetDomainName(v string) *AddCdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *AddCdnDomainRequest) SetOwnerAccount(v string) *AddCdnDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddCdnDomainRequest) SetOwnerId(v int64) *AddCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *AddCdnDomainRequest) SetResourceGroupId(v string) *AddCdnDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddCdnDomainRequest) SetScope(v string) *AddCdnDomainRequest {
	s.Scope = &v
	return s
}

func (s *AddCdnDomainRequest) SetSecurityToken(v string) *AddCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *AddCdnDomainRequest) SetSources(v string) *AddCdnDomainRequest {
	s.Sources = &v
	return s
}

func (s *AddCdnDomainRequest) SetTag(v []*AddCdnDomainRequestTag) *AddCdnDomainRequest {
	s.Tag = v
	return s
}

func (s *AddCdnDomainRequest) SetTopLevelDomain(v string) *AddCdnDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type AddCdnDomainRequestTag struct {
	// The key of the tag. Valid values of N: **1 to 20**.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. Valid values of N: **1 to 20**.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddCdnDomainRequestTag) String() string {
	return tea.Prettify(s)
}

func (s AddCdnDomainRequestTag) GoString() string {
	return s.String()
}

func (s *AddCdnDomainRequestTag) SetKey(v string) *AddCdnDomainRequestTag {
	s.Key = &v
	return s
}

func (s *AddCdnDomainRequestTag) SetValue(v string) *AddCdnDomainRequestTag {
	s.Value = &v
	return s
}

type AddCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddCdnDomainResponseBody) SetRequestId(v string) *AddCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type AddCdnDomainResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *AddCdnDomainResponse) SetHeaders(v map[string]*string) *AddCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *AddCdnDomainResponse) SetStatusCode(v int32) *AddCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddCdnDomainResponse) SetBody(v *AddCdnDomainResponseBody) *AddCdnDomainResponse {
	s.Body = v
	return s
}

type AddFCTriggerRequest struct {
	// The name of the event.
	EventMetaName *string `json:"EventMetaName,omitempty" xml:"EventMetaName,omitempty"`
	// The version of the event.
	EventMetaVersion *string `json:"EventMetaVersion,omitempty" xml:"EventMetaVersion,omitempty"`
	// The feature trigger.
	FunctionARN *string `json:"FunctionARN,omitempty" xml:"FunctionARN,omitempty"`
	// The remarks.
	Notes *string `json:"Notes,omitempty" xml:"Notes,omitempty"`
	// The assigned Resource Access Management (RAM) role.
	RoleARN *string `json:"RoleARN,omitempty" xml:"RoleARN,omitempty"`
	// The resources and filters for event listening.
	SourceARN *string `json:"SourceARN,omitempty" xml:"SourceARN,omitempty"`
	// The trigger that corresponds to the Function Compute service.
	TriggerARN *string `json:"TriggerARN,omitempty" xml:"TriggerARN,omitempty"`
}

func (s AddFCTriggerRequest) String() string {
	return tea.Prettify(s)
}

func (s AddFCTriggerRequest) GoString() string {
	return s.String()
}

func (s *AddFCTriggerRequest) SetEventMetaName(v string) *AddFCTriggerRequest {
	s.EventMetaName = &v
	return s
}

func (s *AddFCTriggerRequest) SetEventMetaVersion(v string) *AddFCTriggerRequest {
	s.EventMetaVersion = &v
	return s
}

func (s *AddFCTriggerRequest) SetFunctionARN(v string) *AddFCTriggerRequest {
	s.FunctionARN = &v
	return s
}

func (s *AddFCTriggerRequest) SetNotes(v string) *AddFCTriggerRequest {
	s.Notes = &v
	return s
}

func (s *AddFCTriggerRequest) SetRoleARN(v string) *AddFCTriggerRequest {
	s.RoleARN = &v
	return s
}

func (s *AddFCTriggerRequest) SetSourceARN(v string) *AddFCTriggerRequest {
	s.SourceARN = &v
	return s
}

func (s *AddFCTriggerRequest) SetTriggerARN(v string) *AddFCTriggerRequest {
	s.TriggerARN = &v
	return s
}

type AddFCTriggerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddFCTriggerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddFCTriggerResponseBody) GoString() string {
	return s.String()
}

func (s *AddFCTriggerResponseBody) SetRequestId(v string) *AddFCTriggerResponseBody {
	s.RequestId = &v
	return s
}

type AddFCTriggerResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddFCTriggerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddFCTriggerResponse) String() string {
	return tea.Prettify(s)
}

func (s AddFCTriggerResponse) GoString() string {
	return s.String()
}

func (s *AddFCTriggerResponse) SetHeaders(v map[string]*string) *AddFCTriggerResponse {
	s.Headers = v
	return s
}

func (s *AddFCTriggerResponse) SetStatusCode(v int32) *AddFCTriggerResponse {
	s.StatusCode = &v
	return s
}

func (s *AddFCTriggerResponse) SetBody(v *AddFCTriggerResponseBody) *AddFCTriggerResponse {
	s.Body = v
	return s
}

type BatchAddCdnDomainRequest struct {
	// The workload type of the domain name to accelerate. Valid values:
	//
	// *   **web**: images and small files
	// *   **download**: large files
	// *   **video**: on-demand video and audio streaming
	CdnType *string `json:"CdnType,omitempty" xml:"CdnType,omitempty"`
	// The URL that is used for health checks.
	CheckUrl *string `json:"CheckUrl,omitempty" xml:"CheckUrl,omitempty"`
	// The domain names that you want to add to Alibaba Cloud CDN. Separate domain names with commas (,).
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. If you do not specify a value for this parameter, the system uses the ID of the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The acceleration region. Default value: domestic. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: global (excluding the Chinese mainland)
	// *   **global**: global
	Scope         *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The top-level domain.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s BatchAddCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchAddCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchAddCdnDomainRequest) SetCdnType(v string) *BatchAddCdnDomainRequest {
	s.CdnType = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetCheckUrl(v string) *BatchAddCdnDomainRequest {
	s.CheckUrl = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetDomainName(v string) *BatchAddCdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetOwnerAccount(v string) *BatchAddCdnDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetOwnerId(v int64) *BatchAddCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetResourceGroupId(v string) *BatchAddCdnDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetScope(v string) *BatchAddCdnDomainRequest {
	s.Scope = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetSecurityToken(v string) *BatchAddCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetSources(v string) *BatchAddCdnDomainRequest {
	s.Sources = &v
	return s
}

func (s *BatchAddCdnDomainRequest) SetTopLevelDomain(v string) *BatchAddCdnDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type BatchAddCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchAddCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchAddCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchAddCdnDomainResponseBody) SetRequestId(v string) *BatchAddCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchAddCdnDomainResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchAddCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchAddCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchAddCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchAddCdnDomainResponse) SetHeaders(v map[string]*string) *BatchAddCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchAddCdnDomainResponse) SetStatusCode(v int32) *BatchAddCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchAddCdnDomainResponse) SetBody(v *BatchAddCdnDomainResponseBody) *BatchAddCdnDomainResponse {
	s.Body = v
	return s
}

type BatchDeleteCdnDomainConfigRequest struct {
	// The accelerated domain names whose configurations you want to delete. Separate multiple accelerated domain names with commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The names of the features that you want to delete. Separate multiple feature names with commas (,). For more information about feature names, see [Parameters for configuring features for domain names](~~388460~~).
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchDeleteCdnDomainConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteCdnDomainConfigRequest) GoString() string {
	return s.String()
}

func (s *BatchDeleteCdnDomainConfigRequest) SetDomainNames(v string) *BatchDeleteCdnDomainConfigRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchDeleteCdnDomainConfigRequest) SetFunctionNames(v string) *BatchDeleteCdnDomainConfigRequest {
	s.FunctionNames = &v
	return s
}

func (s *BatchDeleteCdnDomainConfigRequest) SetOwnerAccount(v string) *BatchDeleteCdnDomainConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchDeleteCdnDomainConfigRequest) SetOwnerId(v int64) *BatchDeleteCdnDomainConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchDeleteCdnDomainConfigRequest) SetSecurityToken(v string) *BatchDeleteCdnDomainConfigRequest {
	s.SecurityToken = &v
	return s
}

type BatchDeleteCdnDomainConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchDeleteCdnDomainConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteCdnDomainConfigResponseBody) GoString() string {
	return s.String()
}

func (s *BatchDeleteCdnDomainConfigResponseBody) SetRequestId(v string) *BatchDeleteCdnDomainConfigResponseBody {
	s.RequestId = &v
	return s
}

type BatchDeleteCdnDomainConfigResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchDeleteCdnDomainConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchDeleteCdnDomainConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteCdnDomainConfigResponse) GoString() string {
	return s.String()
}

func (s *BatchDeleteCdnDomainConfigResponse) SetHeaders(v map[string]*string) *BatchDeleteCdnDomainConfigResponse {
	s.Headers = v
	return s
}

func (s *BatchDeleteCdnDomainConfigResponse) SetStatusCode(v int32) *BatchDeleteCdnDomainConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchDeleteCdnDomainConfigResponse) SetBody(v *BatchDeleteCdnDomainConfigResponseBody) *BatchDeleteCdnDomainConfigResponse {
	s.Body = v
	return s
}

type BatchSetCdnDomainConfigRequest struct {
	// The accelerated domain names. You can specify multiple accelerated domain names and separate them with commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The features that you want to configure. Format:
	//
	// *   **functionName**: the name of the feature. This parameter is required. Separate multiple values with commas (,). For more information, see [Parameters for configuring features for domain names](~~388460~~).
	// *   **argName**: the feature parameter for **functionName**. This parameter is required. You can specify multiple feature parameters.
	// *   **argValue**: the parameter value that is specified for **functionName**. This parameter is required.
	// *   **parentid**: the rule condition ID. This parameter is optional. You can use the **condition** rule engine to create a rule condition. For information, see [Parameters for configuring features for domain names](~~388460~~). A rule condition can identify parameters that are included in requests and filter requests based on the identified parameters. After you create a rule condition, a [configid](~~388994~~) is generated. A configid can be used as parentId that is referenced by other features. This way, you can combine rule conditions and features for flexible configurations.
	//
	// If the **ParentId** parameter is \*\*-1\*\*, the existing rule conditions in the configurations are deleted.
	//
	// ```[{
	//    "functionArgs": [{
	//      "argName": "Parameter A",
	//      "argValue": "Value of parameter A"
	//     },
	//   {
	//     "argName": "Parameter B",
	//     "argValue": "Value of parameter B"
	//      }],
	//  "functionName": "Feature name"
	//  "parentId": Optional. parentId corresponds to configid of the referenced rule condition
	// }]
	// ```
	//
	// The following code provides a sample configuration if **parentId** is not used. In this example, the **origin_request_header** feature is used to add back-to-origin HTTP headers, and the rule condition whose configuration ID is **configid=222728944812032** is referenced.
	//
	// ```[{
	//         "functionArgs": [{
	//             "argName": "header_operation_type",
	//             "argValue": "add"
	//         }, {
	//             "argName": "header_name",
	//             "argValue": "Accept-Encoding"
	//         }, {
	//             "argName": "header_value",
	//             "argValue": "gzip"
	//         }, {
	//             "argName": "duplicate",
	//             "argValue": "off"
	//         }],
	//         "functionName": "origin_request_header"
	// }]
	// ```
	//
	// The following code shows a sample configuration if **parentId** is used. In this example, the **origin_request_header** feature is used to add back-to-origin HTTP headers, and the rule condition whose configuration ID is **222728944812032** is referenced.
	//
	// ```[{
	//         "functionArgs": [{
	//             "argName": "header_operation_type",
	//             "argValue": "add"
	//         }, {
	//             "argName": "header_name",
	//             "argValue": "Accept-Encoding"
	//         }, {
	//             "argName": "header_value",
	//             "argValue": "gzip"
	//         }, {
	//             "argName": "duplicate",
	//             "argValue": "off"
	//         }],
	//         "functionName": "origin_request_header",
	//         "parentId": 222728944812032
	// }]
	// ```
	//
	// The following code provides a sample configuration that deletes the reference to **parentId** for a feature that uses **parentId**. This example shows how to delete the rule condition that has a configuration ID of **222728944812032** and is referenced when **origin_request_header** feature is used to add back-to-origin HTTP headers.
	//
	// ```[{
	//         "functionArgs": [{
	//             "argName": "header_operation_type",
	//             "argValue": "add"
	//         }, {
	//             "argName": "header_name",
	//             "argValue": "Accept-Encoding"
	//         }, {
	//             "argName": "header_value",
	//             "argValue": "gzip"
	//         }, {
	//             "argName": "duplicate",
	//             "argValue": "off"
	//         }],
	//         "functionName": "origin_request_header",
	//         "parentId": -1
	// }]
	// ```
	Functions     *string `json:"Functions,omitempty" xml:"Functions,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchSetCdnDomainConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainConfigRequest) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainConfigRequest) SetDomainNames(v string) *BatchSetCdnDomainConfigRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchSetCdnDomainConfigRequest) SetFunctions(v string) *BatchSetCdnDomainConfigRequest {
	s.Functions = &v
	return s
}

func (s *BatchSetCdnDomainConfigRequest) SetOwnerAccount(v string) *BatchSetCdnDomainConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchSetCdnDomainConfigRequest) SetOwnerId(v int64) *BatchSetCdnDomainConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchSetCdnDomainConfigRequest) SetSecurityToken(v string) *BatchSetCdnDomainConfigRequest {
	s.SecurityToken = &v
	return s
}

type BatchSetCdnDomainConfigResponseBody struct {
	// The list of domain configurations.
	DomainConfigList *BatchSetCdnDomainConfigResponseBodyDomainConfigList `json:"DomainConfigList,omitempty" xml:"DomainConfigList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetCdnDomainConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainConfigResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainConfigResponseBody) SetDomainConfigList(v *BatchSetCdnDomainConfigResponseBodyDomainConfigList) *BatchSetCdnDomainConfigResponseBody {
	s.DomainConfigList = v
	return s
}

func (s *BatchSetCdnDomainConfigResponseBody) SetRequestId(v string) *BatchSetCdnDomainConfigResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetCdnDomainConfigResponseBodyDomainConfigList struct {
	DomainConfigModel []*BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel `json:"DomainConfigModel,omitempty" xml:"DomainConfigModel,omitempty" type:"Repeated"`
}

func (s BatchSetCdnDomainConfigResponseBodyDomainConfigList) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainConfigResponseBodyDomainConfigList) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainConfigResponseBodyDomainConfigList) SetDomainConfigModel(v []*BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel) *BatchSetCdnDomainConfigResponseBodyDomainConfigList {
	s.DomainConfigModel = v
	return s
}

type BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel struct {
	// The ID of the configuration.
	ConfigId *int64 `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel) SetConfigId(v int64) *BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel {
	s.ConfigId = &v
	return s
}

func (s *BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel) SetDomainName(v string) *BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel {
	s.DomainName = &v
	return s
}

func (s *BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel) SetFunctionName(v string) *BatchSetCdnDomainConfigResponseBodyDomainConfigListDomainConfigModel {
	s.FunctionName = &v
	return s
}

type BatchSetCdnDomainConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetCdnDomainConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetCdnDomainConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainConfigResponse) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainConfigResponse) SetHeaders(v map[string]*string) *BatchSetCdnDomainConfigResponse {
	s.Headers = v
	return s
}

func (s *BatchSetCdnDomainConfigResponse) SetStatusCode(v int32) *BatchSetCdnDomainConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetCdnDomainConfigResponse) SetBody(v *BatchSetCdnDomainConfigResponseBody) *BatchSetCdnDomainConfigResponse {
	s.Body = v
	return s
}

type BatchSetCdnDomainServerCertificateRequest struct {
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The type of the certificate. Valid values:
	//
	// *   **upload**: a user-uploaded SSL certificate.
	// *   **cas**: a certificate that is acquired through Certificate Management Service.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The accelerated domain name to which the SSL certificate belongs. The type of request supported by the accelerated domain name must be HTTPS. You can specify multiple accelerated domain names and separate them with commas (,).
	//
	// >You can configure up to 10 domain names at a time.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// Specifies whether to check the certificate name for duplicates. If you set the value to 1, the system does not perform the check and overwrites the information about the existing certificate that uses the same name.
	ForceSet *string `json:"ForceSet,omitempty" xml:"ForceSet,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The private key. Specify the private key only if you want to enable the SSL certificate.
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the SSL certificate. Default value: off. Valid values:
	//
	// *   **on** ：enables the SSL certificate.
	// *   **off**：disables the SSL certificate
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The content of the SSL certificate. Specify the content of the SSL certificate only if you want to enable the SSL certificate.
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchSetCdnDomainServerCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainServerCertificateRequest) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetCertName(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.CertName = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetCertType(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.CertType = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetDomainName(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetForceSet(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.ForceSet = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetOwnerId(v int64) *BatchSetCdnDomainServerCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetRegion(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.Region = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetSSLPri(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetSSLProtocol(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetSSLPub(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateRequest) SetSecurityToken(v string) *BatchSetCdnDomainServerCertificateRequest {
	s.SecurityToken = &v
	return s
}

type BatchSetCdnDomainServerCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetCdnDomainServerCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainServerCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainServerCertificateResponseBody) SetRequestId(v string) *BatchSetCdnDomainServerCertificateResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetCdnDomainServerCertificateResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetCdnDomainServerCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetCdnDomainServerCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetCdnDomainServerCertificateResponse) GoString() string {
	return s.String()
}

func (s *BatchSetCdnDomainServerCertificateResponse) SetHeaders(v map[string]*string) *BatchSetCdnDomainServerCertificateResponse {
	s.Headers = v
	return s
}

func (s *BatchSetCdnDomainServerCertificateResponse) SetStatusCode(v int32) *BatchSetCdnDomainServerCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetCdnDomainServerCertificateResponse) SetBody(v *BatchSetCdnDomainServerCertificateResponseBody) *BatchSetCdnDomainServerCertificateResponse {
	s.Body = v
	return s
}

type BatchStartCdnDomainRequest struct {
	// The accelerated domain names. You can specify one or more domain names. Separate multiple domain names with commas (,).
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStartCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStartCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStartCdnDomainRequest) SetDomainNames(v string) *BatchStartCdnDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStartCdnDomainRequest) SetOwnerId(v int64) *BatchStartCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStartCdnDomainRequest) SetSecurityToken(v string) *BatchStartCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStartCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStartCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStartCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStartCdnDomainResponseBody) SetRequestId(v string) *BatchStartCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStartCdnDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchStartCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchStartCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStartCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStartCdnDomainResponse) SetHeaders(v map[string]*string) *BatchStartCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStartCdnDomainResponse) SetStatusCode(v int32) *BatchStartCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStartCdnDomainResponse) SetBody(v *BatchStartCdnDomainResponseBody) *BatchStartCdnDomainResponse {
	s.Body = v
	return s
}

type BatchStopCdnDomainRequest struct {
	// The names of the accelerated domain names. You can specify one or more domain names in each request. Separate multiple domain names with commas (,).
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStopCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStopCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStopCdnDomainRequest) SetDomainNames(v string) *BatchStopCdnDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStopCdnDomainRequest) SetOwnerId(v int64) *BatchStopCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStopCdnDomainRequest) SetSecurityToken(v string) *BatchStopCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStopCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStopCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStopCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStopCdnDomainResponseBody) SetRequestId(v string) *BatchStopCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStopCdnDomainResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchStopCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchStopCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStopCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStopCdnDomainResponse) SetHeaders(v map[string]*string) *BatchStopCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStopCdnDomainResponse) SetStatusCode(v int32) *BatchStopCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStopCdnDomainResponse) SetBody(v *BatchStopCdnDomainResponseBody) *BatchStopCdnDomainResponse {
	s.Body = v
	return s
}

type BatchUpdateCdnDomainRequest struct {
	// The accelerated domain names. You can specify one or more accelerated domain names. Separate domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	//
	// > Do not set **Sources** and **TopLevelDomain** at the same time. If you set **Sources** and **TopLevelDomain** at the same time, **TopLevelDomain** does not take effect.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The root domain.
	//
	// > Do not set **Sources** and **TopLevelDomain** at the same time. If you set **Sources** and **TopLevelDomain** at the same time, **TopLevelDomain** does not take effect.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s BatchUpdateCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchUpdateCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchUpdateCdnDomainRequest) SetDomainName(v string) *BatchUpdateCdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *BatchUpdateCdnDomainRequest) SetOwnerId(v int64) *BatchUpdateCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchUpdateCdnDomainRequest) SetResourceGroupId(v string) *BatchUpdateCdnDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *BatchUpdateCdnDomainRequest) SetSecurityToken(v string) *BatchUpdateCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *BatchUpdateCdnDomainRequest) SetSources(v string) *BatchUpdateCdnDomainRequest {
	s.Sources = &v
	return s
}

func (s *BatchUpdateCdnDomainRequest) SetTopLevelDomain(v string) *BatchUpdateCdnDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type BatchUpdateCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchUpdateCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchUpdateCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchUpdateCdnDomainResponseBody) SetRequestId(v string) *BatchUpdateCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchUpdateCdnDomainResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchUpdateCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchUpdateCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchUpdateCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchUpdateCdnDomainResponse) SetHeaders(v map[string]*string) *BatchUpdateCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchUpdateCdnDomainResponse) SetStatusCode(v int32) *BatchUpdateCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchUpdateCdnDomainResponse) SetBody(v *BatchUpdateCdnDomainResponseBody) *BatchUpdateCdnDomainResponse {
	s.Body = v
	return s
}

type CreateCdnCertificateSigningRequestRequest struct {
	// The city. Default value: Hangzhou.
	City *string `json:"City,omitempty" xml:"City,omitempty"`
	// The Common Name of the certificate.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The country or region in which the organization is located. Default value: CN.
	Country *string `json:"Country,omitempty" xml:"Country,omitempty"`
	// The email address.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The name of the organization. Default value: Alibaba Inc.
	Organization *string `json:"Organization,omitempty" xml:"Organization,omitempty"`
	// The name of the department. Default value: Aliyun CDN.
	OrganizationUnit *string `json:"OrganizationUnit,omitempty" xml:"OrganizationUnit,omitempty"`
	// The Subject Alternative Name (SAN) extension of the SSL certificate. This extension is used to add domain names to the certificate. Separate multiple domain names with commas (,).
	SANs *string `json:"SANs,omitempty" xml:"SANs,omitempty"`
	// The provincial district. Default value: Zhejiang.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s CreateCdnCertificateSigningRequestRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnCertificateSigningRequestRequest) GoString() string {
	return s.String()
}

func (s *CreateCdnCertificateSigningRequestRequest) SetCity(v string) *CreateCdnCertificateSigningRequestRequest {
	s.City = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestRequest) SetCommonName(v string) *CreateCdnCertificateSigningRequestRequest {
	s.CommonName = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestRequest) SetCountry(v string) *CreateCdnCertificateSigningRequestRequest {
	s.Country = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestRequest) SetEmail(v string) *CreateCdnCertificateSigningRequestRequest {
	s.Email = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestRequest) SetOrganization(v string) *CreateCdnCertificateSigningRequestRequest {
	s.Organization = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestRequest) SetOrganizationUnit(v string) *CreateCdnCertificateSigningRequestRequest {
	s.OrganizationUnit = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestRequest) SetSANs(v string) *CreateCdnCertificateSigningRequestRequest {
	s.SANs = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestRequest) SetState(v string) *CreateCdnCertificateSigningRequestRequest {
	s.State = &v
	return s
}

type CreateCdnCertificateSigningRequestResponseBody struct {
	// The Common Name of the certificate.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The content of the CSR file.
	Csr *string `json:"Csr,omitempty" xml:"Csr,omitempty"`
	// The MD5 hash value of the certificate public key.
	PubMd5 *string `json:"PubMd5,omitempty" xml:"PubMd5,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCdnCertificateSigningRequestResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnCertificateSigningRequestResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCdnCertificateSigningRequestResponseBody) SetCommonName(v string) *CreateCdnCertificateSigningRequestResponseBody {
	s.CommonName = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestResponseBody) SetCsr(v string) *CreateCdnCertificateSigningRequestResponseBody {
	s.Csr = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestResponseBody) SetPubMd5(v string) *CreateCdnCertificateSigningRequestResponseBody {
	s.PubMd5 = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestResponseBody) SetRequestId(v string) *CreateCdnCertificateSigningRequestResponseBody {
	s.RequestId = &v
	return s
}

type CreateCdnCertificateSigningRequestResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCdnCertificateSigningRequestResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCdnCertificateSigningRequestResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnCertificateSigningRequestResponse) GoString() string {
	return s.String()
}

func (s *CreateCdnCertificateSigningRequestResponse) SetHeaders(v map[string]*string) *CreateCdnCertificateSigningRequestResponse {
	s.Headers = v
	return s
}

func (s *CreateCdnCertificateSigningRequestResponse) SetStatusCode(v int32) *CreateCdnCertificateSigningRequestResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCdnCertificateSigningRequestResponse) SetBody(v *CreateCdnCertificateSigningRequestResponseBody) *CreateCdnCertificateSigningRequestResponse {
	s.Body = v
	return s
}

type CreateCdnDeliverTaskRequest struct {
	// The method that is used to send operations reports. Operations reports are sent to you only by email. The settings must be escaped in JSON.
	Deliver *string `json:"Deliver,omitempty" xml:"Deliver,omitempty"`
	// The domain names to be tracked. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
	//
	// > If you do not specify a domain name, the tracking task is created for all domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the tracking task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The operations reports that are tracked by the task. The data must be escaped in JSON.
	Reports *string `json:"Reports,omitempty" xml:"Reports,omitempty"`
	// The parameters that specify the time interval at which the tracking task sends operations reports. The settings must be escaped in JSON.
	Schedule *string `json:"Schedule,omitempty" xml:"Schedule,omitempty"`
}

func (s CreateCdnDeliverTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnDeliverTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateCdnDeliverTaskRequest) SetDeliver(v string) *CreateCdnDeliverTaskRequest {
	s.Deliver = &v
	return s
}

func (s *CreateCdnDeliverTaskRequest) SetDomainName(v string) *CreateCdnDeliverTaskRequest {
	s.DomainName = &v
	return s
}

func (s *CreateCdnDeliverTaskRequest) SetName(v string) *CreateCdnDeliverTaskRequest {
	s.Name = &v
	return s
}

func (s *CreateCdnDeliverTaskRequest) SetReports(v string) *CreateCdnDeliverTaskRequest {
	s.Reports = &v
	return s
}

func (s *CreateCdnDeliverTaskRequest) SetSchedule(v string) *CreateCdnDeliverTaskRequest {
	s.Schedule = &v
	return s
}

type CreateCdnDeliverTaskResponseBody struct {
	// The ID of the tracking task.
	DeliverId *string `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCdnDeliverTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnDeliverTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCdnDeliverTaskResponseBody) SetDeliverId(v string) *CreateCdnDeliverTaskResponseBody {
	s.DeliverId = &v
	return s
}

func (s *CreateCdnDeliverTaskResponseBody) SetRequestId(v string) *CreateCdnDeliverTaskResponseBody {
	s.RequestId = &v
	return s
}

type CreateCdnDeliverTaskResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCdnDeliverTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCdnDeliverTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnDeliverTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateCdnDeliverTaskResponse) SetHeaders(v map[string]*string) *CreateCdnDeliverTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateCdnDeliverTaskResponse) SetStatusCode(v int32) *CreateCdnDeliverTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCdnDeliverTaskResponse) SetBody(v *CreateCdnDeliverTaskResponseBody) *CreateCdnDeliverTaskResponse {
	s.Body = v
	return s
}

type CreateCdnSubTaskRequest struct {
	// The domain names to be tracked. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
	//
	// > If you do not specify a domain name, the custom operations report is created for all domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The IDs of the metrics that you want to include in the report. Separate multiple IDs with commas (,). Valid values:
	//
	// *   **1**: frequently requested URLs (ranked by the number of requests)
	// *   **3**: frequently requested URLs (ranked by the amount of network traffic)
	// *   **5**: frequently used Referer headers (ranked by the number of requests)
	// *   **7**: frequently used Referer headers (ranked by the amount of network traffic)
	// *   **9**: frequently requested URLs that are redirected to the origin (ranked by the number of requests)
	// *   **11**: frequently requested URLs that are redirected to the origin (ranked by the amount of network traffic)
	// *   **13**: top client IP addresses (ranked by the number of requests)
	// *   **15**: top client IP addresses (ranked by the amount of network traffic)
	// *   **17**: domain names ranked by the amount of network traffic
	// *   **19**: page views and unique visitors
	// *   **21**: regions from which requests are initiated
	// *   **23**: Internet service providers (ISPs)
	ReportIds *string `json:"ReportIds,omitempty" xml:"ReportIds,omitempty"`
}

func (s CreateCdnSubTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnSubTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateCdnSubTaskRequest) SetDomainName(v string) *CreateCdnSubTaskRequest {
	s.DomainName = &v
	return s
}

func (s *CreateCdnSubTaskRequest) SetReportIds(v string) *CreateCdnSubTaskRequest {
	s.ReportIds = &v
	return s
}

type CreateCdnSubTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCdnSubTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCdnSubTaskResponseBody) SetRequestId(v string) *CreateCdnSubTaskResponseBody {
	s.RequestId = &v
	return s
}

type CreateCdnSubTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCdnSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCdnSubTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCdnSubTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateCdnSubTaskResponse) SetHeaders(v map[string]*string) *CreateCdnSubTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateCdnSubTaskResponse) SetStatusCode(v int32) *CreateCdnSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCdnSubTaskResponse) SetBody(v *CreateCdnSubTaskResponseBody) *CreateCdnSubTaskResponse {
	s.Body = v
	return s
}

type CreateRealTimeLogDeliveryRequest struct {
	// The accelerated domain name for which you want to configure real-time log delivery.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The name of the Logstore where log entries are stored.
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The ID of the region where the Log Service project is deployed. For more information, see [Regions that support real-time log delivery](~~144883~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s CreateRealTimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRealTimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *CreateRealTimeLogDeliveryRequest) SetDomain(v string) *CreateRealTimeLogDeliveryRequest {
	s.Domain = &v
	return s
}

func (s *CreateRealTimeLogDeliveryRequest) SetLogstore(v string) *CreateRealTimeLogDeliveryRequest {
	s.Logstore = &v
	return s
}

func (s *CreateRealTimeLogDeliveryRequest) SetProject(v string) *CreateRealTimeLogDeliveryRequest {
	s.Project = &v
	return s
}

func (s *CreateRealTimeLogDeliveryRequest) SetRegion(v string) *CreateRealTimeLogDeliveryRequest {
	s.Region = &v
	return s
}

type CreateRealTimeLogDeliveryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateRealTimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRealTimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRealTimeLogDeliveryResponseBody) SetRequestId(v string) *CreateRealTimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type CreateRealTimeLogDeliveryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRealTimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRealTimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRealTimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *CreateRealTimeLogDeliveryResponse) SetHeaders(v map[string]*string) *CreateRealTimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *CreateRealTimeLogDeliveryResponse) SetStatusCode(v int32) *CreateRealTimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRealTimeLogDeliveryResponse) SetBody(v *CreateRealTimeLogDeliveryResponseBody) *CreateRealTimeLogDeliveryResponse {
	s.Body = v
	return s
}

type CreateUsageDetailDataExportTaskRequest struct {
	// The domain names. If you do not specify the Group parameter, resource usage details of these domain names are exported.
	//
	// If you do not specify this parameter, resource usage details are exported based on accounts.
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The domain name group. If you specify this parameter, the **DomainNames** parameter is ignored.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The language in which you want to export the file. Valid values:
	//
	// *   **zh-cn**: Chinese. This is the default value.
	// *   **en-us**: English
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	// The type of resource usage data to query. Valid values:
	//
	// *   **flow**: traffic and bandwidth
	// *   **vas**: requests
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateUsageDetailDataExportTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUsageDetailDataExportTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateUsageDetailDataExportTaskRequest) SetDomainNames(v string) *CreateUsageDetailDataExportTaskRequest {
	s.DomainNames = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskRequest) SetEndTime(v string) *CreateUsageDetailDataExportTaskRequest {
	s.EndTime = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskRequest) SetGroup(v string) *CreateUsageDetailDataExportTaskRequest {
	s.Group = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskRequest) SetLanguage(v string) *CreateUsageDetailDataExportTaskRequest {
	s.Language = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskRequest) SetStartTime(v string) *CreateUsageDetailDataExportTaskRequest {
	s.StartTime = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskRequest) SetTaskName(v string) *CreateUsageDetailDataExportTaskRequest {
	s.TaskName = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskRequest) SetType(v string) *CreateUsageDetailDataExportTaskRequest {
	s.Type = &v
	return s
}

type CreateUsageDetailDataExportTaskResponseBody struct {
	// The end of the time range for which the data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range for which the data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateUsageDetailDataExportTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUsageDetailDataExportTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUsageDetailDataExportTaskResponseBody) SetEndTime(v string) *CreateUsageDetailDataExportTaskResponseBody {
	s.EndTime = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskResponseBody) SetRequestId(v string) *CreateUsageDetailDataExportTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskResponseBody) SetStartTime(v string) *CreateUsageDetailDataExportTaskResponseBody {
	s.StartTime = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskResponseBody) SetTaskId(v string) *CreateUsageDetailDataExportTaskResponseBody {
	s.TaskId = &v
	return s
}

type CreateUsageDetailDataExportTaskResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateUsageDetailDataExportTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUsageDetailDataExportTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUsageDetailDataExportTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateUsageDetailDataExportTaskResponse) SetHeaders(v map[string]*string) *CreateUsageDetailDataExportTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateUsageDetailDataExportTaskResponse) SetStatusCode(v int32) *CreateUsageDetailDataExportTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUsageDetailDataExportTaskResponse) SetBody(v *CreateUsageDetailDataExportTaskResponseBody) *CreateUsageDetailDataExportTaskResponse {
	s.Body = v
	return s
}

type CreateUserUsageDataExportTaskRequest struct {
	// The end of the time range to query. The end time must be later than the start time.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The language in which you want to export the file. Default value: zh-cn. Valid values:
	//
	// *   **zh-cn**: Chinese
	// *   **en-us**: English
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The start of the time range to query. The data is collected every 5 minutes.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s CreateUserUsageDataExportTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUserUsageDataExportTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateUserUsageDataExportTaskRequest) SetEndTime(v string) *CreateUserUsageDataExportTaskRequest {
	s.EndTime = &v
	return s
}

func (s *CreateUserUsageDataExportTaskRequest) SetLanguage(v string) *CreateUserUsageDataExportTaskRequest {
	s.Language = &v
	return s
}

func (s *CreateUserUsageDataExportTaskRequest) SetStartTime(v string) *CreateUserUsageDataExportTaskRequest {
	s.StartTime = &v
	return s
}

func (s *CreateUserUsageDataExportTaskRequest) SetTaskName(v string) *CreateUserUsageDataExportTaskRequest {
	s.TaskName = &v
	return s
}

type CreateUserUsageDataExportTaskResponseBody struct {
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateUserUsageDataExportTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUserUsageDataExportTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUserUsageDataExportTaskResponseBody) SetEndTime(v string) *CreateUserUsageDataExportTaskResponseBody {
	s.EndTime = &v
	return s
}

func (s *CreateUserUsageDataExportTaskResponseBody) SetRequestId(v string) *CreateUserUsageDataExportTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUserUsageDataExportTaskResponseBody) SetStartTime(v string) *CreateUserUsageDataExportTaskResponseBody {
	s.StartTime = &v
	return s
}

func (s *CreateUserUsageDataExportTaskResponseBody) SetTaskId(v string) *CreateUserUsageDataExportTaskResponseBody {
	s.TaskId = &v
	return s
}

type CreateUserUsageDataExportTaskResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateUserUsageDataExportTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUserUsageDataExportTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUserUsageDataExportTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateUserUsageDataExportTaskResponse) SetHeaders(v map[string]*string) *CreateUserUsageDataExportTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateUserUsageDataExportTaskResponse) SetStatusCode(v int32) *CreateUserUsageDataExportTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUserUsageDataExportTaskResponse) SetBody(v *CreateUserUsageDataExportTaskResponseBody) *CreateUserUsageDataExportTaskResponse {
	s.Body = v
	return s
}

type DeleteCdnDeliverTaskRequest struct {
	// The ID of the tracking task that you want to delete. You can call the [DescribeCdnDeliverList](~~270877~~) operation to query task IDs.
	DeliverId *int64 `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
}

func (s DeleteCdnDeliverTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnDeliverTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteCdnDeliverTaskRequest) SetDeliverId(v int64) *DeleteCdnDeliverTaskRequest {
	s.DeliverId = &v
	return s
}

type DeleteCdnDeliverTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCdnDeliverTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnDeliverTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCdnDeliverTaskResponseBody) SetRequestId(v string) *DeleteCdnDeliverTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCdnDeliverTaskResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCdnDeliverTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCdnDeliverTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnDeliverTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteCdnDeliverTaskResponse) SetHeaders(v map[string]*string) *DeleteCdnDeliverTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteCdnDeliverTaskResponse) SetStatusCode(v int32) *DeleteCdnDeliverTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCdnDeliverTaskResponse) SetBody(v *DeleteCdnDeliverTaskResponseBody) *DeleteCdnDeliverTaskResponse {
	s.Body = v
	return s
}

type DeleteCdnDomainRequest struct {
	// The accelerated domain name that you want to remove. You can specify only one domain name in each call.
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s DeleteCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteCdnDomainRequest) SetDomainName(v string) *DeleteCdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteCdnDomainRequest) SetOwnerAccount(v string) *DeleteCdnDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCdnDomainRequest) SetOwnerId(v int64) *DeleteCdnDomainRequest {
	s.OwnerId = &v
	return s
}

type DeleteCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCdnDomainResponseBody) SetRequestId(v string) *DeleteCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCdnDomainResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteCdnDomainResponse) SetHeaders(v map[string]*string) *DeleteCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteCdnDomainResponse) SetStatusCode(v int32) *DeleteCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCdnDomainResponse) SetBody(v *DeleteCdnDomainResponseBody) *DeleteCdnDomainResponse {
	s.Body = v
	return s
}

type DeleteCdnSubTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCdnSubTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCdnSubTaskResponseBody) SetRequestId(v string) *DeleteCdnSubTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCdnSubTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCdnSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCdnSubTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdnSubTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteCdnSubTaskResponse) SetHeaders(v map[string]*string) *DeleteCdnSubTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteCdnSubTaskResponse) SetStatusCode(v int32) *DeleteCdnSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCdnSubTaskResponse) SetBody(v *DeleteCdnSubTaskResponseBody) *DeleteCdnSubTaskResponse {
	s.Body = v
	return s
}

type DeleteFCTriggerRequest struct {
	// The trigger that corresponds to the Function Compute service.
	TriggerARN *string `json:"TriggerARN,omitempty" xml:"TriggerARN,omitempty"`
}

func (s DeleteFCTriggerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFCTriggerRequest) GoString() string {
	return s.String()
}

func (s *DeleteFCTriggerRequest) SetTriggerARN(v string) *DeleteFCTriggerRequest {
	s.TriggerARN = &v
	return s
}

type DeleteFCTriggerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteFCTriggerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFCTriggerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFCTriggerResponseBody) SetRequestId(v string) *DeleteFCTriggerResponseBody {
	s.RequestId = &v
	return s
}

type DeleteFCTriggerResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteFCTriggerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteFCTriggerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFCTriggerResponse) GoString() string {
	return s.String()
}

func (s *DeleteFCTriggerResponse) SetHeaders(v map[string]*string) *DeleteFCTriggerResponse {
	s.Headers = v
	return s
}

func (s *DeleteFCTriggerResponse) SetStatusCode(v int32) *DeleteFCTriggerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFCTriggerResponse) SetBody(v *DeleteFCTriggerResponseBody) *DeleteFCTriggerResponse {
	s.Body = v
	return s
}

type DeleteRealTimeLogLogstoreRequest struct {
	// The name of the Logstore to which log entries are delivered.
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The ID of the region where the Log Service project is deployed. For more information, see [Regions that support real-time log delivery](~~144883~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s DeleteRealTimeLogLogstoreRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRealTimeLogLogstoreRequest) GoString() string {
	return s.String()
}

func (s *DeleteRealTimeLogLogstoreRequest) SetLogstore(v string) *DeleteRealTimeLogLogstoreRequest {
	s.Logstore = &v
	return s
}

func (s *DeleteRealTimeLogLogstoreRequest) SetProject(v string) *DeleteRealTimeLogLogstoreRequest {
	s.Project = &v
	return s
}

func (s *DeleteRealTimeLogLogstoreRequest) SetRegion(v string) *DeleteRealTimeLogLogstoreRequest {
	s.Region = &v
	return s
}

type DeleteRealTimeLogLogstoreResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRealTimeLogLogstoreResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRealTimeLogLogstoreResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRealTimeLogLogstoreResponseBody) SetRequestId(v string) *DeleteRealTimeLogLogstoreResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRealTimeLogLogstoreResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRealTimeLogLogstoreResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRealTimeLogLogstoreResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRealTimeLogLogstoreResponse) GoString() string {
	return s.String()
}

func (s *DeleteRealTimeLogLogstoreResponse) SetHeaders(v map[string]*string) *DeleteRealTimeLogLogstoreResponse {
	s.Headers = v
	return s
}

func (s *DeleteRealTimeLogLogstoreResponse) SetStatusCode(v int32) *DeleteRealTimeLogLogstoreResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRealTimeLogLogstoreResponse) SetBody(v *DeleteRealTimeLogLogstoreResponseBody) *DeleteRealTimeLogLogstoreResponse {
	s.Body = v
	return s
}

type DeleteRealtimeLogDeliveryRequest struct {
	// The acceleration domain name for which you want to disable real-time log delivery. You can specify multiple domain names and separate them with commas (,).
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The name of the Logstore where log entries are stored.
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The ID of the region where the Log Service project is deployed. For more information, see [Regions that support real-time log delivery](~~144883~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s DeleteRealtimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRealtimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *DeleteRealtimeLogDeliveryRequest) SetDomain(v string) *DeleteRealtimeLogDeliveryRequest {
	s.Domain = &v
	return s
}

func (s *DeleteRealtimeLogDeliveryRequest) SetLogstore(v string) *DeleteRealtimeLogDeliveryRequest {
	s.Logstore = &v
	return s
}

func (s *DeleteRealtimeLogDeliveryRequest) SetProject(v string) *DeleteRealtimeLogDeliveryRequest {
	s.Project = &v
	return s
}

func (s *DeleteRealtimeLogDeliveryRequest) SetRegion(v string) *DeleteRealtimeLogDeliveryRequest {
	s.Region = &v
	return s
}

type DeleteRealtimeLogDeliveryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRealtimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRealtimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRealtimeLogDeliveryResponseBody) SetRequestId(v string) *DeleteRealtimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRealtimeLogDeliveryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRealtimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRealtimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRealtimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *DeleteRealtimeLogDeliveryResponse) SetHeaders(v map[string]*string) *DeleteRealtimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *DeleteRealtimeLogDeliveryResponse) SetStatusCode(v int32) *DeleteRealtimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRealtimeLogDeliveryResponse) SetBody(v *DeleteRealtimeLogDeliveryResponseBody) *DeleteRealtimeLogDeliveryResponse {
	s.Body = v
	return s
}

type DeleteSpecificConfigRequest struct {
	// The ID of the configuration. Separate multiple configuration IDs with commas (,). For more information about ConfigId, see [Usage notes on ConfigId](~~388994~~).
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. You can specify only one domain name.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteSpecificConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpecificConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteSpecificConfigRequest) SetConfigId(v string) *DeleteSpecificConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *DeleteSpecificConfigRequest) SetDomainName(v string) *DeleteSpecificConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteSpecificConfigRequest) SetOwnerId(v int64) *DeleteSpecificConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteSpecificConfigRequest) SetSecurityToken(v string) *DeleteSpecificConfigRequest {
	s.SecurityToken = &v
	return s
}

type DeleteSpecificConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSpecificConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpecificConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSpecificConfigResponseBody) SetRequestId(v string) *DeleteSpecificConfigResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSpecificConfigResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSpecificConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSpecificConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpecificConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteSpecificConfigResponse) SetHeaders(v map[string]*string) *DeleteSpecificConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteSpecificConfigResponse) SetStatusCode(v int32) *DeleteSpecificConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSpecificConfigResponse) SetBody(v *DeleteSpecificConfigResponseBody) *DeleteSpecificConfigResponse {
	s.Body = v
	return s
}

type DeleteSpecificStagingConfigRequest struct {
	// The configuration IDs. Separate configuration IDs with commas (,). For more information about ConfigId, see [Usage notes on ConfigId](~~388994~~).
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. You can specify up to 50 domain names in each request. Separate multiple domain names with commas (,).
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteSpecificStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpecificStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteSpecificStagingConfigRequest) SetConfigId(v string) *DeleteSpecificStagingConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *DeleteSpecificStagingConfigRequest) SetDomainName(v string) *DeleteSpecificStagingConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteSpecificStagingConfigRequest) SetOwnerId(v int64) *DeleteSpecificStagingConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteSpecificStagingConfigRequest) SetSecurityToken(v string) *DeleteSpecificStagingConfigRequest {
	s.SecurityToken = &v
	return s
}

type DeleteSpecificStagingConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSpecificStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpecificStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSpecificStagingConfigResponseBody) SetRequestId(v string) *DeleteSpecificStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSpecificStagingConfigResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSpecificStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSpecificStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpecificStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteSpecificStagingConfigResponse) SetHeaders(v map[string]*string) *DeleteSpecificStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteSpecificStagingConfigResponse) SetStatusCode(v int32) *DeleteSpecificStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSpecificStagingConfigResponse) SetBody(v *DeleteSpecificStagingConfigResponseBody) *DeleteSpecificStagingConfigResponse {
	s.Body = v
	return s
}

type DeleteUsageDetailDataExportTaskRequest struct {
	// The ID of the task. You can call the [DescribeUserUsageDataExportTask](~~91062~~) operation to query tasks.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DeleteUsageDetailDataExportTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteUsageDetailDataExportTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteUsageDetailDataExportTaskRequest) SetTaskId(v string) *DeleteUsageDetailDataExportTaskRequest {
	s.TaskId = &v
	return s
}

type DeleteUsageDetailDataExportTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteUsageDetailDataExportTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteUsageDetailDataExportTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteUsageDetailDataExportTaskResponseBody) SetRequestId(v string) *DeleteUsageDetailDataExportTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteUsageDetailDataExportTaskResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteUsageDetailDataExportTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteUsageDetailDataExportTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteUsageDetailDataExportTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteUsageDetailDataExportTaskResponse) SetHeaders(v map[string]*string) *DeleteUsageDetailDataExportTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteUsageDetailDataExportTaskResponse) SetStatusCode(v int32) *DeleteUsageDetailDataExportTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteUsageDetailDataExportTaskResponse) SetBody(v *DeleteUsageDetailDataExportTaskResponseBody) *DeleteUsageDetailDataExportTaskResponse {
	s.Body = v
	return s
}

type DeleteUserUsageDataExportTaskRequest struct {
	// The ID of the task to delete.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DeleteUserUsageDataExportTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserUsageDataExportTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteUserUsageDataExportTaskRequest) SetTaskId(v string) *DeleteUserUsageDataExportTaskRequest {
	s.TaskId = &v
	return s
}

type DeleteUserUsageDataExportTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteUserUsageDataExportTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserUsageDataExportTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteUserUsageDataExportTaskResponseBody) SetRequestId(v string) *DeleteUserUsageDataExportTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteUserUsageDataExportTaskResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteUserUsageDataExportTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteUserUsageDataExportTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserUsageDataExportTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteUserUsageDataExportTaskResponse) SetHeaders(v map[string]*string) *DeleteUserUsageDataExportTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteUserUsageDataExportTaskResponse) SetStatusCode(v int32) *DeleteUserUsageDataExportTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteUserUsageDataExportTaskResponse) SetBody(v *DeleteUserUsageDataExportTaskResponseBody) *DeleteUserUsageDataExportTaskResponse {
	s.Body = v
	return s
}

type DescribeBlockedRegionsRequest struct {
	// The language. Valid values:
	//
	// *   **zh**: simplified Chinese
	// *   **en**: English
	// *   **jp**: Japanese
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
}

func (s DescribeBlockedRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockedRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeBlockedRegionsRequest) SetLanguage(v string) *DescribeBlockedRegionsRequest {
	s.Language = &v
	return s
}

type DescribeBlockedRegionsResponseBody struct {
	// The information returned.
	InfoList *DescribeBlockedRegionsResponseBodyInfoList `json:"InfoList,omitempty" xml:"InfoList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBlockedRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockedRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBlockedRegionsResponseBody) SetInfoList(v *DescribeBlockedRegionsResponseBodyInfoList) *DescribeBlockedRegionsResponseBody {
	s.InfoList = v
	return s
}

func (s *DescribeBlockedRegionsResponseBody) SetRequestId(v string) *DescribeBlockedRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeBlockedRegionsResponseBodyInfoList struct {
	InfoItem []*DescribeBlockedRegionsResponseBodyInfoListInfoItem `json:"InfoItem,omitempty" xml:"InfoItem,omitempty" type:"Repeated"`
}

func (s DescribeBlockedRegionsResponseBodyInfoList) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockedRegionsResponseBodyInfoList) GoString() string {
	return s.String()
}

func (s *DescribeBlockedRegionsResponseBodyInfoList) SetInfoItem(v []*DescribeBlockedRegionsResponseBodyInfoListInfoItem) *DescribeBlockedRegionsResponseBodyInfoList {
	s.InfoItem = v
	return s
}

type DescribeBlockedRegionsResponseBodyInfoListInfoItem struct {
	// The district to which the country or region belongs.
	Continent *string `json:"Continent,omitempty" xml:"Continent,omitempty"`
	// The abbreviation of the name of the country or region.
	CountriesAndRegions *string `json:"CountriesAndRegions,omitempty" xml:"CountriesAndRegions,omitempty"`
	// The name of the country or region.
	CountriesAndRegionsName *string `json:"CountriesAndRegionsName,omitempty" xml:"CountriesAndRegionsName,omitempty"`
}

func (s DescribeBlockedRegionsResponseBodyInfoListInfoItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockedRegionsResponseBodyInfoListInfoItem) GoString() string {
	return s.String()
}

func (s *DescribeBlockedRegionsResponseBodyInfoListInfoItem) SetContinent(v string) *DescribeBlockedRegionsResponseBodyInfoListInfoItem {
	s.Continent = &v
	return s
}

func (s *DescribeBlockedRegionsResponseBodyInfoListInfoItem) SetCountriesAndRegions(v string) *DescribeBlockedRegionsResponseBodyInfoListInfoItem {
	s.CountriesAndRegions = &v
	return s
}

func (s *DescribeBlockedRegionsResponseBodyInfoListInfoItem) SetCountriesAndRegionsName(v string) *DescribeBlockedRegionsResponseBodyInfoListInfoItem {
	s.CountriesAndRegionsName = &v
	return s
}

type DescribeBlockedRegionsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBlockedRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBlockedRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockedRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeBlockedRegionsResponse) SetHeaders(v map[string]*string) *DescribeBlockedRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeBlockedRegionsResponse) SetStatusCode(v int32) *DescribeBlockedRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBlockedRegionsResponse) SetBody(v *DescribeBlockedRegionsResponseBody) *DescribeBlockedRegionsResponse {
	s.Body = v
	return s
}

type DescribeCdnCertificateDetailRequest struct {
	// The ID of the SSL certificate. You can query only one certificate at a time.
	CertName      *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnCertificateDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateDetailRequest) SetCertName(v string) *DescribeCdnCertificateDetailRequest {
	s.CertName = &v
	return s
}

func (s *DescribeCdnCertificateDetailRequest) SetOwnerId(v int64) *DescribeCdnCertificateDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnCertificateDetailRequest) SetSecurityToken(v string) *DescribeCdnCertificateDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnCertificateDetailResponseBody struct {
	// The certificate.
	Cert *string `json:"Cert,omitempty" xml:"Cert,omitempty"`
	// The ID of the certificate.
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The key of the SSL certificate.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnCertificateDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateDetailResponseBody) SetCert(v string) *DescribeCdnCertificateDetailResponseBody {
	s.Cert = &v
	return s
}

func (s *DescribeCdnCertificateDetailResponseBody) SetCertId(v int64) *DescribeCdnCertificateDetailResponseBody {
	s.CertId = &v
	return s
}

func (s *DescribeCdnCertificateDetailResponseBody) SetCertName(v string) *DescribeCdnCertificateDetailResponseBody {
	s.CertName = &v
	return s
}

func (s *DescribeCdnCertificateDetailResponseBody) SetKey(v string) *DescribeCdnCertificateDetailResponseBody {
	s.Key = &v
	return s
}

func (s *DescribeCdnCertificateDetailResponseBody) SetRequestId(v string) *DescribeCdnCertificateDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnCertificateDetailResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnCertificateDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnCertificateDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateDetailResponse) SetHeaders(v map[string]*string) *DescribeCdnCertificateDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnCertificateDetailResponse) SetStatusCode(v int32) *DescribeCdnCertificateDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnCertificateDetailResponse) SetBody(v *DescribeCdnCertificateDetailResponseBody) *DescribeCdnCertificateDetailResponse {
	s.Body = v
	return s
}

type DescribeCdnCertificateListRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// If you do not specify an accelerated domain name, SSL certificates of all your accelerated domain names are queried.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnCertificateListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateListRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateListRequest) SetDomainName(v string) *DescribeCdnCertificateListRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnCertificateListRequest) SetOwnerId(v int64) *DescribeCdnCertificateListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnCertificateListRequest) SetSecurityToken(v string) *DescribeCdnCertificateListRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnCertificateListResponseBody struct {
	// Details about certificates.
	CertificateListModel *DescribeCdnCertificateListResponseBodyCertificateListModel `json:"CertificateListModel,omitempty" xml:"CertificateListModel,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnCertificateListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateListResponseBody) SetCertificateListModel(v *DescribeCdnCertificateListResponseBodyCertificateListModel) *DescribeCdnCertificateListResponseBody {
	s.CertificateListModel = v
	return s
}

func (s *DescribeCdnCertificateListResponseBody) SetRequestId(v string) *DescribeCdnCertificateListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnCertificateListResponseBodyCertificateListModel struct {
	// The list of certificates.
	CertList *DescribeCdnCertificateListResponseBodyCertificateListModelCertList `json:"CertList,omitempty" xml:"CertList,omitempty" type:"Struct"`
	// The number of certificates that are returned.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s DescribeCdnCertificateListResponseBodyCertificateListModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateListResponseBodyCertificateListModel) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModel) SetCertList(v *DescribeCdnCertificateListResponseBodyCertificateListModelCertList) *DescribeCdnCertificateListResponseBodyCertificateListModel {
	s.CertList = v
	return s
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModel) SetCount(v int32) *DescribeCdnCertificateListResponseBodyCertificateListModel {
	s.Count = &v
	return s
}

type DescribeCdnCertificateListResponseBodyCertificateListModelCertList struct {
	Cert []*DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert `json:"Cert,omitempty" xml:"Cert,omitempty" type:"Repeated"`
}

func (s DescribeCdnCertificateListResponseBodyCertificateListModelCertList) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateListResponseBodyCertificateListModelCertList) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModelCertList) SetCert(v []*DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) *DescribeCdnCertificateListResponseBodyCertificateListModelCertList {
	s.Cert = v
	return s
}

type DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert struct {
	// The ID of the certificate.
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The Common Name (CN) attribute of the certificate. In most cases, the CN is a domain name.
	Common *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// The fingerprint of the certificate.
	Fingerprint *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The timestamp.
	LastTime *int64 `json:"LastTime,omitempty" xml:"LastTime,omitempty"`
}

func (s DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) SetCertId(v int64) *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertId = &v
	return s
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) SetCertName(v string) *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertName = &v
	return s
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) SetCommon(v string) *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.Common = &v
	return s
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) SetFingerprint(v string) *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.Fingerprint = &v
	return s
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) SetIssuer(v string) *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.Issuer = &v
	return s
}

func (s *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert) SetLastTime(v int64) *DescribeCdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.LastTime = &v
	return s
}

type DescribeCdnCertificateListResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnCertificateListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnCertificateListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnCertificateListResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnCertificateListResponse) SetHeaders(v map[string]*string) *DescribeCdnCertificateListResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnCertificateListResponse) SetStatusCode(v int32) *DescribeCdnCertificateListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnCertificateListResponse) SetBody(v *DescribeCdnCertificateListResponseBody) *DescribeCdnCertificateListResponse {
	s.Body = v
	return s
}

type DescribeCdnDeletedDomainsRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names to return per page. Valid values: an integer between **1** and **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeCdnDeletedDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeletedDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeletedDomainsRequest) SetPageNumber(v int32) *DescribeCdnDeletedDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCdnDeletedDomainsRequest) SetPageSize(v int32) *DescribeCdnDeletedDomainsRequest {
	s.PageSize = &v
	return s
}

type DescribeCdnDeletedDomainsResponseBody struct {
	// The list of accelerated domain names and the time each domain name was last modified.
	Domains *DescribeCdnDeletedDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page, which is the same as the **PageNumber** parameter in request parameters.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names returned per page, which is the same as the **PageSize** parameter in request parameters.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCdnDeletedDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeletedDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeletedDomainsResponseBody) SetDomains(v *DescribeCdnDeletedDomainsResponseBodyDomains) *DescribeCdnDeletedDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeCdnDeletedDomainsResponseBody) SetPageNumber(v int64) *DescribeCdnDeletedDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCdnDeletedDomainsResponseBody) SetPageSize(v int64) *DescribeCdnDeletedDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCdnDeletedDomainsResponseBody) SetRequestId(v string) *DescribeCdnDeletedDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdnDeletedDomainsResponseBody) SetTotalCount(v int64) *DescribeCdnDeletedDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCdnDeletedDomainsResponseBodyDomains struct {
	PageData []*DescribeCdnDeletedDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeCdnDeletedDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeletedDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeletedDomainsResponseBodyDomains) SetPageData(v []*DescribeCdnDeletedDomainsResponseBodyDomainsPageData) *DescribeCdnDeletedDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeCdnDeletedDomainsResponseBodyDomainsPageData struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The time when the accelerated domain name was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
}

func (s DescribeCdnDeletedDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeletedDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeletedDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeCdnDeletedDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDeletedDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeCdnDeletedDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

type DescribeCdnDeletedDomainsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnDeletedDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnDeletedDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeletedDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeletedDomainsResponse) SetHeaders(v map[string]*string) *DescribeCdnDeletedDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnDeletedDomainsResponse) SetStatusCode(v int32) *DescribeCdnDeletedDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnDeletedDomainsResponse) SetBody(v *DescribeCdnDeletedDomainsResponseBody) *DescribeCdnDeletedDomainsResponse {
	s.Body = v
	return s
}

type DescribeCdnDeliverListRequest struct {
	// The ID of the tracking task that you want to query. If you do not specify an ID, all tracking tasks are queried.
	DeliverId *int64 `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
}

func (s DescribeCdnDeliverListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeliverListRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeliverListRequest) SetDeliverId(v int64) *DescribeCdnDeliverListRequest {
	s.DeliverId = &v
	return s
}

type DescribeCdnDeliverListResponseBody struct {
	// The information about the tracking task.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnDeliverListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeliverListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeliverListResponseBody) SetContent(v string) *DescribeCdnDeliverListResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeCdnDeliverListResponseBody) SetRequestId(v string) *DescribeCdnDeliverListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnDeliverListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnDeliverListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnDeliverListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDeliverListResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnDeliverListResponse) SetHeaders(v map[string]*string) *DescribeCdnDeliverListResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnDeliverListResponse) SetStatusCode(v int32) *DescribeCdnDeliverListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnDeliverListResponse) SetBody(v *DescribeCdnDeliverListResponseBody) *DescribeCdnDeliverListResponse {
	s.Body = v
	return s
}

type DescribeCdnDomainByCertificateRequest struct {
	// The public key of the SSL certificate. You must encode the public key in Base64 before you invoke the encodeURIComponent function to encode a URI component.
	//
	// A public key in the Privacy Enhanced Mail (PEM) format is supported.
	SSLPub *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	// Specifies whether to return only domain names with HTTPS enabled or disabled.
	//
	// *   true: returns only domain names with HTTPS enabled.
	// *   false: returns only domain names with HTTPS disabled.
	SSLStatus *bool `json:"SSLStatus,omitempty" xml:"SSLStatus,omitempty"`
}

func (s DescribeCdnDomainByCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainByCertificateRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainByCertificateRequest) SetSSLPub(v string) *DescribeCdnDomainByCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *DescribeCdnDomainByCertificateRequest) SetSSLStatus(v bool) *DescribeCdnDomainByCertificateRequest {
	s.SSLStatus = &v
	return s
}

type DescribeCdnDomainByCertificateResponseBody struct {
	// The certificate information.
	CertInfos *DescribeCdnDomainByCertificateResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnDomainByCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainByCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainByCertificateResponseBody) SetCertInfos(v *DescribeCdnDomainByCertificateResponseBodyCertInfos) *DescribeCdnDomainByCertificateResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBody) SetRequestId(v string) *DescribeCdnDomainByCertificateResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnDomainByCertificateResponseBodyCertInfos struct {
	CertInfo []*DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeCdnDomainByCertificateResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainByCertificateResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfos) SetCertInfo(v []*DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) *DescribeCdnDomainByCertificateResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo struct {
	// Indicates whether the SSL certificate is obsolete. Valid values:
	//
	// *   **yes**
	// *   **no**
	CertCaIsLegacy *string `json:"CertCaIsLegacy,omitempty" xml:"CertCaIsLegacy,omitempty"`
	// The expiration time of the certificate.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// Indicates whether the SSL certificate is expired. Valid values:
	//
	// *   **yes**
	// *   **no**
	CertExpired *string `json:"CertExpired,omitempty" xml:"CertExpired,omitempty"`
	// The effective time of the certificate.
	CertStartTime *string `json:"CertStartTime,omitempty" xml:"CertStartTime,omitempty"`
	// The name of the SSL certificate owner.
	CertSubjectCommonName *string `json:"CertSubjectCommonName,omitempty" xml:"CertSubjectCommonName,omitempty"`
	// The type of the certificate. Valid values: **RSA**, **DSA**, and **ECDSA**.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The list of domain names. If a value is returned, the value matches the SSL certificate. Multiple domain names are separated by commas (,).
	DomainList *string `json:"DomainList,omitempty" xml:"DomainList,omitempty"`
	// The domain names (DNS fields) that match the SSL certificate. Multiple domain names are separated by commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
}

func (s DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertCaIsLegacy(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertCaIsLegacy = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertExpired(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertExpired = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertStartTime(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertStartTime = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertSubjectCommonName(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertSubjectCommonName = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetDomainList(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.DomainList = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetDomainNames(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.DomainNames = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo) SetIssuer(v string) *DescribeCdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.Issuer = &v
	return s
}

type DescribeCdnDomainByCertificateResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnDomainByCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnDomainByCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainByCertificateResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainByCertificateResponse) SetHeaders(v map[string]*string) *DescribeCdnDomainByCertificateResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnDomainByCertificateResponse) SetStatusCode(v int32) *DescribeCdnDomainByCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnDomainByCertificateResponse) SetBody(v *DescribeCdnDomainByCertificateResponseBody) *DescribeCdnDomainByCertificateResponse {
	s.Body = v
	return s
}

type DescribeCdnDomainConfigsRequest struct {
	// The ID of the configuration. For more information about ConfigId, see [Usage notes on ConfigId](~~388994~~).
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The names of the features. Separate multiple feature names with commas (,). For more information, see [Parameters for configuring features for domain names](~~388460~~).
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainConfigsRequest) SetConfigId(v string) *DescribeCdnDomainConfigsRequest {
	s.ConfigId = &v
	return s
}

func (s *DescribeCdnDomainConfigsRequest) SetDomainName(v string) *DescribeCdnDomainConfigsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDomainConfigsRequest) SetFunctionNames(v string) *DescribeCdnDomainConfigsRequest {
	s.FunctionNames = &v
	return s
}

func (s *DescribeCdnDomainConfigsRequest) SetOwnerId(v int64) *DescribeCdnDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnDomainConfigsRequest) SetSecurityToken(v string) *DescribeCdnDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnDomainConfigsResponseBody struct {
	// The configurations of the domain name.
	DomainConfigs *DescribeCdnDomainConfigsResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainConfigsResponseBody) SetDomainConfigs(v *DescribeCdnDomainConfigsResponseBodyDomainConfigs) *DescribeCdnDomainConfigsResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeCdnDomainConfigsResponseBody) SetRequestId(v string) *DescribeCdnDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnDomainConfigsResponseBodyDomainConfigs struct {
	DomainConfig []*DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig `json:"DomainConfig,omitempty" xml:"DomainConfig,omitempty" type:"Repeated"`
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigs) SetDomainConfig(v []*DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) *DescribeCdnDomainConfigsResponseBodyDomainConfigs {
	s.DomainConfig = v
	return s
}

type DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig struct {
	// The ID of the configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The configuration of each feature.
	FunctionArgs *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Struct"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The ID of the rule condition. This parameter is optional.
	//
	// To create a rule condition, you can configure the **condition** feature that is described in the [Parameters for configuring features for domain names](~~388460~~) topic. A rule condition can identify parameters that are included in requests and filter requests based on the identified parameters. Each rule condition has a [ConfigId](~~388994~~). You can use ConfigId as ParentId that is referenced by other features. This way, you can combine rule conditions and features for flexible configurations.
	//
	// For more information, see [BatchSetCdnDomainConfig](~~90915~~) or ParentId configuration example in this topic.
	ParentId *string `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The status of the configuration. Valid values:
	//
	// *   **success**
	// *   **testing**
	// *   **failed**
	// *   **configuring**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetConfigId(v string) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.ConfigId = &v
	return s
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionArgs(v *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionArgs = v
	return s
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionName(v string) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionName = &v
	return s
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetParentId(v string) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.ParentId = &v
	return s
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetStatus(v string) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.Status = &v
	return s
}

type DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs struct {
	FunctionArg []*DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg `json:"FunctionArg,omitempty" xml:"FunctionArg,omitempty" type:"Repeated"`
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) SetFunctionArg(v []*DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs {
	s.FunctionArg = v
	return s
}

type DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg struct {
	// The parameter name, which is the configuration item of **functionName**. You can configure multiple configuration items.
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The parameter value, which is the value of the configuration item of **functionName**.
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgName(v string) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgName = &v
	return s
}

func (s *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgValue(v string) *DescribeCdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgValue = &v
	return s
}

type DescribeCdnDomainConfigsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainConfigsResponse) SetHeaders(v map[string]*string) *DescribeCdnDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnDomainConfigsResponse) SetStatusCode(v int32) *DescribeCdnDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnDomainConfigsResponse) SetBody(v *DescribeCdnDomainConfigsResponseBody) *DescribeCdnDomainConfigsResponse {
	s.Body = v
	return s
}

type DescribeCdnDomainDetailRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainDetailRequest) SetDomainName(v string) *DescribeCdnDomainDetailRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDomainDetailRequest) SetOwnerId(v int64) *DescribeCdnDomainDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnDomainDetailRequest) SetSecurityToken(v string) *DescribeCdnDomainDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnDomainDetailResponseBody struct {
	// The details about the accelerated domain name.
	GetDomainDetailModel *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel `json:"GetDomainDetailModel,omitempty" xml:"GetDomainDetailModel,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainDetailResponseBody) SetGetDomainDetailModel(v *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) *DescribeCdnDomainDetailResponseBody {
	s.GetDomainDetailModel = v
	return s
}

func (s *DescribeCdnDomainDetailResponseBody) SetRequestId(v string) *DescribeCdnDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnDomainDetailResponseBodyGetDomainDetailModel struct {
	// The workload type of the accelerated domain name. Valid values:
	//
	// *   **web**: images and small files
	// *   **download**: large files
	// *   **video**: on-demand video and audio streaming
	CdnType *string `json:"CdnType,omitempty" xml:"CdnType,omitempty"`
	// The CNAME that is assigned to the accelerated domain name. You must add the CNAME record in the system of your DNS service provider to map the accelerated domain name to the CNAME.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The description of the domain name.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   **online**
	// *   **offline**
	// *   **configuring**
	// *   **configure_failed**
	// *   **checking**
	// *   **check_failed**
	// *   **stopping**
	// *   **deleting**
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the domain name was created.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the domain name was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The CNAME for which HTTPS is enabled.
	HttpsCname *string `json:"HttpsCname,omitempty" xml:"HttpsCname,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The acceleration region.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// Indicates whether the SSL certificate is enabled. Valid values:
	//
	// *   **on**
	// *   **off**
	ServerCertificateStatus *string `json:"ServerCertificateStatus,omitempty" xml:"ServerCertificateStatus,omitempty"`
	// The information about the origin server.
	SourceModels *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels `json:"SourceModels,omitempty" xml:"SourceModels,omitempty" type:"Struct"`
}

func (s DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetCdnType(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.CdnType = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetCname(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.Cname = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetDescription(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.Description = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetDomainName(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetDomainStatus(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.DomainStatus = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetGmtCreated(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.GmtCreated = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetGmtModified(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.GmtModified = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetHttpsCname(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.HttpsCname = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetResourceGroupId(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetScope(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.Scope = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetServerCertificateStatus(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.ServerCertificateStatus = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel) SetSourceModels(v *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModel {
	s.SourceModels = v
	return s
}

type DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels struct {
	SourceModel []*DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel `json:"SourceModel,omitempty" xml:"SourceModel,omitempty" type:"Repeated"`
}

func (s DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels) SetSourceModel(v []*DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModels {
	s.SourceModel = v
	return s
}

type DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The status.
	Enabled *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The port over which requests are redirected to the origin server. Ports 443 and 80 are supported.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server. Valid values:
	//
	// *   **ipaddr**: an origin IP address
	// *   **domain**: an origin domain name
	// *   **oss**: the domain name of an Object Storage Service (OSS) bucket
	// *   **fc_domain:** a Function Compute domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) SetContent(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel {
	s.Content = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) SetEnabled(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel {
	s.Enabled = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) SetPort(v int32) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel {
	s.Port = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) SetPriority(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel {
	s.Priority = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) SetType(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel {
	s.Type = &v
	return s
}

func (s *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel) SetWeight(v string) *DescribeCdnDomainDetailResponseBodyGetDomainDetailModelSourceModelsSourceModel {
	s.Weight = &v
	return s
}

type DescribeCdnDomainDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainDetailResponse) SetHeaders(v map[string]*string) *DescribeCdnDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnDomainDetailResponse) SetStatusCode(v int32) *DescribeCdnDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnDomainDetailResponse) SetBody(v *DescribeCdnDomainDetailResponseBody) *DescribeCdnDomainDetailResponse {
	s.Body = v
	return s
}

type DescribeCdnDomainLogsRequest struct {
	// The domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Pages start from page **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **300**. Maximum value: **1000**. Valid values: **1** to **1000**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnDomainLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsRequest) SetDomainName(v string) *DescribeCdnDomainLogsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDomainLogsRequest) SetEndTime(v string) *DescribeCdnDomainLogsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnDomainLogsRequest) SetPageNumber(v int64) *DescribeCdnDomainLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCdnDomainLogsRequest) SetPageSize(v int64) *DescribeCdnDomainLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCdnDomainLogsRequest) SetStartTime(v string) *DescribeCdnDomainLogsRequest {
	s.StartTime = &v
	return s
}

type DescribeCdnDomainLogsResponseBody struct {
	// A set of DomainLogDetail data.
	DomainLogDetails *DescribeCdnDomainLogsResponseBodyDomainLogDetails `json:"DomainLogDetails,omitempty" xml:"DomainLogDetails,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnDomainLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsResponseBody) SetDomainLogDetails(v *DescribeCdnDomainLogsResponseBodyDomainLogDetails) *DescribeCdnDomainLogsResponseBody {
	s.DomainLogDetails = v
	return s
}

func (s *DescribeCdnDomainLogsResponseBody) SetRequestId(v string) *DescribeCdnDomainLogsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnDomainLogsResponseBodyDomainLogDetails struct {
	DomainLogDetail []*DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail `json:"DomainLogDetail,omitempty" xml:"DomainLogDetail,omitempty" type:"Repeated"`
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetails) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetails) SetDomainLogDetail(v []*DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail) *DescribeCdnDomainLogsResponseBodyDomainLogDetails {
	s.DomainLogDetail = v
	return s
}

type DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The total number of entries returned on the current page.
	LogCount *int64 `json:"LogCount,omitempty" xml:"LogCount,omitempty"`
	// A set of LogInfoDetail data.
	LogInfos *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos `json:"LogInfos,omitempty" xml:"LogInfos,omitempty" type:"Struct"`
	// A set of PageInfoDetail data.
	PageInfos *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos `json:"PageInfos,omitempty" xml:"PageInfos,omitempty" type:"Struct"`
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail) SetDomainName(v string) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail) SetLogCount(v int64) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogCount = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail) SetLogInfos(v *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogInfos = v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail) SetPageInfos(v *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetail {
	s.PageInfos = v
	return s
}

type DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos struct {
	LogInfoDetail []*DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail `json:"LogInfoDetail,omitempty" xml:"LogInfoDetail,omitempty" type:"Repeated"`
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos) SetLogInfoDetail(v []*DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfos {
	s.LogInfoDetail = v
	return s
}

type DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail struct {
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the log file.
	LogName *string `json:"LogName,omitempty" xml:"LogName,omitempty"`
	// The path of the log file.
	LogPath *string `json:"LogPath,omitempty" xml:"LogPath,omitempty"`
	// The size of the log file.
	LogSize *int64 `json:"LogSize,omitempty" xml:"LogSize,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetEndTime(v string) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogName(v string) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogName = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogPath(v string) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogPath = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogSize(v int64) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogSize = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetStartTime(v string) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.StartTime = &v
	return s
}

type DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos struct {
	// The page number of the returned page.
	PageIndex *int64 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageIndex(v int64) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageIndex = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageSize(v int64) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageSize = &v
	return s
}

func (s *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetTotal(v int64) *DescribeCdnDomainLogsResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.Total = &v
	return s
}

type DescribeCdnDomainLogsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnDomainLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnDomainLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainLogsResponse) SetHeaders(v map[string]*string) *DescribeCdnDomainLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnDomainLogsResponse) SetStatusCode(v int32) *DescribeCdnDomainLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnDomainLogsResponse) SetBody(v *DescribeCdnDomainLogsResponseBody) *DescribeCdnDomainLogsResponse {
	s.Body = v
	return s
}

type DescribeCdnDomainStagingConfigRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The list of feature names. Separate multiple values with commas (,). For more information, see [A list of features](~~388460~~).
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
}

func (s DescribeCdnDomainStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainStagingConfigRequest) SetDomainName(v string) *DescribeCdnDomainStagingConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDomainStagingConfigRequest) SetFunctionNames(v string) *DescribeCdnDomainStagingConfigRequest {
	s.FunctionNames = &v
	return s
}

type DescribeCdnDomainStagingConfigResponseBody struct {
	// The domain name configurations.
	DomainConfigs []*DescribeCdnDomainStagingConfigResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Repeated"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnDomainStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainStagingConfigResponseBody) SetDomainConfigs(v []*DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) *DescribeCdnDomainStagingConfigResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponseBody) SetDomainName(v string) *DescribeCdnDomainStagingConfigResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponseBody) SetRequestId(v string) *DescribeCdnDomainStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnDomainStagingConfigResponseBodyDomainConfigs struct {
	// The configuration ID.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The description of each feature.
	FunctionArgs []*DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Repeated"`
	// The feature name.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The rule condition ID. This parameter is optional. To create a rule condition, you can configure the **condition** feature that is described in the [Parameters for configuring features for domain names](~~388460~~) topic. A rule condition can identify parameters that are included in requests and filter requests based on the identified parameters. Each rule condition has a [ConfigId](~~388994~~). You can reference ConfigId instead of ParentId in other features. This way, you can combine rule conditions and features for flexible configurations. For more information, see [BatchSetCdnDomainConfig](~~90915~~) or ParentId configuration example in this topic.
	ParentId *string `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The configuration status. Valid values:
	//
	// *   **testing**
	// *   **configuring**
	// *   **success**
	// *   **failed**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) SetConfigId(v string) *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs {
	s.ConfigId = &v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) SetFunctionArgs(v []*DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs {
	s.FunctionArgs = v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) SetFunctionName(v string) *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs {
	s.FunctionName = &v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) SetParentId(v string) *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs {
	s.ParentId = &v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs) SetStatus(v string) *DescribeCdnDomainStagingConfigResponseBodyDomainConfigs {
	s.Status = &v
	return s
}

type DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs struct {
	// The configuration name.
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The configuration value.
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) SetArgName(v string) *DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs {
	s.ArgName = &v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) SetArgValue(v string) *DescribeCdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs {
	s.ArgValue = &v
	return s
}

type DescribeCdnDomainStagingConfigResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnDomainStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnDomainStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnDomainStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnDomainStagingConfigResponse) SetHeaders(v map[string]*string) *DescribeCdnDomainStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponse) SetStatusCode(v int32) *DescribeCdnDomainStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnDomainStagingConfigResponse) SetBody(v *DescribeCdnDomainStagingConfigResponseBody) *DescribeCdnDomainStagingConfigResponse {
	s.Body = v
	return s
}

type DescribeCdnHttpsDomainListRequest struct {
	// The keyword that is used to search for certificates.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of the page to return. Valid values: **1** to **100000**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeCdnHttpsDomainListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnHttpsDomainListRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnHttpsDomainListRequest) SetKeyword(v string) *DescribeCdnHttpsDomainListRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeCdnHttpsDomainListRequest) SetPageNumber(v int32) *DescribeCdnHttpsDomainListRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCdnHttpsDomainListRequest) SetPageSize(v int32) *DescribeCdnHttpsDomainListRequest {
	s.PageSize = &v
	return s
}

type DescribeCdnHttpsDomainListResponseBody struct {
	// The information about the certificate.
	CertInfos *DescribeCdnHttpsDomainListResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCdnHttpsDomainListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnHttpsDomainListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnHttpsDomainListResponseBody) SetCertInfos(v *DescribeCdnHttpsDomainListResponseBodyCertInfos) *DescribeCdnHttpsDomainListResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBody) SetRequestId(v string) *DescribeCdnHttpsDomainListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBody) SetTotalCount(v int32) *DescribeCdnHttpsDomainListResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCdnHttpsDomainListResponseBodyCertInfos struct {
	CertInfo []*DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeCdnHttpsDomainListResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnHttpsDomainListResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfos) SetCertInfo(v []*DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) *DescribeCdnHttpsDomainListResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo struct {
	// The returned primary domain name of the certificate.
	CertCommonName *string `json:"CertCommonName,omitempty" xml:"CertCommonName,omitempty"`
	// The time at which the certificate expires.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The time at which the certificate became effective.
	CertStartTime *string `json:"CertStartTime,omitempty" xml:"CertStartTime,omitempty"`
	// The status of the certificate.
	//
	// *   **ok**: The certificate is working as expected.
	// *   **mismatch**: The certificate does not match the specified domain name.
	// *   **expired**: The certificate has expired.
	// *   **expire_soon**: The certificate will expire soon.
	CertStatus *string `json:"CertStatus,omitempty" xml:"CertStatus,omitempty"`
	// The type of the certificate.
	//
	// *   **free**: a free certificate.
	// *   **cas**: a certificate that is purchased from Alibaba Cloud SSL Certificates Service.
	// *   **upload**: a certificate that is uploaded by the user.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The time at which the certificate was updated.
	CertUpdateTime *string `json:"CertUpdateTime,omitempty" xml:"CertUpdateTime,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertCommonName(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertCommonName = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertName(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertName = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertStartTime(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertStartTime = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertStatus(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertStatus = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertUpdateTime(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertUpdateTime = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo) SetDomainName(v string) *DescribeCdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.DomainName = &v
	return s
}

type DescribeCdnHttpsDomainListResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnHttpsDomainListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnHttpsDomainListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnHttpsDomainListResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnHttpsDomainListResponse) SetHeaders(v map[string]*string) *DescribeCdnHttpsDomainListResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnHttpsDomainListResponse) SetStatusCode(v int32) *DescribeCdnHttpsDomainListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnHttpsDomainListResponse) SetBody(v *DescribeCdnHttpsDomainListResponseBody) *DescribeCdnHttpsDomainListResponse {
	s.Body = v
	return s
}

type DescribeCdnOrderCommodityCodeRequest struct {
	// The original commodity code.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnOrderCommodityCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnOrderCommodityCodeRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnOrderCommodityCodeRequest) SetCommodityCode(v string) *DescribeCdnOrderCommodityCodeRequest {
	s.CommodityCode = &v
	return s
}

func (s *DescribeCdnOrderCommodityCodeRequest) SetOwnerId(v int64) *DescribeCdnOrderCommodityCodeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnOrderCommodityCodeRequest) SetSecurityToken(v string) *DescribeCdnOrderCommodityCodeRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnOrderCommodityCodeResponseBody struct {
	// The commodity code that includes the organization unit.
	OrderCommodityCode *string `json:"OrderCommodityCode,omitempty" xml:"OrderCommodityCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnOrderCommodityCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnOrderCommodityCodeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnOrderCommodityCodeResponseBody) SetOrderCommodityCode(v string) *DescribeCdnOrderCommodityCodeResponseBody {
	s.OrderCommodityCode = &v
	return s
}

func (s *DescribeCdnOrderCommodityCodeResponseBody) SetRequestId(v string) *DescribeCdnOrderCommodityCodeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnOrderCommodityCodeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnOrderCommodityCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnOrderCommodityCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnOrderCommodityCodeResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnOrderCommodityCodeResponse) SetHeaders(v map[string]*string) *DescribeCdnOrderCommodityCodeResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnOrderCommodityCodeResponse) SetStatusCode(v int32) *DescribeCdnOrderCommodityCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnOrderCommodityCodeResponse) SetBody(v *DescribeCdnOrderCommodityCodeResponseBody) *DescribeCdnOrderCommodityCodeResponse {
	s.Body = v
	return s
}

type DescribeCdnRegionAndIspRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnRegionAndIspRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnRegionAndIspRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnRegionAndIspRequest) SetOwnerId(v int64) *DescribeCdnRegionAndIspRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnRegionAndIspRequest) SetSecurityToken(v string) *DescribeCdnRegionAndIspRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnRegionAndIspResponseBody struct {
	// The list of ISPs.
	Isps *DescribeCdnRegionAndIspResponseBodyIsps `json:"Isps,omitempty" xml:"Isps,omitempty" type:"Struct"`
	// The list of regions.
	Regions *DescribeCdnRegionAndIspResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnRegionAndIspResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnRegionAndIspResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnRegionAndIspResponseBody) SetIsps(v *DescribeCdnRegionAndIspResponseBodyIsps) *DescribeCdnRegionAndIspResponseBody {
	s.Isps = v
	return s
}

func (s *DescribeCdnRegionAndIspResponseBody) SetRegions(v *DescribeCdnRegionAndIspResponseBodyRegions) *DescribeCdnRegionAndIspResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeCdnRegionAndIspResponseBody) SetRequestId(v string) *DescribeCdnRegionAndIspResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnRegionAndIspResponseBodyIsps struct {
	Isp []*DescribeCdnRegionAndIspResponseBodyIspsIsp `json:"Isp,omitempty" xml:"Isp,omitempty" type:"Repeated"`
}

func (s DescribeCdnRegionAndIspResponseBodyIsps) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnRegionAndIspResponseBodyIsps) GoString() string {
	return s.String()
}

func (s *DescribeCdnRegionAndIspResponseBodyIsps) SetIsp(v []*DescribeCdnRegionAndIspResponseBodyIspsIsp) *DescribeCdnRegionAndIspResponseBodyIsps {
	s.Isp = v
	return s
}

type DescribeCdnRegionAndIspResponseBodyIspsIsp struct {
	// The English name of the ISP.
	NameEn *string `json:"NameEn,omitempty" xml:"NameEn,omitempty"`
	// The Chinese name of the ISP.
	NameZh *string `json:"NameZh,omitempty" xml:"NameZh,omitempty"`
}

func (s DescribeCdnRegionAndIspResponseBodyIspsIsp) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnRegionAndIspResponseBodyIspsIsp) GoString() string {
	return s.String()
}

func (s *DescribeCdnRegionAndIspResponseBodyIspsIsp) SetNameEn(v string) *DescribeCdnRegionAndIspResponseBodyIspsIsp {
	s.NameEn = &v
	return s
}

func (s *DescribeCdnRegionAndIspResponseBodyIspsIsp) SetNameZh(v string) *DescribeCdnRegionAndIspResponseBodyIspsIsp {
	s.NameZh = &v
	return s
}

type DescribeCdnRegionAndIspResponseBodyRegions struct {
	Region []*DescribeCdnRegionAndIspResponseBodyRegionsRegion `json:"Region,omitempty" xml:"Region,omitempty" type:"Repeated"`
}

func (s DescribeCdnRegionAndIspResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnRegionAndIspResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeCdnRegionAndIspResponseBodyRegions) SetRegion(v []*DescribeCdnRegionAndIspResponseBodyRegionsRegion) *DescribeCdnRegionAndIspResponseBodyRegions {
	s.Region = v
	return s
}

type DescribeCdnRegionAndIspResponseBodyRegionsRegion struct {
	// The English name of the region.
	NameEn *string `json:"NameEn,omitempty" xml:"NameEn,omitempty"`
	// The Chinese name of the region.
	NameZh *string `json:"NameZh,omitempty" xml:"NameZh,omitempty"`
}

func (s DescribeCdnRegionAndIspResponseBodyRegionsRegion) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnRegionAndIspResponseBodyRegionsRegion) GoString() string {
	return s.String()
}

func (s *DescribeCdnRegionAndIspResponseBodyRegionsRegion) SetNameEn(v string) *DescribeCdnRegionAndIspResponseBodyRegionsRegion {
	s.NameEn = &v
	return s
}

func (s *DescribeCdnRegionAndIspResponseBodyRegionsRegion) SetNameZh(v string) *DescribeCdnRegionAndIspResponseBodyRegionsRegion {
	s.NameZh = &v
	return s
}

type DescribeCdnRegionAndIspResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnRegionAndIspResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnRegionAndIspResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnRegionAndIspResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnRegionAndIspResponse) SetHeaders(v map[string]*string) *DescribeCdnRegionAndIspResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnRegionAndIspResponse) SetStatusCode(v int32) *DescribeCdnRegionAndIspResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnRegionAndIspResponse) SetBody(v *DescribeCdnRegionAndIspResponseBody) *DescribeCdnRegionAndIspResponse {
	s.Body = v
	return s
}

type DescribeCdnReportRequest struct {
	// The region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	//
	// *   If you do not specify a region, data in all regions is queried.
	// *   If you specify a region, data in the specified region is queried. You can specify one or more regions. If you specify multiple regions, separate the regions with commas (,).
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The domain name that you want to query. Separate domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The HTTP status code. Valid values:
	//
	// *   **2xx**
	// *   **3xx**
	// *   **4xx**
	// *   **5xx**
	//
	// If you do not specify this parameter, all HTTP status codes are queried.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// Specifies whether the region is outside the Chinese mainland. Valid values:
	//
	// *   **1**: outside the Chinese mainland
	// *   **0**: inside the Chinese mainland
	IsOverseas *string `json:"IsOverseas,omitempty" xml:"IsOverseas,omitempty"`
	// The ID of the operations report that you want to query. You can specify only one ID in each request. You can call the [DescribeCdnSubList](~~271655~~) operation to query report IDs.
	ReportId *int64 `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnReportRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnReportRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnReportRequest) SetArea(v string) *DescribeCdnReportRequest {
	s.Area = &v
	return s
}

func (s *DescribeCdnReportRequest) SetDomainName(v string) *DescribeCdnReportRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnReportRequest) SetEndTime(v string) *DescribeCdnReportRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnReportRequest) SetHttpCode(v string) *DescribeCdnReportRequest {
	s.HttpCode = &v
	return s
}

func (s *DescribeCdnReportRequest) SetIsOverseas(v string) *DescribeCdnReportRequest {
	s.IsOverseas = &v
	return s
}

func (s *DescribeCdnReportRequest) SetReportId(v int64) *DescribeCdnReportRequest {
	s.ReportId = &v
	return s
}

func (s *DescribeCdnReportRequest) SetStartTime(v string) *DescribeCdnReportRequest {
	s.StartTime = &v
	return s
}

type DescribeCdnReportResponseBody struct {
	// The content of the operations report.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnReportResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnReportResponseBody) SetContent(v map[string]interface{}) *DescribeCdnReportResponseBody {
	s.Content = v
	return s
}

func (s *DescribeCdnReportResponseBody) SetRequestId(v string) *DescribeCdnReportResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnReportResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnReportResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnReportResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnReportResponse) SetHeaders(v map[string]*string) *DescribeCdnReportResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnReportResponse) SetStatusCode(v int32) *DescribeCdnReportResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnReportResponse) SetBody(v *DescribeCdnReportResponseBody) *DescribeCdnReportResponse {
	s.Body = v
	return s
}

type DescribeCdnReportListRequest struct {
	// The ID of the operations report that you want to query. If you do not specify an ID, all operations reports are queried.
	ReportId *int64 `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
}

func (s DescribeCdnReportListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnReportListRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnReportListRequest) SetReportId(v int64) *DescribeCdnReportListRequest {
	s.ReportId = &v
	return s
}

type DescribeCdnReportListResponseBody struct {
	// The information about the report that is queried.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnReportListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnReportListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnReportListResponseBody) SetContent(v string) *DescribeCdnReportListResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeCdnReportListResponseBody) SetRequestId(v string) *DescribeCdnReportListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnReportListResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnReportListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnReportListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnReportListResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnReportListResponse) SetHeaders(v map[string]*string) *DescribeCdnReportListResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnReportListResponse) SetStatusCode(v int32) *DescribeCdnReportListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnReportListResponse) SetBody(v *DescribeCdnReportListResponseBody) *DescribeCdnReportListResponse {
	s.Body = v
	return s
}

type DescribeCdnSMCertificateDetailRequest struct {
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken  *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnSMCertificateDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateDetailRequest) SetCertIdentifier(v string) *DescribeCdnSMCertificateDetailRequest {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailRequest) SetOwnerId(v int64) *DescribeCdnSMCertificateDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailRequest) SetSecurityToken(v string) *DescribeCdnSMCertificateDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnSMCertificateDetailResponseBody struct {
	// The expiration time of the certificate. The time is displayed in UTC.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	CertOrg *string `json:"CertOrg,omitempty" xml:"CertOrg,omitempty"`
	// The common name.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The content of the encryption certificate.
	EncryptCertificate *string `json:"EncryptCertificate,omitempty" xml:"EncryptCertificate,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The subdomain name.
	Sans *string `json:"Sans,omitempty" xml:"Sans,omitempty"`
	// The content of the signature certificate.
	SignCertificate *string `json:"SignCertificate,omitempty" xml:"SignCertificate,omitempty"`
}

func (s DescribeCdnSMCertificateDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetCertExpireTime(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetCertIdentifier(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetCertName(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.CertName = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetCertOrg(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.CertOrg = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetCommonName(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.CommonName = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetEncryptCertificate(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.EncryptCertificate = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetRequestId(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetSans(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.Sans = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponseBody) SetSignCertificate(v string) *DescribeCdnSMCertificateDetailResponseBody {
	s.SignCertificate = &v
	return s
}

type DescribeCdnSMCertificateDetailResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnSMCertificateDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnSMCertificateDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateDetailResponse) SetHeaders(v map[string]*string) *DescribeCdnSMCertificateDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponse) SetStatusCode(v int32) *DescribeCdnSMCertificateDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnSMCertificateDetailResponse) SetBody(v *DescribeCdnSMCertificateDetailResponseBody) *DescribeCdnSMCertificateDetailResponse {
	s.Body = v
	return s
}

type DescribeCdnSMCertificateListRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnSMCertificateListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateListRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateListRequest) SetDomainName(v string) *DescribeCdnSMCertificateListRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnSMCertificateListRequest) SetOwnerId(v int64) *DescribeCdnSMCertificateListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnSMCertificateListRequest) SetSecurityToken(v string) *DescribeCdnSMCertificateListRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnSMCertificateListResponseBody struct {
	// The type of the certificate information.
	CertificateListModel *DescribeCdnSMCertificateListResponseBodyCertificateListModel `json:"CertificateListModel,omitempty" xml:"CertificateListModel,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnSMCertificateListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateListResponseBody) SetCertificateListModel(v *DescribeCdnSMCertificateListResponseBodyCertificateListModel) *DescribeCdnSMCertificateListResponseBody {
	s.CertificateListModel = v
	return s
}

func (s *DescribeCdnSMCertificateListResponseBody) SetRequestId(v string) *DescribeCdnSMCertificateListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnSMCertificateListResponseBodyCertificateListModel struct {
	// The list of certificates.
	CertList *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList `json:"CertList,omitempty" xml:"CertList,omitempty" type:"Struct"`
	// The number of certificates that are returned.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s DescribeCdnSMCertificateListResponseBodyCertificateListModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateListResponseBodyCertificateListModel) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateListResponseBodyCertificateListModel) SetCertList(v *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList) *DescribeCdnSMCertificateListResponseBodyCertificateListModel {
	s.CertList = v
	return s
}

func (s *DescribeCdnSMCertificateListResponseBodyCertificateListModel) SetCount(v int32) *DescribeCdnSMCertificateListResponseBodyCertificateListModel {
	s.Count = &v
	return s
}

type DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList struct {
	Cert []*DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert `json:"Cert,omitempty" xml:"Cert,omitempty" type:"Repeated"`
}

func (s DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList) SetCert(v []*DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert) *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertList {
	s.Cert = v
	return s
}

type DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert struct {
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The common name of the certificate.
	Common *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
}

func (s DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert) SetCertIdentifier(v string) *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert) SetCertName(v string) *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertName = &v
	return s
}

func (s *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert) SetCommon(v string) *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert {
	s.Common = &v
	return s
}

func (s *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert) SetIssuer(v string) *DescribeCdnSMCertificateListResponseBodyCertificateListModelCertListCert {
	s.Issuer = &v
	return s
}

type DescribeCdnSMCertificateListResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnSMCertificateListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnSMCertificateListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSMCertificateListResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnSMCertificateListResponse) SetHeaders(v map[string]*string) *DescribeCdnSMCertificateListResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnSMCertificateListResponse) SetStatusCode(v int32) *DescribeCdnSMCertificateListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnSMCertificateListResponse) SetBody(v *DescribeCdnSMCertificateListResponseBody) *DescribeCdnSMCertificateListResponse {
	s.Body = v
	return s
}

type DescribeCdnServiceRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnServiceRequest) SetOwnerId(v int64) *DescribeCdnServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnServiceRequest) SetSecurityToken(v string) *DescribeCdnServiceRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnServiceResponseBody struct {
	// The time when the metering method for the next cycle takes effect. The time is displayed in GMT.
	ChangingAffectTime *string `json:"ChangingAffectTime,omitempty" xml:"ChangingAffectTime,omitempty"`
	// The metering method for the next cycle. Valid values:
	//
	// *   **PayByTraffic**: pay-by-data-transfer
	// *   **PayByBandwidth**: pay-by-bandwidth
	ChangingChargeType *string `json:"ChangingChargeType,omitempty" xml:"ChangingChargeType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The current metering method. Valid values:
	//
	// *   **PayByTraffic**: pay-by-data-transfer
	// *   **PayByBandwidth**: pay-by-bandwidth
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The time when the service was activated. The time follows the ISO 8601 standard.
	OpeningTime *string `json:"OpeningTime,omitempty" xml:"OpeningTime,omitempty"`
	// The lock status.
	OperationLocks *DescribeCdnServiceResponseBodyOperationLocks `json:"OperationLocks,omitempty" xml:"OperationLocks,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnServiceResponseBody) SetChangingAffectTime(v string) *DescribeCdnServiceResponseBody {
	s.ChangingAffectTime = &v
	return s
}

func (s *DescribeCdnServiceResponseBody) SetChangingChargeType(v string) *DescribeCdnServiceResponseBody {
	s.ChangingChargeType = &v
	return s
}

func (s *DescribeCdnServiceResponseBody) SetInstanceId(v string) *DescribeCdnServiceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeCdnServiceResponseBody) SetInternetChargeType(v string) *DescribeCdnServiceResponseBody {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeCdnServiceResponseBody) SetOpeningTime(v string) *DescribeCdnServiceResponseBody {
	s.OpeningTime = &v
	return s
}

func (s *DescribeCdnServiceResponseBody) SetOperationLocks(v *DescribeCdnServiceResponseBodyOperationLocks) *DescribeCdnServiceResponseBody {
	s.OperationLocks = v
	return s
}

func (s *DescribeCdnServiceResponseBody) SetRequestId(v string) *DescribeCdnServiceResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnServiceResponseBodyOperationLocks struct {
	LockReason []*DescribeCdnServiceResponseBodyOperationLocksLockReason `json:"LockReason,omitempty" xml:"LockReason,omitempty" type:"Repeated"`
}

func (s DescribeCdnServiceResponseBodyOperationLocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnServiceResponseBodyOperationLocks) GoString() string {
	return s.String()
}

func (s *DescribeCdnServiceResponseBodyOperationLocks) SetLockReason(v []*DescribeCdnServiceResponseBodyOperationLocksLockReason) *DescribeCdnServiceResponseBodyOperationLocks {
	s.LockReason = v
	return s
}

type DescribeCdnServiceResponseBodyOperationLocksLockReason struct {
	// The reason why the service is locked. A value of financial indicates that the service is locked due to overdue payments.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
}

func (s DescribeCdnServiceResponseBodyOperationLocksLockReason) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnServiceResponseBodyOperationLocksLockReason) GoString() string {
	return s.String()
}

func (s *DescribeCdnServiceResponseBodyOperationLocksLockReason) SetLockReason(v string) *DescribeCdnServiceResponseBodyOperationLocksLockReason {
	s.LockReason = &v
	return s
}

type DescribeCdnServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnServiceResponse) SetHeaders(v map[string]*string) *DescribeCdnServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnServiceResponse) SetStatusCode(v int32) *DescribeCdnServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnServiceResponse) SetBody(v *DescribeCdnServiceResponseBody) *DescribeCdnServiceResponse {
	s.Body = v
	return s
}

type DescribeCdnSubListResponseBody struct {
	// The information about the custom report task.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnSubListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSubListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnSubListResponseBody) SetContent(v string) *DescribeCdnSubListResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeCdnSubListResponseBody) SetRequestId(v string) *DescribeCdnSubListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnSubListResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnSubListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnSubListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnSubListResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnSubListResponse) SetHeaders(v map[string]*string) *DescribeCdnSubListResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnSubListResponse) SetStatusCode(v int32) *DescribeCdnSubListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnSubListResponse) SetBody(v *DescribeCdnSubListResponseBody) *DescribeCdnSubListResponse {
	s.Body = v
	return s
}

type DescribeCdnUserBillHistoryRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum data granularity is 5 minutes.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnUserBillHistoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillHistoryRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillHistoryRequest) SetEndTime(v string) *DescribeCdnUserBillHistoryRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnUserBillHistoryRequest) SetStartTime(v string) *DescribeCdnUserBillHistoryRequest {
	s.StartTime = &v
	return s
}

type DescribeCdnUserBillHistoryResponseBody struct {
	// The billing history returned.
	BillHistoryData *DescribeCdnUserBillHistoryResponseBodyBillHistoryData `json:"BillHistoryData,omitempty" xml:"BillHistoryData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnUserBillHistoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillHistoryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillHistoryResponseBody) SetBillHistoryData(v *DescribeCdnUserBillHistoryResponseBodyBillHistoryData) *DescribeCdnUserBillHistoryResponseBody {
	s.BillHistoryData = v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBody) SetRequestId(v string) *DescribeCdnUserBillHistoryResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnUserBillHistoryResponseBodyBillHistoryData struct {
	BillHistoryDataItem []*DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem `json:"BillHistoryDataItem,omitempty" xml:"BillHistoryDataItem,omitempty" type:"Repeated"`
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryData) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryData) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryData) SetBillHistoryDataItem(v []*DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) *DescribeCdnUserBillHistoryResponseBodyBillHistoryData {
	s.BillHistoryDataItem = v
	return s
}

type DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem struct {
	// The beginning of the time range that was queried.
	BillTime *string `json:"BillTime,omitempty" xml:"BillTime,omitempty"`
	// The metering method.
	BillType *string `json:"BillType,omitempty" xml:"BillType,omitempty"`
	// The billable items.
	BillingData *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData `json:"BillingData,omitempty" xml:"BillingData,omitempty" type:"Struct"`
	// The dimension.
	Dimension *string `json:"Dimension,omitempty" xml:"Dimension,omitempty"`
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetBillTime(v string) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.BillTime = &v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetBillType(v string) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.BillType = &v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetBillingData(v *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.BillingData = v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetDimension(v string) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.Dimension = &v
	return s
}

type DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData struct {
	BillingDataItem []*DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem `json:"BillingDataItem,omitempty" xml:"BillingDataItem,omitempty" type:"Repeated"`
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) SetBillingDataItem(v []*DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData {
	s.BillingDataItem = v
	return s
}

type DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem struct {
	// The bandwidth. Unit: bit/s.
	Bandwidth *float32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The billable region. Valid values:
	//
	// *   **CN**: Chinese mainland
	// *   **OverSeas**: outside the Chinese mainland
	// *   **AP1**: Asia Pacific 1
	// *   **AP2**: Asia Pacific 2
	// *   **AP3**: Asia Pacific 3
	// *   **NA**: North America
	// *   **SA**: South America
	// *   **EU**: Europe
	// *   **MEAA**: Middle East and Africa
	CdnRegion *string `json:"CdnRegion,omitempty" xml:"CdnRegion,omitempty"`
	// The billing method. Valid values:
	//
	// *   **StaticHttp**: static HTTP requests
	// *   **DynamicHttp**: dynamic HTTP requests
	// *   **DynamicHttps**: dynamic HTTPS requests
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The number of requests.
	Count *float32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The amount of network traffic. Unit: bytes.
	Flow *float32 `json:"Flow,omitempty" xml:"Flow,omitempty"`
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetBandwidth(v float32) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.Bandwidth = &v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetCdnRegion(v string) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.CdnRegion = &v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetChargeType(v string) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.ChargeType = &v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetCount(v float32) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.Count = &v
	return s
}

func (s *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetFlow(v float32) *DescribeCdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.Flow = &v
	return s
}

type DescribeCdnUserBillHistoryResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnUserBillHistoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnUserBillHistoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillHistoryResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillHistoryResponse) SetHeaders(v map[string]*string) *DescribeCdnUserBillHistoryResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnUserBillHistoryResponse) SetStatusCode(v int32) *DescribeCdnUserBillHistoryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnUserBillHistoryResponse) SetBody(v *DescribeCdnUserBillHistoryResponseBody) *DescribeCdnUserBillHistoryResponse {
	s.Body = v
	return s
}

type DescribeCdnUserBillPredictionRequest struct {
	// The ID of the request.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The start time of the estimation.
	Dimension *string `json:"Dimension,omitempty" xml:"Dimension,omitempty"`
	// The end time of the estimation.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The billable region. Valid values:
	//
	// *   **CN**: the Chinese mainland
	// *   **OverSeas**: outside the Chinese mainland
	// *   **AP1**: Asia Pacific 1
	// *   **AP2**: Asia Pacific 2
	// *   **AP3**: Asia Pacific 3
	// *   **NA**: North America
	// *   **SA**: South America
	// *   **EU**: Europe
	// *   **MEAA**: Middle East and Africa
	//
	// By default, the value of this parameter is determined by the metering method that is currently used. Regions inside and outside the Chinese mainland are classified into the **CN** and **OverSeas** billable regions. Billable regions inside the Chinese mainland include **CN**. Billable regions outside the Chinese mainland include **AP1**, **AP2**, **AP3**, **NA**, **SA**, **EU**, and **MEAA**.
	//
	// > For more information about billable regions, see [Billable regions](~~142221~~).
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnUserBillPredictionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillPredictionRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillPredictionRequest) SetArea(v string) *DescribeCdnUserBillPredictionRequest {
	s.Area = &v
	return s
}

func (s *DescribeCdnUserBillPredictionRequest) SetDimension(v string) *DescribeCdnUserBillPredictionRequest {
	s.Dimension = &v
	return s
}

func (s *DescribeCdnUserBillPredictionRequest) SetEndTime(v string) *DescribeCdnUserBillPredictionRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnUserBillPredictionRequest) SetStartTime(v string) *DescribeCdnUserBillPredictionRequest {
	s.StartTime = &v
	return s
}

type DescribeCdnUserBillPredictionResponseBody struct {
	// The billable region.
	BillPredictionData *DescribeCdnUserBillPredictionResponseBodyBillPredictionData `json:"BillPredictionData,omitempty" xml:"BillPredictionData,omitempty" type:"Struct"`
	// The time when the value used as the estimated value is generated. This parameter is returned only if the metering method is pay by 95th percentile, pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00, or pay by 4th peak bandwidth per month.
	BillType *string `json:"BillType,omitempty" xml:"BillType,omitempty"`
	// The metering method.
	//
	// > If the metering method ends with \_overseas, the billable region is outside the Chinese mainland. For example, BillType": "month_avg_day_bandwidth_overseas specifies a billable region outside the Chinese mainland and that the metering method is pay by daily peak bandwidth per month.
	//
	// Valid values:
	//
	// *   hour_flow: pay by hourly data transfer
	// *   day_bandwidth: pay by daily bandwidth
	// *   month\_95: pay by monthly 95th percentile bandwidth.
	// *   month_avg_day_bandwidth: pay by average daily peak bandwidth per month
	// *   month\_4th_day_bandwidth: pay by monthly 4th peak bandwidth
	// *   month_avg_day\_95: pay by average daily 95th percentile bandwidth per month
	// *   month\_95\_night_half: pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00.
	// *   hour_vas: pay by value-added services per hour
	// *   day_count: pay by daily requests
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The estimated value.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The estimated bill data.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnUserBillPredictionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillPredictionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillPredictionResponseBody) SetBillPredictionData(v *DescribeCdnUserBillPredictionResponseBodyBillPredictionData) *DescribeCdnUserBillPredictionResponseBody {
	s.BillPredictionData = v
	return s
}

func (s *DescribeCdnUserBillPredictionResponseBody) SetBillType(v string) *DescribeCdnUserBillPredictionResponseBody {
	s.BillType = &v
	return s
}

func (s *DescribeCdnUserBillPredictionResponseBody) SetEndTime(v string) *DescribeCdnUserBillPredictionResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnUserBillPredictionResponseBody) SetRequestId(v string) *DescribeCdnUserBillPredictionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdnUserBillPredictionResponseBody) SetStartTime(v string) *DescribeCdnUserBillPredictionResponseBody {
	s.StartTime = &v
	return s
}

type DescribeCdnUserBillPredictionResponseBodyBillPredictionData struct {
	BillPredictionDataItem []*DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem `json:"BillPredictionDataItem,omitempty" xml:"BillPredictionDataItem,omitempty" type:"Repeated"`
}

func (s DescribeCdnUserBillPredictionResponseBodyBillPredictionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillPredictionResponseBodyBillPredictionData) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillPredictionResponseBodyBillPredictionData) SetBillPredictionDataItem(v []*DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem) *DescribeCdnUserBillPredictionResponseBodyBillPredictionData {
	s.BillPredictionDataItem = v
	return s
}

type DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem struct {
	Area    *string  `json:"Area,omitempty" xml:"Area,omitempty"`
	TimeStp *string  `json:"TimeStp,omitempty" xml:"TimeStp,omitempty"`
	Value   *float32 `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem) SetArea(v string) *DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem {
	s.Area = &v
	return s
}

func (s *DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem) SetTimeStp(v string) *DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem {
	s.TimeStp = &v
	return s
}

func (s *DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem) SetValue(v float32) *DescribeCdnUserBillPredictionResponseBodyBillPredictionDataBillPredictionDataItem {
	s.Value = &v
	return s
}

type DescribeCdnUserBillPredictionResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnUserBillPredictionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnUserBillPredictionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillPredictionResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillPredictionResponse) SetHeaders(v map[string]*string) *DescribeCdnUserBillPredictionResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnUserBillPredictionResponse) SetStatusCode(v int32) *DescribeCdnUserBillPredictionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnUserBillPredictionResponse) SetBody(v *DescribeCdnUserBillPredictionResponseBody) *DescribeCdnUserBillPredictionResponse {
	s.Body = v
	return s
}

type DescribeCdnUserBillTypeRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum data granularity is 5 minutes.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnUserBillTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillTypeRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillTypeRequest) SetEndTime(v string) *DescribeCdnUserBillTypeRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnUserBillTypeRequest) SetStartTime(v string) *DescribeCdnUserBillTypeRequest {
	s.StartTime = &v
	return s
}

type DescribeCdnUserBillTypeResponseBody struct {
	// Details about the metering methods returned.
	BillTypeData *DescribeCdnUserBillTypeResponseBodyBillTypeData `json:"BillTypeData,omitempty" xml:"BillTypeData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnUserBillTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillTypeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillTypeResponseBody) SetBillTypeData(v *DescribeCdnUserBillTypeResponseBodyBillTypeData) *DescribeCdnUserBillTypeResponseBody {
	s.BillTypeData = v
	return s
}

func (s *DescribeCdnUserBillTypeResponseBody) SetRequestId(v string) *DescribeCdnUserBillTypeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnUserBillTypeResponseBodyBillTypeData struct {
	BillTypeDataItem []*DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem `json:"BillTypeDataItem,omitempty" xml:"BillTypeDataItem,omitempty" type:"Repeated"`
}

func (s DescribeCdnUserBillTypeResponseBodyBillTypeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillTypeResponseBodyBillTypeData) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillTypeResponseBodyBillTypeData) SetBillTypeDataItem(v []*DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) *DescribeCdnUserBillTypeResponseBodyBillTypeData {
	s.BillTypeDataItem = v
	return s
}

type DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem struct {
	// The metering method.
	//
	// > If the metering method is suffixed with \*\*\_overseas\*\*, the billable region is outside the Chinese mainland. For example, "BillType": "month_avg_day_bandwidth_overseas" indicates that the metering method is pay by average daily peak bandwidth per month in a billable region outside the Chinese mainland.
	//
	// Valid values:
	//
	// *   hour_flow: pay by hourly data transfer
	// *   day_bandwidth: pay by daily bandwidth
	// *   month\_95: pay by monthly 95th percentile bandwidth
	// *   month_avg_day_bandwidth: pay by average daily peak bandwidth per month
	// *   month\_4th_day_bandwidth: pay by monthly 4th peak bandwidth
	// *   month_avg_day\_95: pay by average daily 95th percentile bandwidth per month
	// *   month\_95\_night_half: pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00
	// *   hour_vas: pay by value-added services per hour
	// *   quic_hour_count: pay by hourly QUIC requests
	// *   day_count: pay by daily requests
	// *   hour_count: pay by hourly requests
	// *   day\_95: pay by daily 95th percentile bandwidth
	BillType *string `json:"BillType,omitempty" xml:"BillType,omitempty"`
	// The billing cycle.
	BillingCycle *string `json:"BillingCycle,omitempty" xml:"BillingCycle,omitempty"`
	// The dimension. Valid values:
	//
	// *   flow: traffic and bandwidth
	// *   vas: value-added services (HTTPS and requests for dynamic content)
	// *   quic: the number of QUIC requests
	// *   websocket: the WebSocket communications protocol
	// *   rtlog2sls: log entries delivered to Log Service in real time
	// *   stationflow: traffic over the internal network
	Dimension *string `json:"Dimension,omitempty" xml:"Dimension,omitempty"`
	// The time when the metering method ended.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the product.
	Product *string `json:"Product,omitempty" xml:"Product,omitempty"`
	// The time when the metering method started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetBillType(v string) *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.BillType = &v
	return s
}

func (s *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetBillingCycle(v string) *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.BillingCycle = &v
	return s
}

func (s *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetDimension(v string) *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.Dimension = &v
	return s
}

func (s *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetEndTime(v string) *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetProduct(v string) *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.Product = &v
	return s
}

func (s *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetStartTime(v string) *DescribeCdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.StartTime = &v
	return s
}

type DescribeCdnUserBillTypeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnUserBillTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnUserBillTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserBillTypeResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserBillTypeResponse) SetHeaders(v map[string]*string) *DescribeCdnUserBillTypeResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnUserBillTypeResponse) SetStatusCode(v int32) *DescribeCdnUserBillTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnUserBillTypeResponse) SetBody(v *DescribeCdnUserBillTypeResponseBody) *DescribeCdnUserBillTypeResponse {
	s.Body = v
	return s
}

type DescribeCdnUserConfigsRequest struct {
	// The configuration that you want to query. Valid values:
	//
	// *   **domain_business_control**: user configurations
	// *   **waf**: Web Application Firewall (WAF) configurations
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s DescribeCdnUserConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserConfigsRequest) SetFunctionName(v string) *DescribeCdnUserConfigsRequest {
	s.FunctionName = &v
	return s
}

type DescribeCdnUserConfigsResponseBody struct {
	// The user configurations.
	Configs []*DescribeCdnUserConfigsResponseBodyConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnUserConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserConfigsResponseBody) SetConfigs(v []*DescribeCdnUserConfigsResponseBodyConfigs) *DescribeCdnUserConfigsResponseBody {
	s.Configs = v
	return s
}

func (s *DescribeCdnUserConfigsResponseBody) SetRequestId(v string) *DescribeCdnUserConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnUserConfigsResponseBodyConfigs struct {
	// The name of the configuration.
	//
	// The configuration is specified by enterprise users and public service sectors.
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The value of the configuration. Valid values:
	//
	// *   **cc_rule**: HTTP flood protection rules
	// *   **ddos_dispatch**: integration with Anti-DDoS
	// *   **edge_safe**: application security settings on POPs
	// *   **blocked_regions**: blocked regions
	// *   **http_acl_policy**: access control list (ACL) rules
	// *   **bot_manager**: bot traffic management
	// *   **ip_reputation**: IP reputation library
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s DescribeCdnUserConfigsResponseBodyConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserConfigsResponseBodyConfigs) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserConfigsResponseBodyConfigs) SetArgName(v string) *DescribeCdnUserConfigsResponseBodyConfigs {
	s.ArgName = &v
	return s
}

func (s *DescribeCdnUserConfigsResponseBodyConfigs) SetArgValue(v string) *DescribeCdnUserConfigsResponseBodyConfigs {
	s.ArgValue = &v
	return s
}

func (s *DescribeCdnUserConfigsResponseBodyConfigs) SetFunctionName(v string) *DescribeCdnUserConfigsResponseBodyConfigs {
	s.FunctionName = &v
	return s
}

type DescribeCdnUserConfigsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnUserConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnUserConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserConfigsResponse) SetHeaders(v map[string]*string) *DescribeCdnUserConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnUserConfigsResponse) SetStatusCode(v int32) *DescribeCdnUserConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnUserConfigsResponse) SetBody(v *DescribeCdnUserConfigsResponseBody) *DescribeCdnUserConfigsResponse {
	s.Body = v
	return s
}

type DescribeCdnUserDomainsByFuncRequest struct {
	// The ID of the feature.
	//
	// For example, the ID of the origin host feature (set_req_host_header) is 18.
	FuncId *int32 `json:"FuncId,omitempty" xml:"FuncId,omitempty"`
	// The number of the page to return. Default value: **1**.
	//
	// Valid values: **1** to **100000**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names to return on each page. Default value: **20**.
	//
	// Valid values: **1** to **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeCdnUserDomainsByFuncRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserDomainsByFuncRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserDomainsByFuncRequest) SetFuncId(v int32) *DescribeCdnUserDomainsByFuncRequest {
	s.FuncId = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncRequest) SetPageNumber(v int32) *DescribeCdnUserDomainsByFuncRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncRequest) SetPageSize(v int32) *DescribeCdnUserDomainsByFuncRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncRequest) SetResourceGroupId(v string) *DescribeCdnUserDomainsByFuncRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeCdnUserDomainsByFuncResponseBody struct {
	// The configurations of the accelerated domain name.
	Domains *DescribeCdnUserDomainsByFuncResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCdnUserDomainsByFuncResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserDomainsByFuncResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserDomainsByFuncResponseBody) SetDomains(v *DescribeCdnUserDomainsByFuncResponseBodyDomains) *DescribeCdnUserDomainsByFuncResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBody) SetPageNumber(v int64) *DescribeCdnUserDomainsByFuncResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBody) SetPageSize(v int64) *DescribeCdnUserDomainsByFuncResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBody) SetRequestId(v string) *DescribeCdnUserDomainsByFuncResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBody) SetTotalCount(v int64) *DescribeCdnUserDomainsByFuncResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCdnUserDomainsByFuncResponseBodyDomains struct {
	PageData []*DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomains) SetPageData(v []*DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) *DescribeCdnUserDomainsByFuncResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData struct {
	// The type of workload accelerated by Alibaba Cloud CDN. Valid values:
	//
	// *   **web**: image and small file distribution
	// *   **download**: large file distribution
	// *   **video**: on-demand video and audio streaming
	// *   **liveStream**: live streaming
	CdnType *string `json:"CdnType,omitempty" xml:"CdnType,omitempty"`
	// The CNAME assigned to the accelerated domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The description of the status.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   **online**: The domain name is enabled.
	// *   **offline**: The domain is disabled.
	// *   **configuring**: The endpoint group is being configured.
	// *   **configure_failed**: The domain failed to be configured.
	// *   **checking**: The domain name is under review.
	// *   **check_failed**: The domain name failed the review.
	// *   **stopping**: The domain name is be disabled.
	// *   **deleting**: being deleted
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the accelerated domain name was added to Alibaba Cloud CDN.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The last time when the accelerated domain was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The information about the origin server.
	Sources *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// Indicates whether HTTPS is enabled. Valid values:
	//
	// *   **on**
	// *   **off**
	SslProtocol *string `json:"SslProtocol,omitempty" xml:"SslProtocol,omitempty"`
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetCdnType(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.CdnType = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetCname(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetDescription(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetDomainName(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetResourceGroupId(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetSources(v *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData) SetSslProtocol(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.SslProtocol = &v
	return s
}

type DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources struct {
	Source []*DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources) SetSource(v []*DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The port of the origin server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority of the configuration item.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetWeight(v string) *DescribeCdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Weight = &v
	return s
}

type DescribeCdnUserDomainsByFuncResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnUserDomainsByFuncResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnUserDomainsByFuncResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserDomainsByFuncResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserDomainsByFuncResponse) SetHeaders(v map[string]*string) *DescribeCdnUserDomainsByFuncResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponse) SetStatusCode(v int32) *DescribeCdnUserDomainsByFuncResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnUserDomainsByFuncResponse) SetBody(v *DescribeCdnUserDomainsByFuncResponseBody) *DescribeCdnUserDomainsByFuncResponse {
	s.Body = v
	return s
}

type DescribeCdnUserQuotaRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeCdnUserQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserQuotaRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserQuotaRequest) SetOwnerId(v int64) *DescribeCdnUserQuotaRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnUserQuotaRequest) SetSecurityToken(v string) *DescribeCdnUserQuotaRequest {
	s.SecurityToken = &v
	return s
}

type DescribeCdnUserQuotaResponseBody struct {
	// The maximum number of URLs and directories that can be blocked.
	BlockQuota *int32 `json:"BlockQuota,omitempty" xml:"BlockQuota,omitempty"`
	// The remaining number of URLs and directories that can be blocked.
	BlockRemain *int32 `json:"BlockRemain,omitempty" xml:"BlockRemain,omitempty"`
	// The maximum number of accelerated domain names.
	DomainQuota        *int32 `json:"DomainQuota,omitempty" xml:"DomainQuota,omitempty"`
	IgnoreParamsQuota  *int32 `json:"IgnoreParamsQuota,omitempty" xml:"IgnoreParamsQuota,omitempty"`
	IgnoreParamsRemain *int32 `json:"IgnoreParamsRemain,omitempty" xml:"IgnoreParamsRemain,omitempty"`
	// The maximum number of URLs that can be prefetched.
	PreloadQuota *int32 `json:"PreloadQuota,omitempty" xml:"PreloadQuota,omitempty"`
	// The remaining number of URLs that can be prefetched.
	PreloadRemain *int32 `json:"PreloadRemain,omitempty" xml:"PreloadRemain,omitempty"`
	// The maximum number of directories that can be refreshed.
	RefreshDirQuota *int32 `json:"RefreshDirQuota,omitempty" xml:"RefreshDirQuota,omitempty"`
	// The remaining number of directories that can be refreshed.
	RefreshDirRemain *int32 `json:"RefreshDirRemain,omitempty" xml:"RefreshDirRemain,omitempty"`
	// The maximum number of URLs that can be refreshed.
	RefreshUrlQuota *int32 `json:"RefreshUrlQuota,omitempty" xml:"RefreshUrlQuota,omitempty"`
	// The remaining number of URLs that can be refreshed.
	RefreshUrlRemain *int32 `json:"RefreshUrlRemain,omitempty" xml:"RefreshUrlRemain,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCdnUserQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserQuotaResponseBody) SetBlockQuota(v int32) *DescribeCdnUserQuotaResponseBody {
	s.BlockQuota = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetBlockRemain(v int32) *DescribeCdnUserQuotaResponseBody {
	s.BlockRemain = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetDomainQuota(v int32) *DescribeCdnUserQuotaResponseBody {
	s.DomainQuota = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetIgnoreParamsQuota(v int32) *DescribeCdnUserQuotaResponseBody {
	s.IgnoreParamsQuota = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetIgnoreParamsRemain(v int32) *DescribeCdnUserQuotaResponseBody {
	s.IgnoreParamsRemain = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetPreloadQuota(v int32) *DescribeCdnUserQuotaResponseBody {
	s.PreloadQuota = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetPreloadRemain(v int32) *DescribeCdnUserQuotaResponseBody {
	s.PreloadRemain = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetRefreshDirQuota(v int32) *DescribeCdnUserQuotaResponseBody {
	s.RefreshDirQuota = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetRefreshDirRemain(v int32) *DescribeCdnUserQuotaResponseBody {
	s.RefreshDirRemain = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetRefreshUrlQuota(v int32) *DescribeCdnUserQuotaResponseBody {
	s.RefreshUrlQuota = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetRefreshUrlRemain(v int32) *DescribeCdnUserQuotaResponseBody {
	s.RefreshUrlRemain = &v
	return s
}

func (s *DescribeCdnUserQuotaResponseBody) SetRequestId(v string) *DescribeCdnUserQuotaResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCdnUserQuotaResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnUserQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnUserQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserQuotaResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserQuotaResponse) SetHeaders(v map[string]*string) *DescribeCdnUserQuotaResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnUserQuotaResponse) SetStatusCode(v int32) *DescribeCdnUserQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnUserQuotaResponse) SetBody(v *DescribeCdnUserQuotaResponseBody) *DescribeCdnUserQuotaResponse {
	s.Body = v
	return s
}

type DescribeCdnUserResourcePackageRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The status of the resource plan that you want to query. Valid values:
	//
	// *   **valid**: valid
	// *   **closed**: expired
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCdnUserResourcePackageRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserResourcePackageRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserResourcePackageRequest) SetOwnerId(v int64) *DescribeCdnUserResourcePackageRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCdnUserResourcePackageRequest) SetSecurityToken(v string) *DescribeCdnUserResourcePackageRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeCdnUserResourcePackageRequest) SetStatus(v string) *DescribeCdnUserResourcePackageRequest {
	s.Status = &v
	return s
}

type DescribeCdnUserResourcePackageResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The detailed information about resource plans. The returned information is displayed in an array of ResourcePackageInfo nodes.
	ResourcePackageInfos *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos `json:"ResourcePackageInfos,omitempty" xml:"ResourcePackageInfos,omitempty" type:"Struct"`
}

func (s DescribeCdnUserResourcePackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserResourcePackageResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserResourcePackageResponseBody) SetRequestId(v string) *DescribeCdnUserResourcePackageResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBody) SetResourcePackageInfos(v *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos) *DescribeCdnUserResourcePackageResponseBody {
	s.ResourcePackageInfos = v
	return s
}

type DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos struct {
	ResourcePackageInfo []*DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo `json:"ResourcePackageInfo,omitempty" xml:"ResourcePackageInfo,omitempty" type:"Repeated"`
}

func (s DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos) SetResourcePackageInfo(v []*DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfos {
	s.ResourcePackageInfo = v
	return s
}

type DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo struct {
	// The ID of the resource plan.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The remaining quota of the resource plan.
	//
	// *   For a data transfer plan, the quota is measured in bytes.
	// *   For a request resource plan, the quota is measured in the number of requests.
	CurrCapacity *string `json:"CurrCapacity,omitempty" xml:"CurrCapacity,omitempty"`
	// The name of the resource plan.
	DisplayName *string `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	// The expiration time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The total quota of the resource plan.
	//
	// *   For a data transfer plan, the quota is measured in bytes.
	// *   For a request resource plan, the quota is measured in the number of requests.
	InitCapacity *string `json:"InitCapacity,omitempty" xml:"InitCapacity,omitempty"`
	// The ID of the instance
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The effective time.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the resource plan. Valid values:
	//
	// *   **valid**: valid
	// *   **closed**: expired
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The name of the template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetCommodityCode(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.CommodityCode = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetCurrCapacity(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.CurrCapacity = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetDisplayName(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.DisplayName = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetEndTime(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.EndTime = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetInitCapacity(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.InitCapacity = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetInstanceId(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.InstanceId = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetStartTime(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.StartTime = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetStatus(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.Status = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetTemplateName(v string) *DescribeCdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.TemplateName = &v
	return s
}

type DescribeCdnUserResourcePackageResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnUserResourcePackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnUserResourcePackageResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnUserResourcePackageResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnUserResourcePackageResponse) SetHeaders(v map[string]*string) *DescribeCdnUserResourcePackageResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnUserResourcePackageResponse) SetStatusCode(v int32) *DescribeCdnUserResourcePackageResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnUserResourcePackageResponse) SetBody(v *DescribeCdnUserResourcePackageResponseBody) *DescribeCdnUserResourcePackageResponse {
	s.Body = v
	return s
}

type DescribeCdnWafDomainRequest struct {
	// The domain name that you want to query.
	//
	// You can specify only one domain name in each request. You have three options to configure this parameter:
	//
	// *   Specify an exact domain name. For example, if you set this parameter to example.com, configuration information of example.com is queried.
	// *   Specify a keyword. For example, if you set this parameter to example, configuration information about all domain names that contain example is queried.
	// *   Leave this parameter empty. If this parameter is left empty, all accelerated domain names for which WAF is configured are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The region where WAF is enabled. Valid values:
	//
	// *   **cn-hangzhou**: inside the Chinese mainland
	// *   **ap-southeast-1**: outside the Chinese mainland
	//
	// > ap-southeast-1 includes Hong Kong (China), Macao (China), Taiwan (China), and other countries and regions.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeCdnWafDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnWafDomainRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdnWafDomainRequest) SetDomainName(v string) *DescribeCdnWafDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCdnWafDomainRequest) SetRegionId(v string) *DescribeCdnWafDomainRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCdnWafDomainRequest) SetResourceGroupId(v string) *DescribeCdnWafDomainRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeCdnWafDomainResponseBody struct {
	// The information about the accelerated domain name.
	OutPutDomains []*DescribeCdnWafDomainResponseBodyOutPutDomains `json:"OutPutDomains,omitempty" xml:"OutPutDomains,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of accelerated domain names.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCdnWafDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnWafDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdnWafDomainResponseBody) SetOutPutDomains(v []*DescribeCdnWafDomainResponseBodyOutPutDomains) *DescribeCdnWafDomainResponseBody {
	s.OutPutDomains = v
	return s
}

func (s *DescribeCdnWafDomainResponseBody) SetRequestId(v string) *DescribeCdnWafDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdnWafDomainResponseBody) SetTotalCount(v int32) *DescribeCdnWafDomainResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCdnWafDomainResponseBodyOutPutDomains struct {
	// The status of the access control list (ACL) feature. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The status of protection against HTTP flood attacks. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	CcStatus *string `json:"CcStatus,omitempty" xml:"CcStatus,omitempty"`
	// The accelerated domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The WAF status of the domain name. Valid values:
	//
	// *   **1**: The domain name is added to WAF or valid.
	// *   **10**: The domain name is being added to WAF.
	// *   **11**: The domain name failed to be added to WAF.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The status of WAF. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	WafStatus *string `json:"WafStatus,omitempty" xml:"WafStatus,omitempty"`
}

func (s DescribeCdnWafDomainResponseBodyOutPutDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnWafDomainResponseBodyOutPutDomains) GoString() string {
	return s.String()
}

func (s *DescribeCdnWafDomainResponseBodyOutPutDomains) SetAclStatus(v string) *DescribeCdnWafDomainResponseBodyOutPutDomains {
	s.AclStatus = &v
	return s
}

func (s *DescribeCdnWafDomainResponseBodyOutPutDomains) SetCcStatus(v string) *DescribeCdnWafDomainResponseBodyOutPutDomains {
	s.CcStatus = &v
	return s
}

func (s *DescribeCdnWafDomainResponseBodyOutPutDomains) SetDomain(v string) *DescribeCdnWafDomainResponseBodyOutPutDomains {
	s.Domain = &v
	return s
}

func (s *DescribeCdnWafDomainResponseBodyOutPutDomains) SetStatus(v string) *DescribeCdnWafDomainResponseBodyOutPutDomains {
	s.Status = &v
	return s
}

func (s *DescribeCdnWafDomainResponseBodyOutPutDomains) SetWafStatus(v string) *DescribeCdnWafDomainResponseBodyOutPutDomains {
	s.WafStatus = &v
	return s
}

type DescribeCdnWafDomainResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdnWafDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdnWafDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdnWafDomainResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdnWafDomainResponse) SetHeaders(v map[string]*string) *DescribeCdnWafDomainResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdnWafDomainResponse) SetStatusCode(v int32) *DescribeCdnWafDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdnWafDomainResponse) SetBody(v *DescribeCdnWafDomainResponseBody) *DescribeCdnWafDomainResponse {
	s.Body = v
	return s
}

type DescribeCertificateInfoByIDRequest struct {
	// The ID of the certificate. You can query only one certificate in each call.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
}

func (s DescribeCertificateInfoByIDRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertificateInfoByIDRequest) GoString() string {
	return s.String()
}

func (s *DescribeCertificateInfoByIDRequest) SetCertId(v string) *DescribeCertificateInfoByIDRequest {
	s.CertId = &v
	return s
}

type DescribeCertificateInfoByIDResponseBody struct {
	// The information about the certificate.
	CertInfos *DescribeCertificateInfoByIDResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCertificateInfoByIDResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertificateInfoByIDResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCertificateInfoByIDResponseBody) SetCertInfos(v *DescribeCertificateInfoByIDResponseBodyCertInfos) *DescribeCertificateInfoByIDResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeCertificateInfoByIDResponseBody) SetRequestId(v string) *DescribeCertificateInfoByIDResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCertificateInfoByIDResponseBodyCertInfos struct {
	CertInfo []*DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeCertificateInfoByIDResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertificateInfoByIDResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfos) SetCertInfo(v []*DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) *DescribeCertificateInfoByIDResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo struct {
	// The time at which the certificate expires.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The ID of the certificate.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The type of the certificate.
	//
	// *   free: a free certificate
	// *   cas: a certificate purchased by using Certificate Management Service
	// *   upload: a user-uploaded certificate
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The time when the certificate became effective.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The domain names that use the certificate.
	DomainList *string `json:"DomainList,omitempty" xml:"DomainList,omitempty"`
	// The content of the certificate.
	HttpsCrt *string `json:"HttpsCrt,omitempty" xml:"HttpsCrt,omitempty"`
}

func (s DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) SetCertId(v string) *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo {
	s.CertId = &v
	return s
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) SetCertName(v string) *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo {
	s.CertName = &v
	return s
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) SetCreateTime(v string) *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo {
	s.CreateTime = &v
	return s
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) SetDomainList(v string) *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo {
	s.DomainList = &v
	return s
}

func (s *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo) SetHttpsCrt(v string) *DescribeCertificateInfoByIDResponseBodyCertInfosCertInfo {
	s.HttpsCrt = &v
	return s
}

type DescribeCertificateInfoByIDResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCertificateInfoByIDResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCertificateInfoByIDResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertificateInfoByIDResponse) GoString() string {
	return s.String()
}

func (s *DescribeCertificateInfoByIDResponse) SetHeaders(v map[string]*string) *DescribeCertificateInfoByIDResponse {
	s.Headers = v
	return s
}

func (s *DescribeCertificateInfoByIDResponse) SetStatusCode(v int32) *DescribeCertificateInfoByIDResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCertificateInfoByIDResponse) SetBody(v *DescribeCertificateInfoByIDResponseBody) *DescribeCertificateInfoByIDResponse {
	s.Body = v
	return s
}

type DescribeCustomLogConfigRequest struct {
	// The ID of the custom configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
}

func (s DescribeCustomLogConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLogConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomLogConfigRequest) SetConfigId(v string) *DescribeCustomLogConfigRequest {
	s.ConfigId = &v
	return s
}

type DescribeCustomLogConfigResponseBody struct {
	// The format of the log configuration.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The sample.
	Sample *string `json:"Sample,omitempty" xml:"Sample,omitempty"`
	// The tag information about the log configuration.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s DescribeCustomLogConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLogConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomLogConfigResponseBody) SetRemark(v string) *DescribeCustomLogConfigResponseBody {
	s.Remark = &v
	return s
}

func (s *DescribeCustomLogConfigResponseBody) SetRequestId(v string) *DescribeCustomLogConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomLogConfigResponseBody) SetSample(v string) *DescribeCustomLogConfigResponseBody {
	s.Sample = &v
	return s
}

func (s *DescribeCustomLogConfigResponseBody) SetTag(v string) *DescribeCustomLogConfigResponseBody {
	s.Tag = &v
	return s
}

type DescribeCustomLogConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomLogConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomLogConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLogConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomLogConfigResponse) SetHeaders(v map[string]*string) *DescribeCustomLogConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomLogConfigResponse) SetStatusCode(v int32) *DescribeCustomLogConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomLogConfigResponse) SetBody(v *DescribeCustomLogConfigResponseBody) *DescribeCustomLogConfigResponse {
	s.Body = v
	return s
}

type DescribeDomainAverageResponseTimeRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// By default, this operation queries the geographic distribution of users for all accelerated domain names.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The type of the query condition. When you set the value to dynamic, this operation queries the average response time of dynamic resources and static resources. If you do not set this parameter, this operation queries the average response time of only static resources.
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries. Unit: seconds. The value varies based on the values of the **StartTime** and **EndTime** parameters. Valid values:
	//
	// *   If the time span between StartTime and EndTime is less than 3 days, valid values are **300**, **3600**, and **86400**. Default value: **300**.
	// *   If the time span between StartTime and EndTime is greater than or equal to 3 days and less than 31 days, valid values are **3600** and **86400**. Default value: **3600**.
	// *   If the time range between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP) for your Alibaba Cloud CDN service. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISPs. If you do not set this parameter, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions. If you do not set this parameter, data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// Specifies whether to automatically set the interval. If you set the value to 1, the value of the Interval parameter is automatically assigned based on the StartTime and EndTime parameters. You can set this parameter or the Interval parameter.
	TimeMerge *string `json:"TimeMerge,omitempty" xml:"TimeMerge,omitempty"`
}

func (s DescribeDomainAverageResponseTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAverageResponseTimeRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainAverageResponseTimeRequest) SetDomainName(v string) *DescribeDomainAverageResponseTimeRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeRequest) SetDomainType(v string) *DescribeDomainAverageResponseTimeRequest {
	s.DomainType = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeRequest) SetEndTime(v string) *DescribeDomainAverageResponseTimeRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeRequest) SetInterval(v string) *DescribeDomainAverageResponseTimeRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeRequest) SetIspNameEn(v string) *DescribeDomainAverageResponseTimeRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeRequest) SetLocationNameEn(v string) *DescribeDomainAverageResponseTimeRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeRequest) SetStartTime(v string) *DescribeDomainAverageResponseTimeRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeRequest) SetTimeMerge(v string) *DescribeDomainAverageResponseTimeRequest {
	s.TimeMerge = &v
	return s
}

type DescribeDomainAverageResponseTimeResponseBody struct {
	// The average response time data for time intervals.
	AvgRTPerInterval *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval `json:"AvgRTPerInterval,omitempty" xml:"AvgRTPerInterval,omitempty" type:"Struct"`
	// The time interval between the data entries returned.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainAverageResponseTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAverageResponseTimeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainAverageResponseTimeResponseBody) SetAvgRTPerInterval(v *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval) *DescribeDomainAverageResponseTimeResponseBody {
	s.AvgRTPerInterval = v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponseBody) SetDataInterval(v string) *DescribeDomainAverageResponseTimeResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponseBody) SetDomainName(v string) *DescribeDomainAverageResponseTimeResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponseBody) SetEndTime(v string) *DescribeDomainAverageResponseTimeResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponseBody) SetRequestId(v string) *DescribeDomainAverageResponseTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponseBody) SetStartTime(v string) *DescribeDomainAverageResponseTimeResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval struct {
	DataModule []*DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval) SetDataModule(v []*DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule) *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The average response time.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule) SetValue(v string) *DescribeDomainAverageResponseTimeResponseBodyAvgRTPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainAverageResponseTimeResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainAverageResponseTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainAverageResponseTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAverageResponseTimeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainAverageResponseTimeResponse) SetHeaders(v map[string]*string) *DescribeDomainAverageResponseTimeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponse) SetStatusCode(v int32) *DescribeDomainAverageResponseTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainAverageResponseTimeResponse) SetBody(v *DescribeDomainAverageResponseTimeResponseBody) *DescribeDomainAverageResponseTimeResponse {
	s.Body = v
	return s
}

type DescribeDomainBpsDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries bandwidth data for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISP names.
	//
	// If you do not set this parameter, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	//
	// If you do not specify a region, data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataRequest) SetDomainName(v string) *DescribeDomainBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainBpsDataRequest) SetEndTime(v string) *DescribeDomainBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainBpsDataRequest) SetInterval(v string) *DescribeDomainBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainBpsDataRequest) SetIspNameEn(v string) *DescribeDomainBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainBpsDataRequest) SetLocationNameEn(v string) *DescribeDomainBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainBpsDataRequest) SetStartTime(v string) *DescribeDomainBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainBpsDataResponseBody struct {
	// The list of bandwidth data entries returned at each interval.
	BpsDataPerInterval *DescribeDomainBpsDataResponseBodyBpsDataPerInterval `json:"BpsDataPerInterval,omitempty" xml:"BpsDataPerInterval,omitempty" type:"Struct"`
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the ISP.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataResponseBody) SetBpsDataPerInterval(v *DescribeDomainBpsDataResponseBodyBpsDataPerInterval) *DescribeDomainBpsDataResponseBody {
	s.BpsDataPerInterval = v
	return s
}

func (s *DescribeDomainBpsDataResponseBody) SetDataInterval(v string) *DescribeDomainBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBody) SetDomainName(v string) *DescribeDomainBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBody) SetEndTime(v string) *DescribeDomainBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBody) SetIspNameEn(v string) *DescribeDomainBpsDataResponseBody {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBody) SetLocationNameEn(v string) *DescribeDomainBpsDataResponseBody {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBody) SetRequestId(v string) *DescribeDomainBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBody) SetStartTime(v string) *DescribeDomainBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainBpsDataResponseBodyBpsDataPerInterval struct {
	DataModule []*DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainBpsDataResponseBodyBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataResponseBodyBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerInterval) SetDataModule(v []*DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) *DescribeDomainBpsDataResponseBodyBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule struct {
	// The bandwidth value in the Chinese mainland. When the bandwidth data is queried by ISP, this parameter is empty.
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The bandwidth data for HTTPS requests in the Chinese mainland. When the bandwidth data is queried by ISP, this parameter is empty.
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	// The bandwidth data for HTTPS requests in regions outside the Chinese mainland. When the bandwidth data is queried by ISP, this parameter is empty.
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	// The bandwidth value for HTTPS requests. Unit: bit/s.
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The bandwidth data in regions outside the Chinese mainland. When the bandwidth data is queried by ISP, this parameter is empty.
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The bandwidth. Unit: bit/s.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetDomesticValue(v string) *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetOverseasValue(v string) *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetValue(v string) *DescribeDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainBpsDataResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainBpsDataResponse) SetStatusCode(v int32) *DescribeDomainBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainBpsDataResponse) SetBody(v *DescribeDomainBpsDataResponseBody) *DescribeDomainBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainBpsDataByLayerRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// > If you do not specify this parameter, the bandwidth data about all accelerated domain names that belong to your Alibaba Cloud account is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~DescribeCdnRegionAndIsp~~) operation to query ISPs. If you do not specify an ISP, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The layer at which you want to query the bandwidth data. Valid values:
	//
	// *   Network layer: **IPv4** and **IPv6**.
	// *   Application layer: **http**, **https**, and **quic**.
	// *   **all**: specifies that both the network and application layers are included.
	//
	// Default value: **all**.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~DescribeCdnRegionAndIsp~~) operation to query regions. If you do not specify a region, data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainBpsDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByLayerRequest) SetDomainName(v string) *DescribeDomainBpsDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerRequest) SetEndTime(v string) *DescribeDomainBpsDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerRequest) SetInterval(v string) *DescribeDomainBpsDataByLayerRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerRequest) SetIspNameEn(v string) *DescribeDomainBpsDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerRequest) SetLayer(v string) *DescribeDomainBpsDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerRequest) SetLocationNameEn(v string) *DescribeDomainBpsDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerRequest) SetStartTime(v string) *DescribeDomainBpsDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainBpsDataByLayerResponseBody struct {
	// The data returned at each time interval.
	BpsDataInterval *DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval `json:"BpsDataInterval,omitempty" xml:"BpsDataInterval,omitempty" type:"Struct"`
	// The time interval between the data entries. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainBpsDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByLayerResponseBody) SetBpsDataInterval(v *DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval) *DescribeDomainBpsDataByLayerResponseBody {
	s.BpsDataInterval = v
	return s
}

func (s *DescribeDomainBpsDataByLayerResponseBody) SetDataInterval(v string) *DescribeDomainBpsDataByLayerResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerResponseBody) SetRequestId(v string) *DescribeDomainBpsDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval struct {
	DataModule []*DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval) SetDataModule(v []*DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) *DescribeDomainBpsDataByLayerResponseBodyBpsDataInterval {
	s.DataModule = v
	return s
}

type DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total amount of network traffic. Unit: bytes.
	TrafficValue *string `json:"TrafficValue,omitempty" xml:"TrafficValue,omitempty"`
	// The peak bandwidth value. Unit: bit/s.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetTimeStamp(v string) *DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetTrafficValue(v string) *DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.TrafficValue = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetValue(v string) *DescribeDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainBpsDataByLayerResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainBpsDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainBpsDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeDomainBpsDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainBpsDataByLayerResponse) SetStatusCode(v int32) *DescribeDomainBpsDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainBpsDataByLayerResponse) SetBody(v *DescribeDomainBpsDataByLayerResponseBody) *DescribeDomainBpsDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeDomainBpsDataByTimeStampRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The names of the Internet service providers (ISPs). Separate multiple ISPs with commas (,).
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	IspNames *string `json:"IspNames,omitempty" xml:"IspNames,omitempty"`
	// The regions. Separate multiple regions with commas (,).
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	LocationNames *string `json:"LocationNames,omitempty" xml:"LocationNames,omitempty"`
	// The point in time to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The data is collected every 5 minutes.
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s DescribeDomainBpsDataByTimeStampRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByTimeStampRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByTimeStampRequest) SetDomainName(v string) *DescribeDomainBpsDataByTimeStampRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampRequest) SetIspNames(v string) *DescribeDomainBpsDataByTimeStampRequest {
	s.IspNames = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampRequest) SetLocationNames(v string) *DescribeDomainBpsDataByTimeStampRequest {
	s.LocationNames = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampRequest) SetTimePoint(v string) *DescribeDomainBpsDataByTimeStampRequest {
	s.TimePoint = &v
	return s
}

type DescribeDomainBpsDataByTimeStampResponseBody struct {
	// A list of bandwidth values by ISP and region.
	BpsDataList *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList `json:"BpsDataList,omitempty" xml:"BpsDataList,omitempty" type:"Struct"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The point in time.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDomainBpsDataByTimeStampResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByTimeStampResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByTimeStampResponseBody) SetBpsDataList(v *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList) *DescribeDomainBpsDataByTimeStampResponseBody {
	s.BpsDataList = v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponseBody) SetDomainName(v string) *DescribeDomainBpsDataByTimeStampResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponseBody) SetRequestId(v string) *DescribeDomainBpsDataByTimeStampResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponseBody) SetTimeStamp(v string) *DescribeDomainBpsDataByTimeStampResponseBody {
	s.TimeStamp = &v
	return s
}

type DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList struct {
	BpsDataModel []*DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel `json:"BpsDataModel,omitempty" xml:"BpsDataModel,omitempty" type:"Repeated"`
}

func (s DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList) SetBpsDataModel(v []*DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel) *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataList {
	s.BpsDataModel = v
	return s
}

type DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel struct {
	// The bandwidth value.
	Bps *int64 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The name of the ISP.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
	// The name of the region.
	LocationName *string `json:"LocationName,omitempty" xml:"LocationName,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel) SetBps(v int64) *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel {
	s.Bps = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel) SetIspName(v string) *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel {
	s.IspName = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel) SetLocationName(v string) *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel {
	s.LocationName = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel) SetTimeStamp(v string) *DescribeDomainBpsDataByTimeStampResponseBodyBpsDataListBpsDataModel {
	s.TimeStamp = &v
	return s
}

type DescribeDomainBpsDataByTimeStampResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainBpsDataByTimeStampResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainBpsDataByTimeStampResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainBpsDataByTimeStampResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainBpsDataByTimeStampResponse) SetHeaders(v map[string]*string) *DescribeDomainBpsDataByTimeStampResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponse) SetStatusCode(v int32) *DescribeDomainBpsDataByTimeStampResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainBpsDataByTimeStampResponse) SetBody(v *DescribeDomainBpsDataByTimeStampResponseBody) *DescribeDomainBpsDataByTimeStampResponse {
	s.Body = v
	return s
}

type DescribeDomainCcActivityLogRequest struct {
	// The accelerated domain name. You can specify multiple domain names and separate them with commas (,).
	//
	// If you do not specify this parameter, data of all accelerated domain names under your account is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The page number of the page to return. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **30**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// A custom rule name. Valid values:
	//
	// *   default_normal: rule for the normal mode
	// *   default_attack: rule for the emergency mode
	//
	// If you leave this parameter empty, events that triggered rate limiting based on all rules are queried.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum time granularity of data collection is 5 minutes.
	//
	// If you leave this parameter empty, the data collected over the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The trigger of rate limiting by which you want to query data.
	//
	// If you leave this parameter empty, all events that triggered rate limiting are queried.
	TriggerObject *string `json:"TriggerObject,omitempty" xml:"TriggerObject,omitempty"`
	// The value of the trigger.
	//
	// If you leave this parameter empty, all events recorded for the trigger are queried.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainCcActivityLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCcActivityLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainCcActivityLogRequest) SetDomainName(v string) *DescribeDomainCcActivityLogRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainCcActivityLogRequest) SetEndTime(v string) *DescribeDomainCcActivityLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainCcActivityLogRequest) SetPageNumber(v int64) *DescribeDomainCcActivityLogRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainCcActivityLogRequest) SetPageSize(v int64) *DescribeDomainCcActivityLogRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainCcActivityLogRequest) SetRuleName(v string) *DescribeDomainCcActivityLogRequest {
	s.RuleName = &v
	return s
}

func (s *DescribeDomainCcActivityLogRequest) SetStartTime(v string) *DescribeDomainCcActivityLogRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainCcActivityLogRequest) SetTriggerObject(v string) *DescribeDomainCcActivityLogRequest {
	s.TriggerObject = &v
	return s
}

func (s *DescribeDomainCcActivityLogRequest) SetValue(v string) *DescribeDomainCcActivityLogRequest {
	s.Value = &v
	return s
}

type DescribeDomainCcActivityLogResponseBody struct {
	// The list of rate limiting logs.
	ActivityLog []*DescribeDomainCcActivityLogResponseBodyActivityLog `json:"ActivityLog,omitempty" xml:"ActivityLog,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageIndex *int64 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeDomainCcActivityLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCcActivityLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainCcActivityLogResponseBody) SetActivityLog(v []*DescribeDomainCcActivityLogResponseBodyActivityLog) *DescribeDomainCcActivityLogResponseBody {
	s.ActivityLog = v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBody) SetPageIndex(v int64) *DescribeDomainCcActivityLogResponseBody {
	s.PageIndex = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBody) SetPageSize(v int64) *DescribeDomainCcActivityLogResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBody) SetRequestId(v string) *DescribeDomainCcActivityLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBody) SetTotal(v int64) *DescribeDomainCcActivityLogResponseBody {
	s.Total = &v
	return s
}

type DescribeDomainCcActivityLogResponseBodyActivityLog struct {
	// The action that was triggered.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the rule based on which rate limiting was triggered.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The trigger of rate limiting.
	TriggerObject *string `json:"TriggerObject,omitempty" xml:"TriggerObject,omitempty"`
	// The period of time during which rate limiting remains effective.
	Ttl *int64 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The value of the trigger for rate limiting.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainCcActivityLogResponseBodyActivityLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCcActivityLogResponseBodyActivityLog) GoString() string {
	return s.String()
}

func (s *DescribeDomainCcActivityLogResponseBodyActivityLog) SetAction(v string) *DescribeDomainCcActivityLogResponseBodyActivityLog {
	s.Action = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBodyActivityLog) SetDomainName(v string) *DescribeDomainCcActivityLogResponseBodyActivityLog {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBodyActivityLog) SetRuleName(v string) *DescribeDomainCcActivityLogResponseBodyActivityLog {
	s.RuleName = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBodyActivityLog) SetTimeStamp(v string) *DescribeDomainCcActivityLogResponseBodyActivityLog {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBodyActivityLog) SetTriggerObject(v string) *DescribeDomainCcActivityLogResponseBodyActivityLog {
	s.TriggerObject = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBodyActivityLog) SetTtl(v int64) *DescribeDomainCcActivityLogResponseBodyActivityLog {
	s.Ttl = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponseBodyActivityLog) SetValue(v string) *DescribeDomainCcActivityLogResponseBodyActivityLog {
	s.Value = &v
	return s
}

type DescribeDomainCcActivityLogResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainCcActivityLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainCcActivityLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCcActivityLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainCcActivityLogResponse) SetHeaders(v map[string]*string) *DescribeDomainCcActivityLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainCcActivityLogResponse) SetStatusCode(v int32) *DescribeDomainCcActivityLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainCcActivityLogResponse) SetBody(v *DescribeDomainCcActivityLogResponseBody) *DescribeDomainCcActivityLogResponse {
	s.Body = v
	return s
}

type DescribeDomainCertificateInfoRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDomainCertificateInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCertificateInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainCertificateInfoRequest) SetDomainName(v string) *DescribeDomainCertificateInfoRequest {
	s.DomainName = &v
	return s
}

type DescribeDomainCertificateInfoResponseBody struct {
	// The information about the certificate.
	CertInfos *DescribeDomainCertificateInfoResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainCertificateInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCertificateInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainCertificateInfoResponseBody) SetCertInfos(v *DescribeDomainCertificateInfoResponseBodyCertInfos) *DescribeDomainCertificateInfoResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBody) SetRequestId(v string) *DescribeDomainCertificateInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainCertificateInfoResponseBodyCertInfos struct {
	CertInfo []*DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeDomainCertificateInfoResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCertificateInfoResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfos) SetCertInfo(v []*DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) *DescribeDomainCertificateInfoResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo struct {
	// The domain name that matches the certificate.
	CertDomainName *string `json:"CertDomainName,omitempty" xml:"CertDomainName,omitempty"`
	// The time at which the certificate expires.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The ID of the certificate.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The unit of the validity period of the certificate. Valid values:
	//
	// *   **months**
	// *   **years**
	CertLife *string `json:"CertLife,omitempty" xml:"CertLife,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The name of the certificate authority (CA) that issued the certificate.
	CertOrg *string `json:"CertOrg,omitempty" xml:"CertOrg,omitempty"`
	// The region where the certificate is used.
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The time when the certificate became effective.
	CertStartTime *string `json:"CertStartTime,omitempty" xml:"CertStartTime,omitempty"`
	// The type of the certificate.
	//
	// *   **free**: a free certificate
	// *   **cas**: a certificate that is purchased by using Certificate Management Service
	// *   **upload**: a custom certificate that you upload
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The time at which the certificate was updated.
	CertUpdateTime *string `json:"CertUpdateTime,omitempty" xml:"CertUpdateTime,omitempty"`
	// The CANME status of the domain name.
	//
	// *   **ok**: The domain name points to the CNAME assigned by Alibaba Cloud CDN.
	// *   **cname_error**: An error occurred and the domain name cannot point to the CNAME.
	// *   **op_domain_cname_error** : An error occurred to the CNAME of the top-level domain. The domain name cannot point to the CNAME.
	// *   **unsupport_wildcard**: The wildcard domain name is not supported.
	DomainCnameStatus *string `json:"DomainCnameStatus,omitempty" xml:"DomainCnameStatus,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The public key of the certificate.
	ServerCertificate *string `json:"ServerCertificate,omitempty" xml:"ServerCertificate,omitempty"`
	// The status of HTTPS.
	//
	// *   **on**
	// *   **off**
	ServerCertificateStatus *string `json:"ServerCertificateStatus,omitempty" xml:"ServerCertificateStatus,omitempty"`
	// The status of the certificate. Valid values:
	//
	// *   **success**: The certificate has taken effect.
	// *   **checking**: The system is checking whether the domain name is using Alibaba Cloud CDN.
	// *   **cname_error**: No valid CNAME record has been added for the domain name.
	// *   **top_domain_cname_error**: No valid CNAME record has been added for the top-level domain.
	// *   **domain_invalid**: The domain name contains invalid characters.
	// *   **unsupport_wildcard**: The domain name is a wildcard domain name. Wildcard domain names are not supported.
	// *   **applying**: The certificate application is in progress.
	// *   **get_token_timeout**: The certificate application request has timed out.
	// *   **check_token_timeout**: The verification has timed out.
	// *   **get_cert_timeout**: The request to obtain the certificate has timed out.
	// *   **failed**: The certificate application request failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertDomainName(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertDomainName = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertId(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertId = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertLife(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertLife = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertName(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertName = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertOrg(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertOrg = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertRegion(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertRegion = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertStartTime(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertStartTime = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertUpdateTime(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertUpdateTime = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetDomainCnameStatus(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.DomainCnameStatus = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetDomainName(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetServerCertificate(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.ServerCertificate = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetServerCertificateStatus(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.ServerCertificateStatus = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo) SetStatus(v string) *DescribeDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.Status = &v
	return s
}

type DescribeDomainCertificateInfoResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainCertificateInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainCertificateInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCertificateInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainCertificateInfoResponse) SetHeaders(v map[string]*string) *DescribeDomainCertificateInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainCertificateInfoResponse) SetStatusCode(v int32) *DescribeDomainCertificateInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainCertificateInfoResponse) SetBody(v *DescribeDomainCertificateInfoResponseBody) *DescribeDomainCertificateInfoResponse {
	s.Body = v
	return s
}

type DescribeDomainCnameRequest struct {
	// The accelerated domain name that you want to query. Separate multiple domain names with commas (,). This parameter cannot be left empty.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDomainCnameRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCnameRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainCnameRequest) SetDomainName(v string) *DescribeDomainCnameRequest {
	s.DomainName = &v
	return s
}

type DescribeDomainCnameResponseBody struct {
	// Details about the CNAME detection results.
	CnameDatas *DescribeDomainCnameResponseBodyCnameDatas `json:"CnameDatas,omitempty" xml:"CnameDatas,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainCnameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCnameResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainCnameResponseBody) SetCnameDatas(v *DescribeDomainCnameResponseBodyCnameDatas) *DescribeDomainCnameResponseBody {
	s.CnameDatas = v
	return s
}

func (s *DescribeDomainCnameResponseBody) SetRequestId(v string) *DescribeDomainCnameResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainCnameResponseBodyCnameDatas struct {
	Data []*DescribeDomainCnameResponseBodyCnameDatasData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
}

func (s DescribeDomainCnameResponseBodyCnameDatas) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCnameResponseBodyCnameDatas) GoString() string {
	return s.String()
}

func (s *DescribeDomainCnameResponseBodyCnameDatas) SetData(v []*DescribeDomainCnameResponseBodyCnameDatasData) *DescribeDomainCnameResponseBodyCnameDatas {
	s.Data = v
	return s
}

type DescribeDomainCnameResponseBodyCnameDatasData struct {
	// The CNAME assigned to the domain name by Alibaba Cloud CDN.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The accelerated domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The CNAME detection result. Valid values:
	//
	// *   0: The DNS can detect the CNAME assigned to the domain name.
	// *   Value other than 0: The DNS cannot detect the CNAME assigned to the domain name.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDomainCnameResponseBodyCnameDatasData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCnameResponseBodyCnameDatasData) GoString() string {
	return s.String()
}

func (s *DescribeDomainCnameResponseBodyCnameDatasData) SetCname(v string) *DescribeDomainCnameResponseBodyCnameDatasData {
	s.Cname = &v
	return s
}

func (s *DescribeDomainCnameResponseBodyCnameDatasData) SetDomain(v string) *DescribeDomainCnameResponseBodyCnameDatasData {
	s.Domain = &v
	return s
}

func (s *DescribeDomainCnameResponseBodyCnameDatasData) SetStatus(v int32) *DescribeDomainCnameResponseBodyCnameDatasData {
	s.Status = &v
	return s
}

type DescribeDomainCnameResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainCnameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainCnameResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCnameResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainCnameResponse) SetHeaders(v map[string]*string) *DescribeDomainCnameResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainCnameResponse) SetStatusCode(v int32) *DescribeDomainCnameResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainCnameResponse) SetBody(v *DescribeDomainCnameResponseBody) *DescribeDomainCnameResponse {
	s.Body = v
	return s
}

type DescribeDomainCustomLogConfigRequest struct {
	// The domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDomainCustomLogConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCustomLogConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainCustomLogConfigRequest) SetDomainName(v string) *DescribeDomainCustomLogConfigRequest {
	s.DomainName = &v
	return s
}

type DescribeDomainCustomLogConfigResponseBody struct {
	// The ID of the log configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The format of the log configuration.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The sample log configuration.
	Sample *string `json:"Sample,omitempty" xml:"Sample,omitempty"`
	// The tag information about the log configuration.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s DescribeDomainCustomLogConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCustomLogConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainCustomLogConfigResponseBody) SetConfigId(v string) *DescribeDomainCustomLogConfigResponseBody {
	s.ConfigId = &v
	return s
}

func (s *DescribeDomainCustomLogConfigResponseBody) SetRemark(v string) *DescribeDomainCustomLogConfigResponseBody {
	s.Remark = &v
	return s
}

func (s *DescribeDomainCustomLogConfigResponseBody) SetRequestId(v string) *DescribeDomainCustomLogConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainCustomLogConfigResponseBody) SetSample(v string) *DescribeDomainCustomLogConfigResponseBody {
	s.Sample = &v
	return s
}

func (s *DescribeDomainCustomLogConfigResponseBody) SetTag(v string) *DescribeDomainCustomLogConfigResponseBody {
	s.Tag = &v
	return s
}

type DescribeDomainCustomLogConfigResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainCustomLogConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainCustomLogConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainCustomLogConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainCustomLogConfigResponse) SetHeaders(v map[string]*string) *DescribeDomainCustomLogConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainCustomLogConfigResponse) SetStatusCode(v int32) *DescribeDomainCustomLogConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainCustomLogConfigResponse) SetBody(v *DescribeDomainCustomLogConfigResponseBody) *DescribeDomainCustomLogConfigResponse {
	s.Body = v
	return s
}

type DescribeDomainDetailDataByLayerRequest struct {
	// The domain name that you want to query. You can specify multiple domain names and separate them with commas (,). You can specify up to 30 domain names in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time. The maximum time range that can be specified is 1 hour.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The metric that you want to query. You can specify one or more metrics and separate them with commas (,). Valid values: **bps**, **qps**, **traf**, **acc**, **ipv6\_traf**, **ipv6\_bps**, **ipv6\_acc**, **ipv6\_qps**, and **http_code**.
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISP names.
	//
	// If you do not specify an ISP, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The protocol by which you want to query data. Valid values: **http**, **https**, **quic**, and **all**.
	//
	// Default value: **all**.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query region names.
	//
	// If you do not specify a region, data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainDetailDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDetailDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainDetailDataByLayerRequest) SetDomainName(v string) *DescribeDomainDetailDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerRequest) SetEndTime(v string) *DescribeDomainDetailDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerRequest) SetField(v string) *DescribeDomainDetailDataByLayerRequest {
	s.Field = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerRequest) SetIspNameEn(v string) *DescribeDomainDetailDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerRequest) SetLayer(v string) *DescribeDomainDetailDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerRequest) SetLocationNameEn(v string) *DescribeDomainDetailDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerRequest) SetStartTime(v string) *DescribeDomainDetailDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainDetailDataByLayerResponseBody struct {
	// Details about the accelerated domain names.
	Data *DescribeDomainDetailDataByLayerResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainDetailDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDetailDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainDetailDataByLayerResponseBody) SetData(v *DescribeDomainDetailDataByLayerResponseBodyData) *DescribeDomainDetailDataByLayerResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBody) SetRequestId(v string) *DescribeDomainDetailDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainDetailDataByLayerResponseBodyData struct {
	DataModule []*DescribeDomainDetailDataByLayerResponseBodyDataDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainDetailDataByLayerResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDetailDataByLayerResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDomainDetailDataByLayerResponseBodyData) SetDataModule(v []*DescribeDomainDetailDataByLayerResponseBodyDataDataModule) *DescribeDomainDetailDataByLayerResponseBodyData {
	s.DataModule = v
	return s
}

type DescribeDomainDetailDataByLayerResponseBodyDataDataModule struct {
	// The number of requests.
	Acc *int64 `json:"Acc,omitempty" xml:"Acc,omitempty"`
	// The bandwidth. Unit: bit/s.
	Bps *float32 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The distribution of HTTP status codes.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The number of IPv6 requests.
	Ipv6Acc *int64 `json:"Ipv6Acc,omitempty" xml:"Ipv6Acc,omitempty"`
	// The IPv6 bandwidth. Unit: bit/s.
	Ipv6Bps *float32 `json:"Ipv6Bps,omitempty" xml:"Ipv6Bps,omitempty"`
	// The QPS over IPv6.
	Ipv6Qps *float32 `json:"Ipv6Qps,omitempty" xml:"Ipv6Qps,omitempty"`
	// The IPv6 traffic. Unit: bytes.
	Ipv6Traf *int64 `json:"Ipv6Traf,omitempty" xml:"Ipv6Traf,omitempty"`
	// The QPS.
	Qps *float32 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The amount of network traffic. Unit: bytes.
	Traf *int64 `json:"Traf,omitempty" xml:"Traf,omitempty"`
}

func (s DescribeDomainDetailDataByLayerResponseBodyDataDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDetailDataByLayerResponseBodyDataDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetAcc(v int64) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Acc = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetBps(v float32) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Bps = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetDomainName(v string) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetHttpCode(v string) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.HttpCode = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetIpv6Acc(v int64) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Ipv6Acc = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetIpv6Bps(v float32) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Ipv6Bps = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetIpv6Qps(v float32) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Ipv6Qps = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetIpv6Traf(v int64) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Ipv6Traf = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetQps(v float32) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Qps = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetTimeStamp(v string) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponseBodyDataDataModule) SetTraf(v int64) *DescribeDomainDetailDataByLayerResponseBodyDataDataModule {
	s.Traf = &v
	return s
}

type DescribeDomainDetailDataByLayerResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainDetailDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainDetailDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDetailDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainDetailDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeDomainDetailDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponse) SetStatusCode(v int32) *DescribeDomainDetailDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainDetailDataByLayerResponse) SetBody(v *DescribeDomainDetailDataByLayerResponseBody) *DescribeDomainDetailDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeDomainHitRateDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries the byte hit ratios for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainHitRateDataRequest) SetDomainName(v string) *DescribeDomainHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainHitRateDataRequest) SetEndTime(v string) *DescribeDomainHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainHitRateDataRequest) SetInterval(v string) *DescribeDomainHitRateDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainHitRateDataRequest) SetStartTime(v string) *DescribeDomainHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainHitRateDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The byte hit ratio at each time interval. The byte hit ratio is measured in percentage.
	HitRateInterval *DescribeDomainHitRateDataResponseBodyHitRateInterval `json:"HitRateInterval,omitempty" xml:"HitRateInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainHitRateDataResponseBody) SetDataInterval(v string) *DescribeDomainHitRateDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainHitRateDataResponseBody) SetDomainName(v string) *DescribeDomainHitRateDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainHitRateDataResponseBody) SetEndTime(v string) *DescribeDomainHitRateDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainHitRateDataResponseBody) SetHitRateInterval(v *DescribeDomainHitRateDataResponseBodyHitRateInterval) *DescribeDomainHitRateDataResponseBody {
	s.HitRateInterval = v
	return s
}

func (s *DescribeDomainHitRateDataResponseBody) SetRequestId(v string) *DescribeDomainHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainHitRateDataResponseBody) SetStartTime(v string) *DescribeDomainHitRateDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainHitRateDataResponseBodyHitRateInterval struct {
	DataModule []*DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainHitRateDataResponseBodyHitRateInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHitRateDataResponseBodyHitRateInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainHitRateDataResponseBodyHitRateInterval) SetDataModule(v []*DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule) *DescribeDomainHitRateDataResponseBodyHitRateInterval {
	s.DataModule = v
	return s
}

type DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule struct {
	// The byte hit ratio of HTTPS requests.
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The byte hit ratio.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule) SetHttpsValue(v string) *DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule) SetTimeStamp(v string) *DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule) SetValue(v string) *DescribeDomainHitRateDataResponseBodyHitRateIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainHitRateDataResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeDomainHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainHitRateDataResponse) SetStatusCode(v int32) *DescribeDomainHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainHitRateDataResponse) SetBody(v *DescribeDomainHitRateDataResponseBody) *DescribeDomainHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeDomainHttpCodeDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries the number and proportions of HTTP status codes for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the region. You can call the DescribeCdnRegionAndIsp operation to query regions. If you do not specify this parameter, data in all regions is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the Internet service provider (ISP). You can call the DescribeCdnRegionAndIsp operation to query ISPs. If you do not specify this parameter, data of all ISPs is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataRequest) SetDomainName(v string) *DescribeDomainHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainHttpCodeDataRequest) SetEndTime(v string) *DescribeDomainHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainHttpCodeDataRequest) SetInterval(v string) *DescribeDomainHttpCodeDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainHttpCodeDataRequest) SetIspNameEn(v string) *DescribeDomainHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeDomainHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainHttpCodeDataRequest) SetStartTime(v string) *DescribeDomainHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainHttpCodeDataResponseBody struct {
	// The time interval.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The proportions of HTTP status codes at each time interval.
	HttpCodeData *DescribeDomainHttpCodeDataResponseBodyHttpCodeData `json:"HttpCodeData,omitempty" xml:"HttpCodeData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDomainHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDomainHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDomainHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBody) SetHttpCodeData(v *DescribeDomainHttpCodeDataResponseBodyHttpCodeData) *DescribeDomainHttpCodeDataResponseBody {
	s.HttpCodeData = v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDomainHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDomainHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainHttpCodeDataResponseBodyHttpCodeData struct {
	UsageData []*DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeData) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataResponseBodyHttpCodeData) SetUsageData(v []*DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData) *DescribeDomainHttpCodeDataResponseBodyHttpCodeData {
	s.UsageData = v
	return s
}

type DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The information about the HTTP status codes.
	Value *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData) SetTimeStamp(v string) *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData) SetValue(v *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageData {
	s.Value = v
	return s
}

type DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue struct {
	CodeProportionData []*DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData `json:"CodeProportionData,omitempty" xml:"CodeProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) SetCodeProportionData(v []*DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValue {
	s.CodeProportionData = v
	return s
}

type DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData struct {
	// The HTTP status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The count of each HTTP status code.
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) SetCode(v string) *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData {
	s.Code = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) SetCount(v string) *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData {
	s.Count = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) SetProportion(v string) *DescribeDomainHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData {
	s.Proportion = &v
	return s
}

type DescribeDomainHttpCodeDataResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDomainHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDomainHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainHttpCodeDataResponse) SetBody(v *DescribeDomainHttpCodeDataResponseBody) *DescribeDomainHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDomainHttpCodeDataByLayerRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// If you do not specify this parameter, data of all accelerated domain names under your account is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISP names.
	//
	// If you do not specify an ISP, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The protocol by which you want to query HTTP status codes. The network layer supports **IPv4** and **IPv6**. The application layer supports **http**, **https**, and **quic**. You can also set the value to **all**.
	//
	// Default value: **all**
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	//
	// If you do not specify a region, data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainHttpCodeDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataByLayerRequest) SetDomainName(v string) *DescribeDomainHttpCodeDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerRequest) SetEndTime(v string) *DescribeDomainHttpCodeDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerRequest) SetInterval(v string) *DescribeDomainHttpCodeDataByLayerRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerRequest) SetIspNameEn(v string) *DescribeDomainHttpCodeDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerRequest) SetLayer(v string) *DescribeDomainHttpCodeDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerRequest) SetLocationNameEn(v string) *DescribeDomainHttpCodeDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerRequest) SetStartTime(v string) *DescribeDomainHttpCodeDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainHttpCodeDataByLayerResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The statistics of HTTP status codes returned at each time interval.
	HttpCodeDataInterval *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval `json:"HttpCodeDataInterval,omitempty" xml:"HttpCodeDataInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainHttpCodeDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataByLayerResponseBody) SetDataInterval(v string) *DescribeDomainHttpCodeDataByLayerResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerResponseBody) SetHttpCodeDataInterval(v *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) *DescribeDomainHttpCodeDataByLayerResponseBody {
	s.HttpCodeDataInterval = v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerResponseBody) SetRequestId(v string) *DescribeDomainHttpCodeDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval struct {
	DataModule []*DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) SetDataModule(v []*DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval {
	s.DataModule = v
	return s
}

type DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total number of times that HTTP status codes were returned.
	TotalValue *string `json:"TotalValue,omitempty" xml:"TotalValue,omitempty"`
	// The number of times that the HTTP status code was returned.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) SetTimeStamp(v string) *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) SetTotalValue(v string) *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule {
	s.TotalValue = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) SetValue(v string) *DescribeDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainHttpCodeDataByLayerResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainHttpCodeDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainHttpCodeDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainHttpCodeDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainHttpCodeDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeDomainHttpCodeDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerResponse) SetStatusCode(v int32) *DescribeDomainHttpCodeDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainHttpCodeDataByLayerResponse) SetBody(v *DescribeDomainHttpCodeDataByLayerResponseBody) *DescribeDomainHttpCodeDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeDomainISPDataRequest struct {
	// The accelerated domain name. You can specify only one domain name in each call.
	//
	// By default, this operation queries the proportions of data usage for all accelerated domain names.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainISPDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainISPDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainISPDataRequest) SetDomainName(v string) *DescribeDomainISPDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainISPDataRequest) SetEndTime(v string) *DescribeDomainISPDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainISPDataRequest) SetStartTime(v string) *DescribeDomainISPDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainISPDataResponseBody struct {
	// The time interval. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The access statistics by ISP.
	Value *DescribeDomainISPDataResponseBodyValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDomainISPDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainISPDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainISPDataResponseBody) SetDataInterval(v string) *DescribeDomainISPDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainISPDataResponseBody) SetDomainName(v string) *DescribeDomainISPDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainISPDataResponseBody) SetEndTime(v string) *DescribeDomainISPDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainISPDataResponseBody) SetRequestId(v string) *DescribeDomainISPDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainISPDataResponseBody) SetStartTime(v string) *DescribeDomainISPDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainISPDataResponseBody) SetValue(v *DescribeDomainISPDataResponseBodyValue) *DescribeDomainISPDataResponseBody {
	s.Value = v
	return s
}

type DescribeDomainISPDataResponseBodyValue struct {
	ISPProportionData []*DescribeDomainISPDataResponseBodyValueISPProportionData `json:"ISPProportionData,omitempty" xml:"ISPProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDomainISPDataResponseBodyValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainISPDataResponseBodyValue) GoString() string {
	return s.String()
}

func (s *DescribeDomainISPDataResponseBodyValue) SetISPProportionData(v []*DescribeDomainISPDataResponseBodyValueISPProportionData) *DescribeDomainISPDataResponseBodyValue {
	s.ISPProportionData = v
	return s
}

type DescribeDomainISPDataResponseBodyValueISPProportionData struct {
	// The average response size. Unit: bytes.
	AvgObjectSize *string `json:"AvgObjectSize,omitempty" xml:"AvgObjectSize,omitempty"`
	// The average response speed. Unit: byte/ms.
	AvgResponseRate *string `json:"AvgResponseRate,omitempty" xml:"AvgResponseRate,omitempty"`
	// The average response time. Unit: milliseconds.
	AvgResponseTime *string `json:"AvgResponseTime,omitempty" xml:"AvgResponseTime,omitempty"`
	// The bandwidth.
	Bps *string `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The proportion of network traffic.
	BytesProportion *string `json:"BytesProportion,omitempty" xml:"BytesProportion,omitempty"`
	// The information about the ISP.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The name of the ISP.
	IspEname *string `json:"IspEname,omitempty" xml:"IspEname,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
	// The QPS.
	Qps *string `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The request error rate.
	ReqErrRate *string `json:"ReqErrRate,omitempty" xml:"ReqErrRate,omitempty"`
	// The total volume of traffic.
	TotalBytes *string `json:"TotalBytes,omitempty" xml:"TotalBytes,omitempty"`
	// The total number of requests.
	TotalQuery *string `json:"TotalQuery,omitempty" xml:"TotalQuery,omitempty"`
}

func (s DescribeDomainISPDataResponseBodyValueISPProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainISPDataResponseBodyValueISPProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetAvgObjectSize(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.AvgObjectSize = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetAvgResponseRate(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.AvgResponseRate = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetAvgResponseTime(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.AvgResponseTime = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetBps(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.Bps = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetBytesProportion(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.BytesProportion = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetISP(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.ISP = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetIspEname(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.IspEname = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetProportion(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.Proportion = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetQps(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.Qps = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetReqErrRate(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.ReqErrRate = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetTotalBytes(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.TotalBytes = &v
	return s
}

func (s *DescribeDomainISPDataResponseBodyValueISPProportionData) SetTotalQuery(v string) *DescribeDomainISPDataResponseBodyValueISPProportionData {
	s.TotalQuery = &v
	return s
}

type DescribeDomainISPDataResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainISPDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainISPDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainISPDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainISPDataResponse) SetHeaders(v map[string]*string) *DescribeDomainISPDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainISPDataResponse) SetStatusCode(v int32) *DescribeDomainISPDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainISPDataResponse) SetBody(v *DescribeDomainISPDataResponseBody) *DescribeDomainISPDataResponse {
	s.Body = v
	return s
}

type DescribeDomainMax95BpsDataRequest struct {
	// The cycle to query the 95th percentile bandwidth data. Default value: **day**. Valid values:
	//
	// *   **day**: queries the 95th percentile bandwidth data by day.
	// *   **month**: queries the 95th percentile bandwidth data by month.
	Cycle *string `json:"Cycle,omitempty" xml:"Cycle,omitempty"`
	// The accelerated domain name. If you do not specify this parameter, data of all accelerated domain names under your account is queried.
	//
	// > You cannot specify multiple domain names at a time.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s DescribeDomainMax95BpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMax95BpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainMax95BpsDataRequest) SetCycle(v string) *DescribeDomainMax95BpsDataRequest {
	s.Cycle = &v
	return s
}

func (s *DescribeDomainMax95BpsDataRequest) SetDomainName(v string) *DescribeDomainMax95BpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainMax95BpsDataRequest) SetEndTime(v string) *DescribeDomainMax95BpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainMax95BpsDataRequest) SetStartTime(v string) *DescribeDomainMax95BpsDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainMax95BpsDataRequest) SetTimePoint(v string) *DescribeDomainMax95BpsDataRequest {
	s.TimePoint = &v
	return s
}

type DescribeDomainMax95BpsDataResponseBody struct {
	DetailData *DescribeDomainMax95BpsDataResponseBodyDetailData `json:"DetailData,omitempty" xml:"DetailData,omitempty" type:"Struct"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The 95th percentile bandwidth in the Chinese mainland.
	DomesticMax95Bps *string `json:"DomesticMax95Bps,omitempty" xml:"DomesticMax95Bps,omitempty"`
	// The end of the time range for which the data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The 95th percentile bandwidth.
	Max95Bps *string `json:"Max95Bps,omitempty" xml:"Max95Bps,omitempty"`
	// The 95th percentile bandwidth outside the Chinese mainland.
	OverseasMax95Bps *string `json:"OverseasMax95Bps,omitempty" xml:"OverseasMax95Bps,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range for which the data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainMax95BpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMax95BpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetDetailData(v *DescribeDomainMax95BpsDataResponseBodyDetailData) *DescribeDomainMax95BpsDataResponseBody {
	s.DetailData = v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetDomainName(v string) *DescribeDomainMax95BpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetDomesticMax95Bps(v string) *DescribeDomainMax95BpsDataResponseBody {
	s.DomesticMax95Bps = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetEndTime(v string) *DescribeDomainMax95BpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetMax95Bps(v string) *DescribeDomainMax95BpsDataResponseBody {
	s.Max95Bps = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetOverseasMax95Bps(v string) *DescribeDomainMax95BpsDataResponseBody {
	s.OverseasMax95Bps = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetRequestId(v string) *DescribeDomainMax95BpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBody) SetStartTime(v string) *DescribeDomainMax95BpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainMax95BpsDataResponseBodyDetailData struct {
	Max95Detail []*DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail `json:"Max95Detail,omitempty" xml:"Max95Detail,omitempty" type:"Repeated"`
}

func (s DescribeDomainMax95BpsDataResponseBodyDetailData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMax95BpsDataResponseBodyDetailData) GoString() string {
	return s.String()
}

func (s *DescribeDomainMax95BpsDataResponseBodyDetailData) SetMax95Detail(v []*DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail) *DescribeDomainMax95BpsDataResponseBodyDetailData {
	s.Max95Detail = v
	return s
}

type DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail struct {
	Area             *string  `json:"Area,omitempty" xml:"Area,omitempty"`
	Max95Bps         *float32 `json:"Max95Bps,omitempty" xml:"Max95Bps,omitempty"`
	Max95BpsPeakTime *string  `json:"Max95BpsPeakTime,omitempty" xml:"Max95BpsPeakTime,omitempty"`
	TimeStamp        *string  `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail) GoString() string {
	return s.String()
}

func (s *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetArea(v string) *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.Area = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetMax95Bps(v float32) *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.Max95Bps = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetMax95BpsPeakTime(v string) *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.Max95BpsPeakTime = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetTimeStamp(v string) *DescribeDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.TimeStamp = &v
	return s
}

type DescribeDomainMax95BpsDataResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainMax95BpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainMax95BpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMax95BpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainMax95BpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainMax95BpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainMax95BpsDataResponse) SetStatusCode(v int32) *DescribeDomainMax95BpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainMax95BpsDataResponse) SetBody(v *DescribeDomainMax95BpsDataResponseBody) *DescribeDomainMax95BpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainMultiUsageDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// > *   You can specify a maximum of 30 domain names at a time.
	// >*   If this parameter is not set, data of all your accelerated domain names is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainMultiUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMultiUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainMultiUsageDataRequest) SetDomainName(v string) *DescribeDomainMultiUsageDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainMultiUsageDataRequest) SetEndTime(v string) *DescribeDomainMultiUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainMultiUsageDataRequest) SetStartTime(v string) *DescribeDomainMultiUsageDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainMultiUsageDataResponseBody struct {
	// The end of the time range that was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about requests collected every 5 minutes.
	RequestPerInterval *DescribeDomainMultiUsageDataResponseBodyRequestPerInterval `json:"RequestPerInterval,omitempty" xml:"RequestPerInterval,omitempty" type:"Struct"`
	// The start of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The statistics of network traffic collected every 5 minutes.
	TrafficPerInterval *DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval `json:"TrafficPerInterval,omitempty" xml:"TrafficPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDomainMultiUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMultiUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainMultiUsageDataResponseBody) SetEndTime(v string) *DescribeDomainMultiUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBody) SetRequestId(v string) *DescribeDomainMultiUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBody) SetRequestPerInterval(v *DescribeDomainMultiUsageDataResponseBodyRequestPerInterval) *DescribeDomainMultiUsageDataResponseBody {
	s.RequestPerInterval = v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBody) SetStartTime(v string) *DescribeDomainMultiUsageDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBody) SetTrafficPerInterval(v *DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval) *DescribeDomainMultiUsageDataResponseBody {
	s.TrafficPerInterval = v
	return s
}

type DescribeDomainMultiUsageDataResponseBodyRequestPerInterval struct {
	RequestDataModule []*DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule `json:"RequestDataModule,omitempty" xml:"RequestDataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainMultiUsageDataResponseBodyRequestPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMultiUsageDataResponseBodyRequestPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainMultiUsageDataResponseBodyRequestPerInterval) SetRequestDataModule(v []*DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) *DescribeDomainMultiUsageDataResponseBodyRequestPerInterval {
	s.RequestDataModule = v
	return s
}

type DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule struct {
	// The accelerated domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The number of requests.
	Request *int64 `json:"Request,omitempty" xml:"Request,omitempty"`
	// The timestamp of the returned number of requests.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The type.
	//
	// >  The value is Simple for Alibaba Cloud CDN.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetDomain(v string) *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.Domain = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetRequest(v int64) *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.Request = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetTimeStamp(v string) *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetType(v string) *DescribeDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.Type = &v
	return s
}

type DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval struct {
	TrafficDataModule []*DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule `json:"TrafficDataModule,omitempty" xml:"TrafficDataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval) SetTrafficDataModule(v []*DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) *DescribeDomainMultiUsageDataResponseBodyTrafficPerInterval {
	s.TrafficDataModule = v
	return s
}

type DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule struct {
	// The name of the region.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The bandwidth. Unit: bit/s.
	Bps *float32 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The startstamp of the returned usage data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The type of requests. Valid values:
	//
	// *   **StaticHttps**: static HTTPS requests
	// *   **DynamicHttps**: dynamic HTTPS requests
	// *   **DynamicHttp**: dynamic HTTP requests
	// *   **StaticQuic**: static QUIC requests
	// *   **DynamicQuic**: dynamic QUIC requests
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetArea(v string) *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Area = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetBps(v float32) *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Bps = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetDomain(v string) *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Domain = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetTimeStamp(v string) *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetType(v string) *DescribeDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Type = &v
	return s
}

type DescribeDomainMultiUsageDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainMultiUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainMultiUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainMultiUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainMultiUsageDataResponse) SetHeaders(v map[string]*string) *DescribeDomainMultiUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainMultiUsageDataResponse) SetStatusCode(v int32) *DescribeDomainMultiUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainMultiUsageDataResponse) SetBody(v *DescribeDomainMultiUsageDataResponseBody) *DescribeDomainMultiUsageDataResponse {
	s.Body = v
	return s
}

type DescribeDomainPathDataRequest struct {
	// The accelerated domain name.
	//
	// > You can specify only one domain name in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The interval between the start time and end time must be less than 30 days. Example: 2016-10-21T04:00:00Z.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Pages start from page **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: integers from **1** to **1000**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The paths that you want to query. Separate paths with forward slashes (/). If you do not set this parameter, all paths are queried. If you set the value to a directory, it must end with a forward slash (/).
	//
	// > Fuzzy match is not supported. If you want data to be collected based on a directory, you can specify a specific directory, for example, directory/path/. In this case, bandwidth data is collected based on directory/path/.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-10-20T04:00:00Z.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainPathDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPathDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainPathDataRequest) SetDomainName(v string) *DescribeDomainPathDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainPathDataRequest) SetEndTime(v string) *DescribeDomainPathDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainPathDataRequest) SetPageNumber(v int32) *DescribeDomainPathDataRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainPathDataRequest) SetPageSize(v int32) *DescribeDomainPathDataRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainPathDataRequest) SetPath(v string) *DescribeDomainPathDataRequest {
	s.Path = &v
	return s
}

func (s *DescribeDomainPathDataRequest) SetStartTime(v string) *DescribeDomainPathDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainPathDataResponseBody struct {
	// The time interval. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The page number of the returned page. Pages start from page **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// A list of bandwidth values collected at each time interval.
	PathDataPerInterval *DescribeDomainPathDataResponseBodyPathDataPerInterval `json:"PathDataPerInterval,omitempty" xml:"PathDataPerInterval,omitempty" type:"Struct"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDomainPathDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPathDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainPathDataResponseBody) SetDataInterval(v string) *DescribeDomainPathDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainPathDataResponseBody) SetDomainName(v string) *DescribeDomainPathDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainPathDataResponseBody) SetEndTime(v string) *DescribeDomainPathDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainPathDataResponseBody) SetPageNumber(v int32) *DescribeDomainPathDataResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainPathDataResponseBody) SetPageSize(v int32) *DescribeDomainPathDataResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainPathDataResponseBody) SetPathDataPerInterval(v *DescribeDomainPathDataResponseBodyPathDataPerInterval) *DescribeDomainPathDataResponseBody {
	s.PathDataPerInterval = v
	return s
}

func (s *DescribeDomainPathDataResponseBody) SetStartTime(v string) *DescribeDomainPathDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainPathDataResponseBody) SetTotalCount(v int32) *DescribeDomainPathDataResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDomainPathDataResponseBodyPathDataPerInterval struct {
	UsageData []*DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDomainPathDataResponseBodyPathDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPathDataResponseBodyPathDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainPathDataResponseBodyPathDataPerInterval) SetUsageData(v []*DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData) *DescribeDomainPathDataResponseBodyPathDataPerInterval {
	s.UsageData = v
	return s
}

type DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData struct {
	// The number of visits to the URL.
	Acc *int32 `json:"Acc,omitempty" xml:"Acc,omitempty"`
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The point in time.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The amount of network traffic. Unit: bytes.
	Traffic *int32 `json:"Traffic,omitempty" xml:"Traffic,omitempty"`
}

func (s DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData) SetAcc(v int32) *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData {
	s.Acc = &v
	return s
}

func (s *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData) SetPath(v string) *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData {
	s.Path = &v
	return s
}

func (s *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData) SetTime(v string) *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData {
	s.Time = &v
	return s
}

func (s *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData) SetTraffic(v int32) *DescribeDomainPathDataResponseBodyPathDataPerIntervalUsageData {
	s.Traffic = &v
	return s
}

type DescribeDomainPathDataResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainPathDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainPathDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPathDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainPathDataResponse) SetHeaders(v map[string]*string) *DescribeDomainPathDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainPathDataResponse) SetStatusCode(v int32) *DescribeDomainPathDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainPathDataResponse) SetBody(v *DescribeDomainPathDataResponseBody) *DescribeDomainPathDataResponse {
	s.Body = v
	return s
}

type DescribeDomainPvDataRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainPvDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPvDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainPvDataRequest) SetDomainName(v string) *DescribeDomainPvDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainPvDataRequest) SetEndTime(v string) *DescribeDomainPvDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainPvDataRequest) SetStartTime(v string) *DescribeDomainPvDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainPvDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of PVs at each interval.
	PvDataInterval *DescribeDomainPvDataResponseBodyPvDataInterval `json:"PvDataInterval,omitempty" xml:"PvDataInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainPvDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPvDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainPvDataResponseBody) SetDataInterval(v string) *DescribeDomainPvDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainPvDataResponseBody) SetDomainName(v string) *DescribeDomainPvDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainPvDataResponseBody) SetEndTime(v string) *DescribeDomainPvDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainPvDataResponseBody) SetPvDataInterval(v *DescribeDomainPvDataResponseBodyPvDataInterval) *DescribeDomainPvDataResponseBody {
	s.PvDataInterval = v
	return s
}

func (s *DescribeDomainPvDataResponseBody) SetRequestId(v string) *DescribeDomainPvDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainPvDataResponseBody) SetStartTime(v string) *DescribeDomainPvDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainPvDataResponseBodyPvDataInterval struct {
	UsageData []*DescribeDomainPvDataResponseBodyPvDataIntervalUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDomainPvDataResponseBodyPvDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPvDataResponseBodyPvDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainPvDataResponseBodyPvDataInterval) SetUsageData(v []*DescribeDomainPvDataResponseBodyPvDataIntervalUsageData) *DescribeDomainPvDataResponseBodyPvDataInterval {
	s.UsageData = v
	return s
}

type DescribeDomainPvDataResponseBodyPvDataIntervalUsageData struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The number of PVs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainPvDataResponseBodyPvDataIntervalUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPvDataResponseBodyPvDataIntervalUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDomainPvDataResponseBodyPvDataIntervalUsageData) SetTimeStamp(v string) *DescribeDomainPvDataResponseBodyPvDataIntervalUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainPvDataResponseBodyPvDataIntervalUsageData) SetValue(v string) *DescribeDomainPvDataResponseBodyPvDataIntervalUsageData {
	s.Value = &v
	return s
}

type DescribeDomainPvDataResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainPvDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainPvDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainPvDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainPvDataResponse) SetHeaders(v map[string]*string) *DescribeDomainPvDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainPvDataResponse) SetStatusCode(v int32) *DescribeDomainPvDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainPvDataResponse) SetBody(v *DescribeDomainPvDataResponseBody) *DescribeDomainPvDataResponse {
	s.Body = v
	return s
}

type DescribeDomainQpsDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries QPS data for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP) for your Alibaba Cloud CDN service. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISPs. If you do not specify an ISP, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions. If you do not specify a region, data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainQpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataRequest) SetDomainName(v string) *DescribeDomainQpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainQpsDataRequest) SetEndTime(v string) *DescribeDomainQpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainQpsDataRequest) SetInterval(v string) *DescribeDomainQpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainQpsDataRequest) SetIspNameEn(v string) *DescribeDomainQpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainQpsDataRequest) SetLocationNameEn(v string) *DescribeDomainQpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainQpsDataRequest) SetStartTime(v string) *DescribeDomainQpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainQpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The list of QPS records at each interval.
	QpsDataInterval *DescribeDomainQpsDataResponseBodyQpsDataInterval `json:"QpsDataInterval,omitempty" xml:"QpsDataInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainQpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataResponseBody) SetDataInterval(v string) *DescribeDomainQpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBody) SetDomainName(v string) *DescribeDomainQpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBody) SetEndTime(v string) *DescribeDomainQpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBody) SetQpsDataInterval(v *DescribeDomainQpsDataResponseBodyQpsDataInterval) *DescribeDomainQpsDataResponseBody {
	s.QpsDataInterval = v
	return s
}

func (s *DescribeDomainQpsDataResponseBody) SetRequestId(v string) *DescribeDomainQpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBody) SetStartTime(v string) *DescribeDomainQpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainQpsDataResponseBodyQpsDataInterval struct {
	DataModule []*DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainQpsDataResponseBodyQpsDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataResponseBodyQpsDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataInterval) SetDataModule(v []*DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) *DescribeDomainQpsDataResponseBodyQpsDataInterval {
	s.DataModule = v
	return s
}

type DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule struct {
	// The number of requests in the Chinese mainland.
	AccDomesticValue *string `json:"AccDomesticValue,omitempty" xml:"AccDomesticValue,omitempty"`
	// The number of requests outside the Chinese mainland.
	AccOverseasValue *string `json:"AccOverseasValue,omitempty" xml:"AccOverseasValue,omitempty"`
	// The total number of requests.
	AccValue *string `json:"AccValue,omitempty" xml:"AccValue,omitempty"`
	// The number of queries per second in the Chinese mainland.
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The number of HTTPS requests sent to POPs in the Chinese mainland.
	HttpsAccDomesticValue *string `json:"HttpsAccDomesticValue,omitempty" xml:"HttpsAccDomesticValue,omitempty"`
	// The number of HTTPS requests sent to POPs outside the Chinese mainland.
	HttpsAccOverseasValue *string `json:"HttpsAccOverseasValue,omitempty" xml:"HttpsAccOverseasValue,omitempty"`
	// The number of HTTPS requests sent to POPs.
	HttpsAccValue *string `json:"HttpsAccValue,omitempty" xml:"HttpsAccValue,omitempty"`
	// The number of queries per second that is calculated based on the HTTPS requests sent to POPs in the Chinese mainland.
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	// The number of queries per second that is calculated based on the HTTPS requests sent to POPs outside the Chinese mainland.
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	// The number of queries per second that is calculated based on the HTTPS requests sent to points of presence (POPs).
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The number of queries per second outside the Chinese mainland.
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total QPS.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetAccDomesticValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.AccDomesticValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetAccOverseasValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.AccOverseasValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetAccValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.AccValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetDomesticValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsAccDomesticValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsAccDomesticValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsAccOverseasValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsAccOverseasValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsAccValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsAccValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetOverseasValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetTimeStamp(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetValue(v string) *DescribeDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainQpsDataResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainQpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainQpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainQpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainQpsDataResponse) SetStatusCode(v int32) *DescribeDomainQpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainQpsDataResponse) SetBody(v *DescribeDomainQpsDataResponseBody) *DescribeDomainQpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainQpsDataByLayerRequest struct {
	// The accelerated domain name. You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries the QPS of all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format in the ISO 8601 standard. The time is displayed in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries to return. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP) for your Alibaba Cloud CDN service. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISPs. If you do not set this parameter, all ISPs are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The layers at which you want to query the number of queries per second. Valid values:
	//
	// *   **Network layer**: **IPv4**and **IPv6**.
	// *   **Application layer**: **http**, **https**, and **quic**.
	// *   **all**: The default value. Both the network and application layers are included.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query the most recent region list. If you do not set this parameter, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format in the ISO 8601 standard. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainQpsDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataByLayerRequest) SetDomainName(v string) *DescribeDomainQpsDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerRequest) SetEndTime(v string) *DescribeDomainQpsDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerRequest) SetInterval(v string) *DescribeDomainQpsDataByLayerRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerRequest) SetIspNameEn(v string) *DescribeDomainQpsDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerRequest) SetLayer(v string) *DescribeDomainQpsDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerRequest) SetLocationNameEn(v string) *DescribeDomainQpsDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerRequest) SetStartTime(v string) *DescribeDomainQpsDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainQpsDataByLayerResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The layer at which the data was collected.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The number of queries per second at each interval.
	QpsDataInterval *DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval `json:"QpsDataInterval,omitempty" xml:"QpsDataInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainQpsDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataByLayerResponseBody) SetDataInterval(v string) *DescribeDomainQpsDataByLayerResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBody) SetDomainName(v string) *DescribeDomainQpsDataByLayerResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBody) SetEndTime(v string) *DescribeDomainQpsDataByLayerResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBody) SetLayer(v string) *DescribeDomainQpsDataByLayerResponseBody {
	s.Layer = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBody) SetQpsDataInterval(v *DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval) *DescribeDomainQpsDataByLayerResponseBody {
	s.QpsDataInterval = v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBody) SetRequestId(v string) *DescribeDomainQpsDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBody) SetStartTime(v string) *DescribeDomainQpsDataByLayerResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval struct {
	DataModule []*DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval) SetDataModule(v []*DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) *DescribeDomainQpsDataByLayerResponseBodyQpsDataInterval {
	s.DataModule = v
	return s
}

type DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule struct {
	// The number of requests in the Chinese mainland.
	AccDomesticValue *string `json:"AccDomesticValue,omitempty" xml:"AccDomesticValue,omitempty"`
	// The number of requests outside the Chinese mainland.
	AccOverseasValue *string `json:"AccOverseasValue,omitempty" xml:"AccOverseasValue,omitempty"`
	// The total number of requests.
	AccValue *string `json:"AccValue,omitempty" xml:"AccValue,omitempty"`
	// The number of queries per second in the Chinese mainland.
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The number of queries per second outside the Chinese mainland.
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total number of queries per second.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetAccDomesticValue(v string) *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.AccDomesticValue = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetAccOverseasValue(v string) *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.AccOverseasValue = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetAccValue(v string) *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.AccValue = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetDomesticValue(v string) *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetOverseasValue(v string) *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetTimeStamp(v string) *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetValue(v string) *DescribeDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainQpsDataByLayerResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainQpsDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainQpsDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQpsDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainQpsDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeDomainQpsDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponse) SetStatusCode(v int32) *DescribeDomainQpsDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainQpsDataByLayerResponse) SetBody(v *DescribeDomainQpsDataByLayerResponseBody) *DescribeDomainQpsDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeBpsDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// > You can specify up to 500 domain names in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISPs. If you do not set this parameter, all ISPs are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions. If you do not set this parameter, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeBpsDataRequest) SetDomainName(v string) *DescribeDomainRealTimeBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeBpsDataRequest) SetEndTime(v string) *DescribeDomainRealTimeBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeBpsDataRequest) SetIspNameEn(v string) *DescribeDomainRealTimeBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeBpsDataRequest) SetLocationNameEn(v string) *DescribeDomainRealTimeBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeBpsDataRequest) SetStartTime(v string) *DescribeDomainRealTimeBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeBpsDataResponseBody struct {
	// The data returned.
	Data *DescribeDomainRealTimeBpsDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainRealTimeBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeBpsDataResponseBody) SetData(v *DescribeDomainRealTimeBpsDataResponseBodyData) *DescribeDomainRealTimeBpsDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDomainRealTimeBpsDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeBpsDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainRealTimeBpsDataResponseBodyData struct {
	BpsModel []*DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel `json:"BpsModel,omitempty" xml:"BpsModel,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeBpsDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeBpsDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeBpsDataResponseBodyData) SetBpsModel(v []*DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel) *DescribeDomainRealTimeBpsDataResponseBodyData {
	s.BpsModel = v
	return s
}

type DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel struct {
	// The bandwidth. Unit: bit/s.
	Bps *float32 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel) SetBps(v float32) *DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel {
	s.Bps = &v
	return s
}

func (s *DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel) SetTimeStamp(v string) *DescribeDomainRealTimeBpsDataResponseBodyDataBpsModel {
	s.TimeStamp = &v
	return s
}

type DescribeDomainRealTimeBpsDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeBpsDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeBpsDataResponse) SetBody(v *DescribeDomainRealTimeBpsDataResponseBody) *DescribeDomainRealTimeBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeByteHitRateDataRequest struct {
	// The accelerated domain name. You can specify up to 100 domain names in each call. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeByteHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeByteHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeByteHitRateDataRequest) SetDomainName(v string) *DescribeDomainRealTimeByteHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeByteHitRateDataRequest) SetEndTime(v string) *DescribeDomainRealTimeByteHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeByteHitRateDataRequest) SetStartTime(v string) *DescribeDomainRealTimeByteHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeByteHitRateDataResponseBody struct {
	// The data returned.
	Data *DescribeDomainRealTimeByteHitRateDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainRealTimeByteHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeByteHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeByteHitRateDataResponseBody) SetData(v *DescribeDomainRealTimeByteHitRateDataResponseBodyData) *DescribeDomainRealTimeByteHitRateDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDomainRealTimeByteHitRateDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeByteHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainRealTimeByteHitRateDataResponseBodyData struct {
	ByteHitRateDataModel []*DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel `json:"ByteHitRateDataModel,omitempty" xml:"ByteHitRateDataModel,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeByteHitRateDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeByteHitRateDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeByteHitRateDataResponseBodyData) SetByteHitRateDataModel(v []*DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) *DescribeDomainRealTimeByteHitRateDataResponseBodyData {
	s.ByteHitRateDataModel = v
	return s
}

type DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel struct {
	// The byte hit ratio. The byte hit ratio is measured in percentage.
	ByteHitRate *float32 `json:"ByteHitRate,omitempty" xml:"ByteHitRate,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) SetByteHitRate(v float32) *DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel {
	s.ByteHitRate = &v
	return s
}

func (s *DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) SetTimeStamp(v string) *DescribeDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel {
	s.TimeStamp = &v
	return s
}

type DescribeDomainRealTimeByteHitRateDataResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeByteHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeByteHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeByteHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeByteHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeByteHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeByteHitRateDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeByteHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeByteHitRateDataResponse) SetBody(v *DescribeDomainRealTimeByteHitRateDataResponseBody) *DescribeDomainRealTimeByteHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeDetailDataRequest struct {
	// The accelerated domain name that you want to query.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2019-11-30T05:40:00Z.
	//
	// > The end time must be later than the start time. The difference between the end time and the start time cannot exceed 10 minutes.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of data that you want to query. You can specify multiple data types and separate them with commas (,). Valid values:
	//
	// *   **qps**: queries per second (QPS)
	// *   **bps**: bandwidth
	// *   **http_code**: HTTP status code
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISPs. If you do not specify an ISP, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not specify a region, data in all regions is queried. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// Specifies whether to return a summary value based on ISPs and regions. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// Default value: **false**.
	Merge *string `json:"Merge,omitempty" xml:"Merge,omitempty"`
	// Specifies whether to return a summary value based on ISPs and regions. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// Default value: **false**.
	MergeLocIsp *string `json:"MergeLocIsp,omitempty" xml:"MergeLocIsp,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2019-11-30T05:33:00Z.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeDetailDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeDetailDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetDomainName(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetEndTime(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetField(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.Field = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetIspNameEn(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetLocationNameEn(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetMerge(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.Merge = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetMergeLocIsp(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.MergeLocIsp = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataRequest) SetStartTime(v string) *DescribeDomainRealTimeDetailDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeDetailDataResponseBody struct {
	// The monitoring data of each ISP in each region.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainRealTimeDetailDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeDetailDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeDetailDataResponseBody) SetData(v string) *DescribeDomainRealTimeDetailDataResponseBody {
	s.Data = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeDetailDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainRealTimeDetailDataResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeDetailDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeDetailDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeDetailDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeDetailDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeDetailDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeDetailDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeDetailDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeDetailDataResponse) SetBody(v *DescribeDomainRealTimeDetailDataResponseBody) *DescribeDomainRealTimeDetailDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeHttpCodeDataRequest struct {
	// The accelerated domain name. You can specify multiple accelerated domain names and separate them with commas (,).
	//
	// > You can specify up to 100 accelerated domain names in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISP names.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions. If you do not specify a region, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeHttpCodeDataRequest) SetDomainName(v string) *DescribeDomainRealTimeHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataRequest) SetEndTime(v string) *DescribeDomainRealTimeHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataRequest) SetIspNameEn(v string) *DescribeDomainRealTimeHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeDomainRealTimeHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataRequest) SetStartTime(v string) *DescribeDomainRealTimeHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeHttpCodeDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	//
	// Depending on the maximum time range per query, the value is 60 (1 minute), 300 (5 minutes), or 3600 (1 hour). For more information, see the "Time granularity" section in Usage notes.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The proportions of HTTP status codes at each time interval.
	RealTimeHttpCodeData *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData `json:"RealTimeHttpCodeData,omitempty" xml:"RealTimeHttpCodeData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDomainRealTimeHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDomainRealTimeHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDomainRealTimeHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBody) SetRealTimeHttpCodeData(v *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) *DescribeDomainRealTimeHttpCodeDataResponseBody {
	s.RealTimeHttpCodeData = v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDomainRealTimeHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData struct {
	UsageData []*DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) SetUsageData(v []*DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData {
	s.UsageData = v
	return s
}

type DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The proportions of the HTTP status codes.
	Value *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) SetTimeStamp(v string) *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) SetValue(v *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData {
	s.Value = v
	return s
}

type DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue struct {
	RealTimeCodeProportionData []*DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData `json:"RealTimeCodeProportionData,omitempty" xml:"RealTimeCodeProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) SetRealTimeCodeProportionData(v []*DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue {
	s.RealTimeCodeProportionData = v
	return s
}

type DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData struct {
	// The HTTP status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The total number of entries.
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetCode(v string) *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Code = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetCount(v string) *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Count = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetProportion(v string) *DescribeDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Proportion = &v
	return s
}

type DescribeDomainRealTimeHttpCodeDataResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeHttpCodeDataResponse) SetBody(v *DescribeDomainRealTimeHttpCodeDataResponseBody) *DescribeDomainRealTimeHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeQpsDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// > You can specify up to 500 domain names in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// If you do not set this parameter, data of all ISPs is queried. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISP names.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// If you do not set this parameter, data in all regions is queried. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeQpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeQpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeQpsDataRequest) SetDomainName(v string) *DescribeDomainRealTimeQpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeQpsDataRequest) SetEndTime(v string) *DescribeDomainRealTimeQpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeQpsDataRequest) SetIspNameEn(v string) *DescribeDomainRealTimeQpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeQpsDataRequest) SetLocationNameEn(v string) *DescribeDomainRealTimeQpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeQpsDataRequest) SetStartTime(v string) *DescribeDomainRealTimeQpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeQpsDataResponseBody struct {
	// The data entries returned.
	Data *DescribeDomainRealTimeQpsDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainRealTimeQpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeQpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeQpsDataResponseBody) SetData(v *DescribeDomainRealTimeQpsDataResponseBodyData) *DescribeDomainRealTimeQpsDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDomainRealTimeQpsDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeQpsDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainRealTimeQpsDataResponseBodyData struct {
	QpsModel []*DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel `json:"QpsModel,omitempty" xml:"QpsModel,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeQpsDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeQpsDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeQpsDataResponseBodyData) SetQpsModel(v []*DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel) *DescribeDomainRealTimeQpsDataResponseBodyData {
	s.QpsModel = v
	return s
}

type DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel struct {
	// The number of queries per second.
	Qps *float32 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The timestamp of the data returned. The time follows the yyyy-MM-ddTHH:mm:ssZ format in the ISO 8601 standard and is in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel) SetQps(v float32) *DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel {
	s.Qps = &v
	return s
}

func (s *DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel) SetTimeStamp(v string) *DescribeDomainRealTimeQpsDataResponseBodyDataQpsModel {
	s.TimeStamp = &v
	return s
}

type DescribeDomainRealTimeQpsDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeQpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeQpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeQpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeQpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeQpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeQpsDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeQpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeQpsDataResponse) SetBody(v *DescribeDomainRealTimeQpsDataResponseBody) *DescribeDomainRealTimeQpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeReqHitRateDataRequest struct {
	// The accelerated domain name. You can specify up to 100 domain names in each call. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeReqHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeReqHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeReqHitRateDataRequest) SetDomainName(v string) *DescribeDomainRealTimeReqHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeReqHitRateDataRequest) SetEndTime(v string) *DescribeDomainRealTimeReqHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeReqHitRateDataRequest) SetStartTime(v string) *DescribeDomainRealTimeReqHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeReqHitRateDataResponseBody struct {
	// The data returned.
	Data *DescribeDomainRealTimeReqHitRateDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainRealTimeReqHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeReqHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeReqHitRateDataResponseBody) SetData(v *DescribeDomainRealTimeReqHitRateDataResponseBodyData) *DescribeDomainRealTimeReqHitRateDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDomainRealTimeReqHitRateDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeReqHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainRealTimeReqHitRateDataResponseBodyData struct {
	ReqHitRateDataModel []*DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel `json:"ReqHitRateDataModel,omitempty" xml:"ReqHitRateDataModel,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeReqHitRateDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeReqHitRateDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeReqHitRateDataResponseBodyData) SetReqHitRateDataModel(v []*DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) *DescribeDomainRealTimeReqHitRateDataResponseBodyData {
	s.ReqHitRateDataModel = v
	return s
}

type DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel struct {
	// The request hit ratio.
	ReqHitRate *float32 `json:"ReqHitRate,omitempty" xml:"ReqHitRate,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) SetReqHitRate(v float32) *DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel {
	s.ReqHitRate = &v
	return s
}

func (s *DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) SetTimeStamp(v string) *DescribeDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel {
	s.TimeStamp = &v
	return s
}

type DescribeDomainRealTimeReqHitRateDataResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeReqHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeReqHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeReqHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeReqHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeReqHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeReqHitRateDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeReqHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeReqHitRateDataResponse) SetBody(v *DescribeDomainRealTimeReqHitRateDataResponseBody) *DescribeDomainRealTimeReqHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeSrcBpsDataRequest struct {
	// The accelerated domain name. You can specify up to 100 domain names in each request. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeSrcBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcBpsDataRequest) SetDomainName(v string) *DescribeDomainRealTimeSrcBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataRequest) SetEndTime(v string) *DescribeDomainRealTimeSrcBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataRequest) SetStartTime(v string) *DescribeDomainRealTimeSrcBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeSrcBpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600(1 hour). For more information, see **Usage notes**.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The origin bandwidth data at each interval.
	RealTimeSrcBpsDataPerInterval *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval `json:"RealTimeSrcBpsDataPerInterval,omitempty" xml:"RealTimeSrcBpsDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeSrcBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBody) SetDataInterval(v string) *DescribeDomainRealTimeSrcBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBody) SetDomainName(v string) *DescribeDomainRealTimeSrcBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBody) SetEndTime(v string) *DescribeDomainRealTimeSrcBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBody) SetRealTimeSrcBpsDataPerInterval(v *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) *DescribeDomainRealTimeSrcBpsDataResponseBody {
	s.RealTimeSrcBpsDataPerInterval = v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeSrcBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBody) SetStartTime(v string) *DescribeDomainRealTimeSrcBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval struct {
	DataModule []*DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) SetDataModule(v []*DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The bandwidth during back-to-origin routing. Unit: bit/s.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) SetValue(v string) *DescribeDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainRealTimeSrcBpsDataResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeSrcBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeSrcBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeSrcBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeSrcBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeSrcBpsDataResponse) SetBody(v *DescribeDomainRealTimeSrcBpsDataResponseBody) *DescribeDomainRealTimeSrcBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeSrcHttpCodeDataRequest struct {
	// The accelerated domain name. You can specify up to 100 domain names in each call. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISPs. If you leave this parameter empty, all ISPs are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions. If you leave this parameter empty, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeSrcHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataRequest) SetDomainName(v string) *DescribeDomainRealTimeSrcHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataRequest) SetEndTime(v string) *DescribeDomainRealTimeSrcHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataRequest) SetIspNameEn(v string) *DescribeDomainRealTimeSrcHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeDomainRealTimeSrcHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataRequest) SetStartTime(v string) *DescribeDomainRealTimeSrcHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeSrcHttpCodeDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The proportions of HTTP status codes at each time interval.
	RealTimeSrcHttpCodeData *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData `json:"RealTimeSrcHttpCodeData,omitempty" xml:"RealTimeSrcHttpCodeData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBody) SetRealTimeSrcHttpCodeData(v *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) *DescribeDomainRealTimeSrcHttpCodeDataResponseBody {
	s.RealTimeSrcHttpCodeData = v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData struct {
	UsageData []*DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) SetUsageData(v []*DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData {
	s.UsageData = v
	return s
}

type DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The proportions of the HTTP status codes.
	Value *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) SetTimeStamp(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) SetValue(v *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData {
	s.Value = v
	return s
}

type DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue struct {
	RealTimeSrcCodeProportionData []*DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData `json:"RealTimeSrcCodeProportionData,omitempty" xml:"RealTimeSrcCodeProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) SetRealTimeSrcCodeProportionData(v []*DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue {
	s.RealTimeSrcCodeProportionData = v
	return s
}

type DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData struct {
	// The HTTP status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The count of each HTTP status code.
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) SetCode(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData {
	s.Code = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) SetCount(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData {
	s.Count = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) SetProportion(v string) *DescribeDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData {
	s.Proportion = &v
	return s
}

type DescribeDomainRealTimeSrcHttpCodeDataResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeSrcHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeSrcHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeSrcHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeSrcHttpCodeDataResponse) SetBody(v *DescribeDomainRealTimeSrcHttpCodeDataResponseBody) *DescribeDomainRealTimeSrcHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeSrcTrafficDataRequest struct {
	// The accelerated domain name. You can specify up to 100 domain names in each call. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeSrcTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcTrafficDataRequest) SetDomainName(v string) *DescribeDomainRealTimeSrcTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataRequest) SetEndTime(v string) *DescribeDomainRealTimeSrcTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataRequest) SetStartTime(v string) *DescribeDomainRealTimeSrcTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeSrcTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	//
	// Depending on the maximum time range per query, the value is 60 (1 minute), 300 (5 minutes), or 3600 (1 hour). For more information, see the "Time granularity" section in Usage notes.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range for which the data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The amount of back-to-origin traffic returned at each interval.
	RealTimeSrcTrafficDataPerInterval *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval `json:"RealTimeSrcTrafficDataPerInterval,omitempty" xml:"RealTimeSrcTrafficDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range for which the data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeSrcTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBody) SetDataInterval(v string) *DescribeDomainRealTimeSrcTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBody) SetDomainName(v string) *DescribeDomainRealTimeSrcTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBody) SetEndTime(v string) *DescribeDomainRealTimeSrcTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBody) SetRealTimeSrcTrafficDataPerInterval(v *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) *DescribeDomainRealTimeSrcTrafficDataResponseBody {
	s.RealTimeSrcTrafficDataPerInterval = v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeSrcTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBody) SetStartTime(v string) *DescribeDomainRealTimeSrcTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval struct {
	DataModule []*DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) SetDataModule(v []*DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The amount of traffic.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainRealTimeSrcTrafficDataResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeSrcTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeSrcTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeSrcTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeSrcTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeSrcTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeSrcTrafficDataResponse) SetBody(v *DescribeDomainRealTimeSrcTrafficDataResponseBody) *DescribeDomainRealTimeSrcTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealTimeTrafficDataRequest struct {
	// The accelerated domain name. You can specify up to 100 domain names in each call. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query the most recent region list. If you do not set this parameter, all regions are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query the most recent region list. If you do not set this parameter, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeTrafficDataRequest) SetDomainName(v string) *DescribeDomainRealTimeTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataRequest) SetEndTime(v string) *DescribeDomainRealTimeTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataRequest) SetIspNameEn(v string) *DescribeDomainRealTimeTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataRequest) SetLocationNameEn(v string) *DescribeDomainRealTimeTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataRequest) SetStartTime(v string) *DescribeDomainRealTimeTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	//
	// Depending on the maximum time range per query, the value is 60 (1 minute), 300 (5 minutes), or 3600 (1 hour). For more information, see the "Time granularity" section in Usage notes.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The network traffic returned at each time interval. Unit: bytes.
	RealTimeTrafficDataPerInterval *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval `json:"RealTimeTrafficDataPerInterval,omitempty" xml:"RealTimeTrafficDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRealTimeTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeTrafficDataResponseBody) SetDataInterval(v string) *DescribeDomainRealTimeTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponseBody) SetDomainName(v string) *DescribeDomainRealTimeTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponseBody) SetEndTime(v string) *DescribeDomainRealTimeTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponseBody) SetRealTimeTrafficDataPerInterval(v *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) *DescribeDomainRealTimeTrafficDataResponseBody {
	s.RealTimeTrafficDataPerInterval = v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponseBody) SetRequestId(v string) *DescribeDomainRealTimeTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponseBody) SetStartTime(v string) *DescribeDomainRealTimeTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval struct {
	DataModule []*DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) SetDataModule(v []*DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic value at each time interval.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainRealTimeTrafficDataResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealTimeTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealTimeTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealTimeTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealTimeTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRealTimeTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponse) SetStatusCode(v int32) *DescribeDomainRealTimeTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealTimeTrafficDataResponse) SetBody(v *DescribeDomainRealTimeTrafficDataResponseBody) *DescribeDomainRealTimeTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDomainRealtimeLogDeliveryRequest struct {
	// The accelerated domain name for which real-time log delivery is enabled. You can specify only one domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s DescribeDomainRealtimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealtimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealtimeLogDeliveryRequest) SetDomain(v string) *DescribeDomainRealtimeLogDeliveryRequest {
	s.Domain = &v
	return s
}

type DescribeDomainRealtimeLogDeliveryResponseBody struct {
	// The name of the Logstore where log entries are stored.
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The ID of the region where the Log Service project is deployed.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of real-time log delivery. Valid values:
	//
	// *   **online**
	// *   **offline**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDomainRealtimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealtimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealtimeLogDeliveryResponseBody) SetLogstore(v string) *DescribeDomainRealtimeLogDeliveryResponseBody {
	s.Logstore = &v
	return s
}

func (s *DescribeDomainRealtimeLogDeliveryResponseBody) SetProject(v string) *DescribeDomainRealtimeLogDeliveryResponseBody {
	s.Project = &v
	return s
}

func (s *DescribeDomainRealtimeLogDeliveryResponseBody) SetRegion(v string) *DescribeDomainRealtimeLogDeliveryResponseBody {
	s.Region = &v
	return s
}

func (s *DescribeDomainRealtimeLogDeliveryResponseBody) SetRequestId(v string) *DescribeDomainRealtimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRealtimeLogDeliveryResponseBody) SetStatus(v string) *DescribeDomainRealtimeLogDeliveryResponseBody {
	s.Status = &v
	return s
}

type DescribeDomainRealtimeLogDeliveryResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRealtimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRealtimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRealtimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRealtimeLogDeliveryResponse) SetHeaders(v map[string]*string) *DescribeDomainRealtimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRealtimeLogDeliveryResponse) SetStatusCode(v int32) *DescribeDomainRealtimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRealtimeLogDeliveryResponse) SetBody(v *DescribeDomainRealtimeLogDeliveryResponseBody) *DescribeDomainRealtimeLogDeliveryResponse {
	s.Body = v
	return s
}

type DescribeDomainRegionDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// By default, this operation queries the geographic distribution of users for all accelerated domain names.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainRegionDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRegionDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRegionDataRequest) SetDomainName(v string) *DescribeDomainRegionDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRegionDataRequest) SetEndTime(v string) *DescribeDomainRegionDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRegionDataRequest) SetStartTime(v string) *DescribeDomainRegionDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainRegionDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range for which the data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range for which the data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The proportions of requests initiated from each region.
	Value *DescribeDomainRegionDataResponseBodyValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDomainRegionDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRegionDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRegionDataResponseBody) SetDataInterval(v string) *DescribeDomainRegionDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBody) SetDomainName(v string) *DescribeDomainRegionDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBody) SetEndTime(v string) *DescribeDomainRegionDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBody) SetRequestId(v string) *DescribeDomainRegionDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBody) SetStartTime(v string) *DescribeDomainRegionDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBody) SetValue(v *DescribeDomainRegionDataResponseBodyValue) *DescribeDomainRegionDataResponseBody {
	s.Value = v
	return s
}

type DescribeDomainRegionDataResponseBodyValue struct {
	RegionProportionData []*DescribeDomainRegionDataResponseBodyValueRegionProportionData `json:"RegionProportionData,omitempty" xml:"RegionProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDomainRegionDataResponseBodyValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRegionDataResponseBodyValue) GoString() string {
	return s.String()
}

func (s *DescribeDomainRegionDataResponseBodyValue) SetRegionProportionData(v []*DescribeDomainRegionDataResponseBodyValueRegionProportionData) *DescribeDomainRegionDataResponseBodyValue {
	s.RegionProportionData = v
	return s
}

type DescribeDomainRegionDataResponseBodyValueRegionProportionData struct {
	// The average response size. Unit: bytes.
	AvgObjectSize *string `json:"AvgObjectSize,omitempty" xml:"AvgObjectSize,omitempty"`
	// The average response speed. Unit: bit/s.
	AvgResponseRate *string `json:"AvgResponseRate,omitempty" xml:"AvgResponseRate,omitempty"`
	// The average response time. Unit: milliseconds.
	AvgResponseTime *string `json:"AvgResponseTime,omitempty" xml:"AvgResponseTime,omitempty"`
	// The bandwidth.
	Bps *string `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The proportion of traffic from the region. For example, a value of 90 indicates that 90% of the traffic is from the region.
	BytesProportion *string `json:"BytesProportion,omitempty" xml:"BytesProportion,omitempty"`
	// The proportion of visits from the region. For example, a value of 90 indicates that 90% of the visits are from the region.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
	// The number of queries per second.
	Qps *string `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The information about the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The name of the region.
	RegionEname *string `json:"RegionEname,omitempty" xml:"RegionEname,omitempty"`
	// The request error rate. A value of 90 indicates that 90% of the requests encountered errors.
	ReqErrRate *string `json:"ReqErrRate,omitempty" xml:"ReqErrRate,omitempty"`
	// The total traffic. Unit: bytes.
	TotalBytes *string `json:"TotalBytes,omitempty" xml:"TotalBytes,omitempty"`
	// The total number of requests.
	TotalQuery *string `json:"TotalQuery,omitempty" xml:"TotalQuery,omitempty"`
}

func (s DescribeDomainRegionDataResponseBodyValueRegionProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRegionDataResponseBodyValueRegionProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetAvgObjectSize(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.AvgObjectSize = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetAvgResponseRate(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.AvgResponseRate = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetAvgResponseTime(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.AvgResponseTime = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetBps(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.Bps = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetBytesProportion(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.BytesProportion = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetProportion(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.Proportion = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetQps(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.Qps = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetRegion(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.Region = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetRegionEname(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.RegionEname = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetReqErrRate(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.ReqErrRate = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetTotalBytes(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.TotalBytes = &v
	return s
}

func (s *DescribeDomainRegionDataResponseBodyValueRegionProportionData) SetTotalQuery(v string) *DescribeDomainRegionDataResponseBodyValueRegionProportionData {
	s.TotalQuery = &v
	return s
}

type DescribeDomainRegionDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRegionDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRegionDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRegionDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRegionDataResponse) SetHeaders(v map[string]*string) *DescribeDomainRegionDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRegionDataResponse) SetStatusCode(v int32) *DescribeDomainRegionDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRegionDataResponse) SetBody(v *DescribeDomainRegionDataResponseBody) *DescribeDomainRegionDataResponse {
	s.Body = v
	return s
}

type DescribeDomainReqHitRateDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries the request hit ratio for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainReqHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainReqHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainReqHitRateDataRequest) SetDomainName(v string) *DescribeDomainReqHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainReqHitRateDataRequest) SetEndTime(v string) *DescribeDomainReqHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainReqHitRateDataRequest) SetInterval(v string) *DescribeDomainReqHitRateDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainReqHitRateDataRequest) SetStartTime(v string) *DescribeDomainReqHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainReqHitRateDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The request hit ratio data at each time interval. The hit ratio is measured in percentage.
	ReqHitRateInterval *DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval `json:"ReqHitRateInterval,omitempty" xml:"ReqHitRateInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainReqHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainReqHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainReqHitRateDataResponseBody) SetDataInterval(v string) *DescribeDomainReqHitRateDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainReqHitRateDataResponseBody) SetDomainName(v string) *DescribeDomainReqHitRateDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainReqHitRateDataResponseBody) SetEndTime(v string) *DescribeDomainReqHitRateDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainReqHitRateDataResponseBody) SetReqHitRateInterval(v *DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval) *DescribeDomainReqHitRateDataResponseBody {
	s.ReqHitRateInterval = v
	return s
}

func (s *DescribeDomainReqHitRateDataResponseBody) SetRequestId(v string) *DescribeDomainReqHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainReqHitRateDataResponseBody) SetStartTime(v string) *DescribeDomainReqHitRateDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval struct {
	DataModule []*DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval) SetDataModule(v []*DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule) *DescribeDomainReqHitRateDataResponseBodyReqHitRateInterval {
	s.DataModule = v
	return s
}

type DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule struct {
	// The hit ratio of HTTPS requests.
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The request hit ratio.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule) SetHttpsValue(v string) *DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule) SetTimeStamp(v string) *DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule) SetValue(v string) *DescribeDomainReqHitRateDataResponseBodyReqHitRateIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainReqHitRateDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainReqHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainReqHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainReqHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainReqHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeDomainReqHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainReqHitRateDataResponse) SetStatusCode(v int32) *DescribeDomainReqHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainReqHitRateDataResponse) SetBody(v *DescribeDomainReqHitRateDataResponseBody) *DescribeDomainReqHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeDomainSrcBpsDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each call. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries the geographic distribution of users for all accelerated domain names.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcBpsDataRequest) SetDomainName(v string) *DescribeDomainSrcBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcBpsDataRequest) SetEndTime(v string) *DescribeDomainSrcBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcBpsDataRequest) SetInterval(v string) *DescribeDomainSrcBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainSrcBpsDataRequest) SetStartTime(v string) *DescribeDomainSrcBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcBpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The origin bandwidth data at each time interval. Unit: bit/s.
	SrcBpsDataPerInterval *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval `json:"SrcBpsDataPerInterval,omitempty" xml:"SrcBpsDataPerInterval,omitempty" type:"Struct"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcBpsDataResponseBody) SetDataInterval(v string) *DescribeDomainSrcBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainSrcBpsDataResponseBody) SetDomainName(v string) *DescribeDomainSrcBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcBpsDataResponseBody) SetEndTime(v string) *DescribeDomainSrcBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcBpsDataResponseBody) SetRequestId(v string) *DescribeDomainSrcBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainSrcBpsDataResponseBody) SetSrcBpsDataPerInterval(v *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) *DescribeDomainSrcBpsDataResponseBody {
	s.SrcBpsDataPerInterval = v
	return s
}

func (s *DescribeDomainSrcBpsDataResponseBody) SetStartTime(v string) *DescribeDomainSrcBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval struct {
	DataModule []*DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) SetDataModule(v []*DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule struct {
	// The bandwidth values of origin HTTPS requests.
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic value at each time interval.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetValue(v string) *DescribeDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainSrcBpsDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainSrcBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainSrcBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainSrcBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainSrcBpsDataResponse) SetStatusCode(v int32) *DescribeDomainSrcBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainSrcBpsDataResponse) SetBody(v *DescribeDomainSrcBpsDataResponseBody) *DescribeDomainSrcBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainSrcHttpCodeDataRequest struct {
	// The accelerated domain name. You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format in the ISO 8601 standard. The time is displayed in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries to return. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcHttpCodeDataRequest) SetDomainName(v string) *DescribeDomainSrcHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataRequest) SetEndTime(v string) *DescribeDomainSrcHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataRequest) SetInterval(v string) *DescribeDomainSrcHttpCodeDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataRequest) SetStartTime(v string) *DescribeDomainSrcHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcHttpCodeDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The proportions of HTTP status codes at each time interval.
	HttpCodeData *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData `json:"HttpCodeData,omitempty" xml:"HttpCodeData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDomainSrcHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDomainSrcHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDomainSrcHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBody) SetHttpCodeData(v *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData) *DescribeDomainSrcHttpCodeDataResponseBody {
	s.HttpCodeData = v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDomainSrcHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDomainSrcHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData struct {
	UsageData []*DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData) SetUsageData(v []*DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData) *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeData {
	s.UsageData = v
	return s
}

type DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The proportions of the HTTP status codes.
	Value *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData) SetTimeStamp(v string) *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData) SetValue(v *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageData {
	s.Value = v
	return s
}

type DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue struct {
	CodeProportionData []*DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData `json:"CodeProportionData,omitempty" xml:"CodeProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue) SetCodeProportionData(v []*DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValue {
	s.CodeProportionData = v
	return s
}

type DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData struct {
	// The HTTP status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The total number of entries.
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) SetCode(v string) *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData {
	s.Code = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) SetCount(v string) *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData {
	s.Count = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData) SetProportion(v string) *DescribeDomainSrcHttpCodeDataResponseBodyHttpCodeDataUsageDataValueCodeProportionData {
	s.Proportion = &v
	return s
}

type DescribeDomainSrcHttpCodeDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainSrcHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainSrcHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDomainSrcHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDomainSrcHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainSrcHttpCodeDataResponse) SetBody(v *DescribeDomainSrcHttpCodeDataResponseBody) *DescribeDomainSrcHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDomainSrcQpsDataRequest struct {
	// The accelerated domain name. You can specify multiple domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries QPS data for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// If you leave this parameter empty, data collected in the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcQpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcQpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcQpsDataRequest) SetDomainName(v string) *DescribeDomainSrcQpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcQpsDataRequest) SetEndTime(v string) *DescribeDomainSrcQpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcQpsDataRequest) SetInterval(v string) *DescribeDomainSrcQpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainSrcQpsDataRequest) SetStartTime(v string) *DescribeDomainSrcQpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcQpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The back-to-origin bandwidth information at each interval.
	SrcQpsDataPerInterval *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval `json:"SrcQpsDataPerInterval,omitempty" xml:"SrcQpsDataPerInterval,omitempty" type:"Struct"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcQpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcQpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcQpsDataResponseBody) SetDataInterval(v string) *DescribeDomainSrcQpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainSrcQpsDataResponseBody) SetDomainName(v string) *DescribeDomainSrcQpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcQpsDataResponseBody) SetEndTime(v string) *DescribeDomainSrcQpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcQpsDataResponseBody) SetRequestId(v string) *DescribeDomainSrcQpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainSrcQpsDataResponseBody) SetSrcQpsDataPerInterval(v *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval) *DescribeDomainSrcQpsDataResponseBody {
	s.SrcQpsDataPerInterval = v
	return s
}

func (s *DescribeDomainSrcQpsDataResponseBody) SetStartTime(v string) *DescribeDomainSrcQpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval struct {
	DataModule []*DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval) SetDataModule(v []*DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule) *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The QPS value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule) SetValue(v string) *DescribeDomainSrcQpsDataResponseBodySrcQpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainSrcQpsDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainSrcQpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainSrcQpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcQpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcQpsDataResponse) SetHeaders(v map[string]*string) *DescribeDomainSrcQpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainSrcQpsDataResponse) SetStatusCode(v int32) *DescribeDomainSrcQpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainSrcQpsDataResponse) SetBody(v *DescribeDomainSrcQpsDataResponseBody) *DescribeDomainSrcQpsDataResponse {
	s.Body = v
	return s
}

type DescribeDomainSrcTopUrlVisitRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time. The duration between the end time and the start time cannot exceed seven days.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The method that is used to sort the returned URLs. Default value: **pv**. Valid values:
	//
	// *   **traf**: by network traffic
	// *   **pv**: by the number of visits
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > If you leave this parameter empty, data within the previous day is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcTopUrlVisitRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitRequest) SetDomainName(v string) *DescribeDomainSrcTopUrlVisitRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitRequest) SetEndTime(v string) *DescribeDomainSrcTopUrlVisitRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitRequest) SetSortBy(v string) *DescribeDomainSrcTopUrlVisitRequest {
	s.SortBy = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitRequest) SetStartTime(v string) *DescribeDomainSrcTopUrlVisitRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBody struct {
	// A list of frequently requested URLs.
	AllUrlList *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList `json:"AllUrlList,omitempty" xml:"AllUrlList,omitempty" type:"Struct"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// A list of URLs for which 2xx status codes were returned.
	Url200List *DescribeDomainSrcTopUrlVisitResponseBodyUrl200List `json:"Url200List,omitempty" xml:"Url200List,omitempty" type:"Struct"`
	// A list of URLs for which 3xx status codes were returned.
	Url300List *DescribeDomainSrcTopUrlVisitResponseBodyUrl300List `json:"Url300List,omitempty" xml:"Url300List,omitempty" type:"Struct"`
	// A list of URLs for which 4xx status codes were returned.
	Url400List *DescribeDomainSrcTopUrlVisitResponseBodyUrl400List `json:"Url400List,omitempty" xml:"Url400List,omitempty" type:"Struct"`
	// A list of URLs for which 5xx status codes were returned.
	Url500List *DescribeDomainSrcTopUrlVisitResponseBodyUrl500List `json:"Url500List,omitempty" xml:"Url500List,omitempty" type:"Struct"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetAllUrlList(v *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.AllUrlList = v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetDomainName(v string) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetRequestId(v string) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetStartTime(v string) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetUrl200List(v *DescribeDomainSrcTopUrlVisitResponseBodyUrl200List) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.Url200List = v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetUrl300List(v *DescribeDomainSrcTopUrlVisitResponseBodyUrl300List) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.Url300List = v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetUrl400List(v *DescribeDomainSrcTopUrlVisitResponseBodyUrl400List) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.Url400List = v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBody) SetUrl500List(v *DescribeDomainSrcTopUrlVisitResponseBodyUrl500List) *DescribeDomainSrcTopUrlVisitResponseBody {
	s.Url500List = v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList struct {
	UrlList []*DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList) SetUrlList(v []*DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlList {
	s.UrlList = v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) SetFlow(v string) *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) SetFlowProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) SetUrlDetail(v string) *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) SetVisitData(v string) *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList) SetVisitProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyAllUrlListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl200List struct {
	UrlList []*DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl200List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl200List) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl200List) SetUrlList(v []*DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) *DescribeDomainSrcTopUrlVisitResponseBodyUrl200List {
	s.UrlList = v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) SetFlow(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) SetFlowProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) SetUrlDetail(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) SetVisitData(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList) SetVisitProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl200ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl300List struct {
	UrlList []*DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl300List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl300List) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl300List) SetUrlList(v []*DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) *DescribeDomainSrcTopUrlVisitResponseBodyUrl300List {
	s.UrlList = v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) SetFlow(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) SetFlowProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) SetUrlDetail(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) SetVisitData(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList) SetVisitProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl300ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl400List struct {
	UrlList []*DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl400List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl400List) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl400List) SetUrlList(v []*DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) *DescribeDomainSrcTopUrlVisitResponseBodyUrl400List {
	s.UrlList = v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) SetFlow(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) SetFlowProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) SetUrlDetail(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) SetVisitData(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList) SetVisitProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl400ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl500List struct {
	UrlList []*DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl500List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl500List) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl500List) SetUrlList(v []*DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) *DescribeDomainSrcTopUrlVisitResponseBodyUrl500List {
	s.UrlList = v
	return s
}

type DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) SetFlow(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) SetFlowProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) SetUrlDetail(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) SetVisitData(v string) *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList) SetVisitProportion(v float32) *DescribeDomainSrcTopUrlVisitResponseBodyUrl500ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainSrcTopUrlVisitResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainSrcTopUrlVisitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainSrcTopUrlVisitResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTopUrlVisitResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTopUrlVisitResponse) SetHeaders(v map[string]*string) *DescribeDomainSrcTopUrlVisitResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponse) SetStatusCode(v int32) *DescribeDomainSrcTopUrlVisitResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainSrcTopUrlVisitResponse) SetBody(v *DescribeDomainSrcTopUrlVisitResponseBody) *DescribeDomainSrcTopUrlVisitResponse {
	s.Body = v
	return s
}

type DescribeDomainSrcTrafficDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries the origin traffic for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTrafficDataRequest) SetDomainName(v string) *DescribeDomainSrcTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataRequest) SetEndTime(v string) *DescribeDomainSrcTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataRequest) SetInterval(v string) *DescribeDomainSrcTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataRequest) SetStartTime(v string) *DescribeDomainSrcTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The amount of origin traffic returned at each time interval. Unit: bytes.
	SrcTrafficDataPerInterval *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval `json:"SrcTrafficDataPerInterval,omitempty" xml:"SrcTrafficDataPerInterval,omitempty" type:"Struct"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainSrcTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTrafficDataResponseBody) SetDataInterval(v string) *DescribeDomainSrcTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponseBody) SetDomainName(v string) *DescribeDomainSrcTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponseBody) SetEndTime(v string) *DescribeDomainSrcTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponseBody) SetRequestId(v string) *DescribeDomainSrcTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponseBody) SetSrcTrafficDataPerInterval(v *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) *DescribeDomainSrcTrafficDataResponseBody {
	s.SrcTrafficDataPerInterval = v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponseBody) SetStartTime(v string) *DescribeDomainSrcTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval struct {
	DataModule []*DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) SetDataModule(v []*DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule struct {
	// The amount of traffic generated by origin HTTPS requests.
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic value at each time interval.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainSrcTrafficDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainSrcTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainSrcTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSrcTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainSrcTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDomainSrcTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponse) SetStatusCode(v int32) *DescribeDomainSrcTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainSrcTrafficDataResponse) SetBody(v *DescribeDomainSrcTrafficDataResponseBody) *DescribeDomainSrcTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDomainTopClientIpVisitRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// By default, this operation queries client IP addresses for all accelerated domain names.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of entries to return. Maximum value: 100.
	//
	// Default value: 20. The default value specifies that the top 20 IP addresses are returned.
	Limit *string `json:"Limit,omitempty" xml:"Limit,omitempty"`
	// The name of the region. Separate multiple region names with commas (,).
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The criterion by which you want to sort client IP addresses. Valid values:
	//
	// *   **traf**: by network traffic. This is the default value.
	// *   **acc**: by the number of requests.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainTopClientIpVisitRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopClientIpVisitRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopClientIpVisitRequest) SetDomainName(v string) *DescribeDomainTopClientIpVisitRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitRequest) SetEndTime(v string) *DescribeDomainTopClientIpVisitRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitRequest) SetLimit(v string) *DescribeDomainTopClientIpVisitRequest {
	s.Limit = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitRequest) SetLocationNameEn(v string) *DescribeDomainTopClientIpVisitRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitRequest) SetSortBy(v string) *DescribeDomainTopClientIpVisitRequest {
	s.SortBy = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitRequest) SetStartTime(v string) *DescribeDomainTopClientIpVisitRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainTopClientIpVisitResponseBody struct {
	// A list of client IP addresses.
	ClientIpList []*DescribeDomainTopClientIpVisitResponseBodyClientIpList `json:"ClientIpList,omitempty" xml:"ClientIpList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainTopClientIpVisitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopClientIpVisitResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopClientIpVisitResponseBody) SetClientIpList(v []*DescribeDomainTopClientIpVisitResponseBodyClientIpList) *DescribeDomainTopClientIpVisitResponseBody {
	s.ClientIpList = v
	return s
}

func (s *DescribeDomainTopClientIpVisitResponseBody) SetRequestId(v string) *DescribeDomainTopClientIpVisitResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainTopClientIpVisitResponseBodyClientIpList struct {
	// The total number of requests.
	Acc *int64 `json:"Acc,omitempty" xml:"Acc,omitempty"`
	// The client IP address returned. Only IPv4 addressed are supported.
	ClientIp *string `json:"ClientIp,omitempty" xml:"ClientIp,omitempty"`
	// The ranking of the client IP address returned.
	Rank *int32 `json:"Rank,omitempty" xml:"Rank,omitempty"`
	// The total amount of network traffic consumed. Unit: bytes.
	Traffic *int64 `json:"Traffic,omitempty" xml:"Traffic,omitempty"`
}

func (s DescribeDomainTopClientIpVisitResponseBodyClientIpList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopClientIpVisitResponseBodyClientIpList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopClientIpVisitResponseBodyClientIpList) SetAcc(v int64) *DescribeDomainTopClientIpVisitResponseBodyClientIpList {
	s.Acc = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitResponseBodyClientIpList) SetClientIp(v string) *DescribeDomainTopClientIpVisitResponseBodyClientIpList {
	s.ClientIp = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitResponseBodyClientIpList) SetRank(v int32) *DescribeDomainTopClientIpVisitResponseBodyClientIpList {
	s.Rank = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitResponseBodyClientIpList) SetTraffic(v int64) *DescribeDomainTopClientIpVisitResponseBodyClientIpList {
	s.Traffic = &v
	return s
}

type DescribeDomainTopClientIpVisitResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainTopClientIpVisitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainTopClientIpVisitResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopClientIpVisitResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopClientIpVisitResponse) SetHeaders(v map[string]*string) *DescribeDomainTopClientIpVisitResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainTopClientIpVisitResponse) SetStatusCode(v int32) *DescribeDomainTopClientIpVisitResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainTopClientIpVisitResponse) SetBody(v *DescribeDomainTopClientIpVisitResponseBody) *DescribeDomainTopClientIpVisitResponse {
	s.Body = v
	return s
}

type DescribeDomainTopReferVisitRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The order in which you want to sort the queried information. Valid values:
	//
	// *   **traf**: by network traffic.
	// *   **pv**: by the number of page views. This is the default value.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainTopReferVisitRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopReferVisitRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopReferVisitRequest) SetDomainName(v string) *DescribeDomainTopReferVisitRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainTopReferVisitRequest) SetEndTime(v string) *DescribeDomainTopReferVisitRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainTopReferVisitRequest) SetSortBy(v string) *DescribeDomainTopReferVisitRequest {
	s.SortBy = &v
	return s
}

func (s *DescribeDomainTopReferVisitRequest) SetStartTime(v string) *DescribeDomainTopReferVisitRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainTopReferVisitResponseBody struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The most frequently requested web pages.
	TopReferList *DescribeDomainTopReferVisitResponseBodyTopReferList `json:"TopReferList,omitempty" xml:"TopReferList,omitempty" type:"Struct"`
}

func (s DescribeDomainTopReferVisitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopReferVisitResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopReferVisitResponseBody) SetDomainName(v string) *DescribeDomainTopReferVisitResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponseBody) SetRequestId(v string) *DescribeDomainTopReferVisitResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponseBody) SetStartTime(v string) *DescribeDomainTopReferVisitResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponseBody) SetTopReferList(v *DescribeDomainTopReferVisitResponseBodyTopReferList) *DescribeDomainTopReferVisitResponseBody {
	s.TopReferList = v
	return s
}

type DescribeDomainTopReferVisitResponseBodyTopReferList struct {
	ReferList []*DescribeDomainTopReferVisitResponseBodyTopReferListReferList `json:"ReferList,omitempty" xml:"ReferList,omitempty" type:"Repeated"`
}

func (s DescribeDomainTopReferVisitResponseBodyTopReferList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopReferVisitResponseBodyTopReferList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopReferVisitResponseBodyTopReferList) SetReferList(v []*DescribeDomainTopReferVisitResponseBodyTopReferListReferList) *DescribeDomainTopReferVisitResponseBodyTopReferList {
	s.ReferList = v
	return s
}

type DescribeDomainTopReferVisitResponseBodyTopReferListReferList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The URLs to the most frequently requested web pages.
	ReferDetail *string `json:"ReferDetail,omitempty" xml:"ReferDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainTopReferVisitResponseBodyTopReferListReferList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopReferVisitResponseBodyTopReferListReferList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopReferVisitResponseBodyTopReferListReferList) SetFlow(v string) *DescribeDomainTopReferVisitResponseBodyTopReferListReferList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponseBodyTopReferListReferList) SetFlowProportion(v float32) *DescribeDomainTopReferVisitResponseBodyTopReferListReferList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponseBodyTopReferListReferList) SetReferDetail(v string) *DescribeDomainTopReferVisitResponseBodyTopReferListReferList {
	s.ReferDetail = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponseBodyTopReferListReferList) SetVisitData(v string) *DescribeDomainTopReferVisitResponseBodyTopReferListReferList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponseBodyTopReferListReferList) SetVisitProportion(v float32) *DescribeDomainTopReferVisitResponseBodyTopReferListReferList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainTopReferVisitResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainTopReferVisitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainTopReferVisitResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopReferVisitResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopReferVisitResponse) SetHeaders(v map[string]*string) *DescribeDomainTopReferVisitResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainTopReferVisitResponse) SetStatusCode(v int32) *DescribeDomainTopReferVisitResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainTopReferVisitResponse) SetBody(v *DescribeDomainTopReferVisitResponseBody) *DescribeDomainTopReferVisitResponse {
	s.Body = v
	return s
}

type DescribeDomainTopUrlVisitRequest struct {
	// The accelerated domain name that you want to query.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time. The maximum time range that can be specified is seven days.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The method that is used to sort the returned URLs. Default value: **pv**. Valid values:
	//
	// *   **traf**: by network traffic
	// *   **pv**: by the number of page views
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The start of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// If you want to query data of a specific day, we recommend that you set the value in the yyyy-MM-ddT16:00:00Z format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainTopUrlVisitRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitRequest) SetDomainName(v string) *DescribeDomainTopUrlVisitRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainTopUrlVisitRequest) SetEndTime(v string) *DescribeDomainTopUrlVisitRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainTopUrlVisitRequest) SetSortBy(v string) *DescribeDomainTopUrlVisitRequest {
	s.SortBy = &v
	return s
}

func (s *DescribeDomainTopUrlVisitRequest) SetStartTime(v string) *DescribeDomainTopUrlVisitRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainTopUrlVisitResponseBody struct {
	// A list of frequently requested URLs.
	AllUrlList *DescribeDomainTopUrlVisitResponseBodyAllUrlList `json:"AllUrlList,omitempty" xml:"AllUrlList,omitempty" type:"Struct"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// A list of URLs for which 2xx status codes were returned.
	Url200List *DescribeDomainTopUrlVisitResponseBodyUrl200List `json:"Url200List,omitempty" xml:"Url200List,omitempty" type:"Struct"`
	// A list of URLs for which 3xx status codes were returned.
	Url300List *DescribeDomainTopUrlVisitResponseBodyUrl300List `json:"Url300List,omitempty" xml:"Url300List,omitempty" type:"Struct"`
	// A list of URLs for which 4xx status codes were returned.
	Url400List *DescribeDomainTopUrlVisitResponseBodyUrl400List `json:"Url400List,omitempty" xml:"Url400List,omitempty" type:"Struct"`
	// A list of URLs for which 5xx status codes were returned.
	Url500List *DescribeDomainTopUrlVisitResponseBodyUrl500List `json:"Url500List,omitempty" xml:"Url500List,omitempty" type:"Struct"`
}

func (s DescribeDomainTopUrlVisitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetAllUrlList(v *DescribeDomainTopUrlVisitResponseBodyAllUrlList) *DescribeDomainTopUrlVisitResponseBody {
	s.AllUrlList = v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetDomainName(v string) *DescribeDomainTopUrlVisitResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetRequestId(v string) *DescribeDomainTopUrlVisitResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetStartTime(v string) *DescribeDomainTopUrlVisitResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetUrl200List(v *DescribeDomainTopUrlVisitResponseBodyUrl200List) *DescribeDomainTopUrlVisitResponseBody {
	s.Url200List = v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetUrl300List(v *DescribeDomainTopUrlVisitResponseBodyUrl300List) *DescribeDomainTopUrlVisitResponseBody {
	s.Url300List = v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetUrl400List(v *DescribeDomainTopUrlVisitResponseBodyUrl400List) *DescribeDomainTopUrlVisitResponseBody {
	s.Url400List = v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBody) SetUrl500List(v *DescribeDomainTopUrlVisitResponseBodyUrl500List) *DescribeDomainTopUrlVisitResponseBody {
	s.Url500List = v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyAllUrlList struct {
	UrlList []*DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainTopUrlVisitResponseBodyAllUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyAllUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyAllUrlList) SetUrlList(v []*DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) *DescribeDomainTopUrlVisitResponseBodyAllUrlList {
	s.UrlList = v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetFlow(v string) *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetFlowProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetUrlDetail(v string) *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetVisitData(v string) *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetVisitProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl200List struct {
	UrlList []*DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl200List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl200List) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl200List) SetUrlList(v []*DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) *DescribeDomainTopUrlVisitResponseBodyUrl200List {
	s.UrlList = v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetFlow(v string) *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetFlowProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetUrlDetail(v string) *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetVisitData(v string) *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetVisitProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl300List struct {
	UrlList []*DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl300List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl300List) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl300List) SetUrlList(v []*DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) *DescribeDomainTopUrlVisitResponseBodyUrl300List {
	s.UrlList = v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetFlow(v string) *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetFlowProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetUrlDetail(v string) *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetVisitData(v string) *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetVisitProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl400List struct {
	UrlList []*DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl400List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl400List) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl400List) SetUrlList(v []*DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) *DescribeDomainTopUrlVisitResponseBodyUrl400List {
	s.UrlList = v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetFlow(v string) *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetFlowProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetUrlDetail(v string) *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetVisitData(v string) *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetVisitProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl500List struct {
	UrlList []*DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl500List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl500List) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl500List) SetUrlList(v []*DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) *DescribeDomainTopUrlVisitResponseBodyUrl500List {
	s.UrlList = v
	return s
}

type DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList struct {
	// The amount of network traffic. Unit: bytes.
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits to the URL.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetFlow(v string) *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetFlowProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetUrlDetail(v string) *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetVisitData(v string) *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetVisitProportion(v float32) *DescribeDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDomainTopUrlVisitResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainTopUrlVisitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainTopUrlVisitResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopUrlVisitResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopUrlVisitResponse) SetHeaders(v map[string]*string) *DescribeDomainTopUrlVisitResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainTopUrlVisitResponse) SetStatusCode(v int32) *DescribeDomainTopUrlVisitResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainTopUrlVisitResponse) SetBody(v *DescribeDomainTopUrlVisitResponseBody) *DescribeDomainTopUrlVisitResponse {
	s.Body = v
	return s
}

type DescribeDomainTrafficDataRequest struct {
	// The accelerated domain name. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
	//
	// By default, this operation queries the network traffic for all accelerated domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](~~DescribeCdnRegionAndIsp~~) operation to query ISPs.
	//
	// If you do not specify an ISP, data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. You can call the [DescribeCdnRegionAndIsp](~~DescribeCdnRegionAndIsp~~) operation to query regions.
	//
	// If you do not specify a region, data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainTrafficDataRequest) SetDomainName(v string) *DescribeDomainTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainTrafficDataRequest) SetEndTime(v string) *DescribeDomainTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainTrafficDataRequest) SetInterval(v string) *DescribeDomainTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainTrafficDataRequest) SetIspNameEn(v string) *DescribeDomainTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDomainTrafficDataRequest) SetLocationNameEn(v string) *DescribeDomainTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDomainTrafficDataRequest) SetStartTime(v string) *DescribeDomainTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The amount of network traffic at each time interval. Unit: bytes.
	TrafficDataPerInterval *DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval `json:"TrafficDataPerInterval,omitempty" xml:"TrafficDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDomainTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainTrafficDataResponseBody) SetDataInterval(v string) *DescribeDomainTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBody) SetDomainName(v string) *DescribeDomainTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBody) SetEndTime(v string) *DescribeDomainTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBody) SetRequestId(v string) *DescribeDomainTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBody) SetStartTime(v string) *DescribeDomainTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBody) SetTrafficDataPerInterval(v *DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval) *DescribeDomainTrafficDataResponseBody {
	s.TrafficDataPerInterval = v
	return s
}

type DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval struct {
	DataModule []*DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval) SetDataModule(v []*DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) *DescribeDomainTrafficDataResponseBodyTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule struct {
	// The amount of network traffic in the Chinese mainland.
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The amount of HTTPS traffic on points of presence (POPs) in the Chinese mainland.
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	// The amount of HTTPS traffic on POPs outside the Chinese mainland.
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	// The total amount of HTTPS traffic on POPs.
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The amount of network traffic outside the Chinese mainland.
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total volume of traffic.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetDomesticValue(v string) *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetOverseasValue(v string) *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainTrafficDataResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDomainTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainTrafficDataResponse) SetStatusCode(v int32) *DescribeDomainTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainTrafficDataResponse) SetBody(v *DescribeDomainTrafficDataResponseBody) *DescribeDomainTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDomainUsageDataRequest struct {
	// The ID of the billable region. Valid values:
	//
	// *   **CN** (default): inside the Chinese mainland
	// *   **OverSeas**: outside the Chinese mainland
	// *   **AP1**: Asia Pacific 1
	// *   **AP2**: Asia Pacific 2
	// *   **AP3**: Asia Pacific 3
	// *   **NA**: North America
	// *   **SA**: South America
	// *   **EU**: Europe
	// *   **MEAA**: Middle East and Africa
	// *   **all**: all the preceding billable regions
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The protocol of the data that you want to query. Valid values:
	//
	// *   **http**: HTTP
	// *   **https**: HTTPS
	// *   **quic**: QUIC
	// *   **all** (default): HTTP, HTTPS, and QUIC
	DataProtocol *string `json:"DataProtocol,omitempty" xml:"DataProtocol,omitempty"`
	// The accelerated domain name. You can specify up to 100 domain names in each request. Separate multiple domain names with commas (,).
	//
	// > If you leave this parameter empty, the usage data of all accelerated domain names in your Alibaba Cloud account is returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time. The maximum time range that can be specified is 31 days.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the data that you want to query. Valid values:
	//
	// *   **bps**: bandwidth
	// *   **traf**: traffic
	// *   **acc**: requests
	//
	// > If you set this parameter to **acc**, the **Area** parameter is not supported.
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The time granularity of the data entries. Unit: seconds. Valid values: **300** (5 minutes), **3600** (1 hour), and **86400** (1 day).
	//
	// *   If **Interval** is set to **300**, you can query usage data in the last 6 months. The maximum time range per query that can be specified is 3 days.
	// *   If **Interval** is set to **3600** or **86400**, you can query usage data of the previous year.
	// *   If you leave the **Interval** parameter empty, the maximum time range that you can query is 1 month. If you specify a time range of 1 to 3 days, the time interval between the entries that are returned is 1 hour. If you specify a time range of at least 4 days, the time interval between the entries that are returned is 1 day.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > Data is collected every 5 minutes.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of content that you want to query. Valid values:
	//
	// *   **static**: static content
	// *   **dynamic**: dynamic content
	// *   **all** (default): both static and dynamic content
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDomainUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainUsageDataRequest) SetArea(v string) *DescribeDomainUsageDataRequest {
	s.Area = &v
	return s
}

func (s *DescribeDomainUsageDataRequest) SetDataProtocol(v string) *DescribeDomainUsageDataRequest {
	s.DataProtocol = &v
	return s
}

func (s *DescribeDomainUsageDataRequest) SetDomainName(v string) *DescribeDomainUsageDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainUsageDataRequest) SetEndTime(v string) *DescribeDomainUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainUsageDataRequest) SetField(v string) *DescribeDomainUsageDataRequest {
	s.Field = &v
	return s
}

func (s *DescribeDomainUsageDataRequest) SetInterval(v string) *DescribeDomainUsageDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainUsageDataRequest) SetStartTime(v string) *DescribeDomainUsageDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainUsageDataRequest) SetType(v string) *DescribeDomainUsageDataRequest {
	s.Type = &v
	return s
}

type DescribeDomainUsageDataResponseBody struct {
	// The ID of the billable region where the data was collected.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of content.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The resource usage that was collected at each interval.
	UsageDataPerInterval *DescribeDomainUsageDataResponseBodyUsageDataPerInterval `json:"UsageDataPerInterval,omitempty" xml:"UsageDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDomainUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainUsageDataResponseBody) SetArea(v string) *DescribeDomainUsageDataResponseBody {
	s.Area = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBody) SetDataInterval(v string) *DescribeDomainUsageDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBody) SetDomainName(v string) *DescribeDomainUsageDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBody) SetEndTime(v string) *DescribeDomainUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBody) SetRequestId(v string) *DescribeDomainUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBody) SetStartTime(v string) *DescribeDomainUsageDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBody) SetType(v string) *DescribeDomainUsageDataResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBody) SetUsageDataPerInterval(v *DescribeDomainUsageDataResponseBodyUsageDataPerInterval) *DescribeDomainUsageDataResponseBody {
	s.UsageDataPerInterval = v
	return s
}

type DescribeDomainUsageDataResponseBodyUsageDataPerInterval struct {
	DataModule []*DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDomainUsageDataResponseBodyUsageDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUsageDataResponseBodyUsageDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainUsageDataResponseBodyUsageDataPerInterval) SetDataModule(v []*DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) *DescribeDomainUsageDataResponseBodyUsageDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule struct {
	// The time of the peak bandwidth value if the **Field** parameter in the request is set to **bps**. Otherwise, this parameter returns the same value as the **TimeStamp** parameter.
	PeakTime *string `json:"PeakTime,omitempty" xml:"PeakTime,omitempty"`
	// The resource usage in a specific scenario.
	//
	// > SpecialValue indicates the data usage in a specific scenario. If no special billable item is specified, ignore this parameter.
	SpecialValue *string `json:"SpecialValue,omitempty" xml:"SpecialValue,omitempty"`
	// The timestamp of the data returned.
	//
	// > **TimeStamp** indicates the timestamp of the data returned at each interval.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The amount of resource usage.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetPeakTime(v string) *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.PeakTime = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetSpecialValue(v string) *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.SpecialValue = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetValue(v string) *DescribeDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDomainUsageDataResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainUsageDataResponse) SetHeaders(v map[string]*string) *DescribeDomainUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainUsageDataResponse) SetStatusCode(v int32) *DescribeDomainUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainUsageDataResponse) SetBody(v *DescribeDomainUsageDataResponseBody) *DescribeDomainUsageDataResponse {
	s.Body = v
	return s
}

type DescribeDomainUvDataRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainUvDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUvDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainUvDataRequest) SetDomainName(v string) *DescribeDomainUvDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainUvDataRequest) SetEndTime(v string) *DescribeDomainUvDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainUvDataRequest) SetStartTime(v string) *DescribeDomainUvDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainUvDataResponseBody struct {
	// The time interval. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range that was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The number of UVs at each interval.
	UvDataInterval *DescribeDomainUvDataResponseBodyUvDataInterval `json:"UvDataInterval,omitempty" xml:"UvDataInterval,omitempty" type:"Struct"`
}

func (s DescribeDomainUvDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUvDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainUvDataResponseBody) SetDataInterval(v string) *DescribeDomainUvDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainUvDataResponseBody) SetDomainName(v string) *DescribeDomainUvDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainUvDataResponseBody) SetEndTime(v string) *DescribeDomainUvDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainUvDataResponseBody) SetRequestId(v string) *DescribeDomainUvDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainUvDataResponseBody) SetStartTime(v string) *DescribeDomainUvDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainUvDataResponseBody) SetUvDataInterval(v *DescribeDomainUvDataResponseBodyUvDataInterval) *DescribeDomainUvDataResponseBody {
	s.UvDataInterval = v
	return s
}

type DescribeDomainUvDataResponseBodyUvDataInterval struct {
	UsageData []*DescribeDomainUvDataResponseBodyUvDataIntervalUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDomainUvDataResponseBodyUvDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUvDataResponseBodyUvDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDomainUvDataResponseBodyUvDataInterval) SetUsageData(v []*DescribeDomainUvDataResponseBodyUvDataIntervalUsageData) *DescribeDomainUvDataResponseBodyUvDataInterval {
	s.UsageData = v
	return s
}

type DescribeDomainUvDataResponseBodyUvDataIntervalUsageData struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The number of UVs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainUvDataResponseBodyUvDataIntervalUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUvDataResponseBodyUvDataIntervalUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDomainUvDataResponseBodyUvDataIntervalUsageData) SetTimeStamp(v string) *DescribeDomainUvDataResponseBodyUvDataIntervalUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainUvDataResponseBodyUvDataIntervalUsageData) SetValue(v string) *DescribeDomainUvDataResponseBodyUvDataIntervalUsageData {
	s.Value = &v
	return s
}

type DescribeDomainUvDataResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainUvDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainUvDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainUvDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainUvDataResponse) SetHeaders(v map[string]*string) *DescribeDomainUvDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainUvDataResponse) SetStatusCode(v int32) *DescribeDomainUvDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainUvDataResponse) SetBody(v *DescribeDomainUvDataResponseBody) *DescribeDomainUvDataResponse {
	s.Body = v
	return s
}

type DescribeDomainsBySourceRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The origin servers. Separate multiple origin servers with commas (,). Fuzzy match is not supported.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
}

func (s DescribeDomainsBySourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceRequest) SetOwnerId(v int64) *DescribeDomainsBySourceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDomainsBySourceRequest) SetSecurityToken(v string) *DescribeDomainsBySourceRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeDomainsBySourceRequest) SetSources(v string) *DescribeDomainsBySourceRequest {
	s.Sources = &v
	return s
}

type DescribeDomainsBySourceResponseBody struct {
	// The domain names corresponding to each origin server.
	DomainsList *DescribeDomainsBySourceResponseBodyDomainsList `json:"DomainsList,omitempty" xml:"DomainsList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The origin servers.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
}

func (s DescribeDomainsBySourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceResponseBody) SetDomainsList(v *DescribeDomainsBySourceResponseBodyDomainsList) *DescribeDomainsBySourceResponseBody {
	s.DomainsList = v
	return s
}

func (s *DescribeDomainsBySourceResponseBody) SetRequestId(v string) *DescribeDomainsBySourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainsBySourceResponseBody) SetSources(v string) *DescribeDomainsBySourceResponseBody {
	s.Sources = &v
	return s
}

type DescribeDomainsBySourceResponseBodyDomainsList struct {
	DomainsData []*DescribeDomainsBySourceResponseBodyDomainsListDomainsData `json:"DomainsData,omitempty" xml:"DomainsData,omitempty" type:"Repeated"`
}

func (s DescribeDomainsBySourceResponseBodyDomainsList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceResponseBodyDomainsList) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceResponseBodyDomainsList) SetDomainsData(v []*DescribeDomainsBySourceResponseBodyDomainsListDomainsData) *DescribeDomainsBySourceResponseBodyDomainsList {
	s.DomainsData = v
	return s
}

type DescribeDomainsBySourceResponseBodyDomainsListDomainsData struct {
	// Information about the domain name.
	DomainInfos *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos `json:"DomainInfos,omitempty" xml:"DomainInfos,omitempty" type:"Struct"`
	// The domain names that correspond to each origin server.
	Domains *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The origin server.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsData) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsData) SetDomainInfos(v *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos) *DescribeDomainsBySourceResponseBodyDomainsListDomainsData {
	s.DomainInfos = v
	return s
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsData) SetDomains(v *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains) *DescribeDomainsBySourceResponseBodyDomainsListDomainsData {
	s.Domains = v
	return s
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsData) SetSource(v string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsData {
	s.Source = &v
	return s
}

type DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos struct {
	DomainInfo []*DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo `json:"domainInfo,omitempty" xml:"domainInfo,omitempty" type:"Repeated"`
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos) SetDomainInfo(v []*DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfos {
	s.DomainInfo = v
	return s
}

type DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo struct {
	// The workload type of the accelerated domain name. Valid values:
	//
	// *   **web**: images and small files
	// *   **download**: large files
	// *   **video**: on-demand video and audio streaming
	CdnType *string `json:"CdnType,omitempty" xml:"CdnType,omitempty"`
	// The creation time.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The CNAME record assigned to the domain name.
	DomainCname *string `json:"DomainCname,omitempty" xml:"DomainCname,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the domain name. Valid values:
	//
	// *   **applying**: The domain name is under review.
	// *   **configuring**: The domain name is being configured.
	// *   **online**: The domain name is working as expected.
	// *   **stopping**: The domain name is being stopped.
	// *   **offline**: The domain name is disabled.
	// *   **disabling**: The domain name is being removed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The update time.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) SetCdnType(v string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo {
	s.CdnType = &v
	return s
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) SetCreateTime(v string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo {
	s.CreateTime = &v
	return s
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) SetDomainCname(v string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo {
	s.DomainCname = &v
	return s
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) SetDomainName(v string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) SetStatus(v string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo {
	s.Status = &v
	return s
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo) SetUpdateTime(v string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomainInfosDomainInfo {
	s.UpdateTime = &v
	return s
}

type DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains struct {
	DomainNames []*string `json:"domainNames,omitempty" xml:"domainNames,omitempty" type:"Repeated"`
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains) SetDomainNames(v []*string) *DescribeDomainsBySourceResponseBodyDomainsListDomainsDataDomains {
	s.DomainNames = v
	return s
}

type DescribeDomainsBySourceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainsBySourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainsBySourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsBySourceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainsBySourceResponse) SetHeaders(v map[string]*string) *DescribeDomainsBySourceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainsBySourceResponse) SetStatusCode(v int32) *DescribeDomainsBySourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainsBySourceResponse) SetBody(v *DescribeDomainsBySourceResponseBody) *DescribeDomainsBySourceResponse {
	s.Body = v
	return s
}

type DescribeDomainsUsageByDayRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	//
	// If you do not specify an accelerated domain name, the data of all accelerated domain names that belong to your account is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainsUsageByDayRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsUsageByDayRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainsUsageByDayRequest) SetDomainName(v string) *DescribeDomainsUsageByDayRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainsUsageByDayRequest) SetEndTime(v string) *DescribeDomainsUsageByDayRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainsUsageByDayRequest) SetStartTime(v string) *DescribeDomainsUsageByDayRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainsUsageByDayResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The monitoring data collected at each time interval.
	UsageByDays *DescribeDomainsUsageByDayResponseBodyUsageByDays `json:"UsageByDays,omitempty" xml:"UsageByDays,omitempty" type:"Struct"`
	// The summarized monitoring data.
	UsageTotal *DescribeDomainsUsageByDayResponseBodyUsageTotal `json:"UsageTotal,omitempty" xml:"UsageTotal,omitempty" type:"Struct"`
}

func (s DescribeDomainsUsageByDayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsUsageByDayResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainsUsageByDayResponseBody) SetDataInterval(v string) *DescribeDomainsUsageByDayResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBody) SetDomainName(v string) *DescribeDomainsUsageByDayResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBody) SetEndTime(v string) *DescribeDomainsUsageByDayResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBody) SetRequestId(v string) *DescribeDomainsUsageByDayResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBody) SetStartTime(v string) *DescribeDomainsUsageByDayResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBody) SetUsageByDays(v *DescribeDomainsUsageByDayResponseBodyUsageByDays) *DescribeDomainsUsageByDayResponseBody {
	s.UsageByDays = v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBody) SetUsageTotal(v *DescribeDomainsUsageByDayResponseBodyUsageTotal) *DescribeDomainsUsageByDayResponseBody {
	s.UsageTotal = v
	return s
}

type DescribeDomainsUsageByDayResponseBodyUsageByDays struct {
	UsageByDay []*DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay `json:"UsageByDay,omitempty" xml:"UsageByDay,omitempty" type:"Repeated"`
}

func (s DescribeDomainsUsageByDayResponseBodyUsageByDays) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsUsageByDayResponseBodyUsageByDays) GoString() string {
	return s.String()
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDays) SetUsageByDay(v []*DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) *DescribeDomainsUsageByDayResponseBodyUsageByDays {
	s.UsageByDay = v
	return s
}

type DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay struct {
	// The byte hit ratio. The byte hit ratio is measured in percentage.
	BytesHitRate *string `json:"BytesHitRate,omitempty" xml:"BytesHitRate,omitempty"`
	// The peak bandwidth value. Unit: bit/s.
	MaxBps *string `json:"MaxBps,omitempty" xml:"MaxBps,omitempty"`
	// The time when the bandwidth reached the peak value.
	MaxBpsTime *string `json:"MaxBpsTime,omitempty" xml:"MaxBpsTime,omitempty"`
	// The peak bandwidth value during back-to-origin routing. Unit: bit/s.
	MaxSrcBps *string `json:"MaxSrcBps,omitempty" xml:"MaxSrcBps,omitempty"`
	// The time when the bandwidth during back-to-origin routing reached the peak value.
	MaxSrcBpsTime *string `json:"MaxSrcBpsTime,omitempty" xml:"MaxSrcBpsTime,omitempty"`
	// The number of queries per second (QPS).
	Qps *string `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The cache hit ratio that is calculated based on requests. The cache hit ratio is measured in percentage.
	RequestHitRate *string `json:"RequestHitRate,omitempty" xml:"RequestHitRate,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total amount of requests.
	TotalAccess *string `json:"TotalAccess,omitempty" xml:"TotalAccess,omitempty"`
	// The total amount of network traffic. Unit: bytes.
	TotalTraffic *string `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
}

func (s DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) GoString() string {
	return s.String()
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetBytesHitRate(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.BytesHitRate = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetMaxBps(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.MaxBps = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetMaxBpsTime(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.MaxBpsTime = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetMaxSrcBps(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.MaxSrcBps = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetMaxSrcBpsTime(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.MaxSrcBpsTime = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetQps(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.Qps = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetRequestHitRate(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.RequestHitRate = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetTimeStamp(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetTotalAccess(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.TotalAccess = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay) SetTotalTraffic(v string) *DescribeDomainsUsageByDayResponseBodyUsageByDaysUsageByDay {
	s.TotalTraffic = &v
	return s
}

type DescribeDomainsUsageByDayResponseBodyUsageTotal struct {
	// The byte hit ratio. The byte hit ratio is measured in percentage.
	BytesHitRate *string `json:"BytesHitRate,omitempty" xml:"BytesHitRate,omitempty"`
	// The peak bandwidth value. Unit: bit/s.
	MaxBps *string `json:"MaxBps,omitempty" xml:"MaxBps,omitempty"`
	// The time when the bandwidth reached the peak value.
	MaxBpsTime *string `json:"MaxBpsTime,omitempty" xml:"MaxBpsTime,omitempty"`
	// The peak bandwidth value during back-to-origin routing. Unit: bit/s.
	MaxSrcBps *string `json:"MaxSrcBps,omitempty" xml:"MaxSrcBps,omitempty"`
	// The time when the bandwidth during back-to-origin routing reached the peak value.
	MaxSrcBpsTime *string `json:"MaxSrcBpsTime,omitempty" xml:"MaxSrcBpsTime,omitempty"`
	// The cache hit ratio that is calculated based on requests. The cache hit ratio is measured in percentage.
	RequestHitRate *string `json:"RequestHitRate,omitempty" xml:"RequestHitRate,omitempty"`
	// The total amount of requests.
	TotalAccess *string `json:"TotalAccess,omitempty" xml:"TotalAccess,omitempty"`
	// The total amount of network traffic. Unit: bytes.
	TotalTraffic *string `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
}

func (s DescribeDomainsUsageByDayResponseBodyUsageTotal) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsUsageByDayResponseBodyUsageTotal) GoString() string {
	return s.String()
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetBytesHitRate(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.BytesHitRate = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetMaxBps(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.MaxBps = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetMaxBpsTime(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.MaxBpsTime = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetMaxSrcBps(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.MaxSrcBps = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetMaxSrcBpsTime(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.MaxSrcBpsTime = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetRequestHitRate(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.RequestHitRate = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetTotalAccess(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.TotalAccess = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponseBodyUsageTotal) SetTotalTraffic(v string) *DescribeDomainsUsageByDayResponseBodyUsageTotal {
	s.TotalTraffic = &v
	return s
}

type DescribeDomainsUsageByDayResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainsUsageByDayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainsUsageByDayResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsUsageByDayResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainsUsageByDayResponse) SetHeaders(v map[string]*string) *DescribeDomainsUsageByDayResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainsUsageByDayResponse) SetStatusCode(v int32) *DescribeDomainsUsageByDayResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainsUsageByDayResponse) SetBody(v *DescribeDomainsUsageByDayResponseBody) *DescribeDomainsUsageByDayResponse {
	s.Body = v
	return s
}

type DescribeEsExceptionDataRequest struct {
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The script ID. You can call the [DescribeCdnDomainConfigs](~~90924~~) operation to query script IDs.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeEsExceptionDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExceptionDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeEsExceptionDataRequest) SetEndTime(v string) *DescribeEsExceptionDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeEsExceptionDataRequest) SetRuleId(v string) *DescribeEsExceptionDataRequest {
	s.RuleId = &v
	return s
}

func (s *DescribeEsExceptionDataRequest) SetStartTime(v string) *DescribeEsExceptionDataRequest {
	s.StartTime = &v
	return s
}

type DescribeEsExceptionDataResponseBody struct {
	// The content of the script for which an error was reported.
	Contents []*DescribeEsExceptionDataResponseBodyContents `json:"Contents,omitempty" xml:"Contents,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEsExceptionDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExceptionDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEsExceptionDataResponseBody) SetContents(v []*DescribeEsExceptionDataResponseBodyContents) *DescribeEsExceptionDataResponseBody {
	s.Contents = v
	return s
}

func (s *DescribeEsExceptionDataResponseBody) SetRequestId(v string) *DescribeEsExceptionDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEsExceptionDataResponseBodyContents struct {
	// Information about the time column and the error column name.
	Columns []*string `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	// The name of the table that shows the errors of the script.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The time columns and error column names.
	Points []*DescribeEsExceptionDataResponseBodyContentsPoints `json:"Points,omitempty" xml:"Points,omitempty" type:"Repeated"`
}

func (s DescribeEsExceptionDataResponseBodyContents) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExceptionDataResponseBodyContents) GoString() string {
	return s.String()
}

func (s *DescribeEsExceptionDataResponseBodyContents) SetColumns(v []*string) *DescribeEsExceptionDataResponseBodyContents {
	s.Columns = v
	return s
}

func (s *DescribeEsExceptionDataResponseBodyContents) SetName(v string) *DescribeEsExceptionDataResponseBodyContents {
	s.Name = &v
	return s
}

func (s *DescribeEsExceptionDataResponseBodyContents) SetPoints(v []*DescribeEsExceptionDataResponseBodyContentsPoints) *DescribeEsExceptionDataResponseBodyContents {
	s.Points = v
	return s
}

type DescribeEsExceptionDataResponseBodyContentsPoints struct {
	// The data points.
	Points []*string `json:"Points,omitempty" xml:"Points,omitempty" type:"Repeated"`
}

func (s DescribeEsExceptionDataResponseBodyContentsPoints) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExceptionDataResponseBodyContentsPoints) GoString() string {
	return s.String()
}

func (s *DescribeEsExceptionDataResponseBodyContentsPoints) SetPoints(v []*string) *DescribeEsExceptionDataResponseBodyContentsPoints {
	s.Points = v
	return s
}

type DescribeEsExceptionDataResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEsExceptionDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEsExceptionDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExceptionDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeEsExceptionDataResponse) SetHeaders(v map[string]*string) *DescribeEsExceptionDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeEsExceptionDataResponse) SetStatusCode(v int32) *DescribeEsExceptionDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEsExceptionDataResponse) SetBody(v *DescribeEsExceptionDataResponseBody) *DescribeEsExceptionDataResponse {
	s.Body = v
	return s
}

type DescribeEsExecuteDataRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the rule. You can call the [DescribeCdnDomainConfigs](~~90924~~) operation to query script IDs.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeEsExecuteDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExecuteDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeEsExecuteDataRequest) SetEndTime(v string) *DescribeEsExecuteDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeEsExecuteDataRequest) SetRuleId(v string) *DescribeEsExecuteDataRequest {
	s.RuleId = &v
	return s
}

func (s *DescribeEsExecuteDataRequest) SetStartTime(v string) *DescribeEsExecuteDataRequest {
	s.StartTime = &v
	return s
}

type DescribeEsExecuteDataResponseBody struct {
	// The content of the script.
	Contents []*DescribeEsExecuteDataResponseBodyContents `json:"Contents,omitempty" xml:"Contents,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEsExecuteDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExecuteDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEsExecuteDataResponseBody) SetContents(v []*DescribeEsExecuteDataResponseBodyContents) *DescribeEsExecuteDataResponseBody {
	s.Contents = v
	return s
}

func (s *DescribeEsExecuteDataResponseBody) SetRequestId(v string) *DescribeEsExecuteDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEsExecuteDataResponseBodyContents struct {
	// The time and column names in the table that shows the status of the script.
	Columns []*string `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	// The name of the table that shows the status of the script.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The list of timestamps and values in the corresponding columns of the table that shows the status of the script.
	Points []*string `json:"Points,omitempty" xml:"Points,omitempty" type:"Repeated"`
}

func (s DescribeEsExecuteDataResponseBodyContents) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExecuteDataResponseBodyContents) GoString() string {
	return s.String()
}

func (s *DescribeEsExecuteDataResponseBodyContents) SetColumns(v []*string) *DescribeEsExecuteDataResponseBodyContents {
	s.Columns = v
	return s
}

func (s *DescribeEsExecuteDataResponseBodyContents) SetName(v string) *DescribeEsExecuteDataResponseBodyContents {
	s.Name = &v
	return s
}

func (s *DescribeEsExecuteDataResponseBodyContents) SetPoints(v []*string) *DescribeEsExecuteDataResponseBodyContents {
	s.Points = v
	return s
}

type DescribeEsExecuteDataResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEsExecuteDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEsExecuteDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEsExecuteDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeEsExecuteDataResponse) SetHeaders(v map[string]*string) *DescribeEsExecuteDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeEsExecuteDataResponse) SetStatusCode(v int32) *DescribeEsExecuteDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEsExecuteDataResponse) SetBody(v *DescribeEsExecuteDataResponseBody) *DescribeEsExecuteDataResponse {
	s.Body = v
	return s
}

type DescribeFCTriggerRequest struct {
	// The trigger that corresponds to the Function Compute service.
	TriggerARN *string `json:"TriggerARN,omitempty" xml:"TriggerARN,omitempty"`
}

func (s DescribeFCTriggerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeFCTriggerRequest) GoString() string {
	return s.String()
}

func (s *DescribeFCTriggerRequest) SetTriggerARN(v string) *DescribeFCTriggerRequest {
	s.TriggerARN = &v
	return s
}

type DescribeFCTriggerResponseBody struct {
	// The Function Compute trigger that you want to query.
	FCTrigger *DescribeFCTriggerResponseBodyFCTrigger `json:"FCTrigger,omitempty" xml:"FCTrigger,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeFCTriggerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeFCTriggerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFCTriggerResponseBody) SetFCTrigger(v *DescribeFCTriggerResponseBodyFCTrigger) *DescribeFCTriggerResponseBody {
	s.FCTrigger = v
	return s
}

func (s *DescribeFCTriggerResponseBody) SetRequestId(v string) *DescribeFCTriggerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeFCTriggerResponseBodyFCTrigger struct {
	// The name of the event.
	EventMetaName *string `json:"EventMetaName,omitempty" xml:"EventMetaName,omitempty"`
	// The version of the event.
	EventMetaVersion *string `json:"EventMetaVersion,omitempty" xml:"EventMetaVersion,omitempty"`
	// The remarks of the Function Compute trigger.
	Notes *string `json:"Notes,omitempty" xml:"Notes,omitempty"`
	// The assigned Resource Access Management (RAM) role.
	RoleARN *string `json:"RoleARN,omitempty" xml:"RoleARN,omitempty"`
	// The resources and filters for event listening.
	SourceArn *string `json:"SourceArn,omitempty" xml:"SourceArn,omitempty"`
	// The trigger that corresponds to the Function Compute service.
	TriggerARN *string `json:"TriggerARN,omitempty" xml:"TriggerARN,omitempty"`
}

func (s DescribeFCTriggerResponseBodyFCTrigger) String() string {
	return tea.Prettify(s)
}

func (s DescribeFCTriggerResponseBodyFCTrigger) GoString() string {
	return s.String()
}

func (s *DescribeFCTriggerResponseBodyFCTrigger) SetEventMetaName(v string) *DescribeFCTriggerResponseBodyFCTrigger {
	s.EventMetaName = &v
	return s
}

func (s *DescribeFCTriggerResponseBodyFCTrigger) SetEventMetaVersion(v string) *DescribeFCTriggerResponseBodyFCTrigger {
	s.EventMetaVersion = &v
	return s
}

func (s *DescribeFCTriggerResponseBodyFCTrigger) SetNotes(v string) *DescribeFCTriggerResponseBodyFCTrigger {
	s.Notes = &v
	return s
}

func (s *DescribeFCTriggerResponseBodyFCTrigger) SetRoleARN(v string) *DescribeFCTriggerResponseBodyFCTrigger {
	s.RoleARN = &v
	return s
}

func (s *DescribeFCTriggerResponseBodyFCTrigger) SetSourceArn(v string) *DescribeFCTriggerResponseBodyFCTrigger {
	s.SourceArn = &v
	return s
}

func (s *DescribeFCTriggerResponseBodyFCTrigger) SetTriggerARN(v string) *DescribeFCTriggerResponseBodyFCTrigger {
	s.TriggerARN = &v
	return s
}

type DescribeFCTriggerResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeFCTriggerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeFCTriggerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeFCTriggerResponse) GoString() string {
	return s.String()
}

func (s *DescribeFCTriggerResponse) SetHeaders(v map[string]*string) *DescribeFCTriggerResponse {
	s.Headers = v
	return s
}

func (s *DescribeFCTriggerResponse) SetStatusCode(v int32) *DescribeFCTriggerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFCTriggerResponse) SetBody(v *DescribeFCTriggerResponseBody) *DescribeFCTriggerResponse {
	s.Body = v
	return s
}

type DescribeIpInfoRequest struct {
	// The IP address that you want to query. You can specify only one IP address in each request.
	IP *string `json:"IP,omitempty" xml:"IP,omitempty"`
}

func (s DescribeIpInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeIpInfoRequest) SetIP(v string) *DescribeIpInfoRequest {
	s.IP = &v
	return s
}

type DescribeIpInfoResponseBody struct {
	// Indicates whether the IP address belongs to an Alibaba Cloud CDN POP.
	//
	// *   **True**
	// *   **False**
	CdnIp *string `json:"CdnIp,omitempty" xml:"CdnIp,omitempty"`
	// The Chinese name of the ISP.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The English name of the Internet service provider (ISP).
	IspEname *string `json:"IspEname,omitempty" xml:"IspEname,omitempty"`
	// The Chinese name of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The English name of the region.
	RegionEname *string `json:"RegionEname,omitempty" xml:"RegionEname,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeIpInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIpInfoResponseBody) SetCdnIp(v string) *DescribeIpInfoResponseBody {
	s.CdnIp = &v
	return s
}

func (s *DescribeIpInfoResponseBody) SetISP(v string) *DescribeIpInfoResponseBody {
	s.ISP = &v
	return s
}

func (s *DescribeIpInfoResponseBody) SetIspEname(v string) *DescribeIpInfoResponseBody {
	s.IspEname = &v
	return s
}

func (s *DescribeIpInfoResponseBody) SetRegion(v string) *DescribeIpInfoResponseBody {
	s.Region = &v
	return s
}

func (s *DescribeIpInfoResponseBody) SetRegionEname(v string) *DescribeIpInfoResponseBody {
	s.RegionEname = &v
	return s
}

func (s *DescribeIpInfoResponseBody) SetRequestId(v string) *DescribeIpInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeIpInfoResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIpInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIpInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeIpInfoResponse) SetHeaders(v map[string]*string) *DescribeIpInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeIpInfoResponse) SetStatusCode(v int32) *DescribeIpInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIpInfoResponse) SetBody(v *DescribeIpInfoResponseBody) *DescribeIpInfoResponse {
	s.Body = v
	return s
}

type DescribeIpStatusRequest struct {
	// The IP addresses that you want to query. Separate IP addresses with underscores (\_), such as Ips=ip1\_ip2.
	Ips *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
}

func (s DescribeIpStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeIpStatusRequest) SetIps(v string) *DescribeIpStatusRequest {
	s.Ips = &v
	return s
}

type DescribeIpStatusResponseBody struct {
	// The status of the IP addresses of the POPs.
	IpStatus []*DescribeIpStatusResponseBodyIpStatus `json:"IpStatus,omitempty" xml:"IpStatus,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeIpStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIpStatusResponseBody) SetIpStatus(v []*DescribeIpStatusResponseBodyIpStatus) *DescribeIpStatusResponseBody {
	s.IpStatus = v
	return s
}

func (s *DescribeIpStatusResponseBody) SetRequestId(v string) *DescribeIpStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeIpStatusResponseBodyIpStatus struct {
	// The IP address of the POP.
	Ip *string `json:"ip,omitempty" xml:"ip,omitempty"`
	// The status.
	//
	// *   **nonali**: not an Alibaba Cloud CDN POP
	// *   **normal**: an available Alibaba Cloud CDN POP
	// *   **abnormal**: an unavailable Alibaba Cloud CDN POP
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s DescribeIpStatusResponseBodyIpStatus) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpStatusResponseBodyIpStatus) GoString() string {
	return s.String()
}

func (s *DescribeIpStatusResponseBodyIpStatus) SetIp(v string) *DescribeIpStatusResponseBodyIpStatus {
	s.Ip = &v
	return s
}

func (s *DescribeIpStatusResponseBodyIpStatus) SetStatus(v string) *DescribeIpStatusResponseBodyIpStatus {
	s.Status = &v
	return s
}

type DescribeIpStatusResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIpStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIpStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeIpStatusResponse) SetHeaders(v map[string]*string) *DescribeIpStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeIpStatusResponse) SetStatusCode(v int32) *DescribeIpStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIpStatusResponse) SetBody(v *DescribeIpStatusResponseBody) *DescribeIpStatusResponse {
	s.Body = v
	return s
}

type DescribeL2VipsByDomainRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeL2VipsByDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeL2VipsByDomainRequest) GoString() string {
	return s.String()
}

func (s *DescribeL2VipsByDomainRequest) SetDomainName(v string) *DescribeL2VipsByDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeL2VipsByDomainRequest) SetOwnerId(v int64) *DescribeL2VipsByDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeL2VipsByDomainRequest) SetSecurityToken(v string) *DescribeL2VipsByDomainRequest {
	s.SecurityToken = &v
	return s
}

type DescribeL2VipsByDomainResponseBody struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of VIPs.
	Vips *DescribeL2VipsByDomainResponseBodyVips `json:"Vips,omitempty" xml:"Vips,omitempty" type:"Struct"`
}

func (s DescribeL2VipsByDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeL2VipsByDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeL2VipsByDomainResponseBody) SetDomainName(v string) *DescribeL2VipsByDomainResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeL2VipsByDomainResponseBody) SetRequestId(v string) *DescribeL2VipsByDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeL2VipsByDomainResponseBody) SetVips(v *DescribeL2VipsByDomainResponseBodyVips) *DescribeL2VipsByDomainResponseBody {
	s.Vips = v
	return s
}

type DescribeL2VipsByDomainResponseBodyVips struct {
	Vip []*string `json:"Vip,omitempty" xml:"Vip,omitempty" type:"Repeated"`
}

func (s DescribeL2VipsByDomainResponseBodyVips) String() string {
	return tea.Prettify(s)
}

func (s DescribeL2VipsByDomainResponseBodyVips) GoString() string {
	return s.String()
}

func (s *DescribeL2VipsByDomainResponseBodyVips) SetVip(v []*string) *DescribeL2VipsByDomainResponseBodyVips {
	s.Vip = v
	return s
}

type DescribeL2VipsByDomainResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeL2VipsByDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeL2VipsByDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeL2VipsByDomainResponse) GoString() string {
	return s.String()
}

func (s *DescribeL2VipsByDomainResponse) SetHeaders(v map[string]*string) *DescribeL2VipsByDomainResponse {
	s.Headers = v
	return s
}

func (s *DescribeL2VipsByDomainResponse) SetStatusCode(v int32) *DescribeL2VipsByDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeL2VipsByDomainResponse) SetBody(v *DescribeL2VipsByDomainResponseBody) *DescribeL2VipsByDomainResponse {
	s.Body = v
	return s
}

type DescribePreloadDetailByIdRequest struct {
	// Queries the details of a preload task by task ID. You can query one task ID at a time.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribePreloadDetailByIdRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePreloadDetailByIdRequest) GoString() string {
	return s.String()
}

func (s *DescribePreloadDetailByIdRequest) SetTaskId(v string) *DescribePreloadDetailByIdRequest {
	s.TaskId = &v
	return s
}

type DescribePreloadDetailByIdResponseBody struct {
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of queried tasks.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details of the task, including the task ID, start time, end time, domain name, success rate, status, returned error code, and completion details of all URL resources.
	UrlDetails []*DescribePreloadDetailByIdResponseBodyUrlDetails `json:"UrlDetails,omitempty" xml:"UrlDetails,omitempty" type:"Repeated"`
}

func (s DescribePreloadDetailByIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePreloadDetailByIdResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePreloadDetailByIdResponseBody) SetRequestId(v string) *DescribePreloadDetailByIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBody) SetTotalCount(v int64) *DescribePreloadDetailByIdResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBody) SetUrlDetails(v []*DescribePreloadDetailByIdResponseBodyUrlDetails) *DescribePreloadDetailByIdResponseBody {
	s.UrlDetails = v
	return s
}

type DescribePreloadDetailByIdResponseBodyUrlDetails struct {
	// The time when the task was created. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The domain name for prefetching resources.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The time when the task ended. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The progress of the prefetch task, which indicates the number of points of presence (POPs) on which the prefetch task is completed.
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The turned error code. A value of `0` indicates that the task succeeded.
	RetCode *string `json:"RetCode,omitempty" xml:"RetCode,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **Complete**
	// *   **Refreshing**
	// *   **Failed**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task that you want to query.
	//
	// You can call the PushObjectCache operation to query task IDs. Then, you can use the task IDs to query task status.
	//
	// You can query one task ID at a time.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The completion details of all URL resources in the task.
	Urls []*DescribePreloadDetailByIdResponseBodyUrlDetailsUrls `json:"Urls,omitempty" xml:"Urls,omitempty" type:"Repeated"`
}

func (s DescribePreloadDetailByIdResponseBodyUrlDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribePreloadDetailByIdResponseBodyUrlDetails) GoString() string {
	return s.String()
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetCreationTime(v string) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.CreationTime = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetDomain(v string) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.Domain = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetEndTime(v string) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.EndTime = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetProcess(v string) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.Process = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetRetCode(v string) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.RetCode = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetStatus(v string) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.Status = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetTaskId(v string) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.TaskId = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetails) SetUrls(v []*DescribePreloadDetailByIdResponseBodyUrlDetailsUrls) *DescribePreloadDetailByIdResponseBodyUrlDetails {
	s.Urls = v
	return s
}

type DescribePreloadDetailByIdResponseBodyUrlDetailsUrls struct {
	// The details of resource prefetch.
	//
	// *   If the resource is prefetched on all POPs, "Successfully preloaded" is returned.
	// *   If the resource fails to be prefetched on some POPs, the failure details separated by vertical bars (|) are returned.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The success percentage, which indicates the number of POPs on which the resource is prefetched.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
	// The URL of the prefetched resource.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s DescribePreloadDetailByIdResponseBodyUrlDetailsUrls) String() string {
	return tea.Prettify(s)
}

func (s DescribePreloadDetailByIdResponseBodyUrlDetailsUrls) GoString() string {
	return s.String()
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetailsUrls) SetDescription(v string) *DescribePreloadDetailByIdResponseBodyUrlDetailsUrls {
	s.Description = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetailsUrls) SetSuccess(v string) *DescribePreloadDetailByIdResponseBodyUrlDetailsUrls {
	s.Success = &v
	return s
}

func (s *DescribePreloadDetailByIdResponseBodyUrlDetailsUrls) SetUrl(v string) *DescribePreloadDetailByIdResponseBodyUrlDetailsUrls {
	s.Url = &v
	return s
}

type DescribePreloadDetailByIdResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePreloadDetailByIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePreloadDetailByIdResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePreloadDetailByIdResponse) GoString() string {
	return s.String()
}

func (s *DescribePreloadDetailByIdResponse) SetHeaders(v map[string]*string) *DescribePreloadDetailByIdResponse {
	s.Headers = v
	return s
}

func (s *DescribePreloadDetailByIdResponse) SetStatusCode(v int32) *DescribePreloadDetailByIdResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePreloadDetailByIdResponse) SetBody(v *DescribePreloadDetailByIdResponseBody) *DescribePreloadDetailByIdResponse {
	s.Body = v
	return s
}

type DescribeRangeDataByLocateAndIspServiceRequest struct {
	// The accelerated domain name.
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time. The maximum time range that can be specified is 1 hour.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the ISP. You can specify only one ISP name in each call.
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query ISPs.
	IspNames *string `json:"IspNames,omitempty" xml:"IspNames,omitempty"`
	// The names of the regions. Separate multiple region names with commas (,).
	//
	// You can call the [DescribeCdnRegionAndIsp](~~91077~~) operation to query the most recent region list.
	LocationNames *string `json:"LocationNames,omitempty" xml:"LocationNames,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeRangeDataByLocateAndIspServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRangeDataByLocateAndIspServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeRangeDataByLocateAndIspServiceRequest) SetDomainNames(v string) *DescribeRangeDataByLocateAndIspServiceRequest {
	s.DomainNames = &v
	return s
}

func (s *DescribeRangeDataByLocateAndIspServiceRequest) SetEndTime(v string) *DescribeRangeDataByLocateAndIspServiceRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeRangeDataByLocateAndIspServiceRequest) SetIspNames(v string) *DescribeRangeDataByLocateAndIspServiceRequest {
	s.IspNames = &v
	return s
}

func (s *DescribeRangeDataByLocateAndIspServiceRequest) SetLocationNames(v string) *DescribeRangeDataByLocateAndIspServiceRequest {
	s.LocationNames = &v
	return s
}

func (s *DescribeRangeDataByLocateAndIspServiceRequest) SetStartTime(v string) *DescribeRangeDataByLocateAndIspServiceRequest {
	s.StartTime = &v
	return s
}

type DescribeRangeDataByLocateAndIspServiceResponseBody struct {
	// The response parameters in the JSON format. These parameters indicate the following information in sequence: UNIX time, region, ISP, distribution of HTTP status codes, response time, bandwidth (bit/s), average response rate, page views, cache hit ratio, and request hit ratio.
	JsonResult *string `json:"JsonResult,omitempty" xml:"JsonResult,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRangeDataByLocateAndIspServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRangeDataByLocateAndIspServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRangeDataByLocateAndIspServiceResponseBody) SetJsonResult(v string) *DescribeRangeDataByLocateAndIspServiceResponseBody {
	s.JsonResult = &v
	return s
}

func (s *DescribeRangeDataByLocateAndIspServiceResponseBody) SetRequestId(v string) *DescribeRangeDataByLocateAndIspServiceResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRangeDataByLocateAndIspServiceResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRangeDataByLocateAndIspServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRangeDataByLocateAndIspServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRangeDataByLocateAndIspServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeRangeDataByLocateAndIspServiceResponse) SetHeaders(v map[string]*string) *DescribeRangeDataByLocateAndIspServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeRangeDataByLocateAndIspServiceResponse) SetStatusCode(v int32) *DescribeRangeDataByLocateAndIspServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRangeDataByLocateAndIspServiceResponse) SetBody(v *DescribeRangeDataByLocateAndIspServiceResponseBody) *DescribeRangeDataByLocateAndIspServiceResponse {
	s.Body = v
	return s
}

type DescribeRealtimeDeliveryAccRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds. The value varies based on the values of the **StartTime** and **EndTime** parameters. Valid values:
	//
	// *   If the time span between StartTime and EndTime is less than 3 days, valid values are **300**, **3600**, and **86400**. Default value: **300**.
	// *   If the time span between StartTime and EndTime is greater than or equal to 3 days and less than 31 days, valid values are **3600** and **86400**. Default value: **3600**.
	// *   If the time span between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Logstore that stores log data. If you do leave this parameter empty, real-time log deliveries of all Logstores are queried.
	LogStore *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery. If you do leave this parameter empty, real-time log deliveries of all projects are queried.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeRealtimeDeliveryAccRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRealtimeDeliveryAccRequest) GoString() string {
	return s.String()
}

func (s *DescribeRealtimeDeliveryAccRequest) SetEndTime(v string) *DescribeRealtimeDeliveryAccRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeRealtimeDeliveryAccRequest) SetInterval(v string) *DescribeRealtimeDeliveryAccRequest {
	s.Interval = &v
	return s
}

func (s *DescribeRealtimeDeliveryAccRequest) SetLogStore(v string) *DescribeRealtimeDeliveryAccRequest {
	s.LogStore = &v
	return s
}

func (s *DescribeRealtimeDeliveryAccRequest) SetProject(v string) *DescribeRealtimeDeliveryAccRequest {
	s.Project = &v
	return s
}

func (s *DescribeRealtimeDeliveryAccRequest) SetStartTime(v string) *DescribeRealtimeDeliveryAccRequest {
	s.StartTime = &v
	return s
}

type DescribeRealtimeDeliveryAccResponseBody struct {
	// The statistics about real-time log deliveries.
	ReatTimeDeliveryAccData *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData `json:"ReatTimeDeliveryAccData,omitempty" xml:"ReatTimeDeliveryAccData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRealtimeDeliveryAccResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRealtimeDeliveryAccResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRealtimeDeliveryAccResponseBody) SetReatTimeDeliveryAccData(v *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData) *DescribeRealtimeDeliveryAccResponseBody {
	s.ReatTimeDeliveryAccData = v
	return s
}

func (s *DescribeRealtimeDeliveryAccResponseBody) SetRequestId(v string) *DescribeRealtimeDeliveryAccResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData struct {
	AccData []*DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData `json:"AccData,omitempty" xml:"AccData,omitempty" type:"Repeated"`
}

func (s DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData) String() string {
	return tea.Prettify(s)
}

func (s DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData) GoString() string {
	return s.String()
}

func (s *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData) SetAccData(v []*DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData) *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccData {
	s.AccData = v
	return s
}

type DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData struct {
	// The number of failed attempts to deliver log data to Log Service.
	FailedNum *int32 `json:"FailedNum,omitempty" xml:"FailedNum,omitempty"`
	// The number of successful deliveries of log data to Log Service.
	SuccessNum *int32 `json:"SuccessNum,omitempty" xml:"SuccessNum,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData) String() string {
	return tea.Prettify(s)
}

func (s DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData) GoString() string {
	return s.String()
}

func (s *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData) SetFailedNum(v int32) *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData {
	s.FailedNum = &v
	return s
}

func (s *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData) SetSuccessNum(v int32) *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData {
	s.SuccessNum = &v
	return s
}

func (s *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData) SetTimeStamp(v string) *DescribeRealtimeDeliveryAccResponseBodyReatTimeDeliveryAccDataAccData {
	s.TimeStamp = &v
	return s
}

type DescribeRealtimeDeliveryAccResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRealtimeDeliveryAccResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRealtimeDeliveryAccResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRealtimeDeliveryAccResponse) GoString() string {
	return s.String()
}

func (s *DescribeRealtimeDeliveryAccResponse) SetHeaders(v map[string]*string) *DescribeRealtimeDeliveryAccResponse {
	s.Headers = v
	return s
}

func (s *DescribeRealtimeDeliveryAccResponse) SetStatusCode(v int32) *DescribeRealtimeDeliveryAccResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRealtimeDeliveryAccResponse) SetBody(v *DescribeRealtimeDeliveryAccResponseBody) *DescribeRealtimeDeliveryAccResponse {
	s.Body = v
	return s
}

type DescribeRefreshQuotaRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeRefreshQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshQuotaRequest) GoString() string {
	return s.String()
}

func (s *DescribeRefreshQuotaRequest) SetOwnerId(v int64) *DescribeRefreshQuotaRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRefreshQuotaRequest) SetSecurityToken(v string) *DescribeRefreshQuotaRequest {
	s.SecurityToken = &v
	return s
}

type DescribeRefreshQuotaResponseBody struct {
	// The maximum number of URLs that can be refreshed on the current day.
	BlockQuota *string `json:"BlockQuota,omitempty" xml:"BlockQuota,omitempty"`
	// The remaining number of times that you can prefetch content to L2 points of presence (POPs) on the current day.
	BlockRemain *string `json:"BlockRemain,omitempty" xml:"BlockRemain,omitempty"`
	// The ID of the request.
	DirQuota *string `json:"DirQuota,omitempty" xml:"DirQuota,omitempty"`
	// The remaining number of URLs that can be refreshed on the current day.
	DirRemain *string `json:"DirRemain,omitempty" xml:"DirRemain,omitempty"`
	// The maximum number of URLs or directories with parameters ignored that can be refreshed on the current day.
	IgnoreParamsQuota *string `json:"IgnoreParamsQuota,omitempty" xml:"IgnoreParamsQuota,omitempty"`
	// The number of remaining URLs or directories that can be refreshed with parameters ignored on the current day.
	IgnoreParamsRemain *string `json:"IgnoreParamsRemain,omitempty" xml:"IgnoreParamsRemain,omitempty"`
	// The maximum number of directories that can be refreshed on the current day.
	PreloadEdgeQuota *string `json:"PreloadEdgeQuota,omitempty" xml:"PreloadEdgeQuota,omitempty"`
	// The maximum number of times that you can prefetch content to L1 POPs on the current day.
	PreloadEdgeRemain *string `json:"PreloadEdgeRemain,omitempty" xml:"PreloadEdgeRemain,omitempty"`
	// The remaining number of times that you can prefetch content to L1 POPs on the current day.
	PreloadQuota *string `json:"PreloadQuota,omitempty" xml:"PreloadQuota,omitempty"`
	// The maximum number of times that you can prefetch content to L1 nodes on the current day.
	PreloadRemain *string `json:"PreloadRemain,omitempty" xml:"PreloadRemain,omitempty"`
	// The maximum number of times that you can prefetch content to L2 POPs on the current day.
	RegexQuota *string `json:"RegexQuota,omitempty" xml:"RegexQuota,omitempty"`
	// The remaining number of URLs that can be blocked on the current day.
	RegexRemain *string `json:"RegexRemain,omitempty" xml:"RegexRemain,omitempty"`
	// The maximum number of URLs and directories that can be blocked on the current day.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The remaining number of directories that can be refreshed on the current day.
	UrlQuota *string `json:"UrlQuota,omitempty" xml:"UrlQuota,omitempty"`
	// The remaining number of URLs or directories that can be refreshed by using regular expressions on the current day.
	UrlRemain *string `json:"UrlRemain,omitempty" xml:"UrlRemain,omitempty"`
}

func (s DescribeRefreshQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRefreshQuotaResponseBody) SetBlockQuota(v string) *DescribeRefreshQuotaResponseBody {
	s.BlockQuota = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetBlockRemain(v string) *DescribeRefreshQuotaResponseBody {
	s.BlockRemain = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetDirQuota(v string) *DescribeRefreshQuotaResponseBody {
	s.DirQuota = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetDirRemain(v string) *DescribeRefreshQuotaResponseBody {
	s.DirRemain = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetIgnoreParamsQuota(v string) *DescribeRefreshQuotaResponseBody {
	s.IgnoreParamsQuota = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetIgnoreParamsRemain(v string) *DescribeRefreshQuotaResponseBody {
	s.IgnoreParamsRemain = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetPreloadEdgeQuota(v string) *DescribeRefreshQuotaResponseBody {
	s.PreloadEdgeQuota = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetPreloadEdgeRemain(v string) *DescribeRefreshQuotaResponseBody {
	s.PreloadEdgeRemain = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetPreloadQuota(v string) *DescribeRefreshQuotaResponseBody {
	s.PreloadQuota = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetPreloadRemain(v string) *DescribeRefreshQuotaResponseBody {
	s.PreloadRemain = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetRegexQuota(v string) *DescribeRefreshQuotaResponseBody {
	s.RegexQuota = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetRegexRemain(v string) *DescribeRefreshQuotaResponseBody {
	s.RegexRemain = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetRequestId(v string) *DescribeRefreshQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetUrlQuota(v string) *DescribeRefreshQuotaResponseBody {
	s.UrlQuota = &v
	return s
}

func (s *DescribeRefreshQuotaResponseBody) SetUrlRemain(v string) *DescribeRefreshQuotaResponseBody {
	s.UrlRemain = &v
	return s
}

type DescribeRefreshQuotaResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRefreshQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRefreshQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshQuotaResponse) GoString() string {
	return s.String()
}

func (s *DescribeRefreshQuotaResponse) SetHeaders(v map[string]*string) *DescribeRefreshQuotaResponse {
	s.Headers = v
	return s
}

func (s *DescribeRefreshQuotaResponse) SetStatusCode(v int32) *DescribeRefreshQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRefreshQuotaResponse) SetBody(v *DescribeRefreshQuotaResponseBody) *DescribeRefreshQuotaResponse {
	s.Body = v
	return s
}

type DescribeRefreshTaskByIdRequest struct {
	// The ID of the task that you want to query.
	//
	// You can call the [RefreshObjectCaches](~~91164~~) operation to query task IDs. Then, you can use the task IDs to query task status.
	//
	// You can specify up to 10 task IDs. Separate task IDs with commas (,).
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeRefreshTaskByIdRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTaskByIdRequest) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTaskByIdRequest) SetTaskId(v string) *DescribeRefreshTaskByIdRequest {
	s.TaskId = &v
	return s
}

type DescribeRefreshTaskByIdResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details about tasks.
	Tasks []*DescribeRefreshTaskByIdResponseBodyTasks `json:"Tasks,omitempty" xml:"Tasks,omitempty" type:"Repeated"`
	// The total number of tasks.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRefreshTaskByIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTaskByIdResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTaskByIdResponseBody) SetRequestId(v string) *DescribeRefreshTaskByIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBody) SetTasks(v []*DescribeRefreshTaskByIdResponseBodyTasks) *DescribeRefreshTaskByIdResponseBody {
	s.Tasks = v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBody) SetTotalCount(v int64) *DescribeRefreshTaskByIdResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRefreshTaskByIdResponseBodyTasks struct {
	// The time when the task was created. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The error returned when the refresh or prefetch task failed. Valid values:
	//
	// *   **Internal Error**
	// *   **Origin Timeout**
	// *   **Origin Return StatusCode 5XX**
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The path of the object refreshed by the refresh task.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **file**: refreshes an individual file.
	// *   **directory**: refreshes files in the specified directory.
	// *   **preload**: prefetches an individual file.
	// *   **regex**: refreshes content based on a regular expression.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The progress of the task, in percentage.
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **Complete**
	// *   **Pending**
	// *   **Refreshing**
	// *   **Failed**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeRefreshTaskByIdResponseBodyTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTaskByIdResponseBodyTasks) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTaskByIdResponseBodyTasks) SetCreationTime(v string) *DescribeRefreshTaskByIdResponseBodyTasks {
	s.CreationTime = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBodyTasks) SetDescription(v string) *DescribeRefreshTaskByIdResponseBodyTasks {
	s.Description = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBodyTasks) SetObjectPath(v string) *DescribeRefreshTaskByIdResponseBodyTasks {
	s.ObjectPath = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBodyTasks) SetObjectType(v string) *DescribeRefreshTaskByIdResponseBodyTasks {
	s.ObjectType = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBodyTasks) SetProcess(v string) *DescribeRefreshTaskByIdResponseBodyTasks {
	s.Process = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBodyTasks) SetStatus(v string) *DescribeRefreshTaskByIdResponseBodyTasks {
	s.Status = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponseBodyTasks) SetTaskId(v string) *DescribeRefreshTaskByIdResponseBodyTasks {
	s.TaskId = &v
	return s
}

type DescribeRefreshTaskByIdResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRefreshTaskByIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRefreshTaskByIdResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTaskByIdResponse) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTaskByIdResponse) SetHeaders(v map[string]*string) *DescribeRefreshTaskByIdResponse {
	s.Headers = v
	return s
}

func (s *DescribeRefreshTaskByIdResponse) SetStatusCode(v int32) *DescribeRefreshTaskByIdResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRefreshTaskByIdResponse) SetBody(v *DescribeRefreshTaskByIdResponseBody) *DescribeRefreshTaskByIdResponse {
	s.Body = v
	return s
}

type DescribeRefreshTasksRequest struct {
	// The accelerated domain name. You can specify only one accelerated domain name in each call. By default, this operation queries the status of tasks for all accelerated domain names.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The path of the object. The path is used as a condition for exact matching.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **file**: refreshes one or more files.
	// *   **directory**: refreshes files in specific directories.
	// *   **regex**: refreshes content based on a regular expression.
	// *   **preload**: prefetches one or more files.
	//
	// > If you set the **DomainName** or **Status** parameter, you must also set the **ObjectType** parameter.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: **1** to **100000**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **100**. Valid values: **1** to **100**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **Complete**: The task is complete.
	// *   **Refreshing**: The task is in progress.
	// *   **Failed**: The task failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task that you want to query.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeRefreshTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTasksRequest) SetDomainName(v string) *DescribeRefreshTasksRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetEndTime(v string) *DescribeRefreshTasksRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetObjectPath(v string) *DescribeRefreshTasksRequest {
	s.ObjectPath = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetObjectType(v string) *DescribeRefreshTasksRequest {
	s.ObjectType = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetOwnerId(v int64) *DescribeRefreshTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetPageNumber(v int32) *DescribeRefreshTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetPageSize(v int32) *DescribeRefreshTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetResourceGroupId(v string) *DescribeRefreshTasksRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetSecurityToken(v string) *DescribeRefreshTasksRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetStartTime(v string) *DescribeRefreshTasksRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetStatus(v string) *DescribeRefreshTasksRequest {
	s.Status = &v
	return s
}

func (s *DescribeRefreshTasksRequest) SetTaskId(v string) *DescribeRefreshTasksRequest {
	s.TaskId = &v
	return s
}

type DescribeRefreshTasksResponseBody struct {
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details about tasks.
	Tasks *DescribeRefreshTasksResponseBodyTasks `json:"Tasks,omitempty" xml:"Tasks,omitempty" type:"Struct"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRefreshTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTasksResponseBody) SetPageNumber(v int64) *DescribeRefreshTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRefreshTasksResponseBody) SetPageSize(v int64) *DescribeRefreshTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRefreshTasksResponseBody) SetRequestId(v string) *DescribeRefreshTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRefreshTasksResponseBody) SetTasks(v *DescribeRefreshTasksResponseBodyTasks) *DescribeRefreshTasksResponseBody {
	s.Tasks = v
	return s
}

func (s *DescribeRefreshTasksResponseBody) SetTotalCount(v int64) *DescribeRefreshTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRefreshTasksResponseBodyTasks struct {
	CDNTask []*DescribeRefreshTasksResponseBodyTasksCDNTask `json:"CDNTask,omitempty" xml:"CDNTask,omitempty" type:"Repeated"`
}

func (s DescribeRefreshTasksResponseBodyTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTasksResponseBodyTasks) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTasksResponseBodyTasks) SetCDNTask(v []*DescribeRefreshTasksResponseBodyTasksCDNTask) *DescribeRefreshTasksResponseBodyTasks {
	s.CDNTask = v
	return s
}

type DescribeRefreshTasksResponseBodyTasksCDNTask struct {
	// The time when the task was created. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of the error returned when the refresh or prefetch task failed. Valid values:
	//
	// *   **InternalError**: An internal error occurred.
	// *   **OriginTimeout**: The response from the origin server timed out.
	// *   **OriginReturnStatusCode 5XX**: The origin server returned a 5XX error.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the object refreshed.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task.
	//
	// *   **file**: refreshes one or more files.
	// *   **directory**: refreshes files in the specified directories.
	// *   **regex**: refreshes content based on a regular expression.
	// *   **preload**: prefetches one or more files.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The progress of the task, in percentage.
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **Complete**: The task has completed.
	// *   **Refreshing**: The task is in progress.
	// *   **Failed**: The task failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeRefreshTasksResponseBodyTasksCDNTask) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTasksResponseBodyTasksCDNTask) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTasksResponseBodyTasksCDNTask) SetCreationTime(v string) *DescribeRefreshTasksResponseBodyTasksCDNTask {
	s.CreationTime = &v
	return s
}

func (s *DescribeRefreshTasksResponseBodyTasksCDNTask) SetDescription(v string) *DescribeRefreshTasksResponseBodyTasksCDNTask {
	s.Description = &v
	return s
}

func (s *DescribeRefreshTasksResponseBodyTasksCDNTask) SetObjectPath(v string) *DescribeRefreshTasksResponseBodyTasksCDNTask {
	s.ObjectPath = &v
	return s
}

func (s *DescribeRefreshTasksResponseBodyTasksCDNTask) SetObjectType(v string) *DescribeRefreshTasksResponseBodyTasksCDNTask {
	s.ObjectType = &v
	return s
}

func (s *DescribeRefreshTasksResponseBodyTasksCDNTask) SetProcess(v string) *DescribeRefreshTasksResponseBodyTasksCDNTask {
	s.Process = &v
	return s
}

func (s *DescribeRefreshTasksResponseBodyTasksCDNTask) SetStatus(v string) *DescribeRefreshTasksResponseBodyTasksCDNTask {
	s.Status = &v
	return s
}

func (s *DescribeRefreshTasksResponseBodyTasksCDNTask) SetTaskId(v string) *DescribeRefreshTasksResponseBodyTasksCDNTask {
	s.TaskId = &v
	return s
}

type DescribeRefreshTasksResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRefreshTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRefreshTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRefreshTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeRefreshTasksResponse) SetHeaders(v map[string]*string) *DescribeRefreshTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeRefreshTasksResponse) SetStatusCode(v int32) *DescribeRefreshTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRefreshTasksResponse) SetBody(v *DescribeRefreshTasksResponseBody) *DescribeRefreshTasksResponse {
	s.Body = v
	return s
}

type DescribeStagingIpResponseBody struct {
	// IPv4 addresses.
	IPV4s *DescribeStagingIpResponseBodyIPV4s `json:"IPV4s,omitempty" xml:"IPV4s,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeStagingIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeStagingIpResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeStagingIpResponseBody) SetIPV4s(v *DescribeStagingIpResponseBodyIPV4s) *DescribeStagingIpResponseBody {
	s.IPV4s = v
	return s
}

func (s *DescribeStagingIpResponseBody) SetRequestId(v string) *DescribeStagingIpResponseBody {
	s.RequestId = &v
	return s
}

type DescribeStagingIpResponseBodyIPV4s struct {
	IPV4 []*string `json:"IPV4,omitempty" xml:"IPV4,omitempty" type:"Repeated"`
}

func (s DescribeStagingIpResponseBodyIPV4s) String() string {
	return tea.Prettify(s)
}

func (s DescribeStagingIpResponseBodyIPV4s) GoString() string {
	return s.String()
}

func (s *DescribeStagingIpResponseBodyIPV4s) SetIPV4(v []*string) *DescribeStagingIpResponseBodyIPV4s {
	s.IPV4 = v
	return s
}

type DescribeStagingIpResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeStagingIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeStagingIpResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeStagingIpResponse) GoString() string {
	return s.String()
}

func (s *DescribeStagingIpResponse) SetHeaders(v map[string]*string) *DescribeStagingIpResponse {
	s.Headers = v
	return s
}

func (s *DescribeStagingIpResponse) SetStatusCode(v int32) *DescribeStagingIpResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeStagingIpResponse) SetBody(v *DescribeStagingIpResponseBody) *DescribeStagingIpResponse {
	s.Body = v
	return s
}

type DescribeTagResourcesRequest struct {
	// The IDs of the resources. You can specify up to 50 IDs in each request.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Set the value to **DOMAIN**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags. You can specify up to 20 tags in each request.
	Tag []*DescribeTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesRequest) SetResourceId(v []*string) *DescribeTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *DescribeTagResourcesRequest) SetResourceType(v string) *DescribeTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribeTagResourcesRequest) SetTag(v []*DescribeTagResourcesRequestTag) *DescribeTagResourcesRequest {
	s.Tag = v
	return s
}

type DescribeTagResourcesRequestTag struct {
	// The key of the tag. Valid values of N: **1** to **20**.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. Valid values of N: **1** to **20**.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesRequestTag) SetKey(v string) *DescribeTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeTagResourcesRequestTag) SetValue(v string) *DescribeTagResourcesRequestTag {
	s.Value = &v
	return s
}

type DescribeTagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tags that are attached to the specified resource.
	TagResources []*DescribeTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Repeated"`
}

func (s DescribeTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponseBody) SetRequestId(v string) *DescribeTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagResourcesResponseBody) SetTagResources(v []*DescribeTagResourcesResponseBodyTagResources) *DescribeTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type DescribeTagResourcesResponseBodyTagResources struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The key-value pair of the tag.
	Tag []*DescribeTagResourcesResponseBodyTagResourcesTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponseBodyTagResources) SetResourceId(v string) *DescribeTagResourcesResponseBodyTagResources {
	s.ResourceId = &v
	return s
}

func (s *DescribeTagResourcesResponseBodyTagResources) SetTag(v []*DescribeTagResourcesResponseBodyTagResourcesTag) *DescribeTagResourcesResponseBodyTagResources {
	s.Tag = v
	return s
}

type DescribeTagResourcesResponseBodyTagResourcesTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeTagResourcesResponseBodyTagResourcesTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponseBodyTagResourcesTag) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponseBodyTagResourcesTag) SetKey(v string) *DescribeTagResourcesResponseBodyTagResourcesTag {
	s.Key = &v
	return s
}

func (s *DescribeTagResourcesResponseBodyTagResourcesTag) SetValue(v string) *DescribeTagResourcesResponseBodyTagResourcesTag {
	s.Value = &v
	return s
}

type DescribeTagResourcesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponse) SetHeaders(v map[string]*string) *DescribeTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagResourcesResponse) SetStatusCode(v int32) *DescribeTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagResourcesResponse) SetBody(v *DescribeTagResourcesResponseBody) *DescribeTagResourcesResponse {
	s.Body = v
	return s
}

type DescribeTopDomainsByFlowRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of domain names to query. Valid values: **1** to **100**. Default value: **20**.
	Limit *int64 `json:"Limit,omitempty" xml:"Limit,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The value of StartTime must be in UTC. For example, if the local time is 00:00 on June 1, 2021, set StartTime to 2021-05-31T16:00:00Z.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeTopDomainsByFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTopDomainsByFlowRequest) GoString() string {
	return s.String()
}

func (s *DescribeTopDomainsByFlowRequest) SetEndTime(v string) *DescribeTopDomainsByFlowRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeTopDomainsByFlowRequest) SetLimit(v int64) *DescribeTopDomainsByFlowRequest {
	s.Limit = &v
	return s
}

func (s *DescribeTopDomainsByFlowRequest) SetStartTime(v string) *DescribeTopDomainsByFlowRequest {
	s.StartTime = &v
	return s
}

type DescribeTopDomainsByFlowResponseBody struct {
	// The total number of accelerated domain names that belong to the current Alibaba Cloud account.
	DomainCount *int64 `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	// The total number of accelerated domain names that are in the **Enabled** state within the current Alibaba Cloud account.
	DomainOnlineCount *int64 `json:"DomainOnlineCount,omitempty" xml:"DomainOnlineCount,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The top N domain names ranked by network traffic.
	TopDomains *DescribeTopDomainsByFlowResponseBodyTopDomains `json:"TopDomains,omitempty" xml:"TopDomains,omitempty" type:"Struct"`
}

func (s DescribeTopDomainsByFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTopDomainsByFlowResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTopDomainsByFlowResponseBody) SetDomainCount(v int64) *DescribeTopDomainsByFlowResponseBody {
	s.DomainCount = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBody) SetDomainOnlineCount(v int64) *DescribeTopDomainsByFlowResponseBody {
	s.DomainOnlineCount = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBody) SetEndTime(v string) *DescribeTopDomainsByFlowResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBody) SetRequestId(v string) *DescribeTopDomainsByFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBody) SetStartTime(v string) *DescribeTopDomainsByFlowResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBody) SetTopDomains(v *DescribeTopDomainsByFlowResponseBodyTopDomains) *DescribeTopDomainsByFlowResponseBody {
	s.TopDomains = v
	return s
}

type DescribeTopDomainsByFlowResponseBodyTopDomains struct {
	TopDomain []*DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain `json:"TopDomain,omitempty" xml:"TopDomain,omitempty" type:"Repeated"`
}

func (s DescribeTopDomainsByFlowResponseBodyTopDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeTopDomainsByFlowResponseBodyTopDomains) GoString() string {
	return s.String()
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomains) SetTopDomain(v []*DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) *DescribeTopDomainsByFlowResponseBodyTopDomains {
	s.TopDomain = v
	return s
}

type DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The peak bandwidth value.
	MaxBps *float32 `json:"MaxBps,omitempty" xml:"MaxBps,omitempty"`
	// The time when the bandwidth reached the peak value.
	MaxBpsTime *string `json:"MaxBpsTime,omitempty" xml:"MaxBpsTime,omitempty"`
	// The ranking of the accelerated domain name.
	Rank *int64 `json:"Rank,omitempty" xml:"Rank,omitempty"`
	// The number of visits to the domain name.
	TotalAccess *int64 `json:"TotalAccess,omitempty" xml:"TotalAccess,omitempty"`
	// The total volume of traffic.
	TotalTraffic *string `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
	// The proportion of network traffic consumed to access the domain name.
	TrafficPercent *string `json:"TrafficPercent,omitempty" xml:"TrafficPercent,omitempty"`
}

func (s DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) String() string {
	return tea.Prettify(s)
}

func (s DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) GoString() string {
	return s.String()
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetDomainName(v string) *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.DomainName = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetMaxBps(v float32) *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.MaxBps = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetMaxBpsTime(v string) *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.MaxBpsTime = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetRank(v int64) *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.Rank = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetTotalAccess(v int64) *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.TotalAccess = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetTotalTraffic(v string) *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.TotalTraffic = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetTrafficPercent(v string) *DescribeTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.TrafficPercent = &v
	return s
}

type DescribeTopDomainsByFlowResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTopDomainsByFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTopDomainsByFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTopDomainsByFlowResponse) GoString() string {
	return s.String()
}

func (s *DescribeTopDomainsByFlowResponse) SetHeaders(v map[string]*string) *DescribeTopDomainsByFlowResponse {
	s.Headers = v
	return s
}

func (s *DescribeTopDomainsByFlowResponse) SetStatusCode(v int32) *DescribeTopDomainsByFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTopDomainsByFlowResponse) SetBody(v *DescribeTopDomainsByFlowResponseBody) *DescribeTopDomainsByFlowResponse {
	s.Body = v
	return s
}

type DescribeUserCertificateExpireCountResponseBody struct {
	// The number of domain names whose SSL certificates are about to expires within 30 days.
	ExpireWithin30DaysCount *int32 `json:"ExpireWithin30DaysCount,omitempty" xml:"ExpireWithin30DaysCount,omitempty"`
	// The number of domain names whose SSL certificates have already expired.
	ExpiredCount *int32 `json:"ExpiredCount,omitempty" xml:"ExpiredCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserCertificateExpireCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserCertificateExpireCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserCertificateExpireCountResponseBody) SetExpireWithin30DaysCount(v int32) *DescribeUserCertificateExpireCountResponseBody {
	s.ExpireWithin30DaysCount = &v
	return s
}

func (s *DescribeUserCertificateExpireCountResponseBody) SetExpiredCount(v int32) *DescribeUserCertificateExpireCountResponseBody {
	s.ExpiredCount = &v
	return s
}

func (s *DescribeUserCertificateExpireCountResponseBody) SetRequestId(v string) *DescribeUserCertificateExpireCountResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserCertificateExpireCountResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserCertificateExpireCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserCertificateExpireCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserCertificateExpireCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserCertificateExpireCountResponse) SetHeaders(v map[string]*string) *DescribeUserCertificateExpireCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserCertificateExpireCountResponse) SetStatusCode(v int32) *DescribeUserCertificateExpireCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserCertificateExpireCountResponse) SetBody(v *DescribeUserCertificateExpireCountResponseBody) *DescribeUserCertificateExpireCountResponse {
	s.Body = v
	return s
}

type DescribeUserConfigsRequest struct {
	// The feature whose configurations you want to query. You can specify only one feature in each request. Valid values: oss, green_manager, waf, cc_rule, ddos_dispatch, edge_safe, blocked_regions, http_acl_policy, bot_manager, and ip_reputation.
	Config        *string `json:"Config,omitempty" xml:"Config,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeUserConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserConfigsRequest) SetConfig(v string) *DescribeUserConfigsRequest {
	s.Config = &v
	return s
}

func (s *DescribeUserConfigsRequest) SetOwnerId(v int64) *DescribeUserConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeUserConfigsRequest) SetSecurityToken(v string) *DescribeUserConfigsRequest {
	s.SecurityToken = &v
	return s
}

type DescribeUserConfigsResponseBody struct {
	// The configurations of the specified feature.
	Configs *DescribeUserConfigsResponseBodyConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserConfigsResponseBody) SetConfigs(v *DescribeUserConfigsResponseBodyConfigs) *DescribeUserConfigsResponseBody {
	s.Configs = v
	return s
}

func (s *DescribeUserConfigsResponseBody) SetRequestId(v string) *DescribeUserConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserConfigsResponseBodyConfigs struct {
	// The configurations of Object Storage Service (OSS).
	OssLogConfig *DescribeUserConfigsResponseBodyConfigsOssLogConfig `json:"OssLogConfig,omitempty" xml:"OssLogConfig,omitempty" type:"Struct"`
	// The configurations of Web Application Firewall (WAF).
	WafConfig *DescribeUserConfigsResponseBodyConfigsWafConfig `json:"WafConfig,omitempty" xml:"WafConfig,omitempty" type:"Struct"`
}

func (s DescribeUserConfigsResponseBodyConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConfigsResponseBodyConfigs) GoString() string {
	return s.String()
}

func (s *DescribeUserConfigsResponseBodyConfigs) SetOssLogConfig(v *DescribeUserConfigsResponseBodyConfigsOssLogConfig) *DescribeUserConfigsResponseBodyConfigs {
	s.OssLogConfig = v
	return s
}

func (s *DescribeUserConfigsResponseBodyConfigs) SetWafConfig(v *DescribeUserConfigsResponseBodyConfigsWafConfig) *DescribeUserConfigsResponseBodyConfigs {
	s.WafConfig = v
	return s
}

type DescribeUserConfigsResponseBodyConfigsOssLogConfig struct {
	// The name of the bucket.
	Bucket *string `json:"Bucket,omitempty" xml:"Bucket,omitempty"`
	// Indicates whether the OSS bucket is enabled.
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The prefix.
	Prefix *string `json:"Prefix,omitempty" xml:"Prefix,omitempty"`
}

func (s DescribeUserConfigsResponseBodyConfigsOssLogConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConfigsResponseBodyConfigsOssLogConfig) GoString() string {
	return s.String()
}

func (s *DescribeUserConfigsResponseBodyConfigsOssLogConfig) SetBucket(v string) *DescribeUserConfigsResponseBodyConfigsOssLogConfig {
	s.Bucket = &v
	return s
}

func (s *DescribeUserConfigsResponseBodyConfigsOssLogConfig) SetEnable(v string) *DescribeUserConfigsResponseBodyConfigsOssLogConfig {
	s.Enable = &v
	return s
}

func (s *DescribeUserConfigsResponseBodyConfigsOssLogConfig) SetPrefix(v string) *DescribeUserConfigsResponseBodyConfigsOssLogConfig {
	s.Prefix = &v
	return s
}

type DescribeUserConfigsResponseBodyConfigsWafConfig struct {
	// Indicates whether WAF is enabled.
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
}

func (s DescribeUserConfigsResponseBodyConfigsWafConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConfigsResponseBodyConfigsWafConfig) GoString() string {
	return s.String()
}

func (s *DescribeUserConfigsResponseBodyConfigsWafConfig) SetEnable(v string) *DescribeUserConfigsResponseBodyConfigsWafConfig {
	s.Enable = &v
	return s
}

type DescribeUserConfigsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserConfigsResponse) SetHeaders(v map[string]*string) *DescribeUserConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserConfigsResponse) SetStatusCode(v int32) *DescribeUserConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserConfigsResponse) SetBody(v *DescribeUserConfigsResponseBody) *DescribeUserConfigsResponse {
	s.Body = v
	return s
}

type DescribeUserDomainsRequest struct {
	// The type of workload accelerated by Alibaba Cloud CDN. Separate types with commas (,). Valid values:
	//
	// *   **web**: images and small files
	// *   **download**: large files
	// *   **video**: on-demand video and audio streaming
	//
	// If you do not set this parameter, all service types are queried.
	CdnType *string `json:"CdnType,omitempty" xml:"CdnType,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	ChangeEndTime *string `json:"ChangeEndTime,omitempty" xml:"ChangeEndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	ChangeStartTime *string `json:"ChangeStartTime,omitempty" xml:"ChangeStartTime,omitempty"`
	// Specifies whether to display domain names that are under review, failed the review, or failed to be configured. Valid values:
	//
	// *   **true**
	// *   **false**
	CheckDomainShow *bool `json:"CheckDomainShow,omitempty" xml:"CheckDomainShow,omitempty"`
	// The acceleration region. By default, all acceleration regions are queried. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **global**: global
	// *   **overseas**: outside the Chinese mainland
	Coverage *string `json:"Coverage,omitempty" xml:"Coverage,omitempty"`
	// The accelerated domain. If you do not set this parameter, all domain names that match the conditions are returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The search mode. Valid values:
	//
	// *   **fuzzy_match**: fuzzy match
	// *   **pre_match**: prefix match
	// *   **suf_match**: suffix match
	// *   **full_match** (default): exact match
	//
	// > If you specify the domain names to query but do not set the DomainSearchType parameter, the exact match mode is used.
	DomainSearchType *string `json:"DomainSearchType,omitempty" xml:"DomainSearchType,omitempty"`
	// The status of the domain name. Valid values:
	//
	// *   **online**
	// *   **offline**
	// *   **configuring**
	// *   **configure_failed**
	// *   **checking**
	// *   **check_failed**
	// *   **stopping**
	// *   **deleting**
	//
	// If you do not set this parameter, domain names in all states are queried.
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: **1** to **100000**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1 to 50**. Default value: **20**. Maximum value: **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group. By default, all IDs are queried.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the origin server.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The list of tags. Maximum number of elements in the list: 20
	Tag []*DescribeUserDomainsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeUserDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsRequest) SetCdnType(v string) *DescribeUserDomainsRequest {
	s.CdnType = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetChangeEndTime(v string) *DescribeUserDomainsRequest {
	s.ChangeEndTime = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetChangeStartTime(v string) *DescribeUserDomainsRequest {
	s.ChangeStartTime = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetCheckDomainShow(v bool) *DescribeUserDomainsRequest {
	s.CheckDomainShow = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetCoverage(v string) *DescribeUserDomainsRequest {
	s.Coverage = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetDomainName(v string) *DescribeUserDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetDomainSearchType(v string) *DescribeUserDomainsRequest {
	s.DomainSearchType = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetDomainStatus(v string) *DescribeUserDomainsRequest {
	s.DomainStatus = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetOwnerId(v int64) *DescribeUserDomainsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetPageNumber(v int32) *DescribeUserDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetPageSize(v int32) *DescribeUserDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetResourceGroupId(v string) *DescribeUserDomainsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetSecurityToken(v string) *DescribeUserDomainsRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetSource(v string) *DescribeUserDomainsRequest {
	s.Source = &v
	return s
}

func (s *DescribeUserDomainsRequest) SetTag(v []*DescribeUserDomainsRequestTag) *DescribeUserDomainsRequest {
	s.Tag = v
	return s
}

type DescribeUserDomainsRequestTag struct {
	// The key of a tag.
	//
	// By default, all tag keys are queried.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	//
	// By default, all tag values are queried.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeUserDomainsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsRequestTag) SetKey(v string) *DescribeUserDomainsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeUserDomainsRequestTag) SetValue(v string) *DescribeUserDomainsRequestTag {
	s.Value = &v
	return s
}

type DescribeUserDomainsResponseBody struct {
	// The list of the accelerated domain names returned.
	Domains *DescribeUserDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeUserDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsResponseBody) SetDomains(v *DescribeUserDomainsResponseBodyDomains) *DescribeUserDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeUserDomainsResponseBody) SetPageNumber(v int64) *DescribeUserDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeUserDomainsResponseBody) SetPageSize(v int64) *DescribeUserDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeUserDomainsResponseBody) SetRequestId(v string) *DescribeUserDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUserDomainsResponseBody) SetTotalCount(v int64) *DescribeUserDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeUserDomainsResponseBodyDomains struct {
	PageData []*DescribeUserDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeUserDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsResponseBodyDomains) SetPageData(v []*DescribeUserDomainsResponseBodyDomainsPageData) *DescribeUserDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeUserDomainsResponseBodyDomainsPageData struct {
	// The type of the workload accelerated by Alibaba Cloud CDN. Valid values:
	//
	// *   **web**: images and small files
	// *   **download**: large files
	// *   **video**: on-demand video and audio streaming
	CdnType *string `json:"CdnType,omitempty" xml:"CdnType,omitempty"`
	// The CNAME assigned to the accelerated domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The acceleration region. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **global**: global
	// *   **overseas**: outside the Chinese mainland
	Coverage *string `json:"Coverage,omitempty" xml:"Coverage,omitempty"`
	// The information about Internet Content Provider (ICP) filing.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the accelerated domain name.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The accelerated domain.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   **online**
	// *   **offline**
	// *   **configuring**
	// *   **configure_failed**
	// *   **checking**
	// *   **check_failed**
	// *   **stopping**
	// *   **deleting**
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the accelerated domain name was added.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the accelerated domain name was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the accelerated domain name is in a sandbox.
	Sandbox *string `json:"Sandbox,omitempty" xml:"Sandbox,omitempty"`
	// The information about the origin server.
	Sources *DescribeUserDomainsResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// Indicates whether HTTPS is enabled. Valid values:
	//
	// *   **on**
	// *   **off**
	SslProtocol *string `json:"SslProtocol,omitempty" xml:"SslProtocol,omitempty"`
}

func (s DescribeUserDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetCdnType(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.CdnType = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetCname(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetCoverage(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.Coverage = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetDescription(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetDomainId(v int64) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.DomainId = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetResourceGroupId(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetSandbox(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.Sandbox = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetSources(v *DescribeUserDomainsResponseBodyDomainsPageDataSources) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageData) SetSslProtocol(v string) *DescribeUserDomainsResponseBodyDomainsPageData {
	s.SslProtocol = &v
	return s
}

type DescribeUserDomainsResponseBodyDomainsPageDataSources struct {
	Source []*DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeUserDomainsResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsResponseBodyDomainsPageDataSources) SetSource(v []*DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) *DescribeUserDomainsResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The port of the origin server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource) SetWeight(v string) *DescribeUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Weight = &v
	return s
}

type DescribeUserDomainsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserDomainsResponse) SetHeaders(v map[string]*string) *DescribeUserDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserDomainsResponse) SetStatusCode(v int32) *DescribeUserDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserDomainsResponse) SetBody(v *DescribeUserDomainsResponseBody) *DescribeUserDomainsResponse {
	s.Body = v
	return s
}

type DescribeUserTagsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tags.
	Tags []*DescribeUserTagsResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeUserTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserTagsResponseBody) SetRequestId(v string) *DescribeUserTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUserTagsResponseBody) SetTags(v []*DescribeUserTagsResponseBodyTags) *DescribeUserTagsResponseBody {
	s.Tags = v
	return s
}

type DescribeUserTagsResponseBodyTags struct {
	// The key of a tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag values returned.
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeUserTagsResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserTagsResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeUserTagsResponseBodyTags) SetKey(v string) *DescribeUserTagsResponseBodyTags {
	s.Key = &v
	return s
}

func (s *DescribeUserTagsResponseBodyTags) SetValue(v []*string) *DescribeUserTagsResponseBodyTags {
	s.Value = v
	return s
}

type DescribeUserTagsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserTagsResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserTagsResponse) SetHeaders(v map[string]*string) *DescribeUserTagsResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserTagsResponse) SetStatusCode(v int32) *DescribeUserTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserTagsResponse) SetBody(v *DescribeUserTagsResponseBody) *DescribeUserTagsResponse {
	s.Body = v
	return s
}

type DescribeUserUsageDataExportTaskRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **50**.
	//
	// Valid values: an integer from **1** to **50**.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeUserUsageDataExportTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDataExportTaskRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDataExportTaskRequest) SetPageNumber(v string) *DescribeUserUsageDataExportTaskRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskRequest) SetPageSize(v string) *DescribeUserUsageDataExportTaskRequest {
	s.PageSize = &v
	return s
}

type DescribeUserUsageDataExportTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The usage details returned per page.
	UsageDataPerPage *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage `json:"UsageDataPerPage,omitempty" xml:"UsageDataPerPage,omitempty" type:"Struct"`
}

func (s DescribeUserUsageDataExportTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDataExportTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDataExportTaskResponseBody) SetRequestId(v string) *DescribeUserUsageDataExportTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBody) SetUsageDataPerPage(v *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage) *DescribeUserUsageDataExportTaskResponseBody {
	s.UsageDataPerPage = v
	return s
}

type DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage struct {
	// The information about the tasks.
	Data *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage) SetData(v *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage {
	s.Data = v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage) SetPageNumber(v int32) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage {
	s.PageNumber = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage) SetPageSize(v int32) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage {
	s.PageSize = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage) SetTotalCount(v int32) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPage {
	s.TotalCount = &v
	return s
}

type DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData struct {
	DataItem []*DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem `json:"DataItem,omitempty" xml:"DataItem,omitempty" type:"Repeated"`
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData) SetDataItem(v []*DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageData {
	s.DataItem = v
	return s
}

type DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem struct {
	// The time when the task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The download URL.
	DownloadUrl *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	// The state of the task.
	//
	// *   created: The task is being created.
	// *   success: The task is successful.
	// *   failed: The task failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The configurations of the task.
	TaskConfig *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig `json:"TaskConfig,omitempty" xml:"TaskConfig,omitempty" type:"Struct"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	// The time when the task was last modified.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetCreateTime(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.CreateTime = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetDownloadUrl(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.DownloadUrl = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetStatus(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.Status = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetTaskConfig(v *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.TaskConfig = v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetTaskId(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.TaskId = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetTaskName(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.TaskName = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetUpdateTime(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.UpdateTime = &v
	return s
}

type DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig struct {
	// The end of the time range that was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) SetEndTime(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig {
	s.EndTime = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) SetStartTime(v string) *DescribeUserUsageDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig {
	s.StartTime = &v
	return s
}

type DescribeUserUsageDataExportTaskResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserUsageDataExportTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserUsageDataExportTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDataExportTaskResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDataExportTaskResponse) SetHeaders(v map[string]*string) *DescribeUserUsageDataExportTaskResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponse) SetStatusCode(v int32) *DescribeUserUsageDataExportTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserUsageDataExportTaskResponse) SetBody(v *DescribeUserUsageDataExportTaskResponseBody) *DescribeUserUsageDataExportTaskResponse {
	s.Body = v
	return s
}

type DescribeUserUsageDetailDataExportTaskRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **50**.
	//
	// Valid values: an integer from **1** to **50**.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeUserUsageDetailDataExportTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDetailDataExportTaskRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDetailDataExportTaskRequest) SetPageNumber(v string) *DescribeUserUsageDetailDataExportTaskRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskRequest) SetPageSize(v string) *DescribeUserUsageDetailDataExportTaskRequest {
	s.PageSize = &v
	return s
}

type DescribeUserUsageDetailDataExportTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The usage details returned per page.
	UsageDataPerPage *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage `json:"UsageDataPerPage,omitempty" xml:"UsageDataPerPage,omitempty" type:"Struct"`
}

func (s DescribeUserUsageDetailDataExportTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDetailDataExportTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBody) SetRequestId(v string) *DescribeUserUsageDetailDataExportTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBody) SetUsageDataPerPage(v *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage) *DescribeUserUsageDetailDataExportTaskResponseBody {
	s.UsageDataPerPage = v
	return s
}

type DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage struct {
	// The information about the task.
	Data *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage) SetData(v *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage {
	s.Data = v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage) SetPageNumber(v int32) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage {
	s.PageNumber = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage) SetPageSize(v int32) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage {
	s.PageSize = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage) SetTotalCount(v int32) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPage {
	s.TotalCount = &v
	return s
}

type DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData struct {
	DataItem []*DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem `json:"DataItem,omitempty" xml:"DataItem,omitempty" type:"Repeated"`
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData) SetDataItem(v []*DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageData {
	s.DataItem = v
	return s
}

type DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem struct {
	// The time when the task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The download URL.
	DownloadUrl *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	// The status of the task.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The configurations of the task.
	TaskConfig *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig `json:"TaskConfig,omitempty" xml:"TaskConfig,omitempty" type:"Struct"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	// The time when the task was last modified.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetCreateTime(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.CreateTime = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetDownloadUrl(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.DownloadUrl = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetStatus(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.Status = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetTaskConfig(v *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.TaskConfig = v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetTaskId(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.TaskId = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetTaskName(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.TaskName = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem) SetUpdateTime(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItem {
	s.UpdateTime = &v
	return s
}

type DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig struct {
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) SetEndTime(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig {
	s.EndTime = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig) SetStartTime(v string) *DescribeUserUsageDetailDataExportTaskResponseBodyUsageDataPerPageDataDataItemTaskConfig {
	s.StartTime = &v
	return s
}

type DescribeUserUsageDetailDataExportTaskResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserUsageDetailDataExportTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserUsageDetailDataExportTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserUsageDetailDataExportTaskResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserUsageDetailDataExportTaskResponse) SetHeaders(v map[string]*string) *DescribeUserUsageDetailDataExportTaskResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponse) SetStatusCode(v int32) *DescribeUserUsageDetailDataExportTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserUsageDetailDataExportTaskResponse) SetBody(v *DescribeUserUsageDetailDataExportTaskResponseBody) *DescribeUserUsageDetailDataExportTaskResponse {
	s.Body = v
	return s
}

type DescribeUserVipsByDomainRequest struct {
	// Specifies whether to query the virtual IP addresses of only healthy CDN POPs. Valid values:
	//
	// *   **on**：healthy CDN edge nodes.
	// *   **off**：all CDN edge nodes.
	Available *string `json:"Available,omitempty" xml:"Available,omitempty"`
	// The accelerated domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeUserVipsByDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserVipsByDomainRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserVipsByDomainRequest) SetAvailable(v string) *DescribeUserVipsByDomainRequest {
	s.Available = &v
	return s
}

func (s *DescribeUserVipsByDomainRequest) SetDomainName(v string) *DescribeUserVipsByDomainRequest {
	s.DomainName = &v
	return s
}

type DescribeUserVipsByDomainResponseBody struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of VIPs.
	Vips *DescribeUserVipsByDomainResponseBodyVips `json:"Vips,omitempty" xml:"Vips,omitempty" type:"Struct"`
}

func (s DescribeUserVipsByDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserVipsByDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserVipsByDomainResponseBody) SetDomainName(v string) *DescribeUserVipsByDomainResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeUserVipsByDomainResponseBody) SetRequestId(v string) *DescribeUserVipsByDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUserVipsByDomainResponseBody) SetVips(v *DescribeUserVipsByDomainResponseBodyVips) *DescribeUserVipsByDomainResponseBody {
	s.Vips = v
	return s
}

type DescribeUserVipsByDomainResponseBodyVips struct {
	Vip []*string `json:"Vip,omitempty" xml:"Vip,omitempty" type:"Repeated"`
}

func (s DescribeUserVipsByDomainResponseBodyVips) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserVipsByDomainResponseBodyVips) GoString() string {
	return s.String()
}

func (s *DescribeUserVipsByDomainResponseBodyVips) SetVip(v []*string) *DescribeUserVipsByDomainResponseBodyVips {
	s.Vip = v
	return s
}

type DescribeUserVipsByDomainResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserVipsByDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserVipsByDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserVipsByDomainResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserVipsByDomainResponse) SetHeaders(v map[string]*string) *DescribeUserVipsByDomainResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserVipsByDomainResponse) SetStatusCode(v int32) *DescribeUserVipsByDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserVipsByDomainResponse) SetBody(v *DescribeUserVipsByDomainResponseBody) *DescribeUserVipsByDomainResponse {
	s.Body = v
	return s
}

type DescribeVerifyContentRequest struct {
	// The domain name of which the ownership was verified. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeVerifyContentRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVerifyContentRequest) GoString() string {
	return s.String()
}

func (s *DescribeVerifyContentRequest) SetDomainName(v string) *DescribeVerifyContentRequest {
	s.DomainName = &v
	return s
}

type DescribeVerifyContentResponseBody struct {
	// The verification content.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVerifyContentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVerifyContentResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVerifyContentResponseBody) SetContent(v string) *DescribeVerifyContentResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeVerifyContentResponseBody) SetRequestId(v string) *DescribeVerifyContentResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVerifyContentResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVerifyContentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVerifyContentResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVerifyContentResponse) GoString() string {
	return s.String()
}

func (s *DescribeVerifyContentResponse) SetHeaders(v map[string]*string) *DescribeVerifyContentResponse {
	s.Headers = v
	return s
}

func (s *DescribeVerifyContentResponse) SetStatusCode(v int32) *DescribeVerifyContentResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVerifyContentResponse) SetBody(v *DescribeVerifyContentResponseBody) *DescribeVerifyContentResponse {
	s.Body = v
	return s
}

type DisableRealtimeLogDeliveryRequest struct {
	// The accelerated domain name for which you want to disable real-time log delivery. You can specify multiple domain names and separate them with commas (,).
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s DisableRealtimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableRealtimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *DisableRealtimeLogDeliveryRequest) SetDomain(v string) *DisableRealtimeLogDeliveryRequest {
	s.Domain = &v
	return s
}

type DisableRealtimeLogDeliveryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableRealtimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableRealtimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *DisableRealtimeLogDeliveryResponseBody) SetRequestId(v string) *DisableRealtimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type DisableRealtimeLogDeliveryResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableRealtimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableRealtimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableRealtimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *DisableRealtimeLogDeliveryResponse) SetHeaders(v map[string]*string) *DisableRealtimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *DisableRealtimeLogDeliveryResponse) SetStatusCode(v int32) *DisableRealtimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableRealtimeLogDeliveryResponse) SetBody(v *DisableRealtimeLogDeliveryResponseBody) *DisableRealtimeLogDeliveryResponse {
	s.Body = v
	return s
}

type EnableRealtimeLogDeliveryRequest struct {
	// The accelerated domain name for which you want to enable real-time log delivery. You can specify multiple domain names and separate them with commas (,).
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s EnableRealtimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableRealtimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *EnableRealtimeLogDeliveryRequest) SetDomain(v string) *EnableRealtimeLogDeliveryRequest {
	s.Domain = &v
	return s
}

type EnableRealtimeLogDeliveryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableRealtimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableRealtimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *EnableRealtimeLogDeliveryResponseBody) SetRequestId(v string) *EnableRealtimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type EnableRealtimeLogDeliveryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableRealtimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableRealtimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableRealtimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *EnableRealtimeLogDeliveryResponse) SetHeaders(v map[string]*string) *EnableRealtimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *EnableRealtimeLogDeliveryResponse) SetStatusCode(v int32) *EnableRealtimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableRealtimeLogDeliveryResponse) SetBody(v *EnableRealtimeLogDeliveryResponseBody) *EnableRealtimeLogDeliveryResponse {
	s.Body = v
	return s
}

type ListDomainsByLogConfigIdRequest struct {
	// The ID of the custom configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
}

func (s ListDomainsByLogConfigIdRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsByLogConfigIdRequest) GoString() string {
	return s.String()
}

func (s *ListDomainsByLogConfigIdRequest) SetConfigId(v string) *ListDomainsByLogConfigIdRequest {
	s.ConfigId = &v
	return s
}

type ListDomainsByLogConfigIdResponseBody struct {
	// The domain names.
	Domains *ListDomainsByLogConfigIdResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDomainsByLogConfigIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsByLogConfigIdResponseBody) GoString() string {
	return s.String()
}

func (s *ListDomainsByLogConfigIdResponseBody) SetDomains(v *ListDomainsByLogConfigIdResponseBodyDomains) *ListDomainsByLogConfigIdResponseBody {
	s.Domains = v
	return s
}

func (s *ListDomainsByLogConfigIdResponseBody) SetRequestId(v string) *ListDomainsByLogConfigIdResponseBody {
	s.RequestId = &v
	return s
}

type ListDomainsByLogConfigIdResponseBodyDomains struct {
	Domain []*string `json:"Domain,omitempty" xml:"Domain,omitempty" type:"Repeated"`
}

func (s ListDomainsByLogConfigIdResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsByLogConfigIdResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *ListDomainsByLogConfigIdResponseBodyDomains) SetDomain(v []*string) *ListDomainsByLogConfigIdResponseBodyDomains {
	s.Domain = v
	return s
}

type ListDomainsByLogConfigIdResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDomainsByLogConfigIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDomainsByLogConfigIdResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsByLogConfigIdResponse) GoString() string {
	return s.String()
}

func (s *ListDomainsByLogConfigIdResponse) SetHeaders(v map[string]*string) *ListDomainsByLogConfigIdResponse {
	s.Headers = v
	return s
}

func (s *ListDomainsByLogConfigIdResponse) SetStatusCode(v int32) *ListDomainsByLogConfigIdResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDomainsByLogConfigIdResponse) SetBody(v *ListDomainsByLogConfigIdResponseBody) *ListDomainsByLogConfigIdResponse {
	s.Body = v
	return s
}

type ListFCTriggerRequest struct {
	// The name of the event. You can specify only one name.
	EventMetaName *string `json:"EventMetaName,omitempty" xml:"EventMetaName,omitempty"`
	// The version number of the event. You can specify only one version number.
	EventMetaVersion *string `json:"EventMetaVersion,omitempty" xml:"EventMetaVersion,omitempty"`
}

func (s ListFCTriggerRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFCTriggerRequest) GoString() string {
	return s.String()
}

func (s *ListFCTriggerRequest) SetEventMetaName(v string) *ListFCTriggerRequest {
	s.EventMetaName = &v
	return s
}

func (s *ListFCTriggerRequest) SetEventMetaVersion(v string) *ListFCTriggerRequest {
	s.EventMetaVersion = &v
	return s
}

type ListFCTriggerResponseBody struct {
	// The Function Compute triggers that are set for Alibaba Cloud CDN events.
	FCTriggers []*ListFCTriggerResponseBodyFCTriggers `json:"FCTriggers,omitempty" xml:"FCTriggers,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListFCTriggerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFCTriggerResponseBody) GoString() string {
	return s.String()
}

func (s *ListFCTriggerResponseBody) SetFCTriggers(v []*ListFCTriggerResponseBodyFCTriggers) *ListFCTriggerResponseBody {
	s.FCTriggers = v
	return s
}

func (s *ListFCTriggerResponseBody) SetRequestId(v string) *ListFCTriggerResponseBody {
	s.RequestId = &v
	return s
}

type ListFCTriggerResponseBodyFCTriggers struct {
	// The name of the event.
	EventMetaName *string `json:"EventMetaName,omitempty" xml:"EventMetaName,omitempty"`
	// The version of the event.
	EventMetaVersion *string `json:"EventMetaVersion,omitempty" xml:"EventMetaVersion,omitempty"`
	// The remarks.
	Notes *string `json:"Notes,omitempty" xml:"Notes,omitempty"`
	// The Resource Access Management (RAM) role.
	RoleARN *string `json:"RoleARN,omitempty" xml:"RoleARN,omitempty"`
	// The resources and filters for event listening.
	SourceArn *string `json:"SourceArn,omitempty" xml:"SourceArn,omitempty"`
	// The trigger that corresponds to the Function Compute service.
	TriggerARN *string `json:"TriggerARN,omitempty" xml:"TriggerARN,omitempty"`
}

func (s ListFCTriggerResponseBodyFCTriggers) String() string {
	return tea.Prettify(s)
}

func (s ListFCTriggerResponseBodyFCTriggers) GoString() string {
	return s.String()
}

func (s *ListFCTriggerResponseBodyFCTriggers) SetEventMetaName(v string) *ListFCTriggerResponseBodyFCTriggers {
	s.EventMetaName = &v
	return s
}

func (s *ListFCTriggerResponseBodyFCTriggers) SetEventMetaVersion(v string) *ListFCTriggerResponseBodyFCTriggers {
	s.EventMetaVersion = &v
	return s
}

func (s *ListFCTriggerResponseBodyFCTriggers) SetNotes(v string) *ListFCTriggerResponseBodyFCTriggers {
	s.Notes = &v
	return s
}

func (s *ListFCTriggerResponseBodyFCTriggers) SetRoleARN(v string) *ListFCTriggerResponseBodyFCTriggers {
	s.RoleARN = &v
	return s
}

func (s *ListFCTriggerResponseBodyFCTriggers) SetSourceArn(v string) *ListFCTriggerResponseBodyFCTriggers {
	s.SourceArn = &v
	return s
}

func (s *ListFCTriggerResponseBodyFCTriggers) SetTriggerARN(v string) *ListFCTriggerResponseBodyFCTriggers {
	s.TriggerARN = &v
	return s
}

type ListFCTriggerResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListFCTriggerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFCTriggerResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFCTriggerResponse) GoString() string {
	return s.String()
}

func (s *ListFCTriggerResponse) SetHeaders(v map[string]*string) *ListFCTriggerResponse {
	s.Headers = v
	return s
}

func (s *ListFCTriggerResponse) SetStatusCode(v int32) *ListFCTriggerResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFCTriggerResponse) SetBody(v *ListFCTriggerResponseBody) *ListFCTriggerResponse {
	s.Body = v
	return s
}

type ListRealtimeLogDeliveryDomainsRequest struct {
	// The name of the Logstore that collects log data from Alibaba Cloud CDN in real time. You can specify multiple Logstore names and separate them with commas (,).
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery. You can specify multiple project names and separate them with commas (,).
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The ID of the region where the Log Service project is deployed. You can specify multiple region IDs and separate them with commas (,).
	//
	// For more information about regions, see [Regions that support real-time log delivery](~~144883~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s ListRealtimeLogDeliveryDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryDomainsRequest) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryDomainsRequest) SetLogstore(v string) *ListRealtimeLogDeliveryDomainsRequest {
	s.Logstore = &v
	return s
}

func (s *ListRealtimeLogDeliveryDomainsRequest) SetProject(v string) *ListRealtimeLogDeliveryDomainsRequest {
	s.Project = &v
	return s
}

func (s *ListRealtimeLogDeliveryDomainsRequest) SetRegion(v string) *ListRealtimeLogDeliveryDomainsRequest {
	s.Region = &v
	return s
}

type ListRealtimeLogDeliveryDomainsResponseBody struct {
	// The information about the accelerated domain names.
	Content *ListRealtimeLogDeliveryDomainsResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListRealtimeLogDeliveryDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryDomainsResponseBody) SetContent(v *ListRealtimeLogDeliveryDomainsResponseBodyContent) *ListRealtimeLogDeliveryDomainsResponseBody {
	s.Content = v
	return s
}

func (s *ListRealtimeLogDeliveryDomainsResponseBody) SetRequestId(v string) *ListRealtimeLogDeliveryDomainsResponseBody {
	s.RequestId = &v
	return s
}

type ListRealtimeLogDeliveryDomainsResponseBodyContent struct {
	Domains []*ListRealtimeLogDeliveryDomainsResponseBodyContentDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
}

func (s ListRealtimeLogDeliveryDomainsResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryDomainsResponseBodyContent) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryDomainsResponseBodyContent) SetDomains(v []*ListRealtimeLogDeliveryDomainsResponseBodyContentDomains) *ListRealtimeLogDeliveryDomainsResponseBodyContent {
	s.Domains = v
	return s
}

type ListRealtimeLogDeliveryDomainsResponseBodyContentDomains struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status. Valid values:
	//
	// *   **online**: enabled
	// *   **offline**: disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListRealtimeLogDeliveryDomainsResponseBodyContentDomains) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryDomainsResponseBodyContentDomains) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryDomainsResponseBodyContentDomains) SetDomainName(v string) *ListRealtimeLogDeliveryDomainsResponseBodyContentDomains {
	s.DomainName = &v
	return s
}

func (s *ListRealtimeLogDeliveryDomainsResponseBodyContentDomains) SetStatus(v string) *ListRealtimeLogDeliveryDomainsResponseBodyContentDomains {
	s.Status = &v
	return s
}

type ListRealtimeLogDeliveryDomainsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRealtimeLogDeliveryDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRealtimeLogDeliveryDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryDomainsResponse) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryDomainsResponse) SetHeaders(v map[string]*string) *ListRealtimeLogDeliveryDomainsResponse {
	s.Headers = v
	return s
}

func (s *ListRealtimeLogDeliveryDomainsResponse) SetStatusCode(v int32) *ListRealtimeLogDeliveryDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRealtimeLogDeliveryDomainsResponse) SetBody(v *ListRealtimeLogDeliveryDomainsResponseBody) *ListRealtimeLogDeliveryDomainsResponse {
	s.Body = v
	return s
}

type ListRealtimeLogDeliveryInfosResponseBody struct {
	// The information about real-time log delivery.
	Content *ListRealtimeLogDeliveryInfosResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListRealtimeLogDeliveryInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryInfosResponseBody) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryInfosResponseBody) SetContent(v *ListRealtimeLogDeliveryInfosResponseBodyContent) *ListRealtimeLogDeliveryInfosResponseBody {
	s.Content = v
	return s
}

func (s *ListRealtimeLogDeliveryInfosResponseBody) SetRequestId(v string) *ListRealtimeLogDeliveryInfosResponseBody {
	s.RequestId = &v
	return s
}

type ListRealtimeLogDeliveryInfosResponseBodyContent struct {
	RealtimeLogDeliveryInfos []*ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos `json:"RealtimeLogDeliveryInfos,omitempty" xml:"RealtimeLogDeliveryInfos,omitempty" type:"Repeated"`
}

func (s ListRealtimeLogDeliveryInfosResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryInfosResponseBodyContent) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryInfosResponseBodyContent) SetRealtimeLogDeliveryInfos(v []*ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos) *ListRealtimeLogDeliveryInfosResponseBodyContent {
	s.RealtimeLogDeliveryInfos = v
	return s
}

type ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos struct {
	// The name of the Logstore that collects log data from Alibaba Cloud CDN in real time.
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The ID of the region where the Log Service project is deployed. For more information, see [Regions that support real-time log delivery](~~144883~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos) SetLogstore(v string) *ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos {
	s.Logstore = &v
	return s
}

func (s *ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos) SetProject(v string) *ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos {
	s.Project = &v
	return s
}

func (s *ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos) SetRegion(v string) *ListRealtimeLogDeliveryInfosResponseBodyContentRealtimeLogDeliveryInfos {
	s.Region = &v
	return s
}

type ListRealtimeLogDeliveryInfosResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRealtimeLogDeliveryInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRealtimeLogDeliveryInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRealtimeLogDeliveryInfosResponse) GoString() string {
	return s.String()
}

func (s *ListRealtimeLogDeliveryInfosResponse) SetHeaders(v map[string]*string) *ListRealtimeLogDeliveryInfosResponse {
	s.Headers = v
	return s
}

func (s *ListRealtimeLogDeliveryInfosResponse) SetStatusCode(v int32) *ListRealtimeLogDeliveryInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRealtimeLogDeliveryInfosResponse) SetBody(v *ListRealtimeLogDeliveryInfosResponseBody) *ListRealtimeLogDeliveryInfosResponse {
	s.Body = v
	return s
}

type ListUserCustomLogConfigResponseBody struct {
	// The list of log configuration IDs.
	ConfigIds *ListUserCustomLogConfigResponseBodyConfigIds `json:"ConfigIds,omitempty" xml:"ConfigIds,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListUserCustomLogConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListUserCustomLogConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ListUserCustomLogConfigResponseBody) SetConfigIds(v *ListUserCustomLogConfigResponseBodyConfigIds) *ListUserCustomLogConfigResponseBody {
	s.ConfigIds = v
	return s
}

func (s *ListUserCustomLogConfigResponseBody) SetRequestId(v string) *ListUserCustomLogConfigResponseBody {
	s.RequestId = &v
	return s
}

type ListUserCustomLogConfigResponseBodyConfigIds struct {
	ConfigId []*string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty" type:"Repeated"`
}

func (s ListUserCustomLogConfigResponseBodyConfigIds) String() string {
	return tea.Prettify(s)
}

func (s ListUserCustomLogConfigResponseBodyConfigIds) GoString() string {
	return s.String()
}

func (s *ListUserCustomLogConfigResponseBodyConfigIds) SetConfigId(v []*string) *ListUserCustomLogConfigResponseBodyConfigIds {
	s.ConfigId = v
	return s
}

type ListUserCustomLogConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListUserCustomLogConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUserCustomLogConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUserCustomLogConfigResponse) GoString() string {
	return s.String()
}

func (s *ListUserCustomLogConfigResponse) SetHeaders(v map[string]*string) *ListUserCustomLogConfigResponse {
	s.Headers = v
	return s
}

func (s *ListUserCustomLogConfigResponse) SetStatusCode(v int32) *ListUserCustomLogConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ListUserCustomLogConfigResponse) SetBody(v *ListUserCustomLogConfigResponseBody) *ListUserCustomLogConfigResponse {
	s.Body = v
	return s
}

type ModifyCdnDomainRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	//
	// > Do not set **Sources** and **TopLevelDomain** at the same time. If you set **Sources** and **TopLevelDomain** at the same time, **TopLevelDomain** does not take effect.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The root domain. To add a root domain name, you must be added to the whitelist specified by the CDN_TOP_LEVEL_DOMAIN_GREY_USER_LIST parameter.
	//
	// > Do not set **Sources** and **TopLevelDomain** at the same time. If you set **Sources** and **TopLevelDomain** at the same time, **TopLevelDomain** does not take effect.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s ModifyCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *ModifyCdnDomainRequest) SetDomainName(v string) *ModifyCdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *ModifyCdnDomainRequest) SetOwnerId(v int64) *ModifyCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCdnDomainRequest) SetResourceGroupId(v string) *ModifyCdnDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyCdnDomainRequest) SetSecurityToken(v string) *ModifyCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *ModifyCdnDomainRequest) SetSources(v string) *ModifyCdnDomainRequest {
	s.Sources = &v
	return s
}

func (s *ModifyCdnDomainRequest) SetTopLevelDomain(v string) *ModifyCdnDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type ModifyCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCdnDomainResponseBody) SetRequestId(v string) *ModifyCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCdnDomainResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *ModifyCdnDomainResponse) SetHeaders(v map[string]*string) *ModifyCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *ModifyCdnDomainResponse) SetStatusCode(v int32) *ModifyCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCdnDomainResponse) SetBody(v *ModifyCdnDomainResponseBody) *ModifyCdnDomainResponse {
	s.Body = v
	return s
}

type ModifyCdnDomainSchdmByPropertyRequest struct {
	// The accelerated domain name for which you want to change the acceleration region. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The information about the acceleration region. {"coverage":"overseas"}
	//
	// Valid values for coverage:
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: global (excluding the Chinese mainland)
	// *   **global**: global
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
}

func (s ModifyCdnDomainSchdmByPropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdnDomainSchdmByPropertyRequest) GoString() string {
	return s.String()
}

func (s *ModifyCdnDomainSchdmByPropertyRequest) SetDomainName(v string) *ModifyCdnDomainSchdmByPropertyRequest {
	s.DomainName = &v
	return s
}

func (s *ModifyCdnDomainSchdmByPropertyRequest) SetProperty(v string) *ModifyCdnDomainSchdmByPropertyRequest {
	s.Property = &v
	return s
}

type ModifyCdnDomainSchdmByPropertyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCdnDomainSchdmByPropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdnDomainSchdmByPropertyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCdnDomainSchdmByPropertyResponseBody) SetRequestId(v string) *ModifyCdnDomainSchdmByPropertyResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCdnDomainSchdmByPropertyResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCdnDomainSchdmByPropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCdnDomainSchdmByPropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdnDomainSchdmByPropertyResponse) GoString() string {
	return s.String()
}

func (s *ModifyCdnDomainSchdmByPropertyResponse) SetHeaders(v map[string]*string) *ModifyCdnDomainSchdmByPropertyResponse {
	s.Headers = v
	return s
}

func (s *ModifyCdnDomainSchdmByPropertyResponse) SetStatusCode(v int32) *ModifyCdnDomainSchdmByPropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCdnDomainSchdmByPropertyResponse) SetBody(v *ModifyCdnDomainSchdmByPropertyResponseBody) *ModifyCdnDomainSchdmByPropertyResponse {
	s.Body = v
	return s
}

type ModifyRealtimeLogDeliveryRequest struct {
	// The accelerated domain name for which you want to modify the configurations of real-time log delivery. Only one domain name is supported.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The name of the Logstore where log entries are stored.
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the Log Service project that is used for real-time log delivery.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The ID of the region where the Log Service project is deployed. For more information, see [Regions that support real-time log delivery](~~144883~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s ModifyRealtimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyRealtimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *ModifyRealtimeLogDeliveryRequest) SetDomain(v string) *ModifyRealtimeLogDeliveryRequest {
	s.Domain = &v
	return s
}

func (s *ModifyRealtimeLogDeliveryRequest) SetLogstore(v string) *ModifyRealtimeLogDeliveryRequest {
	s.Logstore = &v
	return s
}

func (s *ModifyRealtimeLogDeliveryRequest) SetProject(v string) *ModifyRealtimeLogDeliveryRequest {
	s.Project = &v
	return s
}

func (s *ModifyRealtimeLogDeliveryRequest) SetRegion(v string) *ModifyRealtimeLogDeliveryRequest {
	s.Region = &v
	return s
}

type ModifyRealtimeLogDeliveryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyRealtimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyRealtimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyRealtimeLogDeliveryResponseBody) SetRequestId(v string) *ModifyRealtimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type ModifyRealtimeLogDeliveryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyRealtimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyRealtimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyRealtimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *ModifyRealtimeLogDeliveryResponse) SetHeaders(v map[string]*string) *ModifyRealtimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *ModifyRealtimeLogDeliveryResponse) SetStatusCode(v int32) *ModifyRealtimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyRealtimeLogDeliveryResponse) SetBody(v *ModifyRealtimeLogDeliveryResponseBody) *ModifyRealtimeLogDeliveryResponse {
	s.Body = v
	return s
}

type OpenCdnServiceRequest struct {
	// The metering method of Alibaba Cloud CDN. A value of **PayByTraffic** indicates that the metering method is pay-by-data-transfer.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken      *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s OpenCdnServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenCdnServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenCdnServiceRequest) SetInternetChargeType(v string) *OpenCdnServiceRequest {
	s.InternetChargeType = &v
	return s
}

func (s *OpenCdnServiceRequest) SetOwnerId(v int64) *OpenCdnServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *OpenCdnServiceRequest) SetSecurityToken(v string) *OpenCdnServiceRequest {
	s.SecurityToken = &v
	return s
}

type OpenCdnServiceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenCdnServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenCdnServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenCdnServiceResponseBody) SetRequestId(v string) *OpenCdnServiceResponseBody {
	s.RequestId = &v
	return s
}

type OpenCdnServiceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenCdnServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenCdnServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenCdnServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenCdnServiceResponse) SetHeaders(v map[string]*string) *OpenCdnServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenCdnServiceResponse) SetStatusCode(v int32) *OpenCdnServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenCdnServiceResponse) SetBody(v *OpenCdnServiceResponseBody) *OpenCdnServiceResponse {
	s.Body = v
	return s
}

type PublishStagingConfigToProductionRequest struct {
	// The accelerated domain name. You can specify only one domain name in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s PublishStagingConfigToProductionRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishStagingConfigToProductionRequest) GoString() string {
	return s.String()
}

func (s *PublishStagingConfigToProductionRequest) SetDomainName(v string) *PublishStagingConfigToProductionRequest {
	s.DomainName = &v
	return s
}

type PublishStagingConfigToProductionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PublishStagingConfigToProductionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishStagingConfigToProductionResponseBody) GoString() string {
	return s.String()
}

func (s *PublishStagingConfigToProductionResponseBody) SetRequestId(v string) *PublishStagingConfigToProductionResponseBody {
	s.RequestId = &v
	return s
}

type PublishStagingConfigToProductionResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishStagingConfigToProductionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishStagingConfigToProductionResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishStagingConfigToProductionResponse) GoString() string {
	return s.String()
}

func (s *PublishStagingConfigToProductionResponse) SetHeaders(v map[string]*string) *PublishStagingConfigToProductionResponse {
	s.Headers = v
	return s
}

func (s *PublishStagingConfigToProductionResponse) SetStatusCode(v int32) *PublishStagingConfigToProductionResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishStagingConfigToProductionResponse) SetBody(v *PublishStagingConfigToProductionResponseBody) *PublishStagingConfigToProductionResponse {
	s.Body = v
	return s
}

type PushObjectCacheRequest struct {
	// The accelerated region where content is to be prefetched. Valid values:
	//
	// *   **domestic****: Chinese mainland**
	// *   **overseas****: regions outside the Chinese mainland**
	//
	// If you do not set this parameter, content in the accelerated region of the domain name is prefetched.
	//
	// *   If the accelerated region is set to **Mainland China Only**, content in regions in the Chinese mainland is prefetched.
	// *   If the accelerated region is set to **Global**, content in all regions is prefetched.
	// *   If the accelerated region is set to **Global (Excluding Mainland China)**, content in regions outside the Chinese mainland is prefetched.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// Specifies whether to prefetch content to POPs. Valid values:
	//
	// *   **true**: prefetches content to POPs.
	// *   **false**: prefetches content to regular POPs. Regular POPs can be L2 POPs or L3 POPs. Default value: **false**.
	L2Preload *bool `json:"L2Preload,omitempty" xml:"L2Preload,omitempty"`
	// The URLs based on which content is prefetched. Format: **accelerated domain name/files to be prefetched**.
	//
	// > Separate URLs with line feeds (\n or \r\n). Each object path can be up to 1,024 characters in length.
	ObjectPath    *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The custom header for prefetch in the JSON format.
	WithHeader *string `json:"WithHeader,omitempty" xml:"WithHeader,omitempty"`
}

func (s PushObjectCacheRequest) String() string {
	return tea.Prettify(s)
}

func (s PushObjectCacheRequest) GoString() string {
	return s.String()
}

func (s *PushObjectCacheRequest) SetArea(v string) *PushObjectCacheRequest {
	s.Area = &v
	return s
}

func (s *PushObjectCacheRequest) SetL2Preload(v bool) *PushObjectCacheRequest {
	s.L2Preload = &v
	return s
}

func (s *PushObjectCacheRequest) SetObjectPath(v string) *PushObjectCacheRequest {
	s.ObjectPath = &v
	return s
}

func (s *PushObjectCacheRequest) SetOwnerId(v int64) *PushObjectCacheRequest {
	s.OwnerId = &v
	return s
}

func (s *PushObjectCacheRequest) SetSecurityToken(v string) *PushObjectCacheRequest {
	s.SecurityToken = &v
	return s
}

func (s *PushObjectCacheRequest) SetWithHeader(v string) *PushObjectCacheRequest {
	s.WithHeader = &v
	return s
}

type PushObjectCacheResponseBody struct {
	// The ID of the prefetch task. If multiple tasks are returned, the IDs are separated by commas (,). The task IDs are merged based on the following rules:
	//
	// *   If the tasks are set for the same accelerated domain name, submitted within the same second, and prefetch content from URLs instead of directories, the tasks IDs are merged into the same task ID (RushTaskId).
	// *   If the number of tasks that are set for the same accelerated domain name, submitted within the same second, and prefetch content from URLs instead of directories exceeds 500, every 500 task IDs are merged into the same task ID (RushTaskId).
	PushTaskId *string `json:"PushTaskId,omitempty" xml:"PushTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PushObjectCacheResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PushObjectCacheResponseBody) GoString() string {
	return s.String()
}

func (s *PushObjectCacheResponseBody) SetPushTaskId(v string) *PushObjectCacheResponseBody {
	s.PushTaskId = &v
	return s
}

func (s *PushObjectCacheResponseBody) SetRequestId(v string) *PushObjectCacheResponseBody {
	s.RequestId = &v
	return s
}

type PushObjectCacheResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PushObjectCacheResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PushObjectCacheResponse) String() string {
	return tea.Prettify(s)
}

func (s PushObjectCacheResponse) GoString() string {
	return s.String()
}

func (s *PushObjectCacheResponse) SetHeaders(v map[string]*string) *PushObjectCacheResponse {
	s.Headers = v
	return s
}

func (s *PushObjectCacheResponse) SetStatusCode(v int32) *PushObjectCacheResponse {
	s.StatusCode = &v
	return s
}

func (s *PushObjectCacheResponse) SetBody(v *PushObjectCacheResponseBody) *PushObjectCacheResponse {
	s.Body = v
	return s
}

type RefreshObjectCachesRequest struct {
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the object that you want to refresh. Valid values:
	//
	// *   **File** (default): refreshes one or more files.
	// *   **Directory**: refreshes the files in one or more directories.
	// *   **Regex**: refreshes content based on regular expressions.
	// *   **ExQuery**: omits parameters after the question mark in the URL and refreshes content.
	//
	// If you set the ObjectType parameter to File or Directory, you can view [Refresh and prefetch resources](~~27140~~) to obtain more information. If you set the ObjectType parameter to Regex, you can view [Configure URL refresh rules that contain regular expressions](~~146195~~) to obtain more information.
	//
	// If you set the ObjectType parameter to Directory, the resources in the directory that you want to refresh are marked as expired. You cannot delete the directory. If clients request resources on POPs that are marked as expired, Alibaba Cloud CDN checks whether the resources on your origin server are updated. If resources are updated, Alibaba Cloud CDN retrieves the latest version of the resources and returns the resources to the clients. Otherwise, the origin server returns the 304 status code.
	ObjectType    *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s RefreshObjectCachesRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshObjectCachesRequest) GoString() string {
	return s.String()
}

func (s *RefreshObjectCachesRequest) SetObjectPath(v string) *RefreshObjectCachesRequest {
	s.ObjectPath = &v
	return s
}

func (s *RefreshObjectCachesRequest) SetObjectType(v string) *RefreshObjectCachesRequest {
	s.ObjectType = &v
	return s
}

func (s *RefreshObjectCachesRequest) SetOwnerId(v int64) *RefreshObjectCachesRequest {
	s.OwnerId = &v
	return s
}

func (s *RefreshObjectCachesRequest) SetSecurityToken(v string) *RefreshObjectCachesRequest {
	s.SecurityToken = &v
	return s
}

type RefreshObjectCachesResponseBody struct {
	// The refresh task ID. If multiple tasks are returned, the IDs are separated by commas (,). The task IDs are merged based on the following rules:
	//
	// *   If the tasks are specified for the same accelerated domain name, submitted within the same second, and run to refresh content based on URLs instead of directories, the task IDs are merged into one task ID.
	// *   If the number of tasks that are specified for the same accelerated domain name, submitted within the same second, and run to refresh content based on URLs instead of directories exceeds 2,000, every 2,000 task IDs are merged into one task ID.
	RefreshTaskId *string `json:"RefreshTaskId,omitempty" xml:"RefreshTaskId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RefreshObjectCachesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshObjectCachesResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshObjectCachesResponseBody) SetRefreshTaskId(v string) *RefreshObjectCachesResponseBody {
	s.RefreshTaskId = &v
	return s
}

func (s *RefreshObjectCachesResponseBody) SetRequestId(v string) *RefreshObjectCachesResponseBody {
	s.RequestId = &v
	return s
}

type RefreshObjectCachesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshObjectCachesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshObjectCachesResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshObjectCachesResponse) GoString() string {
	return s.String()
}

func (s *RefreshObjectCachesResponse) SetHeaders(v map[string]*string) *RefreshObjectCachesResponse {
	s.Headers = v
	return s
}

func (s *RefreshObjectCachesResponse) SetStatusCode(v int32) *RefreshObjectCachesResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshObjectCachesResponse) SetBody(v *RefreshObjectCachesResponseBody) *RefreshObjectCachesResponse {
	s.Body = v
	return s
}

type RollbackStagingConfigRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s RollbackStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s RollbackStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *RollbackStagingConfigRequest) SetDomainName(v string) *RollbackStagingConfigRequest {
	s.DomainName = &v
	return s
}

type RollbackStagingConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RollbackStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RollbackStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *RollbackStagingConfigResponseBody) SetRequestId(v string) *RollbackStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type RollbackStagingConfigResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RollbackStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RollbackStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s RollbackStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *RollbackStagingConfigResponse) SetHeaders(v map[string]*string) *RollbackStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *RollbackStagingConfigResponse) SetStatusCode(v int32) *RollbackStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *RollbackStagingConfigResponse) SetBody(v *RollbackStagingConfigResponseBody) *RollbackStagingConfigResponse {
	s.Body = v
	return s
}

type SetCdnDomainCSRCertificateRequest struct {
	// The accelerated domain name for which you want to configure an SSL certificate. The domain name must have HTTPS secure acceleration enabled.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The content of the certificate. The certificate must match the certificate signing request (CSR) created by calling the [CreateCdnCertificateSigningRequest](~~144478~~) operation. Make sure that the content of the certificate is encoded in Base64 and then encoded by encodeURIComponent.
	ServerCertificate *string `json:"ServerCertificate,omitempty" xml:"ServerCertificate,omitempty"`
}

func (s SetCdnDomainCSRCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainCSRCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetCdnDomainCSRCertificateRequest) SetDomainName(v string) *SetCdnDomainCSRCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetCdnDomainCSRCertificateRequest) SetServerCertificate(v string) *SetCdnDomainCSRCertificateRequest {
	s.ServerCertificate = &v
	return s
}

type SetCdnDomainCSRCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCdnDomainCSRCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainCSRCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetCdnDomainCSRCertificateResponseBody) SetRequestId(v string) *SetCdnDomainCSRCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetCdnDomainCSRCertificateResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetCdnDomainCSRCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetCdnDomainCSRCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainCSRCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetCdnDomainCSRCertificateResponse) SetHeaders(v map[string]*string) *SetCdnDomainCSRCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetCdnDomainCSRCertificateResponse) SetStatusCode(v int32) *SetCdnDomainCSRCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCdnDomainCSRCertificateResponse) SetBody(v *SetCdnDomainCSRCertificateResponseBody) *SetCdnDomainCSRCertificateResponse {
	s.Body = v
	return s
}

type SetCdnDomainSMCertificateRequest struct {
	// The ID of the SM certificate that you want to configure. The identifier of the certificate. The value is Certificate ID-cn-hangzhou. For example, if the certificate ID is 123, set the value of this parameter to 123-cn-hangzhou.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The accelerated domain name for which you want to configure the SM certificate.
	//
	// > The domain name must use HTTPS acceleration.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to enable the SSL certificate. Valid values:
	//
	// *   **on**
	// *   **off**
	SSLProtocol   *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetCdnDomainSMCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainSMCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetCdnDomainSMCertificateRequest) SetCertIdentifier(v string) *SetCdnDomainSMCertificateRequest {
	s.CertIdentifier = &v
	return s
}

func (s *SetCdnDomainSMCertificateRequest) SetDomainName(v string) *SetCdnDomainSMCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetCdnDomainSMCertificateRequest) SetOwnerId(v int64) *SetCdnDomainSMCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetCdnDomainSMCertificateRequest) SetSSLProtocol(v string) *SetCdnDomainSMCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetCdnDomainSMCertificateRequest) SetSecurityToken(v string) *SetCdnDomainSMCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetCdnDomainSMCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCdnDomainSMCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainSMCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetCdnDomainSMCertificateResponseBody) SetRequestId(v string) *SetCdnDomainSMCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetCdnDomainSMCertificateResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetCdnDomainSMCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetCdnDomainSMCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainSMCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetCdnDomainSMCertificateResponse) SetHeaders(v map[string]*string) *SetCdnDomainSMCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetCdnDomainSMCertificateResponse) SetStatusCode(v int32) *SetCdnDomainSMCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCdnDomainSMCertificateResponse) SetBody(v *SetCdnDomainSMCertificateResponseBody) *SetCdnDomainSMCertificateResponse {
	s.Body = v
	return s
}

type SetCdnDomainSSLCertificateRequest struct {
	// The ID of the certificate.
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the SSL certificate. You can specify only one certificate name.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The region ID of the certificate. Valid values: **cn-hangzhou** and **ap-southeast-1**. Default value: **cn-hangzhou**.
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The type of the certificate.
	//
	// *   **upload**: a user-uploaded SSL certificate.
	// *   **cas**: a certificate that is acquired through Certificate Management Service.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The accelerated domain name for which you want to configure the SSL certificate. The type of request supported by the domain name must be HTTPS. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The private key. Specify the private key only if you want to enable the SSL certificate.
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the SSL certificate.
	//
	// *   **on**
	// *   **off**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The content of the SSL certificate. Specify the content of the SSL certificate only if you want to enable the SSL certificate.
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetCdnDomainSSLCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainSSLCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetCdnDomainSSLCertificateRequest) SetCertId(v int64) *SetCdnDomainSSLCertificateRequest {
	s.CertId = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetCertName(v string) *SetCdnDomainSSLCertificateRequest {
	s.CertName = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetCertRegion(v string) *SetCdnDomainSSLCertificateRequest {
	s.CertRegion = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetCertType(v string) *SetCdnDomainSSLCertificateRequest {
	s.CertType = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetDomainName(v string) *SetCdnDomainSSLCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetOwnerId(v int64) *SetCdnDomainSSLCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetSSLPri(v string) *SetCdnDomainSSLCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetSSLProtocol(v string) *SetCdnDomainSSLCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetSSLPub(v string) *SetCdnDomainSSLCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *SetCdnDomainSSLCertificateRequest) SetSecurityToken(v string) *SetCdnDomainSSLCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetCdnDomainSSLCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCdnDomainSSLCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainSSLCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetCdnDomainSSLCertificateResponseBody) SetRequestId(v string) *SetCdnDomainSSLCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetCdnDomainSSLCertificateResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetCdnDomainSSLCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetCdnDomainSSLCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainSSLCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetCdnDomainSSLCertificateResponse) SetHeaders(v map[string]*string) *SetCdnDomainSSLCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetCdnDomainSSLCertificateResponse) SetStatusCode(v int32) *SetCdnDomainSSLCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCdnDomainSSLCertificateResponse) SetBody(v *SetCdnDomainSSLCertificateResponseBody) *SetCdnDomainSSLCertificateResponse {
	s.Body = v
	return s
}

type SetCdnDomainStagingConfigRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The features that you want to configure. Format:
	//
	// > *   **functionName**: The name of the feature. Separate multiple values with commas (,). For more information, see [A list of features](~~388460~~).
	// >*   **argName**: The feature parameters for **functionName**.
	// >*   **argValue**: The parameter values set for **functionName**.
	//
	//         [
	//          {
	//            "functionArgs": [
	//             {
	//              "argName": "Parameter A",
	//              "argValue": "Value of Parameter A"
	//             },
	//           {
	//             "argName": "Parameter B",
	//             "argValue": "Value of Parameter B"
	//              }
	//          ],
	//          "functionName": "Feature name"
	//             }
	//         ]
	Functions *string `json:"Functions,omitempty" xml:"Functions,omitempty"`
}

func (s SetCdnDomainStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *SetCdnDomainStagingConfigRequest) SetDomainName(v string) *SetCdnDomainStagingConfigRequest {
	s.DomainName = &v
	return s
}

func (s *SetCdnDomainStagingConfigRequest) SetFunctions(v string) *SetCdnDomainStagingConfigRequest {
	s.Functions = &v
	return s
}

type SetCdnDomainStagingConfigResponseBody struct {
	// The list of domain configurations.
	DomainConfigList []*SetCdnDomainStagingConfigResponseBodyDomainConfigList `json:"DomainConfigList,omitempty" xml:"DomainConfigList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCdnDomainStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *SetCdnDomainStagingConfigResponseBody) SetDomainConfigList(v []*SetCdnDomainStagingConfigResponseBodyDomainConfigList) *SetCdnDomainStagingConfigResponseBody {
	s.DomainConfigList = v
	return s
}

func (s *SetCdnDomainStagingConfigResponseBody) SetRequestId(v string) *SetCdnDomainStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type SetCdnDomainStagingConfigResponseBodyDomainConfigList struct {
	// The ID of the configuration.
	ConfigId *int64 `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s SetCdnDomainStagingConfigResponseBodyDomainConfigList) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainStagingConfigResponseBodyDomainConfigList) GoString() string {
	return s.String()
}

func (s *SetCdnDomainStagingConfigResponseBodyDomainConfigList) SetConfigId(v int64) *SetCdnDomainStagingConfigResponseBodyDomainConfigList {
	s.ConfigId = &v
	return s
}

func (s *SetCdnDomainStagingConfigResponseBodyDomainConfigList) SetDomainName(v string) *SetCdnDomainStagingConfigResponseBodyDomainConfigList {
	s.DomainName = &v
	return s
}

func (s *SetCdnDomainStagingConfigResponseBodyDomainConfigList) SetFunctionName(v string) *SetCdnDomainStagingConfigResponseBodyDomainConfigList {
	s.FunctionName = &v
	return s
}

type SetCdnDomainStagingConfigResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetCdnDomainStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetCdnDomainStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCdnDomainStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *SetCdnDomainStagingConfigResponse) SetHeaders(v map[string]*string) *SetCdnDomainStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *SetCdnDomainStagingConfigResponse) SetStatusCode(v int32) *SetCdnDomainStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCdnDomainStagingConfigResponse) SetBody(v *SetCdnDomainStagingConfigResponseBody) *SetCdnDomainStagingConfigResponse {
	s.Body = v
	return s
}

type SetDomainServerCertificateRequest struct {
	// The name of the SSL certificate. You can specify only one name.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The type of the certificate. Valid values:
	//
	// *   **upload**: a user-uploaded SSL certificate.
	// *   **cas**: a certificate that is purchased from Alibaba Cloud SSL Certificates Service.
	//
	// > If this parameter is set to **cas**, the **PrivateKey** parameter is optional.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The accelerated domain name for which you want to configure the SSL certificate. The type of request supported by the domain name must be HTTPS.
	//
	// You can specify one domain name in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// Specifies whether to check the certificate name for duplicates. If you set the value to 1, the system does not perform the check and overwrites the information about the existing certificate that uses the same name.
	ForceSet *string `json:"ForceSet,omitempty" xml:"ForceSet,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The private key. Specify the private key only if you want to enable the SSL certificate.
	PrivateKey    *string `json:"PrivateKey,omitempty" xml:"PrivateKey,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The content of the SSL certificate. Specify the content of the SSL certificate only if you want to enable the SSL certificate. You can use one of the following methods to obtain the content of the SSL certificate:
	//
	// *   Method 1: Call the [DescribeDomainCertificateInfo](~~91182~~) API operation to query the information about the SSL certificate corresponding to the accelerated domain name and obtain the public key of the ServerCertificate certificate from the returned data.
	// *   Method 2: Call the [DescribeCdnCertificateList](~~91181~~) API operation to query the SSL certificate list corresponding to the accelerated domain name, and obtain the value of CertName from the returned data. Then, Call the [DescribeCdnCertificateDetail](~~131905~~) API operation with CertName as a parameter to obtain the details about the certificate, and obtain the public key of the Cert certificate from the returned data.
	ServerCertificate *string `json:"ServerCertificate,omitempty" xml:"ServerCertificate,omitempty"`
	// Specifies whether to enable the SSL certificate. Default value: off. Valid values:
	//
	// *   **on** ：enables the SSL certificate.
	// *   **off**：disables the SSL certificate.
	ServerCertificateStatus *string `json:"ServerCertificateStatus,omitempty" xml:"ServerCertificateStatus,omitempty"`
}

func (s SetDomainServerCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDomainServerCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetDomainServerCertificateRequest) SetCertName(v string) *SetDomainServerCertificateRequest {
	s.CertName = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetCertType(v string) *SetDomainServerCertificateRequest {
	s.CertType = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetDomainName(v string) *SetDomainServerCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetForceSet(v string) *SetDomainServerCertificateRequest {
	s.ForceSet = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetOwnerId(v int64) *SetDomainServerCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetPrivateKey(v string) *SetDomainServerCertificateRequest {
	s.PrivateKey = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetSecurityToken(v string) *SetDomainServerCertificateRequest {
	s.SecurityToken = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetServerCertificate(v string) *SetDomainServerCertificateRequest {
	s.ServerCertificate = &v
	return s
}

func (s *SetDomainServerCertificateRequest) SetServerCertificateStatus(v string) *SetDomainServerCertificateRequest {
	s.ServerCertificateStatus = &v
	return s
}

type SetDomainServerCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDomainServerCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDomainServerCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetDomainServerCertificateResponseBody) SetRequestId(v string) *SetDomainServerCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetDomainServerCertificateResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDomainServerCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDomainServerCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDomainServerCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetDomainServerCertificateResponse) SetHeaders(v map[string]*string) *SetDomainServerCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetDomainServerCertificateResponse) SetStatusCode(v int32) *SetDomainServerCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDomainServerCertificateResponse) SetBody(v *SetDomainServerCertificateResponseBody) *SetDomainServerCertificateResponse {
	s.Body = v
	return s
}

type SetReqHeaderConfigRequest struct {
	// The ID of the configuration.
	ConfigId *int64 `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the custom header.
	Key           *string `json:"Key,omitempty" xml:"Key,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The value of the custom header.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SetReqHeaderConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s SetReqHeaderConfigRequest) GoString() string {
	return s.String()
}

func (s *SetReqHeaderConfigRequest) SetConfigId(v int64) *SetReqHeaderConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *SetReqHeaderConfigRequest) SetDomainName(v string) *SetReqHeaderConfigRequest {
	s.DomainName = &v
	return s
}

func (s *SetReqHeaderConfigRequest) SetKey(v string) *SetReqHeaderConfigRequest {
	s.Key = &v
	return s
}

func (s *SetReqHeaderConfigRequest) SetOwnerId(v int64) *SetReqHeaderConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *SetReqHeaderConfigRequest) SetSecurityToken(v string) *SetReqHeaderConfigRequest {
	s.SecurityToken = &v
	return s
}

func (s *SetReqHeaderConfigRequest) SetValue(v string) *SetReqHeaderConfigRequest {
	s.Value = &v
	return s
}

type SetReqHeaderConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetReqHeaderConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetReqHeaderConfigResponseBody) GoString() string {
	return s.String()
}

func (s *SetReqHeaderConfigResponseBody) SetRequestId(v string) *SetReqHeaderConfigResponseBody {
	s.RequestId = &v
	return s
}

type SetReqHeaderConfigResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetReqHeaderConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetReqHeaderConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s SetReqHeaderConfigResponse) GoString() string {
	return s.String()
}

func (s *SetReqHeaderConfigResponse) SetHeaders(v map[string]*string) *SetReqHeaderConfigResponse {
	s.Headers = v
	return s
}

func (s *SetReqHeaderConfigResponse) SetStatusCode(v int32) *SetReqHeaderConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *SetReqHeaderConfigResponse) SetBody(v *SetReqHeaderConfigResponseBody) *SetReqHeaderConfigResponse {
	s.Body = v
	return s
}

type SetWaitingRoomConfigRequest struct {
	// The percentage of requests that are allowed to be redirected to the origin server. Valid values: **0** to **100**.
	AllowPct *int32 `json:"AllowPct,omitempty" xml:"AllowPct,omitempty"`
	// The accelerated domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The length of waiting time to skip after an exit from the queue. Unit: seconds.
	GapTime *int32 `json:"GapTime,omitempty" xml:"GapTime,omitempty"`
	// The maximum length of waiting time in the queue. Unit: seconds.
	MaxTimeWait *int32 `json:"MaxTimeWait,omitempty" xml:"MaxTimeWait,omitempty"`
	// The regular expression that is used to match URI strings for which the virtual waiting room feature is enabled.
	WaitUri *string `json:"WaitUri,omitempty" xml:"WaitUri,omitempty"`
	// The URL of the waiting page.
	WaitUrl *string `json:"WaitUrl,omitempty" xml:"WaitUrl,omitempty"`
}

func (s SetWaitingRoomConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s SetWaitingRoomConfigRequest) GoString() string {
	return s.String()
}

func (s *SetWaitingRoomConfigRequest) SetAllowPct(v int32) *SetWaitingRoomConfigRequest {
	s.AllowPct = &v
	return s
}

func (s *SetWaitingRoomConfigRequest) SetDomainName(v string) *SetWaitingRoomConfigRequest {
	s.DomainName = &v
	return s
}

func (s *SetWaitingRoomConfigRequest) SetGapTime(v int32) *SetWaitingRoomConfigRequest {
	s.GapTime = &v
	return s
}

func (s *SetWaitingRoomConfigRequest) SetMaxTimeWait(v int32) *SetWaitingRoomConfigRequest {
	s.MaxTimeWait = &v
	return s
}

func (s *SetWaitingRoomConfigRequest) SetWaitUri(v string) *SetWaitingRoomConfigRequest {
	s.WaitUri = &v
	return s
}

func (s *SetWaitingRoomConfigRequest) SetWaitUrl(v string) *SetWaitingRoomConfigRequest {
	s.WaitUrl = &v
	return s
}

type SetWaitingRoomConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetWaitingRoomConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetWaitingRoomConfigResponseBody) GoString() string {
	return s.String()
}

func (s *SetWaitingRoomConfigResponseBody) SetRequestId(v string) *SetWaitingRoomConfigResponseBody {
	s.RequestId = &v
	return s
}

type SetWaitingRoomConfigResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetWaitingRoomConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetWaitingRoomConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s SetWaitingRoomConfigResponse) GoString() string {
	return s.String()
}

func (s *SetWaitingRoomConfigResponse) SetHeaders(v map[string]*string) *SetWaitingRoomConfigResponse {
	s.Headers = v
	return s
}

func (s *SetWaitingRoomConfigResponse) SetStatusCode(v int32) *SetWaitingRoomConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *SetWaitingRoomConfigResponse) SetBody(v *SetWaitingRoomConfigResponseBody) *SetWaitingRoomConfigResponse {
	s.Body = v
	return s
}

type StartCdnDomainRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s StartCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s StartCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *StartCdnDomainRequest) SetDomainName(v string) *StartCdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *StartCdnDomainRequest) SetOwnerId(v int64) *StartCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *StartCdnDomainRequest) SetSecurityToken(v string) *StartCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type StartCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *StartCdnDomainResponseBody) SetRequestId(v string) *StartCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type StartCdnDomainResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s StartCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *StartCdnDomainResponse) SetHeaders(v map[string]*string) *StartCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *StartCdnDomainResponse) SetStatusCode(v int32) *StartCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *StartCdnDomainResponse) SetBody(v *StartCdnDomainResponseBody) *StartCdnDomainResponse {
	s.Body = v
	return s
}

type StopCdnDomainRequest struct {
	// The accelerated domain name that you want to disable. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s StopCdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s StopCdnDomainRequest) GoString() string {
	return s.String()
}

func (s *StopCdnDomainRequest) SetDomainName(v string) *StopCdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *StopCdnDomainRequest) SetOwnerId(v int64) *StopCdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *StopCdnDomainRequest) SetSecurityToken(v string) *StopCdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type StopCdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopCdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopCdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *StopCdnDomainResponseBody) SetRequestId(v string) *StopCdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type StopCdnDomainResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopCdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopCdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s StopCdnDomainResponse) GoString() string {
	return s.String()
}

func (s *StopCdnDomainResponse) SetHeaders(v map[string]*string) *StopCdnDomainResponse {
	s.Headers = v
	return s
}

func (s *StopCdnDomainResponse) SetStatusCode(v int32) *StopCdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *StopCdnDomainResponse) SetBody(v *StopCdnDomainResponseBody) *StopCdnDomainResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The list of resource IDs. Maximum number of list elements: 50.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource. Set this value to **DOMAIN**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags. Maximum number of list elements: 20.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The key of a tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of a tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to remove all tags. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no.
	//
	// Default value: **false**.
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The list of resource IDs. You can specify up to 50 resource IDs in the list.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resources from which you want to remove tags. Set this parameter to **DOMAIN**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tag keys. You can specify up to 20 tag keys in the list.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateCdnDeliverTaskRequest struct {
	// The method that is used to send operations reports. Operations reports are sent to you only by email. The settings must be escaped in JSON.
	Deliver *string `json:"Deliver,omitempty" xml:"Deliver,omitempty"`
	// The ID of the tracking task that you want to update.
	DeliverId *int64 `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
	// The domain name that you want to track. You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,). If you do not specify a domain name, the task collects data from all domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the tracking task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The operations reports that are tracked by the task. The data must be escaped in JSON.
	Reports *string `json:"Reports,omitempty" xml:"Reports,omitempty"`
	// The parameters that specify the time interval at which the tracking task sends operations reports. The settings must be escaped in JSON.
	Schedule *string `json:"Schedule,omitempty" xml:"Schedule,omitempty"`
}

func (s UpdateCdnDeliverTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCdnDeliverTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateCdnDeliverTaskRequest) SetDeliver(v string) *UpdateCdnDeliverTaskRequest {
	s.Deliver = &v
	return s
}

func (s *UpdateCdnDeliverTaskRequest) SetDeliverId(v int64) *UpdateCdnDeliverTaskRequest {
	s.DeliverId = &v
	return s
}

func (s *UpdateCdnDeliverTaskRequest) SetDomainName(v string) *UpdateCdnDeliverTaskRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateCdnDeliverTaskRequest) SetName(v string) *UpdateCdnDeliverTaskRequest {
	s.Name = &v
	return s
}

func (s *UpdateCdnDeliverTaskRequest) SetReports(v string) *UpdateCdnDeliverTaskRequest {
	s.Reports = &v
	return s
}

func (s *UpdateCdnDeliverTaskRequest) SetSchedule(v string) *UpdateCdnDeliverTaskRequest {
	s.Schedule = &v
	return s
}

type UpdateCdnDeliverTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCdnDeliverTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCdnDeliverTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCdnDeliverTaskResponseBody) SetRequestId(v string) *UpdateCdnDeliverTaskResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCdnDeliverTaskResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCdnDeliverTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCdnDeliverTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCdnDeliverTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateCdnDeliverTaskResponse) SetHeaders(v map[string]*string) *UpdateCdnDeliverTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateCdnDeliverTaskResponse) SetStatusCode(v int32) *UpdateCdnDeliverTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCdnDeliverTaskResponse) SetBody(v *UpdateCdnDeliverTaskResponseBody) *UpdateCdnDeliverTaskResponse {
	s.Body = v
	return s
}

type UpdateCdnSubTaskRequest struct {
	// The domain name that you want to track. You can specify up to 500 domain names in each request. If you specify multiple domain names, separate them with commas (,). If you do not specify a domain name, operations reports are updated for all domain names in your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IDs of operations reports that you want to update. Separate IDs with commas (,).
	ReportIds *string `json:"ReportIds,omitempty" xml:"ReportIds,omitempty"`
	// The start time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s UpdateCdnSubTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCdnSubTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateCdnSubTaskRequest) SetDomainName(v string) *UpdateCdnSubTaskRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateCdnSubTaskRequest) SetEndTime(v string) *UpdateCdnSubTaskRequest {
	s.EndTime = &v
	return s
}

func (s *UpdateCdnSubTaskRequest) SetReportIds(v string) *UpdateCdnSubTaskRequest {
	s.ReportIds = &v
	return s
}

func (s *UpdateCdnSubTaskRequest) SetStartTime(v string) *UpdateCdnSubTaskRequest {
	s.StartTime = &v
	return s
}

type UpdateCdnSubTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCdnSubTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCdnSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCdnSubTaskResponseBody) SetRequestId(v string) *UpdateCdnSubTaskResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCdnSubTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCdnSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCdnSubTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCdnSubTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateCdnSubTaskResponse) SetHeaders(v map[string]*string) *UpdateCdnSubTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateCdnSubTaskResponse) SetStatusCode(v int32) *UpdateCdnSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCdnSubTaskResponse) SetBody(v *UpdateCdnSubTaskResponseBody) *UpdateCdnSubTaskResponse {
	s.Body = v
	return s
}

type UpdateFCTriggerRequest struct {
	// The feature trigger.
	FunctionARN *string `json:"FunctionARN,omitempty" xml:"FunctionARN,omitempty"`
	// The remarks.
	Notes *string `json:"Notes,omitempty" xml:"Notes,omitempty"`
	// The assigned RAM role.
	RoleARN *string `json:"RoleARN,omitempty" xml:"RoleARN,omitempty"`
	// The resources and filters for event listening.
	SourceARN *string `json:"SourceARN,omitempty" xml:"SourceARN,omitempty"`
	// The trigger that corresponds to the Function Compute service.
	TriggerARN *string `json:"TriggerARN,omitempty" xml:"TriggerARN,omitempty"`
}

func (s UpdateFCTriggerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateFCTriggerRequest) GoString() string {
	return s.String()
}

func (s *UpdateFCTriggerRequest) SetFunctionARN(v string) *UpdateFCTriggerRequest {
	s.FunctionARN = &v
	return s
}

func (s *UpdateFCTriggerRequest) SetNotes(v string) *UpdateFCTriggerRequest {
	s.Notes = &v
	return s
}

func (s *UpdateFCTriggerRequest) SetRoleARN(v string) *UpdateFCTriggerRequest {
	s.RoleARN = &v
	return s
}

func (s *UpdateFCTriggerRequest) SetSourceARN(v string) *UpdateFCTriggerRequest {
	s.SourceARN = &v
	return s
}

func (s *UpdateFCTriggerRequest) SetTriggerARN(v string) *UpdateFCTriggerRequest {
	s.TriggerARN = &v
	return s
}

type UpdateFCTriggerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateFCTriggerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateFCTriggerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateFCTriggerResponseBody) SetRequestId(v string) *UpdateFCTriggerResponseBody {
	s.RequestId = &v
	return s
}

type UpdateFCTriggerResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateFCTriggerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFCTriggerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateFCTriggerResponse) GoString() string {
	return s.String()
}

func (s *UpdateFCTriggerResponse) SetHeaders(v map[string]*string) *UpdateFCTriggerResponse {
	s.Headers = v
	return s
}

func (s *UpdateFCTriggerResponse) SetStatusCode(v int32) *UpdateFCTriggerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateFCTriggerResponse) SetBody(v *UpdateFCTriggerResponseBody) *UpdateFCTriggerResponse {
	s.Body = v
	return s
}

type VerifyDomainOwnerRequest struct {
	// The domain name of which you want to verify the ownership. You can specify only one domain name.
	DomainName         *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	GlobalResourcePlan *string `json:"GlobalResourcePlan,omitempty" xml:"GlobalResourcePlan,omitempty"`
	// The verification method. Valid values:
	//
	// *   **dnsCheck**: by DNS record
	// *   **fileCheck**: by verification file
	VerifyType *string `json:"VerifyType,omitempty" xml:"VerifyType,omitempty"`
}

func (s VerifyDomainOwnerRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyDomainOwnerRequest) GoString() string {
	return s.String()
}

func (s *VerifyDomainOwnerRequest) SetDomainName(v string) *VerifyDomainOwnerRequest {
	s.DomainName = &v
	return s
}

func (s *VerifyDomainOwnerRequest) SetGlobalResourcePlan(v string) *VerifyDomainOwnerRequest {
	s.GlobalResourcePlan = &v
	return s
}

func (s *VerifyDomainOwnerRequest) SetVerifyType(v string) *VerifyDomainOwnerRequest {
	s.VerifyType = &v
	return s
}

type VerifyDomainOwnerResponseBody struct {
	// The verification result.
	//
	// > This parameter is returned only if the operation fails.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyDomainOwnerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyDomainOwnerResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyDomainOwnerResponseBody) SetContent(v string) *VerifyDomainOwnerResponseBody {
	s.Content = &v
	return s
}

func (s *VerifyDomainOwnerResponseBody) SetRequestId(v string) *VerifyDomainOwnerResponseBody {
	s.RequestId = &v
	return s
}

type VerifyDomainOwnerResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyDomainOwnerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyDomainOwnerResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyDomainOwnerResponse) GoString() string {
	return s.String()
}

func (s *VerifyDomainOwnerResponse) SetHeaders(v map[string]*string) *VerifyDomainOwnerResponse {
	s.Headers = v
	return s
}

func (s *VerifyDomainOwnerResponse) SetStatusCode(v int32) *VerifyDomainOwnerResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyDomainOwnerResponse) SetBody(v *VerifyDomainOwnerResponseBody) *VerifyDomainOwnerResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("central")
	client.EndpointMap = map[string]*string{
		"ap-northeast-1": tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"ap-south-1":     tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"ap-southeast-1": tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"ap-southeast-2": tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"ap-southeast-3": tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"ap-southeast-5": tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"eu-central-1":   tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"eu-west-1":      tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"me-east-1":      tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"us-east-1":      tea.String("cdn.ap-southeast-1.aliyuncs.com"),
		"us-west-1":      tea.String("cdn.ap-southeast-1.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("cdn"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You must activate Alibaba Cloud CDN before you can add a domain name to it. For more information, see [Activate Alibaba Cloud CDN](~~27272~~).
 * *   The domain name that you want to add has a valid Internet Content Provider (ICP) number.
 * *   You can add only one domain name to Alibaba Cloud CDN in each call. Each Alibaba Cloud account can add a maximum of 50 domain names to Alibaba Cloud CDN.
 * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review will be completed by the end of the next business day after you submit the application.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request AddCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCdnDomainResponse
 */
func (client *Client) AddCdnDomainWithOptions(request *AddCdnDomainRequest, runtime *util.RuntimeOptions) (_result *AddCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdnType)) {
		query["CdnType"] = request.CdnType
	}

	if !tea.BoolValue(util.IsUnset(request.CheckUrl)) {
		query["CheckUrl"] = request.CheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You must activate Alibaba Cloud CDN before you can add a domain name to it. For more information, see [Activate Alibaba Cloud CDN](~~27272~~).
 * *   The domain name that you want to add has a valid Internet Content Provider (ICP) number.
 * *   You can add only one domain name to Alibaba Cloud CDN in each call. Each Alibaba Cloud account can add a maximum of 50 domain names to Alibaba Cloud CDN.
 * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review will be completed by the end of the next business day after you submit the application.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request AddCdnDomainRequest
 * @return AddCdnDomainResponse
 */
func (client *Client) AddCdnDomain(request *AddCdnDomainRequest) (_result *AddCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddCdnDomainResponse{}
	_body, _err := client.AddCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddFCTriggerWithOptions(request *AddFCTriggerRequest, runtime *util.RuntimeOptions) (_result *AddFCTriggerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TriggerARN)) {
		query["TriggerARN"] = request.TriggerARN
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventMetaName)) {
		body["EventMetaName"] = request.EventMetaName
	}

	if !tea.BoolValue(util.IsUnset(request.EventMetaVersion)) {
		body["EventMetaVersion"] = request.EventMetaVersion
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionARN)) {
		body["FunctionARN"] = request.FunctionARN
	}

	if !tea.BoolValue(util.IsUnset(request.Notes)) {
		body["Notes"] = request.Notes
	}

	if !tea.BoolValue(util.IsUnset(request.RoleARN)) {
		body["RoleARN"] = request.RoleARN
	}

	if !tea.BoolValue(util.IsUnset(request.SourceARN)) {
		body["SourceARN"] = request.SourceARN
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AddFCTrigger"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddFCTriggerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddFCTrigger(request *AddFCTriggerRequest) (_result *AddFCTriggerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddFCTriggerResponse{}
	_body, _err := client.AddFCTriggerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You must activate Alibaba Cloud CDN before you can add a domain name to it. For more information, see [Activate Alibaba Cloud CDN](~~27272~~).
 * *   If the acceleration region is Chinese Mainland Only or Global, you must apply for an ICP filing for the domain name.
 * *   You can specify multiple domain names and separate them with commas (,). You can specify at most 50 domain names in each call.
 * *   For more information, see [Add a domain name](~~122181~~).
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchAddCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddCdnDomainResponse
 */
func (client *Client) BatchAddCdnDomainWithOptions(request *BatchAddCdnDomainRequest, runtime *util.RuntimeOptions) (_result *BatchAddCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdnType)) {
		query["CdnType"] = request.CdnType
	}

	if !tea.BoolValue(util.IsUnset(request.CheckUrl)) {
		query["CheckUrl"] = request.CheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchAddCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchAddCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You must activate Alibaba Cloud CDN before you can add a domain name to it. For more information, see [Activate Alibaba Cloud CDN](~~27272~~).
 * *   If the acceleration region is Chinese Mainland Only or Global, you must apply for an ICP filing for the domain name.
 * *   You can specify multiple domain names and separate them with commas (,). You can specify at most 50 domain names in each call.
 * *   For more information, see [Add a domain name](~~122181~~).
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchAddCdnDomainRequest
 * @return BatchAddCdnDomainResponse
 */
func (client *Client) BatchAddCdnDomain(request *BatchAddCdnDomainRequest) (_result *BatchAddCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchAddCdnDomainResponse{}
	_body, _err := client.BatchAddCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can specify up to 50 domain names in each request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchDeleteCdnDomainConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteCdnDomainConfigResponse
 */
func (client *Client) BatchDeleteCdnDomainConfigWithOptions(request *BatchDeleteCdnDomainConfigRequest, runtime *util.RuntimeOptions) (_result *BatchDeleteCdnDomainConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchDeleteCdnDomainConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchDeleteCdnDomainConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can specify up to 50 domain names in each request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchDeleteCdnDomainConfigRequest
 * @return BatchDeleteCdnDomainConfigResponse
 */
func (client *Client) BatchDeleteCdnDomainConfig(request *BatchDeleteCdnDomainConfigRequest) (_result *BatchDeleteCdnDomainConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchDeleteCdnDomainConfigResponse{}
	_body, _err := client.BatchDeleteCdnDomainConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify multiple domain names and must separate them with commas (,). You can specify up to 50 domain names in each call.
 * *   If the BatchSetCdnDomainConfig operation is successful, a unique configuration ID (ConfigId) is generated. You can use configuration IDs to update or delete configurations. For more information, see [Usage notes on ConfigId](~~388994~~).
 *
 * @param request BatchSetCdnDomainConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetCdnDomainConfigResponse
 */
func (client *Client) BatchSetCdnDomainConfigWithOptions(request *BatchSetCdnDomainConfigRequest, runtime *util.RuntimeOptions) (_result *BatchSetCdnDomainConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.Functions)) {
		query["Functions"] = request.Functions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetCdnDomainConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetCdnDomainConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify multiple domain names and must separate them with commas (,). You can specify up to 50 domain names in each call.
 * *   If the BatchSetCdnDomainConfig operation is successful, a unique configuration ID (ConfigId) is generated. You can use configuration IDs to update or delete configurations. For more information, see [Usage notes on ConfigId](~~388994~~).
 *
 * @param request BatchSetCdnDomainConfigRequest
 * @return BatchSetCdnDomainConfigResponse
 */
func (client *Client) BatchSetCdnDomainConfig(request *BatchSetCdnDomainConfigRequest) (_result *BatchSetCdnDomainConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetCdnDomainConfigResponse{}
	_body, _err := client.BatchSetCdnDomainConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   You can specify up to 10 domain names in each request. Separate multiple domain names with commas (,)
 *
 * @param request BatchSetCdnDomainServerCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetCdnDomainServerCertificateResponse
 */
func (client *Client) BatchSetCdnDomainServerCertificateWithOptions(request *BatchSetCdnDomainServerCertificateRequest, runtime *util.RuntimeOptions) (_result *BatchSetCdnDomainServerCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertType)) {
		query["CertType"] = request.CertType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ForceSet)) {
		query["ForceSet"] = request.ForceSet
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetCdnDomainServerCertificate"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetCdnDomainServerCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   You can specify up to 10 domain names in each request. Separate multiple domain names with commas (,)
 *
 * @param request BatchSetCdnDomainServerCertificateRequest
 * @return BatchSetCdnDomainServerCertificateResponse
 */
func (client *Client) BatchSetCdnDomainServerCertificate(request *BatchSetCdnDomainServerCertificateRequest) (_result *BatchSetCdnDomainServerCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetCdnDomainServerCertificateResponse{}
	_body, _err := client.BatchSetCdnDomainServerCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If a domain name specified in the request is in an invalid state or your account has an overdue payment, the domain name cannot be enabled.
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify up to 50 domain names in each request.
 *
 * @param request BatchStartCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchStartCdnDomainResponse
 */
func (client *Client) BatchStartCdnDomainWithOptions(request *BatchStartCdnDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStartCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStartCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchStartCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If a domain name specified in the request is in an invalid state or your account has an overdue payment, the domain name cannot be enabled.
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify up to 50 domain names in each request.
 *
 * @param request BatchStartCdnDomainRequest
 * @return BatchStartCdnDomainResponse
 */
func (client *Client) BatchStartCdnDomain(request *BatchStartCdnDomainRequest) (_result *BatchStartCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStartCdnDomainResponse{}
	_body, _err := client.BatchStartCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After an accelerated domain name is disabled, Alibaba Cloud CDN retains its information and reroutes all the requests that are destined for the accelerated domain name to the origin.
 * *   If you need to temporarily disable CDN acceleration for a domain name, we recommend that you call the StopDomain operation.
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify up to 50 domain names in each request.
 *
 * @param request BatchStopCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchStopCdnDomainResponse
 */
func (client *Client) BatchStopCdnDomainWithOptions(request *BatchStopCdnDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStopCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStopCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchStopCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After an accelerated domain name is disabled, Alibaba Cloud CDN retains its information and reroutes all the requests that are destined for the accelerated domain name to the origin.
 * *   If you need to temporarily disable CDN acceleration for a domain name, we recommend that you call the StopDomain operation.
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify up to 50 domain names in each request.
 *
 * @param request BatchStopCdnDomainRequest
 * @return BatchStopCdnDomainResponse
 */
func (client *Client) BatchStopCdnDomain(request *BatchStopCdnDomainRequest) (_result *BatchStopCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStopCdnDomainResponse{}
	_body, _err := client.BatchStopCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify up to 50 domain names in each request. Separate multiple domain names with commas (,).
 *
 * @param request BatchUpdateCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateCdnDomainResponse
 */
func (client *Client) BatchUpdateCdnDomainWithOptions(request *BatchUpdateCdnDomainRequest, runtime *util.RuntimeOptions) (_result *BatchUpdateCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchUpdateCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchUpdateCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 * *   You can specify up to 50 domain names in each request. Separate multiple domain names with commas (,).
 *
 * @param request BatchUpdateCdnDomainRequest
 * @return BatchUpdateCdnDomainResponse
 */
func (client *Client) BatchUpdateCdnDomain(request *BatchUpdateCdnDomainRequest) (_result *BatchUpdateCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchUpdateCdnDomainResponse{}
	_body, _err := client.BatchUpdateCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request CreateCdnCertificateSigningRequestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCdnCertificateSigningRequestResponse
 */
func (client *Client) CreateCdnCertificateSigningRequestWithOptions(request *CreateCdnCertificateSigningRequestRequest, runtime *util.RuntimeOptions) (_result *CreateCdnCertificateSigningRequestResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.City)) {
		query["City"] = request.City
	}

	if !tea.BoolValue(util.IsUnset(request.CommonName)) {
		query["CommonName"] = request.CommonName
	}

	if !tea.BoolValue(util.IsUnset(request.Country)) {
		query["Country"] = request.Country
	}

	if !tea.BoolValue(util.IsUnset(request.Email)) {
		query["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.Organization)) {
		query["Organization"] = request.Organization
	}

	if !tea.BoolValue(util.IsUnset(request.OrganizationUnit)) {
		query["OrganizationUnit"] = request.OrganizationUnit
	}

	if !tea.BoolValue(util.IsUnset(request.SANs)) {
		query["SANs"] = request.SANs
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCdnCertificateSigningRequest"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCdnCertificateSigningRequestResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request CreateCdnCertificateSigningRequestRequest
 * @return CreateCdnCertificateSigningRequestResponse
 */
func (client *Client) CreateCdnCertificateSigningRequest(request *CreateCdnCertificateSigningRequestRequest) (_result *CreateCdnCertificateSigningRequestResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCdnCertificateSigningRequestResponse{}
	_body, _err := client.CreateCdnCertificateSigningRequestWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request CreateCdnDeliverTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCdnDeliverTaskResponse
 */
func (client *Client) CreateCdnDeliverTaskWithOptions(request *CreateCdnDeliverTaskRequest, runtime *util.RuntimeOptions) (_result *CreateCdnDeliverTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Deliver)) {
		body["Deliver"] = request.Deliver
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Reports)) {
		body["Reports"] = request.Reports
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["Schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCdnDeliverTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCdnDeliverTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request CreateCdnDeliverTaskRequest
 * @return CreateCdnDeliverTaskResponse
 */
func (client *Client) CreateCdnDeliverTask(request *CreateCdnDeliverTaskRequest) (_result *CreateCdnDeliverTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCdnDeliverTaskResponse{}
	_body, _err := client.CreateCdnDeliverTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation allows you to create a custom operations report for a specific domain name. You can view the statistics about the domain name in the report.
 * *   You can call this operation up to three times per second per account.
 *
 * @param request CreateCdnSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCdnSubTaskResponse
 */
func (client *Client) CreateCdnSubTaskWithOptions(request *CreateCdnSubTaskRequest, runtime *util.RuntimeOptions) (_result *CreateCdnSubTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ReportIds)) {
		body["ReportIds"] = request.ReportIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCdnSubTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCdnSubTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation allows you to create a custom operations report for a specific domain name. You can view the statistics about the domain name in the report.
 * *   You can call this operation up to three times per second per account.
 *
 * @param request CreateCdnSubTaskRequest
 * @return CreateCdnSubTaskResponse
 */
func (client *Client) CreateCdnSubTask(request *CreateCdnSubTaskRequest) (_result *CreateCdnSubTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCdnSubTaskResponse{}
	_body, _err := client.CreateCdnSubTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this API operation up to 100 times per second per account.
 *
 * @param request CreateRealTimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRealTimeLogDeliveryResponse
 */
func (client *Client) CreateRealTimeLogDeliveryWithOptions(request *CreateRealTimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *CreateRealTimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRealTimeLogDelivery"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRealTimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this API operation up to 100 times per second per account.
 *
 * @param request CreateRealTimeLogDeliveryRequest
 * @return CreateRealTimeLogDeliveryResponse
 */
func (client *Client) CreateRealTimeLogDelivery(request *CreateRealTimeLogDeliveryRequest) (_result *CreateRealTimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRealTimeLogDeliveryResponse{}
	_body, _err := client.CreateRealTimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can create a task to query data in the last year. The maximum time range that can be queried is one month.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request CreateUsageDetailDataExportTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUsageDetailDataExportTaskResponse
 */
func (client *Client) CreateUsageDetailDataExportTaskWithOptions(request *CreateUsageDetailDataExportTaskRequest, runtime *util.RuntimeOptions) (_result *CreateUsageDetailDataExportTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["Group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUsageDetailDataExportTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUsageDetailDataExportTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can create a task to query data in the last year. The maximum time range that can be queried is one month.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request CreateUsageDetailDataExportTaskRequest
 * @return CreateUsageDetailDataExportTaskResponse
 */
func (client *Client) CreateUsageDetailDataExportTask(request *CreateUsageDetailDataExportTaskRequest) (_result *CreateUsageDetailDataExportTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUsageDetailDataExportTaskResponse{}
	_body, _err := client.CreateUsageDetailDataExportTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can create a task to query data in the last year. The maximum time range that can be queried is one month.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request CreateUserUsageDataExportTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUserUsageDataExportTaskResponse
 */
func (client *Client) CreateUserUsageDataExportTaskWithOptions(request *CreateUserUsageDataExportTaskRequest, runtime *util.RuntimeOptions) (_result *CreateUserUsageDataExportTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUserUsageDataExportTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUserUsageDataExportTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can create a task to query data in the last year. The maximum time range that can be queried is one month.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request CreateUserUsageDataExportTaskRequest
 * @return CreateUserUsageDataExportTaskResponse
 */
func (client *Client) CreateUserUsageDataExportTask(request *CreateUserUsageDataExportTaskRequest) (_result *CreateUserUsageDataExportTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUserUsageDataExportTaskResponse{}
	_body, _err := client.CreateUserUsageDataExportTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DeleteCdnDeliverTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCdnDeliverTaskResponse
 */
func (client *Client) DeleteCdnDeliverTaskWithOptions(request *DeleteCdnDeliverTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteCdnDeliverTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeliverId)) {
		query["DeliverId"] = request.DeliverId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCdnDeliverTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCdnDeliverTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DeleteCdnDeliverTaskRequest
 * @return DeleteCdnDeliverTaskResponse
 */
func (client *Client) DeleteCdnDeliverTask(request *DeleteCdnDeliverTaskRequest) (_result *DeleteCdnDeliverTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCdnDeliverTaskResponse{}
	_body, _err := client.DeleteCdnDeliverTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   We recommend that you add an A record for the domain name in the system of your DNS service provider before you remove the domain name from Alibaba Cloud CDN. Otherwise, the domain name may become inaccessible. Proceed with caution.
 * *   After you successfully call the DeleteCdnDomain operation, all records of the removed domain name are deleted. If you need to only disable the domain name, we recommend that you call the StopCdnDomain operation.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCdnDomainResponse
 */
func (client *Client) DeleteCdnDomainWithOptions(request *DeleteCdnDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   We recommend that you add an A record for the domain name in the system of your DNS service provider before you remove the domain name from Alibaba Cloud CDN. Otherwise, the domain name may become inaccessible. Proceed with caution.
 * *   After you successfully call the DeleteCdnDomain operation, all records of the removed domain name are deleted. If you need to only disable the domain name, we recommend that you call the StopCdnDomain operation.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteCdnDomainRequest
 * @return DeleteCdnDomainResponse
 */
func (client *Client) DeleteCdnDomain(request *DeleteCdnDomainRequest) (_result *DeleteCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCdnDomainResponse{}
	_body, _err := client.DeleteCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this API operation up to three times per second per account.
 *
 * @param request DeleteCdnSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCdnSubTaskResponse
 */
func (client *Client) DeleteCdnSubTaskWithOptions(runtime *util.RuntimeOptions) (_result *DeleteCdnSubTaskResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DeleteCdnSubTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCdnSubTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this API operation up to three times per second per account.
 *
 * @return DeleteCdnSubTaskResponse
 */
func (client *Client) DeleteCdnSubTask() (_result *DeleteCdnSubTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCdnSubTaskResponse{}
	_body, _err := client.DeleteCdnSubTaskWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteFCTriggerWithOptions(request *DeleteFCTriggerRequest, runtime *util.RuntimeOptions) (_result *DeleteFCTriggerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TriggerARN)) {
		query["TriggerARN"] = request.TriggerARN
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFCTrigger"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFCTriggerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteFCTrigger(request *DeleteFCTriggerRequest) (_result *DeleteFCTriggerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFCTriggerResponse{}
	_body, _err := client.DeleteFCTriggerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRealTimeLogLogstoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRealTimeLogLogstoreResponse
 */
func (client *Client) DeleteRealTimeLogLogstoreWithOptions(request *DeleteRealTimeLogLogstoreRequest, runtime *util.RuntimeOptions) (_result *DeleteRealTimeLogLogstoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRealTimeLogLogstore"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRealTimeLogLogstoreResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRealTimeLogLogstoreRequest
 * @return DeleteRealTimeLogLogstoreResponse
 */
func (client *Client) DeleteRealTimeLogLogstore(request *DeleteRealTimeLogLogstoreRequest) (_result *DeleteRealTimeLogLogstoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRealTimeLogLogstoreResponse{}
	_body, _err := client.DeleteRealTimeLogLogstoreWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRealtimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRealtimeLogDeliveryResponse
 */
func (client *Client) DeleteRealtimeLogDeliveryWithOptions(request *DeleteRealtimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *DeleteRealtimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRealtimeLogDelivery"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRealtimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRealtimeLogDeliveryRequest
 * @return DeleteRealtimeLogDeliveryResponse
 */
func (client *Client) DeleteRealtimeLogDelivery(request *DeleteRealtimeLogDeliveryRequest) (_result *DeleteRealtimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRealtimeLogDeliveryResponse{}
	_body, _err := client.DeleteRealtimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DeleteSpecificConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSpecificConfigResponse
 */
func (client *Client) DeleteSpecificConfigWithOptions(request *DeleteSpecificConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteSpecificConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSpecificConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSpecificConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DeleteSpecificConfigRequest
 * @return DeleteSpecificConfigResponse
 */
func (client *Client) DeleteSpecificConfig(request *DeleteSpecificConfigRequest) (_result *DeleteSpecificConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSpecificConfigResponse{}
	_body, _err := client.DeleteSpecificConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DeleteSpecificStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSpecificStagingConfigResponse
 */
func (client *Client) DeleteSpecificStagingConfigWithOptions(request *DeleteSpecificStagingConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteSpecificStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSpecificStagingConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSpecificStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DeleteSpecificStagingConfigRequest
 * @return DeleteSpecificStagingConfigResponse
 */
func (client *Client) DeleteSpecificStagingConfig(request *DeleteSpecificStagingConfigRequest) (_result *DeleteSpecificStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSpecificStagingConfigResponse{}
	_body, _err := client.DeleteSpecificStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteUsageDetailDataExportTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUsageDetailDataExportTaskResponse
 */
func (client *Client) DeleteUsageDetailDataExportTaskWithOptions(request *DeleteUsageDetailDataExportTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteUsageDetailDataExportTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteUsageDetailDataExportTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteUsageDetailDataExportTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteUsageDetailDataExportTaskRequest
 * @return DeleteUsageDetailDataExportTaskResponse
 */
func (client *Client) DeleteUsageDetailDataExportTask(request *DeleteUsageDetailDataExportTaskRequest) (_result *DeleteUsageDetailDataExportTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteUsageDetailDataExportTaskResponse{}
	_body, _err := client.DeleteUsageDetailDataExportTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteUserUsageDataExportTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUserUsageDataExportTaskResponse
 */
func (client *Client) DeleteUserUsageDataExportTaskWithOptions(request *DeleteUserUsageDataExportTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteUserUsageDataExportTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteUserUsageDataExportTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteUserUsageDataExportTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteUserUsageDataExportTaskRequest
 * @return DeleteUserUsageDataExportTaskResponse
 */
func (client *Client) DeleteUserUsageDataExportTask(request *DeleteUserUsageDataExportTaskRequest) (_result *DeleteUserUsageDataExportTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteUserUsageDataExportTaskResponse{}
	_body, _err := client.DeleteUserUsageDataExportTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeBlockedRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockedRegionsResponse
 */
func (client *Client) DescribeBlockedRegionsWithOptions(request *DescribeBlockedRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeBlockedRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBlockedRegions"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBlockedRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeBlockedRegionsRequest
 * @return DescribeBlockedRegionsResponse
 */
func (client *Client) DescribeBlockedRegions(request *DescribeBlockedRegionsRequest) (_result *DescribeBlockedRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBlockedRegionsResponse{}
	_body, _err := client.DescribeBlockedRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeCdnCertificateDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnCertificateDetailResponse
 */
func (client *Client) DescribeCdnCertificateDetailWithOptions(request *DescribeCdnCertificateDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnCertificateDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnCertificateDetail"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnCertificateDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeCdnCertificateDetailRequest
 * @return DescribeCdnCertificateDetailResponse
 */
func (client *Client) DescribeCdnCertificateDetail(request *DescribeCdnCertificateDetailRequest) (_result *DescribeCdnCertificateDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnCertificateDetailResponse{}
	_body, _err := client.DescribeCdnCertificateDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnCertificateListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnCertificateListResponse
 */
func (client *Client) DescribeCdnCertificateListWithOptions(request *DescribeCdnCertificateListRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnCertificateListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnCertificateList"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnCertificateListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnCertificateListRequest
 * @return DescribeCdnCertificateListResponse
 */
func (client *Client) DescribeCdnCertificateList(request *DescribeCdnCertificateListRequest) (_result *DescribeCdnCertificateListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnCertificateListResponse{}
	_body, _err := client.DescribeCdnCertificateListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeCdnDeletedDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnDeletedDomainsResponse
 */
func (client *Client) DescribeCdnDeletedDomainsWithOptions(request *DescribeCdnDeletedDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnDeletedDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnDeletedDomains"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnDeletedDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeCdnDeletedDomainsRequest
 * @return DescribeCdnDeletedDomainsResponse
 */
func (client *Client) DescribeCdnDeletedDomains(request *DescribeCdnDeletedDomainsRequest) (_result *DescribeCdnDeletedDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnDeletedDomainsResponse{}
	_body, _err := client.DescribeCdnDeletedDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 3 times per second per account.
 *
 * @param request DescribeCdnDeliverListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnDeliverListResponse
 */
func (client *Client) DescribeCdnDeliverListWithOptions(request *DescribeCdnDeliverListRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnDeliverListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeliverId)) {
		query["DeliverId"] = request.DeliverId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnDeliverList"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnDeliverListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 3 times per second per account.
 *
 * @param request DescribeCdnDeliverListRequest
 * @return DescribeCdnDeliverListResponse
 */
func (client *Client) DescribeCdnDeliverList(request *DescribeCdnDeliverListRequest) (_result *DescribeCdnDeliverListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnDeliverListResponse{}
	_body, _err := client.DescribeCdnDeliverListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnDomainByCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnDomainByCertificateResponse
 */
func (client *Client) DescribeCdnDomainByCertificateWithOptions(request *DescribeCdnDomainByCertificateRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnDomainByCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SSLStatus)) {
		query["SSLStatus"] = request.SSLStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnDomainByCertificate"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnDomainByCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnDomainByCertificateRequest
 * @return DescribeCdnDomainByCertificateResponse
 */
func (client *Client) DescribeCdnDomainByCertificate(request *DescribeCdnDomainByCertificateRequest) (_result *DescribeCdnDomainByCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnDomainByCertificateResponse{}
	_body, _err := client.DescribeCdnDomainByCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnDomainConfigsResponse
 */
func (client *Client) DescribeCdnDomainConfigsWithOptions(request *DescribeCdnDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnDomainConfigs"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnDomainConfigsRequest
 * @return DescribeCdnDomainConfigsResponse
 */
func (client *Client) DescribeCdnDomainConfigs(request *DescribeCdnDomainConfigsRequest) (_result *DescribeCdnDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnDomainConfigsResponse{}
	_body, _err := client.DescribeCdnDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnDomainDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnDomainDetailResponse
 */
func (client *Client) DescribeCdnDomainDetailWithOptions(request *DescribeCdnDomainDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnDomainDetail"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnDomainDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnDomainDetailRequest
 * @return DescribeCdnDomainDetailResponse
 */
func (client *Client) DescribeCdnDomainDetail(request *DescribeCdnDomainDetailRequest) (_result *DescribeCdnDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnDomainDetailResponse{}
	_body, _err := client.DescribeCdnDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set **StartTime** or **EndTime**, the request returns the data collected in the last 24 hours. If you set both **StartTime** and **EndTime**, the request returns the data collected within the specified time range.
 * *   The log data is collected every hour.
 * *   You can call this operation up to 100 times per second per account.
 * *   You can query only logs in the last month. The start time and the current time cannot exceed 31 days.
 *
 * @param request DescribeCdnDomainLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnDomainLogsResponse
 */
func (client *Client) DescribeCdnDomainLogsWithOptions(request *DescribeCdnDomainLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnDomainLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnDomainLogs"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnDomainLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set **StartTime** or **EndTime**, the request returns the data collected in the last 24 hours. If you set both **StartTime** and **EndTime**, the request returns the data collected within the specified time range.
 * *   The log data is collected every hour.
 * *   You can call this operation up to 100 times per second per account.
 * *   You can query only logs in the last month. The start time and the current time cannot exceed 31 days.
 *
 * @param request DescribeCdnDomainLogsRequest
 * @return DescribeCdnDomainLogsResponse
 */
func (client *Client) DescribeCdnDomainLogs(request *DescribeCdnDomainLogsRequest) (_result *DescribeCdnDomainLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnDomainLogsResponse{}
	_body, _err := client.DescribeCdnDomainLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnDomainStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnDomainStagingConfigResponse
 */
func (client *Client) DescribeCdnDomainStagingConfigWithOptions(request *DescribeCdnDomainStagingConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnDomainStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnDomainStagingConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnDomainStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnDomainStagingConfigRequest
 * @return DescribeCdnDomainStagingConfigResponse
 */
func (client *Client) DescribeCdnDomainStagingConfig(request *DescribeCdnDomainStagingConfigRequest) (_result *DescribeCdnDomainStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnDomainStagingConfigResponse{}
	_body, _err := client.DescribeCdnDomainStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnHttpsDomainListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnHttpsDomainListResponse
 */
func (client *Client) DescribeCdnHttpsDomainListWithOptions(request *DescribeCdnHttpsDomainListRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnHttpsDomainListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnHttpsDomainList"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnHttpsDomainListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnHttpsDomainListRequest
 * @return DescribeCdnHttpsDomainListResponse
 */
func (client *Client) DescribeCdnHttpsDomainList(request *DescribeCdnHttpsDomainListRequest) (_result *DescribeCdnHttpsDomainListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnHttpsDomainListResponse{}
	_body, _err := client.DescribeCdnHttpsDomainListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCdnOrderCommodityCodeWithOptions(request *DescribeCdnOrderCommodityCodeRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnOrderCommodityCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnOrderCommodityCode"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnOrderCommodityCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCdnOrderCommodityCode(request *DescribeCdnOrderCommodityCodeRequest) (_result *DescribeCdnOrderCommodityCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnOrderCommodityCodeResponse{}
	_body, _err := client.DescribeCdnOrderCommodityCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The lists of ISPs and regions that are supported by Alibaba Cloud CDN are updated and published on the Alibaba Cloud International site.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnRegionAndIspRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnRegionAndIspResponse
 */
func (client *Client) DescribeCdnRegionAndIspWithOptions(request *DescribeCdnRegionAndIspRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnRegionAndIspResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnRegionAndIsp"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnRegionAndIspResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The lists of ISPs and regions that are supported by Alibaba Cloud CDN are updated and published on the Alibaba Cloud International site.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnRegionAndIspRequest
 * @return DescribeCdnRegionAndIspResponse
 */
func (client *Client) DescribeCdnRegionAndIsp(request *DescribeCdnRegionAndIspRequest) (_result *DescribeCdnRegionAndIspResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnRegionAndIspResponse{}
	_body, _err := client.DescribeCdnRegionAndIspWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DescribeCdnReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnReportResponse
 */
func (client *Client) DescribeCdnReportWithOptions(request *DescribeCdnReportRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.HttpCode)) {
		query["HttpCode"] = request.HttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.IsOverseas)) {
		query["IsOverseas"] = request.IsOverseas
	}

	if !tea.BoolValue(util.IsUnset(request.ReportId)) {
		query["ReportId"] = request.ReportId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnReport"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DescribeCdnReportRequest
 * @return DescribeCdnReportResponse
 */
func (client *Client) DescribeCdnReport(request *DescribeCdnReportRequest) (_result *DescribeCdnReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnReportResponse{}
	_body, _err := client.DescribeCdnReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
 * *   You can call this operation up to three times per second per account.
 *
 * @param request DescribeCdnReportListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnReportListResponse
 */
func (client *Client) DescribeCdnReportListWithOptions(request *DescribeCdnReportListRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnReportListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ReportId)) {
		query["ReportId"] = request.ReportId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnReportList"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnReportListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
 * *   You can call this operation up to three times per second per account.
 *
 * @param request DescribeCdnReportListRequest
 * @return DescribeCdnReportListResponse
 */
func (client *Client) DescribeCdnReportList(request *DescribeCdnReportListRequest) (_result *DescribeCdnReportListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnReportListResponse{}
	_body, _err := client.DescribeCdnReportListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeCdnSMCertificateDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnSMCertificateDetailResponse
 */
func (client *Client) DescribeCdnSMCertificateDetailWithOptions(request *DescribeCdnSMCertificateDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnSMCertificateDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnSMCertificateDetail"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnSMCertificateDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeCdnSMCertificateDetailRequest
 * @return DescribeCdnSMCertificateDetailResponse
 */
func (client *Client) DescribeCdnSMCertificateDetail(request *DescribeCdnSMCertificateDetailRequest) (_result *DescribeCdnSMCertificateDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnSMCertificateDetailResponse{}
	_body, _err := client.DescribeCdnSMCertificateDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnSMCertificateListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnSMCertificateListResponse
 */
func (client *Client) DescribeCdnSMCertificateListWithOptions(request *DescribeCdnSMCertificateListRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnSMCertificateListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnSMCertificateList"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnSMCertificateListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnSMCertificateListRequest
 * @return DescribeCdnSMCertificateListResponse
 */
func (client *Client) DescribeCdnSMCertificateList(request *DescribeCdnSMCertificateListRequest) (_result *DescribeCdnSMCertificateListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnSMCertificateListResponse{}
	_body, _err := client.DescribeCdnSMCertificateListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnServiceResponse
 */
func (client *Client) DescribeCdnServiceWithOptions(request *DescribeCdnServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnService"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnServiceRequest
 * @return DescribeCdnServiceResponse
 */
func (client *Client) DescribeCdnService(request *DescribeCdnServiceRequest) (_result *DescribeCdnServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnServiceResponse{}
	_body, _err := client.DescribeCdnServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   By default, this operation queries all custom operations reports. However, only one operations report can be displayed. Therefore, only one operations report is returned.
 * *   You can call this operation up to three times per second per account.
 *
 * @param request DescribeCdnSubListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnSubListResponse
 */
func (client *Client) DescribeCdnSubListWithOptions(runtime *util.RuntimeOptions) (_result *DescribeCdnSubListResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnSubList"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnSubListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   By default, this operation queries all custom operations reports. However, only one operations report can be displayed. Therefore, only one operations report is returned.
 * *   You can call this operation up to three times per second per account.
 *
 * @return DescribeCdnSubListResponse
 */
func (client *Client) DescribeCdnSubList() (_result *DescribeCdnSubListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnSubListResponse{}
	_body, _err := client.DescribeCdnSubListWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can query billing history up to the last one month.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnUserBillHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnUserBillHistoryResponse
 */
func (client *Client) DescribeCdnUserBillHistoryWithOptions(request *DescribeCdnUserBillHistoryRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnUserBillHistoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnUserBillHistory"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnUserBillHistoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can query billing history up to the last one month.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnUserBillHistoryRequest
 * @return DescribeCdnUserBillHistoryResponse
 */
func (client *Client) DescribeCdnUserBillHistory(request *DescribeCdnUserBillHistoryRequest) (_result *DescribeCdnUserBillHistoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnUserBillHistoryResponse{}
	_body, _err := client.DescribeCdnUserBillHistoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The billable region. Valid values:
 * *   **CN**: the Chinese mainland
 * *   **OverSeas**: outside the Chinese mainland
 * *   **AP1**: Asia Pacific 1
 * *   **AP2**: Asia Pacific 2
 * *   **AP3**: Asia Pacific 3
 * *   **NA**: North America
 * *   **SA**: South America
 * *   **EU**: Europe
 * *   **MEAA**: Middle East and Africa
 * By default, the value of this parameter is determined by the metering method that is currently used. Regions inside and outside the Chinese mainland are classified into the **CN** and **OverSeas** billable regions. Billable regions inside the Chinese mainland include **CN**. Billable regions outside the Chinese mainland include **AP1**, **AP2**, **AP3**, **NA**, **SA**, **EU**, and **MEAA**.
 * > For more information about billable regions, see [Billable regions](~~142221~~).
 *
 * @param request DescribeCdnUserBillPredictionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnUserBillPredictionResponse
 */
func (client *Client) DescribeCdnUserBillPredictionWithOptions(request *DescribeCdnUserBillPredictionRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnUserBillPredictionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.Dimension)) {
		query["Dimension"] = request.Dimension
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnUserBillPrediction"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnUserBillPredictionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The billable region. Valid values:
 * *   **CN**: the Chinese mainland
 * *   **OverSeas**: outside the Chinese mainland
 * *   **AP1**: Asia Pacific 1
 * *   **AP2**: Asia Pacific 2
 * *   **AP3**: Asia Pacific 3
 * *   **NA**: North America
 * *   **SA**: South America
 * *   **EU**: Europe
 * *   **MEAA**: Middle East and Africa
 * By default, the value of this parameter is determined by the metering method that is currently used. Regions inside and outside the Chinese mainland are classified into the **CN** and **OverSeas** billable regions. Billable regions inside the Chinese mainland include **CN**. Billable regions outside the Chinese mainland include **AP1**, **AP2**, **AP3**, **NA**, **SA**, **EU**, and **MEAA**.
 * > For more information about billable regions, see [Billable regions](~~142221~~).
 *
 * @param request DescribeCdnUserBillPredictionRequest
 * @return DescribeCdnUserBillPredictionResponse
 */
func (client *Client) DescribeCdnUserBillPrediction(request *DescribeCdnUserBillPredictionRequest) (_result *DescribeCdnUserBillPredictionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnUserBillPredictionResponse{}
	_body, _err := client.DescribeCdnUserBillPredictionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnUserBillTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnUserBillTypeResponse
 */
func (client *Client) DescribeCdnUserBillTypeWithOptions(request *DescribeCdnUserBillTypeRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnUserBillTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnUserBillType"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnUserBillTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCdnUserBillTypeRequest
 * @return DescribeCdnUserBillTypeResponse
 */
func (client *Client) DescribeCdnUserBillType(request *DescribeCdnUserBillTypeRequest) (_result *DescribeCdnUserBillTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnUserBillTypeResponse{}
	_body, _err := client.DescribeCdnUserBillTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnUserConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnUserConfigsResponse
 */
func (client *Client) DescribeCdnUserConfigsWithOptions(request *DescribeCdnUserConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnUserConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionName)) {
		query["FunctionName"] = request.FunctionName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnUserConfigs"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnUserConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnUserConfigsRequest
 * @return DescribeCdnUserConfigsResponse
 */
func (client *Client) DescribeCdnUserConfigs(request *DescribeCdnUserConfigsRequest) (_result *DescribeCdnUserConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnUserConfigsResponse{}
	_body, _err := client.DescribeCdnUserConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request DescribeCdnUserDomainsByFuncRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnUserDomainsByFuncResponse
 */
func (client *Client) DescribeCdnUserDomainsByFuncWithOptions(request *DescribeCdnUserDomainsByFuncRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnUserDomainsByFuncResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FuncId)) {
		query["FuncId"] = request.FuncId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnUserDomainsByFunc"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnUserDomainsByFuncResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request DescribeCdnUserDomainsByFuncRequest
 * @return DescribeCdnUserDomainsByFuncResponse
 */
func (client *Client) DescribeCdnUserDomainsByFunc(request *DescribeCdnUserDomainsByFuncRequest) (_result *DescribeCdnUserDomainsByFuncResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnUserDomainsByFuncResponse{}
	_body, _err := client.DescribeCdnUserDomainsByFuncWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnUserQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnUserQuotaResponse
 */
func (client *Client) DescribeCdnUserQuotaWithOptions(request *DescribeCdnUserQuotaRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnUserQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnUserQuota"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnUserQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnUserQuotaRequest
 * @return DescribeCdnUserQuotaResponse
 */
func (client *Client) DescribeCdnUserQuota(request *DescribeCdnUserQuotaRequest) (_result *DescribeCdnUserQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnUserQuotaResponse{}
	_body, _err := client.DescribeCdnUserQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnUserResourcePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnUserResourcePackageResponse
 */
func (client *Client) DescribeCdnUserResourcePackageWithOptions(request *DescribeCdnUserResourcePackageRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnUserResourcePackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnUserResourcePackage"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnUserResourcePackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeCdnUserResourcePackageRequest
 * @return DescribeCdnUserResourcePackageResponse
 */
func (client *Client) DescribeCdnUserResourcePackage(request *DescribeCdnUserResourcePackageRequest) (_result *DescribeCdnUserResourcePackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnUserResourcePackageResponse{}
	_body, _err := client.DescribeCdnUserResourcePackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 150 times per second per account.
 *
 * @param request DescribeCdnWafDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCdnWafDomainResponse
 */
func (client *Client) DescribeCdnWafDomainWithOptions(request *DescribeCdnWafDomainRequest, runtime *util.RuntimeOptions) (_result *DescribeCdnWafDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdnWafDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdnWafDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 150 times per second per account.
 *
 * @param request DescribeCdnWafDomainRequest
 * @return DescribeCdnWafDomainResponse
 */
func (client *Client) DescribeCdnWafDomain(request *DescribeCdnWafDomainRequest) (_result *DescribeCdnWafDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdnWafDomainResponse{}
	_body, _err := client.DescribeCdnWafDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 100 times per second per account.
 * *   If a certificate is associated with a domain name but the certificate is not enabled, the result of this operation shows that the certificate does not exist.
 *
 * @param request DescribeCertificateInfoByIDRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCertificateInfoByIDResponse
 */
func (client *Client) DescribeCertificateInfoByIDWithOptions(request *DescribeCertificateInfoByIDRequest, runtime *util.RuntimeOptions) (_result *DescribeCertificateInfoByIDResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCertificateInfoByID"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCertificateInfoByIDResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 100 times per second per account.
 * *   If a certificate is associated with a domain name but the certificate is not enabled, the result of this operation shows that the certificate does not exist.
 *
 * @param request DescribeCertificateInfoByIDRequest
 * @return DescribeCertificateInfoByIDResponse
 */
func (client *Client) DescribeCertificateInfoByID(request *DescribeCertificateInfoByIDRequest) (_result *DescribeCertificateInfoByIDResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCertificateInfoByIDResponse{}
	_body, _err := client.DescribeCertificateInfoByIDWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCustomLogConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCustomLogConfigResponse
 */
func (client *Client) DescribeCustomLogConfigWithOptions(request *DescribeCustomLogConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomLogConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomLogConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomLogConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeCustomLogConfigRequest
 * @return DescribeCustomLogConfigResponse
 */
func (client *Client) DescribeCustomLogConfig(request *DescribeCustomLogConfigRequest) (_result *DescribeCustomLogConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomLogConfigResponse{}
	_body, _err := client.DescribeCustomLogConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature to for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can call this operation up to 100 times per second per account.
 * >*   You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
 *
 * @param request DescribeDomainAverageResponseTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainAverageResponseTimeResponse
 */
func (client *Client) DescribeDomainAverageResponseTimeWithOptions(request *DescribeDomainAverageResponseTimeRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainAverageResponseTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainType)) {
		query["DomainType"] = request.DomainType
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TimeMerge)) {
		query["TimeMerge"] = request.TimeMerge
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainAverageResponseTime"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainAverageResponseTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature to for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can call this operation up to 100 times per second per account.
 * >*   You can specify up to 500 domain names in each request. Separate multiple domain names with commas (,).
 *
 * @param request DescribeDomainAverageResponseTimeRequest
 * @return DescribeDomainAverageResponseTimeResponse
 */
func (client *Client) DescribeDomainAverageResponseTime(request *DescribeDomainAverageResponseTimeRequest) (_result *DescribeDomainAverageResponseTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainAverageResponseTimeResponse{}
	_body, _err := client.DescribeDomainAverageResponseTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 150 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainBpsDataResponse
 */
func (client *Client) DescribeDomainBpsDataWithOptions(request *DescribeDomainBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainBpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 150 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainBpsDataRequest
 * @return DescribeDomainBpsDataResponse
 */
func (client *Client) DescribeDomainBpsData(request *DescribeDomainBpsDataRequest) (_result *DescribeDomainBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainBpsDataResponse{}
	_body, _err := client.DescribeDomainBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainBpsDataByLayerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainBpsDataByLayerResponse
 */
func (client *Client) DescribeDomainBpsDataByLayerWithOptions(request *DescribeDomainBpsDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainBpsDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.Layer)) {
		query["Layer"] = request.Layer
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainBpsDataByLayer"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainBpsDataByLayerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainBpsDataByLayerRequest
 * @return DescribeDomainBpsDataByLayerResponse
 */
func (client *Client) DescribeDomainBpsDataByLayer(request *DescribeDomainBpsDataByLayerRequest) (_result *DescribeDomainBpsDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainBpsDataByLayerResponse{}
	_body, _err := client.DescribeDomainBpsDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The bandwidth is measured in bit/s.
 * *   You can specify only one accelerated domain name in each request.
 * *   The data is collected every 5 minutes.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDomainBpsDataByTimeStampRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainBpsDataByTimeStampResponse
 */
func (client *Client) DescribeDomainBpsDataByTimeStampWithOptions(request *DescribeDomainBpsDataByTimeStampRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainBpsDataByTimeStampResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.IspNames)) {
		query["IspNames"] = request.IspNames
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNames)) {
		query["LocationNames"] = request.LocationNames
	}

	if !tea.BoolValue(util.IsUnset(request.TimePoint)) {
		query["TimePoint"] = request.TimePoint
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainBpsDataByTimeStamp"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainBpsDataByTimeStampResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The bandwidth is measured in bit/s.
 * *   You can specify only one accelerated domain name in each request.
 * *   The data is collected every 5 minutes.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDomainBpsDataByTimeStampRequest
 * @return DescribeDomainBpsDataByTimeStampResponse
 */
func (client *Client) DescribeDomainBpsDataByTimeStamp(request *DescribeDomainBpsDataByTimeStampRequest) (_result *DescribeDomainBpsDataByTimeStampResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainBpsDataByTimeStampResponse{}
	_body, _err := client.DescribeDomainBpsDataByTimeStampWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both parameters empty.
 * *   You can specify up to 20 domain names in reach request. If you specify multiple domain names, separate them with commas (,).
 * *   You can query data collected over the last 30 days.
 * *   You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDomainCcActivityLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainCcActivityLogResponse
 */
func (client *Client) DescribeDomainCcActivityLogWithOptions(request *DescribeDomainCcActivityLogRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainCcActivityLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TriggerObject)) {
		query["TriggerObject"] = request.TriggerObject
	}

	if !tea.BoolValue(util.IsUnset(request.Value)) {
		query["Value"] = request.Value
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainCcActivityLog"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainCcActivityLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both parameters empty.
 * *   You can specify up to 20 domain names in reach request. If you specify multiple domain names, separate them with commas (,).
 * *   You can query data collected over the last 30 days.
 * *   You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDomainCcActivityLogRequest
 * @return DescribeDomainCcActivityLogResponse
 */
func (client *Client) DescribeDomainCcActivityLog(request *DescribeDomainCcActivityLogRequest) (_result *DescribeDomainCcActivityLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainCcActivityLogResponse{}
	_body, _err := client.DescribeDomainCcActivityLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainCertificateInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainCertificateInfoResponse
 */
func (client *Client) DescribeDomainCertificateInfoWithOptions(request *DescribeDomainCertificateInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainCertificateInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainCertificateInfo"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainCertificateInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainCertificateInfoRequest
 * @return DescribeDomainCertificateInfoResponse
 */
func (client *Client) DescribeDomainCertificateInfo(request *DescribeDomainCertificateInfoRequest) (_result *DescribeDomainCertificateInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainCertificateInfoResponse{}
	_body, _err := client.DescribeDomainCertificateInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainCnameWithOptions(request *DescribeDomainCnameRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainCnameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainCname"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainCnameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainCname(request *DescribeDomainCnameRequest) (_result *DescribeDomainCnameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainCnameResponse{}
	_body, _err := client.DescribeDomainCnameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainCustomLogConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainCustomLogConfigResponse
 */
func (client *Client) DescribeDomainCustomLogConfigWithOptions(request *DescribeDomainCustomLogConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainCustomLogConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainCustomLogConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainCustomLogConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainCustomLogConfigRequest
 * @return DescribeDomainCustomLogConfigResponse
 */
func (client *Client) DescribeDomainCustomLogConfig(request *DescribeDomainCustomLogConfigRequest) (_result *DescribeDomainCustomLogConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainCustomLogConfigResponse{}
	_body, _err := client.DescribeDomainCustomLogConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 *
 * @param request DescribeDomainDetailDataByLayerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainDetailDataByLayerResponse
 */
func (client *Client) DescribeDomainDetailDataByLayerWithOptions(request *DescribeDomainDetailDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainDetailDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainDetailDataByLayer"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainDetailDataByLayerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 *
 * @param request DescribeDomainDetailDataByLayerRequest
 * @return DescribeDomainDetailDataByLayerResponse
 */
func (client *Client) DescribeDomainDetailDataByLayer(request *DescribeDomainDetailDataByLayerRequest) (_result *DescribeDomainDetailDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainDetailDataByLayerResponse{}
	_body, _err := client.DescribeDomainDetailDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainHitRateDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainHitRateDataResponse
 */
func (client *Client) DescribeDomainHitRateDataWithOptions(request *DescribeDomainHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainHitRateData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainHitRateDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainHitRateDataRequest
 * @return DescribeDomainHitRateDataResponse
 */
func (client *Client) DescribeDomainHitRateData(request *DescribeDomainHitRateDataRequest) (_result *DescribeDomainHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainHitRateDataResponse{}
	_body, _err := client.DescribeDomainHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainHttpCodeDataResponse
 */
func (client *Client) DescribeDomainHttpCodeDataWithOptions(request *DescribeDomainHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainHttpCodeData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainHttpCodeDataRequest
 * @return DescribeDomainHttpCodeDataResponse
 */
func (client *Client) DescribeDomainHttpCodeData(request *DescribeDomainHttpCodeDataRequest) (_result *DescribeDomainHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainHttpCodeDataResponse{}
	_body, _err := client.DescribeDomainHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * ### Time granularity
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainHttpCodeDataByLayerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainHttpCodeDataByLayerResponse
 */
func (client *Client) DescribeDomainHttpCodeDataByLayerWithOptions(request *DescribeDomainHttpCodeDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainHttpCodeDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.Layer)) {
		query["Layer"] = request.Layer
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainHttpCodeDataByLayer"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainHttpCodeDataByLayerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * ### Time granularity
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainHttpCodeDataByLayerRequest
 * @return DescribeDomainHttpCodeDataByLayerResponse
 */
func (client *Client) DescribeDomainHttpCodeDataByLayer(request *DescribeDomainHttpCodeDataByLayerRequest) (_result *DescribeDomainHttpCodeDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainHttpCodeDataByLayerResponse{}
	_body, _err := client.DescribeDomainHttpCodeDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not set StartTime or EndTime, the request returns the data collected in the last 24 hours. If you set both StartTime and EndTime, the request returns the data collected within the specified time range.
 * >*   This operation queries proportions of data usage of different ISPs for only a specific accelerated domain name, or for all accelerated domain names in your Alibaba Cloud account.
 * >*   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainISPDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainISPDataResponse
 */
func (client *Client) DescribeDomainISPDataWithOptions(request *DescribeDomainISPDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainISPDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainISPData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainISPDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not set StartTime or EndTime, the request returns the data collected in the last 24 hours. If you set both StartTime and EndTime, the request returns the data collected within the specified time range.
 * >*   This operation queries proportions of data usage of different ISPs for only a specific accelerated domain name, or for all accelerated domain names in your Alibaba Cloud account.
 * >*   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainISPDataRequest
 * @return DescribeDomainISPDataResponse
 */
func (client *Client) DescribeDomainISPData(request *DescribeDomainISPDataRequest) (_result *DescribeDomainISPDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainISPDataResponse{}
	_body, _err := client.DescribeDomainISPDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The unit of the bandwidth is bit/s.
 * *   The time granularity of the queried data is 5 minutes.
 * *   You can query data in the last 90 days.
 * *   You can specify the StartTime and EndTime parameters, or the TimePoint and Cycle parameters to query the 95th percentile bandwidth data. If you specify the StartTime and EndTime parameters and the time range that is specified by these parameters is less than or equal to 24 hours, the 95th percentile bandwidth data on the day of the start time is returned. If the time range that is specified by these parameters is more than 24 hours, the 95th percentile bandwidth data in the month of the start time is returned. If you specify the TimePoint and Cycle parameters, the 95th percentile bandwidth data of the cycle is returned. If you do not specify parameters as previously mentioned, the 95th percentile bandwidth data in the last 24 hours is returned.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainMax95BpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainMax95BpsDataResponse
 */
func (client *Client) DescribeDomainMax95BpsDataWithOptions(request *DescribeDomainMax95BpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainMax95BpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cycle)) {
		query["Cycle"] = request.Cycle
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TimePoint)) {
		query["TimePoint"] = request.TimePoint
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainMax95BpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainMax95BpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The unit of the bandwidth is bit/s.
 * *   The time granularity of the queried data is 5 minutes.
 * *   You can query data in the last 90 days.
 * *   You can specify the StartTime and EndTime parameters, or the TimePoint and Cycle parameters to query the 95th percentile bandwidth data. If you specify the StartTime and EndTime parameters and the time range that is specified by these parameters is less than or equal to 24 hours, the 95th percentile bandwidth data on the day of the start time is returned. If the time range that is specified by these parameters is more than 24 hours, the 95th percentile bandwidth data in the month of the start time is returned. If you specify the TimePoint and Cycle parameters, the 95th percentile bandwidth data of the cycle is returned. If you do not specify parameters as previously mentioned, the 95th percentile bandwidth data in the last 24 hours is returned.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainMax95BpsDataRequest
 * @return DescribeDomainMax95BpsDataResponse
 */
func (client *Client) DescribeDomainMax95BpsData(request *DescribeDomainMax95BpsDataRequest) (_result *DescribeDomainMax95BpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainMax95BpsDataResponse{}
	_body, _err := client.DescribeDomainMax95BpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set StartTime or EndTime, data collected within the last 10 minutes is queried.
 * *   The maximum interval between StartTime and EndTime is 1 hour.
 * *   You can query data within the last 90 days.
 * *   You can query the traffic data and the number of requests for accelerated domain names that are deleted.
 * *   You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDomainMultiUsageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainMultiUsageDataResponse
 */
func (client *Client) DescribeDomainMultiUsageDataWithOptions(request *DescribeDomainMultiUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainMultiUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainMultiUsageData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainMultiUsageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set StartTime or EndTime, data collected within the last 10 minutes is queried.
 * *   The maximum interval between StartTime and EndTime is 1 hour.
 * *   You can query data within the last 90 days.
 * *   You can query the traffic data and the number of requests for accelerated domain names that are deleted.
 * *   You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDomainMultiUsageDataRequest
 * @return DescribeDomainMultiUsageDataResponse
 */
func (client *Client) DescribeDomainMultiUsageData(request *DescribeDomainMultiUsageDataRequest) (_result *DescribeDomainMultiUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainMultiUsageDataResponse{}
	_body, _err := client.DescribeDomainMultiUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation is available only to users that are on the whitelist. If the daily peak bandwidth value of your workloads reaches 10 Gbit/s, you can [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex) to apply to be included in the whitelist.
 * *   You can call this API operation up to 6,000 times per second per account.
 * *   Data collection by directory is available only to specified domain names within your Alibaba Cloud account. It cannot be enabled for all domain names within your Alibaba Cloud account.
 * *   The average size of the files that belong to the domain name must be larger than 1 MB.
 * *   The number of directories specified for a single domain name cannot exceed 100. If the number of directories exceeds 100, the data accuracy reduces.
 * *   If you do not set StartTime or EndTime, data collected within the last 24 hours is queried. If you set both StartTime and EndTime, data within the specified time range is queried.
 * *   You can query data collected within the last 30 days.
 *
 * @param request DescribeDomainPathDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainPathDataResponse
 */
func (client *Client) DescribeDomainPathDataWithOptions(request *DescribeDomainPathDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainPathDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainPathData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainPathDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation is available only to users that are on the whitelist. If the daily peak bandwidth value of your workloads reaches 10 Gbit/s, you can [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex) to apply to be included in the whitelist.
 * *   You can call this API operation up to 6,000 times per second per account.
 * *   Data collection by directory is available only to specified domain names within your Alibaba Cloud account. It cannot be enabled for all domain names within your Alibaba Cloud account.
 * *   The average size of the files that belong to the domain name must be larger than 1 MB.
 * *   The number of directories specified for a single domain name cannot exceed 100. If the number of directories exceeds 100, the data accuracy reduces.
 * *   If you do not set StartTime or EndTime, data collected within the last 24 hours is queried. If you set both StartTime and EndTime, data within the specified time range is queried.
 * *   You can query data collected within the last 30 days.
 *
 * @param request DescribeDomainPathDataRequest
 * @return DescribeDomainPathDataResponse
 */
func (client *Client) DescribeDomainPathData(request *DescribeDomainPathDataRequest) (_result *DescribeDomainPathDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainPathDataResponse{}
	_body, _err := client.DescribeDomainPathDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature to for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDomainPvDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainPvDataResponse
 */
func (client *Client) DescribeDomainPvDataWithOptions(request *DescribeDomainPvDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainPvDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainPvData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainPvDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature to for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDomainPvDataRequest
 * @return DescribeDomainPvDataResponse
 */
func (client *Client) DescribeDomainPvData(request *DescribeDomainPvDataRequest) (_result *DescribeDomainPvDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainPvDataResponse{}
	_body, _err := client.DescribeDomainPvDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainQpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainQpsDataResponse
 */
func (client *Client) DescribeDomainQpsDataWithOptions(request *DescribeDomainQpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainQpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainQpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainQpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainQpsDataRequest
 * @return DescribeDomainQpsDataResponse
 */
func (client *Client) DescribeDomainQpsData(request *DescribeDomainQpsDataRequest) (_result *DescribeDomainQpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainQpsDataResponse{}
	_body, _err := client.DescribeDomainQpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per user.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainQpsDataByLayerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainQpsDataByLayerResponse
 */
func (client *Client) DescribeDomainQpsDataByLayerWithOptions(request *DescribeDomainQpsDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainQpsDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.Layer)) {
		query["Layer"] = request.Layer
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainQpsDataByLayer"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainQpsDataByLayerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per user.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainQpsDataByLayerRequest
 * @return DescribeDomainQpsDataByLayerResponse
 */
func (client *Client) DescribeDomainQpsDataByLayer(request *DescribeDomainQpsDataByLayerRequest) (_result *DescribeDomainQpsDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainQpsDataByLayerResponse{}
	_body, _err := client.DescribeDomainQpsDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity** The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeBpsDataResponse
 */
func (client *Client) DescribeDomainRealTimeBpsDataWithOptions(request *DescribeDomainRealTimeBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeBpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity** The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeBpsDataRequest
 * @return DescribeDomainRealTimeBpsDataResponse
 */
func (client *Client) DescribeDomainRealTimeBpsData(request *DescribeDomainRealTimeBpsDataRequest) (_result *DescribeDomainRealTimeBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeBpsDataResponse{}
	_body, _err := client.DescribeDomainRealTimeBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeByteHitRateDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeByteHitRateDataResponse
 */
func (client *Client) DescribeDomainRealTimeByteHitRateDataWithOptions(request *DescribeDomainRealTimeByteHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeByteHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeByteHitRateData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeByteHitRateDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeByteHitRateDataRequest
 * @return DescribeDomainRealTimeByteHitRateDataResponse
 */
func (client *Client) DescribeDomainRealTimeByteHitRateData(request *DescribeDomainRealTimeByteHitRateDataRequest) (_result *DescribeDomainRealTimeByteHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeByteHitRateDataResponse{}
	_body, _err := client.DescribeDomainRealTimeByteHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can query data in the last seven days. Data is collected every minute.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainRealTimeDetailDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeDetailDataResponse
 */
func (client *Client) DescribeDomainRealTimeDetailDataWithOptions(request *DescribeDomainRealTimeDetailDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeDetailDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeDetailData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeDetailDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can query data in the last seven days. Data is collected every minute.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainRealTimeDetailDataRequest
 * @return DescribeDomainRealTimeDetailDataResponse
 */
func (client *Client) DescribeDomainRealTimeDetailData(request *DescribeDomainRealTimeDetailDataRequest) (_result *DescribeDomainRealTimeDetailDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeDetailDataResponse{}
	_body, _err := client.DescribeDomainRealTimeDetailDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeHttpCodeDataResponse
 */
func (client *Client) DescribeDomainRealTimeHttpCodeDataWithOptions(request *DescribeDomainRealTimeHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeHttpCodeData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeHttpCodeDataRequest
 * @return DescribeDomainRealTimeHttpCodeDataResponse
 */
func (client *Client) DescribeDomainRealTimeHttpCodeData(request *DescribeDomainRealTimeHttpCodeDataRequest) (_result *DescribeDomainRealTimeHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeHttpCodeDataResponse{}
	_body, _err := client.DescribeDomainRealTimeHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeQpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeQpsDataResponse
 */
func (client *Client) DescribeDomainRealTimeQpsDataWithOptions(request *DescribeDomainRealTimeQpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeQpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeQpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeQpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeQpsDataRequest
 * @return DescribeDomainRealTimeQpsDataResponse
 */
func (client *Client) DescribeDomainRealTimeQpsData(request *DescribeDomainRealTimeQpsDataRequest) (_result *DescribeDomainRealTimeQpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeQpsDataResponse{}
	_body, _err := client.DescribeDomainRealTimeQpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * * By default, requests in the Go programming language use the POST request method. You must manually change the request method to GET by declaring: request.Method="GET".
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the request hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeReqHitRateDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeReqHitRateDataResponse
 */
func (client *Client) DescribeDomainRealTimeReqHitRateDataWithOptions(request *DescribeDomainRealTimeReqHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeReqHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeReqHitRateData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeReqHitRateDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * * By default, requests in the Go programming language use the POST request method. You must manually change the request method to GET by declaring: request.Method="GET".
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the request hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeReqHitRateDataRequest
 * @return DescribeDomainRealTimeReqHitRateDataResponse
 */
func (client *Client) DescribeDomainRealTimeReqHitRateData(request *DescribeDomainRealTimeReqHitRateDataRequest) (_result *DescribeDomainRealTimeReqHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeReqHitRateDataResponse{}
	_body, _err := client.DescribeDomainRealTimeReqHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeSrcBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeSrcBpsDataResponse
 */
func (client *Client) DescribeDomainRealTimeSrcBpsDataWithOptions(request *DescribeDomainRealTimeSrcBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeSrcBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeSrcBpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeSrcBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeSrcBpsDataRequest
 * @return DescribeDomainRealTimeSrcBpsDataResponse
 */
func (client *Client) DescribeDomainRealTimeSrcBpsData(request *DescribeDomainRealTimeSrcBpsDataRequest) (_result *DescribeDomainRealTimeSrcBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeSrcBpsDataResponse{}
	_body, _err := client.DescribeDomainRealTimeSrcBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeSrcHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeSrcHttpCodeDataResponse
 */
func (client *Client) DescribeDomainRealTimeSrcHttpCodeDataWithOptions(request *DescribeDomainRealTimeSrcHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeSrcHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeSrcHttpCodeData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeSrcHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeSrcHttpCodeDataRequest
 * @return DescribeDomainRealTimeSrcHttpCodeDataResponse
 */
func (client *Client) DescribeDomainRealTimeSrcHttpCodeData(request *DescribeDomainRealTimeSrcHttpCodeDataRequest) (_result *DescribeDomainRealTimeSrcHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeSrcHttpCodeDataResponse{}
	_body, _err := client.DescribeDomainRealTimeSrcHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour by default. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeSrcTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeSrcTrafficDataResponse
 */
func (client *Client) DescribeDomainRealTimeSrcTrafficDataWithOptions(request *DescribeDomainRealTimeSrcTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeSrcTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeSrcTrafficData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeSrcTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour by default. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeSrcTrafficDataRequest
 * @return DescribeDomainRealTimeSrcTrafficDataResponse
 */
func (client *Client) DescribeDomainRealTimeSrcTrafficData(request *DescribeDomainRealTimeSrcTrafficDataRequest) (_result *DescribeDomainRealTimeSrcTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeSrcTrafficDataResponse{}
	_body, _err := client.DescribeDomainRealTimeSrcTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 50 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealTimeTrafficDataResponse
 */
func (client *Client) DescribeDomainRealTimeTrafficDataWithOptions(request *DescribeDomainRealTimeTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealTimeTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealTimeTrafficData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealTimeTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 50 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDomainRealTimeTrafficDataRequest
 * @return DescribeDomainRealTimeTrafficDataResponse
 */
func (client *Client) DescribeDomainRealTimeTrafficData(request *DescribeDomainRealTimeTrafficDataRequest) (_result *DescribeDomainRealTimeTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealTimeTrafficDataResponse{}
	_body, _err := client.DescribeDomainRealTimeTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainRealtimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRealtimeLogDeliveryResponse
 */
func (client *Client) DescribeDomainRealtimeLogDeliveryWithOptions(request *DescribeDomainRealtimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRealtimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRealtimeLogDelivery"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRealtimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainRealtimeLogDeliveryRequest
 * @return DescribeDomainRealtimeLogDeliveryResponse
 */
func (client *Client) DescribeDomainRealtimeLogDelivery(request *DescribeDomainRealtimeLogDeliveryRequest) (_result *DescribeDomainRealtimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRealtimeLogDeliveryResponse{}
	_body, _err := client.DescribeDomainRealtimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you not use this operation because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not specify the **StartTime** or **EndTime** parameter, data collected within the last **24** hours is queried. If you specify both the **StartTime** and **EndTime** parameters, data collected within the specified time range is queried.
 * >*   There is delay in data collection. If you want to query data collected within the last day, we recommend that you query the data on the next day.
 * >*   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainRegionDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRegionDataResponse
 */
func (client *Client) DescribeDomainRegionDataWithOptions(request *DescribeDomainRegionDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRegionDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRegionData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRegionDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you not use this operation because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not specify the **StartTime** or **EndTime** parameter, data collected within the last **24** hours is queried. If you specify both the **StartTime** and **EndTime** parameters, data collected within the specified time range is queried.
 * >*   There is delay in data collection. If you want to query data collected within the last day, we recommend that you query the data on the next day.
 * >*   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainRegionDataRequest
 * @return DescribeDomainRegionDataResponse
 */
func (client *Client) DescribeDomainRegionData(request *DescribeDomainRegionDataRequest) (_result *DescribeDomainRegionDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRegionDataResponse{}
	_body, _err := client.DescribeDomainRegionDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainReqHitRateDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainReqHitRateDataResponse
 */
func (client *Client) DescribeDomainReqHitRateDataWithOptions(request *DescribeDomainReqHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainReqHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainReqHitRateData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainReqHitRateDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainReqHitRateDataRequest
 * @return DescribeDomainReqHitRateDataResponse
 */
func (client *Client) DescribeDomainReqHitRateData(request *DescribeDomainReqHitRateDataRequest) (_result *DescribeDomainReqHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainReqHitRateDataResponse{}
	_body, _err := client.DescribeDomainReqHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSrcBpsDataResponse
 */
func (client *Client) DescribeDomainSrcBpsDataWithOptions(request *DescribeDomainSrcBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainSrcBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainSrcBpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainSrcBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcBpsDataRequest
 * @return DescribeDomainSrcBpsDataResponse
 */
func (client *Client) DescribeDomainSrcBpsData(request *DescribeDomainSrcBpsDataRequest) (_result *DescribeDomainSrcBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainSrcBpsDataResponse{}
	_body, _err := client.DescribeDomainSrcBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSrcHttpCodeDataResponse
 */
func (client *Client) DescribeDomainSrcHttpCodeDataWithOptions(request *DescribeDomainSrcHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainSrcHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainSrcHttpCodeData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainSrcHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcHttpCodeDataRequest
 * @return DescribeDomainSrcHttpCodeDataResponse
 */
func (client *Client) DescribeDomainSrcHttpCodeData(request *DescribeDomainSrcHttpCodeDataRequest) (_result *DescribeDomainSrcHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainSrcHttpCodeDataResponse{}
	_body, _err := client.DescribeDomainSrcHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * ### Time granularity
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcQpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSrcQpsDataResponse
 */
func (client *Client) DescribeDomainSrcQpsDataWithOptions(request *DescribeDomainSrcQpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainSrcQpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainSrcQpsData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainSrcQpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * ### Time granularity
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcQpsDataRequest
 * @return DescribeDomainSrcQpsDataResponse
 */
func (client *Client) DescribeDomainSrcQpsData(request *DescribeDomainSrcQpsDataRequest) (_result *DescribeDomainSrcQpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainSrcQpsDataResponse{}
	_body, _err := client.DescribeDomainSrcQpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   The data is collected at an interval of 5 minutes.
 * >*   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainSrcTopUrlVisitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSrcTopUrlVisitResponse
 */
func (client *Client) DescribeDomainSrcTopUrlVisitWithOptions(request *DescribeDomainSrcTopUrlVisitRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainSrcTopUrlVisitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainSrcTopUrlVisit"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainSrcTopUrlVisitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   The data is collected at an interval of 5 minutes.
 * >*   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainSrcTopUrlVisitRequest
 * @return DescribeDomainSrcTopUrlVisitResponse
 */
func (client *Client) DescribeDomainSrcTopUrlVisit(request *DescribeDomainSrcTopUrlVisitRequest) (_result *DescribeDomainSrcTopUrlVisitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainSrcTopUrlVisitResponse{}
	_body, _err := client.DescribeDomainSrcTopUrlVisitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSrcTrafficDataResponse
 */
func (client *Client) DescribeDomainSrcTrafficDataWithOptions(request *DescribeDomainSrcTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainSrcTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainSrcTrafficData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainSrcTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainSrcTrafficDataRequest
 * @return DescribeDomainSrcTrafficDataResponse
 */
func (client *Client) DescribeDomainSrcTrafficData(request *DescribeDomainSrcTrafficDataRequest) (_result *DescribeDomainSrcTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainSrcTrafficDataResponse{}
	_body, _err := client.DescribeDomainSrcTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature to for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   Data is collected every hour.
 * >*   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainTopClientIpVisitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopClientIpVisitResponse
 */
func (client *Client) DescribeDomainTopClientIpVisitWithOptions(request *DescribeDomainTopClientIpVisitRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainTopClientIpVisitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Limit)) {
		query["Limit"] = request.Limit
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainTopClientIpVisit"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainTopClientIpVisitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature to for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   Data is collected every hour.
 * >*   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainTopClientIpVisitRequest
 * @return DescribeDomainTopClientIpVisitResponse
 */
func (client *Client) DescribeDomainTopClientIpVisit(request *DescribeDomainTopClientIpVisitRequest) (_result *DescribeDomainTopClientIpVisitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainTopClientIpVisitResponse{}
	_body, _err := client.DescribeDomainTopClientIpVisitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature or [ship real-time logs in Log Service](~~440145~~) to analyze data.
 * >
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   Data is collected at an interval of five minutes.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainTopReferVisitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopReferVisitResponse
 */
func (client *Client) DescribeDomainTopReferVisitWithOptions(request *DescribeDomainTopReferVisitRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainTopReferVisitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainTopReferVisit"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainTopReferVisitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature or [ship real-time logs in Log Service](~~440145~~) to analyze data.
 * >
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   Data is collected at an interval of five minutes.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainTopReferVisitRequest
 * @return DescribeDomainTopReferVisitResponse
 */
func (client *Client) DescribeDomainTopReferVisit(request *DescribeDomainTopReferVisitRequest) (_result *DescribeDomainTopReferVisitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainTopReferVisitResponse{}
	_body, _err := client.DescribeDomainTopReferVisitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can query data collected in the last 90 days.
 * >*   You can specify only one domain name in each call.
 * >*   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainTopUrlVisitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopUrlVisitResponse
 */
func (client *Client) DescribeDomainTopUrlVisitWithOptions(request *DescribeDomainTopUrlVisitRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainTopUrlVisitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainTopUrlVisit"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainTopUrlVisitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can query data collected in the last 90 days.
 * >*   You can specify only one domain name in each call.
 * >*   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDomainTopUrlVisitRequest
 * @return DescribeDomainTopUrlVisitResponse
 */
func (client *Client) DescribeDomainTopUrlVisit(request *DescribeDomainTopUrlVisitRequest) (_result *DescribeDomainTopUrlVisitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainTopUrlVisitResponse{}
	_body, _err := client.DescribeDomainTopUrlVisitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366|04:00 on the next day|
 *
 * @param request DescribeDomainTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTrafficDataResponse
 */
func (client *Client) DescribeDomainTrafficDataWithOptions(request *DescribeDomainTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainTrafficData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366|04:00 on the next day|
 *
 * @param request DescribeDomainTrafficDataRequest
 * @return DescribeDomainTrafficDataResponse
 */
func (client *Client) DescribeDomainTrafficData(request *DescribeDomainTrafficDataRequest) (_result *DescribeDomainTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainTrafficDataResponse{}
	_body, _err := client.DescribeDomainTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|90 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainUsageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainUsageDataResponse
 */
func (client *Client) DescribeDomainUsageDataWithOptions(request *DescribeDomainUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.DataProtocol)) {
		query["DataProtocol"] = request.DataProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Field)) {
		query["Field"] = request.Field
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainUsageData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainUsageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|90 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDomainUsageDataRequest
 * @return DescribeDomainUsageDataResponse
 */
func (client *Client) DescribeDomainUsageData(request *DescribeDomainUsageDataRequest) (_result *DescribeDomainUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainUsageDataResponse{}
	_body, _err := client.DescribeDomainUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * >
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   You can specify only one accelerated domain name or all accelerated domain names in your Alibaba Cloud account.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainUvDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainUvDataResponse
 */
func (client *Client) DescribeDomainUvDataWithOptions(request *DescribeDomainUvDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainUvDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainUvData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainUvDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * >
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   You can specify only one accelerated domain name or all accelerated domain names in your Alibaba Cloud account.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDomainUvDataRequest
 * @return DescribeDomainUvDataResponse
 */
func (client *Client) DescribeDomainUvData(request *DescribeDomainUvDataRequest) (_result *DescribeDomainUvDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainUvDataResponse{}
	_body, _err := client.DescribeDomainUvDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDomainsBySourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainsBySourceResponse
 */
func (client *Client) DescribeDomainsBySourceWithOptions(request *DescribeDomainsBySourceRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainsBySourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainsBySource"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainsBySourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDomainsBySourceRequest
 * @return DescribeDomainsBySourceResponse
 */
func (client *Client) DescribeDomainsBySource(request *DescribeDomainsBySourceRequest) (_result *DescribeDomainsBySourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainsBySourceResponse{}
	_body, _err := client.DescribeDomainsBySourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   If you do not set StartTime or EndTime, data within the last 24 hours is queried. If you set both StartTime and EndTime, data within the specified time range is queried.
 * *   You can query the monitoring data of a specific accelerated domain name or all accelerated domain names that belong to your Alibaba Cloud account.
 *
 * @param request DescribeDomainsUsageByDayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainsUsageByDayResponse
 */
func (client *Client) DescribeDomainsUsageByDayWithOptions(request *DescribeDomainsUsageByDayRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainsUsageByDayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainsUsageByDay"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainsUsageByDayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   If you do not set StartTime or EndTime, data within the last 24 hours is queried. If you set both StartTime and EndTime, data within the specified time range is queried.
 * *   You can query the monitoring data of a specific accelerated domain name or all accelerated domain names that belong to your Alibaba Cloud account.
 *
 * @param request DescribeDomainsUsageByDayRequest
 * @return DescribeDomainsUsageByDayResponse
 */
func (client *Client) DescribeDomainsUsageByDay(request *DescribeDomainsUsageByDayRequest) (_result *DescribeDomainsUsageByDayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainsUsageByDayResponse{}
	_body, _err := client.DescribeDomainsUsageByDayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeEsExceptionDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEsExceptionDataResponse
 */
func (client *Client) DescribeEsExceptionDataWithOptions(request *DescribeEsExceptionDataRequest, runtime *util.RuntimeOptions) (_result *DescribeEsExceptionDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEsExceptionData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEsExceptionDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeEsExceptionDataRequest
 * @return DescribeEsExceptionDataResponse
 */
func (client *Client) DescribeEsExceptionData(request *DescribeEsExceptionDataRequest) (_result *DescribeEsExceptionDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEsExceptionDataResponse{}
	_body, _err := client.DescribeEsExceptionDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeEsExecuteDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeEsExecuteDataResponse
 */
func (client *Client) DescribeEsExecuteDataWithOptions(request *DescribeEsExecuteDataRequest, runtime *util.RuntimeOptions) (_result *DescribeEsExecuteDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEsExecuteData"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEsExecuteDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeEsExecuteDataRequest
 * @return DescribeEsExecuteDataResponse
 */
func (client *Client) DescribeEsExecuteData(request *DescribeEsExecuteDataRequest) (_result *DescribeEsExecuteDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEsExecuteDataResponse{}
	_body, _err := client.DescribeEsExecuteDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeFCTriggerWithOptions(request *DescribeFCTriggerRequest, runtime *util.RuntimeOptions) (_result *DescribeFCTriggerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeFCTrigger"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeFCTriggerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeFCTrigger(request *DescribeFCTriggerRequest) (_result *DescribeFCTriggerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeFCTriggerResponse{}
	_body, _err := client.DescribeFCTriggerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeIpInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIpInfoResponse
 */
func (client *Client) DescribeIpInfoWithOptions(request *DescribeIpInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeIpInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IP)) {
		query["IP"] = request.IP
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIpInfo"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIpInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeIpInfoRequest
 * @return DescribeIpInfoResponse
 */
func (client *Client) DescribeIpInfo(request *DescribeIpInfoRequest) (_result *DescribeIpInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIpInfoResponse{}
	_body, _err := client.DescribeIpInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeIpStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIpStatusResponse
 */
func (client *Client) DescribeIpStatusWithOptions(request *DescribeIpStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeIpStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIpStatus"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIpStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeIpStatusRequest
 * @return DescribeIpStatusResponse
 */
func (client *Client) DescribeIpStatus(request *DescribeIpStatusRequest) (_result *DescribeIpStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIpStatusResponse{}
	_body, _err := client.DescribeIpStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation is available only to users whose daily peak bandwidth value is higher than 1 Gbit/s. If you meet this requirement, you can [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex) to apply for permissions to use this operation.
 * *   You can call this operation up to 40 times per second per account.
 *
 * @param request DescribeL2VipsByDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeL2VipsByDomainResponse
 */
func (client *Client) DescribeL2VipsByDomainWithOptions(request *DescribeL2VipsByDomainRequest, runtime *util.RuntimeOptions) (_result *DescribeL2VipsByDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeL2VipsByDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeL2VipsByDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation is available only to users whose daily peak bandwidth value is higher than 1 Gbit/s. If you meet this requirement, you can [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex) to apply for permissions to use this operation.
 * *   You can call this operation up to 40 times per second per account.
 *
 * @param request DescribeL2VipsByDomainRequest
 * @return DescribeL2VipsByDomainResponse
 */
func (client *Client) DescribeL2VipsByDomain(request *DescribeL2VipsByDomainRequest) (_result *DescribeL2VipsByDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeL2VipsByDomainResponse{}
	_body, _err := client.DescribeL2VipsByDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can query data within the last 3 days.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribePreloadDetailByIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePreloadDetailByIdResponse
 */
func (client *Client) DescribePreloadDetailByIdWithOptions(request *DescribePreloadDetailByIdRequest, runtime *util.RuntimeOptions) (_result *DescribePreloadDetailByIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePreloadDetailById"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePreloadDetailByIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can query data within the last 3 days.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribePreloadDetailByIdRequest
 * @return DescribePreloadDetailByIdResponse
 */
func (client *Client) DescribePreloadDetailById(request *DescribePreloadDetailByIdRequest) (_result *DescribePreloadDetailByIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePreloadDetailByIdResponse{}
	_body, _err := client.DescribePreloadDetailByIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The data is collected every 5 minutes.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeRangeDataByLocateAndIspServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRangeDataByLocateAndIspServiceResponse
 */
func (client *Client) DescribeRangeDataByLocateAndIspServiceWithOptions(request *DescribeRangeDataByLocateAndIspServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeRangeDataByLocateAndIspServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNames)) {
		query["IspNames"] = request.IspNames
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNames)) {
		query["LocationNames"] = request.LocationNames
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRangeDataByLocateAndIspService"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRangeDataByLocateAndIspServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The data is collected every 5 minutes.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeRangeDataByLocateAndIspServiceRequest
 * @return DescribeRangeDataByLocateAndIspServiceResponse
 */
func (client *Client) DescribeRangeDataByLocateAndIspService(request *DescribeRangeDataByLocateAndIspServiceRequest) (_result *DescribeRangeDataByLocateAndIspServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRangeDataByLocateAndIspServiceResponse{}
	_body, _err := client.DescribeRangeDataByLocateAndIspServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRealtimeDeliveryAccRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRealtimeDeliveryAccResponse
 */
func (client *Client) DescribeRealtimeDeliveryAccWithOptions(request *DescribeRealtimeDeliveryAccRequest, runtime *util.RuntimeOptions) (_result *DescribeRealtimeDeliveryAccResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.LogStore)) {
		query["LogStore"] = request.LogStore
	}

	if !tea.BoolValue(util.IsUnset(request.Project)) {
		query["Project"] = request.Project
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRealtimeDeliveryAcc"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRealtimeDeliveryAccResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRealtimeDeliveryAccRequest
 * @return DescribeRealtimeDeliveryAccResponse
 */
func (client *Client) DescribeRealtimeDeliveryAcc(request *DescribeRealtimeDeliveryAccRequest) (_result *DescribeRealtimeDeliveryAccResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRealtimeDeliveryAccResponse{}
	_body, _err := client.DescribeRealtimeDeliveryAccWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Queries the maximum and remaining numbers of URLs and directories that can be refreshed, the maximum and remaining numbers of times that you can prefetch content, and the maximum and remaining numbers of URLs and directories that can be blocked on the current day.
 *
 * @param request DescribeRefreshQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRefreshQuotaResponse
 */
func (client *Client) DescribeRefreshQuotaWithOptions(request *DescribeRefreshQuotaRequest, runtime *util.RuntimeOptions) (_result *DescribeRefreshQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRefreshQuota"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRefreshQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Queries the maximum and remaining numbers of URLs and directories that can be refreshed, the maximum and remaining numbers of times that you can prefetch content, and the maximum and remaining numbers of URLs and directories that can be blocked on the current day.
 *
 * @param request DescribeRefreshQuotaRequest
 * @return DescribeRefreshQuotaResponse
 */
func (client *Client) DescribeRefreshQuota(request *DescribeRefreshQuotaRequest) (_result *DescribeRefreshQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRefreshQuotaResponse{}
	_body, _err := client.DescribeRefreshQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can query data in the last three days.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeRefreshTaskByIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRefreshTaskByIdResponse
 */
func (client *Client) DescribeRefreshTaskByIdWithOptions(request *DescribeRefreshTaskByIdRequest, runtime *util.RuntimeOptions) (_result *DescribeRefreshTaskByIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRefreshTaskById"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRefreshTaskByIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can query data in the last three days.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeRefreshTaskByIdRequest
 * @return DescribeRefreshTaskByIdResponse
 */
func (client *Client) DescribeRefreshTaskById(request *DescribeRefreshTaskByIdRequest) (_result *DescribeRefreshTaskByIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRefreshTaskByIdResponse{}
	_body, _err := client.DescribeRefreshTaskByIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can query the status of tasks by task ID or URL.
 * *   You can set both the **TaskId** and **ObjectPath** parameters. If you do not set the **TaskId** or **ObjectPath** parameter, data entries on the first page (20 entries) collected in the last 3 days are returned.
 * *   You can query data collected in the last 3 days.
 * *   If auto CDN cache update is enabled in the Object Storage Service (OSS) console, you cannot call the DescribeRefreshTasks operation to query automatic refresh tasks in OSS.
 * *   You can call this operation up to 10 times per second per account. If you want to query tasks at a higher frequency, call the [DescribeRefreshTaskById](~~187709~~) operation. This operation allows you to query tasks by task ID.
 *
 * @param request DescribeRefreshTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRefreshTasksResponse
 */
func (client *Client) DescribeRefreshTasksWithOptions(request *DescribeRefreshTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeRefreshTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRefreshTasks"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRefreshTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can query the status of tasks by task ID or URL.
 * *   You can set both the **TaskId** and **ObjectPath** parameters. If you do not set the **TaskId** or **ObjectPath** parameter, data entries on the first page (20 entries) collected in the last 3 days are returned.
 * *   You can query data collected in the last 3 days.
 * *   If auto CDN cache update is enabled in the Object Storage Service (OSS) console, you cannot call the DescribeRefreshTasks operation to query automatic refresh tasks in OSS.
 * *   You can call this operation up to 10 times per second per account. If you want to query tasks at a higher frequency, call the [DescribeRefreshTaskById](~~187709~~) operation. This operation allows you to query tasks by task ID.
 *
 * @param request DescribeRefreshTasksRequest
 * @return DescribeRefreshTasksResponse
 */
func (client *Client) DescribeRefreshTasks(request *DescribeRefreshTasksRequest) (_result *DescribeRefreshTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRefreshTasksResponse{}
	_body, _err := client.DescribeRefreshTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >The maximum number of times that each user can call this operation per second is 30.
 *
 * @param request DescribeStagingIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStagingIpResponse
 */
func (client *Client) DescribeStagingIpWithOptions(runtime *util.RuntimeOptions) (_result *DescribeStagingIpResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeStagingIp"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeStagingIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >The maximum number of times that each user can call this operation per second is 30.
 *
 * @return DescribeStagingIpResponse
 */
func (client *Client) DescribeStagingIp() (_result *DescribeStagingIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeStagingIpResponse{}
	_body, _err := client.DescribeStagingIpWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 10.
 *
 * @param request DescribeTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagResourcesResponse
 */
func (client *Client) DescribeTagResourcesWithOptions(request *DescribeTagResourcesRequest, runtime *util.RuntimeOptions) (_result *DescribeTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTagResources"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 10.
 *
 * @param request DescribeTagResourcesRequest
 * @return DescribeTagResourcesResponse
 */
func (client *Client) DescribeTagResources(request *DescribeTagResourcesRequest) (_result *DescribeTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagResourcesResponse{}
	_body, _err := client.DescribeTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the current month. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeTopDomainsByFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTopDomainsByFlowResponse
 */
func (client *Client) DescribeTopDomainsByFlowWithOptions(request *DescribeTopDomainsByFlowRequest, runtime *util.RuntimeOptions) (_result *DescribeTopDomainsByFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Limit)) {
		query["Limit"] = request.Limit
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTopDomainsByFlow"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTopDomainsByFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The statistical analysis feature of Alibaba Cloud CDN is no longer available. The API operations related to the statistical analysis feature are no longer maintained. We recommend that you do not use the API operations because data may be missing or inaccurate. You can use the [operations report](~~279577~~) feature for data analysis.
 * > *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the current month. If you set both these parameters, the request returns the data collected within the specified time range.
 * >*   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeTopDomainsByFlowRequest
 * @return DescribeTopDomainsByFlowResponse
 */
func (client *Client) DescribeTopDomainsByFlow(request *DescribeTopDomainsByFlowRequest) (_result *DescribeTopDomainsByFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTopDomainsByFlowResponse{}
	_body, _err := client.DescribeTopDomainsByFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeUserCertificateExpireCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserCertificateExpireCountResponse
 */
func (client *Client) DescribeUserCertificateExpireCountWithOptions(runtime *util.RuntimeOptions) (_result *DescribeUserCertificateExpireCountResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserCertificateExpireCount"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserCertificateExpireCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return DescribeUserCertificateExpireCountResponse
 */
func (client *Client) DescribeUserCertificateExpireCount() (_result *DescribeUserCertificateExpireCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserCertificateExpireCountResponse{}
	_body, _err := client.DescribeUserCertificateExpireCountWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeUserConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserConfigsResponse
 */
// Deprecated
func (client *Client) DescribeUserConfigsWithOptions(request *DescribeUserConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeUserConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserConfigs"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DescribeUserConfigsRequest
 * @return DescribeUserConfigsResponse
 */
// Deprecated
func (client *Client) DescribeUserConfigs(request *DescribeUserConfigsRequest) (_result *DescribeUserConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserConfigsResponse{}
	_body, _err := client.DescribeUserConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 100 times per second per account.
 * *   You can specify up to 50 domain names in each request. Separate multiple domain names with commas (,).
 *
 * @param request DescribeUserDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserDomainsResponse
 */
func (client *Client) DescribeUserDomainsWithOptions(request *DescribeUserDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeUserDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdnType)) {
		query["CdnType"] = request.CdnType
	}

	if !tea.BoolValue(util.IsUnset(request.ChangeEndTime)) {
		query["ChangeEndTime"] = request.ChangeEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ChangeStartTime)) {
		query["ChangeStartTime"] = request.ChangeStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.CheckDomainShow)) {
		query["CheckDomainShow"] = request.CheckDomainShow
	}

	if !tea.BoolValue(util.IsUnset(request.Coverage)) {
		query["Coverage"] = request.Coverage
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainSearchType)) {
		query["DomainSearchType"] = request.DomainSearchType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainStatus)) {
		query["DomainStatus"] = request.DomainStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["Source"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserDomains"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 100 times per second per account.
 * *   You can specify up to 50 domain names in each request. Separate multiple domain names with commas (,).
 *
 * @param request DescribeUserDomainsRequest
 * @return DescribeUserDomainsResponse
 */
func (client *Client) DescribeUserDomains(request *DescribeUserDomainsRequest) (_result *DescribeUserDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserDomainsResponse{}
	_body, _err := client.DescribeUserDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeUserTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserTagsResponse
 */
func (client *Client) DescribeUserTagsWithOptions(runtime *util.RuntimeOptions) (_result *DescribeUserTagsResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserTags"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return DescribeUserTagsResponse
 */
func (client *Client) DescribeUserTags() (_result *DescribeUserTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserTagsResponse{}
	_body, _err := client.DescribeUserTagsWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeUserUsageDataExportTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserUsageDataExportTaskResponse
 */
func (client *Client) DescribeUserUsageDataExportTaskWithOptions(request *DescribeUserUsageDataExportTaskRequest, runtime *util.RuntimeOptions) (_result *DescribeUserUsageDataExportTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserUsageDataExportTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserUsageDataExportTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeUserUsageDataExportTaskRequest
 * @return DescribeUserUsageDataExportTaskResponse
 */
func (client *Client) DescribeUserUsageDataExportTask(request *DescribeUserUsageDataExportTaskRequest) (_result *DescribeUserUsageDataExportTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserUsageDataExportTaskResponse{}
	_body, _err := client.DescribeUserUsageDataExportTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation has been available since July 20, 2018. You can query information about resource usage collected within the last three months.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeUserUsageDetailDataExportTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserUsageDetailDataExportTaskResponse
 */
func (client *Client) DescribeUserUsageDetailDataExportTaskWithOptions(request *DescribeUserUsageDetailDataExportTaskRequest, runtime *util.RuntimeOptions) (_result *DescribeUserUsageDetailDataExportTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserUsageDetailDataExportTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserUsageDetailDataExportTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation has been available since July 20, 2018. You can query information about resource usage collected within the last three months.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeUserUsageDetailDataExportTaskRequest
 * @return DescribeUserUsageDetailDataExportTaskResponse
 */
func (client *Client) DescribeUserUsageDetailDataExportTask(request *DescribeUserUsageDetailDataExportTaskRequest) (_result *DescribeUserUsageDetailDataExportTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserUsageDetailDataExportTaskResponse{}
	_body, _err := client.DescribeUserUsageDetailDataExportTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeUserVipsByDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserVipsByDomainResponse
 */
func (client *Client) DescribeUserVipsByDomainWithOptions(request *DescribeUserVipsByDomainRequest, runtime *util.RuntimeOptions) (_result *DescribeUserVipsByDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserVipsByDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserVipsByDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeUserVipsByDomainRequest
 * @return DescribeUserVipsByDomainResponse
 */
func (client *Client) DescribeUserVipsByDomain(request *DescribeUserVipsByDomainRequest) (_result *DescribeUserVipsByDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserVipsByDomainResponse{}
	_body, _err := client.DescribeUserVipsByDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVerifyContentWithOptions(request *DescribeVerifyContentRequest, runtime *util.RuntimeOptions) (_result *DescribeVerifyContentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVerifyContent"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVerifyContentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVerifyContent(request *DescribeVerifyContentRequest) (_result *DescribeVerifyContentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVerifyContentResponse{}
	_body, _err := client.DescribeVerifyContentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request DisableRealtimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableRealtimeLogDeliveryResponse
 */
func (client *Client) DisableRealtimeLogDeliveryWithOptions(request *DisableRealtimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *DisableRealtimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableRealtimeLogDelivery"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableRealtimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request DisableRealtimeLogDeliveryRequest
 * @return DisableRealtimeLogDeliveryResponse
 */
func (client *Client) DisableRealtimeLogDelivery(request *DisableRealtimeLogDeliveryRequest) (_result *DisableRealtimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableRealtimeLogDeliveryResponse{}
	_body, _err := client.DisableRealtimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request EnableRealtimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableRealtimeLogDeliveryResponse
 */
func (client *Client) EnableRealtimeLogDeliveryWithOptions(request *EnableRealtimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *EnableRealtimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableRealtimeLogDelivery"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableRealtimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request EnableRealtimeLogDeliveryRequest
 * @return EnableRealtimeLogDeliveryResponse
 */
func (client *Client) EnableRealtimeLogDelivery(request *EnableRealtimeLogDeliveryRequest) (_result *EnableRealtimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableRealtimeLogDeliveryResponse{}
	_body, _err := client.EnableRealtimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListDomainsByLogConfigIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDomainsByLogConfigIdResponse
 */
func (client *Client) ListDomainsByLogConfigIdWithOptions(request *ListDomainsByLogConfigIdRequest, runtime *util.RuntimeOptions) (_result *ListDomainsByLogConfigIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDomainsByLogConfigId"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDomainsByLogConfigIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListDomainsByLogConfigIdRequest
 * @return ListDomainsByLogConfigIdResponse
 */
func (client *Client) ListDomainsByLogConfigId(request *ListDomainsByLogConfigIdRequest) (_result *ListDomainsByLogConfigIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDomainsByLogConfigIdResponse{}
	_body, _err := client.ListDomainsByLogConfigIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListFCTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFCTriggerResponse
 */
func (client *Client) ListFCTriggerWithOptions(request *ListFCTriggerRequest, runtime *util.RuntimeOptions) (_result *ListFCTriggerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFCTrigger"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFCTriggerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListFCTriggerRequest
 * @return ListFCTriggerResponse
 */
func (client *Client) ListFCTrigger(request *ListFCTriggerRequest) (_result *ListFCTriggerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFCTriggerResponse{}
	_body, _err := client.ListFCTriggerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListRealtimeLogDeliveryDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRealtimeLogDeliveryDomainsResponse
 */
func (client *Client) ListRealtimeLogDeliveryDomainsWithOptions(request *ListRealtimeLogDeliveryDomainsRequest, runtime *util.RuntimeOptions) (_result *ListRealtimeLogDeliveryDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRealtimeLogDeliveryDomains"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRealtimeLogDeliveryDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListRealtimeLogDeliveryDomainsRequest
 * @return ListRealtimeLogDeliveryDomainsResponse
 */
func (client *Client) ListRealtimeLogDeliveryDomains(request *ListRealtimeLogDeliveryDomainsRequest) (_result *ListRealtimeLogDeliveryDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRealtimeLogDeliveryDomainsResponse{}
	_body, _err := client.ListRealtimeLogDeliveryDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListRealtimeLogDeliveryInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRealtimeLogDeliveryInfosResponse
 */
func (client *Client) ListRealtimeLogDeliveryInfosWithOptions(runtime *util.RuntimeOptions) (_result *ListRealtimeLogDeliveryInfosResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("ListRealtimeLogDeliveryInfos"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRealtimeLogDeliveryInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return ListRealtimeLogDeliveryInfosResponse
 */
func (client *Client) ListRealtimeLogDeliveryInfos() (_result *ListRealtimeLogDeliveryInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRealtimeLogDeliveryInfosResponse{}
	_body, _err := client.ListRealtimeLogDeliveryInfosWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListUserCustomLogConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserCustomLogConfigResponse
 */
func (client *Client) ListUserCustomLogConfigWithOptions(runtime *util.RuntimeOptions) (_result *ListUserCustomLogConfigResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("ListUserCustomLogConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListUserCustomLogConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return ListUserCustomLogConfigResponse
 */
func (client *Client) ListUserCustomLogConfig() (_result *ListUserCustomLogConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListUserCustomLogConfigResponse{}
	_body, _err := client.ListUserCustomLogConfigWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request ModifyCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCdnDomainResponse
 */
func (client *Client) ModifyCdnDomainWithOptions(request *ModifyCdnDomainRequest, runtime *util.RuntimeOptions) (_result *ModifyCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request ModifyCdnDomainRequest
 * @return ModifyCdnDomainResponse
 */
func (client *Client) ModifyCdnDomain(request *ModifyCdnDomainRequest) (_result *ModifyCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCdnDomainResponse{}
	_body, _err := client.ModifyCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ModifyCdnDomainSchdmByPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCdnDomainSchdmByPropertyResponse
 */
func (client *Client) ModifyCdnDomainSchdmByPropertyWithOptions(request *ModifyCdnDomainSchdmByPropertyRequest, runtime *util.RuntimeOptions) (_result *ModifyCdnDomainSchdmByPropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Property)) {
		query["Property"] = request.Property
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCdnDomainSchdmByProperty"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCdnDomainSchdmByPropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ModifyCdnDomainSchdmByPropertyRequest
 * @return ModifyCdnDomainSchdmByPropertyResponse
 */
func (client *Client) ModifyCdnDomainSchdmByProperty(request *ModifyCdnDomainSchdmByPropertyRequest) (_result *ModifyCdnDomainSchdmByPropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCdnDomainSchdmByPropertyResponse{}
	_body, _err := client.ModifyCdnDomainSchdmByPropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ModifyRealtimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRealtimeLogDeliveryResponse
 */
func (client *Client) ModifyRealtimeLogDeliveryWithOptions(request *ModifyRealtimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *ModifyRealtimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyRealtimeLogDelivery"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyRealtimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ModifyRealtimeLogDeliveryRequest
 * @return ModifyRealtimeLogDeliveryResponse
 */
func (client *Client) ModifyRealtimeLogDelivery(request *ModifyRealtimeLogDeliveryRequest) (_result *ModifyRealtimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyRealtimeLogDeliveryResponse{}
	_body, _err := client.ModifyRealtimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Alibaba Cloud CDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must complete real-name verification to activate Alibaba Cloud CDN.
 * *   You can call this operation up to five times per second per user.
 *
 * @param request OpenCdnServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenCdnServiceResponse
 */
func (client *Client) OpenCdnServiceWithOptions(request *OpenCdnServiceRequest, runtime *util.RuntimeOptions) (_result *OpenCdnServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenCdnService"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenCdnServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Alibaba Cloud CDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must complete real-name verification to activate Alibaba Cloud CDN.
 * *   You can call this operation up to five times per second per user.
 *
 * @param request OpenCdnServiceRequest
 * @return OpenCdnServiceResponse
 */
func (client *Client) OpenCdnService(request *OpenCdnServiceRequest) (_result *OpenCdnServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenCdnServiceResponse{}
	_body, _err := client.OpenCdnServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request PublishStagingConfigToProductionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishStagingConfigToProductionResponse
 */
func (client *Client) PublishStagingConfigToProductionWithOptions(request *PublishStagingConfigToProductionRequest, runtime *util.RuntimeOptions) (_result *PublishStagingConfigToProductionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishStagingConfigToProduction"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishStagingConfigToProductionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request PublishStagingConfigToProductionRequest
 * @return PublishStagingConfigToProductionResponse
 */
func (client *Client) PublishStagingConfigToProduction(request *PublishStagingConfigToProductionRequest) (_result *PublishStagingConfigToProductionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishStagingConfigToProductionResponse{}
	_body, _err := client.PublishStagingConfigToProductionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Alibaba Cloud CDN supports POST requests in which parameters are sent as a form.
 * *   You can call the [RefreshObjectCaches](~~91164~~) operation to refresh content and call the [PushObjectCache](~~91161~~) operation to prefetch content.
 * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
 * *   You can specify at most 100 URLs in each prefetch request.
 * *   For each Alibaba Cloud account, the prefetch queue can contain up to 50,000 URLs. Content is prefetched based on the time when the URLs are submitted. The URL that is submitted the earliest has the highest priority. If the number of URLs in the queue reaches 50,000, you cannot submit more URLs until the number drops below 50,000.
 * *   You can call this operation up to 50 times per second per account.
 * *   For more information about how to automate refresh or prefetch tasks, see [Run scripts to refresh and prefetch content](~~151829~~).
 * ## Precautions
 * *   After a prefetch task is submitted and completed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
 * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks require 5 to 30 minutes to complete. A task with a smaller average file size requires less time.
 * *   To allow RAM users to perform this operation, you must first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~260300~~).
 *
 * @param request PushObjectCacheRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushObjectCacheResponse
 */
func (client *Client) PushObjectCacheWithOptions(request *PushObjectCacheRequest, runtime *util.RuntimeOptions) (_result *PushObjectCacheResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.L2Preload)) {
		query["L2Preload"] = request.L2Preload
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.WithHeader)) {
		query["WithHeader"] = request.WithHeader
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PushObjectCache"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PushObjectCacheResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Alibaba Cloud CDN supports POST requests in which parameters are sent as a form.
 * *   You can call the [RefreshObjectCaches](~~91164~~) operation to refresh content and call the [PushObjectCache](~~91161~~) operation to prefetch content.
 * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
 * *   You can specify at most 100 URLs in each prefetch request.
 * *   For each Alibaba Cloud account, the prefetch queue can contain up to 50,000 URLs. Content is prefetched based on the time when the URLs are submitted. The URL that is submitted the earliest has the highest priority. If the number of URLs in the queue reaches 50,000, you cannot submit more URLs until the number drops below 50,000.
 * *   You can call this operation up to 50 times per second per account.
 * *   For more information about how to automate refresh or prefetch tasks, see [Run scripts to refresh and prefetch content](~~151829~~).
 * ## Precautions
 * *   After a prefetch task is submitted and completed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
 * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks require 5 to 30 minutes to complete. A task with a smaller average file size requires less time.
 * *   To allow RAM users to perform this operation, you must first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~260300~~).
 *
 * @param request PushObjectCacheRequest
 * @return PushObjectCacheResponse
 */
func (client *Client) PushObjectCache(request *PushObjectCacheRequest) (_result *PushObjectCacheResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PushObjectCacheResponse{}
	_body, _err := client.PushObjectCacheWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Alibaba Cloud CDN supports POST requests in which parameters are sent as a form.
 * *   You can call the [RefreshObjectCaches](~~91164~~) operation to refresh content and call the [PushObjectCache](~~91161~~) operation to prefetch content.
 * *   You can call the RefreshObjectCaches operation up to 50 times per second per account.
 * *   For more information about how to automatically refresh or prefetch tasks, see [Run scripts to refresh and prefetch content](~~151829~~).
 * ## Precautions
 * *   After a refresh task is submitted and completed, specific resources are removed from POPs. When a POP receives a request for the removed resources, the POP forwards the request to the origin server to retrieve the resources. The retrieved resources are returned to the client and cached on the POP. Multiple refresh tasks may cause a large number of resources to be removed from the POPs. This increases the number of requests that are forwarded to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
 * *   A refresh task takes effect 5 to 6 minutes after being submitted. This means that if the resource you want to refresh has a TTL of less than five minutes, you wait for it to expire instead of manually running a refresh task.
 * *   If you want to use RAM users to refresh or prefetch resources, you must obtain the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~260300~~).
 * ### Refresh quota
 * *   By default, each Alibaba Cloud account can refresh content from up to 10,000 URLs and 100 directories per day. The directories include subdirectories. If the daily peak bandwidth value exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to request a quota increase. Alibaba Cloud CDN evaluates your application based on your workloads.
 * *   By default, each Alibaba Cloud account can submit up to 20 refresh rules that contain regular expressions per day. If the daily peak bandwidth of your Alibaba Cloud account exceeds 10 Gbit/s, you can [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to request a quota increase.
 * *   You can specify up to 1,000 URL refresh rules, 100 directory refresh rules, or 1 refresh rule that contains regular expressions in each call.
 * *   You can refresh up to 1,000 URLs per minute for each domain name.
 *
 * @param request RefreshObjectCachesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshObjectCachesResponse
 */
func (client *Client) RefreshObjectCachesWithOptions(request *RefreshObjectCachesRequest, runtime *util.RuntimeOptions) (_result *RefreshObjectCachesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshObjectCaches"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshObjectCachesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Alibaba Cloud CDN supports POST requests in which parameters are sent as a form.
 * *   You can call the [RefreshObjectCaches](~~91164~~) operation to refresh content and call the [PushObjectCache](~~91161~~) operation to prefetch content.
 * *   You can call the RefreshObjectCaches operation up to 50 times per second per account.
 * *   For more information about how to automatically refresh or prefetch tasks, see [Run scripts to refresh and prefetch content](~~151829~~).
 * ## Precautions
 * *   After a refresh task is submitted and completed, specific resources are removed from POPs. When a POP receives a request for the removed resources, the POP forwards the request to the origin server to retrieve the resources. The retrieved resources are returned to the client and cached on the POP. Multiple refresh tasks may cause a large number of resources to be removed from the POPs. This increases the number of requests that are forwarded to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
 * *   A refresh task takes effect 5 to 6 minutes after being submitted. This means that if the resource you want to refresh has a TTL of less than five minutes, you wait for it to expire instead of manually running a refresh task.
 * *   If you want to use RAM users to refresh or prefetch resources, you must obtain the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~260300~~).
 * ### Refresh quota
 * *   By default, each Alibaba Cloud account can refresh content from up to 10,000 URLs and 100 directories per day. The directories include subdirectories. If the daily peak bandwidth value exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to request a quota increase. Alibaba Cloud CDN evaluates your application based on your workloads.
 * *   By default, each Alibaba Cloud account can submit up to 20 refresh rules that contain regular expressions per day. If the daily peak bandwidth of your Alibaba Cloud account exceeds 10 Gbit/s, you can [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to request a quota increase.
 * *   You can specify up to 1,000 URL refresh rules, 100 directory refresh rules, or 1 refresh rule that contains regular expressions in each call.
 * *   You can refresh up to 1,000 URLs per minute for each domain name.
 *
 * @param request RefreshObjectCachesRequest
 * @return RefreshObjectCachesResponse
 */
func (client *Client) RefreshObjectCaches(request *RefreshObjectCachesRequest) (_result *RefreshObjectCachesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshObjectCachesResponse{}
	_body, _err := client.RefreshObjectCachesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request RollbackStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RollbackStagingConfigResponse
 */
func (client *Client) RollbackStagingConfigWithOptions(request *RollbackStagingConfigRequest, runtime *util.RuntimeOptions) (_result *RollbackStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RollbackStagingConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RollbackStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request RollbackStagingConfigRequest
 * @return RollbackStagingConfigResponse
 */
func (client *Client) RollbackStagingConfig(request *RollbackStagingConfigRequest) (_result *RollbackStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RollbackStagingConfigResponse{}
	_body, _err := client.RollbackStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request SetCdnDomainCSRCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetCdnDomainCSRCertificateResponse
 */
func (client *Client) SetCdnDomainCSRCertificateWithOptions(request *SetCdnDomainCSRCertificateRequest, runtime *util.RuntimeOptions) (_result *SetCdnDomainCSRCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificate)) {
		query["ServerCertificate"] = request.ServerCertificate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCdnDomainCSRCertificate"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetCdnDomainCSRCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request SetCdnDomainCSRCertificateRequest
 * @return SetCdnDomainCSRCertificateResponse
 */
func (client *Client) SetCdnDomainCSRCertificate(request *SetCdnDomainCSRCertificateRequest) (_result *SetCdnDomainCSRCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCdnDomainCSRCertificateResponse{}
	_body, _err := client.SetCdnDomainCSRCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetCdnDomainSMCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetCdnDomainSMCertificateResponse
 */
func (client *Client) SetCdnDomainSMCertificateWithOptions(request *SetCdnDomainSMCertificateRequest, runtime *util.RuntimeOptions) (_result *SetCdnDomainSMCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCdnDomainSMCertificate"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetCdnDomainSMCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetCdnDomainSMCertificateRequest
 * @return SetCdnDomainSMCertificateResponse
 */
func (client *Client) SetCdnDomainSMCertificate(request *SetCdnDomainSMCertificateRequest) (_result *SetCdnDomainSMCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCdnDomainSMCertificateResponse{}
	_body, _err := client.SetCdnDomainSMCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 * *   Method: POST.
 *
 * @param request SetCdnDomainSSLCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetCdnDomainSSLCertificateResponse
 */
func (client *Client) SetCdnDomainSSLCertificateWithOptions(request *SetCdnDomainSSLCertificateRequest, runtime *util.RuntimeOptions) (_result *SetCdnDomainSSLCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertId)) {
		query["CertId"] = request.CertId
	}

	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertRegion)) {
		query["CertRegion"] = request.CertRegion
	}

	if !tea.BoolValue(util.IsUnset(request.CertType)) {
		query["CertType"] = request.CertType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCdnDomainSSLCertificate"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetCdnDomainSSLCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 30 times per second per account.
 * *   Method: POST.
 *
 * @param request SetCdnDomainSSLCertificateRequest
 * @return SetCdnDomainSSLCertificateResponse
 */
func (client *Client) SetCdnDomainSSLCertificate(request *SetCdnDomainSSLCertificateRequest) (_result *SetCdnDomainSSLCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCdnDomainSSLCertificateResponse{}
	_body, _err := client.SetCdnDomainSSLCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request SetCdnDomainStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetCdnDomainStagingConfigResponse
 */
func (client *Client) SetCdnDomainStagingConfigWithOptions(request *SetCdnDomainStagingConfigRequest, runtime *util.RuntimeOptions) (_result *SetCdnDomainStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Functions)) {
		query["Functions"] = request.Functions
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCdnDomainStagingConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetCdnDomainStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request SetCdnDomainStagingConfigRequest
 * @return SetCdnDomainStagingConfigResponse
 */
func (client *Client) SetCdnDomainStagingConfig(request *SetCdnDomainStagingConfigRequest) (_result *SetCdnDomainStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCdnDomainStagingConfigResponse{}
	_body, _err := client.SetCdnDomainStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per user.
 * *   Method: POST.
 *
 * @param request SetDomainServerCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDomainServerCertificateResponse
 */
func (client *Client) SetDomainServerCertificateWithOptions(request *SetDomainServerCertificateRequest, runtime *util.RuntimeOptions) (_result *SetDomainServerCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertType)) {
		query["CertType"] = request.CertType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ForceSet)) {
		query["ForceSet"] = request.ForceSet
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateKey)) {
		query["PrivateKey"] = request.PrivateKey
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificate)) {
		query["ServerCertificate"] = request.ServerCertificate
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateStatus)) {
		query["ServerCertificateStatus"] = request.ServerCertificateStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDomainServerCertificate"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDomainServerCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per user.
 * *   Method: POST.
 *
 * @param request SetDomainServerCertificateRequest
 * @return SetDomainServerCertificateResponse
 */
func (client *Client) SetDomainServerCertificate(request *SetDomainServerCertificateRequest) (_result *SetDomainServerCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDomainServerCertificateResponse{}
	_body, _err := client.SetDomainServerCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetReqHeaderConfigWithOptions(request *SetReqHeaderConfigRequest, runtime *util.RuntimeOptions) (_result *SetReqHeaderConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Value)) {
		query["Value"] = request.Value
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetReqHeaderConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetReqHeaderConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetReqHeaderConfig(request *SetReqHeaderConfigRequest) (_result *SetReqHeaderConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetReqHeaderConfigResponse{}
	_body, _err := client.SetReqHeaderConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetWaitingRoomConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetWaitingRoomConfigResponse
 */
func (client *Client) SetWaitingRoomConfigWithOptions(request *SetWaitingRoomConfigRequest, runtime *util.RuntimeOptions) (_result *SetWaitingRoomConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllowPct)) {
		query["AllowPct"] = request.AllowPct
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.GapTime)) {
		query["GapTime"] = request.GapTime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxTimeWait)) {
		query["MaxTimeWait"] = request.MaxTimeWait
	}

	if !tea.BoolValue(util.IsUnset(request.WaitUri)) {
		query["WaitUri"] = request.WaitUri
	}

	if !tea.BoolValue(util.IsUnset(request.WaitUrl)) {
		query["WaitUrl"] = request.WaitUrl
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetWaitingRoomConfig"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetWaitingRoomConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetWaitingRoomConfigRequest
 * @return SetWaitingRoomConfigResponse
 */
func (client *Client) SetWaitingRoomConfig(request *SetWaitingRoomConfigRequest) (_result *SetWaitingRoomConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetWaitingRoomConfigResponse{}
	_body, _err := client.SetWaitingRoomConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If the domain name is in an invalid state or you have an overdue payment in your account, the domain name cannot be enabled.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request StartCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartCdnDomainResponse
 */
func (client *Client) StartCdnDomainWithOptions(request *StartCdnDomainRequest, runtime *util.RuntimeOptions) (_result *StartCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If the domain name is in an invalid state or you have an overdue payment in your account, the domain name cannot be enabled.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request StartCdnDomainRequest
 * @return StartCdnDomainResponse
 */
func (client *Client) StartCdnDomain(request *StartCdnDomainRequest) (_result *StartCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartCdnDomainResponse{}
	_body, _err := client.StartCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After an accelerated domain is disabled, Alibaba Cloud CDN retains its information and routes all the requests that are destined for the accelerated domain to the origin server.
 * *   You can call this operation up to 40 times per second per account.
 *
 * @param request StopCdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopCdnDomainResponse
 */
func (client *Client) StopCdnDomainWithOptions(request *StopCdnDomainRequest, runtime *util.RuntimeOptions) (_result *StopCdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopCdnDomain"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopCdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After an accelerated domain is disabled, Alibaba Cloud CDN retains its information and routes all the requests that are destined for the accelerated domain to the origin server.
 * *   You can call this operation up to 40 times per second per account.
 *
 * @param request StopCdnDomainRequest
 * @return StopCdnDomainResponse
 */
func (client *Client) StopCdnDomain(request *StopCdnDomainRequest) (_result *StopCdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopCdnDomainResponse{}
	_body, _err := client.StopCdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request UpdateCdnDeliverTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCdnDeliverTaskResponse
 */
func (client *Client) UpdateCdnDeliverTaskWithOptions(request *UpdateCdnDeliverTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateCdnDeliverTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Deliver)) {
		body["Deliver"] = request.Deliver
	}

	if !tea.BoolValue(util.IsUnset(request.DeliverId)) {
		body["DeliverId"] = request.DeliverId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Reports)) {
		body["Reports"] = request.Reports
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["Schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCdnDeliverTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCdnDeliverTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request UpdateCdnDeliverTaskRequest
 * @return UpdateCdnDeliverTaskResponse
 */
func (client *Client) UpdateCdnDeliverTask(request *UpdateCdnDeliverTaskRequest) (_result *UpdateCdnDeliverTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCdnDeliverTaskResponse{}
	_body, _err := client.UpdateCdnDeliverTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request UpdateCdnSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCdnSubTaskResponse
 */
func (client *Client) UpdateCdnSubTaskWithOptions(request *UpdateCdnSubTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateCdnSubTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ReportIds)) {
		body["ReportIds"] = request.ReportIds
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		body["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCdnSubTask"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCdnSubTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request UpdateCdnSubTaskRequest
 * @return UpdateCdnSubTaskResponse
 */
func (client *Client) UpdateCdnSubTask(request *UpdateCdnSubTaskRequest) (_result *UpdateCdnSubTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCdnSubTaskResponse{}
	_body, _err := client.UpdateCdnSubTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateFCTriggerWithOptions(request *UpdateFCTriggerRequest, runtime *util.RuntimeOptions) (_result *UpdateFCTriggerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TriggerARN)) {
		query["TriggerARN"] = request.TriggerARN
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionARN)) {
		body["FunctionARN"] = request.FunctionARN
	}

	if !tea.BoolValue(util.IsUnset(request.Notes)) {
		body["Notes"] = request.Notes
	}

	if !tea.BoolValue(util.IsUnset(request.RoleARN)) {
		body["RoleARN"] = request.RoleARN
	}

	if !tea.BoolValue(util.IsUnset(request.SourceARN)) {
		body["SourceARN"] = request.SourceARN
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateFCTrigger"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateFCTriggerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateFCTrigger(request *UpdateFCTriggerRequest) (_result *UpdateFCTriggerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateFCTriggerResponse{}
	_body, _err := client.UpdateFCTriggerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request VerifyDomainOwnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyDomainOwnerResponse
 */
func (client *Client) VerifyDomainOwnerWithOptions(request *VerifyDomainOwnerRequest, runtime *util.RuntimeOptions) (_result *VerifyDomainOwnerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalResourcePlan)) {
		query["GlobalResourcePlan"] = request.GlobalResourcePlan
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyType)) {
		query["VerifyType"] = request.VerifyType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyDomainOwner"),
		Version:     tea.String("2018-05-10"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyDomainOwnerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request VerifyDomainOwnerRequest
 * @return VerifyDomainOwnerResponse
 */
func (client *Client) VerifyDomainOwner(request *VerifyDomainOwnerRequest) (_result *VerifyDomainOwnerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyDomainOwnerResponse{}
	_body, _err := client.VerifyDomainOwnerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
