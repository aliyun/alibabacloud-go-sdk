// This file is auto-generated, don't edit it. Thanks.
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type ClientNodeConfiguration struct {
	// This parameter is required.
	Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
	// This parameter is required.
	Disk *int64 `json:"disk,omitempty" xml:"disk,omitempty"`
	// This parameter is required.
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// This parameter is required.
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s ClientNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ClientNodeConfiguration) GoString() string {
	return s.String()
}

func (s *ClientNodeConfiguration) SetAmount(v int64) *ClientNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *ClientNodeConfiguration) SetDisk(v int64) *ClientNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *ClientNodeConfiguration) SetDiskType(v string) *ClientNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *ClientNodeConfiguration) SetSpec(v string) *ClientNodeConfiguration {
	s.Spec = &v
	return s
}

type CollectorDeployMachine struct {
	// This parameter is required.
	//
	// example:
	//
	// collectorDeployMachine
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// example:
	//
	// default_ct-cn-f3t0dq5p97199ru3z
	GroupId *string `json:"groupId,omitempty" xml:"groupId,omitempty"`
	// example:
	//
	// ce93d7566df2141f490f0f60f646252c3
	InstanceId *string                           `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	Machines   []*CollectorDeployMachineMachines `json:"machines,omitempty" xml:"machines,omitempty" type:"Repeated"`
	// example:
	//
	// 1
	SuccessPodsCount *string `json:"successPodsCount,omitempty" xml:"successPodsCount,omitempty"`
	// example:
	//
	// 2
	TotalPodsCount *string `json:"totalPodsCount,omitempty" xml:"totalPodsCount,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ACKCluster
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s CollectorDeployMachine) String() string {
	return tea.Prettify(s)
}

func (s CollectorDeployMachine) GoString() string {
	return s.String()
}

func (s *CollectorDeployMachine) SetConfigType(v string) *CollectorDeployMachine {
	s.ConfigType = &v
	return s
}

func (s *CollectorDeployMachine) SetGroupId(v string) *CollectorDeployMachine {
	s.GroupId = &v
	return s
}

func (s *CollectorDeployMachine) SetInstanceId(v string) *CollectorDeployMachine {
	s.InstanceId = &v
	return s
}

func (s *CollectorDeployMachine) SetMachines(v []*CollectorDeployMachineMachines) *CollectorDeployMachine {
	s.Machines = v
	return s
}

func (s *CollectorDeployMachine) SetSuccessPodsCount(v string) *CollectorDeployMachine {
	s.SuccessPodsCount = &v
	return s
}

func (s *CollectorDeployMachine) SetTotalPodsCount(v string) *CollectorDeployMachine {
	s.TotalPodsCount = &v
	return s
}

func (s *CollectorDeployMachine) SetType(v string) *CollectorDeployMachine {
	s.Type = &v
	return s
}

type CollectorDeployMachineMachines struct {
	// example:
	//
	// UNINSTALLED
	AgentStatus *string `json:"agentStatus,omitempty" xml:"agentStatus,omitempty"`
	// example:
	//
	// i-xs34****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
}

func (s CollectorDeployMachineMachines) String() string {
	return tea.Prettify(s)
}

func (s CollectorDeployMachineMachines) GoString() string {
	return s.String()
}

func (s *CollectorDeployMachineMachines) SetAgentStatus(v string) *CollectorDeployMachineMachines {
	s.AgentStatus = &v
	return s
}

func (s *CollectorDeployMachineMachines) SetInstanceId(v string) *CollectorDeployMachineMachines {
	s.InstanceId = &v
	return s
}

type CollectorKibanaInstance struct {
	// This parameter is required.
	//
	// example:
	//
	// collectorElasticsearchForKibana
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// es-cn-*****-kibana.internal.elasticsearch.aliyuncs.com:5601
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// es-cn-45dfy****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// https://es-cn-****.kibana.elasticsearch.aliyuncs.com:5601
	KibanaHost *string `json:"kibanaHost,omitempty" xml:"kibanaHost,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// password
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// username
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s CollectorKibanaInstance) String() string {
	return tea.Prettify(s)
}

func (s CollectorKibanaInstance) GoString() string {
	return s.String()
}

func (s *CollectorKibanaInstance) SetConfigType(v string) *CollectorKibanaInstance {
	s.ConfigType = &v
	return s
}

func (s *CollectorKibanaInstance) SetHost(v string) *CollectorKibanaInstance {
	s.Host = &v
	return s
}

func (s *CollectorKibanaInstance) SetInstanceId(v string) *CollectorKibanaInstance {
	s.InstanceId = &v
	return s
}

func (s *CollectorKibanaInstance) SetKibanaHost(v string) *CollectorKibanaInstance {
	s.KibanaHost = &v
	return s
}

func (s *CollectorKibanaInstance) SetPassword(v string) *CollectorKibanaInstance {
	s.Password = &v
	return s
}

func (s *CollectorKibanaInstance) SetProtocol(v string) *CollectorKibanaInstance {
	s.Protocol = &v
	return s
}

func (s *CollectorKibanaInstance) SetUserName(v string) *CollectorKibanaInstance {
	s.UserName = &v
	return s
}

type CollectorTargetInstance struct {
	// This parameter is required.
	//
	// example:
	//
	// collectorTargetInstance
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// false
	EnableMonitoring *bool     `json:"enableMonitoring,omitempty" xml:"enableMonitoring,omitempty"`
	Hosts            []*string `json:"hosts,omitempty" xml:"hosts,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// es-cn-ks8x****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// elasticsearch
	InstanceType *string `json:"instanceType,omitempty" xml:"instanceType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// password
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// username
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s CollectorTargetInstance) String() string {
	return tea.Prettify(s)
}

func (s CollectorTargetInstance) GoString() string {
	return s.String()
}

func (s *CollectorTargetInstance) SetConfigType(v string) *CollectorTargetInstance {
	s.ConfigType = &v
	return s
}

func (s *CollectorTargetInstance) SetEnableMonitoring(v bool) *CollectorTargetInstance {
	s.EnableMonitoring = &v
	return s
}

func (s *CollectorTargetInstance) SetHosts(v []*string) *CollectorTargetInstance {
	s.Hosts = v
	return s
}

func (s *CollectorTargetInstance) SetInstanceId(v string) *CollectorTargetInstance {
	s.InstanceId = &v
	return s
}

func (s *CollectorTargetInstance) SetInstanceType(v string) *CollectorTargetInstance {
	s.InstanceType = &v
	return s
}

func (s *CollectorTargetInstance) SetPassword(v string) *CollectorTargetInstance {
	s.Password = &v
	return s
}

func (s *CollectorTargetInstance) SetProtocol(v string) *CollectorTargetInstance {
	s.Protocol = &v
	return s
}

func (s *CollectorTargetInstance) SetUserName(v string) *CollectorTargetInstance {
	s.UserName = &v
	return s
}

type DictInfo struct {
	FileSize   *int64  `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	Name       *string `json:"name,omitempty" xml:"name,omitempty"`
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	Type       *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s DictInfo) String() string {
	return tea.Prettify(s)
}

func (s DictInfo) GoString() string {
	return s.String()
}

func (s *DictInfo) SetFileSize(v int64) *DictInfo {
	s.FileSize = &v
	return s
}

func (s *DictInfo) SetName(v string) *DictInfo {
	s.Name = &v
	return s
}

func (s *DictInfo) SetSourceType(v string) *DictInfo {
	s.SourceType = &v
	return s
}

func (s *DictInfo) SetType(v string) *DictInfo {
	s.Type = &v
	return s
}

type ElasticDataNodeConfiguration struct {
	Amount           *int64  `json:"amount,omitempty" xml:"amount,omitempty"`
	Disk             *int64  `json:"disk,omitempty" xml:"disk,omitempty"`
	DiskEncryption   *bool   `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	DiskType         *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	PerformanceLevel *string `json:"performanceLevel,omitempty" xml:"performanceLevel,omitempty"`
	// This parameter is required.
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s ElasticDataNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ElasticDataNodeConfiguration) GoString() string {
	return s.String()
}

func (s *ElasticDataNodeConfiguration) SetAmount(v int64) *ElasticDataNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *ElasticDataNodeConfiguration) SetDisk(v int64) *ElasticDataNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *ElasticDataNodeConfiguration) SetDiskEncryption(v bool) *ElasticDataNodeConfiguration {
	s.DiskEncryption = &v
	return s
}

func (s *ElasticDataNodeConfiguration) SetDiskType(v string) *ElasticDataNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *ElasticDataNodeConfiguration) SetPerformanceLevel(v string) *ElasticDataNodeConfiguration {
	s.PerformanceLevel = &v
	return s
}

func (s *ElasticDataNodeConfiguration) SetSpec(v string) *ElasticDataNodeConfiguration {
	s.Spec = &v
	return s
}

type Elasticsearch struct {
	AdvancedDedicateMaster       *bool                         `json:"advancedDedicateMaster,omitempty" xml:"advancedDedicateMaster,omitempty"`
	AdvancedSetting              *ElasticsearchAdvancedSetting `json:"advancedSetting,omitempty" xml:"advancedSetting,omitempty" type:"Struct"`
	AliwsDicts                   []*DictInfo                   `json:"aliwsDicts,omitempty" xml:"aliwsDicts,omitempty" type:"Repeated"`
	ClientNodeConfiguration      *ClientNodeConfiguration      `json:"clientNodeConfiguration,omitempty" xml:"clientNodeConfiguration,omitempty"`
	CreatedAt                    *string                       `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	DataNode                     *bool                         `json:"dataNode,omitempty" xml:"dataNode,omitempty"`
	DedicateMaster               *bool                         `json:"dedicateMaster,omitempty" xml:"dedicateMaster,omitempty"`
	Description                  *string                       `json:"description,omitempty" xml:"description,omitempty"`
	DictList                     []*DictInfo                   `json:"dictList,omitempty" xml:"dictList,omitempty" type:"Repeated"`
	Domain                       *string                       `json:"domain,omitempty" xml:"domain,omitempty"`
	ElasticDataNodeConfiguration *ElasticDataNodeConfiguration `json:"elasticDataNodeConfiguration,omitempty" xml:"elasticDataNodeConfiguration,omitempty"`
	EnableKibanaPrivateNetwork   *bool                         `json:"enableKibanaPrivateNetwork,omitempty" xml:"enableKibanaPrivateNetwork,omitempty"`
	EnableKibanaPublicNetwork    *bool                         `json:"enableKibanaPublicNetwork,omitempty" xml:"enableKibanaPublicNetwork,omitempty"`
	EnablePublic                 *bool                         `json:"enablePublic,omitempty" xml:"enablePublic,omitempty"`
	EndTime                      *int64                        `json:"endTime,omitempty" xml:"endTime,omitempty"`
	EsConfig                     map[string]*string            `json:"esConfig,omitempty" xml:"esConfig,omitempty"`
	EsIPWhitelist                []*string                     `json:"esIPWhitelist,omitempty" xml:"esIPWhitelist,omitempty" type:"Repeated"`
	EsVersion                    *string                       `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	ExtendConfigs                []map[string]interface{}      `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	HaveClientNode               *bool                         `json:"haveClientNode,omitempty" xml:"haveClientNode,omitempty"`
	HaveElasticDataNode          *bool                         `json:"haveElasticDataNode,omitempty" xml:"haveElasticDataNode,omitempty"`
	HaveKibana                   *bool                         `json:"haveKibana,omitempty" xml:"haveKibana,omitempty"`
	IkHotDicts                   []*DictInfo                   `json:"ikHotDicts,omitempty" xml:"ikHotDicts,omitempty" type:"Repeated"`
	InstanceId                   *string                       `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	KibanaConfiguration          *KibanaNodeConfiguration      `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty"`
	KibanaDomain                 *string                       `json:"kibanaDomain,omitempty" xml:"kibanaDomain,omitempty"`
	KibanaIPWhitelist            []*string                     `json:"kibanaIPWhitelist,omitempty" xml:"kibanaIPWhitelist,omitempty" type:"Repeated"`
	KibanaPort                   *int64                        `json:"kibanaPort,omitempty" xml:"kibanaPort,omitempty"`
	KibanaPrivateDomain          *string                       `json:"kibanaPrivateDomain,omitempty" xml:"kibanaPrivateDomain,omitempty"`
	KibanaPrivateIPWhitelist     []*string                     `json:"kibanaPrivateIPWhitelist,omitempty" xml:"kibanaPrivateIPWhitelist,omitempty" type:"Repeated"`
	KibanaPrivatePort            *int64                        `json:"kibanaPrivatePort,omitempty" xml:"kibanaPrivatePort,omitempty"`
	KibanaProtocol               *string                       `json:"kibanaProtocol,omitempty" xml:"kibanaProtocol,omitempty"`
	MasterConfiguration          *MasterNodeConfiguration      `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty"`
	NetworkConfig                *NetworkConfig                `json:"networkConfig,omitempty" xml:"networkConfig,omitempty"`
	NodeAmount                   *int64                        `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	NodeSpec                     *NodeSpec                     `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty"`
	PaymentType                  *string                       `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	Port                         *int64                        `json:"port,omitempty" xml:"port,omitempty"`
	PrivateNetworkIpWhiteList    []*string                     `json:"privateNetworkIpWhiteList,omitempty" xml:"privateNetworkIpWhiteList,omitempty" type:"Repeated"`
	ProductType                  *string                       `json:"productType,omitempty" xml:"productType,omitempty"`
	Protocol                     *string                       `json:"protocol,omitempty" xml:"protocol,omitempty"`
	PublicDomain                 *string                       `json:"publicDomain,omitempty" xml:"publicDomain,omitempty"`
	PublicIpWhitelist            []*string                     `json:"publicIpWhitelist,omitempty" xml:"publicIpWhitelist,omitempty" type:"Repeated"`
	PublicPort                   *int64                        `json:"publicPort,omitempty" xml:"publicPort,omitempty"`
	ReadWritePolicy              *ReadWritePolicy              `json:"readWritePolicy,omitempty" xml:"readWritePolicy,omitempty"`
	ResourceGroupId              *string                       `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	ServiceVpc                   *bool                         `json:"serviceVpc,omitempty" xml:"serviceVpc,omitempty"`
	Status                       *string                       `json:"status,omitempty" xml:"status,omitempty"`
	SynonymsDicts                []*DictInfo                   `json:"synonymsDicts,omitempty" xml:"synonymsDicts,omitempty" type:"Repeated"`
	Tags                         []*Tag                        `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	UpdatedAt                    *string                       `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	WarmNode                     *bool                         `json:"warmNode,omitempty" xml:"warmNode,omitempty"`
	WarmNodeConfiguration        *WarmNodeConfiguration        `json:"warmNodeConfiguration,omitempty" xml:"warmNodeConfiguration,omitempty"`
	ZoneCount                    *int64                        `json:"zoneCount,omitempty" xml:"zoneCount,omitempty"`
	ZoneInfos                    []*ZoneInfo                   `json:"zoneInfos,omitempty" xml:"zoneInfos,omitempty" type:"Repeated"`
}

func (s Elasticsearch) String() string {
	return tea.Prettify(s)
}

func (s Elasticsearch) GoString() string {
	return s.String()
}

func (s *Elasticsearch) SetAdvancedDedicateMaster(v bool) *Elasticsearch {
	s.AdvancedDedicateMaster = &v
	return s
}

func (s *Elasticsearch) SetAdvancedSetting(v *ElasticsearchAdvancedSetting) *Elasticsearch {
	s.AdvancedSetting = v
	return s
}

func (s *Elasticsearch) SetAliwsDicts(v []*DictInfo) *Elasticsearch {
	s.AliwsDicts = v
	return s
}

func (s *Elasticsearch) SetClientNodeConfiguration(v *ClientNodeConfiguration) *Elasticsearch {
	s.ClientNodeConfiguration = v
	return s
}

func (s *Elasticsearch) SetCreatedAt(v string) *Elasticsearch {
	s.CreatedAt = &v
	return s
}

func (s *Elasticsearch) SetDataNode(v bool) *Elasticsearch {
	s.DataNode = &v
	return s
}

func (s *Elasticsearch) SetDedicateMaster(v bool) *Elasticsearch {
	s.DedicateMaster = &v
	return s
}

func (s *Elasticsearch) SetDescription(v string) *Elasticsearch {
	s.Description = &v
	return s
}

func (s *Elasticsearch) SetDictList(v []*DictInfo) *Elasticsearch {
	s.DictList = v
	return s
}

func (s *Elasticsearch) SetDomain(v string) *Elasticsearch {
	s.Domain = &v
	return s
}

func (s *Elasticsearch) SetElasticDataNodeConfiguration(v *ElasticDataNodeConfiguration) *Elasticsearch {
	s.ElasticDataNodeConfiguration = v
	return s
}

func (s *Elasticsearch) SetEnableKibanaPrivateNetwork(v bool) *Elasticsearch {
	s.EnableKibanaPrivateNetwork = &v
	return s
}

func (s *Elasticsearch) SetEnableKibanaPublicNetwork(v bool) *Elasticsearch {
	s.EnableKibanaPublicNetwork = &v
	return s
}

func (s *Elasticsearch) SetEnablePublic(v bool) *Elasticsearch {
	s.EnablePublic = &v
	return s
}

func (s *Elasticsearch) SetEndTime(v int64) *Elasticsearch {
	s.EndTime = &v
	return s
}

func (s *Elasticsearch) SetEsConfig(v map[string]*string) *Elasticsearch {
	s.EsConfig = v
	return s
}

func (s *Elasticsearch) SetEsIPWhitelist(v []*string) *Elasticsearch {
	s.EsIPWhitelist = v
	return s
}

func (s *Elasticsearch) SetEsVersion(v string) *Elasticsearch {
	s.EsVersion = &v
	return s
}

func (s *Elasticsearch) SetExtendConfigs(v []map[string]interface{}) *Elasticsearch {
	s.ExtendConfigs = v
	return s
}

func (s *Elasticsearch) SetHaveClientNode(v bool) *Elasticsearch {
	s.HaveClientNode = &v
	return s
}

func (s *Elasticsearch) SetHaveElasticDataNode(v bool) *Elasticsearch {
	s.HaveElasticDataNode = &v
	return s
}

func (s *Elasticsearch) SetHaveKibana(v bool) *Elasticsearch {
	s.HaveKibana = &v
	return s
}

func (s *Elasticsearch) SetIkHotDicts(v []*DictInfo) *Elasticsearch {
	s.IkHotDicts = v
	return s
}

func (s *Elasticsearch) SetInstanceId(v string) *Elasticsearch {
	s.InstanceId = &v
	return s
}

func (s *Elasticsearch) SetKibanaConfiguration(v *KibanaNodeConfiguration) *Elasticsearch {
	s.KibanaConfiguration = v
	return s
}

func (s *Elasticsearch) SetKibanaDomain(v string) *Elasticsearch {
	s.KibanaDomain = &v
	return s
}

func (s *Elasticsearch) SetKibanaIPWhitelist(v []*string) *Elasticsearch {
	s.KibanaIPWhitelist = v
	return s
}

func (s *Elasticsearch) SetKibanaPort(v int64) *Elasticsearch {
	s.KibanaPort = &v
	return s
}

func (s *Elasticsearch) SetKibanaPrivateDomain(v string) *Elasticsearch {
	s.KibanaPrivateDomain = &v
	return s
}

func (s *Elasticsearch) SetKibanaPrivateIPWhitelist(v []*string) *Elasticsearch {
	s.KibanaPrivateIPWhitelist = v
	return s
}

func (s *Elasticsearch) SetKibanaPrivatePort(v int64) *Elasticsearch {
	s.KibanaPrivatePort = &v
	return s
}

func (s *Elasticsearch) SetKibanaProtocol(v string) *Elasticsearch {
	s.KibanaProtocol = &v
	return s
}

func (s *Elasticsearch) SetMasterConfiguration(v *MasterNodeConfiguration) *Elasticsearch {
	s.MasterConfiguration = v
	return s
}

func (s *Elasticsearch) SetNetworkConfig(v *NetworkConfig) *Elasticsearch {
	s.NetworkConfig = v
	return s
}

func (s *Elasticsearch) SetNodeAmount(v int64) *Elasticsearch {
	s.NodeAmount = &v
	return s
}

func (s *Elasticsearch) SetNodeSpec(v *NodeSpec) *Elasticsearch {
	s.NodeSpec = v
	return s
}

func (s *Elasticsearch) SetPaymentType(v string) *Elasticsearch {
	s.PaymentType = &v
	return s
}

func (s *Elasticsearch) SetPort(v int64) *Elasticsearch {
	s.Port = &v
	return s
}

func (s *Elasticsearch) SetPrivateNetworkIpWhiteList(v []*string) *Elasticsearch {
	s.PrivateNetworkIpWhiteList = v
	return s
}

func (s *Elasticsearch) SetProductType(v string) *Elasticsearch {
	s.ProductType = &v
	return s
}

func (s *Elasticsearch) SetProtocol(v string) *Elasticsearch {
	s.Protocol = &v
	return s
}

func (s *Elasticsearch) SetPublicDomain(v string) *Elasticsearch {
	s.PublicDomain = &v
	return s
}

func (s *Elasticsearch) SetPublicIpWhitelist(v []*string) *Elasticsearch {
	s.PublicIpWhitelist = v
	return s
}

func (s *Elasticsearch) SetPublicPort(v int64) *Elasticsearch {
	s.PublicPort = &v
	return s
}

func (s *Elasticsearch) SetReadWritePolicy(v *ReadWritePolicy) *Elasticsearch {
	s.ReadWritePolicy = v
	return s
}

func (s *Elasticsearch) SetResourceGroupId(v string) *Elasticsearch {
	s.ResourceGroupId = &v
	return s
}

func (s *Elasticsearch) SetServiceVpc(v bool) *Elasticsearch {
	s.ServiceVpc = &v
	return s
}

func (s *Elasticsearch) SetStatus(v string) *Elasticsearch {
	s.Status = &v
	return s
}

func (s *Elasticsearch) SetSynonymsDicts(v []*DictInfo) *Elasticsearch {
	s.SynonymsDicts = v
	return s
}

func (s *Elasticsearch) SetTags(v []*Tag) *Elasticsearch {
	s.Tags = v
	return s
}

func (s *Elasticsearch) SetUpdatedAt(v string) *Elasticsearch {
	s.UpdatedAt = &v
	return s
}

func (s *Elasticsearch) SetWarmNode(v bool) *Elasticsearch {
	s.WarmNode = &v
	return s
}

func (s *Elasticsearch) SetWarmNodeConfiguration(v *WarmNodeConfiguration) *Elasticsearch {
	s.WarmNodeConfiguration = v
	return s
}

func (s *Elasticsearch) SetZoneCount(v int64) *Elasticsearch {
	s.ZoneCount = &v
	return s
}

func (s *Elasticsearch) SetZoneInfos(v []*ZoneInfo) *Elasticsearch {
	s.ZoneInfos = v
	return s
}

type ElasticsearchAdvancedSetting struct {
	GcName *string `json:"gcName,omitempty" xml:"gcName,omitempty"`
}

func (s ElasticsearchAdvancedSetting) String() string {
	return tea.Prettify(s)
}

func (s ElasticsearchAdvancedSetting) GoString() string {
	return s.String()
}

func (s *ElasticsearchAdvancedSetting) SetGcName(v string) *ElasticsearchAdvancedSetting {
	s.GcName = &v
	return s
}

type KibanaNodeConfiguration struct {
	Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
	Disk   *int64 `json:"disk,omitempty" xml:"disk,omitempty"`
	// This parameter is required.
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s KibanaNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s KibanaNodeConfiguration) GoString() string {
	return s.String()
}

func (s *KibanaNodeConfiguration) SetAmount(v int64) *KibanaNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *KibanaNodeConfiguration) SetDisk(v int64) *KibanaNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *KibanaNodeConfiguration) SetSpec(v string) *KibanaNodeConfiguration {
	s.Spec = &v
	return s
}

type Logstash struct {
	Config          map[string]*string      `json:"config,omitempty" xml:"config,omitempty"`
	CreatedAt       *string                 `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	DataNode        *bool                   `json:"dataNode,omitempty" xml:"dataNode,omitempty"`
	Description     *string                 `json:"description,omitempty" xml:"description,omitempty"`
	EndTime         *int64                  `json:"endTime,omitempty" xml:"endTime,omitempty"`
	EndpointList    []*LogstashEndpointList `json:"endpointList,omitempty" xml:"endpointList,omitempty" type:"Repeated"`
	InstanceId      *string                 `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	NetworkConfig   *LogstashNetworkConfig  `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	NodeAmount      *int64                  `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	NodeSpec        *LogstashNodeSpec       `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	PaymentType     *string                 `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	Protocol        *string                 `json:"protocol,omitempty" xml:"protocol,omitempty"`
	ResourceGroupId *string                 `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	Status          *string                 `json:"status,omitempty" xml:"status,omitempty"`
	Tags            []*LogstashTags         `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	UpdatedAt       *string                 `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	Version         *string                 `json:"version,omitempty" xml:"version,omitempty"`
	ZoneCount       *int64                  `json:"zoneCount,omitempty" xml:"zoneCount,omitempty"`
	ZoneInfos       []*LogstashZoneInfos    `json:"zoneInfos,omitempty" xml:"zoneInfos,omitempty" type:"Repeated"`
}

func (s Logstash) String() string {
	return tea.Prettify(s)
}

func (s Logstash) GoString() string {
	return s.String()
}

func (s *Logstash) SetConfig(v map[string]*string) *Logstash {
	s.Config = v
	return s
}

func (s *Logstash) SetCreatedAt(v string) *Logstash {
	s.CreatedAt = &v
	return s
}

func (s *Logstash) SetDataNode(v bool) *Logstash {
	s.DataNode = &v
	return s
}

func (s *Logstash) SetDescription(v string) *Logstash {
	s.Description = &v
	return s
}

func (s *Logstash) SetEndTime(v int64) *Logstash {
	s.EndTime = &v
	return s
}

func (s *Logstash) SetEndpointList(v []*LogstashEndpointList) *Logstash {
	s.EndpointList = v
	return s
}

func (s *Logstash) SetInstanceId(v string) *Logstash {
	s.InstanceId = &v
	return s
}

func (s *Logstash) SetNetworkConfig(v *LogstashNetworkConfig) *Logstash {
	s.NetworkConfig = v
	return s
}

func (s *Logstash) SetNodeAmount(v int64) *Logstash {
	s.NodeAmount = &v
	return s
}

func (s *Logstash) SetNodeSpec(v *LogstashNodeSpec) *Logstash {
	s.NodeSpec = v
	return s
}

func (s *Logstash) SetPaymentType(v string) *Logstash {
	s.PaymentType = &v
	return s
}

func (s *Logstash) SetProtocol(v string) *Logstash {
	s.Protocol = &v
	return s
}

func (s *Logstash) SetResourceGroupId(v string) *Logstash {
	s.ResourceGroupId = &v
	return s
}

func (s *Logstash) SetStatus(v string) *Logstash {
	s.Status = &v
	return s
}

func (s *Logstash) SetTags(v []*LogstashTags) *Logstash {
	s.Tags = v
	return s
}

func (s *Logstash) SetUpdatedAt(v string) *Logstash {
	s.UpdatedAt = &v
	return s
}

func (s *Logstash) SetVersion(v string) *Logstash {
	s.Version = &v
	return s
}

func (s *Logstash) SetZoneCount(v int64) *Logstash {
	s.ZoneCount = &v
	return s
}

func (s *Logstash) SetZoneInfos(v []*LogstashZoneInfos) *Logstash {
	s.ZoneInfos = v
	return s
}

type LogstashEndpointList struct {
	Host   *string `json:"host,omitempty" xml:"host,omitempty"`
	Port   *int64  `json:"port,omitempty" xml:"port,omitempty"`
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s LogstashEndpointList) String() string {
	return tea.Prettify(s)
}

func (s LogstashEndpointList) GoString() string {
	return s.String()
}

func (s *LogstashEndpointList) SetHost(v string) *LogstashEndpointList {
	s.Host = &v
	return s
}

func (s *LogstashEndpointList) SetPort(v int64) *LogstashEndpointList {
	s.Port = &v
	return s
}

func (s *LogstashEndpointList) SetZoneId(v string) *LogstashEndpointList {
	s.ZoneId = &v
	return s
}

type LogstashNetworkConfig struct {
	Type      *string `json:"type,omitempty" xml:"type,omitempty"`
	VpcId     *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	VsArea    *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s LogstashNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s LogstashNetworkConfig) GoString() string {
	return s.String()
}

func (s *LogstashNetworkConfig) SetType(v string) *LogstashNetworkConfig {
	s.Type = &v
	return s
}

func (s *LogstashNetworkConfig) SetVpcId(v string) *LogstashNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *LogstashNetworkConfig) SetVsArea(v string) *LogstashNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *LogstashNetworkConfig) SetVswitchId(v string) *LogstashNetworkConfig {
	s.VswitchId = &v
	return s
}

type LogstashNodeSpec struct {
	Disk     *int64  `json:"disk,omitempty" xml:"disk,omitempty"`
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s LogstashNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s LogstashNodeSpec) GoString() string {
	return s.String()
}

func (s *LogstashNodeSpec) SetDisk(v int64) *LogstashNodeSpec {
	s.Disk = &v
	return s
}

func (s *LogstashNodeSpec) SetDiskType(v string) *LogstashNodeSpec {
	s.DiskType = &v
	return s
}

func (s *LogstashNodeSpec) SetSpec(v string) *LogstashNodeSpec {
	s.Spec = &v
	return s
}

type LogstashTags struct {
	TagKey   *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s LogstashTags) String() string {
	return tea.Prettify(s)
}

func (s LogstashTags) GoString() string {
	return s.String()
}

func (s *LogstashTags) SetTagKey(v string) *LogstashTags {
	s.TagKey = &v
	return s
}

func (s *LogstashTags) SetTagValue(v string) *LogstashTags {
	s.TagValue = &v
	return s
}

type LogstashZoneInfos struct {
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s LogstashZoneInfos) String() string {
	return tea.Prettify(s)
}

func (s LogstashZoneInfos) GoString() string {
	return s.String()
}

func (s *LogstashZoneInfos) SetStatus(v string) *LogstashZoneInfos {
	s.Status = &v
	return s
}

func (s *LogstashZoneInfos) SetZoneId(v string) *LogstashZoneInfos {
	s.ZoneId = &v
	return s
}

type MasterNodeConfiguration struct {
	// This parameter is required.
	Amount *int64 `json:"amount,omitempty" xml:"amount,omitempty"`
	// This parameter is required.
	Disk *int64 `json:"disk,omitempty" xml:"disk,omitempty"`
	// This parameter is required.
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// This parameter is required.
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s MasterNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s MasterNodeConfiguration) GoString() string {
	return s.String()
}

func (s *MasterNodeConfiguration) SetAmount(v int64) *MasterNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *MasterNodeConfiguration) SetDisk(v int64) *MasterNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *MasterNodeConfiguration) SetDiskType(v string) *MasterNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *MasterNodeConfiguration) SetSpec(v string) *MasterNodeConfiguration {
	s.Spec = &v
	return s
}

type MigrationJob struct {
	CurrentState             *string                     `json:"currentState,omitempty" xml:"currentState,omitempty"`
	DisableSourceClusterAuth *bool                       `json:"disableSourceClusterAuth,omitempty" xml:"disableSourceClusterAuth,omitempty"`
	DisableTargetClusterAuth *bool                       `json:"disableTargetClusterAuth,omitempty" xml:"disableTargetClusterAuth,omitempty"`
	EndTime                  *int64                      `json:"endTime,omitempty" xml:"endTime,omitempty"`
	MigrationJobId           *string                     `json:"migrationJobId,omitempty" xml:"migrationJobId,omitempty"`
	Phase                    *string                     `json:"phase,omitempty" xml:"phase,omitempty"`
	SourceCluster            *MigrationJobSourceCluster  `json:"sourceCluster,omitempty" xml:"sourceCluster,omitempty" type:"Struct"`
	StartTime                *int64                      `json:"startTime,omitempty" xml:"startTime,omitempty"`
	StatusResult             []*MigrationJobStatusResult `json:"statusResult,omitempty" xml:"statusResult,omitempty" type:"Repeated"`
	TargetCluster            *MigrationJobTargetCluster  `json:"targetCluster,omitempty" xml:"targetCluster,omitempty" type:"Struct"`
	UpdateTime               *int64                      `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
}

func (s MigrationJob) String() string {
	return tea.Prettify(s)
}

func (s MigrationJob) GoString() string {
	return s.String()
}

func (s *MigrationJob) SetCurrentState(v string) *MigrationJob {
	s.CurrentState = &v
	return s
}

func (s *MigrationJob) SetDisableSourceClusterAuth(v bool) *MigrationJob {
	s.DisableSourceClusterAuth = &v
	return s
}

func (s *MigrationJob) SetDisableTargetClusterAuth(v bool) *MigrationJob {
	s.DisableTargetClusterAuth = &v
	return s
}

func (s *MigrationJob) SetEndTime(v int64) *MigrationJob {
	s.EndTime = &v
	return s
}

func (s *MigrationJob) SetMigrationJobId(v string) *MigrationJob {
	s.MigrationJobId = &v
	return s
}

func (s *MigrationJob) SetPhase(v string) *MigrationJob {
	s.Phase = &v
	return s
}

func (s *MigrationJob) SetSourceCluster(v *MigrationJobSourceCluster) *MigrationJob {
	s.SourceCluster = v
	return s
}

func (s *MigrationJob) SetStartTime(v int64) *MigrationJob {
	s.StartTime = &v
	return s
}

func (s *MigrationJob) SetStatusResult(v []*MigrationJobStatusResult) *MigrationJob {
	s.StatusResult = v
	return s
}

func (s *MigrationJob) SetTargetCluster(v *MigrationJobTargetCluster) *MigrationJob {
	s.TargetCluster = v
	return s
}

func (s *MigrationJob) SetUpdateTime(v int64) *MigrationJob {
	s.UpdateTime = &v
	return s
}

type MigrationJobSourceCluster struct {
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	Type       *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s MigrationJobSourceCluster) String() string {
	return tea.Prettify(s)
}

func (s MigrationJobSourceCluster) GoString() string {
	return s.String()
}

func (s *MigrationJobSourceCluster) SetInstanceId(v string) *MigrationJobSourceCluster {
	s.InstanceId = &v
	return s
}

func (s *MigrationJobSourceCluster) SetType(v string) *MigrationJobSourceCluster {
	s.Type = &v
	return s
}

type MigrationJobStatusResult struct {
	Code    *string `json:"code,omitempty" xml:"code,omitempty"`
	Success *bool   `json:"success,omitempty" xml:"success,omitempty"`
}

func (s MigrationJobStatusResult) String() string {
	return tea.Prettify(s)
}

func (s MigrationJobStatusResult) GoString() string {
	return s.String()
}

func (s *MigrationJobStatusResult) SetCode(v string) *MigrationJobStatusResult {
	s.Code = &v
	return s
}

func (s *MigrationJobStatusResult) SetSuccess(v bool) *MigrationJobStatusResult {
	s.Success = &v
	return s
}

type MigrationJobTargetCluster struct {
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	Type       *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s MigrationJobTargetCluster) String() string {
	return tea.Prettify(s)
}

func (s MigrationJobTargetCluster) GoString() string {
	return s.String()
}

func (s *MigrationJobTargetCluster) SetInstanceId(v string) *MigrationJobTargetCluster {
	s.InstanceId = &v
	return s
}

func (s *MigrationJobTargetCluster) SetType(v string) *MigrationJobTargetCluster {
	s.Type = &v
	return s
}

type NetworkConfig struct {
	Type             *string         `json:"type,omitempty" xml:"type,omitempty"`
	VpcId            *string         `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	VsArea           *string         `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	VswitchId        *string         `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
	WhiteIpGroupList []*WhiteIpGroup `json:"whiteIpGroupList,omitempty" xml:"whiteIpGroupList,omitempty" type:"Repeated"`
}

func (s NetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s NetworkConfig) GoString() string {
	return s.String()
}

func (s *NetworkConfig) SetType(v string) *NetworkConfig {
	s.Type = &v
	return s
}

func (s *NetworkConfig) SetVpcId(v string) *NetworkConfig {
	s.VpcId = &v
	return s
}

func (s *NetworkConfig) SetVsArea(v string) *NetworkConfig {
	s.VsArea = &v
	return s
}

func (s *NetworkConfig) SetVswitchId(v string) *NetworkConfig {
	s.VswitchId = &v
	return s
}

func (s *NetworkConfig) SetWhiteIpGroupList(v []*WhiteIpGroup) *NetworkConfig {
	s.WhiteIpGroupList = v
	return s
}

type NodeInfo struct {
	Host     *string `json:"host,omitempty" xml:"host,omitempty"`
	HostName *string `json:"hostName,omitempty" xml:"hostName,omitempty"`
	Port     *int64  `json:"port,omitempty" xml:"port,omitempty"`
	ZoneId   *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s NodeInfo) String() string {
	return tea.Prettify(s)
}

func (s NodeInfo) GoString() string {
	return s.String()
}

func (s *NodeInfo) SetHost(v string) *NodeInfo {
	s.Host = &v
	return s
}

func (s *NodeInfo) SetHostName(v string) *NodeInfo {
	s.HostName = &v
	return s
}

func (s *NodeInfo) SetPort(v int64) *NodeInfo {
	s.Port = &v
	return s
}

func (s *NodeInfo) SetZoneId(v string) *NodeInfo {
	s.ZoneId = &v
	return s
}

type NodeSpec struct {
	Disk             *int32  `json:"disk,omitempty" xml:"disk,omitempty"`
	DiskEncryption   *bool   `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	DiskType         *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	PerformanceLevel *string `json:"performanceLevel,omitempty" xml:"performanceLevel,omitempty"`
	// This parameter is required.
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s NodeSpec) String() string {
	return tea.Prettify(s)
}

func (s NodeSpec) GoString() string {
	return s.String()
}

func (s *NodeSpec) SetDisk(v int32) *NodeSpec {
	s.Disk = &v
	return s
}

func (s *NodeSpec) SetDiskEncryption(v bool) *NodeSpec {
	s.DiskEncryption = &v
	return s
}

func (s *NodeSpec) SetDiskType(v string) *NodeSpec {
	s.DiskType = &v
	return s
}

func (s *NodeSpec) SetPerformanceLevel(v string) *NodeSpec {
	s.PerformanceLevel = &v
	return s
}

func (s *NodeSpec) SetSpec(v string) *NodeSpec {
	s.Spec = &v
	return s
}

type PaymentInfo struct {
	AutoRenewDuration *int64  `json:"autoRenewDuration,omitempty" xml:"autoRenewDuration,omitempty"`
	Duration          *int64  `json:"duration,omitempty" xml:"duration,omitempty"`
	IsAutoRenew       *bool   `json:"isAutoRenew,omitempty" xml:"isAutoRenew,omitempty"`
	PricingCycle      *string `json:"pricingCycle,omitempty" xml:"pricingCycle,omitempty"`
}

func (s PaymentInfo) String() string {
	return tea.Prettify(s)
}

func (s PaymentInfo) GoString() string {
	return s.String()
}

func (s *PaymentInfo) SetAutoRenewDuration(v int64) *PaymentInfo {
	s.AutoRenewDuration = &v
	return s
}

func (s *PaymentInfo) SetDuration(v int64) *PaymentInfo {
	s.Duration = &v
	return s
}

func (s *PaymentInfo) SetIsAutoRenew(v bool) *PaymentInfo {
	s.IsAutoRenew = &v
	return s
}

func (s *PaymentInfo) SetPricingCycle(v string) *PaymentInfo {
	s.PricingCycle = &v
	return s
}

type ReadWritePolicy struct {
	AutoGeneratePk *bool   `json:"autoGeneratePk,omitempty" xml:"autoGeneratePk,omitempty"`
	WriteHa        *bool   `json:"writeHa,omitempty" xml:"writeHa,omitempty"`
	WritePolicy    *string `json:"writePolicy,omitempty" xml:"writePolicy,omitempty"`
}

func (s ReadWritePolicy) String() string {
	return tea.Prettify(s)
}

func (s ReadWritePolicy) GoString() string {
	return s.String()
}

func (s *ReadWritePolicy) SetAutoGeneratePk(v bool) *ReadWritePolicy {
	s.AutoGeneratePk = &v
	return s
}

func (s *ReadWritePolicy) SetWriteHa(v bool) *ReadWritePolicy {
	s.WriteHa = &v
	return s
}

func (s *ReadWritePolicy) SetWritePolicy(v string) *ReadWritePolicy {
	s.WritePolicy = &v
	return s
}

type Tag struct {
	TagKey   *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s Tag) String() string {
	return tea.Prettify(s)
}

func (s Tag) GoString() string {
	return s.String()
}

func (s *Tag) SetTagKey(v string) *Tag {
	s.TagKey = &v
	return s
}

func (s *Tag) SetTagValue(v string) *Tag {
	s.TagValue = &v
	return s
}

type WarmNodeConfiguration struct {
	Amount           *int64  `json:"amount,omitempty" xml:"amount,omitempty"`
	Disk             *int64  `json:"disk,omitempty" xml:"disk,omitempty"`
	DiskEncryption   *bool   `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	DiskType         *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	PerformanceLevel *string `json:"performanceLevel,omitempty" xml:"performanceLevel,omitempty"`
	// This parameter is required.
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s WarmNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s WarmNodeConfiguration) GoString() string {
	return s.String()
}

func (s *WarmNodeConfiguration) SetAmount(v int64) *WarmNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *WarmNodeConfiguration) SetDisk(v int64) *WarmNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *WarmNodeConfiguration) SetDiskEncryption(v bool) *WarmNodeConfiguration {
	s.DiskEncryption = &v
	return s
}

func (s *WarmNodeConfiguration) SetDiskType(v string) *WarmNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *WarmNodeConfiguration) SetPerformanceLevel(v string) *WarmNodeConfiguration {
	s.PerformanceLevel = &v
	return s
}

func (s *WarmNodeConfiguration) SetSpec(v string) *WarmNodeConfiguration {
	s.Spec = &v
	return s
}

type WhiteIpGroup struct {
	WhiteIpType *string   `json:"WhiteIpType,omitempty" xml:"WhiteIpType,omitempty"`
	GroupName   *string   `json:"groupName,omitempty" xml:"groupName,omitempty"`
	Ips         []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
}

func (s WhiteIpGroup) String() string {
	return tea.Prettify(s)
}

func (s WhiteIpGroup) GoString() string {
	return s.String()
}

func (s *WhiteIpGroup) SetWhiteIpType(v string) *WhiteIpGroup {
	s.WhiteIpType = &v
	return s
}

func (s *WhiteIpGroup) SetGroupName(v string) *WhiteIpGroup {
	s.GroupName = &v
	return s
}

func (s *WhiteIpGroup) SetIps(v []*string) *WhiteIpGroup {
	s.Ips = v
	return s
}

type ZoneInfo struct {
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s ZoneInfo) String() string {
	return tea.Prettify(s)
}

func (s ZoneInfo) GoString() string {
	return s.String()
}

func (s *ZoneInfo) SetStatus(v string) *ZoneInfo {
	s.Status = &v
	return s
}

func (s *ZoneInfo) SetZoneId(v string) *ZoneInfo {
	s.ZoneId = &v
	return s
}

type ResultSpecInfoMapValue struct {
	CpuCount      *string `json:"cpuCount,omitempty" xml:"cpuCount,omitempty"`
	MemorySize    *string `json:"memorySize,omitempty" xml:"memorySize,omitempty"`
	Enable        *string `json:"enable,omitempty" xml:"enable,omitempty"`
	Spec          *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecGroupType *string `json:"specGroupType,omitempty" xml:"specGroupType,omitempty"`
	Disk          *string `json:"disk,omitempty" xml:"disk,omitempty"`
	DiskType      *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
}

func (s ResultSpecInfoMapValue) String() string {
	return tea.Prettify(s)
}

func (s ResultSpecInfoMapValue) GoString() string {
	return s.String()
}

func (s *ResultSpecInfoMapValue) SetCpuCount(v string) *ResultSpecInfoMapValue {
	s.CpuCount = &v
	return s
}

func (s *ResultSpecInfoMapValue) SetMemorySize(v string) *ResultSpecInfoMapValue {
	s.MemorySize = &v
	return s
}

func (s *ResultSpecInfoMapValue) SetEnable(v string) *ResultSpecInfoMapValue {
	s.Enable = &v
	return s
}

func (s *ResultSpecInfoMapValue) SetSpec(v string) *ResultSpecInfoMapValue {
	s.Spec = &v
	return s
}

func (s *ResultSpecInfoMapValue) SetSpecGroupType(v string) *ResultSpecInfoMapValue {
	s.SpecGroupType = &v
	return s
}

func (s *ResultSpecInfoMapValue) SetDisk(v string) *ResultSpecInfoMapValue {
	s.Disk = &v
	return s
}

func (s *ResultSpecInfoMapValue) SetDiskType(v string) *ResultSpecInfoMapValue {
	s.DiskType = &v
	return s
}

type ActivateZonesRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s ActivateZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s ActivateZonesRequest) GoString() string {
	return s.String()
}

func (s *ActivateZonesRequest) SetBody(v string) *ActivateZonesRequest {
	s.Body = &v
	return s
}

func (s *ActivateZonesRequest) SetClientToken(v string) *ActivateZonesRequest {
	s.ClientToken = &v
	return s
}

type ActivateZonesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5A5D8E74-565C-43DC-B031-29289FA****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the nodes in disabled zones are restored. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ActivateZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActivateZonesResponseBody) GoString() string {
	return s.String()
}

func (s *ActivateZonesResponseBody) SetRequestId(v string) *ActivateZonesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ActivateZonesResponseBody) SetResult(v bool) *ActivateZonesResponseBody {
	s.Result = &v
	return s
}

type ActivateZonesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ActivateZonesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ActivateZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s ActivateZonesResponse) GoString() string {
	return s.String()
}

func (s *ActivateZonesResponse) SetHeaders(v map[string]*string) *ActivateZonesResponse {
	s.Headers = v
	return s
}

func (s *ActivateZonesResponse) SetStatusCode(v int32) *ActivateZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *ActivateZonesResponse) SetBody(v *ActivateZonesResponseBody) *ActivateZonesResponse {
	s.Body = v
	return s
}

type AddConnectableClusterRequest struct {
	// example:
	//
	// {     "instanceId":"es-cn-09k1rgid9000g****" }
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s AddConnectableClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s AddConnectableClusterRequest) GoString() string {
	return s.String()
}

func (s *AddConnectableClusterRequest) SetBody(v string) *AddConnectableClusterRequest {
	s.Body = &v
	return s
}

func (s *AddConnectableClusterRequest) SetClientToken(v string) *AddConnectableClusterRequest {
	s.ClientToken = &v
	return s
}

type AddConnectableClusterResponseBody struct {
	// example:
	//
	// 5A5D8E74-565C-43DC-B031-29289FA****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s AddConnectableClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddConnectableClusterResponseBody) GoString() string {
	return s.String()
}

func (s *AddConnectableClusterResponseBody) SetRequestId(v string) *AddConnectableClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddConnectableClusterResponseBody) SetResult(v bool) *AddConnectableClusterResponseBody {
	s.Result = &v
	return s
}

type AddConnectableClusterResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddConnectableClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddConnectableClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s AddConnectableClusterResponse) GoString() string {
	return s.String()
}

func (s *AddConnectableClusterResponse) SetHeaders(v map[string]*string) *AddConnectableClusterResponse {
	s.Headers = v
	return s
}

func (s *AddConnectableClusterResponse) SetStatusCode(v int32) *AddConnectableClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *AddConnectableClusterResponse) SetBody(v *AddConnectableClusterResponseBody) *AddConnectableClusterResponse {
	s.Body = v
	return s
}

type AddSnapshotRepoRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddSnapshotRepoRequest) String() string {
	return tea.Prettify(s)
}

func (s AddSnapshotRepoRequest) GoString() string {
	return s.String()
}

func (s *AddSnapshotRepoRequest) SetBody(v string) *AddSnapshotRepoRequest {
	s.Body = &v
	return s
}

type AddSnapshotRepoResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: Reference warehouse created successfully
	//
	// 	- false: Reference warehouse created failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s AddSnapshotRepoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddSnapshotRepoResponseBody) GoString() string {
	return s.String()
}

func (s *AddSnapshotRepoResponseBody) SetRequestId(v string) *AddSnapshotRepoResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddSnapshotRepoResponseBody) SetResult(v bool) *AddSnapshotRepoResponseBody {
	s.Result = &v
	return s
}

type AddSnapshotRepoResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddSnapshotRepoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddSnapshotRepoResponse) String() string {
	return tea.Prettify(s)
}

func (s AddSnapshotRepoResponse) GoString() string {
	return s.String()
}

func (s *AddSnapshotRepoResponse) SetHeaders(v map[string]*string) *AddSnapshotRepoResponse {
	s.Headers = v
	return s
}

func (s *AddSnapshotRepoResponse) SetStatusCode(v int32) *AddSnapshotRepoResponse {
	s.StatusCode = &v
	return s
}

func (s *AddSnapshotRepoResponse) SetBody(v *AddSnapshotRepoResponseBody) *AddSnapshotRepoResponse {
	s.Body = v
	return s
}

type CancelDeletionRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s CancelDeletionRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelDeletionRequest) GoString() string {
	return s.String()
}

func (s *CancelDeletionRequest) SetClientToken(v string) *CancelDeletionRequest {
	s.ClientToken = &v
	return s
}

type CancelDeletionResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// D682B6B3-B425-46DA-A5FC-5F5C60553622
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the cluster is restored. Valid values:
	//
	// 	- true: The cluster is restored.
	//
	// 	- false: The cluster fails to be restored.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CancelDeletionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelDeletionResponseBody) GoString() string {
	return s.String()
}

func (s *CancelDeletionResponseBody) SetRequestId(v string) *CancelDeletionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelDeletionResponseBody) SetResult(v bool) *CancelDeletionResponseBody {
	s.Result = &v
	return s
}

type CancelDeletionResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelDeletionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelDeletionResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelDeletionResponse) GoString() string {
	return s.String()
}

func (s *CancelDeletionResponse) SetHeaders(v map[string]*string) *CancelDeletionResponse {
	s.Headers = v
	return s
}

func (s *CancelDeletionResponse) SetStatusCode(v int32) *CancelDeletionResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelDeletionResponse) SetBody(v *CancelDeletionResponseBody) *CancelDeletionResponse {
	s.Body = v
	return s
}

type CancelLogstashDeletionRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s CancelLogstashDeletionRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelLogstashDeletionRequest) GoString() string {
	return s.String()
}

func (s *CancelLogstashDeletionRequest) SetClientToken(v string) *CancelLogstashDeletionRequest {
	s.ClientToken = &v
	return s
}

type CancelLogstashDeletionResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 23EBF56B-2DC0-4507-8BE5-B87395DB0FEB
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the cluster is restored. Valid values:
	//
	// 	- true: The cluster is restored.
	//
	// 	- false: The cluster is not restored.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CancelLogstashDeletionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelLogstashDeletionResponseBody) GoString() string {
	return s.String()
}

func (s *CancelLogstashDeletionResponseBody) SetRequestId(v string) *CancelLogstashDeletionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelLogstashDeletionResponseBody) SetResult(v bool) *CancelLogstashDeletionResponseBody {
	s.Result = &v
	return s
}

type CancelLogstashDeletionResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelLogstashDeletionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelLogstashDeletionResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelLogstashDeletionResponse) GoString() string {
	return s.String()
}

func (s *CancelLogstashDeletionResponse) SetHeaders(v map[string]*string) *CancelLogstashDeletionResponse {
	s.Headers = v
	return s
}

func (s *CancelLogstashDeletionResponse) SetStatusCode(v int32) *CancelLogstashDeletionResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelLogstashDeletionResponse) SetBody(v *CancelLogstashDeletionResponseBody) *CancelLogstashDeletionResponse {
	s.Body = v
	return s
}

type CancelTaskRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The type of the data migration task. Set the value to MigrateData.
	//
	// This parameter is required.
	//
	// example:
	//
	// MigrateData
	TaskType *string `json:"taskType,omitempty" xml:"taskType,omitempty"`
}

func (s CancelTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelTaskRequest) GoString() string {
	return s.String()
}

func (s *CancelTaskRequest) SetClientToken(v string) *CancelTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *CancelTaskRequest) SetTaskType(v string) *CancelTaskRequest {
	s.TaskType = &v
	return s
}

type CancelTaskResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: the task was cancelled successfully
	//
	// 	- false: the task was cancelled successfully failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CancelTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CancelTaskResponseBody) SetRequestId(v string) *CancelTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelTaskResponseBody) SetResult(v bool) *CancelTaskResponseBody {
	s.Result = &v
	return s
}

type CancelTaskResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelTaskResponse) GoString() string {
	return s.String()
}

func (s *CancelTaskResponse) SetHeaders(v map[string]*string) *CancelTaskResponse {
	s.Headers = v
	return s
}

func (s *CancelTaskResponse) SetStatusCode(v int32) *CancelTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelTaskResponse) SetBody(v *CancelTaskResponseBody) *CancelTaskResponse {
	s.Body = v
	return s
}

type CapacityPlanRequest struct {
	// example:
	//
	// true
	ComplexQueryAvailable *bool                          `json:"complexQueryAvailable,omitempty" xml:"complexQueryAvailable,omitempty"`
	DataInfo              []*CapacityPlanRequestDataInfo `json:"dataInfo,omitempty" xml:"dataInfo,omitempty" type:"Repeated"`
	Metric                []*CapacityPlanRequestMetric   `json:"metric,omitempty" xml:"metric,omitempty" type:"Repeated"`
	// example:
	//
	// general
	UsageScenario *string `json:"usageScenario,omitempty" xml:"usageScenario,omitempty"`
}

func (s CapacityPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanRequest) GoString() string {
	return s.String()
}

func (s *CapacityPlanRequest) SetComplexQueryAvailable(v bool) *CapacityPlanRequest {
	s.ComplexQueryAvailable = &v
	return s
}

func (s *CapacityPlanRequest) SetDataInfo(v []*CapacityPlanRequestDataInfo) *CapacityPlanRequest {
	s.DataInfo = v
	return s
}

func (s *CapacityPlanRequest) SetMetric(v []*CapacityPlanRequestMetric) *CapacityPlanRequest {
	s.Metric = v
	return s
}

func (s *CapacityPlanRequest) SetUsageScenario(v string) *CapacityPlanRequest {
	s.UsageScenario = &v
	return s
}

type CapacityPlanRequestDataInfo struct {
	// example:
	//
	// totalRawData
	Code *string `json:"code,omitempty" xml:"code,omitempty"`
	// example:
	//
	// 100
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
	// example:
	//
	// 10000
	TotalCount *int32 `json:"totalCount,omitempty" xml:"totalCount,omitempty"`
	// example:
	//
	// hot
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// example:
	//
	// MiB
	Unit *string `json:"unit,omitempty" xml:"unit,omitempty"`
}

func (s CapacityPlanRequestDataInfo) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanRequestDataInfo) GoString() string {
	return s.String()
}

func (s *CapacityPlanRequestDataInfo) SetCode(v string) *CapacityPlanRequestDataInfo {
	s.Code = &v
	return s
}

func (s *CapacityPlanRequestDataInfo) SetSize(v int64) *CapacityPlanRequestDataInfo {
	s.Size = &v
	return s
}

func (s *CapacityPlanRequestDataInfo) SetTotalCount(v int32) *CapacityPlanRequestDataInfo {
	s.TotalCount = &v
	return s
}

func (s *CapacityPlanRequestDataInfo) SetType(v string) *CapacityPlanRequestDataInfo {
	s.Type = &v
	return s
}

func (s *CapacityPlanRequestDataInfo) SetUnit(v string) *CapacityPlanRequestDataInfo {
	s.Unit = &v
	return s
}

type CapacityPlanRequestMetric struct {
	// example:
	//
	// 30
	AverageQps *int32 `json:"averageQps,omitempty" xml:"averageQps,omitempty"`
	// example:
	//
	// write
	Code *string `json:"code,omitempty" xml:"code,omitempty"`
	// example:
	//
	// 2
	Concurrent *int64 `json:"concurrent,omitempty" xml:"concurrent,omitempty"`
	// example:
	//
	// 30
	PeakQps *int32 `json:"peakQps,omitempty" xml:"peakQps,omitempty"`
	// example:
	//
	// 100
	ResponseTime *int32 `json:"responseTime,omitempty" xml:"responseTime,omitempty"`
	// example:
	//
	// 100
	Throughput *int64 `json:"throughput,omitempty" xml:"throughput,omitempty"`
	// example:
	//
	// common
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s CapacityPlanRequestMetric) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanRequestMetric) GoString() string {
	return s.String()
}

func (s *CapacityPlanRequestMetric) SetAverageQps(v int32) *CapacityPlanRequestMetric {
	s.AverageQps = &v
	return s
}

func (s *CapacityPlanRequestMetric) SetCode(v string) *CapacityPlanRequestMetric {
	s.Code = &v
	return s
}

func (s *CapacityPlanRequestMetric) SetConcurrent(v int64) *CapacityPlanRequestMetric {
	s.Concurrent = &v
	return s
}

func (s *CapacityPlanRequestMetric) SetPeakQps(v int32) *CapacityPlanRequestMetric {
	s.PeakQps = &v
	return s
}

func (s *CapacityPlanRequestMetric) SetResponseTime(v int32) *CapacityPlanRequestMetric {
	s.ResponseTime = &v
	return s
}

func (s *CapacityPlanRequestMetric) SetThroughput(v int64) *CapacityPlanRequestMetric {
	s.Throughput = &v
	return s
}

func (s *CapacityPlanRequestMetric) SetType(v string) *CapacityPlanRequestMetric {
	s.Type = &v
	return s
}

type CapacityPlanResponseBody struct {
	// The response of the request.
	//
	// example:
	//
	// E91B7129-A669-4D9D-A743-F90A0FF1F5EF
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The extension configuration information.
	Result *CapacityPlanResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s CapacityPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanResponseBody) GoString() string {
	return s.String()
}

func (s *CapacityPlanResponseBody) SetRequestId(v string) *CapacityPlanResponseBody {
	s.RequestId = &v
	return s
}

func (s *CapacityPlanResponseBody) SetResult(v *CapacityPlanResponseBodyResult) *CapacityPlanResponseBody {
	s.Result = v
	return s
}

type CapacityPlanResponseBodyResult struct {
	// The type of the configuration. Set the value to sharedDisk.
	//
	// >  The extendConfigs attribute that may occur when the planned instance type is enhanced (advanced).
	ExtendConfigs []*CapacityPlanResponseBodyResultExtendConfigs `json:"ExtendConfigs,omitempty" xml:"ExtendConfigs,omitempty" type:"Repeated"`
	// The node information.
	//
	// example:
	//
	// advanced
	InstanceCategory *string `json:"InstanceCategory,omitempty" xml:"InstanceCategory,omitempty"`
	// The number of cores.
	NodeConfigurations []*CapacityPlanResponseBodyResultNodeConfigurations `json:"NodeConfigurations,omitempty" xml:"NodeConfigurations,omitempty" type:"Repeated"`
	// example:
	//
	// true
	OversizedCluster *bool `json:"OversizedCluster,omitempty" xml:"OversizedCluster,omitempty"`
}

func (s CapacityPlanResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanResponseBodyResult) GoString() string {
	return s.String()
}

func (s *CapacityPlanResponseBodyResult) SetExtendConfigs(v []*CapacityPlanResponseBodyResultExtendConfigs) *CapacityPlanResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *CapacityPlanResponseBodyResult) SetInstanceCategory(v string) *CapacityPlanResponseBodyResult {
	s.InstanceCategory = &v
	return s
}

func (s *CapacityPlanResponseBodyResult) SetNodeConfigurations(v []*CapacityPlanResponseBodyResultNodeConfigurations) *CapacityPlanResponseBodyResult {
	s.NodeConfigurations = v
	return s
}

func (s *CapacityPlanResponseBodyResult) SetOversizedCluster(v bool) *CapacityPlanResponseBodyResult {
	s.OversizedCluster = &v
	return s
}

type CapacityPlanResponseBodyResultExtendConfigs struct {
	// The size of the disk. Unit: GiB.
	//
	// example:
	//
	// sharedDisk
	ConfigType *string `json:"ConfigType,omitempty" xml:"ConfigType,omitempty"`
	// The type of the disk. Valid value: CPFS_PREMIUM.
	//
	// >  The extendConfigs attribute that may occur when the planned instance type is enhanced (advanced).
	//
	// example:
	//
	// 2048
	Disk *int64 `json:"Disk,omitempty" xml:"Disk,omitempty"`
	// The version type. Valid values:
	//
	// 	- advanced: enhanced edition
	//
	// 	- x-pack: Commercial Edition
	//
	// 	- community: community version
	//
	// example:
	//
	// CPFS_PREMIUM
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
}

func (s CapacityPlanResponseBodyResultExtendConfigs) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanResponseBodyResultExtendConfigs) GoString() string {
	return s.String()
}

func (s *CapacityPlanResponseBodyResultExtendConfigs) SetConfigType(v string) *CapacityPlanResponseBodyResultExtendConfigs {
	s.ConfigType = &v
	return s
}

func (s *CapacityPlanResponseBodyResultExtendConfigs) SetDisk(v int64) *CapacityPlanResponseBodyResultExtendConfigs {
	s.Disk = &v
	return s
}

func (s *CapacityPlanResponseBodyResultExtendConfigs) SetDiskType(v string) *CapacityPlanResponseBodyResultExtendConfigs {
	s.DiskType = &v
	return s
}

type CapacityPlanResponseBodyResultNodeConfigurations struct {
	// The number of CPUs of the cloud desktop.
	//
	// example:
	//
	// 10
	Amount *int64 `json:"Amount,omitempty" xml:"Amount,omitempty"`
	// The size of the disk. Unit: GiB.
	//
	// example:
	//
	// 1
	Cpu *int64 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The type of the hard disk. Valid values:
	//
	// 	- cloud_essd: enhanced SSD (ESSD)
	//
	// 	- cloud_ssd: standard SSD
	//
	// 	- cloud_efficiency: ultra disk
	//
	// 	- local_ssd: local SSD
	//
	// 	- local_efficiency: local ultra disk
	//
	// example:
	//
	// 20
	Disk *int64 `json:"Disk,omitempty" xml:"Disk,omitempty"`
	// The memory size of the current node role.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The type of the node. Supported types are as follows:
	//
	// 	- WORKER: data node
	//
	// 	- WORKER_WARM: cold data node
	//
	// 	- MASTER: dedicated master node
	//
	// 	- KIBANA: Kibana node
	//
	// 	- COORDINATING: client node
	//
	// 	- ELASTIC_WORKER: elastic node
	//
	// example:
	//
	// 2
	Memory *int64 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The result calculated based on the capacity planning. No default value is available. The values are as follows:
	//
	// 	- true: indicates that the number of data nodes calculated by capacity planning exceeds the threshold of 50.
	//
	// 	- false: The number of data nodes calculated by capacity planning is less than 50.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
}

func (s CapacityPlanResponseBodyResultNodeConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanResponseBodyResultNodeConfigurations) GoString() string {
	return s.String()
}

func (s *CapacityPlanResponseBodyResultNodeConfigurations) SetAmount(v int64) *CapacityPlanResponseBodyResultNodeConfigurations {
	s.Amount = &v
	return s
}

func (s *CapacityPlanResponseBodyResultNodeConfigurations) SetCpu(v int64) *CapacityPlanResponseBodyResultNodeConfigurations {
	s.Cpu = &v
	return s
}

func (s *CapacityPlanResponseBodyResultNodeConfigurations) SetDisk(v int64) *CapacityPlanResponseBodyResultNodeConfigurations {
	s.Disk = &v
	return s
}

func (s *CapacityPlanResponseBodyResultNodeConfigurations) SetDiskType(v string) *CapacityPlanResponseBodyResultNodeConfigurations {
	s.DiskType = &v
	return s
}

func (s *CapacityPlanResponseBodyResultNodeConfigurations) SetMemory(v int64) *CapacityPlanResponseBodyResultNodeConfigurations {
	s.Memory = &v
	return s
}

func (s *CapacityPlanResponseBodyResultNodeConfigurations) SetNodeType(v string) *CapacityPlanResponseBodyResultNodeConfigurations {
	s.NodeType = &v
	return s
}

type CapacityPlanResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CapacityPlanResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CapacityPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s CapacityPlanResponse) GoString() string {
	return s.String()
}

func (s *CapacityPlanResponse) SetHeaders(v map[string]*string) *CapacityPlanResponse {
	s.Headers = v
	return s
}

func (s *CapacityPlanResponse) SetStatusCode(v int32) *CapacityPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *CapacityPlanResponse) SetBody(v *CapacityPlanResponseBody) *CapacityPlanResponse {
	s.Body = v
	return s
}

type CloseDiagnosisRequest struct {
	// The ID of the request.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// example:
	//
	// spanish
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s CloseDiagnosisRequest) String() string {
	return tea.Prettify(s)
}

func (s CloseDiagnosisRequest) GoString() string {
	return s.String()
}

func (s *CloseDiagnosisRequest) SetClientToken(v string) *CloseDiagnosisRequest {
	s.ClientToken = &v
	return s
}

func (s *CloseDiagnosisRequest) SetLang(v string) *CloseDiagnosisRequest {
	s.Lang = &v
	return s
}

type CloseDiagnosisResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CloseDiagnosisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloseDiagnosisResponseBody) GoString() string {
	return s.String()
}

func (s *CloseDiagnosisResponseBody) SetRequestId(v string) *CloseDiagnosisResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloseDiagnosisResponseBody) SetResult(v bool) *CloseDiagnosisResponseBody {
	s.Result = &v
	return s
}

type CloseDiagnosisResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CloseDiagnosisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CloseDiagnosisResponse) String() string {
	return tea.Prettify(s)
}

func (s CloseDiagnosisResponse) GoString() string {
	return s.String()
}

func (s *CloseDiagnosisResponse) SetHeaders(v map[string]*string) *CloseDiagnosisResponse {
	s.Headers = v
	return s
}

func (s *CloseDiagnosisResponse) SetStatusCode(v int32) *CloseDiagnosisResponse {
	s.StatusCode = &v
	return s
}

func (s *CloseDiagnosisResponse) SetBody(v *CloseDiagnosisResponseBody) *CloseDiagnosisResponse {
	s.Body = v
	return s
}

type CloseHttpsRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B350****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s CloseHttpsRequest) String() string {
	return tea.Prettify(s)
}

func (s CloseHttpsRequest) GoString() string {
	return s.String()
}

func (s *CloseHttpsRequest) SetClientToken(v string) *CloseHttpsRequest {
	s.ClientToken = &v
	return s
}

type CloseHttpsResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CloseHttpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloseHttpsResponseBody) GoString() string {
	return s.String()
}

func (s *CloseHttpsResponseBody) SetRequestId(v string) *CloseHttpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloseHttpsResponseBody) SetResult(v bool) *CloseHttpsResponseBody {
	s.Result = &v
	return s
}

type CloseHttpsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CloseHttpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CloseHttpsResponse) String() string {
	return tea.Prettify(s)
}

func (s CloseHttpsResponse) GoString() string {
	return s.String()
}

func (s *CloseHttpsResponse) SetHeaders(v map[string]*string) *CloseHttpsResponse {
	s.Headers = v
	return s
}

func (s *CloseHttpsResponse) SetStatusCode(v int32) *CloseHttpsResponse {
	s.StatusCode = &v
	return s
}

func (s *CloseHttpsResponse) SetBody(v *CloseHttpsResponseBody) *CloseHttpsResponse {
	s.Body = v
	return s
}

type CloseManagedIndexRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s CloseManagedIndexRequest) String() string {
	return tea.Prettify(s)
}

func (s CloseManagedIndexRequest) GoString() string {
	return s.String()
}

func (s *CloseManagedIndexRequest) SetClientToken(v string) *CloseManagedIndexRequest {
	s.ClientToken = &v
	return s
}

type CloseManagedIndexResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CloseManagedIndexResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloseManagedIndexResponseBody) GoString() string {
	return s.String()
}

func (s *CloseManagedIndexResponseBody) SetRequestId(v string) *CloseManagedIndexResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloseManagedIndexResponseBody) SetResult(v bool) *CloseManagedIndexResponseBody {
	s.Result = &v
	return s
}

type CloseManagedIndexResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CloseManagedIndexResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CloseManagedIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s CloseManagedIndexResponse) GoString() string {
	return s.String()
}

func (s *CloseManagedIndexResponse) SetHeaders(v map[string]*string) *CloseManagedIndexResponse {
	s.Headers = v
	return s
}

func (s *CloseManagedIndexResponse) SetStatusCode(v int32) *CloseManagedIndexResponse {
	s.StatusCode = &v
	return s
}

func (s *CloseManagedIndexResponse) SetBody(v *CloseManagedIndexResponseBody) *CloseManagedIndexResponse {
	s.Body = v
	return s
}

type CreateCollectorRequest struct {
	CollectorPaths []*string `json:"collectorPaths,omitempty" xml:"collectorPaths,omitempty" type:"Repeated"`
	// This parameter is required.
	Configs []*CreateCollectorRequestConfigs `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// true
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
	// This parameter is required.
	ExtendConfigs []map[string]interface{} `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// ct-test
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// fileBeat
	ResType *string `json:"resType,omitempty" xml:"resType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 6.8.5_with_community
	ResVersion *string `json:"resVersion,omitempty" xml:"resVersion,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// vpc-bp12nu14urf0upaf*****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// The ID of the created crawer.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s CreateCollectorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCollectorRequest) GoString() string {
	return s.String()
}

func (s *CreateCollectorRequest) SetCollectorPaths(v []*string) *CreateCollectorRequest {
	s.CollectorPaths = v
	return s
}

func (s *CreateCollectorRequest) SetConfigs(v []*CreateCollectorRequestConfigs) *CreateCollectorRequest {
	s.Configs = v
	return s
}

func (s *CreateCollectorRequest) SetDryRun(v bool) *CreateCollectorRequest {
	s.DryRun = &v
	return s
}

func (s *CreateCollectorRequest) SetExtendConfigs(v []map[string]interface{}) *CreateCollectorRequest {
	s.ExtendConfigs = v
	return s
}

func (s *CreateCollectorRequest) SetName(v string) *CreateCollectorRequest {
	s.Name = &v
	return s
}

func (s *CreateCollectorRequest) SetResType(v string) *CreateCollectorRequest {
	s.ResType = &v
	return s
}

func (s *CreateCollectorRequest) SetResVersion(v string) *CreateCollectorRequest {
	s.ResVersion = &v
	return s
}

func (s *CreateCollectorRequest) SetVpcId(v string) *CreateCollectorRequest {
	s.VpcId = &v
	return s
}

func (s *CreateCollectorRequest) SetClientToken(v string) *CreateCollectorRequest {
	s.ClientToken = &v
	return s
}

type CreateCollectorRequestConfigs struct {
	// This parameter is required.
	//
	// example:
	//
	// "filebeat.inputs:xxx"
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// filebeat.yml
	FileName *string `json:"fileName,omitempty" xml:"fileName,omitempty"`
}

func (s CreateCollectorRequestConfigs) String() string {
	return tea.Prettify(s)
}

func (s CreateCollectorRequestConfigs) GoString() string {
	return s.String()
}

func (s *CreateCollectorRequestConfigs) SetContent(v string) *CreateCollectorRequestConfigs {
	s.Content = &v
	return s
}

func (s *CreateCollectorRequestConfigs) SetFileName(v string) *CreateCollectorRequestConfigs {
	s.FileName = &v
	return s
}

type CreateCollectorResponseBody struct {
	// example:
	//
	// 8466BDFB-C513-4B8D-B4E3-5AB256AB****
	RequestId *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *CreateCollectorResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s CreateCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCollectorResponseBody) SetRequestId(v string) *CreateCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCollectorResponseBody) SetResult(v *CreateCollectorResponseBodyResult) *CreateCollectorResponseBody {
	s.Result = v
	return s
}

type CreateCollectorResponseBodyResult struct {
	// example:
	//
	// ct-cn-4135is2tj194p****
	ResId *string `json:"resId,omitempty" xml:"resId,omitempty"`
}

func (s CreateCollectorResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s CreateCollectorResponseBodyResult) GoString() string {
	return s.String()
}

func (s *CreateCollectorResponseBodyResult) SetResId(v string) *CreateCollectorResponseBodyResult {
	s.ResId = &v
	return s
}

type CreateCollectorResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCollectorResponse) GoString() string {
	return s.String()
}

func (s *CreateCollectorResponse) SetHeaders(v map[string]*string) *CreateCollectorResponse {
	s.Headers = v
	return s
}

func (s *CreateCollectorResponse) SetStatusCode(v int32) *CreateCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCollectorResponse) SetBody(v *CreateCollectorResponseBody) *CreateCollectorResponse {
	s.Body = v
	return s
}

type CreateComponentIndexRequest struct {
	// example:
	//
	// {       "description": "set number of shards to one"   }
	Meta     map[string]interface{}               `json:"_meta,omitempty" xml:"_meta,omitempty"`
	Template *CreateComponentIndexRequestTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
}

func (s CreateComponentIndexRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateComponentIndexRequest) GoString() string {
	return s.String()
}

func (s *CreateComponentIndexRequest) SetMeta(v map[string]interface{}) *CreateComponentIndexRequest {
	s.Meta = v
	return s
}

func (s *CreateComponentIndexRequest) SetTemplate(v *CreateComponentIndexRequestTemplate) *CreateComponentIndexRequest {
	s.Template = v
	return s
}

type CreateComponentIndexRequestTemplate struct {
	// example:
	//
	// {}
	Aliases map[string]interface{} `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// { 			"properties": { 				"@timestamp": { 					"type": "date" 				} 			} 		}
	Mappings map[string]interface{} `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// { 			"index.number_of_replicas": 0 		}
	Settings map[string]interface{} `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s CreateComponentIndexRequestTemplate) String() string {
	return tea.Prettify(s)
}

func (s CreateComponentIndexRequestTemplate) GoString() string {
	return s.String()
}

func (s *CreateComponentIndexRequestTemplate) SetAliases(v map[string]interface{}) *CreateComponentIndexRequestTemplate {
	s.Aliases = v
	return s
}

func (s *CreateComponentIndexRequestTemplate) SetMappings(v map[string]interface{}) *CreateComponentIndexRequestTemplate {
	s.Mappings = v
	return s
}

func (s *CreateComponentIndexRequestTemplate) SetSettings(v map[string]interface{}) *CreateComponentIndexRequestTemplate {
	s.Settings = v
	return s
}

type CreateComponentIndexResponseBody struct {
	// example:
	//
	// C20022BA-5382-4339-89FB-30AF48A05431
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CreateComponentIndexResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateComponentIndexResponseBody) GoString() string {
	return s.String()
}

func (s *CreateComponentIndexResponseBody) SetRequestId(v string) *CreateComponentIndexResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateComponentIndexResponseBody) SetResult(v bool) *CreateComponentIndexResponseBody {
	s.Result = &v
	return s
}

type CreateComponentIndexResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateComponentIndexResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateComponentIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateComponentIndexResponse) GoString() string {
	return s.String()
}

func (s *CreateComponentIndexResponse) SetHeaders(v map[string]*string) *CreateComponentIndexResponse {
	s.Headers = v
	return s
}

func (s *CreateComponentIndexResponse) SetStatusCode(v int32) *CreateComponentIndexResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateComponentIndexResponse) SetBody(v *CreateComponentIndexResponseBody) *CreateComponentIndexResponse {
	s.Body = v
	return s
}

type CreateDataStreamRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF***
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataStreamRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataStreamRequest) GoString() string {
	return s.String()
}

func (s *CreateDataStreamRequest) SetClientToken(v string) *CreateDataStreamRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDataStreamRequest) SetBody(v string) *CreateDataStreamRequest {
	s.Body = &v
	return s
}

type CreateDataStreamResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *CreateDataStreamResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s CreateDataStreamResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataStreamResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataStreamResponseBody) SetRequestId(v string) *CreateDataStreamResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataStreamResponseBody) SetResult(v *CreateDataStreamResponseBodyResult) *CreateDataStreamResponseBody {
	s.Result = v
	return s
}

type CreateDataStreamResponseBodyResult struct {
	// example:
	//
	// ds-
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s CreateDataStreamResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s CreateDataStreamResponseBodyResult) GoString() string {
	return s.String()
}

func (s *CreateDataStreamResponseBodyResult) SetName(v string) *CreateDataStreamResponseBodyResult {
	s.Name = &v
	return s
}

type CreateDataStreamResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataStreamResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataStreamResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataStreamResponse) GoString() string {
	return s.String()
}

func (s *CreateDataStreamResponse) SetHeaders(v map[string]*string) *CreateDataStreamResponse {
	s.Headers = v
	return s
}

func (s *CreateDataStreamResponse) SetStatusCode(v int32) *CreateDataStreamResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataStreamResponse) SetBody(v *CreateDataStreamResponseBody) *CreateDataStreamResponse {
	s.Body = v
	return s
}

type CreateILMPolicyRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateILMPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateILMPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateILMPolicyRequest) SetClientToken(v string) *CreateILMPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateILMPolicyRequest) SetBody(v string) *CreateILMPolicyRequest {
	s.Body = &v
	return s
}

type CreateILMPolicyResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// my-policy
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CreateILMPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateILMPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateILMPolicyResponseBody) SetRequestId(v string) *CreateILMPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateILMPolicyResponseBody) SetResult(v string) *CreateILMPolicyResponseBody {
	s.Result = &v
	return s
}

type CreateILMPolicyResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateILMPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateILMPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateILMPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateILMPolicyResponse) SetHeaders(v map[string]*string) *CreateILMPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateILMPolicyResponse) SetStatusCode(v int32) *CreateILMPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateILMPolicyResponse) SetBody(v *CreateILMPolicyResponseBody) *CreateILMPolicyResponse {
	s.Body = v
	return s
}

type CreateIndexTemplateRequest struct {
	// example:
	//
	// E1136AE9-4E49-4585-9358-6FDD2A6D****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// This parameter is required.
	DataStream *bool `json:"dataStream,omitempty" xml:"dataStream,omitempty"`
	// example:
	//
	// policy-1
	IlmPolicy *string `json:"ilmPolicy,omitempty" xml:"ilmPolicy,omitempty"`
	// This parameter is required.
	IndexPatterns []*string `json:"indexPatterns,omitempty" xml:"indexPatterns,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// index-template
	IndexTemplate *string `json:"indexTemplate,omitempty" xml:"indexTemplate,omitempty"`
	// example:
	//
	// 100
	Priority *int32                              `json:"priority,omitempty" xml:"priority,omitempty"`
	Template *CreateIndexTemplateRequestTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
}

func (s CreateIndexTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIndexTemplateRequest) GoString() string {
	return s.String()
}

func (s *CreateIndexTemplateRequest) SetClientToken(v string) *CreateIndexTemplateRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIndexTemplateRequest) SetDataStream(v bool) *CreateIndexTemplateRequest {
	s.DataStream = &v
	return s
}

func (s *CreateIndexTemplateRequest) SetIlmPolicy(v string) *CreateIndexTemplateRequest {
	s.IlmPolicy = &v
	return s
}

func (s *CreateIndexTemplateRequest) SetIndexPatterns(v []*string) *CreateIndexTemplateRequest {
	s.IndexPatterns = v
	return s
}

func (s *CreateIndexTemplateRequest) SetIndexTemplate(v string) *CreateIndexTemplateRequest {
	s.IndexTemplate = &v
	return s
}

func (s *CreateIndexTemplateRequest) SetPriority(v int32) *CreateIndexTemplateRequest {
	s.Priority = &v
	return s
}

func (s *CreateIndexTemplateRequest) SetTemplate(v *CreateIndexTemplateRequestTemplate) *CreateIndexTemplateRequest {
	s.Template = v
	return s
}

type CreateIndexTemplateRequestTemplate struct {
	// example:
	//
	// {"mydata": {}}
	Aliases *string `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// {"properties": {"created_at": {"type": "date","format": "EEE MMM dd HH:mm:ss Z yyyy"},"host_name": {"type": "keyword"}}}
	Mappings *string `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// {\"index.refresh_interval\":\"1s\"}
	Settings *string `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s CreateIndexTemplateRequestTemplate) String() string {
	return tea.Prettify(s)
}

func (s CreateIndexTemplateRequestTemplate) GoString() string {
	return s.String()
}

func (s *CreateIndexTemplateRequestTemplate) SetAliases(v string) *CreateIndexTemplateRequestTemplate {
	s.Aliases = &v
	return s
}

func (s *CreateIndexTemplateRequestTemplate) SetMappings(v string) *CreateIndexTemplateRequestTemplate {
	s.Mappings = &v
	return s
}

func (s *CreateIndexTemplateRequestTemplate) SetSettings(v string) *CreateIndexTemplateRequestTemplate {
	s.Settings = &v
	return s
}

type CreateIndexTemplateResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// index-template
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CreateIndexTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIndexTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIndexTemplateResponseBody) SetRequestId(v string) *CreateIndexTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateIndexTemplateResponseBody) SetResult(v string) *CreateIndexTemplateResponseBody {
	s.Result = &v
	return s
}

type CreateIndexTemplateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateIndexTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateIndexTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIndexTemplateResponse) GoString() string {
	return s.String()
}

func (s *CreateIndexTemplateResponse) SetHeaders(v map[string]*string) *CreateIndexTemplateResponse {
	s.Headers = v
	return s
}

func (s *CreateIndexTemplateResponse) SetStatusCode(v int32) *CreateIndexTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIndexTemplateResponse) SetBody(v *CreateIndexTemplateResponseBody) *CreateIndexTemplateResponse {
	s.Body = v
	return s
}

type CreateLogstashRequest struct {
	// example:
	//
	// ls-cn-abc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	NetworkConfig *CreateLogstashRequestNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	// This parameter is required.
	//
	// example:
	//
	// 2
	NodeAmount *int32 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// This parameter is required.
	NodeSpec    *CreateLogstashRequestNodeSpec    `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	PaymentInfo *CreateLogstashRequestPaymentInfo `json:"paymentInfo,omitempty" xml:"paymentInfo,omitempty" type:"Struct"`
	// example:
	//
	// prepaid
	PaymentType     *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 6.7_with_X-Pack
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s CreateLogstashRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLogstashRequest) GoString() string {
	return s.String()
}

func (s *CreateLogstashRequest) SetDescription(v string) *CreateLogstashRequest {
	s.Description = &v
	return s
}

func (s *CreateLogstashRequest) SetNetworkConfig(v *CreateLogstashRequestNetworkConfig) *CreateLogstashRequest {
	s.NetworkConfig = v
	return s
}

func (s *CreateLogstashRequest) SetNodeAmount(v int32) *CreateLogstashRequest {
	s.NodeAmount = &v
	return s
}

func (s *CreateLogstashRequest) SetNodeSpec(v *CreateLogstashRequestNodeSpec) *CreateLogstashRequest {
	s.NodeSpec = v
	return s
}

func (s *CreateLogstashRequest) SetPaymentInfo(v *CreateLogstashRequestPaymentInfo) *CreateLogstashRequest {
	s.PaymentInfo = v
	return s
}

func (s *CreateLogstashRequest) SetPaymentType(v string) *CreateLogstashRequest {
	s.PaymentType = &v
	return s
}

func (s *CreateLogstashRequest) SetResourceGroupId(v string) *CreateLogstashRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateLogstashRequest) SetVersion(v string) *CreateLogstashRequest {
	s.Version = &v
	return s
}

func (s *CreateLogstashRequest) SetClientToken(v string) *CreateLogstashRequest {
	s.ClientToken = &v
	return s
}

type CreateLogstashRequestNetworkConfig struct {
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// vpc-bp16k1dvzxtmagcva****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou-i
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// vsw-bp1k4ec6s7sjdbudw****
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s CreateLogstashRequestNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateLogstashRequestNetworkConfig) GoString() string {
	return s.String()
}

func (s *CreateLogstashRequestNetworkConfig) SetType(v string) *CreateLogstashRequestNetworkConfig {
	s.Type = &v
	return s
}

func (s *CreateLogstashRequestNetworkConfig) SetVpcId(v string) *CreateLogstashRequestNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *CreateLogstashRequestNetworkConfig) SetVsArea(v string) *CreateLogstashRequestNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *CreateLogstashRequestNetworkConfig) SetVswitchId(v string) *CreateLogstashRequestNetworkConfig {
	s.VswitchId = &v
	return s
}

type CreateLogstashRequestNodeSpec struct {
	// example:
	//
	// 50
	Disk *int64 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// logstash.n4.small
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s CreateLogstashRequestNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s CreateLogstashRequestNodeSpec) GoString() string {
	return s.String()
}

func (s *CreateLogstashRequestNodeSpec) SetDisk(v int64) *CreateLogstashRequestNodeSpec {
	s.Disk = &v
	return s
}

func (s *CreateLogstashRequestNodeSpec) SetDiskType(v string) *CreateLogstashRequestNodeSpec {
	s.DiskType = &v
	return s
}

func (s *CreateLogstashRequestNodeSpec) SetSpec(v string) *CreateLogstashRequestNodeSpec {
	s.Spec = &v
	return s
}

type CreateLogstashRequestPaymentInfo struct {
	// example:
	//
	// 3
	AutoRenewDuration *int64 `json:"autoRenewDuration,omitempty" xml:"autoRenewDuration,omitempty"`
	// example:
	//
	// 1
	Duration *int64 `json:"duration,omitempty" xml:"duration,omitempty"`
	// example:
	//
	// false
	IsAutoRenew *bool `json:"isAutoRenew,omitempty" xml:"isAutoRenew,omitempty"`
	// example:
	//
	// Month
	PricingCycle *string `json:"pricingCycle,omitempty" xml:"pricingCycle,omitempty"`
}

func (s CreateLogstashRequestPaymentInfo) String() string {
	return tea.Prettify(s)
}

func (s CreateLogstashRequestPaymentInfo) GoString() string {
	return s.String()
}

func (s *CreateLogstashRequestPaymentInfo) SetAutoRenewDuration(v int64) *CreateLogstashRequestPaymentInfo {
	s.AutoRenewDuration = &v
	return s
}

func (s *CreateLogstashRequestPaymentInfo) SetDuration(v int64) *CreateLogstashRequestPaymentInfo {
	s.Duration = &v
	return s
}

func (s *CreateLogstashRequestPaymentInfo) SetIsAutoRenew(v bool) *CreateLogstashRequestPaymentInfo {
	s.IsAutoRenew = &v
	return s
}

func (s *CreateLogstashRequestPaymentInfo) SetPricingCycle(v string) *CreateLogstashRequestPaymentInfo {
	s.PricingCycle = &v
	return s
}

type CreateLogstashResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE*****
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *Logstash `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CreateLogstashResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLogstashResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLogstashResponseBody) SetRequestId(v string) *CreateLogstashResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLogstashResponseBody) SetResult(v *Logstash) *CreateLogstashResponseBody {
	s.Result = v
	return s
}

type CreateLogstashResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateLogstashResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateLogstashResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLogstashResponse) GoString() string {
	return s.String()
}

func (s *CreateLogstashResponse) SetHeaders(v map[string]*string) *CreateLogstashResponse {
	s.Headers = v
	return s
}

func (s *CreateLogstashResponse) SetStatusCode(v int32) *CreateLogstashResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLogstashResponse) SetBody(v *CreateLogstashResponseBody) *CreateLogstashResponse {
	s.Body = v
	return s
}

type CreatePipelinesRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string                       `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        []*CreatePipelinesRequestBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// example:
	//
	// false
	Trigger *bool `json:"trigger,omitempty" xml:"trigger,omitempty"`
}

func (s CreatePipelinesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePipelinesRequest) GoString() string {
	return s.String()
}

func (s *CreatePipelinesRequest) SetClientToken(v string) *CreatePipelinesRequest {
	s.ClientToken = &v
	return s
}

func (s *CreatePipelinesRequest) SetBody(v []*CreatePipelinesRequestBody) *CreatePipelinesRequest {
	s.Body = v
	return s
}

func (s *CreatePipelinesRequest) SetTrigger(v bool) *CreatePipelinesRequest {
	s.Trigger = &v
	return s
}

type CreatePipelinesRequestBody struct {
	// example:
	//
	// 50
	BatchDelay *int32 `json:"batchDelay,omitempty" xml:"batchDelay,omitempty"`
	// example:
	//
	// 125
	BatchSize *int32 `json:"batchSize,omitempty" xml:"batchSize,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// input { } filter { } output { }
	Config *string `json:"config,omitempty" xml:"config,omitempty"`
	// example:
	//
	// this is a test
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// pipeline-test
	PipelineId *string `json:"pipelineId,omitempty" xml:"pipelineId,omitempty"`
	// example:
	//
	// 1024
	QueueCheckPointWrites *int32 `json:"queueCheckPointWrites,omitempty" xml:"queueCheckPointWrites,omitempty"`
	// example:
	//
	// 1024
	QueueMaxBytes *int32 `json:"queueMaxBytes,omitempty" xml:"queueMaxBytes,omitempty"`
	// example:
	//
	// MEMORY
	QueueType *string `json:"queueType,omitempty" xml:"queueType,omitempty"`
	// example:
	//
	// 2
	Workers *int32 `json:"workers,omitempty" xml:"workers,omitempty"`
}

func (s CreatePipelinesRequestBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePipelinesRequestBody) GoString() string {
	return s.String()
}

func (s *CreatePipelinesRequestBody) SetBatchDelay(v int32) *CreatePipelinesRequestBody {
	s.BatchDelay = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetBatchSize(v int32) *CreatePipelinesRequestBody {
	s.BatchSize = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetConfig(v string) *CreatePipelinesRequestBody {
	s.Config = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetDescription(v string) *CreatePipelinesRequestBody {
	s.Description = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetPipelineId(v string) *CreatePipelinesRequestBody {
	s.PipelineId = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetQueueCheckPointWrites(v int32) *CreatePipelinesRequestBody {
	s.QueueCheckPointWrites = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetQueueMaxBytes(v int32) *CreatePipelinesRequestBody {
	s.QueueMaxBytes = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetQueueType(v string) *CreatePipelinesRequestBody {
	s.QueueType = &v
	return s
}

func (s *CreatePipelinesRequestBody) SetWorkers(v int32) *CreatePipelinesRequestBody {
	s.Workers = &v
	return s
}

type CreatePipelinesResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CreatePipelinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePipelinesResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePipelinesResponseBody) SetRequestId(v string) *CreatePipelinesResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreatePipelinesResponseBody) SetResult(v bool) *CreatePipelinesResponseBody {
	s.Result = &v
	return s
}

type CreatePipelinesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreatePipelinesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreatePipelinesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePipelinesResponse) GoString() string {
	return s.String()
}

func (s *CreatePipelinesResponse) SetHeaders(v map[string]*string) *CreatePipelinesResponse {
	s.Headers = v
	return s
}

func (s *CreatePipelinesResponse) SetStatusCode(v int32) *CreatePipelinesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePipelinesResponse) SetBody(v *CreatePipelinesResponseBody) *CreatePipelinesResponse {
	s.Body = v
	return s
}

type CreateSnapshotRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateSnapshotRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSnapshotRequest) GoString() string {
	return s.String()
}

func (s *CreateSnapshotRequest) SetClientToken(v string) *CreateSnapshotRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateSnapshotRequest) SetBody(v string) *CreateSnapshotRequest {
	s.Body = &v
	return s
}

type CreateSnapshotResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: manual snapshot backup successfully
	//
	// 	- false: manual snapshot backup failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s CreateSnapshotResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSnapshotResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSnapshotResponseBody) SetRequestId(v string) *CreateSnapshotResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSnapshotResponseBody) SetResult(v bool) *CreateSnapshotResponseBody {
	s.Result = &v
	return s
}

type CreateSnapshotResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateSnapshotResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateSnapshotResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSnapshotResponse) GoString() string {
	return s.String()
}

func (s *CreateSnapshotResponse) SetHeaders(v map[string]*string) *CreateSnapshotResponse {
	s.Headers = v
	return s
}

func (s *CreateSnapshotResponse) SetStatusCode(v int32) *CreateSnapshotResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSnapshotResponse) SetBody(v *CreateSnapshotResponseBody) *CreateSnapshotResponse {
	s.Body = v
	return s
}

type CreateVpcEndpointRequest struct {
	// The returned result details.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// example:
	//
	// epsrv-hp3xdsq46ael67lo****
	ServiceId *string `json:"serviceId,omitempty" xml:"serviceId,omitempty"`
	// example:
	//
	// cn-hangzhou-i
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
	// The ID of the user endpoint service associated with the endpoint.
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
}

func (s CreateVpcEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcEndpointRequest) GoString() string {
	return s.String()
}

func (s *CreateVpcEndpointRequest) SetClientToken(v string) *CreateVpcEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateVpcEndpointRequest) SetServiceId(v string) *CreateVpcEndpointRequest {
	s.ServiceId = &v
	return s
}

func (s *CreateVpcEndpointRequest) SetZoneId(v string) *CreateVpcEndpointRequest {
	s.ZoneId = &v
	return s
}

func (s *CreateVpcEndpointRequest) SetDryRun(v bool) *CreateVpcEndpointRequest {
	s.DryRun = &v
	return s
}

type CreateVpcEndpointResponseBody struct {
	// The endpoint domain name, which is used to configure the connection.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the endpoint on the service VPC side.
	Result *CreateVpcEndpointResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s CreateVpcEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVpcEndpointResponseBody) SetRequestId(v string) *CreateVpcEndpointResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVpcEndpointResponseBody) SetResult(v *CreateVpcEndpointResponseBodyResult) *CreateVpcEndpointResponseBody {
	s.Result = v
	return s
}

type CreateVpcEndpointResponseBodyResult struct {
	// example:
	//
	// ep-bp1tah7zbrwmkjef****.epsrv-bp1w0p3jdirbfmt6****.cn-hangzhou.privatelink.aliyuncs.com
	EndpointDomain *string `json:"endpointDomain,omitempty" xml:"endpointDomain,omitempty"`
	// example:
	//
	// ep-bp1tah7zbrwmkjef****
	EndpointId *string `json:"endpointId,omitempty" xml:"endpointId,omitempty"`
	// example:
	//
	// vpcElasticSearchABC
	EndpointName *string `json:"endpointName,omitempty" xml:"endpointName,omitempty"`
	// The name of the service VPC-side endpoint.
	//
	// example:
	//
	// epsrv-bp1w0p3jdirbfmt6****
	ServiceId *string `json:"serviceId,omitempty" xml:"serviceId,omitempty"`
}

func (s CreateVpcEndpointResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcEndpointResponseBodyResult) GoString() string {
	return s.String()
}

func (s *CreateVpcEndpointResponseBodyResult) SetEndpointDomain(v string) *CreateVpcEndpointResponseBodyResult {
	s.EndpointDomain = &v
	return s
}

func (s *CreateVpcEndpointResponseBodyResult) SetEndpointId(v string) *CreateVpcEndpointResponseBodyResult {
	s.EndpointId = &v
	return s
}

func (s *CreateVpcEndpointResponseBodyResult) SetEndpointName(v string) *CreateVpcEndpointResponseBodyResult {
	s.EndpointName = &v
	return s
}

func (s *CreateVpcEndpointResponseBodyResult) SetServiceId(v string) *CreateVpcEndpointResponseBodyResult {
	s.ServiceId = &v
	return s
}

type CreateVpcEndpointResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateVpcEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateVpcEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVpcEndpointResponse) GoString() string {
	return s.String()
}

func (s *CreateVpcEndpointResponse) SetHeaders(v map[string]*string) *CreateVpcEndpointResponse {
	s.Headers = v
	return s
}

func (s *CreateVpcEndpointResponse) SetStatusCode(v int32) *CreateVpcEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVpcEndpointResponse) SetBody(v *CreateVpcEndpointResponseBody) *CreateVpcEndpointResponse {
	s.Body = v
	return s
}

type DeactivateZonesRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s DeactivateZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactivateZonesRequest) GoString() string {
	return s.String()
}

func (s *DeactivateZonesRequest) SetBody(v string) *DeactivateZonesRequest {
	s.Body = &v
	return s
}

func (s *DeactivateZonesRequest) SetClientToken(v string) *DeactivateZonesRequest {
	s.ClientToken = &v
	return s
}

type DeactivateZonesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: offline zone successfully
	//
	// 	- false: offline zone successfully failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeactivateZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactivateZonesResponseBody) GoString() string {
	return s.String()
}

func (s *DeactivateZonesResponseBody) SetRequestId(v string) *DeactivateZonesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeactivateZonesResponseBody) SetResult(v bool) *DeactivateZonesResponseBody {
	s.Result = &v
	return s
}

type DeactivateZonesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeactivateZonesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeactivateZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactivateZonesResponse) GoString() string {
	return s.String()
}

func (s *DeactivateZonesResponse) SetHeaders(v map[string]*string) *DeactivateZonesResponse {
	s.Headers = v
	return s
}

func (s *DeactivateZonesResponse) SetStatusCode(v int32) *DeactivateZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactivateZonesResponse) SetBody(v *DeactivateZonesResponseBody) *DeactivateZonesResponse {
	s.Body = v
	return s
}

type DeleteCollectorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s DeleteCollectorRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCollectorRequest) GoString() string {
	return s.String()
}

func (s *DeleteCollectorRequest) SetClientToken(v string) *DeleteCollectorRequest {
	s.ClientToken = &v
	return s
}

type DeleteCollectorResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the shipper is deleted. Valid values:
	//
	// 	- true: The shipper is deleted.
	//
	// 	- false: The shipper fails to be deleted.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCollectorResponseBody) SetRequestId(v string) *DeleteCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteCollectorResponseBody) SetResult(v bool) *DeleteCollectorResponseBody {
	s.Result = &v
	return s
}

type DeleteCollectorResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCollectorResponse) GoString() string {
	return s.String()
}

func (s *DeleteCollectorResponse) SetHeaders(v map[string]*string) *DeleteCollectorResponse {
	s.Headers = v
	return s
}

func (s *DeleteCollectorResponse) SetStatusCode(v int32) *DeleteCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCollectorResponse) SetBody(v *DeleteCollectorResponseBody) *DeleteCollectorResponse {
	s.Body = v
	return s
}

type DeleteComponentIndexResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteComponentIndexResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteComponentIndexResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteComponentIndexResponseBody) SetRequestId(v string) *DeleteComponentIndexResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteComponentIndexResponseBody) SetResult(v bool) *DeleteComponentIndexResponseBody {
	s.Result = &v
	return s
}

type DeleteComponentIndexResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteComponentIndexResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteComponentIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteComponentIndexResponse) GoString() string {
	return s.String()
}

func (s *DeleteComponentIndexResponse) SetHeaders(v map[string]*string) *DeleteComponentIndexResponse {
	s.Headers = v
	return s
}

func (s *DeleteComponentIndexResponse) SetStatusCode(v int32) *DeleteComponentIndexResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteComponentIndexResponse) SetBody(v *DeleteComponentIndexResponseBody) *DeleteComponentIndexResponse {
	s.Body = v
	return s
}

type DeleteConnectedClusterRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The ID of the remote instance for which the network connection is established.
	//
	// This parameter is required.
	//
	// example:
	//
	// es-cn-09k1rgid9000g****
	ConnectedInstanceId *string `json:"connectedInstanceId,omitempty" xml:"connectedInstanceId,omitempty"`
}

func (s DeleteConnectedClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteConnectedClusterRequest) GoString() string {
	return s.String()
}

func (s *DeleteConnectedClusterRequest) SetClientToken(v string) *DeleteConnectedClusterRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteConnectedClusterRequest) SetConnectedInstanceId(v string) *DeleteConnectedClusterRequest {
	s.ConnectedInstanceId = &v
	return s
}

type DeleteConnectedClusterResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: remove the interworking instance successfully
	//
	// 	- false: remove the interworking instance failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteConnectedClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteConnectedClusterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteConnectedClusterResponseBody) SetRequestId(v string) *DeleteConnectedClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteConnectedClusterResponseBody) SetResult(v bool) *DeleteConnectedClusterResponseBody {
	s.Result = &v
	return s
}

type DeleteConnectedClusterResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteConnectedClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteConnectedClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConnectedClusterResponse) GoString() string {
	return s.String()
}

func (s *DeleteConnectedClusterResponse) SetHeaders(v map[string]*string) *DeleteConnectedClusterResponse {
	s.Headers = v
	return s
}

func (s *DeleteConnectedClusterResponse) SetStatusCode(v int32) *DeleteConnectedClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteConnectedClusterResponse) SetBody(v *DeleteConnectedClusterResponseBody) *DeleteConnectedClusterResponse {
	s.Body = v
	return s
}

type DeleteDataStreamRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s DeleteDataStreamRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataStreamRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataStreamRequest) SetClientToken(v string) *DeleteDataStreamRequest {
	s.ClientToken = &v
	return s
}

type DeleteDataStreamResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteDataStreamResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataStreamResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDataStreamResponseBody) SetRequestId(v string) *DeleteDataStreamResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDataStreamResponseBody) SetResult(v bool) *DeleteDataStreamResponseBody {
	s.Result = &v
	return s
}

type DeleteDataStreamResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDataStreamResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDataStreamResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataStreamResponse) GoString() string {
	return s.String()
}

func (s *DeleteDataStreamResponse) SetHeaders(v map[string]*string) *DeleteDataStreamResponse {
	s.Headers = v
	return s
}

func (s *DeleteDataStreamResponse) SetStatusCode(v int32) *DeleteDataStreamResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDataStreamResponse) SetBody(v *DeleteDataStreamResponseBody) *DeleteDataStreamResponse {
	s.Body = v
	return s
}

type DeleteDataTaskRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the index migration task.
	//
	// This parameter is required.
	//
	// example:
	//
	// et_cn_0oyg09o96ib40****
	TaskId *string `json:"taskId,omitempty" xml:"taskId,omitempty"`
}

func (s DeleteDataTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataTaskRequest) SetClientToken(v string) *DeleteDataTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteDataTaskRequest) SetTaskId(v string) *DeleteDataTaskRequest {
	s.TaskId = &v
	return s
}

type DeleteDataTaskResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned results.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteDataTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDataTaskResponseBody) SetRequestId(v string) *DeleteDataTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDataTaskResponseBody) SetResult(v bool) *DeleteDataTaskResponseBody {
	s.Result = &v
	return s
}

type DeleteDataTaskResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDataTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDataTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteDataTaskResponse) SetHeaders(v map[string]*string) *DeleteDataTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteDataTaskResponse) SetStatusCode(v int32) *DeleteDataTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDataTaskResponse) SetBody(v *DeleteDataTaskResponseBody) *DeleteDataTaskResponse {
	s.Body = v
	return s
}

type DeleteDeprecatedTemplateResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteDeprecatedTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeprecatedTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeprecatedTemplateResponseBody) SetRequestId(v string) *DeleteDeprecatedTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeprecatedTemplateResponseBody) SetResult(v bool) *DeleteDeprecatedTemplateResponseBody {
	s.Result = &v
	return s
}

type DeleteDeprecatedTemplateResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDeprecatedTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDeprecatedTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeprecatedTemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeprecatedTemplateResponse) SetHeaders(v map[string]*string) *DeleteDeprecatedTemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeprecatedTemplateResponse) SetStatusCode(v int32) *DeleteDeprecatedTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeprecatedTemplateResponse) SetBody(v *DeleteDeprecatedTemplateResponseBody) *DeleteDeprecatedTemplateResponse {
	s.Body = v
	return s
}

type DeleteILMPolicyResponseBody struct {
	// example:
	//
	// 694FDC20-0FDD-47C4-B921-BFF902FA****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteILMPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteILMPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteILMPolicyResponseBody) SetRequestId(v string) *DeleteILMPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteILMPolicyResponseBody) SetResult(v bool) *DeleteILMPolicyResponseBody {
	s.Result = &v
	return s
}

type DeleteILMPolicyResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteILMPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteILMPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteILMPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteILMPolicyResponse) SetHeaders(v map[string]*string) *DeleteILMPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteILMPolicyResponse) SetStatusCode(v int32) *DeleteILMPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteILMPolicyResponse) SetBody(v *DeleteILMPolicyResponseBody) *DeleteILMPolicyResponse {
	s.Body = v
	return s
}

type DeleteIndexTemplateResponseBody struct {
	// example:
	//
	// A0761F7E-0B50-46B9-8CAA-EBB3A420****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteIndexTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIndexTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIndexTemplateResponseBody) SetRequestId(v string) *DeleteIndexTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteIndexTemplateResponseBody) SetResult(v bool) *DeleteIndexTemplateResponseBody {
	s.Result = &v
	return s
}

type DeleteIndexTemplateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteIndexTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteIndexTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIndexTemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteIndexTemplateResponse) SetHeaders(v map[string]*string) *DeleteIndexTemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteIndexTemplateResponse) SetStatusCode(v int32) *DeleteIndexTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIndexTemplateResponse) SetBody(v *DeleteIndexTemplateResponseBody) *DeleteIndexTemplateResponse {
	s.Body = v
	return s
}

type DeleteInstanceRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// example:
	//
	// protective
	DeleteType *string `json:"deleteType,omitempty" xml:"deleteType,omitempty"`
}

func (s DeleteInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteInstanceRequest) SetClientToken(v string) *DeleteInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteInstanceRequest) SetDeleteType(v string) *DeleteInstanceRequest {
	s.DeleteType = &v
	return s
}

type DeleteInstanceResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 94B03BBA-A132-42C3-8367-0A0C1C45****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteInstanceResponseBody) SetRequestId(v string) *DeleteInstanceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteInstanceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteInstanceResponse) SetHeaders(v map[string]*string) *DeleteInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteInstanceResponse) SetStatusCode(v int32) *DeleteInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteInstanceResponse) SetBody(v *DeleteInstanceResponseBody) *DeleteInstanceResponse {
	s.Body = v
	return s
}

type DeleteLogstashRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The type of the release operation. Valid values:
	//
	// 	- immediate: The cluster is immediately deleted when it is released. After the cluster is deleted, the data stored in the cluster is deleted, and the system removes the cluster from the Logstash cluster list.
	//
	// 	- protective: The cluster is released 24 hours later. During the period of 24 hours, you can still find the cluster in the Logstash cluster list, and [restore the cluster](https://help.aliyun.com/document_detail/202205.html) or [immediately release the cluster](https://help.aliyun.com/document_detail/160591.html). After 24 hours elapse, the data stored in the cluster is deleted.
	//
	// example:
	//
	// protective
	DeleteType *string `json:"deleteType,omitempty" xml:"deleteType,omitempty"`
}

func (s DeleteLogstashRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogstashRequest) GoString() string {
	return s.String()
}

func (s *DeleteLogstashRequest) SetClientToken(v string) *DeleteLogstashRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteLogstashRequest) SetDeleteType(v string) *DeleteLogstashRequest {
	s.DeleteType = &v
	return s
}

type DeleteLogstashResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 94B03BBA-A132-42C3-8367-0A0C1C45****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLogstashResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogstashResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLogstashResponseBody) SetRequestId(v string) *DeleteLogstashResponseBody {
	s.RequestId = &v
	return s
}

type DeleteLogstashResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteLogstashResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteLogstashResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogstashResponse) GoString() string {
	return s.String()
}

func (s *DeleteLogstashResponse) SetHeaders(v map[string]*string) *DeleteLogstashResponse {
	s.Headers = v
	return s
}

func (s *DeleteLogstashResponse) SetStatusCode(v int32) *DeleteLogstashResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLogstashResponse) SetBody(v *DeleteLogstashResponseBody) *DeleteLogstashResponse {
	s.Body = v
	return s
}

type DeletePipelinesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the pipeline.
	//
	// example:
	//
	// pipeline-test
	PipelineIds *string `json:"pipelineIds,omitempty" xml:"pipelineIds,omitempty"`
}

func (s DeletePipelinesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePipelinesRequest) GoString() string {
	return s.String()
}

func (s *DeletePipelinesRequest) SetClientToken(v string) *DeletePipelinesRequest {
	s.ClientToken = &v
	return s
}

func (s *DeletePipelinesRequest) SetPipelineIds(v string) *DeletePipelinesRequest {
	s.PipelineIds = &v
	return s
}

type DeletePipelinesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the pipeline is deleted. Valid values:
	//
	// 	- true: The pipeline is deleted.
	//
	// 	- false: The pipeline fails to be deleted.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeletePipelinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePipelinesResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePipelinesResponseBody) SetRequestId(v string) *DeletePipelinesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeletePipelinesResponseBody) SetResult(v bool) *DeletePipelinesResponseBody {
	s.Result = &v
	return s
}

type DeletePipelinesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeletePipelinesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeletePipelinesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePipelinesResponse) GoString() string {
	return s.String()
}

func (s *DeletePipelinesResponse) SetHeaders(v map[string]*string) *DeletePipelinesResponse {
	s.Headers = v
	return s
}

func (s *DeletePipelinesResponse) SetStatusCode(v int32) *DeletePipelinesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePipelinesResponse) SetBody(v *DeletePipelinesResponseBody) *DeletePipelinesResponse {
	s.Body = v
	return s
}

type DeleteSnapshotRepoRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// Reference instance ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// es-cn-n6w1rux8i000w****
	RepoPath *string `json:"repoPath,omitempty" xml:"repoPath,omitempty"`
}

func (s DeleteSnapshotRepoRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnapshotRepoRequest) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotRepoRequest) SetClientToken(v string) *DeleteSnapshotRepoRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteSnapshotRepoRequest) SetRepoPath(v string) *DeleteSnapshotRepoRequest {
	s.RepoPath = &v
	return s
}

type DeleteSnapshotRepoResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: reference warehouse deleted successfully
	//
	// 	- false: reference warehouse deleted successfully failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteSnapshotRepoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnapshotRepoResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotRepoResponseBody) SetRequestId(v string) *DeleteSnapshotRepoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSnapshotRepoResponseBody) SetResult(v bool) *DeleteSnapshotRepoResponseBody {
	s.Result = &v
	return s
}

type DeleteSnapshotRepoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteSnapshotRepoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteSnapshotRepoResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnapshotRepoResponse) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotRepoResponse) SetHeaders(v map[string]*string) *DeleteSnapshotRepoResponse {
	s.Headers = v
	return s
}

func (s *DeleteSnapshotRepoResponse) SetStatusCode(v int32) *DeleteSnapshotRepoResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSnapshotRepoResponse) SetBody(v *DeleteSnapshotRepoResponseBody) *DeleteSnapshotRepoResponse {
	s.Body = v
	return s
}

type DeleteVpcEndpointRequest struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s DeleteVpcEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcEndpointRequest) GoString() string {
	return s.String()
}

func (s *DeleteVpcEndpointRequest) SetClientToken(v string) *DeleteVpcEndpointRequest {
	s.ClientToken = &v
	return s
}

type DeleteVpcEndpointResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteVpcEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVpcEndpointResponseBody) SetRequestId(v string) *DeleteVpcEndpointResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteVpcEndpointResponseBody) SetResult(v bool) *DeleteVpcEndpointResponseBody {
	s.Result = &v
	return s
}

type DeleteVpcEndpointResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteVpcEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteVpcEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVpcEndpointResponse) GoString() string {
	return s.String()
}

func (s *DeleteVpcEndpointResponse) SetHeaders(v map[string]*string) *DeleteVpcEndpointResponse {
	s.Headers = v
	return s
}

func (s *DeleteVpcEndpointResponse) SetStatusCode(v int32) *DeleteVpcEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVpcEndpointResponse) SetBody(v *DeleteVpcEndpointResponseBody) *DeleteVpcEndpointResponse {
	s.Body = v
	return s
}

type DescribeAckOperatorResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 6615EE8D-FD9D-4FD3-997E-6FEA5B8D82ED
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *DescribeAckOperatorResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeAckOperatorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAckOperatorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAckOperatorResponseBody) SetRequestId(v string) *DescribeAckOperatorResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAckOperatorResponseBody) SetResult(v *DescribeAckOperatorResponseBodyResult) *DescribeAckOperatorResponseBody {
	s.Result = v
	return s
}

type DescribeAckOperatorResponseBodyResult struct {
	// The installation status of ES-operator. Valid values:
	//
	// 	- deployed: ES-operator is installed.
	//
	// 	- not-deploy: ES-operator is not installed.
	//
	// 	- failed: ES-operator fails to be installed.
	//
	// 	- unknown: The installation status of ES-operator is unknown.
	//
	// example:
	//
	// deployed
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The version of ES-operator.
	//
	// example:
	//
	// 1
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s DescribeAckOperatorResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeAckOperatorResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeAckOperatorResponseBodyResult) SetStatus(v string) *DescribeAckOperatorResponseBodyResult {
	s.Status = &v
	return s
}

func (s *DescribeAckOperatorResponseBodyResult) SetVersion(v string) *DescribeAckOperatorResponseBodyResult {
	s.Version = &v
	return s
}

type DescribeAckOperatorResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAckOperatorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAckOperatorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAckOperatorResponse) GoString() string {
	return s.String()
}

func (s *DescribeAckOperatorResponse) SetHeaders(v map[string]*string) *DescribeAckOperatorResponse {
	s.Headers = v
	return s
}

func (s *DescribeAckOperatorResponse) SetStatusCode(v int32) *DescribeAckOperatorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAckOperatorResponse) SetBody(v *DescribeAckOperatorResponseBody) *DescribeAckOperatorResponse {
	s.Body = v
	return s
}

type DescribeApmResponseBody struct {
	// example:
	//
	// 97597D87-8066-5493-B692-5C50DA236D68
	RequestId *string                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *DescribeApmResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeApmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeApmResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeApmResponseBody) SetRequestId(v string) *DescribeApmResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeApmResponseBody) SetResult(v *DescribeApmResponseBodyResult) *DescribeApmResponseBody {
	s.Result = v
	return s
}

type DescribeApmResponseBodyResult struct {
	// example:
	//
	// apm-cn-i7m2fuae****.apm.elasticsearch.aliyuncs.com:8200
	ApmServerDomain *string `json:"apmServerDomain,omitempty" xml:"apmServerDomain,omitempty"`
	// example:
	//
	// 2021-11-16T07:15:51.967Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// example:
	//
	// 1
	DeployedReplica *int64 `json:"deployedReplica,omitempty" xml:"deployedReplica,omitempty"`
	// example:
	//
	// APMtest
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// 4792752000000
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// example:
	//
	// apm-cn-i7m2fuae****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// 1
	NodeAmount *int64 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// example:
	//
	// es-cn-i7m2fsfhc001x****
	OutputES *string `json:"outputES,omitempty" xml:"outputES,omitempty"`
	// example:
	//
	// elastic
	OutputESUserName *string `json:"outputESUserName,omitempty" xml:"outputESUserName,omitempty"`
	// example:
	//
	// 133071096032****
	OwnerId *string `json:"ownerId,omitempty" xml:"ownerId,omitempty"`
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// example:
	//
	// cn-hangzhou
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// example:
	//
	// 1
	Replica *int32 `json:"replica,omitempty" xml:"replica,omitempty"`
	// example:
	//
	// C1M2
	ResourceSpec *string `json:"resourceSpec,omitempty" xml:"resourceSpec,omitempty"`
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// example:
	//
	// 7.10.2
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
	// example:
	//
	// vpc-bp1530vdhqkamm9s0****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// example:
	//
	// cn-hangzhou-i
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// example:
	//
	// vsw-bp1j1mql6r9g5vfb4****
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s DescribeApmResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeApmResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeApmResponseBodyResult) SetApmServerDomain(v string) *DescribeApmResponseBodyResult {
	s.ApmServerDomain = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetCreatedAt(v string) *DescribeApmResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetDeployedReplica(v int64) *DescribeApmResponseBodyResult {
	s.DeployedReplica = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetDescription(v string) *DescribeApmResponseBodyResult {
	s.Description = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetEndTime(v int64) *DescribeApmResponseBodyResult {
	s.EndTime = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetInstanceId(v string) *DescribeApmResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetNodeAmount(v int64) *DescribeApmResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetOutputES(v string) *DescribeApmResponseBodyResult {
	s.OutputES = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetOutputESUserName(v string) *DescribeApmResponseBodyResult {
	s.OutputESUserName = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetOwnerId(v string) *DescribeApmResponseBodyResult {
	s.OwnerId = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetPaymentType(v string) *DescribeApmResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetRegion(v string) *DescribeApmResponseBodyResult {
	s.Region = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetReplica(v int32) *DescribeApmResponseBodyResult {
	s.Replica = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetResourceSpec(v string) *DescribeApmResponseBodyResult {
	s.ResourceSpec = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetStatus(v string) *DescribeApmResponseBodyResult {
	s.Status = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetVersion(v string) *DescribeApmResponseBodyResult {
	s.Version = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetVpcId(v string) *DescribeApmResponseBodyResult {
	s.VpcId = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetVsArea(v string) *DescribeApmResponseBodyResult {
	s.VsArea = &v
	return s
}

func (s *DescribeApmResponseBodyResult) SetVswitchId(v string) *DescribeApmResponseBodyResult {
	s.VswitchId = &v
	return s
}

type DescribeApmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeApmResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeApmResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeApmResponse) GoString() string {
	return s.String()
}

func (s *DescribeApmResponse) SetHeaders(v map[string]*string) *DescribeApmResponse {
	s.Headers = v
	return s
}

func (s *DescribeApmResponse) SetStatusCode(v int32) *DescribeApmResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeApmResponse) SetBody(v *DescribeApmResponseBody) *DescribeApmResponse {
	s.Body = v
	return s
}

type DescribeCollectorResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *DescribeCollectorResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCollectorResponseBody) SetRequestId(v string) *DescribeCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCollectorResponseBody) SetResult(v *DescribeCollectorResponseBodyResult) *DescribeCollectorResponseBody {
	s.Result = v
	return s
}

type DescribeCollectorResponseBodyResult struct {
	CollectorPaths []*string `json:"collectorPaths,omitempty" xml:"collectorPaths,omitempty" type:"Repeated"`
	// The information about the configuration file of the shipper.
	Configs []*DescribeCollectorResponseBodyResultConfigs `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// Indicates whether a dry run is performed. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
	// The extended configurations of the shipper.
	ExtendConfigs []*DescribeCollectorResponseBodyResultExtendConfigs `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// The time when the shipper was created.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtCreatedTime *string `json:"gmtCreatedTime,omitempty" xml:"gmtCreatedTime,omitempty"`
	// The time when the shipper was updated.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtUpdateTime *string `json:"gmtUpdateTime,omitempty" xml:"gmtUpdateTime,omitempty"`
	// The name of the shipper.
	//
	// example:
	//
	// ct-cn-4135is2tj194p****
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The account ID.
	//
	// example:
	//
	// 16852099488*****
	OwnerId *string `json:"ownerId,omitempty" xml:"ownerId,omitempty"`
	// The ID of the shipper.
	//
	// example:
	//
	// ct-cn-rg31ahn82m0qd****
	ResId *string `json:"resId,omitempty" xml:"resId,omitempty"`
	// The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.
	//
	// example:
	//
	// fileBeat
	ResType *string `json:"resType,omitempty" xml:"resType,omitempty"`
	// The version of the shipper.
	//
	// example:
	//
	// 6.8.5_with_community
	ResVersion *string `json:"resVersion,omitempty" xml:"resVersion,omitempty"`
	// The status of the shipper. Valid values:
	//
	// 	- activating
	//
	// 	- active
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The ID of the virtual private cloud (VPC) where the shipper resides.
	//
	// example:
	//
	// vpc-bp16k1dvzxtma*****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s DescribeCollectorResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollectorResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeCollectorResponseBodyResult) SetCollectorPaths(v []*string) *DescribeCollectorResponseBodyResult {
	s.CollectorPaths = v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetConfigs(v []*DescribeCollectorResponseBodyResultConfigs) *DescribeCollectorResponseBodyResult {
	s.Configs = v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetDryRun(v bool) *DescribeCollectorResponseBodyResult {
	s.DryRun = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetExtendConfigs(v []*DescribeCollectorResponseBodyResultExtendConfigs) *DescribeCollectorResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetGmtCreatedTime(v string) *DescribeCollectorResponseBodyResult {
	s.GmtCreatedTime = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetGmtUpdateTime(v string) *DescribeCollectorResponseBodyResult {
	s.GmtUpdateTime = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetName(v string) *DescribeCollectorResponseBodyResult {
	s.Name = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetOwnerId(v string) *DescribeCollectorResponseBodyResult {
	s.OwnerId = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetResId(v string) *DescribeCollectorResponseBodyResult {
	s.ResId = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetResType(v string) *DescribeCollectorResponseBodyResult {
	s.ResType = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetResVersion(v string) *DescribeCollectorResponseBodyResult {
	s.ResVersion = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetStatus(v string) *DescribeCollectorResponseBodyResult {
	s.Status = &v
	return s
}

func (s *DescribeCollectorResponseBodyResult) SetVpcId(v string) *DescribeCollectorResponseBodyResult {
	s.VpcId = &v
	return s
}

type DescribeCollectorResponseBodyResultConfigs struct {
	// The content of the file.
	//
	// example:
	//
	// fileBeat.inputs:xxx
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// The name of the file.
	//
	// example:
	//
	// filebeat.yml
	FileName *string `json:"fileName,omitempty" xml:"fileName,omitempty"`
}

func (s DescribeCollectorResponseBodyResultConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollectorResponseBodyResultConfigs) GoString() string {
	return s.String()
}

func (s *DescribeCollectorResponseBodyResultConfigs) SetContent(v string) *DescribeCollectorResponseBodyResultConfigs {
	s.Content = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultConfigs) SetFileName(v string) *DescribeCollectorResponseBodyResultConfigs {
	s.FileName = &v
	return s
}

type DescribeCollectorResponseBodyResultExtendConfigs struct {
	// The configuration type. Valid values:
	//
	// 	- collectorTargetInstance
	//
	// 	- collectorDeployMachine
	//
	// 	- collectorElasticsearchForKibana
	//
	// example:
	//
	// collectorDeployMachine
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// Indicates whether monitoring is enabled. This parameter is returned if the value of **configType*	- is **collectorTargetInstance**. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" xml:"enableMonitoring,omitempty"`
	// The ID of the machine group. This parameter is returned if the value of **configType*	- is **collectorDeployMachine**.
	//
	// example:
	//
	// default_ct-cn-5i2l75bz4776****
	GroupId *string `json:"groupId,omitempty" xml:"groupId,omitempty"`
	// The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType*	- is **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601
	Host  *string   `json:"host,omitempty" xml:"host,omitempty"`
	Hosts []*string `json:"hosts,omitempty" xml:"hosts,omitempty" type:"Repeated"`
	// The ID of the resource that is associated with the shipper. If the value of **configType*	- is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType*	- is **collectorDeployMachines*	- and the value of **type*	- is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.
	//
	// example:
	//
	// es-cn-n6w1o1****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// elasticsearch
	InstanceType *string `json:"instanceType,omitempty" xml:"instanceType,omitempty"`
	// The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType*	- is **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601
	KibanaHost *string `json:"kibanaHost,omitempty" xml:"kibanaHost,omitempty"`
	// The information about the Elastic Compute Service (ECS) instances on which the shipper is deployed. This parameter is returned if the value of **configType*	- is **collectorDeployMachines*	- and the value of **type*	- is **ECSInstanceId**.
	Machines []*DescribeCollectorResponseBodyResultExtendConfigsMachines `json:"machines,omitempty" xml:"machines,omitempty" type:"Repeated"`
	// The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// The number of pods from which data is succcessfully collected in the Container Service for Kubernetes (ACK) cluster.
	//
	// example:
	//
	// 8
	SuccessPodsCount *string `json:"successPodsCount,omitempty" xml:"successPodsCount,omitempty"`
	// The total number of pods from which data is collected in the ACK cluster.
	//
	// example:
	//
	// 10
	TotalPodsCount *string `json:"totalPodsCount,omitempty" xml:"totalPodsCount,omitempty"`
	// The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType*	- is **collectorDeployMachine**. Valid values:
	//
	// 	- ECSInstanceId
	//
	// 	- ACKCluster
	//
	// example:
	//
	// ECSInstanceId
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType*	- is **collectorTargetInstance*	- or **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s DescribeCollectorResponseBodyResultExtendConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollectorResponseBodyResultExtendConfigs) GoString() string {
	return s.String()
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetConfigType(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.ConfigType = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetEnableMonitoring(v bool) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.EnableMonitoring = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetGroupId(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.GroupId = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetHost(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.Host = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetHosts(v []*string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.Hosts = v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetInstanceId(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.InstanceId = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetInstanceType(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.InstanceType = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetKibanaHost(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.KibanaHost = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetMachines(v []*DescribeCollectorResponseBodyResultExtendConfigsMachines) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.Machines = v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetProtocol(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.Protocol = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetSuccessPodsCount(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.SuccessPodsCount = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetTotalPodsCount(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.TotalPodsCount = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetType(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.Type = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigs) SetUserName(v string) *DescribeCollectorResponseBodyResultExtendConfigs {
	s.UserName = &v
	return s
}

type DescribeCollectorResponseBodyResultExtendConfigsMachines struct {
	// The status of the shipper on the ECS instance. Valid values:
	//
	// 	- heartOk: The heartbeat is normal.
	//
	// 	- heartLost: The heartbeat is abnormal.
	//
	// 	- uninstalled: The shipper is not installed.
	//
	// 	- failed: The shipper fails to be installed.
	//
	// example:
	//
	// heartOk
	AgentStatus *string `json:"agentStatus,omitempty" xml:"agentStatus,omitempty"`
	// The IDs of the ECS instances.
	//
	// example:
	//
	// i-bp1gyhphjaj73jsr****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
}

func (s DescribeCollectorResponseBodyResultExtendConfigsMachines) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollectorResponseBodyResultExtendConfigsMachines) GoString() string {
	return s.String()
}

func (s *DescribeCollectorResponseBodyResultExtendConfigsMachines) SetAgentStatus(v string) *DescribeCollectorResponseBodyResultExtendConfigsMachines {
	s.AgentStatus = &v
	return s
}

func (s *DescribeCollectorResponseBodyResultExtendConfigsMachines) SetInstanceId(v string) *DescribeCollectorResponseBodyResultExtendConfigsMachines {
	s.InstanceId = &v
	return s
}

type DescribeCollectorResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCollectorResponse) GoString() string {
	return s.String()
}

func (s *DescribeCollectorResponse) SetHeaders(v map[string]*string) *DescribeCollectorResponse {
	s.Headers = v
	return s
}

func (s *DescribeCollectorResponse) SetStatusCode(v int32) *DescribeCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCollectorResponse) SetBody(v *DescribeCollectorResponseBody) *DescribeCollectorResponse {
	s.Body = v
	return s
}

type DescribeComponentIndexResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *DescribeComponentIndexResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeComponentIndexResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeComponentIndexResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeComponentIndexResponseBody) SetRequestId(v string) *DescribeComponentIndexResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeComponentIndexResponseBody) SetResult(v *DescribeComponentIndexResponseBodyResult) *DescribeComponentIndexResponseBody {
	s.Result = v
	return s
}

type DescribeComponentIndexResponseBodyResult struct {
	// example:
	//
	// { "description": "set number of shards to one" }
	Meta     map[string]interface{}                            `json:"_meta,omitempty" xml:"_meta,omitempty"`
	Template *DescribeComponentIndexResponseBodyResultTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
}

func (s DescribeComponentIndexResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeComponentIndexResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeComponentIndexResponseBodyResult) SetMeta(v map[string]interface{}) *DescribeComponentIndexResponseBodyResult {
	s.Meta = v
	return s
}

func (s *DescribeComponentIndexResponseBodyResult) SetTemplate(v *DescribeComponentIndexResponseBodyResultTemplate) *DescribeComponentIndexResponseBodyResult {
	s.Template = v
	return s
}

type DescribeComponentIndexResponseBodyResultTemplate struct {
	// example:
	//
	// {}
	Aliases map[string]interface{} `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// { "properties": { "@timestamp": { "type": "date" } } }
	Mappings map[string]interface{} `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// { "index.number_of_replicas": 0 }
	Settings map[string]interface{} `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s DescribeComponentIndexResponseBodyResultTemplate) String() string {
	return tea.Prettify(s)
}

func (s DescribeComponentIndexResponseBodyResultTemplate) GoString() string {
	return s.String()
}

func (s *DescribeComponentIndexResponseBodyResultTemplate) SetAliases(v map[string]interface{}) *DescribeComponentIndexResponseBodyResultTemplate {
	s.Aliases = v
	return s
}

func (s *DescribeComponentIndexResponseBodyResultTemplate) SetMappings(v map[string]interface{}) *DescribeComponentIndexResponseBodyResultTemplate {
	s.Mappings = v
	return s
}

func (s *DescribeComponentIndexResponseBodyResultTemplate) SetSettings(v map[string]interface{}) *DescribeComponentIndexResponseBodyResultTemplate {
	s.Settings = v
	return s
}

type DescribeComponentIndexResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeComponentIndexResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeComponentIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeComponentIndexResponse) GoString() string {
	return s.String()
}

func (s *DescribeComponentIndexResponse) SetHeaders(v map[string]*string) *DescribeComponentIndexResponse {
	s.Headers = v
	return s
}

func (s *DescribeComponentIndexResponse) SetStatusCode(v int32) *DescribeComponentIndexResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeComponentIndexResponse) SetBody(v *DescribeComponentIndexResponseBody) *DescribeComponentIndexResponse {
	s.Body = v
	return s
}

type DescribeConnectableClustersRequest struct {
	// The ID of the instance that can communicate with each other.
	//
	// example:
	//
	// true
	AlreadySetItems *bool `json:"alreadySetItems,omitempty" xml:"alreadySetItems,omitempty"`
}

func (s DescribeConnectableClustersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeConnectableClustersRequest) GoString() string {
	return s.String()
}

func (s *DescribeConnectableClustersRequest) SetAlreadySetItems(v bool) *DescribeConnectableClustersRequest {
	s.AlreadySetItems = &v
	return s
}

type DescribeConnectableClustersResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*DescribeConnectableClustersResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s DescribeConnectableClustersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeConnectableClustersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeConnectableClustersResponseBody) SetRequestId(v string) *DescribeConnectableClustersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeConnectableClustersResponseBody) SetResult(v []*DescribeConnectableClustersResponseBodyResult) *DescribeConnectableClustersResponseBody {
	s.Result = v
	return s
}

type DescribeConnectableClustersResponseBodyResult struct {
	// example:
	//
	// es-cn-xxx
	Instances *string `json:"instances,omitempty" xml:"instances,omitempty"`
	// example:
	//
	// vpc
	NetworkType *string `json:"networkType,omitempty" xml:"networkType,omitempty"`
}

func (s DescribeConnectableClustersResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeConnectableClustersResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeConnectableClustersResponseBodyResult) SetInstances(v string) *DescribeConnectableClustersResponseBodyResult {
	s.Instances = &v
	return s
}

func (s *DescribeConnectableClustersResponseBodyResult) SetNetworkType(v string) *DescribeConnectableClustersResponseBodyResult {
	s.NetworkType = &v
	return s
}

type DescribeConnectableClustersResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeConnectableClustersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeConnectableClustersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeConnectableClustersResponse) GoString() string {
	return s.String()
}

func (s *DescribeConnectableClustersResponse) SetHeaders(v map[string]*string) *DescribeConnectableClustersResponse {
	s.Headers = v
	return s
}

func (s *DescribeConnectableClustersResponse) SetStatusCode(v int32) *DescribeConnectableClustersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeConnectableClustersResponse) SetBody(v *DescribeConnectableClustersResponseBody) *DescribeConnectableClustersResponse {
	s.Body = v
	return s
}

type DescribeDeprecatedTemplateResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *DescribeDeprecatedTemplateResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeDeprecatedTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDeprecatedTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDeprecatedTemplateResponseBody) SetRequestId(v string) *DescribeDeprecatedTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBody) SetResult(v *DescribeDeprecatedTemplateResponseBodyResult) *DescribeDeprecatedTemplateResponseBody {
	s.Result = v
	return s
}

type DescribeDeprecatedTemplateResponseBodyResult struct {
	// example:
	//
	// false
	DataStream    *bool     `json:"dataStream,omitempty" xml:"dataStream,omitempty"`
	IndexPatterns []*string `json:"indexPatterns,omitempty" xml:"indexPatterns,omitempty" type:"Repeated"`
	// example:
	//
	// openstore-index-template
	IndexTemplate *string `json:"indexTemplate,omitempty" xml:"indexTemplate,omitempty"`
	// example:
	//
	// 100
	Order    *int64                                                `json:"order,omitempty" xml:"order,omitempty"`
	Template *DescribeDeprecatedTemplateResponseBodyResultTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
	// example:
	//
	// 70000
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s DescribeDeprecatedTemplateResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeDeprecatedTemplateResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeDeprecatedTemplateResponseBodyResult) SetDataStream(v bool) *DescribeDeprecatedTemplateResponseBodyResult {
	s.DataStream = &v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBodyResult) SetIndexPatterns(v []*string) *DescribeDeprecatedTemplateResponseBodyResult {
	s.IndexPatterns = v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBodyResult) SetIndexTemplate(v string) *DescribeDeprecatedTemplateResponseBodyResult {
	s.IndexTemplate = &v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBodyResult) SetOrder(v int64) *DescribeDeprecatedTemplateResponseBodyResult {
	s.Order = &v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBodyResult) SetTemplate(v *DescribeDeprecatedTemplateResponseBodyResultTemplate) *DescribeDeprecatedTemplateResponseBodyResult {
	s.Template = v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBodyResult) SetVersion(v string) *DescribeDeprecatedTemplateResponseBodyResult {
	s.Version = &v
	return s
}

type DescribeDeprecatedTemplateResponseBodyResultTemplate struct {
	// example:
	//
	// "{}"
	Aliases *string `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// "{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}"
	Mappings *string `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// "{\\"index.number_of_shards\\":\\"1\\"}"
	Settings *string `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s DescribeDeprecatedTemplateResponseBodyResultTemplate) String() string {
	return tea.Prettify(s)
}

func (s DescribeDeprecatedTemplateResponseBodyResultTemplate) GoString() string {
	return s.String()
}

func (s *DescribeDeprecatedTemplateResponseBodyResultTemplate) SetAliases(v string) *DescribeDeprecatedTemplateResponseBodyResultTemplate {
	s.Aliases = &v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBodyResultTemplate) SetMappings(v string) *DescribeDeprecatedTemplateResponseBodyResultTemplate {
	s.Mappings = &v
	return s
}

func (s *DescribeDeprecatedTemplateResponseBodyResultTemplate) SetSettings(v string) *DescribeDeprecatedTemplateResponseBodyResultTemplate {
	s.Settings = &v
	return s
}

type DescribeDeprecatedTemplateResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDeprecatedTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDeprecatedTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDeprecatedTemplateResponse) GoString() string {
	return s.String()
}

func (s *DescribeDeprecatedTemplateResponse) SetHeaders(v map[string]*string) *DescribeDeprecatedTemplateResponse {
	s.Headers = v
	return s
}

func (s *DescribeDeprecatedTemplateResponse) SetStatusCode(v int32) *DescribeDeprecatedTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDeprecatedTemplateResponse) SetBody(v *DescribeDeprecatedTemplateResponseBody) *DescribeDeprecatedTemplateResponse {
	s.Body = v
	return s
}

type DescribeDiagnoseReportRequest struct {
	// example:
	//
	// en
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s DescribeDiagnoseReportRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnoseReportRequest) GoString() string {
	return s.String()
}

func (s *DescribeDiagnoseReportRequest) SetLang(v string) *DescribeDiagnoseReportRequest {
	s.Lang = &v
	return s
}

type DescribeDiagnoseReportResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *DescribeDiagnoseReportResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeDiagnoseReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnoseReportResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDiagnoseReportResponseBody) SetRequestId(v string) *DescribeDiagnoseReportResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBody) SetResult(v *DescribeDiagnoseReportResponseBodyResult) *DescribeDiagnoseReportResponseBody {
	s.Result = v
	return s
}

type DescribeDiagnoseReportResponseBodyResult struct {
	// example:
	//
	// 1535745731000
	CreateTime    *int64                                                   `json:"createTime,omitempty" xml:"createTime,omitempty"`
	DiagnoseItems []*DescribeDiagnoseReportResponseBodyResultDiagnoseItems `json:"diagnoseItems,omitempty" xml:"diagnoseItems,omitempty" type:"Repeated"`
	// example:
	//
	// YELLOW
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// example:
	//
	// es-cn-abc
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// trigger__2020-08-17T17:09:02
	ReportId *string `json:"reportId,omitempty" xml:"reportId,omitempty"`
	// example:
	//
	// SUCCESS
	State *string `json:"state,omitempty" xml:"state,omitempty"`
	// example:
	//
	// SYSTEM
	Trigger *string `json:"trigger,omitempty" xml:"trigger,omitempty"`
}

func (s DescribeDiagnoseReportResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnoseReportResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeDiagnoseReportResponseBodyResult) SetCreateTime(v int64) *DescribeDiagnoseReportResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResult) SetDiagnoseItems(v []*DescribeDiagnoseReportResponseBodyResultDiagnoseItems) *DescribeDiagnoseReportResponseBodyResult {
	s.DiagnoseItems = v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResult) SetHealth(v string) *DescribeDiagnoseReportResponseBodyResult {
	s.Health = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResult) SetInstanceId(v string) *DescribeDiagnoseReportResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResult) SetReportId(v string) *DescribeDiagnoseReportResponseBodyResult {
	s.ReportId = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResult) SetState(v string) *DescribeDiagnoseReportResponseBodyResult {
	s.State = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResult) SetTrigger(v string) *DescribeDiagnoseReportResponseBodyResult {
	s.Trigger = &v
	return s
}

type DescribeDiagnoseReportResponseBodyResultDiagnoseItems struct {
	Detail *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail `json:"detail,omitempty" xml:"detail,omitempty" type:"Struct"`
	// example:
	//
	// YELLOW
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// example:
	//
	// IndexAliasUseDiagnostic
	Item *string `json:"item,omitempty" xml:"item,omitempty"`
}

func (s DescribeDiagnoseReportResponseBodyResultDiagnoseItems) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnoseReportResponseBodyResultDiagnoseItems) GoString() string {
	return s.String()
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItems) SetDetail(v *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) *DescribeDiagnoseReportResponseBodyResultDiagnoseItems {
	s.Detail = v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItems) SetHealth(v string) *DescribeDiagnoseReportResponseBodyResultDiagnoseItems {
	s.Health = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItems) SetItem(v string) *DescribeDiagnoseReportResponseBodyResultDiagnoseItems {
	s.Item = &v
	return s
}

type DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail struct {
	// example:
	//
	// Check whether the number of replica shards is optimal and easy to maintain
	Desc *string `json:"desc,omitempty" xml:"desc,omitempty"`
	// example:
	//
	// Number of Replica Shards
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// You may need to adjust the numbers of replica shards of some indices as follows: [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]
	Result *string `json:"result,omitempty" xml:"result,omitempty"`
	// example:
	//
	// You can call the following function in the Elasticsearch API....
	Suggest *string `json:"suggest,omitempty" xml:"suggest,omitempty"`
	// example:
	//
	// ES_API
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) GoString() string {
	return s.String()
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetDesc(v string) *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Desc = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetName(v string) *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Name = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetResult(v string) *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Result = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetSuggest(v string) *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Suggest = &v
	return s
}

func (s *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetType(v string) *DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Type = &v
	return s
}

type DescribeDiagnoseReportResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDiagnoseReportResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDiagnoseReportResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnoseReportResponse) GoString() string {
	return s.String()
}

func (s *DescribeDiagnoseReportResponse) SetHeaders(v map[string]*string) *DescribeDiagnoseReportResponse {
	s.Headers = v
	return s
}

func (s *DescribeDiagnoseReportResponse) SetStatusCode(v int32) *DescribeDiagnoseReportResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDiagnoseReportResponse) SetBody(v *DescribeDiagnoseReportResponseBody) *DescribeDiagnoseReportResponse {
	s.Body = v
	return s
}

type DescribeDiagnosisSettingsRequest struct {
	// The language of the returned result. Default value: en.
	//
	// example:
	//
	// en
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s DescribeDiagnosisSettingsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosisSettingsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosisSettingsRequest) SetLang(v string) *DescribeDiagnosisSettingsRequest {
	s.Lang = &v
	return s
}

type DescribeDiagnosisSettingsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5E82B8A8-EED7-4557-A6E9-D1AD3E58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result *DescribeDiagnosisSettingsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeDiagnosisSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosisSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosisSettingsResponseBody) SetRequestId(v string) *DescribeDiagnosisSettingsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDiagnosisSettingsResponseBody) SetResult(v *DescribeDiagnosisSettingsResponseBodyResult) *DescribeDiagnosisSettingsResponseBody {
	s.Result = v
	return s
}

type DescribeDiagnosisSettingsResponseBodyResult struct {
	// Scenarios of intelligent maintenance.
	//
	// example:
	//
	// Business Search
	Scene *string `json:"scene,omitempty" xml:"scene,omitempty"`
	// The timestamp of the last update for Intelligent Maintenance scenarios.
	//
	// example:
	//
	// 1588994035385
	UpdateTime *int64 `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
}

func (s DescribeDiagnosisSettingsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosisSettingsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosisSettingsResponseBodyResult) SetScene(v string) *DescribeDiagnosisSettingsResponseBodyResult {
	s.Scene = &v
	return s
}

func (s *DescribeDiagnosisSettingsResponseBodyResult) SetUpdateTime(v int64) *DescribeDiagnosisSettingsResponseBodyResult {
	s.UpdateTime = &v
	return s
}

type DescribeDiagnosisSettingsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDiagnosisSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDiagnosisSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDiagnosisSettingsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDiagnosisSettingsResponse) SetHeaders(v map[string]*string) *DescribeDiagnosisSettingsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDiagnosisSettingsResponse) SetStatusCode(v int32) *DescribeDiagnosisSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDiagnosisSettingsResponse) SetBody(v *DescribeDiagnosisSettingsResponseBody) *DescribeDiagnosisSettingsResponse {
	s.Body = v
	return s
}

type DescribeDynamicSettingsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DescribeDynamicSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDynamicSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDynamicSettingsResponseBody) SetRequestId(v string) *DescribeDynamicSettingsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDynamicSettingsResponseBody) SetResult(v string) *DescribeDynamicSettingsResponseBody {
	s.Result = &v
	return s
}

type DescribeDynamicSettingsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDynamicSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDynamicSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDynamicSettingsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDynamicSettingsResponse) SetHeaders(v map[string]*string) *DescribeDynamicSettingsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDynamicSettingsResponse) SetStatusCode(v int32) *DescribeDynamicSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDynamicSettingsResponse) SetBody(v *DescribeDynamicSettingsResponseBody) *DescribeDynamicSettingsResponse {
	s.Body = v
	return s
}

type DescribeElasticsearchHealthResponseBody struct {
	// The response code returned.
	//
	// example:
	//
	// 200
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response message returned.
	//
	// example:
	//
	// success
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 0731F217-2C8A-4D42-8BCD-5C352866E3B7
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The color that indicates the health status of the cluster.
	//
	// example:
	//
	// GREEN
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DescribeElasticsearchHealthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticsearchHealthResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeElasticsearchHealthResponseBody) SetCode(v string) *DescribeElasticsearchHealthResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeElasticsearchHealthResponseBody) SetMessage(v string) *DescribeElasticsearchHealthResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeElasticsearchHealthResponseBody) SetRequestId(v string) *DescribeElasticsearchHealthResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeElasticsearchHealthResponseBody) SetResult(v string) *DescribeElasticsearchHealthResponseBody {
	s.Result = &v
	return s
}

type DescribeElasticsearchHealthResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeElasticsearchHealthResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeElasticsearchHealthResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticsearchHealthResponse) GoString() string {
	return s.String()
}

func (s *DescribeElasticsearchHealthResponse) SetHeaders(v map[string]*string) *DescribeElasticsearchHealthResponse {
	s.Headers = v
	return s
}

func (s *DescribeElasticsearchHealthResponse) SetStatusCode(v int32) *DescribeElasticsearchHealthResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeElasticsearchHealthResponse) SetBody(v *DescribeElasticsearchHealthResponseBody) *DescribeElasticsearchHealthResponse {
	s.Body = v
	return s
}

type DescribeILMPolicyResponseBody struct {
	// example:
	//
	// FF44681E-FD41-4FDE-B8DF-295DCDD6****
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *DescribeILMPolicyResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeILMPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeILMPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeILMPolicyResponseBody) SetRequestId(v string) *DescribeILMPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeILMPolicyResponseBody) SetResult(v *DescribeILMPolicyResponseBodyResult) *DescribeILMPolicyResponseBody {
	s.Result = v
	return s
}

type DescribeILMPolicyResponseBodyResult struct {
	// example:
	//
	// ilm-history-ilm-policy
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// {"cold":{"minAge":"30d","actions":{"allocate":{"numberOfReplicas":1,"require":{"boxType":"warm"}},"setPriority":{"priority":100}}},"hot":{"minAge":"0s","actions":{"rollover":{"maxAge":"30d","maxDocs":10000,"maxSize":"50gb"},"setPriority":{"priority":1000}}},"delete":{"minAge":"30d","actions":{"delete":{}}}}
	Phases map[string]interface{} `json:"phases,omitempty" xml:"phases,omitempty"`
}

func (s DescribeILMPolicyResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeILMPolicyResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeILMPolicyResponseBodyResult) SetName(v string) *DescribeILMPolicyResponseBodyResult {
	s.Name = &v
	return s
}

func (s *DescribeILMPolicyResponseBodyResult) SetPhases(v map[string]interface{}) *DescribeILMPolicyResponseBodyResult {
	s.Phases = v
	return s
}

type DescribeILMPolicyResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeILMPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeILMPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeILMPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeILMPolicyResponse) SetHeaders(v map[string]*string) *DescribeILMPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeILMPolicyResponse) SetStatusCode(v int32) *DescribeILMPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeILMPolicyResponse) SetBody(v *DescribeILMPolicyResponseBody) *DescribeILMPolicyResponse {
	s.Body = v
	return s
}

type DescribeIndexTemplateResponseBody struct {
	// example:
	//
	// 25DB38F8-82E4-4D16-82BB-FF077C7F****
	RequestId *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *DescribeIndexTemplateResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeIndexTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIndexTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIndexTemplateResponseBody) SetRequestId(v string) *DescribeIndexTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIndexTemplateResponseBody) SetResult(v *DescribeIndexTemplateResponseBodyResult) *DescribeIndexTemplateResponseBody {
	s.Result = v
	return s
}

type DescribeIndexTemplateResponseBodyResult struct {
	// example:
	//
	// true
	DataStream *bool `json:"dataStream,omitempty" xml:"dataStream,omitempty"`
	// example:
	//
	// cube_default_ilm_policy
	IlmPolicy     *string   `json:"ilmPolicy,omitempty" xml:"ilmPolicy,omitempty"`
	IndexPatterns []*string `json:"indexPatterns,omitempty" xml:"indexPatterns,omitempty" type:"Repeated"`
	// example:
	//
	// data-stream-default
	IndexTemplate *string `json:"indexTemplate,omitempty" xml:"indexTemplate,omitempty"`
	// example:
	//
	// 0
	Priority *int32                                           `json:"priority,omitempty" xml:"priority,omitempty"`
	Template *DescribeIndexTemplateResponseBodyResultTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
}

func (s DescribeIndexTemplateResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeIndexTemplateResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeIndexTemplateResponseBodyResult) SetDataStream(v bool) *DescribeIndexTemplateResponseBodyResult {
	s.DataStream = &v
	return s
}

func (s *DescribeIndexTemplateResponseBodyResult) SetIlmPolicy(v string) *DescribeIndexTemplateResponseBodyResult {
	s.IlmPolicy = &v
	return s
}

func (s *DescribeIndexTemplateResponseBodyResult) SetIndexPatterns(v []*string) *DescribeIndexTemplateResponseBodyResult {
	s.IndexPatterns = v
	return s
}

func (s *DescribeIndexTemplateResponseBodyResult) SetIndexTemplate(v string) *DescribeIndexTemplateResponseBodyResult {
	s.IndexTemplate = &v
	return s
}

func (s *DescribeIndexTemplateResponseBodyResult) SetPriority(v int32) *DescribeIndexTemplateResponseBodyResult {
	s.Priority = &v
	return s
}

func (s *DescribeIndexTemplateResponseBodyResult) SetTemplate(v *DescribeIndexTemplateResponseBodyResultTemplate) *DescribeIndexTemplateResponseBodyResult {
	s.Template = v
	return s
}

type DescribeIndexTemplateResponseBodyResultTemplate struct {
	// example:
	//
	// {\\"mydata\\":{}}
	Aliases *string `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// {\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}
	Mappings *string `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// {\\"index.refresh_interval\\":\\"1s\\"}
	Settings *string `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s DescribeIndexTemplateResponseBodyResultTemplate) String() string {
	return tea.Prettify(s)
}

func (s DescribeIndexTemplateResponseBodyResultTemplate) GoString() string {
	return s.String()
}

func (s *DescribeIndexTemplateResponseBodyResultTemplate) SetAliases(v string) *DescribeIndexTemplateResponseBodyResultTemplate {
	s.Aliases = &v
	return s
}

func (s *DescribeIndexTemplateResponseBodyResultTemplate) SetMappings(v string) *DescribeIndexTemplateResponseBodyResultTemplate {
	s.Mappings = &v
	return s
}

func (s *DescribeIndexTemplateResponseBodyResultTemplate) SetSettings(v string) *DescribeIndexTemplateResponseBodyResultTemplate {
	s.Settings = &v
	return s
}

type DescribeIndexTemplateResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeIndexTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeIndexTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIndexTemplateResponse) GoString() string {
	return s.String()
}

func (s *DescribeIndexTemplateResponse) SetHeaders(v map[string]*string) *DescribeIndexTemplateResponse {
	s.Headers = v
	return s
}

func (s *DescribeIndexTemplateResponse) SetStatusCode(v int32) *DescribeIndexTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIndexTemplateResponse) SetBody(v *DescribeIndexTemplateResponseBody) *DescribeIndexTemplateResponse {
	s.Body = v
	return s
}

type DescribeInstanceResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *DescribeInstanceResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBody) SetRequestId(v string) *DescribeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstanceResponseBody) SetResult(v *DescribeInstanceResponseBodyResult) *DescribeInstanceResponseBody {
	s.Result = v
	return s
}

type DescribeInstanceResponseBodyResult struct {
	// example:
	//
	// true
	AdvancedDedicateMaster  *bool                                                      `json:"advancedDedicateMaster,omitempty" xml:"advancedDedicateMaster,omitempty"`
	AdvancedSetting         *DescribeInstanceResponseBodyResultAdvancedSetting         `json:"advancedSetting,omitempty" xml:"advancedSetting,omitempty" type:"Struct"`
	AliwsDicts              []*DescribeInstanceResponseBodyResultAliwsDicts            `json:"aliwsDicts,omitempty" xml:"aliwsDicts,omitempty" type:"Repeated"`
	ArchType                *string                                                    `json:"archType,omitempty" xml:"archType,omitempty"`
	ClientNodeConfiguration *DescribeInstanceResponseBodyResultClientNodeConfiguration `json:"clientNodeConfiguration,omitempty" xml:"clientNodeConfiguration,omitempty" type:"Struct"`
	// example:
	//
	// 2018-07-13T03:58:07.253Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// example:
	//
	// false
	DedicateMaster *bool `json:"dedicateMaster,omitempty" xml:"dedicateMaster,omitempty"`
	// example:
	//
	// es-cn-abc
	Description *string                                       `json:"description,omitempty" xml:"description,omitempty"`
	DictList    []*DescribeInstanceResponseBodyResultDictList `json:"dictList,omitempty" xml:"dictList,omitempty" type:"Repeated"`
	// example:
	//
	// es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com
	Domain                       *string                                                         `json:"domain,omitempty" xml:"domain,omitempty"`
	ElasticDataNodeConfiguration *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration `json:"elasticDataNodeConfiguration,omitempty" xml:"elasticDataNodeConfiguration,omitempty" type:"Struct"`
	// example:
	//
	// false
	EnableKibanaPrivateNetwork *bool `json:"enableKibanaPrivateNetwork,omitempty" xml:"enableKibanaPrivateNetwork,omitempty"`
	// example:
	//
	// true
	EnableKibanaPublicNetwork *bool `json:"enableKibanaPublicNetwork,omitempty" xml:"enableKibanaPublicNetwork,omitempty"`
	// example:
	//
	// true
	EnablePublic *bool  `json:"enablePublic,omitempty" xml:"enablePublic,omitempty"`
	Endtime      *int64 `json:"endtime,omitempty" xml:"endtime,omitempty"`
	// example:
	//
	// {"http.cors.allow-credentials":"false"}
	EsConfig      map[string]interface{} `json:"esConfig,omitempty" xml:"esConfig,omitempty"`
	EsIPBlacklist []*string              `json:"esIPBlacklist,omitempty" xml:"esIPBlacklist,omitempty" type:"Repeated"`
	EsIPWhitelist []*string              `json:"esIPWhitelist,omitempty" xml:"esIPWhitelist,omitempty" type:"Repeated"`
	// example:
	//
	// 6.3.2_with_X-Pack
	EsVersion     *string                  `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	ExtendConfigs []map[string]interface{} `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// example:
	//
	// true
	HaveClientNode *bool `json:"haveClientNode,omitempty" xml:"haveClientNode,omitempty"`
	// example:
	//
	// true
	HaveKibana *bool                                           `json:"haveKibana,omitempty" xml:"haveKibana,omitempty"`
	IkHotDicts []*DescribeInstanceResponseBodyResultIkHotDicts `json:"ikHotDicts,omitempty" xml:"ikHotDicts,omitempty" type:"Repeated"`
	// example:
	//
	// advanced
	InstanceCategory *string `json:"instanceCategory,omitempty" xml:"instanceCategory,omitempty"`
	// example:
	//
	// es-cn-3h4k3axh33th9****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// true
	IsNewDeployment     *bool                                                  `json:"isNewDeployment,omitempty" xml:"isNewDeployment,omitempty"`
	KibanaConfiguration *DescribeInstanceResponseBodyResultKibanaConfiguration `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty" type:"Struct"`
	// example:
	//
	// es-cn-3h4k3axh33th9****.kibana.elasticsearch.aliyuncs.com
	KibanaDomain      *string   `json:"kibanaDomain,omitempty" xml:"kibanaDomain,omitempty"`
	KibanaIPWhitelist []*string `json:"kibanaIPWhitelist,omitempty" xml:"kibanaIPWhitelist,omitempty" type:"Repeated"`
	// example:
	//
	// 5601
	KibanaPort               *int32                                                 `json:"kibanaPort,omitempty" xml:"kibanaPort,omitempty"`
	KibanaPrivateIPWhitelist []*string                                              `json:"kibanaPrivateIPWhitelist,omitempty" xml:"kibanaPrivateIPWhitelist,omitempty" type:"Repeated"`
	MasterConfiguration      *DescribeInstanceResponseBodyResultMasterConfiguration `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty" type:"Struct"`
	NetworkConfig            *DescribeInstanceResponseBodyResultNetworkConfig       `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	// example:
	//
	// 2
	NodeAmount *int32                                      `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	NodeSpec   *DescribeInstanceResponseBodyResultNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
	// example:
	//
	// active
	PostpaidServiceStatus     *string   `json:"postpaidServiceStatus,omitempty" xml:"postpaidServiceStatus,omitempty"`
	PrivateNetworkIpWhiteList []*string `json:"privateNetworkIpWhiteList,omitempty" xml:"privateNetworkIpWhiteList,omitempty" type:"Repeated"`
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// example:
	//
	// es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com
	PublicDomain      *string   `json:"publicDomain,omitempty" xml:"publicDomain,omitempty"`
	PublicIpWhitelist []*string `json:"publicIpWhitelist,omitempty" xml:"publicIpWhitelist,omitempty" type:"Repeated"`
	// example:
	//
	// 9200
	PublicPort *int32 `json:"publicPort,omitempty" xml:"publicPort,omitempty"`
	// example:
	//
	// rg-aekzvowej3i****
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// example:
	//
	// true
	ServiceVpc *bool `json:"serviceVpc,omitempty" xml:"serviceVpc,omitempty"`
	// example:
	//
	// active
	Status        *string                                            `json:"status,omitempty" xml:"status,omitempty"`
	SynonymsDicts []*DescribeInstanceResponseBodyResultSynonymsDicts `json:"synonymsDicts,omitempty" xml:"synonymsDicts,omitempty" type:"Repeated"`
	Tags          []*DescribeInstanceResponseBodyResultTags          `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	// example:
	//
	// 2018-07-13T03:58:07.253Z
	UpdatedAt *string `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	// example:
	//
	// vpc-bp1uag5jj38c****
	VpcInstanceId *string `json:"vpcInstanceId,omitempty" xml:"vpcInstanceId,omitempty"`
	// example:
	//
	// true
	WarmNode              *bool                                                    `json:"warmNode,omitempty" xml:"warmNode,omitempty"`
	WarmNodeConfiguration *DescribeInstanceResponseBodyResultWarmNodeConfiguration `json:"warmNodeConfiguration,omitempty" xml:"warmNodeConfiguration,omitempty" type:"Struct"`
	// example:
	//
	// 2
	ZoneCount *int32                                         `json:"zoneCount,omitempty" xml:"zoneCount,omitempty"`
	ZoneInfos []*DescribeInstanceResponseBodyResultZoneInfos `json:"zoneInfos,omitempty" xml:"zoneInfos,omitempty" type:"Repeated"`
}

func (s DescribeInstanceResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResult) SetAdvancedDedicateMaster(v bool) *DescribeInstanceResponseBodyResult {
	s.AdvancedDedicateMaster = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetAdvancedSetting(v *DescribeInstanceResponseBodyResultAdvancedSetting) *DescribeInstanceResponseBodyResult {
	s.AdvancedSetting = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetAliwsDicts(v []*DescribeInstanceResponseBodyResultAliwsDicts) *DescribeInstanceResponseBodyResult {
	s.AliwsDicts = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetArchType(v string) *DescribeInstanceResponseBodyResult {
	s.ArchType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetClientNodeConfiguration(v *DescribeInstanceResponseBodyResultClientNodeConfiguration) *DescribeInstanceResponseBodyResult {
	s.ClientNodeConfiguration = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetCreatedAt(v string) *DescribeInstanceResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetDedicateMaster(v bool) *DescribeInstanceResponseBodyResult {
	s.DedicateMaster = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetDescription(v string) *DescribeInstanceResponseBodyResult {
	s.Description = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetDictList(v []*DescribeInstanceResponseBodyResultDictList) *DescribeInstanceResponseBodyResult {
	s.DictList = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetDomain(v string) *DescribeInstanceResponseBodyResult {
	s.Domain = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetElasticDataNodeConfiguration(v *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) *DescribeInstanceResponseBodyResult {
	s.ElasticDataNodeConfiguration = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEnableKibanaPrivateNetwork(v bool) *DescribeInstanceResponseBodyResult {
	s.EnableKibanaPrivateNetwork = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEnableKibanaPublicNetwork(v bool) *DescribeInstanceResponseBodyResult {
	s.EnableKibanaPublicNetwork = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEnablePublic(v bool) *DescribeInstanceResponseBodyResult {
	s.EnablePublic = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEndtime(v int64) *DescribeInstanceResponseBodyResult {
	s.Endtime = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEsConfig(v map[string]interface{}) *DescribeInstanceResponseBodyResult {
	s.EsConfig = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEsIPBlacklist(v []*string) *DescribeInstanceResponseBodyResult {
	s.EsIPBlacklist = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEsIPWhitelist(v []*string) *DescribeInstanceResponseBodyResult {
	s.EsIPWhitelist = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetEsVersion(v string) *DescribeInstanceResponseBodyResult {
	s.EsVersion = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetExtendConfigs(v []map[string]interface{}) *DescribeInstanceResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetHaveClientNode(v bool) *DescribeInstanceResponseBodyResult {
	s.HaveClientNode = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetHaveKibana(v bool) *DescribeInstanceResponseBodyResult {
	s.HaveKibana = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetIkHotDicts(v []*DescribeInstanceResponseBodyResultIkHotDicts) *DescribeInstanceResponseBodyResult {
	s.IkHotDicts = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetInstanceCategory(v string) *DescribeInstanceResponseBodyResult {
	s.InstanceCategory = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetInstanceId(v string) *DescribeInstanceResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetIsNewDeployment(v bool) *DescribeInstanceResponseBodyResult {
	s.IsNewDeployment = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetKibanaConfiguration(v *DescribeInstanceResponseBodyResultKibanaConfiguration) *DescribeInstanceResponseBodyResult {
	s.KibanaConfiguration = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetKibanaDomain(v string) *DescribeInstanceResponseBodyResult {
	s.KibanaDomain = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetKibanaIPWhitelist(v []*string) *DescribeInstanceResponseBodyResult {
	s.KibanaIPWhitelist = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetKibanaPort(v int32) *DescribeInstanceResponseBodyResult {
	s.KibanaPort = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetKibanaPrivateIPWhitelist(v []*string) *DescribeInstanceResponseBodyResult {
	s.KibanaPrivateIPWhitelist = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetMasterConfiguration(v *DescribeInstanceResponseBodyResultMasterConfiguration) *DescribeInstanceResponseBodyResult {
	s.MasterConfiguration = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetNetworkConfig(v *DescribeInstanceResponseBodyResultNetworkConfig) *DescribeInstanceResponseBodyResult {
	s.NetworkConfig = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetNodeAmount(v int32) *DescribeInstanceResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetNodeSpec(v *DescribeInstanceResponseBodyResultNodeSpec) *DescribeInstanceResponseBodyResult {
	s.NodeSpec = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetPaymentType(v string) *DescribeInstanceResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetPort(v int32) *DescribeInstanceResponseBodyResult {
	s.Port = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetPostpaidServiceStatus(v string) *DescribeInstanceResponseBodyResult {
	s.PostpaidServiceStatus = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetPrivateNetworkIpWhiteList(v []*string) *DescribeInstanceResponseBodyResult {
	s.PrivateNetworkIpWhiteList = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetProtocol(v string) *DescribeInstanceResponseBodyResult {
	s.Protocol = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetPublicDomain(v string) *DescribeInstanceResponseBodyResult {
	s.PublicDomain = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetPublicIpWhitelist(v []*string) *DescribeInstanceResponseBodyResult {
	s.PublicIpWhitelist = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetPublicPort(v int32) *DescribeInstanceResponseBodyResult {
	s.PublicPort = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetResourceGroupId(v string) *DescribeInstanceResponseBodyResult {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetServiceVpc(v bool) *DescribeInstanceResponseBodyResult {
	s.ServiceVpc = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetStatus(v string) *DescribeInstanceResponseBodyResult {
	s.Status = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetSynonymsDicts(v []*DescribeInstanceResponseBodyResultSynonymsDicts) *DescribeInstanceResponseBodyResult {
	s.SynonymsDicts = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetTags(v []*DescribeInstanceResponseBodyResultTags) *DescribeInstanceResponseBodyResult {
	s.Tags = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetUpdatedAt(v string) *DescribeInstanceResponseBodyResult {
	s.UpdatedAt = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetVpcInstanceId(v string) *DescribeInstanceResponseBodyResult {
	s.VpcInstanceId = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetWarmNode(v bool) *DescribeInstanceResponseBodyResult {
	s.WarmNode = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetWarmNodeConfiguration(v *DescribeInstanceResponseBodyResultWarmNodeConfiguration) *DescribeInstanceResponseBodyResult {
	s.WarmNodeConfiguration = v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetZoneCount(v int32) *DescribeInstanceResponseBodyResult {
	s.ZoneCount = &v
	return s
}

func (s *DescribeInstanceResponseBodyResult) SetZoneInfos(v []*DescribeInstanceResponseBodyResultZoneInfos) *DescribeInstanceResponseBodyResult {
	s.ZoneInfos = v
	return s
}

type DescribeInstanceResponseBodyResultAdvancedSetting struct {
	// example:
	//
	// CMS
	GcName *string `json:"gcName,omitempty" xml:"gcName,omitempty"`
}

func (s DescribeInstanceResponseBodyResultAdvancedSetting) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultAdvancedSetting) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultAdvancedSetting) SetGcName(v string) *DescribeInstanceResponseBodyResultAdvancedSetting {
	s.GcName = &v
	return s
}

type DescribeInstanceResponseBodyResultAliwsDicts struct {
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// example:
	//
	// aliws_ext_dict.txt
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// OSS
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// example:
	//
	// ALI_WS
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s DescribeInstanceResponseBodyResultAliwsDicts) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultAliwsDicts) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultAliwsDicts) SetFileSize(v int64) *DescribeInstanceResponseBodyResultAliwsDicts {
	s.FileSize = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultAliwsDicts) SetName(v string) *DescribeInstanceResponseBodyResultAliwsDicts {
	s.Name = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultAliwsDicts) SetSourceType(v string) *DescribeInstanceResponseBodyResultAliwsDicts {
	s.SourceType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultAliwsDicts) SetType(v string) *DescribeInstanceResponseBodyResultAliwsDicts {
	s.Type = &v
	return s
}

type DescribeInstanceResponseBodyResultClientNodeConfiguration struct {
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// example:
	//
	// 40
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// cloud_efficiency
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// elasticsearch.n4.small
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s DescribeInstanceResponseBodyResultClientNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultClientNodeConfiguration) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultClientNodeConfiguration) SetAmount(v int32) *DescribeInstanceResponseBodyResultClientNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultClientNodeConfiguration) SetDisk(v int32) *DescribeInstanceResponseBodyResultClientNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultClientNodeConfiguration) SetDiskType(v string) *DescribeInstanceResponseBodyResultClientNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultClientNodeConfiguration) SetSpec(v string) *DescribeInstanceResponseBodyResultClientNodeConfiguration {
	s.Spec = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultClientNodeConfiguration) SetSpecInfo(v string) *DescribeInstanceResponseBodyResultClientNodeConfiguration {
	s.SpecInfo = &v
	return s
}

type DescribeInstanceResponseBodyResultDictList struct {
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// example:
	//
	// MAIN
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s DescribeInstanceResponseBodyResultDictList) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultDictList) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultDictList) SetFileSize(v int64) *DescribeInstanceResponseBodyResultDictList {
	s.FileSize = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultDictList) SetName(v string) *DescribeInstanceResponseBodyResultDictList {
	s.Name = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultDictList) SetSourceType(v string) *DescribeInstanceResponseBodyResultDictList {
	s.SourceType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultDictList) SetType(v string) *DescribeInstanceResponseBodyResultDictList {
	s.Type = &v
	return s
}

type DescribeInstanceResponseBodyResultElasticDataNodeConfiguration struct {
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// true
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) SetAmount(v int32) *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) SetDisk(v int32) *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) SetDiskEncryption(v bool) *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.DiskEncryption = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) SetDiskType(v string) *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) SetSpec(v string) *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.Spec = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration) SetSpecInfo(v string) *DescribeInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.SpecInfo = &v
	return s
}

type DescribeInstanceResponseBodyResultIkHotDicts struct {
	// example:
	//
	// 6
	FileSize *int32 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// example:
	//
	// deploy_0.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// OSS
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// example:
	//
	// MAIN
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s DescribeInstanceResponseBodyResultIkHotDicts) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultIkHotDicts) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultIkHotDicts) SetFileSize(v int32) *DescribeInstanceResponseBodyResultIkHotDicts {
	s.FileSize = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultIkHotDicts) SetName(v string) *DescribeInstanceResponseBodyResultIkHotDicts {
	s.Name = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultIkHotDicts) SetSourceType(v string) *DescribeInstanceResponseBodyResultIkHotDicts {
	s.SourceType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultIkHotDicts) SetType(v string) *DescribeInstanceResponseBodyResultIkHotDicts {
	s.Type = &v
	return s
}

type DescribeInstanceResponseBodyResultKibanaConfiguration struct {
	// example:
	//
	// 1
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// elasticsearch.n4.small
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s DescribeInstanceResponseBodyResultKibanaConfiguration) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultKibanaConfiguration) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultKibanaConfiguration) SetAmount(v int32) *DescribeInstanceResponseBodyResultKibanaConfiguration {
	s.Amount = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultKibanaConfiguration) SetDisk(v int32) *DescribeInstanceResponseBodyResultKibanaConfiguration {
	s.Disk = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultKibanaConfiguration) SetSpec(v string) *DescribeInstanceResponseBodyResultKibanaConfiguration {
	s.Spec = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultKibanaConfiguration) SetSpecInfo(v string) *DescribeInstanceResponseBodyResultKibanaConfiguration {
	s.SpecInfo = &v
	return s
}

type DescribeInstanceResponseBodyResultMasterConfiguration struct {
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// example:
	//
	// 40
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// elasticsearch.n4.small
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s DescribeInstanceResponseBodyResultMasterConfiguration) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultMasterConfiguration) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultMasterConfiguration) SetAmount(v int32) *DescribeInstanceResponseBodyResultMasterConfiguration {
	s.Amount = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultMasterConfiguration) SetDisk(v int32) *DescribeInstanceResponseBodyResultMasterConfiguration {
	s.Disk = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultMasterConfiguration) SetDiskType(v string) *DescribeInstanceResponseBodyResultMasterConfiguration {
	s.DiskType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultMasterConfiguration) SetSpec(v string) *DescribeInstanceResponseBodyResultMasterConfiguration {
	s.Spec = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultMasterConfiguration) SetSpecInfo(v string) *DescribeInstanceResponseBodyResultMasterConfiguration {
	s.SpecInfo = &v
	return s
}

type DescribeInstanceResponseBodyResultNetworkConfig struct {
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// example:
	//
	// vpc-abc
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// example:
	//
	// cn-hangzhou-b
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// example:
	//
	// vsw-abc
	VswitchId        *string                                                            `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
	WhiteIpGroupList []*DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList `json:"whiteIpGroupList,omitempty" xml:"whiteIpGroupList,omitempty" type:"Repeated"`
}

func (s DescribeInstanceResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultNetworkConfig) SetType(v string) *DescribeInstanceResponseBodyResultNetworkConfig {
	s.Type = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNetworkConfig) SetVpcId(v string) *DescribeInstanceResponseBodyResultNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNetworkConfig) SetVsArea(v string) *DescribeInstanceResponseBodyResultNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNetworkConfig) SetVswitchId(v string) *DescribeInstanceResponseBodyResultNetworkConfig {
	s.VswitchId = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNetworkConfig) SetWhiteIpGroupList(v []*DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) *DescribeInstanceResponseBodyResultNetworkConfig {
	s.WhiteIpGroupList = v
	return s
}

type DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList struct {
	// example:
	//
	// default
	GroupName *string   `json:"groupName,omitempty" xml:"groupName,omitempty"`
	Ips       []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
	// example:
	//
	// PRIVATE_ES
	WhiteIpType *string `json:"whiteIpType,omitempty" xml:"whiteIpType,omitempty"`
}

func (s DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) SetGroupName(v string) *DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.GroupName = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) SetIps(v []*string) *DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.Ips = v
	return s
}

func (s *DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) SetWhiteIpType(v string) *DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.WhiteIpType = &v
	return s
}

type DescribeInstanceResponseBodyResultNodeSpec struct {
	// example:
	//
	// 0
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// true
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// PL1
	PerformanceLevel *string `json:"performanceLevel,omitempty" xml:"performanceLevel,omitempty"`
	// example:
	//
	// elasticsearch.n4.small
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s DescribeInstanceResponseBodyResultNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultNodeSpec) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultNodeSpec) SetDisk(v int32) *DescribeInstanceResponseBodyResultNodeSpec {
	s.Disk = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNodeSpec) SetDiskEncryption(v bool) *DescribeInstanceResponseBodyResultNodeSpec {
	s.DiskEncryption = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNodeSpec) SetDiskType(v string) *DescribeInstanceResponseBodyResultNodeSpec {
	s.DiskType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNodeSpec) SetPerformanceLevel(v string) *DescribeInstanceResponseBodyResultNodeSpec {
	s.PerformanceLevel = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNodeSpec) SetSpec(v string) *DescribeInstanceResponseBodyResultNodeSpec {
	s.Spec = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultNodeSpec) SetSpecInfo(v string) *DescribeInstanceResponseBodyResultNodeSpec {
	s.SpecInfo = &v
	return s
}

type DescribeInstanceResponseBodyResultSynonymsDicts struct {
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// example:
	//
	// STOP
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s DescribeInstanceResponseBodyResultSynonymsDicts) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultSynonymsDicts) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultSynonymsDicts) SetFileSize(v int64) *DescribeInstanceResponseBodyResultSynonymsDicts {
	s.FileSize = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultSynonymsDicts) SetName(v string) *DescribeInstanceResponseBodyResultSynonymsDicts {
	s.Name = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultSynonymsDicts) SetSourceType(v string) *DescribeInstanceResponseBodyResultSynonymsDicts {
	s.SourceType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultSynonymsDicts) SetType(v string) *DescribeInstanceResponseBodyResultSynonymsDicts {
	s.Type = &v
	return s
}

type DescribeInstanceResponseBodyResultTags struct {
	// example:
	//
	// env
	TagKey *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	// example:
	//
	// dev
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s DescribeInstanceResponseBodyResultTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultTags) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultTags) SetTagKey(v string) *DescribeInstanceResponseBodyResultTags {
	s.TagKey = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultTags) SetTagValue(v string) *DescribeInstanceResponseBodyResultTags {
	s.TagValue = &v
	return s
}

type DescribeInstanceResponseBodyResultWarmNodeConfiguration struct {
	// example:
	//
	// 6
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// example:
	//
	// 500
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// true
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// example:
	//
	// cloud_efficiency
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// elasticsearch.n4.small
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s DescribeInstanceResponseBodyResultWarmNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultWarmNodeConfiguration) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultWarmNodeConfiguration) SetAmount(v int32) *DescribeInstanceResponseBodyResultWarmNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultWarmNodeConfiguration) SetDisk(v int32) *DescribeInstanceResponseBodyResultWarmNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultWarmNodeConfiguration) SetDiskEncryption(v bool) *DescribeInstanceResponseBodyResultWarmNodeConfiguration {
	s.DiskEncryption = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultWarmNodeConfiguration) SetDiskType(v string) *DescribeInstanceResponseBodyResultWarmNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultWarmNodeConfiguration) SetSpec(v string) *DescribeInstanceResponseBodyResultWarmNodeConfiguration {
	s.Spec = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultWarmNodeConfiguration) SetSpecInfo(v string) *DescribeInstanceResponseBodyResultWarmNodeConfiguration {
	s.SpecInfo = &v
	return s
}

type DescribeInstanceResponseBodyResultZoneInfos struct {
	// example:
	//
	// NORMAL
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// example:
	//
	// cn-hangzhou-b
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s DescribeInstanceResponseBodyResultZoneInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponseBodyResultZoneInfos) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponseBodyResultZoneInfos) SetStatus(v string) *DescribeInstanceResponseBodyResultZoneInfos {
	s.Status = &v
	return s
}

func (s *DescribeInstanceResponseBodyResultZoneInfos) SetZoneId(v string) *DescribeInstanceResponseBodyResultZoneInfos {
	s.ZoneId = &v
	return s
}

type DescribeInstanceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceResponse) SetHeaders(v map[string]*string) *DescribeInstanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceResponse) SetStatusCode(v int32) *DescribeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceResponse) SetBody(v *DescribeInstanceResponseBody) *DescribeInstanceResponse {
	s.Body = v
	return s
}

type DescribeKibanaSettingsResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6D*****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// {"map.includeElasticMapsService": "false", "server.ssl.cert": "/home/admin/packages/kibana/config/cert/client.crt", "server.ssl.enabled": "true", "server.ssl.key": "/home/admin/packages/kibana/config/cert/client.key", "xpack.reporting.capture.browser.chromium.disableSandbox": "true"}
	Result map[string]interface{} `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DescribeKibanaSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeKibanaSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeKibanaSettingsResponseBody) SetRequestId(v string) *DescribeKibanaSettingsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeKibanaSettingsResponseBody) SetResult(v map[string]interface{}) *DescribeKibanaSettingsResponseBody {
	s.Result = v
	return s
}

type DescribeKibanaSettingsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeKibanaSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeKibanaSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeKibanaSettingsResponse) GoString() string {
	return s.String()
}

func (s *DescribeKibanaSettingsResponse) SetHeaders(v map[string]*string) *DescribeKibanaSettingsResponse {
	s.Headers = v
	return s
}

func (s *DescribeKibanaSettingsResponse) SetStatusCode(v int32) *DescribeKibanaSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeKibanaSettingsResponse) SetBody(v *DescribeKibanaSettingsResponseBody) *DescribeKibanaSettingsResponse {
	s.Body = v
	return s
}

type DescribeLogstashResponseBody struct {
	// Detailed information about the instance.
	//
	// example:
	//
	// C9334241-4837-46C2-B24B-9BDC517318DE
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The configurations of the instance.
	Result *DescribeLogstashResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeLogstashResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponseBody) SetRequestId(v string) *DescribeLogstashResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLogstashResponseBody) SetResult(v *DescribeLogstashResponseBodyResult) *DescribeLogstashResponseBody {
	s.Result = v
	return s
}

type DescribeLogstashResponseBodyResult struct {
	// The configuration information of the node.
	ExtendConfigs []map[string]interface{} `json:"ExtendConfigs,omitempty" xml:"ExtendConfigs,omitempty" type:"Repeated"`
	// The number of data nodes.
	//
	// example:
	//
	// rg-aekzvowej3i****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The key of the tag.
	Tags []*DescribeLogstashResponseBodyResultTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The status of the zone. Valid values:
	//
	// 	- ISOLATION: offline
	//
	// 	- NORMAL
	ZoneInfos []*DescribeLogstashResponseBodyResultZoneInfos `json:"ZoneInfos,omitempty" xml:"ZoneInfos,omitempty" type:"Repeated"`
	// The billing method of the instance. Valid values:
	//
	// 	- prepaid: subscription
	//
	// 	- postpaid: pay-as-you-go
	//
	// example:
	//
	// {"slowlog.threshold.warn": "2s","slowlog.threshold.info": "1s","slowlog.threshold.debug": "500ms","slowlog.threshold.trace": "100ms" }
	Config map[string]interface{} `json:"config,omitempty" xml:"config,omitempty"`
	// The state of the instance. Four states are supported:
	//
	// 	- Normal: active
	//
	// 	- Active: activating
	//
	// 	- Freeze: inactive
	//
	// 	- Invalid: invalid
	//
	// example:
	//
	// 2020-02-06T14:12:03.672Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The time when the instance was created.
	//
	// example:
	//
	// ls-cn-abc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The ID of the zone where the node resides.
	EndpointList []*DescribeLogstashResponseBodyResultEndpointList `json:"endpointList,omitempty" xml:"endpointList,omitempty" type:"Repeated"`
	// The access information of the node.
	//
	// example:
	//
	// ls-cn-abc
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	NetworkConfig *DescribeLogstashResponseBodyResultNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	// The name of the instance.
	//
	// example:
	//
	// 2
	NodeAmount *int32 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// The specifications of the node.
	NodeSpec *DescribeLogstashResponseBodyResultNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// The ID of the resource group to which the instance belongs.
	//
	// example:
	//
	// prepaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the elastic container instances belong.
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The edition of the dedicated KMS instance.
	//
	// example:
	//
	// 2020-02-06T14:22:36.850Z
	UpdatedAt *string `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	// The ID of the instance.
	//
	// example:
	//
	// 7.4.0_with_X-Pack
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
	// The time when the instance was last updated.
	//
	// example:
	//
	// vpc-bp16k1dvzxtmagcva****
	VpcInstanceId *string `json:"vpcInstanceId,omitempty" xml:"vpcInstanceId,omitempty"`
}

func (s DescribeLogstashResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponseBodyResult) SetExtendConfigs(v []map[string]interface{}) *DescribeLogstashResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetResourceGroupId(v string) *DescribeLogstashResponseBodyResult {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetTags(v []*DescribeLogstashResponseBodyResultTags) *DescribeLogstashResponseBodyResult {
	s.Tags = v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetZoneInfos(v []*DescribeLogstashResponseBodyResultZoneInfos) *DescribeLogstashResponseBodyResult {
	s.ZoneInfos = v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetConfig(v map[string]interface{}) *DescribeLogstashResponseBodyResult {
	s.Config = v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetCreatedAt(v string) *DescribeLogstashResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetDescription(v string) *DescribeLogstashResponseBodyResult {
	s.Description = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetEndpointList(v []*DescribeLogstashResponseBodyResultEndpointList) *DescribeLogstashResponseBodyResult {
	s.EndpointList = v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetInstanceId(v string) *DescribeLogstashResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetNetworkConfig(v *DescribeLogstashResponseBodyResultNetworkConfig) *DescribeLogstashResponseBodyResult {
	s.NetworkConfig = v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetNodeAmount(v int32) *DescribeLogstashResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetNodeSpec(v *DescribeLogstashResponseBodyResultNodeSpec) *DescribeLogstashResponseBodyResult {
	s.NodeSpec = v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetPaymentType(v string) *DescribeLogstashResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetStatus(v string) *DescribeLogstashResponseBodyResult {
	s.Status = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetUpdatedAt(v string) *DescribeLogstashResponseBodyResult {
	s.UpdatedAt = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetVersion(v string) *DescribeLogstashResponseBodyResult {
	s.Version = &v
	return s
}

func (s *DescribeLogstashResponseBodyResult) SetVpcInstanceId(v string) *DescribeLogstashResponseBodyResult {
	s.VpcInstanceId = &v
	return s
}

type DescribeLogstashResponseBodyResultTags struct {
	// The value of the tag.
	//
	// example:
	//
	// env
	TagKey *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	// The information about the zones.
	//
	// example:
	//
	// dev
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s DescribeLogstashResponseBodyResultTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponseBodyResultTags) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponseBodyResultTags) SetTagKey(v string) *DescribeLogstashResponseBodyResultTags {
	s.TagKey = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultTags) SetTagValue(v string) *DescribeLogstashResponseBodyResultTags {
	s.TagValue = &v
	return s
}

type DescribeLogstashResponseBodyResultZoneInfos struct {
	// The zone ID of the new instance.
	//
	// example:
	//
	// NORMAL
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The configuration of cluster extension parameters.
	//
	// example:
	//
	// cn-hangzhou-b
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s DescribeLogstashResponseBodyResultZoneInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponseBodyResultZoneInfos) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponseBodyResultZoneInfos) SetStatus(v string) *DescribeLogstashResponseBodyResultZoneInfos {
	s.Status = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultZoneInfos) SetZoneId(v string) *DescribeLogstashResponseBodyResultZoneInfos {
	s.ZoneId = &v
	return s
}

type DescribeLogstashResponseBodyResultEndpointList struct {
	// The tags added to the ALB instance.
	//
	// example:
	//
	// 172.16.\*\*.**
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// The IP address of the node.
	//
	// example:
	//
	// 9600
	Port *string `json:"port,omitempty" xml:"port,omitempty"`
	// The port number.
	//
	// example:
	//
	// cn-hangzhou-b
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s DescribeLogstashResponseBodyResultEndpointList) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponseBodyResultEndpointList) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponseBodyResultEndpointList) SetHost(v string) *DescribeLogstashResponseBodyResultEndpointList {
	s.Host = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultEndpointList) SetPort(v string) *DescribeLogstashResponseBodyResultEndpointList {
	s.Port = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultEndpointList) SetZoneId(v string) *DescribeLogstashResponseBodyResultEndpointList {
	s.ZoneId = &v
	return s
}

type DescribeLogstashResponseBodyResultNetworkConfig struct {
	// The ID of the vSwitch to which the instance is connected.
	//
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The zone where the cluster resides.
	//
	// example:
	//
	// vpc-bp16k1dvzxtmagcva****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// The network type of the instance. Valid values: Currently, only Virtual Private Cloud (VPC) are supported.
	//
	// example:
	//
	// cn-hangzhou-*
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// example:
	//
	// vsw-bp1k4ec6s7sjdbudw****
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s DescribeLogstashResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponseBodyResultNetworkConfig) SetType(v string) *DescribeLogstashResponseBodyResultNetworkConfig {
	s.Type = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultNetworkConfig) SetVpcId(v string) *DescribeLogstashResponseBodyResultNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultNetworkConfig) SetVsArea(v string) *DescribeLogstashResponseBodyResultNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultNetworkConfig) SetVswitchId(v string) *DescribeLogstashResponseBodyResultNetworkConfig {
	s.VswitchId = &v
	return s
}

type DescribeLogstashResponseBodyResultNodeSpec struct {
	// Whether to use disk encryption:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The disk type of the node.
	//
	// example:
	//
	// true
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// The network configurations.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The disk size of the node.
	//
	// example:
	//
	// elasticsearch.sn1ne.large
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s DescribeLogstashResponseBodyResultNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponseBodyResultNodeSpec) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponseBodyResultNodeSpec) SetDisk(v int32) *DescribeLogstashResponseBodyResultNodeSpec {
	s.Disk = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultNodeSpec) SetDiskEncryption(v bool) *DescribeLogstashResponseBodyResultNodeSpec {
	s.DiskEncryption = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultNodeSpec) SetDiskType(v string) *DescribeLogstashResponseBodyResultNodeSpec {
	s.DiskType = &v
	return s
}

func (s *DescribeLogstashResponseBodyResultNodeSpec) SetSpec(v string) *DescribeLogstashResponseBodyResultNodeSpec {
	s.Spec = &v
	return s
}

type DescribeLogstashResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeLogstashResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeLogstashResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogstashResponse) GoString() string {
	return s.String()
}

func (s *DescribeLogstashResponse) SetHeaders(v map[string]*string) *DescribeLogstashResponse {
	s.Headers = v
	return s
}

func (s *DescribeLogstashResponse) SetStatusCode(v int32) *DescribeLogstashResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLogstashResponse) SetBody(v *DescribeLogstashResponseBody) *DescribeLogstashResponse {
	s.Body = v
	return s
}

type DescribePipelineResponseBody struct {
	// The time when the pipeline was updated.
	//
	// example:
	//
	// 829F38F6-E2D6-4109-90A6-888160BD1***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The type of the queue. Valid values:
	//
	// 	- MEMORY: a traditional memory-based queue.
	//
	// 	- PERSISTED: disk-based ACKed queue (persistent queue).
	Result *DescribePipelineResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribePipelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePipelineResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePipelineResponseBody) SetRequestId(v string) *DescribePipelineResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePipelineResponseBody) SetResult(v *DescribePipelineResponseBodyResult) *DescribePipelineResponseBody {
	s.Result = v
	return s
}

type DescribePipelineResponseBodyResult struct {
	// The time when the pipeline was created.
	//
	// example:
	//
	// 50
	BatchDelay *int32 `json:"batchDelay,omitempty" xml:"batchDelay,omitempty"`
	// example:
	//
	// 125
	BatchSize *int32 `json:"batchSize,omitempty" xml:"batchSize,omitempty"`
	// The description of the pipeline.
	//
	// example:
	//
	// input {  }  filter {  }  output {  }
	Config *string `json:"config,omitempty" xml:"config,omitempty"`
	// The state of the MPS queue. Valid values:
	//
	// 	- NOT_DEPLOYED: The node is not deployed.
	//
	// 	- RUNNING
	//
	// 	- DELETED: Deleted. The console does not display this status.
	//
	// example:
	//
	// this is a test
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtCreatedTime *string `json:"gmtCreatedTime,omitempty" xml:"gmtCreatedTime,omitempty"`
	// The total capacity of the queue in bytes. Unit: MB.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtUpdateTime *string `json:"gmtUpdateTime,omitempty" xml:"gmtUpdateTime,omitempty"`
	// Number of queue checkpoint writes.
	//
	// example:
	//
	// pipeline_test
	PipelineId *string `json:"pipelineId,omitempty" xml:"pipelineId,omitempty"`
	// example:
	//
	// RUNNING
	PipelineStatus *string `json:"pipelineStatus,omitempty" xml:"pipelineStatus,omitempty"`
	// Pipeline batch delay. Unit: milliseconds.
	//
	// example:
	//
	// 1024
	QueueCheckPointWrites *int32 `json:"queueCheckPointWrites,omitempty" xml:"queueCheckPointWrites,omitempty"`
	// The number of pipeline workers.
	//
	// example:
	//
	// 1024
	QueueMaxBytes *int32 `json:"queueMaxBytes,omitempty" xml:"queueMaxBytes,omitempty"`
	// The specific configuration of the pipeline.
	//
	// example:
	//
	// MEMORY
	QueueType *string `json:"queueType,omitempty" xml:"queueType,omitempty"`
	// The size of the pipeline batch.
	//
	// example:
	//
	// 2
	Workers *int32 `json:"workers,omitempty" xml:"workers,omitempty"`
}

func (s DescribePipelineResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribePipelineResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribePipelineResponseBodyResult) SetBatchDelay(v int32) *DescribePipelineResponseBodyResult {
	s.BatchDelay = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetBatchSize(v int32) *DescribePipelineResponseBodyResult {
	s.BatchSize = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetConfig(v string) *DescribePipelineResponseBodyResult {
	s.Config = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetDescription(v string) *DescribePipelineResponseBodyResult {
	s.Description = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetGmtCreatedTime(v string) *DescribePipelineResponseBodyResult {
	s.GmtCreatedTime = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetGmtUpdateTime(v string) *DescribePipelineResponseBodyResult {
	s.GmtUpdateTime = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetPipelineId(v string) *DescribePipelineResponseBodyResult {
	s.PipelineId = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetPipelineStatus(v string) *DescribePipelineResponseBodyResult {
	s.PipelineStatus = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetQueueCheckPointWrites(v int32) *DescribePipelineResponseBodyResult {
	s.QueueCheckPointWrites = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetQueueMaxBytes(v int32) *DescribePipelineResponseBodyResult {
	s.QueueMaxBytes = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetQueueType(v string) *DescribePipelineResponseBodyResult {
	s.QueueType = &v
	return s
}

func (s *DescribePipelineResponseBodyResult) SetWorkers(v int32) *DescribePipelineResponseBodyResult {
	s.Workers = &v
	return s
}

type DescribePipelineResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePipelineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePipelineResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePipelineResponse) GoString() string {
	return s.String()
}

func (s *DescribePipelineResponse) SetHeaders(v map[string]*string) *DescribePipelineResponse {
	s.Headers = v
	return s
}

func (s *DescribePipelineResponse) SetStatusCode(v int32) *DescribePipelineResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePipelineResponse) SetBody(v *DescribePipelineResponseBody) *DescribePipelineResponse {
	s.Body = v
	return s
}

type DescribePipelineManagementConfigRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s DescribePipelineManagementConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePipelineManagementConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribePipelineManagementConfigRequest) SetClientToken(v string) *DescribePipelineManagementConfigRequest {
	s.ClientToken = &v
	return s
}

type DescribePipelineManagementConfigResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *DescribePipelineManagementConfigResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribePipelineManagementConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePipelineManagementConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePipelineManagementConfigResponseBody) SetRequestId(v string) *DescribePipelineManagementConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePipelineManagementConfigResponseBody) SetResult(v *DescribePipelineManagementConfigResponseBodyResult) *DescribePipelineManagementConfigResponseBody {
	s.Result = v
	return s
}

type DescribePipelineManagementConfigResponseBodyResult struct {
	// The access addresses of the Elasticsearch cluster. Specify each address in the `http://Endpoint of the Elasticsearch cluster:Port number` format.
	//
	// example:
	//
	// ["http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200"]
	Endpoints *string `json:"endpoints,omitempty" xml:"endpoints,omitempty"`
	// The ID of the Elasticsearch cluster.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****
	EsInstanceId *string   `json:"esInstanceId,omitempty" xml:"esInstanceId,omitempty"`
	PipelineIds  []*string `json:"pipelineIds,omitempty" xml:"pipelineIds,omitempty" type:"Repeated"`
	// The pipeline management method. Valid values: Kibana and MULTIPLE_PIPELINE.
	//
	// example:
	//
	// MULTIPLE_PIPELINE
	PipelineManagementType *string `json:"pipelineManagementType,omitempty" xml:"pipelineManagementType,omitempty"`
	// The username that is used to access the Elasticsearch cluster.
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s DescribePipelineManagementConfigResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribePipelineManagementConfigResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribePipelineManagementConfigResponseBodyResult) SetEndpoints(v string) *DescribePipelineManagementConfigResponseBodyResult {
	s.Endpoints = &v
	return s
}

func (s *DescribePipelineManagementConfigResponseBodyResult) SetEsInstanceId(v string) *DescribePipelineManagementConfigResponseBodyResult {
	s.EsInstanceId = &v
	return s
}

func (s *DescribePipelineManagementConfigResponseBodyResult) SetPipelineIds(v []*string) *DescribePipelineManagementConfigResponseBodyResult {
	s.PipelineIds = v
	return s
}

func (s *DescribePipelineManagementConfigResponseBodyResult) SetPipelineManagementType(v string) *DescribePipelineManagementConfigResponseBodyResult {
	s.PipelineManagementType = &v
	return s
}

func (s *DescribePipelineManagementConfigResponseBodyResult) SetUserName(v string) *DescribePipelineManagementConfigResponseBodyResult {
	s.UserName = &v
	return s
}

type DescribePipelineManagementConfigResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePipelineManagementConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePipelineManagementConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePipelineManagementConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribePipelineManagementConfigResponse) SetHeaders(v map[string]*string) *DescribePipelineManagementConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribePipelineManagementConfigResponse) SetStatusCode(v int32) *DescribePipelineManagementConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePipelineManagementConfigResponse) SetBody(v *DescribePipelineManagementConfigResponseBody) *DescribePipelineManagementConfigResponse {
	s.Body = v
	return s
}

type DescribeRegionsResponseBody struct {
	// The available status of the region.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1ADFG
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The endpoint of the region.
	Result []*DescribeRegionsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRegionsResponseBody) SetResult(v []*DescribeRegionsResponseBodyResult) *DescribeRegionsResponseBody {
	s.Result = v
	return s
}

type DescribeRegionsResponseBodyResult struct {
	// example:
	//
	// https://elasticsearch-cn-hangzhou.console.aliyun.com
	ConsoleEndpoint *string `json:"consoleEndpoint,omitempty" xml:"consoleEndpoint,omitempty"`
	// example:
	//
	// China (Hangzhou)
	LocalName *string `json:"localName,omitempty" xml:"localName,omitempty"`
	// example:
	//
	// elasticsearch.cn-hangzhou.aliyuncs.com
	RegionEndpoint *string `json:"regionEndpoint,omitempty" xml:"regionEndpoint,omitempty"`
	// The name of the region.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"regionId,omitempty" xml:"regionId,omitempty"`
	// The endpoint of the region that is exposed in the console.
	//
	// example:
	//
	// available
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s DescribeRegionsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyResult) SetConsoleEndpoint(v string) *DescribeRegionsResponseBodyResult {
	s.ConsoleEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyResult) SetLocalName(v string) *DescribeRegionsResponseBodyResult {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyResult) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyResult {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyResult) SetRegionId(v string) *DescribeRegionsResponseBodyResult {
	s.RegionId = &v
	return s
}

func (s *DescribeRegionsResponseBodyResult) SetStatus(v string) *DescribeRegionsResponseBodyResult {
	s.Status = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DescribeSnapshotSettingResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result *DescribeSnapshotSettingResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeSnapshotSettingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnapshotSettingResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotSettingResponseBody) SetRequestId(v string) *DescribeSnapshotSettingResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSnapshotSettingResponseBody) SetResult(v *DescribeSnapshotSettingResponseBodyResult) *DescribeSnapshotSettingResponseBody {
	s.Result = v
	return s
}

type DescribeSnapshotSettingResponseBodyResult struct {
	// Whether to enable automatic backup.
	//
	// example:
	//
	// true
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// Automatic backup time configuration, using Quartz Cron expression.
	//
	// example:
	//
	// 0 0 01 ? 	- 	- *
	QuartzRegex *string `json:"QuartzRegex,omitempty" xml:"QuartzRegex,omitempty"`
}

func (s DescribeSnapshotSettingResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnapshotSettingResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotSettingResponseBodyResult) SetEnable(v bool) *DescribeSnapshotSettingResponseBodyResult {
	s.Enable = &v
	return s
}

func (s *DescribeSnapshotSettingResponseBodyResult) SetQuartzRegex(v string) *DescribeSnapshotSettingResponseBodyResult {
	s.QuartzRegex = &v
	return s
}

type DescribeSnapshotSettingResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSnapshotSettingResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSnapshotSettingResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnapshotSettingResponse) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotSettingResponse) SetHeaders(v map[string]*string) *DescribeSnapshotSettingResponse {
	s.Headers = v
	return s
}

func (s *DescribeSnapshotSettingResponse) SetStatusCode(v int32) *DescribeSnapshotSettingResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSnapshotSettingResponse) SetBody(v *DescribeSnapshotSettingResponseBody) *DescribeSnapshotSettingResponse {
	s.Body = v
	return s
}

type DescribeTemplatesResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*DescribeTemplatesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s DescribeTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTemplatesResponseBody) SetRequestId(v string) *DescribeTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTemplatesResponseBody) SetResult(v []*DescribeTemplatesResponseBodyResult) *DescribeTemplatesResponseBody {
	s.Result = v
	return s
}

type DescribeTemplatesResponseBodyResult struct {
	// example:
	//
	// {\\n\\t\\"persistent\\":{\\n\\t\\t\\"search\\":{\\n\\t\\t\\t\\"max_buckets\\":\\"10000\\"\\n\\t\\t}\\n\\t}\\n}
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// example:
	//
	// dynamicSettings
	TemplateName *string `json:"templateName,omitempty" xml:"templateName,omitempty"`
}

func (s DescribeTemplatesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeTemplatesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeTemplatesResponseBodyResult) SetContent(v string) *DescribeTemplatesResponseBodyResult {
	s.Content = &v
	return s
}

func (s *DescribeTemplatesResponseBodyResult) SetTemplateName(v string) *DescribeTemplatesResponseBodyResult {
	s.TemplateName = &v
	return s
}

type DescribeTemplatesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTemplatesResponse) GoString() string {
	return s.String()
}

func (s *DescribeTemplatesResponse) SetHeaders(v map[string]*string) *DescribeTemplatesResponse {
	s.Headers = v
	return s
}

func (s *DescribeTemplatesResponse) SetStatusCode(v int32) *DescribeTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTemplatesResponse) SetBody(v *DescribeTemplatesResponseBody) *DescribeTemplatesResponse {
	s.Body = v
	return s
}

type DescribeXpackMonitorConfigResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *DescribeXpackMonitorConfigResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DescribeXpackMonitorConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeXpackMonitorConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeXpackMonitorConfigResponseBody) SetRequestId(v string) *DescribeXpackMonitorConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeXpackMonitorConfigResponseBody) SetResult(v *DescribeXpackMonitorConfigResponseBodyResult) *DescribeXpackMonitorConfigResponseBody {
	s.Result = v
	return s
}

type DescribeXpackMonitorConfigResponseBodyResult struct {
	// Indicates whether the X-Pack Monitoring feature is enabled. Valid values:
	//
	// 	- true: enabled
	//
	// 	- false: disabled
	//
	// example:
	//
	// true
	Enable    *bool     `json:"enable,omitempty" xml:"enable,omitempty"`
	Endpoints []*string `json:"endpoints,omitempty" xml:"endpoints,omitempty" type:"Repeated"`
	// The ID of the associated Elasticsearch cluster.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****
	EsInstanceId *string   `json:"esInstanceId,omitempty" xml:"esInstanceId,omitempty"`
	PipelineIds  []*string `json:"pipelineIds,omitempty" xml:"pipelineIds,omitempty" type:"Repeated"`
	// The username that is used to access the associated Elasticsearch cluster.
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s DescribeXpackMonitorConfigResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeXpackMonitorConfigResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeXpackMonitorConfigResponseBodyResult) SetEnable(v bool) *DescribeXpackMonitorConfigResponseBodyResult {
	s.Enable = &v
	return s
}

func (s *DescribeXpackMonitorConfigResponseBodyResult) SetEndpoints(v []*string) *DescribeXpackMonitorConfigResponseBodyResult {
	s.Endpoints = v
	return s
}

func (s *DescribeXpackMonitorConfigResponseBodyResult) SetEsInstanceId(v string) *DescribeXpackMonitorConfigResponseBodyResult {
	s.EsInstanceId = &v
	return s
}

func (s *DescribeXpackMonitorConfigResponseBodyResult) SetPipelineIds(v []*string) *DescribeXpackMonitorConfigResponseBodyResult {
	s.PipelineIds = v
	return s
}

func (s *DescribeXpackMonitorConfigResponseBodyResult) SetUserName(v string) *DescribeXpackMonitorConfigResponseBodyResult {
	s.UserName = &v
	return s
}

type DescribeXpackMonitorConfigResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeXpackMonitorConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeXpackMonitorConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeXpackMonitorConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeXpackMonitorConfigResponse) SetHeaders(v map[string]*string) *DescribeXpackMonitorConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeXpackMonitorConfigResponse) SetStatusCode(v int32) *DescribeXpackMonitorConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeXpackMonitorConfigResponse) SetBody(v *DescribeXpackMonitorConfigResponseBody) *DescribeXpackMonitorConfigResponse {
	s.Body = v
	return s
}

type DiagnoseInstanceRequest struct {
	// The timestamp when the diagnostic report was generated.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken   *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DiagnoseItems []*string `json:"diagnoseItems,omitempty" xml:"diagnoseItems,omitempty" type:"Repeated"`
	Indices       []*string `json:"indices,omitempty" xml:"indices,omitempty" type:"Repeated"`
	// example:
	//
	// ALL
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The returned data.
	//
	// example:
	//
	// en
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s DiagnoseInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DiagnoseInstanceRequest) GoString() string {
	return s.String()
}

func (s *DiagnoseInstanceRequest) SetClientToken(v string) *DiagnoseInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *DiagnoseInstanceRequest) SetDiagnoseItems(v []*string) *DiagnoseInstanceRequest {
	s.DiagnoseItems = v
	return s
}

func (s *DiagnoseInstanceRequest) SetIndices(v []*string) *DiagnoseInstanceRequest {
	s.Indices = v
	return s
}

func (s *DiagnoseInstanceRequest) SetType(v string) *DiagnoseInstanceRequest {
	s.Type = &v
	return s
}

func (s *DiagnoseInstanceRequest) SetLang(v string) *DiagnoseInstanceRequest {
	s.Lang = &v
	return s
}

type DiagnoseInstanceResponseBody struct {
	// The ID of the report.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.
	Result *DiagnoseInstanceResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s DiagnoseInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DiagnoseInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DiagnoseInstanceResponseBody) SetRequestId(v string) *DiagnoseInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DiagnoseInstanceResponseBody) SetResult(v *DiagnoseInstanceResponseBodyResult) *DiagnoseInstanceResponseBody {
	s.Result = v
	return s
}

type DiagnoseInstanceResponseBodyResult struct {
	// The ID of the diagnostic instance.
	//
	// example:
	//
	// 1535745731000
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// es-cn-n6w1o1x0w001c****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// trigger__2020-08-17T17:09:02
	ReportId *string `json:"reportId,omitempty" xml:"reportId,omitempty"`
	// example:
	//
	// RUNNING
	State *string `json:"state,omitempty" xml:"state,omitempty"`
}

func (s DiagnoseInstanceResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DiagnoseInstanceResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DiagnoseInstanceResponseBodyResult) SetCreateTime(v int64) *DiagnoseInstanceResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *DiagnoseInstanceResponseBodyResult) SetInstanceId(v string) *DiagnoseInstanceResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *DiagnoseInstanceResponseBodyResult) SetReportId(v string) *DiagnoseInstanceResponseBodyResult {
	s.ReportId = &v
	return s
}

func (s *DiagnoseInstanceResponseBodyResult) SetState(v string) *DiagnoseInstanceResponseBodyResult {
	s.State = &v
	return s
}

type DiagnoseInstanceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DiagnoseInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DiagnoseInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DiagnoseInstanceResponse) GoString() string {
	return s.String()
}

func (s *DiagnoseInstanceResponse) SetHeaders(v map[string]*string) *DiagnoseInstanceResponse {
	s.Headers = v
	return s
}

func (s *DiagnoseInstanceResponse) SetStatusCode(v int32) *DiagnoseInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DiagnoseInstanceResponse) SetBody(v *DiagnoseInstanceResponseBody) *DiagnoseInstanceResponse {
	s.Body = v
	return s
}

type DisableKibanaPvlNetworkResponseBody struct {
	// request id
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1DERFG
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DisableKibanaPvlNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableKibanaPvlNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *DisableKibanaPvlNetworkResponseBody) SetRequestId(v string) *DisableKibanaPvlNetworkResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableKibanaPvlNetworkResponseBody) SetResult(v bool) *DisableKibanaPvlNetworkResponseBody {
	s.Result = &v
	return s
}

type DisableKibanaPvlNetworkResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableKibanaPvlNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableKibanaPvlNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableKibanaPvlNetworkResponse) GoString() string {
	return s.String()
}

func (s *DisableKibanaPvlNetworkResponse) SetHeaders(v map[string]*string) *DisableKibanaPvlNetworkResponse {
	s.Headers = v
	return s
}

func (s *DisableKibanaPvlNetworkResponse) SetStatusCode(v int32) *DisableKibanaPvlNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableKibanaPvlNetworkResponse) SetBody(v *DisableKibanaPvlNetworkResponseBody) *DisableKibanaPvlNetworkResponse {
	s.Body = v
	return s
}

type EnableKibanaPvlNetworkRequest struct {
	// This parameter is required.
	//
	// example:
	//
	// es-cn-27a3mul6l000xxx-kibana-endpoint
	EndpointName *string `json:"endpointName,omitempty" xml:"endpointName,omitempty"`
	// This parameter is required.
	SecurityGroups []*string `json:"securityGroups,omitempty" xml:"securityGroups,omitempty" type:"Repeated"`
	// This parameter is required.
	VSwitchIdsZone []*EnableKibanaPvlNetworkRequestVSwitchIdsZone `json:"vSwitchIdsZone,omitempty" xml:"vSwitchIdsZone,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// vpc-xxx
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s EnableKibanaPvlNetworkRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableKibanaPvlNetworkRequest) GoString() string {
	return s.String()
}

func (s *EnableKibanaPvlNetworkRequest) SetEndpointName(v string) *EnableKibanaPvlNetworkRequest {
	s.EndpointName = &v
	return s
}

func (s *EnableKibanaPvlNetworkRequest) SetSecurityGroups(v []*string) *EnableKibanaPvlNetworkRequest {
	s.SecurityGroups = v
	return s
}

func (s *EnableKibanaPvlNetworkRequest) SetVSwitchIdsZone(v []*EnableKibanaPvlNetworkRequestVSwitchIdsZone) *EnableKibanaPvlNetworkRequest {
	s.VSwitchIdsZone = v
	return s
}

func (s *EnableKibanaPvlNetworkRequest) SetVpcId(v string) *EnableKibanaPvlNetworkRequest {
	s.VpcId = &v
	return s
}

type EnableKibanaPvlNetworkRequestVSwitchIdsZone struct {
	// This parameter is required.
	//
	// example:
	//
	// vsw-xxxx
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou-h
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s EnableKibanaPvlNetworkRequestVSwitchIdsZone) String() string {
	return tea.Prettify(s)
}

func (s EnableKibanaPvlNetworkRequestVSwitchIdsZone) GoString() string {
	return s.String()
}

func (s *EnableKibanaPvlNetworkRequestVSwitchIdsZone) SetVswitchId(v string) *EnableKibanaPvlNetworkRequestVSwitchIdsZone {
	s.VswitchId = &v
	return s
}

func (s *EnableKibanaPvlNetworkRequestVSwitchIdsZone) SetZoneId(v string) *EnableKibanaPvlNetworkRequestVSwitchIdsZone {
	s.ZoneId = &v
	return s
}

type EnableKibanaPvlNetworkResponseBody struct {
	// example:
	//
	// 0DC92CFE-62AF-51AF-9D5B-F1078D7C451E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s EnableKibanaPvlNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableKibanaPvlNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *EnableKibanaPvlNetworkResponseBody) SetRequestId(v string) *EnableKibanaPvlNetworkResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableKibanaPvlNetworkResponseBody) SetResult(v bool) *EnableKibanaPvlNetworkResponseBody {
	s.Result = &v
	return s
}

type EnableKibanaPvlNetworkResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableKibanaPvlNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableKibanaPvlNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableKibanaPvlNetworkResponse) GoString() string {
	return s.String()
}

func (s *EnableKibanaPvlNetworkResponse) SetHeaders(v map[string]*string) *EnableKibanaPvlNetworkResponse {
	s.Headers = v
	return s
}

func (s *EnableKibanaPvlNetworkResponse) SetStatusCode(v int32) *EnableKibanaPvlNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableKibanaPvlNetworkResponse) SetBody(v *EnableKibanaPvlNetworkResponseBody) *EnableKibanaPvlNetworkResponse {
	s.Body = v
	return s
}

type EstimatedLogstashRestartTimeRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// Specifies whether to forcibly restart the cluster. Default value: false.
	//
	// example:
	//
	// false
	Force *bool `json:"force,omitempty" xml:"force,omitempty"`
}

func (s EstimatedLogstashRestartTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s EstimatedLogstashRestartTimeRequest) GoString() string {
	return s.String()
}

func (s *EstimatedLogstashRestartTimeRequest) SetBody(v string) *EstimatedLogstashRestartTimeRequest {
	s.Body = &v
	return s
}

func (s *EstimatedLogstashRestartTimeRequest) SetForce(v bool) *EstimatedLogstashRestartTimeRequest {
	s.Force = &v
	return s
}

type EstimatedLogstashRestartTimeResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *EstimatedLogstashRestartTimeResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s EstimatedLogstashRestartTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EstimatedLogstashRestartTimeResponseBody) GoString() string {
	return s.String()
}

func (s *EstimatedLogstashRestartTimeResponseBody) SetRequestId(v string) *EstimatedLogstashRestartTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *EstimatedLogstashRestartTimeResponseBody) SetResult(v *EstimatedLogstashRestartTimeResponseBodyResult) *EstimatedLogstashRestartTimeResponseBody {
	s.Result = v
	return s
}

type EstimatedLogstashRestartTimeResponseBodyResult struct {
	// The unit.
	//
	// example:
	//
	// second
	Unit *string `json:"unit,omitempty" xml:"unit,omitempty"`
	// The estimated restart time.
	//
	// example:
	//
	// 600
	Value *int64 `json:"value,omitempty" xml:"value,omitempty"`
}

func (s EstimatedLogstashRestartTimeResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s EstimatedLogstashRestartTimeResponseBodyResult) GoString() string {
	return s.String()
}

func (s *EstimatedLogstashRestartTimeResponseBodyResult) SetUnit(v string) *EstimatedLogstashRestartTimeResponseBodyResult {
	s.Unit = &v
	return s
}

func (s *EstimatedLogstashRestartTimeResponseBodyResult) SetValue(v int64) *EstimatedLogstashRestartTimeResponseBodyResult {
	s.Value = &v
	return s
}

type EstimatedLogstashRestartTimeResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EstimatedLogstashRestartTimeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EstimatedLogstashRestartTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s EstimatedLogstashRestartTimeResponse) GoString() string {
	return s.String()
}

func (s *EstimatedLogstashRestartTimeResponse) SetHeaders(v map[string]*string) *EstimatedLogstashRestartTimeResponse {
	s.Headers = v
	return s
}

func (s *EstimatedLogstashRestartTimeResponse) SetStatusCode(v int32) *EstimatedLogstashRestartTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *EstimatedLogstashRestartTimeResponse) SetBody(v *EstimatedLogstashRestartTimeResponseBody) *EstimatedLogstashRestartTimeResponse {
	s.Body = v
	return s
}

type EstimatedRestartTimeRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// Specifies whether to forcibly restart the cluster. Default value: false.
	//
	// example:
	//
	// false
	Force *bool `json:"force,omitempty" xml:"force,omitempty"`
}

func (s EstimatedRestartTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s EstimatedRestartTimeRequest) GoString() string {
	return s.String()
}

func (s *EstimatedRestartTimeRequest) SetBody(v string) *EstimatedRestartTimeRequest {
	s.Body = &v
	return s
}

func (s *EstimatedRestartTimeRequest) SetForce(v bool) *EstimatedRestartTimeRequest {
	s.Force = &v
	return s
}

type EstimatedRestartTimeResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *EstimatedRestartTimeResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s EstimatedRestartTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EstimatedRestartTimeResponseBody) GoString() string {
	return s.String()
}

func (s *EstimatedRestartTimeResponseBody) SetRequestId(v string) *EstimatedRestartTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *EstimatedRestartTimeResponseBody) SetResult(v *EstimatedRestartTimeResponseBodyResult) *EstimatedRestartTimeResponseBody {
	s.Result = v
	return s
}

type EstimatedRestartTimeResponseBodyResult struct {
	// The unit.
	//
	// example:
	//
	// second
	Unit *string `json:"unit,omitempty" xml:"unit,omitempty"`
	// The estimated restart time.
	//
	// example:
	//
	// 50
	Value *int64 `json:"value,omitempty" xml:"value,omitempty"`
}

func (s EstimatedRestartTimeResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s EstimatedRestartTimeResponseBodyResult) GoString() string {
	return s.String()
}

func (s *EstimatedRestartTimeResponseBodyResult) SetUnit(v string) *EstimatedRestartTimeResponseBodyResult {
	s.Unit = &v
	return s
}

func (s *EstimatedRestartTimeResponseBodyResult) SetValue(v int64) *EstimatedRestartTimeResponseBodyResult {
	s.Value = &v
	return s
}

type EstimatedRestartTimeResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EstimatedRestartTimeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EstimatedRestartTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s EstimatedRestartTimeResponse) GoString() string {
	return s.String()
}

func (s *EstimatedRestartTimeResponse) SetHeaders(v map[string]*string) *EstimatedRestartTimeResponse {
	s.Headers = v
	return s
}

func (s *EstimatedRestartTimeResponse) SetStatusCode(v int32) *EstimatedRestartTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *EstimatedRestartTimeResponse) SetBody(v *EstimatedRestartTimeResponseBody) *EstimatedRestartTimeResponse {
	s.Body = v
	return s
}

type GetClusterDataInformationRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetClusterDataInformationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetClusterDataInformationRequest) GoString() string {
	return s.String()
}

func (s *GetClusterDataInformationRequest) SetBody(v string) *GetClusterDataInformationRequest {
	s.Body = &v
	return s
}

type GetClusterDataInformationResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result *GetClusterDataInformationResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s GetClusterDataInformationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetClusterDataInformationResponseBody) GoString() string {
	return s.String()
}

func (s *GetClusterDataInformationResponseBody) SetRequestId(v string) *GetClusterDataInformationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetClusterDataInformationResponseBody) SetResult(v *GetClusterDataInformationResponseBodyResult) *GetClusterDataInformationResponseBody {
	s.Result = v
	return s
}

type GetClusterDataInformationResponseBodyResult struct {
	// Whether it is connectable.
	//
	// example:
	//
	// true
	Connectable *bool `json:"connectable,omitempty" xml:"connectable,omitempty"`
	// The metadata of the cluster.
	MetaInfo *GetClusterDataInformationResponseBodyResultMetaInfo `json:"metaInfo,omitempty" xml:"metaInfo,omitempty" type:"Struct"`
}

func (s GetClusterDataInformationResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetClusterDataInformationResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetClusterDataInformationResponseBodyResult) SetConnectable(v bool) *GetClusterDataInformationResponseBodyResult {
	s.Connectable = &v
	return s
}

func (s *GetClusterDataInformationResponseBodyResult) SetMetaInfo(v *GetClusterDataInformationResponseBodyResultMetaInfo) *GetClusterDataInformationResponseBodyResult {
	s.MetaInfo = v
	return s
}

type GetClusterDataInformationResponseBodyResultMetaInfo struct {
	// The fields in the Mapping for the index.
	Fields []*string `json:"fields,omitempty" xml:"fields,omitempty" type:"Repeated"`
	// The index list of the cluster.
	Indices []*string `json:"indices,omitempty" xml:"indices,omitempty" type:"Repeated"`
	// The Mapping configuration of the cluster.
	//
	// example:
	//
	// {\\"_doc\\":{\\"properties\\":{\\"user\\":{\\"properties\\":{\\"last\\":{\\"type\\":\\"text\\",...}}}}}}
	Mapping *string `json:"mapping,omitempty" xml:"mapping,omitempty"`
	// The Settings of the cluster.
	//
	// example:
	//
	// {\\n  \\"index\\": {\\n    \\"replication\\": {\\n}.....}}
	Settings *string `json:"settings,omitempty" xml:"settings,omitempty"`
	// Specifies the type of the index.
	TypeName []*string `json:"typeName,omitempty" xml:"typeName,omitempty" type:"Repeated"`
}

func (s GetClusterDataInformationResponseBodyResultMetaInfo) String() string {
	return tea.Prettify(s)
}

func (s GetClusterDataInformationResponseBodyResultMetaInfo) GoString() string {
	return s.String()
}

func (s *GetClusterDataInformationResponseBodyResultMetaInfo) SetFields(v []*string) *GetClusterDataInformationResponseBodyResultMetaInfo {
	s.Fields = v
	return s
}

func (s *GetClusterDataInformationResponseBodyResultMetaInfo) SetIndices(v []*string) *GetClusterDataInformationResponseBodyResultMetaInfo {
	s.Indices = v
	return s
}

func (s *GetClusterDataInformationResponseBodyResultMetaInfo) SetMapping(v string) *GetClusterDataInformationResponseBodyResultMetaInfo {
	s.Mapping = &v
	return s
}

func (s *GetClusterDataInformationResponseBodyResultMetaInfo) SetSettings(v string) *GetClusterDataInformationResponseBodyResultMetaInfo {
	s.Settings = &v
	return s
}

func (s *GetClusterDataInformationResponseBodyResultMetaInfo) SetTypeName(v []*string) *GetClusterDataInformationResponseBodyResultMetaInfo {
	s.TypeName = v
	return s
}

type GetClusterDataInformationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetClusterDataInformationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetClusterDataInformationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetClusterDataInformationResponse) GoString() string {
	return s.String()
}

func (s *GetClusterDataInformationResponse) SetHeaders(v map[string]*string) *GetClusterDataInformationResponse {
	s.Headers = v
	return s
}

func (s *GetClusterDataInformationResponse) SetStatusCode(v int32) *GetClusterDataInformationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetClusterDataInformationResponse) SetBody(v *GetClusterDataInformationResponseBody) *GetClusterDataInformationResponse {
	s.Body = v
	return s
}

type GetElastictaskResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *GetElastictaskResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s GetElastictaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetElastictaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetElastictaskResponseBody) SetRequestId(v string) *GetElastictaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetElastictaskResponseBody) SetResult(v *GetElastictaskResponseBodyResult) *GetElastictaskResponseBody {
	s.Result = v
	return s
}

type GetElastictaskResponseBodyResult struct {
	ElasticExpansionTask *GetElastictaskResponseBodyResultElasticExpansionTask `json:"elasticExpansionTask,omitempty" xml:"elasticExpansionTask,omitempty" type:"Struct"`
	ElasticShrinkTask    *GetElastictaskResponseBodyResultElasticShrinkTask    `json:"elasticShrinkTask,omitempty" xml:"elasticShrinkTask,omitempty" type:"Struct"`
}

func (s GetElastictaskResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetElastictaskResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetElastictaskResponseBodyResult) SetElasticExpansionTask(v *GetElastictaskResponseBodyResultElasticExpansionTask) *GetElastictaskResponseBodyResult {
	s.ElasticExpansionTask = v
	return s
}

func (s *GetElastictaskResponseBodyResult) SetElasticShrinkTask(v *GetElastictaskResponseBodyResultElasticShrinkTask) *GetElastictaskResponseBodyResult {
	s.ElasticShrinkTask = v
	return s
}

type GetElastictaskResponseBodyResultElasticExpansionTask struct {
	// example:
	//
	// 0 0 0 ? 	- MON
	CronExpression *string `json:"cronExpression,omitempty" xml:"cronExpression,omitempty"`
	// example:
	//
	// 2
	ElasticNodeCount *int32 `json:"elasticNodeCount,omitempty" xml:"elasticNodeCount,omitempty"`
	// example:
	//
	// 2
	ReplicaCount  *int32    `json:"replicaCount,omitempty" xml:"replicaCount,omitempty"`
	TargetIndices []*string `json:"targetIndices,omitempty" xml:"targetIndices,omitempty" type:"Repeated"`
	// example:
	//
	// crontab
	TriggerType *string `json:"triggerType,omitempty" xml:"triggerType,omitempty"`
}

func (s GetElastictaskResponseBodyResultElasticExpansionTask) String() string {
	return tea.Prettify(s)
}

func (s GetElastictaskResponseBodyResultElasticExpansionTask) GoString() string {
	return s.String()
}

func (s *GetElastictaskResponseBodyResultElasticExpansionTask) SetCronExpression(v string) *GetElastictaskResponseBodyResultElasticExpansionTask {
	s.CronExpression = &v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticExpansionTask) SetElasticNodeCount(v int32) *GetElastictaskResponseBodyResultElasticExpansionTask {
	s.ElasticNodeCount = &v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticExpansionTask) SetReplicaCount(v int32) *GetElastictaskResponseBodyResultElasticExpansionTask {
	s.ReplicaCount = &v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticExpansionTask) SetTargetIndices(v []*string) *GetElastictaskResponseBodyResultElasticExpansionTask {
	s.TargetIndices = v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticExpansionTask) SetTriggerType(v string) *GetElastictaskResponseBodyResultElasticExpansionTask {
	s.TriggerType = &v
	return s
}

type GetElastictaskResponseBodyResultElasticShrinkTask struct {
	// example:
	//
	// 4 4 4 ? 	- WED
	CronExpression *string `json:"cronExpression,omitempty" xml:"cronExpression,omitempty"`
	// example:
	//
	// 2
	ElasticNodeCount *int32 `json:"elasticNodeCount,omitempty" xml:"elasticNodeCount,omitempty"`
	// example:
	//
	// 2
	ReplicaCount  *int32    `json:"replicaCount,omitempty" xml:"replicaCount,omitempty"`
	TargetIndices []*string `json:"targetIndices,omitempty" xml:"targetIndices,omitempty" type:"Repeated"`
	// example:
	//
	// crontab
	TriggerType *string `json:"triggerType,omitempty" xml:"triggerType,omitempty"`
}

func (s GetElastictaskResponseBodyResultElasticShrinkTask) String() string {
	return tea.Prettify(s)
}

func (s GetElastictaskResponseBodyResultElasticShrinkTask) GoString() string {
	return s.String()
}

func (s *GetElastictaskResponseBodyResultElasticShrinkTask) SetCronExpression(v string) *GetElastictaskResponseBodyResultElasticShrinkTask {
	s.CronExpression = &v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticShrinkTask) SetElasticNodeCount(v int32) *GetElastictaskResponseBodyResultElasticShrinkTask {
	s.ElasticNodeCount = &v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticShrinkTask) SetReplicaCount(v int32) *GetElastictaskResponseBodyResultElasticShrinkTask {
	s.ReplicaCount = &v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticShrinkTask) SetTargetIndices(v []*string) *GetElastictaskResponseBodyResultElasticShrinkTask {
	s.TargetIndices = v
	return s
}

func (s *GetElastictaskResponseBodyResultElasticShrinkTask) SetTriggerType(v string) *GetElastictaskResponseBodyResultElasticShrinkTask {
	s.TriggerType = &v
	return s
}

type GetElastictaskResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetElastictaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetElastictaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetElastictaskResponse) GoString() string {
	return s.String()
}

func (s *GetElastictaskResponse) SetHeaders(v map[string]*string) *GetElastictaskResponse {
	s.Headers = v
	return s
}

func (s *GetElastictaskResponse) SetStatusCode(v int32) *GetElastictaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetElastictaskResponse) SetBody(v *GetElastictaskResponseBody) *GetElastictaskResponse {
	s.Body = v
	return s
}

type GetEmonGrafanaAlertsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEmonGrafanaAlertsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEmonGrafanaAlertsRequest) GoString() string {
	return s.String()
}

func (s *GetEmonGrafanaAlertsRequest) SetBody(v string) *GetEmonGrafanaAlertsRequest {
	s.Body = &v
	return s
}

type GetEmonGrafanaAlertsResponseBody struct {
	// example:
	//
	// 200
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// example:
	//
	// ""
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// example:
	//
	// 08FA74C7-5654-4309-9729-D555AF587B7F
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetEmonGrafanaAlertsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEmonGrafanaAlertsResponseBody) GoString() string {
	return s.String()
}

func (s *GetEmonGrafanaAlertsResponseBody) SetCode(v string) *GetEmonGrafanaAlertsResponseBody {
	s.Code = &v
	return s
}

func (s *GetEmonGrafanaAlertsResponseBody) SetMessage(v string) *GetEmonGrafanaAlertsResponseBody {
	s.Message = &v
	return s
}

func (s *GetEmonGrafanaAlertsResponseBody) SetRequestId(v string) *GetEmonGrafanaAlertsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEmonGrafanaAlertsResponseBody) SetSuccess(v bool) *GetEmonGrafanaAlertsResponseBody {
	s.Success = &v
	return s
}

type GetEmonGrafanaAlertsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetEmonGrafanaAlertsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEmonGrafanaAlertsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEmonGrafanaAlertsResponse) GoString() string {
	return s.String()
}

func (s *GetEmonGrafanaAlertsResponse) SetHeaders(v map[string]*string) *GetEmonGrafanaAlertsResponse {
	s.Headers = v
	return s
}

func (s *GetEmonGrafanaAlertsResponse) SetStatusCode(v int32) *GetEmonGrafanaAlertsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEmonGrafanaAlertsResponse) SetBody(v *GetEmonGrafanaAlertsResponseBody) *GetEmonGrafanaAlertsResponse {
	s.Body = v
	return s
}

type GetEmonGrafanaDashboardsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEmonGrafanaDashboardsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEmonGrafanaDashboardsRequest) GoString() string {
	return s.String()
}

func (s *GetEmonGrafanaDashboardsRequest) SetBody(v string) *GetEmonGrafanaDashboardsRequest {
	s.Body = &v
	return s
}

type GetEmonGrafanaDashboardsResponseBody struct {
	// example:
	//
	// 200
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// example:
	//
	// ""
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// example:
	//
	// 1E9D9827-2092-4385-9DA1-FC5A8D1DB3F5
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetEmonGrafanaDashboardsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEmonGrafanaDashboardsResponseBody) GoString() string {
	return s.String()
}

func (s *GetEmonGrafanaDashboardsResponseBody) SetCode(v string) *GetEmonGrafanaDashboardsResponseBody {
	s.Code = &v
	return s
}

func (s *GetEmonGrafanaDashboardsResponseBody) SetMessage(v string) *GetEmonGrafanaDashboardsResponseBody {
	s.Message = &v
	return s
}

func (s *GetEmonGrafanaDashboardsResponseBody) SetRequestId(v string) *GetEmonGrafanaDashboardsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEmonGrafanaDashboardsResponseBody) SetSuccess(v bool) *GetEmonGrafanaDashboardsResponseBody {
	s.Success = &v
	return s
}

type GetEmonGrafanaDashboardsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetEmonGrafanaDashboardsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEmonGrafanaDashboardsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEmonGrafanaDashboardsResponse) GoString() string {
	return s.String()
}

func (s *GetEmonGrafanaDashboardsResponse) SetHeaders(v map[string]*string) *GetEmonGrafanaDashboardsResponse {
	s.Headers = v
	return s
}

func (s *GetEmonGrafanaDashboardsResponse) SetStatusCode(v int32) *GetEmonGrafanaDashboardsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEmonGrafanaDashboardsResponse) SetBody(v *GetEmonGrafanaDashboardsResponseBody) *GetEmonGrafanaDashboardsResponse {
	s.Body = v
	return s
}

type GetEmonMonitorDataRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEmonMonitorDataRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEmonMonitorDataRequest) GoString() string {
	return s.String()
}

func (s *GetEmonMonitorDataRequest) SetBody(v string) *GetEmonMonitorDataRequest {
	s.Body = &v
	return s
}

type GetEmonMonitorDataResponseBody struct {
	// example:
	//
	// 200
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// example:
	//
	// ""
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// example:
	//
	// 2D184B55-FA51-43F7-A1EF-E68A0545****
	RequestId *string                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*GetEmonMonitorDataResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetEmonMonitorDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEmonMonitorDataResponseBody) GoString() string {
	return s.String()
}

func (s *GetEmonMonitorDataResponseBody) SetCode(v string) *GetEmonMonitorDataResponseBody {
	s.Code = &v
	return s
}

func (s *GetEmonMonitorDataResponseBody) SetMessage(v string) *GetEmonMonitorDataResponseBody {
	s.Message = &v
	return s
}

func (s *GetEmonMonitorDataResponseBody) SetRequestId(v string) *GetEmonMonitorDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEmonMonitorDataResponseBody) SetResult(v []*GetEmonMonitorDataResponseBodyResult) *GetEmonMonitorDataResponseBody {
	s.Result = v
	return s
}

func (s *GetEmonMonitorDataResponseBody) SetSuccess(v bool) *GetEmonMonitorDataResponseBody {
	s.Success = &v
	return s
}

type GetEmonMonitorDataResponseBodyResult struct {
	// example:
	//
	// { "1586249280": 465.1980465119913, "1586249300": 213.45243650423305 }
	Dps map[string]interface{} `json:"dps,omitempty" xml:"dps,omitempty"`
	// example:
	//
	// 1.0
	Integrity *float32 `json:"integrity,omitempty" xml:"integrity,omitempty"`
	// example:
	//
	// 1522127381471
	MessageWatermark *int64 `json:"messageWatermark,omitempty" xml:"messageWatermark,omitempty"`
	// example:
	//
	// elasticbuild.elasticsearch.source.total_doc_count
	Metric *string `json:"metric,omitempty" xml:"metric,omitempty"`
	// example:
	//
	// 10
	Summary *float32 `json:"summary,omitempty" xml:"summary,omitempty"`
	// example:
	//
	// {"taskName":"et-xxx","userId":"123456"}
	Tags map[string]interface{} `json:"tags,omitempty" xml:"tags,omitempty"`
}

func (s GetEmonMonitorDataResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetEmonMonitorDataResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetEmonMonitorDataResponseBodyResult) SetDps(v map[string]interface{}) *GetEmonMonitorDataResponseBodyResult {
	s.Dps = v
	return s
}

func (s *GetEmonMonitorDataResponseBodyResult) SetIntegrity(v float32) *GetEmonMonitorDataResponseBodyResult {
	s.Integrity = &v
	return s
}

func (s *GetEmonMonitorDataResponseBodyResult) SetMessageWatermark(v int64) *GetEmonMonitorDataResponseBodyResult {
	s.MessageWatermark = &v
	return s
}

func (s *GetEmonMonitorDataResponseBodyResult) SetMetric(v string) *GetEmonMonitorDataResponseBodyResult {
	s.Metric = &v
	return s
}

func (s *GetEmonMonitorDataResponseBodyResult) SetSummary(v float32) *GetEmonMonitorDataResponseBodyResult {
	s.Summary = &v
	return s
}

func (s *GetEmonMonitorDataResponseBodyResult) SetTags(v map[string]interface{}) *GetEmonMonitorDataResponseBodyResult {
	s.Tags = v
	return s
}

type GetEmonMonitorDataResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetEmonMonitorDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEmonMonitorDataResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEmonMonitorDataResponse) GoString() string {
	return s.String()
}

func (s *GetEmonMonitorDataResponse) SetHeaders(v map[string]*string) *GetEmonMonitorDataResponse {
	s.Headers = v
	return s
}

func (s *GetEmonMonitorDataResponse) SetStatusCode(v int32) *GetEmonMonitorDataResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEmonMonitorDataResponse) SetBody(v *GetEmonMonitorDataResponseBody) *GetEmonMonitorDataResponse {
	s.Body = v
	return s
}

type GetOpenStoreUsageResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// E1DE2491-804F-4C86-BAB4-548DD70B****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The current request result.
	Result *GetOpenStoreUsageResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s GetOpenStoreUsageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOpenStoreUsageResponseBody) GoString() string {
	return s.String()
}

func (s *GetOpenStoreUsageResponseBody) SetRequestId(v string) *GetOpenStoreUsageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOpenStoreUsageResponseBody) SetResult(v *GetOpenStoreUsageResponseBodyResult) *GetOpenStoreUsageResponseBody {
	s.Result = v
	return s
}

type GetOpenStoreUsageResponseBodyResult struct {
	// The current OpenStore storage capacity (estimated value based on actual indexes). Unit: Byte.
	//
	// example:
	//
	// 204800
	CurrentUsage *int64 `json:"currentUsage,omitempty" xml:"currentUsage,omitempty"`
	// The storage capacity of OpenStore yesterday. Unit: bytes.
	//
	// example:
	//
	// 184320
	LastDayUsage *int64 `json:"lastDayUsage,omitempty" xml:"lastDayUsage,omitempty"`
}

func (s GetOpenStoreUsageResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetOpenStoreUsageResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetOpenStoreUsageResponseBodyResult) SetCurrentUsage(v int64) *GetOpenStoreUsageResponseBodyResult {
	s.CurrentUsage = &v
	return s
}

func (s *GetOpenStoreUsageResponseBodyResult) SetLastDayUsage(v int64) *GetOpenStoreUsageResponseBodyResult {
	s.LastDayUsage = &v
	return s
}

type GetOpenStoreUsageResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetOpenStoreUsageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetOpenStoreUsageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOpenStoreUsageResponse) GoString() string {
	return s.String()
}

func (s *GetOpenStoreUsageResponse) SetHeaders(v map[string]*string) *GetOpenStoreUsageResponse {
	s.Headers = v
	return s
}

func (s *GetOpenStoreUsageResponse) SetStatusCode(v int32) *GetOpenStoreUsageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOpenStoreUsageResponse) SetBody(v *GetOpenStoreUsageResponseBody) *GetOpenStoreUsageResponse {
	s.Body = v
	return s
}

type GetRegionConfigurationRequest struct {
	// example:
	//
	// cn-hangzhou-f
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s GetRegionConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationRequest) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationRequest) SetZoneId(v string) *GetRegionConfigurationRequest {
	s.ZoneId = &v
	return s
}

type GetRegionConfigurationResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6F******
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *GetRegionConfigurationResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s GetRegionConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBody) SetRequestId(v string) *GetRegionConfigurationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRegionConfigurationResponseBody) SetResult(v *GetRegionConfigurationResponseBodyResult) *GetRegionConfigurationResponseBody {
	s.Result = v
	return s
}

type GetRegionConfigurationResponseBodyResult struct {
	ClientNodeAmountRange *GetRegionConfigurationResponseBodyResultClientNodeAmountRange `json:"clientNodeAmountRange,omitempty" xml:"clientNodeAmountRange,omitempty" type:"Struct"`
	ClientNodeDiskList    []*GetRegionConfigurationResponseBodyResultClientNodeDiskList  `json:"clientNodeDiskList,omitempty" xml:"clientNodeDiskList,omitempty" type:"Repeated"`
	ClientNodeSpec        []*string                                                      `json:"clientNodeSpec,omitempty" xml:"clientNodeSpec,omitempty" type:"Repeated"`
	// example:
	//
	// https://common-buy.aliyun.com/?commodityCode=elasticsearch&orderType=BUY#/buy
	CreateUrl             *string                                                        `json:"createUrl,omitempty" xml:"createUrl,omitempty"`
	DataDiskList          []*GetRegionConfigurationResponseBodyResultDataDiskList        `json:"dataDiskList,omitempty" xml:"dataDiskList,omitempty" type:"Repeated"`
	ElasticNodeProperties *GetRegionConfigurationResponseBodyResultElasticNodeProperties `json:"elasticNodeProperties,omitempty" xml:"elasticNodeProperties,omitempty" type:"Struct"`
	// example:
	//
	// production
	Env                  *string                                                         `json:"env,omitempty" xml:"env,omitempty"`
	EsVersions           []*string                                                       `json:"esVersions,omitempty" xml:"esVersions,omitempty" type:"Repeated"`
	EsVersionsLatestList []*GetRegionConfigurationResponseBodyResultEsVersionsLatestList `json:"esVersionsLatestList,omitempty" xml:"esVersionsLatestList,omitempty" type:"Repeated"`
	InstanceSupportNodes []*string                                                       `json:"instanceSupportNodes,omitempty" xml:"instanceSupportNodes,omitempty" type:"Repeated"`
	JvmConfine           *GetRegionConfigurationResponseBodyResultJvmConfine             `json:"jvmConfine,omitempty" xml:"jvmConfine,omitempty" type:"Struct"`
	KibanaNodeProperties *GetRegionConfigurationResponseBodyResultKibanaNodeProperties   `json:"kibanaNodeProperties,omitempty" xml:"kibanaNodeProperties,omitempty" type:"Struct"`
	MasterDiskList       []*GetRegionConfigurationResponseBodyResultMasterDiskList       `json:"masterDiskList,omitempty" xml:"masterDiskList,omitempty" type:"Repeated"`
	MasterSpec           []*string                                                       `json:"masterSpec,omitempty" xml:"masterSpec,omitempty" type:"Repeated"`
	Node                 *GetRegionConfigurationResponseBodyResultNode                   `json:"node,omitempty" xml:"node,omitempty" type:"Struct"`
	NodeSpecList         []*GetRegionConfigurationResponseBodyResultNodeSpecList         `json:"nodeSpecList,omitempty" xml:"nodeSpecList,omitempty" type:"Repeated"`
	// example:
	//
	// cn-hangzhou
	RegionId           *string                                                     `json:"regionId,omitempty" xml:"regionId,omitempty"`
	SupportVersions    []*GetRegionConfigurationResponseBodyResultSupportVersions  `json:"supportVersions,omitempty" xml:"supportVersions,omitempty" type:"Repeated"`
	WarmNodeProperties *GetRegionConfigurationResponseBodyResultWarmNodeProperties `json:"warmNodeProperties,omitempty" xml:"warmNodeProperties,omitempty" type:"Struct"`
	Zones              []*string                                                   `json:"zones,omitempty" xml:"zones,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResult) SetClientNodeAmountRange(v *GetRegionConfigurationResponseBodyResultClientNodeAmountRange) *GetRegionConfigurationResponseBodyResult {
	s.ClientNodeAmountRange = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetClientNodeDiskList(v []*GetRegionConfigurationResponseBodyResultClientNodeDiskList) *GetRegionConfigurationResponseBodyResult {
	s.ClientNodeDiskList = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetClientNodeSpec(v []*string) *GetRegionConfigurationResponseBodyResult {
	s.ClientNodeSpec = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetCreateUrl(v string) *GetRegionConfigurationResponseBodyResult {
	s.CreateUrl = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetDataDiskList(v []*GetRegionConfigurationResponseBodyResultDataDiskList) *GetRegionConfigurationResponseBodyResult {
	s.DataDiskList = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetElasticNodeProperties(v *GetRegionConfigurationResponseBodyResultElasticNodeProperties) *GetRegionConfigurationResponseBodyResult {
	s.ElasticNodeProperties = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetEnv(v string) *GetRegionConfigurationResponseBodyResult {
	s.Env = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetEsVersions(v []*string) *GetRegionConfigurationResponseBodyResult {
	s.EsVersions = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetEsVersionsLatestList(v []*GetRegionConfigurationResponseBodyResultEsVersionsLatestList) *GetRegionConfigurationResponseBodyResult {
	s.EsVersionsLatestList = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetInstanceSupportNodes(v []*string) *GetRegionConfigurationResponseBodyResult {
	s.InstanceSupportNodes = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetJvmConfine(v *GetRegionConfigurationResponseBodyResultJvmConfine) *GetRegionConfigurationResponseBodyResult {
	s.JvmConfine = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetKibanaNodeProperties(v *GetRegionConfigurationResponseBodyResultKibanaNodeProperties) *GetRegionConfigurationResponseBodyResult {
	s.KibanaNodeProperties = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetMasterDiskList(v []*GetRegionConfigurationResponseBodyResultMasterDiskList) *GetRegionConfigurationResponseBodyResult {
	s.MasterDiskList = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetMasterSpec(v []*string) *GetRegionConfigurationResponseBodyResult {
	s.MasterSpec = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetNode(v *GetRegionConfigurationResponseBodyResultNode) *GetRegionConfigurationResponseBodyResult {
	s.Node = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetNodeSpecList(v []*GetRegionConfigurationResponseBodyResultNodeSpecList) *GetRegionConfigurationResponseBodyResult {
	s.NodeSpecList = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetRegionId(v string) *GetRegionConfigurationResponseBodyResult {
	s.RegionId = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetSupportVersions(v []*GetRegionConfigurationResponseBodyResultSupportVersions) *GetRegionConfigurationResponseBodyResult {
	s.SupportVersions = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetWarmNodeProperties(v *GetRegionConfigurationResponseBodyResultWarmNodeProperties) *GetRegionConfigurationResponseBodyResult {
	s.WarmNodeProperties = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResult) SetZones(v []*string) *GetRegionConfigurationResponseBodyResult {
	s.Zones = v
	return s
}

type GetRegionConfigurationResponseBodyResultClientNodeAmountRange struct {
	// example:
	//
	// 25
	MaxAmount *int32 `json:"maxAmount,omitempty" xml:"maxAmount,omitempty"`
	// example:
	//
	// 2
	MinAmount *int32 `json:"minAmount,omitempty" xml:"minAmount,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultClientNodeAmountRange) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultClientNodeAmountRange) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultClientNodeAmountRange) SetMaxAmount(v int32) *GetRegionConfigurationResponseBodyResultClientNodeAmountRange {
	s.MaxAmount = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultClientNodeAmountRange) SetMinAmount(v int32) *GetRegionConfigurationResponseBodyResultClientNodeAmountRange {
	s.MinAmount = &v
	return s
}

type GetRegionConfigurationResponseBodyResultClientNodeDiskList struct {
	// example:
	//
	// cloud_efficiency
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// 20
	MaxSize *int32 `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	// example:
	//
	// 20
	MinSize *int32 `json:"minSize,omitempty" xml:"minSize,omitempty"`
	// example:
	//
	// 18
	ScaleLimit *int32 `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultClientNodeDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultClientNodeDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultClientNodeDiskList) SetDiskType(v string) *GetRegionConfigurationResponseBodyResultClientNodeDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultClientNodeDiskList) SetMaxSize(v int32) *GetRegionConfigurationResponseBodyResultClientNodeDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultClientNodeDiskList) SetMinSize(v int32) *GetRegionConfigurationResponseBodyResultClientNodeDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultClientNodeDiskList) SetScaleLimit(v int32) *GetRegionConfigurationResponseBodyResultClientNodeDiskList {
	s.ScaleLimit = &v
	return s
}

type GetRegionConfigurationResponseBodyResultDataDiskList struct {
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// 5120
	MaxSize *int32 `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	// example:
	//
	// 20
	MinSize *int32 `json:"minSize,omitempty" xml:"minSize,omitempty"`
	// example:
	//
	// 2048
	ScaleLimit    *int32    `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
	ValueLimitSet []*string `json:"valueLimitSet,omitempty" xml:"valueLimitSet,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultDataDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultDataDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultDataDiskList) SetDiskType(v string) *GetRegionConfigurationResponseBodyResultDataDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultDataDiskList) SetMaxSize(v int32) *GetRegionConfigurationResponseBodyResultDataDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultDataDiskList) SetMinSize(v int32) *GetRegionConfigurationResponseBodyResultDataDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultDataDiskList) SetScaleLimit(v int32) *GetRegionConfigurationResponseBodyResultDataDiskList {
	s.ScaleLimit = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultDataDiskList) SetValueLimitSet(v []*string) *GetRegionConfigurationResponseBodyResultDataDiskList {
	s.ValueLimitSet = v
	return s
}

type GetRegionConfigurationResponseBodyResultElasticNodeProperties struct {
	AmountRange *GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange `json:"amountRange,omitempty" xml:"amountRange,omitempty" type:"Struct"`
	DiskList    []*GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList  `json:"diskList,omitempty" xml:"diskList,omitempty" type:"Repeated"`
	Spec        []*string                                                                 `json:"spec,omitempty" xml:"spec,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultElasticNodeProperties) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultElasticNodeProperties) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodeProperties) SetAmountRange(v *GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange) *GetRegionConfigurationResponseBodyResultElasticNodeProperties {
	s.AmountRange = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodeProperties) SetDiskList(v []*GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) *GetRegionConfigurationResponseBodyResultElasticNodeProperties {
	s.DiskList = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodeProperties) SetSpec(v []*string) *GetRegionConfigurationResponseBodyResultElasticNodeProperties {
	s.Spec = v
	return s
}

type GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange struct {
	// example:
	//
	// 25
	MaxAmount *int32 `json:"maxAmount,omitempty" xml:"maxAmount,omitempty"`
	// example:
	//
	// 2
	MinAmount *int32 `json:"minAmount,omitempty" xml:"minAmount,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange) SetMaxAmount(v int32) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange {
	s.MaxAmount = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange) SetMinAmount(v int32) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange {
	s.MinAmount = &v
	return s
}

type GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList struct {
	// example:
	//
	// true
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// 5120
	MaxSize *int32 `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	// example:
	//
	// 500
	MinSize *int32 `json:"minSize,omitempty" xml:"minSize,omitempty"`
	// example:
	//
	// 2048
	ScaleLimit    *int32    `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
	ValueLimitSet []*string `json:"valueLimitSet,omitempty" xml:"valueLimitSet,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) SetDiskEncryption(v bool) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList {
	s.DiskEncryption = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) SetDiskType(v string) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) SetMaxSize(v int32) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) SetMinSize(v int32) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) SetScaleLimit(v int32) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList {
	s.ScaleLimit = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList) SetValueLimitSet(v []*string) *GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList {
	s.ValueLimitSet = v
	return s
}

type GetRegionConfigurationResponseBodyResultEsVersionsLatestList struct {
	// example:
	//
	// 5.5_with_X-Pack
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// example:
	//
	// 5.5.3_with_X-Pack
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultEsVersionsLatestList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultEsVersionsLatestList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultEsVersionsLatestList) SetKey(v string) *GetRegionConfigurationResponseBodyResultEsVersionsLatestList {
	s.Key = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultEsVersionsLatestList) SetValue(v string) *GetRegionConfigurationResponseBodyResultEsVersionsLatestList {
	s.Value = &v
	return s
}

type GetRegionConfigurationResponseBodyResultJvmConfine struct {
	// example:
	//
	// 32
	Memory            *int32    `json:"memory,omitempty" xml:"memory,omitempty"`
	SupportEsVersions []*string `json:"supportEsVersions,omitempty" xml:"supportEsVersions,omitempty" type:"Repeated"`
	SupportGcs        []*string `json:"supportGcs,omitempty" xml:"supportGcs,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultJvmConfine) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultJvmConfine) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultJvmConfine) SetMemory(v int32) *GetRegionConfigurationResponseBodyResultJvmConfine {
	s.Memory = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultJvmConfine) SetSupportEsVersions(v []*string) *GetRegionConfigurationResponseBodyResultJvmConfine {
	s.SupportEsVersions = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultJvmConfine) SetSupportGcs(v []*string) *GetRegionConfigurationResponseBodyResultJvmConfine {
	s.SupportGcs = v
	return s
}

type GetRegionConfigurationResponseBodyResultKibanaNodeProperties struct {
	AmountRange *GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange `json:"amountRange,omitempty" xml:"amountRange,omitempty" type:"Struct"`
	Spec        []*string                                                                `json:"spec,omitempty" xml:"spec,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultKibanaNodeProperties) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultKibanaNodeProperties) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultKibanaNodeProperties) SetAmountRange(v *GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange) *GetRegionConfigurationResponseBodyResultKibanaNodeProperties {
	s.AmountRange = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultKibanaNodeProperties) SetSpec(v []*string) *GetRegionConfigurationResponseBodyResultKibanaNodeProperties {
	s.Spec = v
	return s
}

type GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange struct {
	// example:
	//
	// 20
	MaxAmount *int32 `json:"maxAmount,omitempty" xml:"maxAmount,omitempty"`
	// example:
	//
	// 1
	MinAmount *int32 `json:"minAmount,omitempty" xml:"minAmount,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange) SetMaxAmount(v int32) *GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange {
	s.MaxAmount = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange) SetMinAmount(v int32) *GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange {
	s.MinAmount = &v
	return s
}

type GetRegionConfigurationResponseBodyResultMasterDiskList struct {
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// 20
	MaxSize *int32 `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	// example:
	//
	// 20
	MinSize *int32 `json:"minSize,omitempty" xml:"minSize,omitempty"`
	// example:
	//
	// 20
	ScaleLimit *int32 `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultMasterDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultMasterDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultMasterDiskList) SetDiskType(v string) *GetRegionConfigurationResponseBodyResultMasterDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultMasterDiskList) SetMaxSize(v int32) *GetRegionConfigurationResponseBodyResultMasterDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultMasterDiskList) SetMinSize(v int32) *GetRegionConfigurationResponseBodyResultMasterDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultMasterDiskList) SetScaleLimit(v int32) *GetRegionConfigurationResponseBodyResultMasterDiskList {
	s.ScaleLimit = &v
	return s
}

type GetRegionConfigurationResponseBodyResultNode struct {
	// example:
	//
	// 50
	MaxAmount *int32 `json:"maxAmount,omitempty" xml:"maxAmount,omitempty"`
	// example:
	//
	// 2
	MinAmount *int32 `json:"minAmount,omitempty" xml:"minAmount,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultNode) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultNode) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultNode) SetMaxAmount(v int32) *GetRegionConfigurationResponseBodyResultNode {
	s.MaxAmount = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultNode) SetMinAmount(v int32) *GetRegionConfigurationResponseBodyResultNode {
	s.MinAmount = &v
	return s
}

type GetRegionConfigurationResponseBodyResultNodeSpecList struct {
	// example:
	//
	// 16
	CpuCount *int32 `json:"cpuCount,omitempty" xml:"cpuCount,omitempty"`
	// example:
	//
	// 44000
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// local_efficiency
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// true
	Enable *bool `json:"enable,omitempty" xml:"enable,omitempty"`
	// example:
	//
	// 64
	MemorySize *int32 `json:"memorySize,omitempty" xml:"memorySize,omitempty"`
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
	// example:
	//
	// local_efficiency
	SpecGroupType *string `json:"specGroupType,omitempty" xml:"specGroupType,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultNodeSpecList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultNodeSpecList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultNodeSpecList) SetCpuCount(v int32) *GetRegionConfigurationResponseBodyResultNodeSpecList {
	s.CpuCount = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultNodeSpecList) SetDisk(v int32) *GetRegionConfigurationResponseBodyResultNodeSpecList {
	s.Disk = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultNodeSpecList) SetDiskType(v string) *GetRegionConfigurationResponseBodyResultNodeSpecList {
	s.DiskType = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultNodeSpecList) SetEnable(v bool) *GetRegionConfigurationResponseBodyResultNodeSpecList {
	s.Enable = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultNodeSpecList) SetMemorySize(v int32) *GetRegionConfigurationResponseBodyResultNodeSpecList {
	s.MemorySize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultNodeSpecList) SetSpec(v string) *GetRegionConfigurationResponseBodyResultNodeSpecList {
	s.Spec = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultNodeSpecList) SetSpecGroupType(v string) *GetRegionConfigurationResponseBodyResultNodeSpecList {
	s.SpecGroupType = &v
	return s
}

type GetRegionConfigurationResponseBodyResultSupportVersions struct {
	// example:
	//
	// x-pack
	InstanceCategory   *string                                                                      `json:"instanceCategory,omitempty" xml:"instanceCategory,omitempty"`
	SupportVersionList []*GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList `json:"supportVersionList,omitempty" xml:"supportVersionList,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultSupportVersions) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultSupportVersions) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultSupportVersions) SetInstanceCategory(v string) *GetRegionConfigurationResponseBodyResultSupportVersions {
	s.InstanceCategory = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultSupportVersions) SetSupportVersionList(v []*GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList) *GetRegionConfigurationResponseBodyResultSupportVersions {
	s.SupportVersionList = v
	return s
}

type GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList struct {
	// example:
	//
	// 5.5
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// example:
	//
	// 5.5.3
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList) SetKey(v string) *GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList {
	s.Key = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList) SetValue(v string) *GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList {
	s.Value = &v
	return s
}

type GetRegionConfigurationResponseBodyResultWarmNodeProperties struct {
	AmountRange *GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange `json:"amountRange,omitempty" xml:"amountRange,omitempty" type:"Struct"`
	DiskList    []*GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList  `json:"diskList,omitempty" xml:"diskList,omitempty" type:"Repeated"`
	Spec        []*string                                                              `json:"spec,omitempty" xml:"spec,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultWarmNodeProperties) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultWarmNodeProperties) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodeProperties) SetAmountRange(v *GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange) *GetRegionConfigurationResponseBodyResultWarmNodeProperties {
	s.AmountRange = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodeProperties) SetDiskList(v []*GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) *GetRegionConfigurationResponseBodyResultWarmNodeProperties {
	s.DiskList = v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodeProperties) SetSpec(v []*string) *GetRegionConfigurationResponseBodyResultWarmNodeProperties {
	s.Spec = v
	return s
}

type GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange struct {
	// example:
	//
	// 50
	MaxAmount *int32 `json:"maxAmount,omitempty" xml:"maxAmount,omitempty"`
	// example:
	//
	// 2
	MinAmount *int32 `json:"minAmount,omitempty" xml:"minAmount,omitempty"`
}

func (s GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange) SetMaxAmount(v int32) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange {
	s.MaxAmount = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange) SetMinAmount(v int32) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange {
	s.MinAmount = &v
	return s
}

type GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList struct {
	// example:
	//
	// true
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// example:
	//
	// cloud_efficiency
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// 5120
	MaxSize *int32 `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	// example:
	//
	// 500
	MinSize *int32 `json:"minSize,omitempty" xml:"minSize,omitempty"`
	// example:
	//
	// 2048
	ScaleLimit    *int32    `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
	ValueLimitSet []*string `json:"valueLimitSet,omitempty" xml:"valueLimitSet,omitempty" type:"Repeated"`
}

func (s GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) SetDiskEncryption(v bool) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList {
	s.DiskEncryption = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) SetDiskType(v string) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) SetMaxSize(v int32) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) SetMinSize(v int32) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) SetScaleLimit(v int32) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList {
	s.ScaleLimit = &v
	return s
}

func (s *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList) SetValueLimitSet(v []*string) *GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList {
	s.ValueLimitSet = v
	return s
}

type GetRegionConfigurationResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetRegionConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetRegionConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRegionConfigurationResponse) GoString() string {
	return s.String()
}

func (s *GetRegionConfigurationResponse) SetHeaders(v map[string]*string) *GetRegionConfigurationResponse {
	s.Headers = v
	return s
}

func (s *GetRegionConfigurationResponse) SetStatusCode(v int32) *GetRegionConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRegionConfigurationResponse) SetBody(v *GetRegionConfigurationResponseBody) *GetRegionConfigurationResponse {
	s.Body = v
	return s
}

type GetRegionalInstanceConfigResponseBody struct {
	RequestId *string                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *GetRegionalInstanceConfigResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s GetRegionalInstanceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBody) SetRequestId(v string) *GetRegionalInstanceConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBody) SetResult(v *GetRegionalInstanceConfigResponseBodyResult) *GetRegionalInstanceConfigResponseBody {
	s.Result = v
	return s
}

type GetRegionalInstanceConfigResponseBodyResult struct {
	ClientNodeAmountRange *GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange `json:"clientNodeAmountRange,omitempty" xml:"clientNodeAmountRange,omitempty" type:"Struct"`
	ClientNodeDiskList    []*GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList  `json:"clientNodeDiskList,omitempty" xml:"clientNodeDiskList,omitempty" type:"Repeated"`
	ClientSpecs           []*string                                                         `json:"clientSpecs,omitempty" xml:"clientSpecs,omitempty" type:"Repeated"`
	DataNodeAmountRange   *GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange   `json:"dataNodeAmountRange,omitempty" xml:"dataNodeAmountRange,omitempty" type:"Struct"`
	DataNodeDiskList      []*GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList    `json:"dataNodeDiskList,omitempty" xml:"dataNodeDiskList,omitempty" type:"Repeated"`
	DataNodeSpecs         []*string                                                         `json:"dataNodeSpecs,omitempty" xml:"dataNodeSpecs,omitempty" type:"Repeated"`
	KibanaSpecs           []*string                                                         `json:"kibanaSpecs,omitempty" xml:"kibanaSpecs,omitempty" type:"Repeated"`
	MasterAmountRange     []*string                                                         `json:"masterAmountRange,omitempty" xml:"masterAmountRange,omitempty" type:"Repeated"`
	MasterDiskList        []*GetRegionalInstanceConfigResponseBodyResultMasterDiskList      `json:"masterDiskList,omitempty" xml:"masterDiskList,omitempty" type:"Repeated"`
	MasterSpecs           []*string                                                         `json:"masterSpecs,omitempty" xml:"masterSpecs,omitempty" type:"Repeated"`
	SpecInfoMap           map[string]*ResultSpecInfoMapValue                                `json:"specInfoMap,omitempty" xml:"specInfoMap,omitempty"`
	Versions              []*string                                                         `json:"versions,omitempty" xml:"versions,omitempty" type:"Repeated"`
}

func (s GetRegionalInstanceConfigResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetClientNodeAmountRange(v *GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange) *GetRegionalInstanceConfigResponseBodyResult {
	s.ClientNodeAmountRange = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetClientNodeDiskList(v []*GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList) *GetRegionalInstanceConfigResponseBodyResult {
	s.ClientNodeDiskList = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetClientSpecs(v []*string) *GetRegionalInstanceConfigResponseBodyResult {
	s.ClientSpecs = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetDataNodeAmountRange(v *GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange) *GetRegionalInstanceConfigResponseBodyResult {
	s.DataNodeAmountRange = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetDataNodeDiskList(v []*GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) *GetRegionalInstanceConfigResponseBodyResult {
	s.DataNodeDiskList = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetDataNodeSpecs(v []*string) *GetRegionalInstanceConfigResponseBodyResult {
	s.DataNodeSpecs = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetKibanaSpecs(v []*string) *GetRegionalInstanceConfigResponseBodyResult {
	s.KibanaSpecs = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetMasterAmountRange(v []*string) *GetRegionalInstanceConfigResponseBodyResult {
	s.MasterAmountRange = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetMasterDiskList(v []*GetRegionalInstanceConfigResponseBodyResultMasterDiskList) *GetRegionalInstanceConfigResponseBodyResult {
	s.MasterDiskList = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetMasterSpecs(v []*string) *GetRegionalInstanceConfigResponseBodyResult {
	s.MasterSpecs = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetSpecInfoMap(v map[string]*ResultSpecInfoMapValue) *GetRegionalInstanceConfigResponseBodyResult {
	s.SpecInfoMap = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResult) SetVersions(v []*string) *GetRegionalInstanceConfigResponseBodyResult {
	s.Versions = v
	return s
}

type GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange struct {
	MaxAmount *int32 `json:"maxAmount,omitempty" xml:"maxAmount,omitempty"`
	MinAmount *int32 `json:"minAmount,omitempty" xml:"minAmount,omitempty"`
}

func (s GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange) SetMaxAmount(v int32) *GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange {
	s.MaxAmount = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange) SetMinAmount(v int32) *GetRegionalInstanceConfigResponseBodyResultClientNodeAmountRange {
	s.MinAmount = &v
	return s
}

type GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList struct {
	DiskType   *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	MaxSize    *int32  `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	MinSize    *int32  `json:"minSize,omitempty" xml:"minSize,omitempty"`
	ScaleLimit *int32  `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
}

func (s GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList) SetDiskType(v string) *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList) SetMaxSize(v int32) *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList) SetMinSize(v int32) *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList) SetScaleLimit(v int32) *GetRegionalInstanceConfigResponseBodyResultClientNodeDiskList {
	s.ScaleLimit = &v
	return s
}

type GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange struct {
	MaxAmount *int32 `json:"maxAmount,omitempty" xml:"maxAmount,omitempty"`
	MinAmount *int32 `json:"minAmount,omitempty" xml:"minAmount,omitempty"`
}

func (s GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange) SetMaxAmount(v int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange {
	s.MaxAmount = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange) SetMinAmount(v int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeAmountRange {
	s.MinAmount = &v
	return s
}

type GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList struct {
	DiskType                  *string                                                                                 `json:"diskType,omitempty" xml:"diskType,omitempty"`
	MaxSize                   *int32                                                                                  `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	MinSize                   *int32                                                                                  `json:"minSize,omitempty" xml:"minSize,omitempty"`
	ScaleLimit                *int32                                                                                  `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
	SubClassificationConfines []*GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines `json:"subClassificationConfines,omitempty" xml:"subClassificationConfines,omitempty" type:"Repeated"`
	ValueLimitSet             []*int32                                                                                `json:"valueLimitSet,omitempty" xml:"valueLimitSet,omitempty" type:"Repeated"`
}

func (s GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) SetDiskType(v string) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) SetMaxSize(v int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) SetMinSize(v int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) SetScaleLimit(v int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList {
	s.ScaleLimit = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) SetSubClassificationConfines(v []*GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList {
	s.SubClassificationConfines = v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList) SetValueLimitSet(v []*int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskList {
	s.ValueLimitSet = v
	return s
}

type GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines struct {
	MaxSize          *int32  `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	MinSize          *int32  `json:"minSize,omitempty" xml:"minSize,omitempty"`
	PerformanceLevel *string `json:"performanceLevel,omitempty" xml:"performanceLevel,omitempty"`
}

func (s GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines) SetMaxSize(v int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines {
	s.MaxSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines) SetMinSize(v int32) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines {
	s.MinSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines) SetPerformanceLevel(v string) *GetRegionalInstanceConfigResponseBodyResultDataNodeDiskListSubClassificationConfines {
	s.PerformanceLevel = &v
	return s
}

type GetRegionalInstanceConfigResponseBodyResultMasterDiskList struct {
	DiskType                  *string                                                                               `json:"diskType,omitempty" xml:"diskType,omitempty"`
	MaxSize                   *int32                                                                                `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	MinSize                   *int32                                                                                `json:"minSize,omitempty" xml:"minSize,omitempty"`
	ScaleLimit                *int32                                                                                `json:"scaleLimit,omitempty" xml:"scaleLimit,omitempty"`
	SubClassificationConfines []*GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines `json:"subClassificationConfines,omitempty" xml:"subClassificationConfines,omitempty" type:"Repeated"`
}

func (s GetRegionalInstanceConfigResponseBodyResultMasterDiskList) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResultMasterDiskList) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskList) SetDiskType(v string) *GetRegionalInstanceConfigResponseBodyResultMasterDiskList {
	s.DiskType = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskList) SetMaxSize(v int32) *GetRegionalInstanceConfigResponseBodyResultMasterDiskList {
	s.MaxSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskList) SetMinSize(v int32) *GetRegionalInstanceConfigResponseBodyResultMasterDiskList {
	s.MinSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskList) SetScaleLimit(v int32) *GetRegionalInstanceConfigResponseBodyResultMasterDiskList {
	s.ScaleLimit = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskList) SetSubClassificationConfines(v []*GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines) *GetRegionalInstanceConfigResponseBodyResultMasterDiskList {
	s.SubClassificationConfines = v
	return s
}

type GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines struct {
	MaxSize          *int32  `json:"maxSize,omitempty" xml:"maxSize,omitempty"`
	MinSize          *int32  `json:"minSize,omitempty" xml:"minSize,omitempty"`
	PerformanceLevel *string `json:"performanceLevel,omitempty" xml:"performanceLevel,omitempty"`
}

func (s GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines) SetMaxSize(v int32) *GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines {
	s.MaxSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines) SetMinSize(v int32) *GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines {
	s.MinSize = &v
	return s
}

func (s *GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines) SetPerformanceLevel(v string) *GetRegionalInstanceConfigResponseBodyResultMasterDiskListSubClassificationConfines {
	s.PerformanceLevel = &v
	return s
}

type GetRegionalInstanceConfigResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetRegionalInstanceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetRegionalInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRegionalInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *GetRegionalInstanceConfigResponse) SetHeaders(v map[string]*string) *GetRegionalInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *GetRegionalInstanceConfigResponse) SetStatusCode(v int32) *GetRegionalInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRegionalInstanceConfigResponse) SetBody(v *GetRegionalInstanceConfigResponseBody) *GetRegionalInstanceConfigResponse {
	s.Body = v
	return s
}

type GetSuggestShrinkableNodesRequest struct {
	// The number of nodes that you want to remove.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// Specifies whether to ignore the instance status. Default value: false.
	//
	// example:
	//
	// false
	IgnoreStatus *bool `json:"ignoreStatus,omitempty" xml:"ignoreStatus,omitempty"`
	// The type of removing nodes. WORKER indicates hot node and WORKER_WARM indicates warm node.
	//
	// This parameter is required.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
}

func (s GetSuggestShrinkableNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSuggestShrinkableNodesRequest) GoString() string {
	return s.String()
}

func (s *GetSuggestShrinkableNodesRequest) SetCount(v int32) *GetSuggestShrinkableNodesRequest {
	s.Count = &v
	return s
}

func (s *GetSuggestShrinkableNodesRequest) SetIgnoreStatus(v bool) *GetSuggestShrinkableNodesRequest {
	s.IgnoreStatus = &v
	return s
}

func (s *GetSuggestShrinkableNodesRequest) SetNodeType(v string) *GetSuggestShrinkableNodesRequest {
	s.NodeType = &v
	return s
}

type GetSuggestShrinkableNodesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result []*GetSuggestShrinkableNodesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s GetSuggestShrinkableNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSuggestShrinkableNodesResponseBody) GoString() string {
	return s.String()
}

func (s *GetSuggestShrinkableNodesResponseBody) SetRequestId(v string) *GetSuggestShrinkableNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSuggestShrinkableNodesResponseBody) SetResult(v []*GetSuggestShrinkableNodesResponseBodyResult) *GetSuggestShrinkableNodesResponseBody {
	s.Result = v
	return s
}

type GetSuggestShrinkableNodesResponseBodyResult struct {
	// The IP address of the node.
	//
	// example:
	//
	// 192.168.\*\*.**
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// The access port number of the node.
	//
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
}

func (s GetSuggestShrinkableNodesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetSuggestShrinkableNodesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetSuggestShrinkableNodesResponseBodyResult) SetHost(v string) *GetSuggestShrinkableNodesResponseBodyResult {
	s.Host = &v
	return s
}

func (s *GetSuggestShrinkableNodesResponseBodyResult) SetPort(v int32) *GetSuggestShrinkableNodesResponseBodyResult {
	s.Port = &v
	return s
}

type GetSuggestShrinkableNodesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetSuggestShrinkableNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetSuggestShrinkableNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSuggestShrinkableNodesResponse) GoString() string {
	return s.String()
}

func (s *GetSuggestShrinkableNodesResponse) SetHeaders(v map[string]*string) *GetSuggestShrinkableNodesResponse {
	s.Headers = v
	return s
}

func (s *GetSuggestShrinkableNodesResponse) SetStatusCode(v int32) *GetSuggestShrinkableNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSuggestShrinkableNodesResponse) SetBody(v *GetSuggestShrinkableNodesResponseBody) *GetSuggestShrinkableNodesResponse {
	s.Body = v
	return s
}

type GetTransferableNodesRequest struct {
	// The number of nodes to be migrated.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The type of nodes.**WORKER**represents a hot node,**WORKER_WARM*	- represents a warm node.
	//
	// This parameter is required.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
}

func (s GetTransferableNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTransferableNodesRequest) GoString() string {
	return s.String()
}

func (s *GetTransferableNodesRequest) SetCount(v int32) *GetTransferableNodesRequest {
	s.Count = &v
	return s
}

func (s *GetTransferableNodesRequest) SetNodeType(v string) *GetTransferableNodesRequest {
	s.NodeType = &v
	return s
}

type GetTransferableNodesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result []*GetTransferableNodesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s GetTransferableNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTransferableNodesResponseBody) GoString() string {
	return s.String()
}

func (s *GetTransferableNodesResponseBody) SetRequestId(v string) *GetTransferableNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTransferableNodesResponseBody) SetResult(v []*GetTransferableNodesResponseBodyResult) *GetTransferableNodesResponseBody {
	s.Result = v
	return s
}

type GetTransferableNodesResponseBodyResult struct {
	// The IP address of the node.
	//
	// example:
	//
	// 192.168.\*\*.**
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// The access port of the node.
	//
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
}

func (s GetTransferableNodesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s GetTransferableNodesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *GetTransferableNodesResponseBodyResult) SetHost(v string) *GetTransferableNodesResponseBodyResult {
	s.Host = &v
	return s
}

func (s *GetTransferableNodesResponseBodyResult) SetPort(v int32) *GetTransferableNodesResponseBodyResult {
	s.Port = &v
	return s
}

type GetTransferableNodesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetTransferableNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetTransferableNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTransferableNodesResponse) GoString() string {
	return s.String()
}

func (s *GetTransferableNodesResponse) SetHeaders(v map[string]*string) *GetTransferableNodesResponse {
	s.Headers = v
	return s
}

func (s *GetTransferableNodesResponse) SetStatusCode(v int32) *GetTransferableNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTransferableNodesResponse) SetBody(v *GetTransferableNodesResponseBody) *GetTransferableNodesResponse {
	s.Body = v
	return s
}

type InitializeOperationRoleRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InitializeOperationRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s InitializeOperationRoleRequest) GoString() string {
	return s.String()
}

func (s *InitializeOperationRoleRequest) SetClientToken(v string) *InitializeOperationRoleRequest {
	s.ClientToken = &v
	return s
}

func (s *InitializeOperationRoleRequest) SetBody(v string) *InitializeOperationRoleRequest {
	s.Body = &v
	return s
}

type InitializeOperationRoleResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 29101430-4797-4D1D-96C3-9FCBCCA8F845
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the service-linked role is created. Valid values:
	//
	// 	- true: The service-linked role is created.
	//
	// 	- false: The service-linked role fails to be created.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s InitializeOperationRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InitializeOperationRoleResponseBody) GoString() string {
	return s.String()
}

func (s *InitializeOperationRoleResponseBody) SetRequestId(v string) *InitializeOperationRoleResponseBody {
	s.RequestId = &v
	return s
}

func (s *InitializeOperationRoleResponseBody) SetResult(v bool) *InitializeOperationRoleResponseBody {
	s.Result = &v
	return s
}

type InitializeOperationRoleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InitializeOperationRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InitializeOperationRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s InitializeOperationRoleResponse) GoString() string {
	return s.String()
}

func (s *InitializeOperationRoleResponse) SetHeaders(v map[string]*string) *InitializeOperationRoleResponse {
	s.Headers = v
	return s
}

func (s *InitializeOperationRoleResponse) SetStatusCode(v int32) *InitializeOperationRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *InitializeOperationRoleResponse) SetBody(v *InitializeOperationRoleResponseBody) *InitializeOperationRoleResponse {
	s.Body = v
	return s
}

type InstallAckOperatorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallAckOperatorRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallAckOperatorRequest) GoString() string {
	return s.String()
}

func (s *InstallAckOperatorRequest) SetClientToken(v string) *InstallAckOperatorRequest {
	s.ClientToken = &v
	return s
}

func (s *InstallAckOperatorRequest) SetBody(v string) *InstallAckOperatorRequest {
	s.Body = &v
	return s
}

type InstallAckOperatorResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// EFA88951-7A6F-4A8E-AB8F-2BB7132BA751
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether ES-operator is installed. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s InstallAckOperatorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallAckOperatorResponseBody) GoString() string {
	return s.String()
}

func (s *InstallAckOperatorResponseBody) SetRequestId(v string) *InstallAckOperatorResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallAckOperatorResponseBody) SetResult(v bool) *InstallAckOperatorResponseBody {
	s.Result = &v
	return s
}

type InstallAckOperatorResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InstallAckOperatorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallAckOperatorResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallAckOperatorResponse) GoString() string {
	return s.String()
}

func (s *InstallAckOperatorResponse) SetHeaders(v map[string]*string) *InstallAckOperatorResponse {
	s.Headers = v
	return s
}

func (s *InstallAckOperatorResponse) SetStatusCode(v int32) *InstallAckOperatorResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallAckOperatorResponse) SetBody(v *InstallAckOperatorResponseBody) *InstallAckOperatorResponse {
	s.Body = v
	return s
}

type InstallKibanaSystemPluginRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s InstallKibanaSystemPluginRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallKibanaSystemPluginRequest) GoString() string {
	return s.String()
}

func (s *InstallKibanaSystemPluginRequest) SetBody(v string) *InstallKibanaSystemPluginRequest {
	s.Body = &v
	return s
}

func (s *InstallKibanaSystemPluginRequest) SetClientToken(v string) *InstallKibanaSystemPluginRequest {
	s.ClientToken = &v
	return s
}

type InstallKibanaSystemPluginResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of plug-ins to be installed.
	Result []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s InstallKibanaSystemPluginResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallKibanaSystemPluginResponseBody) GoString() string {
	return s.String()
}

func (s *InstallKibanaSystemPluginResponseBody) SetRequestId(v string) *InstallKibanaSystemPluginResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallKibanaSystemPluginResponseBody) SetResult(v []*string) *InstallKibanaSystemPluginResponseBody {
	s.Result = v
	return s
}

type InstallKibanaSystemPluginResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InstallKibanaSystemPluginResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallKibanaSystemPluginResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallKibanaSystemPluginResponse) GoString() string {
	return s.String()
}

func (s *InstallKibanaSystemPluginResponse) SetHeaders(v map[string]*string) *InstallKibanaSystemPluginResponse {
	s.Headers = v
	return s
}

func (s *InstallKibanaSystemPluginResponse) SetStatusCode(v int32) *InstallKibanaSystemPluginResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallKibanaSystemPluginResponse) SetBody(v *InstallKibanaSystemPluginResponseBody) *InstallKibanaSystemPluginResponse {
	s.Body = v
	return s
}

type InstallLogstashSystemPluginRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s InstallLogstashSystemPluginRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallLogstashSystemPluginRequest) GoString() string {
	return s.String()
}

func (s *InstallLogstashSystemPluginRequest) SetBody(v string) *InstallLogstashSystemPluginRequest {
	s.Body = &v
	return s
}

func (s *InstallLogstashSystemPluginRequest) SetClientToken(v string) *InstallLogstashSystemPluginRequest {
	s.ClientToken = &v
	return s
}

type InstallLogstashSystemPluginResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC4****
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s InstallLogstashSystemPluginResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallLogstashSystemPluginResponseBody) GoString() string {
	return s.String()
}

func (s *InstallLogstashSystemPluginResponseBody) SetRequestId(v string) *InstallLogstashSystemPluginResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallLogstashSystemPluginResponseBody) SetResult(v []*string) *InstallLogstashSystemPluginResponseBody {
	s.Result = v
	return s
}

type InstallLogstashSystemPluginResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InstallLogstashSystemPluginResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallLogstashSystemPluginResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallLogstashSystemPluginResponse) GoString() string {
	return s.String()
}

func (s *InstallLogstashSystemPluginResponse) SetHeaders(v map[string]*string) *InstallLogstashSystemPluginResponse {
	s.Headers = v
	return s
}

func (s *InstallLogstashSystemPluginResponse) SetStatusCode(v int32) *InstallLogstashSystemPluginResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallLogstashSystemPluginResponse) SetBody(v *InstallLogstashSystemPluginResponseBody) *InstallLogstashSystemPluginResponse {
	s.Body = v
	return s
}

type InstallSystemPluginRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s InstallSystemPluginRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallSystemPluginRequest) GoString() string {
	return s.String()
}

func (s *InstallSystemPluginRequest) SetBody(v string) *InstallSystemPluginRequest {
	s.Body = &v
	return s
}

func (s *InstallSystemPluginRequest) SetClientToken(v string) *InstallSystemPluginRequest {
	s.ClientToken = &v
	return s
}

type InstallSystemPluginResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of plug-ins to be installed.
	Result []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s InstallSystemPluginResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallSystemPluginResponseBody) GoString() string {
	return s.String()
}

func (s *InstallSystemPluginResponseBody) SetRequestId(v string) *InstallSystemPluginResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallSystemPluginResponseBody) SetResult(v []*string) *InstallSystemPluginResponseBody {
	s.Result = v
	return s
}

type InstallSystemPluginResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InstallSystemPluginResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallSystemPluginResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallSystemPluginResponse) GoString() string {
	return s.String()
}

func (s *InstallSystemPluginResponse) SetHeaders(v map[string]*string) *InstallSystemPluginResponse {
	s.Headers = v
	return s
}

func (s *InstallSystemPluginResponse) SetStatusCode(v int32) *InstallSystemPluginResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallSystemPluginResponse) SetBody(v *InstallSystemPluginResponseBody) *InstallSystemPluginResponse {
	s.Body = v
	return s
}

type InstallUserPluginsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallUserPluginsRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallUserPluginsRequest) GoString() string {
	return s.String()
}

func (s *InstallUserPluginsRequest) SetBody(v string) *InstallUserPluginsRequest {
	s.Body = &v
	return s
}

type InstallUserPluginsResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6F*****
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s InstallUserPluginsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallUserPluginsResponseBody) GoString() string {
	return s.String()
}

func (s *InstallUserPluginsResponseBody) SetRequestId(v string) *InstallUserPluginsResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallUserPluginsResponseBody) SetResult(v []*string) *InstallUserPluginsResponseBody {
	s.Result = v
	return s
}

type InstallUserPluginsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InstallUserPluginsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallUserPluginsResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallUserPluginsResponse) GoString() string {
	return s.String()
}

func (s *InstallUserPluginsResponse) SetHeaders(v map[string]*string) *InstallUserPluginsResponse {
	s.Headers = v
	return s
}

func (s *InstallUserPluginsResponse) SetStatusCode(v int32) *InstallUserPluginsResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallUserPluginsResponse) SetBody(v *InstallUserPluginsResponseBody) *InstallUserPluginsResponse {
	s.Body = v
	return s
}

type InterruptElasticsearchTaskRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s InterruptElasticsearchTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s InterruptElasticsearchTaskRequest) GoString() string {
	return s.String()
}

func (s *InterruptElasticsearchTaskRequest) SetClientToken(v string) *InterruptElasticsearchTaskRequest {
	s.ClientToken = &v
	return s
}

type InterruptElasticsearchTaskResponseBody struct {
	// The error code. Only displayed if an exception is returned.
	//
	// example:
	//
	// InstanceStatusNotSupportCurrentAction
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message. Only displayed if an exception is returned.
	//
	// example:
	//
	// The cluster is running tasks or in an error status. Try again later.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: interrupted change successfully
	//
	// 	- false: interrupted change failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s InterruptElasticsearchTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InterruptElasticsearchTaskResponseBody) GoString() string {
	return s.String()
}

func (s *InterruptElasticsearchTaskResponseBody) SetCode(v string) *InterruptElasticsearchTaskResponseBody {
	s.Code = &v
	return s
}

func (s *InterruptElasticsearchTaskResponseBody) SetMessage(v string) *InterruptElasticsearchTaskResponseBody {
	s.Message = &v
	return s
}

func (s *InterruptElasticsearchTaskResponseBody) SetRequestId(v string) *InterruptElasticsearchTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *InterruptElasticsearchTaskResponseBody) SetResult(v bool) *InterruptElasticsearchTaskResponseBody {
	s.Result = &v
	return s
}

type InterruptElasticsearchTaskResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InterruptElasticsearchTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InterruptElasticsearchTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s InterruptElasticsearchTaskResponse) GoString() string {
	return s.String()
}

func (s *InterruptElasticsearchTaskResponse) SetHeaders(v map[string]*string) *InterruptElasticsearchTaskResponse {
	s.Headers = v
	return s
}

func (s *InterruptElasticsearchTaskResponse) SetStatusCode(v int32) *InterruptElasticsearchTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *InterruptElasticsearchTaskResponse) SetBody(v *InterruptElasticsearchTaskResponseBody) *InterruptElasticsearchTaskResponse {
	s.Body = v
	return s
}

type InterruptLogstashTaskRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s InterruptLogstashTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s InterruptLogstashTaskRequest) GoString() string {
	return s.String()
}

func (s *InterruptLogstashTaskRequest) SetClientToken(v string) *InterruptLogstashTaskRequest {
	s.ClientToken = &v
	return s
}

type InterruptLogstashTaskResponseBody struct {
	// The error code returned. If the API operation is successfully called, this parameter is not returned.
	//
	// example:
	//
	// .
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned. If the API operation is successfully called, this parameter is not returned.
	//
	// example:
	//
	// .
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 0FA05123-745C-42FD-A69B-AFF48EF9****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the task is suspended. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s InterruptLogstashTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InterruptLogstashTaskResponseBody) GoString() string {
	return s.String()
}

func (s *InterruptLogstashTaskResponseBody) SetCode(v string) *InterruptLogstashTaskResponseBody {
	s.Code = &v
	return s
}

func (s *InterruptLogstashTaskResponseBody) SetMessage(v string) *InterruptLogstashTaskResponseBody {
	s.Message = &v
	return s
}

func (s *InterruptLogstashTaskResponseBody) SetRequestId(v string) *InterruptLogstashTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *InterruptLogstashTaskResponseBody) SetResult(v bool) *InterruptLogstashTaskResponseBody {
	s.Result = &v
	return s
}

type InterruptLogstashTaskResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InterruptLogstashTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InterruptLogstashTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s InterruptLogstashTaskResponse) GoString() string {
	return s.String()
}

func (s *InterruptLogstashTaskResponse) SetHeaders(v map[string]*string) *InterruptLogstashTaskResponse {
	s.Headers = v
	return s
}

func (s *InterruptLogstashTaskResponse) SetStatusCode(v int32) *InterruptLogstashTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *InterruptLogstashTaskResponse) SetBody(v *InterruptLogstashTaskResponseBody) *InterruptLogstashTaskResponse {
	s.Body = v
	return s
}

type ListAckClustersRequest struct {
	// The number of the page to return.
	//
	// example:
	//
	// 3
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The number of entries to return on each page.
	//
	// example:
	//
	// 20
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the ACK clusters belong.
	//
	// example:
	//
	// vpc-bp12nu14urf0upaf4****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s ListAckClustersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAckClustersRequest) GoString() string {
	return s.String()
}

func (s *ListAckClustersRequest) SetPage(v int32) *ListAckClustersRequest {
	s.Page = &v
	return s
}

func (s *ListAckClustersRequest) SetSize(v int32) *ListAckClustersRequest {
	s.Size = &v
	return s
}

func (s *ListAckClustersRequest) SetVpcId(v string) *ListAckClustersRequest {
	s.VpcId = &v
	return s
}

type ListAckClustersResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// F93EAA49-284F-4FCE-9E67-FA23FB4BB512
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListAckClustersResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListAckClustersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAckClustersResponseBody) GoString() string {
	return s.String()
}

func (s *ListAckClustersResponseBody) SetRequestId(v string) *ListAckClustersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAckClustersResponseBody) SetResult(v []*ListAckClustersResponseBodyResult) *ListAckClustersResponseBody {
	s.Result = v
	return s
}

type ListAckClustersResponseBodyResult struct {
	// The ID of cluster.
	//
	// example:
	//
	// c5ea2c2d9a3cf499481292f60425d****
	ClusterId *string `json:"clusterId,omitempty" xml:"clusterId,omitempty"`
	// The type of the cluster. The value is fixed as ManagedKubernetes.
	//
	// example:
	//
	// ManagedKubernetes
	ClusterType *string `json:"clusterType,omitempty" xml:"clusterType,omitempty"`
	// The name of the cluster.
	//
	// example:
	//
	// test
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The ID of the VPC to which the cluster belongs.
	//
	// example:
	//
	// vpc-bp12nu14urf0upaf4****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s ListAckClustersResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListAckClustersResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListAckClustersResponseBodyResult) SetClusterId(v string) *ListAckClustersResponseBodyResult {
	s.ClusterId = &v
	return s
}

func (s *ListAckClustersResponseBodyResult) SetClusterType(v string) *ListAckClustersResponseBodyResult {
	s.ClusterType = &v
	return s
}

func (s *ListAckClustersResponseBodyResult) SetName(v string) *ListAckClustersResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListAckClustersResponseBodyResult) SetVpcId(v string) *ListAckClustersResponseBodyResult {
	s.VpcId = &v
	return s
}

type ListAckClustersResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAckClustersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAckClustersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAckClustersResponse) GoString() string {
	return s.String()
}

func (s *ListAckClustersResponse) SetHeaders(v map[string]*string) *ListAckClustersResponse {
	s.Headers = v
	return s
}

func (s *ListAckClustersResponse) SetStatusCode(v int32) *ListAckClustersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAckClustersResponse) SetBody(v *ListAckClustersResponseBody) *ListAckClustersResponse {
	s.Body = v
	return s
}

type ListAckNamespacesRequest struct {
	// The number of the page to return.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The number of entries to return on each page.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListAckNamespacesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAckNamespacesRequest) GoString() string {
	return s.String()
}

func (s *ListAckNamespacesRequest) SetPage(v int32) *ListAckNamespacesRequest {
	s.Page = &v
	return s
}

func (s *ListAckNamespacesRequest) SetSize(v int32) *ListAckNamespacesRequest {
	s.Size = &v
	return s
}

type ListAckNamespacesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 95789100-A329-473B-9D14-9E0B7DB4BD5A
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListAckNamespacesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListAckNamespacesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAckNamespacesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAckNamespacesResponseBody) SetRequestId(v string) *ListAckNamespacesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAckNamespacesResponseBody) SetResult(v []*ListAckNamespacesResponseBodyResult) *ListAckNamespacesResponseBody {
	s.Result = v
	return s
}

type ListAckNamespacesResponseBodyResult struct {
	// The namespace of the cluster.
	//
	// example:
	//
	// logging
	Namespace *string `json:"namespace,omitempty" xml:"namespace,omitempty"`
	// The status of the namespace.
	//
	// example:
	//
	// Active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s ListAckNamespacesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListAckNamespacesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListAckNamespacesResponseBodyResult) SetNamespace(v string) *ListAckNamespacesResponseBodyResult {
	s.Namespace = &v
	return s
}

func (s *ListAckNamespacesResponseBodyResult) SetStatus(v string) *ListAckNamespacesResponseBodyResult {
	s.Status = &v
	return s
}

type ListAckNamespacesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAckNamespacesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAckNamespacesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAckNamespacesResponse) GoString() string {
	return s.String()
}

func (s *ListAckNamespacesResponse) SetHeaders(v map[string]*string) *ListAckNamespacesResponse {
	s.Headers = v
	return s
}

func (s *ListAckNamespacesResponse) SetStatusCode(v int32) *ListAckNamespacesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAckNamespacesResponse) SetBody(v *ListAckNamespacesResponseBody) *ListAckNamespacesResponse {
	s.Body = v
	return s
}

type ListActionRecordsRequest struct {
	ActionNames *string `json:"actionNames,omitempty" xml:"actionNames,omitempty"`
	EndTime     *int64  `json:"endTime,omitempty" xml:"endTime,omitempty"`
	Filter      *string `json:"filter,omitempty" xml:"filter,omitempty"`
	Page        *int32  `json:"page,omitempty" xml:"page,omitempty"`
	RequestId   *string `json:"requestId,omitempty" xml:"requestId,omitempty"`
	Size        *int32  `json:"size,omitempty" xml:"size,omitempty"`
	StartTime   *int64  `json:"startTime,omitempty" xml:"startTime,omitempty"`
	UserId      *string `json:"userId,omitempty" xml:"userId,omitempty"`
}

func (s ListActionRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListActionRecordsRequest) GoString() string {
	return s.String()
}

func (s *ListActionRecordsRequest) SetActionNames(v string) *ListActionRecordsRequest {
	s.ActionNames = &v
	return s
}

func (s *ListActionRecordsRequest) SetEndTime(v int64) *ListActionRecordsRequest {
	s.EndTime = &v
	return s
}

func (s *ListActionRecordsRequest) SetFilter(v string) *ListActionRecordsRequest {
	s.Filter = &v
	return s
}

func (s *ListActionRecordsRequest) SetPage(v int32) *ListActionRecordsRequest {
	s.Page = &v
	return s
}

func (s *ListActionRecordsRequest) SetRequestId(v string) *ListActionRecordsRequest {
	s.RequestId = &v
	return s
}

func (s *ListActionRecordsRequest) SetSize(v int32) *ListActionRecordsRequest {
	s.Size = &v
	return s
}

func (s *ListActionRecordsRequest) SetStartTime(v int64) *ListActionRecordsRequest {
	s.StartTime = &v
	return s
}

func (s *ListActionRecordsRequest) SetUserId(v string) *ListActionRecordsRequest {
	s.UserId = &v
	return s
}

type ListActionRecordsResponseBody struct {
	RequestId *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListActionRecordsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListActionRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListActionRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *ListActionRecordsResponseBody) SetRequestId(v string) *ListActionRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListActionRecordsResponseBody) SetResult(v []*ListActionRecordsResponseBodyResult) *ListActionRecordsResponseBody {
	s.Result = v
	return s
}

type ListActionRecordsResponseBodyResult struct {
	ActionName             *string                                          `json:"ActionName,omitempty" xml:"ActionName,omitempty"`
	ActionParams           map[string]interface{}                           `json:"ActionParams,omitempty" xml:"ActionParams,omitempty"`
	ActionResultAccessList []*string                                        `json:"ActionResultAccessList,omitempty" xml:"ActionResultAccessList,omitempty" type:"Repeated"`
	EndTime                *int64                                           `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	InstanceId             *string                                          `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	MetaNow                *string                                          `json:"MetaNow,omitempty" xml:"MetaNow,omitempty"`
	MetaOld                *string                                          `json:"MetaOld,omitempty" xml:"MetaOld,omitempty"`
	OwnerId                *string                                          `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	Process                *string                                          `json:"Process,omitempty" xml:"Process,omitempty"`
	RecordDiff             map[string]interface{}                           `json:"RecordDiff,omitempty" xml:"RecordDiff,omitempty"`
	RecordIds              []*string                                        `json:"RecordIds,omitempty" xml:"RecordIds,omitempty" type:"Repeated"`
	RequestId              *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	StartTime              *int64                                           `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	StateType              *string                                          `json:"StateType,omitempty" xml:"StateType,omitempty"`
	StatusInfo             []*ListActionRecordsResponseBodyResultStatusInfo `json:"StatusInfo,omitempty" xml:"StatusInfo,omitempty" type:"Repeated"`
	UserId                 *string                                          `json:"UserId,omitempty" xml:"UserId,omitempty"`
	UserInfo               *string                                          `json:"UserInfo,omitempty" xml:"UserInfo,omitempty"`
	UserType               *string                                          `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s ListActionRecordsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListActionRecordsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListActionRecordsResponseBodyResult) SetActionName(v string) *ListActionRecordsResponseBodyResult {
	s.ActionName = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetActionParams(v map[string]interface{}) *ListActionRecordsResponseBodyResult {
	s.ActionParams = v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetActionResultAccessList(v []*string) *ListActionRecordsResponseBodyResult {
	s.ActionResultAccessList = v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetEndTime(v int64) *ListActionRecordsResponseBodyResult {
	s.EndTime = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetInstanceId(v string) *ListActionRecordsResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetMetaNow(v string) *ListActionRecordsResponseBodyResult {
	s.MetaNow = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetMetaOld(v string) *ListActionRecordsResponseBodyResult {
	s.MetaOld = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetOwnerId(v string) *ListActionRecordsResponseBodyResult {
	s.OwnerId = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetProcess(v string) *ListActionRecordsResponseBodyResult {
	s.Process = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetRecordDiff(v map[string]interface{}) *ListActionRecordsResponseBodyResult {
	s.RecordDiff = v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetRecordIds(v []*string) *ListActionRecordsResponseBodyResult {
	s.RecordIds = v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetRequestId(v string) *ListActionRecordsResponseBodyResult {
	s.RequestId = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetStartTime(v int64) *ListActionRecordsResponseBodyResult {
	s.StartTime = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetStateType(v string) *ListActionRecordsResponseBodyResult {
	s.StateType = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetStatusInfo(v []*ListActionRecordsResponseBodyResultStatusInfo) *ListActionRecordsResponseBodyResult {
	s.StatusInfo = v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetUserId(v string) *ListActionRecordsResponseBodyResult {
	s.UserId = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetUserInfo(v string) *ListActionRecordsResponseBodyResult {
	s.UserInfo = &v
	return s
}

func (s *ListActionRecordsResponseBodyResult) SetUserType(v string) *ListActionRecordsResponseBodyResult {
	s.UserType = &v
	return s
}

type ListActionRecordsResponseBodyResultStatusInfo struct {
	CompleteNodeCount *int32                                                        `json:"completeNodeCount,omitempty" xml:"completeNodeCount,omitempty"`
	EndTime           *int64                                                        `json:"endTime,omitempty" xml:"endTime,omitempty"`
	Exception         *string                                                       `json:"exception,omitempty" xml:"exception,omitempty"`
	LatencyMills      *int64                                                        `json:"latencyMills,omitempty" xml:"latencyMills,omitempty"`
	NodeCount         *int32                                                        `json:"nodeCount,omitempty" xml:"nodeCount,omitempty"`
	Process           *string                                                       `json:"process,omitempty" xml:"process,omitempty"`
	StartTime         *int64                                                        `json:"startTime,omitempty" xml:"startTime,omitempty"`
	StateType         *string                                                       `json:"stateType,omitempty" xml:"stateType,omitempty"`
	SubState          *string                                                       `json:"subState,omitempty" xml:"subState,omitempty"`
	SubStatusInfo     []*ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo `json:"subStatusInfo,omitempty" xml:"subStatusInfo,omitempty" type:"Repeated"`
}

func (s ListActionRecordsResponseBodyResultStatusInfo) String() string {
	return tea.Prettify(s)
}

func (s ListActionRecordsResponseBodyResultStatusInfo) GoString() string {
	return s.String()
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetCompleteNodeCount(v int32) *ListActionRecordsResponseBodyResultStatusInfo {
	s.CompleteNodeCount = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetEndTime(v int64) *ListActionRecordsResponseBodyResultStatusInfo {
	s.EndTime = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetException(v string) *ListActionRecordsResponseBodyResultStatusInfo {
	s.Exception = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetLatencyMills(v int64) *ListActionRecordsResponseBodyResultStatusInfo {
	s.LatencyMills = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetNodeCount(v int32) *ListActionRecordsResponseBodyResultStatusInfo {
	s.NodeCount = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetProcess(v string) *ListActionRecordsResponseBodyResultStatusInfo {
	s.Process = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetStartTime(v int64) *ListActionRecordsResponseBodyResultStatusInfo {
	s.StartTime = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetStateType(v string) *ListActionRecordsResponseBodyResultStatusInfo {
	s.StateType = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetSubState(v string) *ListActionRecordsResponseBodyResultStatusInfo {
	s.SubState = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfo) SetSubStatusInfo(v []*ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) *ListActionRecordsResponseBodyResultStatusInfo {
	s.SubStatusInfo = v
	return s
}

type ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo struct {
	CompleteNodeCount *int32  `json:"completeNodeCount,omitempty" xml:"completeNodeCount,omitempty"`
	EndTime           *int64  `json:"endTime,omitempty" xml:"endTime,omitempty"`
	Exception         *string `json:"exception,omitempty" xml:"exception,omitempty"`
	LatencyMills      *int64  `json:"latencyMills,omitempty" xml:"latencyMills,omitempty"`
	NodeCount         *int32  `json:"nodeCount,omitempty" xml:"nodeCount,omitempty"`
	Process           *string `json:"process,omitempty" xml:"process,omitempty"`
	StartTime         *int64  `json:"startTime,omitempty" xml:"startTime,omitempty"`
	StateType         *string `json:"stateType,omitempty" xml:"stateType,omitempty"`
	SubState          *string `json:"subState,omitempty" xml:"subState,omitempty"`
}

func (s ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) String() string {
	return tea.Prettify(s)
}

func (s ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) GoString() string {
	return s.String()
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetCompleteNodeCount(v int32) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.CompleteNodeCount = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetEndTime(v int64) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.EndTime = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetException(v string) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.Exception = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetLatencyMills(v int64) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.LatencyMills = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetNodeCount(v int32) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.NodeCount = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetProcess(v string) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.Process = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetStartTime(v int64) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.StartTime = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetStateType(v string) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.StateType = &v
	return s
}

func (s *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo) SetSubState(v string) *ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo {
	s.SubState = &v
	return s
}

type ListActionRecordsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListActionRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListActionRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListActionRecordsResponse) GoString() string {
	return s.String()
}

func (s *ListActionRecordsResponse) SetHeaders(v map[string]*string) *ListActionRecordsResponse {
	s.Headers = v
	return s
}

func (s *ListActionRecordsResponse) SetStatusCode(v int32) *ListActionRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListActionRecordsResponse) SetBody(v *ListActionRecordsResponseBody) *ListActionRecordsResponse {
	s.Body = v
	return s
}

type ListAllNodeRequest struct {
	// The Java Virtual Machine (JVM) heap memory usage of the node.
	//
	// example:
	//
	// false
	Extended *bool `json:"extended,omitempty" xml:"extended,omitempty"`
}

func (s ListAllNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAllNodeRequest) GoString() string {
	return s.String()
}

func (s *ListAllNodeRequest) SetExtended(v bool) *ListAllNodeRequest {
	s.Extended = &v
	return s
}

type ListAllNodeResponseBody struct {
	// The zone ID of the node.
	//
	// example:
	//
	// 0D71B597-F3FF-5B56-88D7-74F9D3F7****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The CPU utilization.
	//
	// >  If the **extended*	- request parameter is set to **true*	- and the monitoring information of the nodes in the cluster is being synchronized, the value of the cpuPercent parameter is null. In this case, you need to send a request again after 10 seconds to obtain the value of the cpuPercent parameter.
	Result []*ListAllNodeResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListAllNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAllNodeResponseBody) GoString() string {
	return s.String()
}

func (s *ListAllNodeResponseBody) SetRequestId(v string) *ListAllNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAllNodeResponseBody) SetResult(v []*ListAllNodeResponseBodyResult) *ListAllNodeResponseBody {
	s.Result = v
	return s
}

type ListAllNodeResponseBodyResult struct {
	// The disk usage.
	//
	// example:
	//
	// 4.2%
	CpuPercent *string `json:"cpuPercent,omitempty" xml:"cpuPercent,omitempty"`
	// The health status of the node. Valid values: GREEN, YELLOW, RED, and GRAY.
	//
	// example:
	//
	// 1.0%
	DiskUsedPercent *string `json:"diskUsedPercent,omitempty" xml:"diskUsedPercent,omitempty"`
	// example:
	//
	// GREEN
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// The IP address of the node.
	//
	// example:
	//
	// 21.6%
	HeapPercent *string `json:"heapPercent,omitempty" xml:"heapPercent,omitempty"`
	// The port that is used to connect to the node.
	//
	// example:
	//
	// 10.15.XX.XX
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// example:
	//
	// 0.12
	LoadOneM *string `json:"loadOneM,omitempty" xml:"loadOneM,omitempty"`
	// The 1-minute load of the node.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
	// The type of the nodes. Valid values:
	//
	// 	- MASTER: dedicated master node
	//
	// 	- WORKER: hot node
	//
	// 	- WORKER_WARM: warm node
	//
	// 	- COORDINATING: client node
	//
	// 	- KIBANA: Kibana node
	//
	// example:
	//
	// cn-hangzhou-i
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s ListAllNodeResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListAllNodeResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListAllNodeResponseBodyResult) SetCpuPercent(v string) *ListAllNodeResponseBodyResult {
	s.CpuPercent = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetDiskUsedPercent(v string) *ListAllNodeResponseBodyResult {
	s.DiskUsedPercent = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetHealth(v string) *ListAllNodeResponseBodyResult {
	s.Health = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetHeapPercent(v string) *ListAllNodeResponseBodyResult {
	s.HeapPercent = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetHost(v string) *ListAllNodeResponseBodyResult {
	s.Host = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetLoadOneM(v string) *ListAllNodeResponseBodyResult {
	s.LoadOneM = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetNodeType(v string) *ListAllNodeResponseBodyResult {
	s.NodeType = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetPort(v int32) *ListAllNodeResponseBodyResult {
	s.Port = &v
	return s
}

func (s *ListAllNodeResponseBodyResult) SetZoneId(v string) *ListAllNodeResponseBodyResult {
	s.ZoneId = &v
	return s
}

type ListAllNodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAllNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAllNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAllNodeResponse) GoString() string {
	return s.String()
}

func (s *ListAllNodeResponse) SetHeaders(v map[string]*string) *ListAllNodeResponse {
	s.Headers = v
	return s
}

func (s *ListAllNodeResponse) SetStatusCode(v int32) *ListAllNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAllNodeResponse) SetBody(v *ListAllNodeResponseBody) *ListAllNodeResponse {
	s.Body = v
	return s
}

type ListAlternativeSnapshotReposRequest struct {
	// Indicates whether to return the OSS reference repository added. The return value. Valid values: true and false.
	//
	// example:
	//
	// true
	AlreadySetItems *bool `json:"alreadySetItems,omitempty" xml:"alreadySetItems,omitempty"`
}

func (s ListAlternativeSnapshotReposRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAlternativeSnapshotReposRequest) GoString() string {
	return s.String()
}

func (s *ListAlternativeSnapshotReposRequest) SetAlreadySetItems(v bool) *ListAlternativeSnapshotReposRequest {
	s.AlreadySetItems = &v
	return s
}

type ListAlternativeSnapshotReposResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result []*ListAlternativeSnapshotReposResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListAlternativeSnapshotReposResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAlternativeSnapshotReposResponseBody) GoString() string {
	return s.String()
}

func (s *ListAlternativeSnapshotReposResponseBody) SetRequestId(v string) *ListAlternativeSnapshotReposResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAlternativeSnapshotReposResponseBody) SetResult(v []*ListAlternativeSnapshotReposResponseBodyResult) *ListAlternativeSnapshotReposResponseBody {
	s.Result = v
	return s
}

type ListAlternativeSnapshotReposResponseBodyResult struct {
	// The ID of the instance.
	//
	// example:
	//
	// es-cn-6ja1ro4jt000c****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The address of the repository.
	//
	// example:
	//
	// RepoPath
	RepoPath *string `json:"repoPath,omitempty" xml:"repoPath,omitempty"`
}

func (s ListAlternativeSnapshotReposResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListAlternativeSnapshotReposResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListAlternativeSnapshotReposResponseBodyResult) SetInstanceId(v string) *ListAlternativeSnapshotReposResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListAlternativeSnapshotReposResponseBodyResult) SetRepoPath(v string) *ListAlternativeSnapshotReposResponseBodyResult {
	s.RepoPath = &v
	return s
}

type ListAlternativeSnapshotReposResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAlternativeSnapshotReposResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAlternativeSnapshotReposResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAlternativeSnapshotReposResponse) GoString() string {
	return s.String()
}

func (s *ListAlternativeSnapshotReposResponse) SetHeaders(v map[string]*string) *ListAlternativeSnapshotReposResponse {
	s.Headers = v
	return s
}

func (s *ListAlternativeSnapshotReposResponse) SetStatusCode(v int32) *ListAlternativeSnapshotReposResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAlternativeSnapshotReposResponse) SetBody(v *ListAlternativeSnapshotReposResponseBody) *ListAlternativeSnapshotReposResponse {
	s.Body = v
	return s
}

type ListApmRequest struct {
	// example:
	//
	// APMtest
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// apm-cn-i7m2fuae****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// es-cn-i7m2fsfhc001x****
	Output *string `json:"output,omitempty" xml:"output,omitempty"`
	// example:
	//
	// 1
	Page *int64 `json:"page,omitempty" xml:"page,omitempty"`
	// example:
	//
	// 10
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListApmRequest) String() string {
	return tea.Prettify(s)
}

func (s ListApmRequest) GoString() string {
	return s.String()
}

func (s *ListApmRequest) SetDescription(v string) *ListApmRequest {
	s.Description = &v
	return s
}

func (s *ListApmRequest) SetInstanceId(v string) *ListApmRequest {
	s.InstanceId = &v
	return s
}

func (s *ListApmRequest) SetOutput(v string) *ListApmRequest {
	s.Output = &v
	return s
}

func (s *ListApmRequest) SetPage(v int64) *ListApmRequest {
	s.Page = &v
	return s
}

func (s *ListApmRequest) SetSize(v int64) *ListApmRequest {
	s.Size = &v
	return s
}

type ListApmResponseBody struct {
	Headers *ListApmResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// example:
	//
	// 080D3399-76CF-519D-A540-2C44BC056EB7
	RequestId *string                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListApmResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListApmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListApmResponseBody) GoString() string {
	return s.String()
}

func (s *ListApmResponseBody) SetHeaders(v *ListApmResponseBodyHeaders) *ListApmResponseBody {
	s.Headers = v
	return s
}

func (s *ListApmResponseBody) SetRequestId(v string) *ListApmResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListApmResponseBody) SetResult(v []*ListApmResponseBodyResult) *ListApmResponseBody {
	s.Result = v
	return s
}

type ListApmResponseBodyHeaders struct {
	// example:
	//
	// 1
	XTotalCount *int64 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListApmResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListApmResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListApmResponseBodyHeaders) SetXTotalCount(v int64) *ListApmResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListApmResponseBodyResult struct {
	// example:
	//
	// 2021-11-16T07:15:51.967Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// example:
	//
	// 1
	DeployedReplica *int64 `json:"deployedReplica,omitempty" xml:"deployedReplica,omitempty"`
	// example:
	//
	// APMtest
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// apm-cn-i7m2fuae****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// 1
	NodeAmount *int64 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// example:
	//
	// es-cn-i7m2fsfhc001x****
	OutputES *string `json:"outputES,omitempty" xml:"outputES,omitempty"`
	// example:
	//
	// elastic
	OutputESUserName *string `json:"outputESUserName,omitempty" xml:"outputESUserName,omitempty"`
	// example:
	//
	// 133071096032****
	OwnerId *string `json:"ownerId,omitempty" xml:"ownerId,omitempty"`
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// example:
	//
	// cn-hangzhou
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// example:
	//
	// 1
	Replica *int64 `json:"replica,omitempty" xml:"replica,omitempty"`
	// example:
	//
	// C1M2
	ResourceSpec *string `json:"resourceSpec,omitempty" xml:"resourceSpec,omitempty"`
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// example:
	//
	// 7.10.2
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
	// example:
	//
	// vpc-bp1530vdhqkamm9s0****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// example:
	//
	// cn-hangzhou-i
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// example:
	//
	// vsw-bp1j1mql6r9g5vfb4****
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s ListApmResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListApmResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListApmResponseBodyResult) SetCreatedAt(v string) *ListApmResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *ListApmResponseBodyResult) SetDeployedReplica(v int64) *ListApmResponseBodyResult {
	s.DeployedReplica = &v
	return s
}

func (s *ListApmResponseBodyResult) SetDescription(v string) *ListApmResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListApmResponseBodyResult) SetInstanceId(v string) *ListApmResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListApmResponseBodyResult) SetNodeAmount(v int64) *ListApmResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *ListApmResponseBodyResult) SetOutputES(v string) *ListApmResponseBodyResult {
	s.OutputES = &v
	return s
}

func (s *ListApmResponseBodyResult) SetOutputESUserName(v string) *ListApmResponseBodyResult {
	s.OutputESUserName = &v
	return s
}

func (s *ListApmResponseBodyResult) SetOwnerId(v string) *ListApmResponseBodyResult {
	s.OwnerId = &v
	return s
}

func (s *ListApmResponseBodyResult) SetPaymentType(v string) *ListApmResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *ListApmResponseBodyResult) SetRegion(v string) *ListApmResponseBodyResult {
	s.Region = &v
	return s
}

func (s *ListApmResponseBodyResult) SetReplica(v int64) *ListApmResponseBodyResult {
	s.Replica = &v
	return s
}

func (s *ListApmResponseBodyResult) SetResourceSpec(v string) *ListApmResponseBodyResult {
	s.ResourceSpec = &v
	return s
}

func (s *ListApmResponseBodyResult) SetStatus(v string) *ListApmResponseBodyResult {
	s.Status = &v
	return s
}

func (s *ListApmResponseBodyResult) SetVersion(v string) *ListApmResponseBodyResult {
	s.Version = &v
	return s
}

func (s *ListApmResponseBodyResult) SetVpcId(v string) *ListApmResponseBodyResult {
	s.VpcId = &v
	return s
}

func (s *ListApmResponseBodyResult) SetVsArea(v string) *ListApmResponseBodyResult {
	s.VsArea = &v
	return s
}

func (s *ListApmResponseBodyResult) SetVswitchId(v string) *ListApmResponseBodyResult {
	s.VswitchId = &v
	return s
}

type ListApmResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListApmResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListApmResponse) String() string {
	return tea.Prettify(s)
}

func (s ListApmResponse) GoString() string {
	return s.String()
}

func (s *ListApmResponse) SetHeaders(v map[string]*string) *ListApmResponse {
	s.Headers = v
	return s
}

func (s *ListApmResponse) SetStatusCode(v int32) *ListApmResponse {
	s.StatusCode = &v
	return s
}

func (s *ListApmResponse) SetBody(v *ListApmResponseBody) *ListApmResponse {
	s.Body = v
	return s
}

type ListAvailableEsInstanceIdsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListAvailableEsInstanceIdsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListAvailableEsInstanceIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableEsInstanceIdsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAvailableEsInstanceIdsResponseBody) SetRequestId(v string) *ListAvailableEsInstanceIdsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAvailableEsInstanceIdsResponseBody) SetResult(v []*ListAvailableEsInstanceIdsResponseBodyResult) *ListAvailableEsInstanceIdsResponseBody {
	s.Result = v
	return s
}

type ListAvailableEsInstanceIdsResponseBodyResult struct {
	// The name of the Elasticsearch cluster.
	//
	// example:
	//
	// instanceName
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The address that is used to access the Elasticsearch cluster over the Internet.
	//
	// example:
	//
	// http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// The ID of the Elasticsearch cluster.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****
	EsInstanceId *string `json:"esInstanceId,omitempty" xml:"esInstanceId,omitempty"`
	// The address that is used to access the Kibana console of the Elasticsearch cluster over the Internet.
	//
	// example:
	//
	// https://es-cn-n6w1o1x0w001c****.kibana.elasticsearch.aliyuncs.com:5601
	KibanaEndpoint *string `json:"kibanaEndpoint,omitempty" xml:"kibanaEndpoint,omitempty"`
}

func (s ListAvailableEsInstanceIdsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableEsInstanceIdsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListAvailableEsInstanceIdsResponseBodyResult) SetDescription(v string) *ListAvailableEsInstanceIdsResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListAvailableEsInstanceIdsResponseBodyResult) SetEndpoint(v string) *ListAvailableEsInstanceIdsResponseBodyResult {
	s.Endpoint = &v
	return s
}

func (s *ListAvailableEsInstanceIdsResponseBodyResult) SetEsInstanceId(v string) *ListAvailableEsInstanceIdsResponseBodyResult {
	s.EsInstanceId = &v
	return s
}

func (s *ListAvailableEsInstanceIdsResponseBodyResult) SetKibanaEndpoint(v string) *ListAvailableEsInstanceIdsResponseBodyResult {
	s.KibanaEndpoint = &v
	return s
}

type ListAvailableEsInstanceIdsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAvailableEsInstanceIdsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAvailableEsInstanceIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableEsInstanceIdsResponse) GoString() string {
	return s.String()
}

func (s *ListAvailableEsInstanceIdsResponse) SetHeaders(v map[string]*string) *ListAvailableEsInstanceIdsResponse {
	s.Headers = v
	return s
}

func (s *ListAvailableEsInstanceIdsResponse) SetStatusCode(v int32) *ListAvailableEsInstanceIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAvailableEsInstanceIdsResponse) SetBody(v *ListAvailableEsInstanceIdsResponseBody) *ListAvailableEsInstanceIdsResponse {
	s.Body = v
	return s
}

type ListCollectorsRequest struct {
	// The ID of the resource with which the shipper is associated.
	//
	// example:
	//
	// es-cn-nif1q8auz0003****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The name of the shipper.
	//
	// example:
	//
	// collectorName1
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The number of the page to return. Valid values: 1 to 200. Default value: 1.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The ID of the shipper.
	//
	// example:
	//
	// ct-cn-77uqof2s7rg5c****
	ResId *string `json:"resId,omitempty" xml:"resId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 500. Default value: 20.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The type of the machine on which the shipper is deployed. If you leave this parameter empty, shippers deployed on all types of machines are returned. Valid values:
	//
	// 	- ECS
	//
	// 	- ACK
	//
	// example:
	//
	// ECS
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
}

func (s ListCollectorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsRequest) GoString() string {
	return s.String()
}

func (s *ListCollectorsRequest) SetInstanceId(v string) *ListCollectorsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListCollectorsRequest) SetName(v string) *ListCollectorsRequest {
	s.Name = &v
	return s
}

func (s *ListCollectorsRequest) SetPage(v int32) *ListCollectorsRequest {
	s.Page = &v
	return s
}

func (s *ListCollectorsRequest) SetResId(v string) *ListCollectorsRequest {
	s.ResId = &v
	return s
}

func (s *ListCollectorsRequest) SetSize(v int32) *ListCollectorsRequest {
	s.Size = &v
	return s
}

func (s *ListCollectorsRequest) SetSourceType(v string) *ListCollectorsRequest {
	s.SourceType = &v
	return s
}

type ListCollectorsResponseBody struct {
	// The header of the response.
	Headers *ListCollectorsResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListCollectorsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListCollectorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListCollectorsResponseBody) SetHeaders(v *ListCollectorsResponseBodyHeaders) *ListCollectorsResponseBody {
	s.Headers = v
	return s
}

func (s *ListCollectorsResponseBody) SetRequestId(v string) *ListCollectorsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCollectorsResponseBody) SetResult(v []*ListCollectorsResponseBodyResult) *ListCollectorsResponseBody {
	s.Result = v
	return s
}

type ListCollectorsResponseBodyHeaders struct {
	// The total number of entries returned.
	//
	// example:
	//
	// 5
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListCollectorsResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListCollectorsResponseBodyHeaders) SetXTotalCount(v int32) *ListCollectorsResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListCollectorsResponseBodyResult struct {
	CollectorPaths []*string `json:"collectorPaths,omitempty" xml:"collectorPaths,omitempty" type:"Repeated"`
	// The information about the configuration file of the shipper.
	Configs []*ListCollectorsResponseBodyResultConfigs `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// Indicates whether a dry run is performed. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
	// The extended configurations of the shipper.
	ExtendConfigs []*ListCollectorsResponseBodyResultExtendConfigs `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// The time when the shipper was created.
	//
	// example:
	//
	// 2020-08-18T02:06:12.000+0000
	GmtCreatedTime *string `json:"gmtCreatedTime,omitempty" xml:"gmtCreatedTime,omitempty"`
	// The time when the shipper was updated.
	//
	// example:
	//
	// 2020-08-18T09:40:43.000+0000
	GmtUpdateTime *string `json:"gmtUpdateTime,omitempty" xml:"gmtUpdateTime,omitempty"`
	// The name of the shipper.
	//
	// example:
	//
	// FileBeat001
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The account ID.
	//
	// example:
	//
	// 168520994880****
	OwnerId *string `json:"ownerId,omitempty" xml:"ownerId,omitempty"`
	// The ID of the shipper.
	//
	// example:
	//
	// ct-cn-0v3xj86085dvq****
	ResId *string `json:"resId,omitempty" xml:"resId,omitempty"`
	// The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.
	//
	// example:
	//
	// fileBeat
	ResType *string `json:"resType,omitempty" xml:"resType,omitempty"`
	// The version of the shipper.
	//
	// example:
	//
	// 6.8.5_with_community
	ResVersion *string `json:"resVersion,omitempty" xml:"resVersion,omitempty"`
	// The status of the shipper. Valid values:
	//
	// 	- activating
	//
	// 	- active
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The ID of the virtual private cloud (VPC) where the shipper resides.
	//
	// example:
	//
	// vpc-bp16k1dvzxtma*****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s ListCollectorsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListCollectorsResponseBodyResult) SetCollectorPaths(v []*string) *ListCollectorsResponseBodyResult {
	s.CollectorPaths = v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetConfigs(v []*ListCollectorsResponseBodyResultConfigs) *ListCollectorsResponseBodyResult {
	s.Configs = v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetDryRun(v bool) *ListCollectorsResponseBodyResult {
	s.DryRun = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetExtendConfigs(v []*ListCollectorsResponseBodyResultExtendConfigs) *ListCollectorsResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetGmtCreatedTime(v string) *ListCollectorsResponseBodyResult {
	s.GmtCreatedTime = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetGmtUpdateTime(v string) *ListCollectorsResponseBodyResult {
	s.GmtUpdateTime = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetName(v string) *ListCollectorsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetOwnerId(v string) *ListCollectorsResponseBodyResult {
	s.OwnerId = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetResId(v string) *ListCollectorsResponseBodyResult {
	s.ResId = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetResType(v string) *ListCollectorsResponseBodyResult {
	s.ResType = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetResVersion(v string) *ListCollectorsResponseBodyResult {
	s.ResVersion = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetStatus(v string) *ListCollectorsResponseBodyResult {
	s.Status = &v
	return s
}

func (s *ListCollectorsResponseBodyResult) SetVpcId(v string) *ListCollectorsResponseBodyResult {
	s.VpcId = &v
	return s
}

type ListCollectorsResponseBodyResultConfigs struct {
	// The content of the file.
	//
	// example:
	//
	// - key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// The name of the file.
	//
	// example:
	//
	// fields.yml
	FileName *string `json:"fileName,omitempty" xml:"fileName,omitempty"`
}

func (s ListCollectorsResponseBodyResultConfigs) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsResponseBodyResultConfigs) GoString() string {
	return s.String()
}

func (s *ListCollectorsResponseBodyResultConfigs) SetContent(v string) *ListCollectorsResponseBodyResultConfigs {
	s.Content = &v
	return s
}

func (s *ListCollectorsResponseBodyResultConfigs) SetFileName(v string) *ListCollectorsResponseBodyResultConfigs {
	s.FileName = &v
	return s
}

type ListCollectorsResponseBodyResultExtendConfigs struct {
	// The configuration type. Valid values:
	//
	// 	- collectorTargetInstance
	//
	// 	- collectorDeployMachine
	//
	// 	- collectorElasticsearchForKibana
	//
	// example:
	//
	// collectorDeployMachine
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// Indicates whether monitoring is enabled. This parameter is returned if the value of **configType*	- is **collectorTargetInstance*	- and the value of **instanceType*	- is **elasticsearch**. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" xml:"enableMonitoring,omitempty"`
	// The ID of the machine group. This parameter is returned if the value of **configType*	- is **collectorDeployMachine**.
	//
	// example:
	//
	// default_ct-cn-5i2l75bz4776****
	GroupId *string `json:"groupId,omitempty" xml:"groupId,omitempty"`
	// The internal endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType*	- is **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601
	Host  *string   `json:"host,omitempty" xml:"host,omitempty"`
	Hosts []*string `json:"hosts,omitempty" xml:"hosts,omitempty" type:"Repeated"`
	// The ID of the resource with which the shipper is associated. If the value of **configType*	- is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.
	//
	// example:
	//
	// es-cn-nif1z89fz003i****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// elasticsearch
	InstanceType *string `json:"instanceType,omitempty" xml:"instanceType,omitempty"`
	// The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType*	- is **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601
	KibanaHost *string `json:"kibanaHost,omitempty" xml:"kibanaHost,omitempty"`
	// The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ECSInstanceId**.
	Machines []*ListCollectorsResponseBodyResultExtendConfigsMachines `json:"machines,omitempty" xml:"machines,omitempty" type:"Repeated"`
	// The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ACKCluster**.
	//
	// example:
	//
	// 8
	SuccessPodsCount *string `json:"successPodsCount,omitempty" xml:"successPodsCount,omitempty"`
	// The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ACKCluster**.
	//
	// example:
	//
	// 10
	TotalPodsCount *string `json:"totalPodsCount,omitempty" xml:"totalPodsCount,omitempty"`
	// The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType*	- is **collectorDeployMachine**. Valid values:
	//
	// 	- ECSInstanceId
	//
	// 	- ACKCluster
	//
	// example:
	//
	// ECSInstanceId
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType*	- is **collectorTargetInstance*	- or **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s ListCollectorsResponseBodyResultExtendConfigs) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsResponseBodyResultExtendConfigs) GoString() string {
	return s.String()
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetConfigType(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.ConfigType = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetEnableMonitoring(v bool) *ListCollectorsResponseBodyResultExtendConfigs {
	s.EnableMonitoring = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetGroupId(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.GroupId = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetHost(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.Host = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetHosts(v []*string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.Hosts = v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetInstanceId(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.InstanceId = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetInstanceType(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.InstanceType = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetKibanaHost(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.KibanaHost = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetMachines(v []*ListCollectorsResponseBodyResultExtendConfigsMachines) *ListCollectorsResponseBodyResultExtendConfigs {
	s.Machines = v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetProtocol(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.Protocol = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetSuccessPodsCount(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.SuccessPodsCount = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetTotalPodsCount(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.TotalPodsCount = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetType(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.Type = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigs) SetUserName(v string) *ListCollectorsResponseBodyResultExtendConfigs {
	s.UserName = &v
	return s
}

type ListCollectorsResponseBodyResultExtendConfigsMachines struct {
	// The status of the shipper on the ECS instance. Valid values:
	//
	// 	- heartOk
	//
	// 	- heartLost
	//
	// 	- uninstalled
	//
	// 	- failed
	//
	// example:
	//
	// heartOk
	AgentStatus *string `json:"agentStatus,omitempty" xml:"agentStatus,omitempty"`
	// The IDs of the ECS instances.
	//
	// example:
	//
	// i-bp13y63575oypr9d****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
}

func (s ListCollectorsResponseBodyResultExtendConfigsMachines) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsResponseBodyResultExtendConfigsMachines) GoString() string {
	return s.String()
}

func (s *ListCollectorsResponseBodyResultExtendConfigsMachines) SetAgentStatus(v string) *ListCollectorsResponseBodyResultExtendConfigsMachines {
	s.AgentStatus = &v
	return s
}

func (s *ListCollectorsResponseBodyResultExtendConfigsMachines) SetInstanceId(v string) *ListCollectorsResponseBodyResultExtendConfigsMachines {
	s.InstanceId = &v
	return s
}

type ListCollectorsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListCollectorsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListCollectorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCollectorsResponse) GoString() string {
	return s.String()
}

func (s *ListCollectorsResponse) SetHeaders(v map[string]*string) *ListCollectorsResponse {
	s.Headers = v
	return s
}

func (s *ListCollectorsResponse) SetStatusCode(v int32) *ListCollectorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCollectorsResponse) SetBody(v *ListCollectorsResponseBody) *ListCollectorsResponse {
	s.Body = v
	return s
}

type ListComponentIndicesRequest struct {
	// example:
	//
	// template
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// if can be null:
	// true
	//
	// example:
	//
	// 5
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// if can be null:
	// true
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListComponentIndicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesRequest) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesRequest) SetName(v string) *ListComponentIndicesRequest {
	s.Name = &v
	return s
}

func (s *ListComponentIndicesRequest) SetPage(v int32) *ListComponentIndicesRequest {
	s.Page = &v
	return s
}

func (s *ListComponentIndicesRequest) SetSize(v int32) *ListComponentIndicesRequest {
	s.Size = &v
	return s
}

type ListComponentIndicesResponseBody struct {
	Headers *ListComponentIndicesResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListComponentIndicesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListComponentIndicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBody) SetHeaders(v *ListComponentIndicesResponseBodyHeaders) *ListComponentIndicesResponseBody {
	s.Headers = v
	return s
}

func (s *ListComponentIndicesResponseBody) SetRequestId(v string) *ListComponentIndicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListComponentIndicesResponseBody) SetResult(v []*ListComponentIndicesResponseBodyResult) *ListComponentIndicesResponseBody {
	s.Result = v
	return s
}

type ListComponentIndicesResponseBodyHeaders struct {
	// example:
	//
	// 10
	XTotalCount *int64 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListComponentIndicesResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBodyHeaders) SetXTotalCount(v int64) *ListComponentIndicesResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListComponentIndicesResponseBodyResult struct {
	Composed []*string                                      `json:"composed,omitempty" xml:"composed,omitempty" type:"Repeated"`
	Content  *ListComponentIndicesResponseBodyResultContent `json:"content,omitempty" xml:"content,omitempty" type:"Struct"`
	// example:
	//
	// synthetics-settings
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ListComponentIndicesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBodyResult) SetComposed(v []*string) *ListComponentIndicesResponseBodyResult {
	s.Composed = v
	return s
}

func (s *ListComponentIndicesResponseBodyResult) SetContent(v *ListComponentIndicesResponseBodyResultContent) *ListComponentIndicesResponseBodyResult {
	s.Content = v
	return s
}

func (s *ListComponentIndicesResponseBodyResult) SetName(v string) *ListComponentIndicesResponseBodyResult {
	s.Name = &v
	return s
}

type ListComponentIndicesResponseBodyResultContent struct {
	// example:
	//
	// { "description": "set number of shards to one" }
	Meta     map[string]interface{}                                 `json:"_meta,omitempty" xml:"_meta,omitempty"`
	Template *ListComponentIndicesResponseBodyResultContentTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
	// example:
	//
	// 0
	Version *int64 `json:"version,omitempty" xml:"version,omitempty"`
}

func (s ListComponentIndicesResponseBodyResultContent) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBodyResultContent) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBodyResultContent) SetMeta(v map[string]interface{}) *ListComponentIndicesResponseBodyResultContent {
	s.Meta = v
	return s
}

func (s *ListComponentIndicesResponseBodyResultContent) SetTemplate(v *ListComponentIndicesResponseBodyResultContentTemplate) *ListComponentIndicesResponseBodyResultContent {
	s.Template = v
	return s
}

func (s *ListComponentIndicesResponseBodyResultContent) SetVersion(v int64) *ListComponentIndicesResponseBodyResultContent {
	s.Version = &v
	return s
}

type ListComponentIndicesResponseBodyResultContentTemplate struct {
	Settings *ListComponentIndicesResponseBodyResultContentTemplateSettings `json:"settings,omitempty" xml:"settings,omitempty" type:"Struct"`
}

func (s ListComponentIndicesResponseBodyResultContentTemplate) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBodyResultContentTemplate) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBodyResultContentTemplate) SetSettings(v *ListComponentIndicesResponseBodyResultContentTemplateSettings) *ListComponentIndicesResponseBodyResultContentTemplate {
	s.Settings = v
	return s
}

type ListComponentIndicesResponseBodyResultContentTemplateSettings struct {
	Index *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex `json:"index,omitempty" xml:"index,omitempty" type:"Struct"`
}

func (s ListComponentIndicesResponseBodyResultContentTemplateSettings) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBodyResultContentTemplateSettings) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBodyResultContentTemplateSettings) SetIndex(v *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex) *ListComponentIndicesResponseBodyResultContentTemplateSettings {
	s.Index = v
	return s
}

type ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex struct {
	// example:
	//
	// best_compression
	Codec     *string                                                                      `json:"codec,omitempty" xml:"codec,omitempty"`
	Lifecycle *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle `json:"lifecycle,omitempty" xml:"lifecycle,omitempty" type:"Struct"`
}

func (s ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex) SetCodec(v string) *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex {
	s.Codec = &v
	return s
}

func (s *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex) SetLifecycle(v *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle) *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex {
	s.Lifecycle = v
	return s
}

type ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle struct {
	// example:
	//
	// synthetics
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle) SetName(v string) *ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle {
	s.Name = &v
	return s
}

type ListComponentIndicesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListComponentIndicesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListComponentIndicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListComponentIndicesResponse) GoString() string {
	return s.String()
}

func (s *ListComponentIndicesResponse) SetHeaders(v map[string]*string) *ListComponentIndicesResponse {
	s.Headers = v
	return s
}

func (s *ListComponentIndicesResponse) SetStatusCode(v int32) *ListComponentIndicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListComponentIndicesResponse) SetBody(v *ListComponentIndicesResponseBody) *ListComponentIndicesResponse {
	s.Body = v
	return s
}

type ListConnectedClustersResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result *ListConnectedClustersResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s ListConnectedClustersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConnectedClustersResponseBody) GoString() string {
	return s.String()
}

func (s *ListConnectedClustersResponseBody) SetRequestId(v string) *ListConnectedClustersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListConnectedClustersResponseBody) SetResult(v *ListConnectedClustersResponseBodyResult) *ListConnectedClustersResponseBody {
	s.Result = v
	return s
}

type ListConnectedClustersResponseBodyResult struct {
	Result []*ListConnectedClustersResponseBodyResultResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListConnectedClustersResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListConnectedClustersResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListConnectedClustersResponseBodyResult) SetResult(v []*ListConnectedClustersResponseBodyResultResult) *ListConnectedClustersResponseBodyResult {
	s.Result = v
	return s
}

type ListConnectedClustersResponseBodyResultResult struct {
	// The ID of the remote instance that is connected to the network of the current instance.
	//
	// example:
	//
	// es-cn-09k1rocex0006****
	Instances *string `json:"instances,omitempty" xml:"instances,omitempty"`
	// The network type of the instance.
	//
	// example:
	//
	// vpc
	NetworkType *string `json:"networkType,omitempty" xml:"networkType,omitempty"`
}

func (s ListConnectedClustersResponseBodyResultResult) String() string {
	return tea.Prettify(s)
}

func (s ListConnectedClustersResponseBodyResultResult) GoString() string {
	return s.String()
}

func (s *ListConnectedClustersResponseBodyResultResult) SetInstances(v string) *ListConnectedClustersResponseBodyResultResult {
	s.Instances = &v
	return s
}

func (s *ListConnectedClustersResponseBodyResultResult) SetNetworkType(v string) *ListConnectedClustersResponseBodyResultResult {
	s.NetworkType = &v
	return s
}

type ListConnectedClustersResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListConnectedClustersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListConnectedClustersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConnectedClustersResponse) GoString() string {
	return s.String()
}

func (s *ListConnectedClustersResponse) SetHeaders(v map[string]*string) *ListConnectedClustersResponse {
	s.Headers = v
	return s
}

func (s *ListConnectedClustersResponse) SetStatusCode(v int32) *ListConnectedClustersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConnectedClustersResponse) SetBody(v *ListConnectedClustersResponseBody) *ListConnectedClustersResponse {
	s.Body = v
	return s
}

type ListDataStreamsRequest struct {
	// example:
	//
	// false
	IsManaged *bool `json:"isManaged,omitempty" xml:"isManaged,omitempty"`
	// example:
	//
	// Log1
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ListDataStreamsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataStreamsRequest) GoString() string {
	return s.String()
}

func (s *ListDataStreamsRequest) SetIsManaged(v bool) *ListDataStreamsRequest {
	s.IsManaged = &v
	return s
}

func (s *ListDataStreamsRequest) SetName(v string) *ListDataStreamsRequest {
	s.Name = &v
	return s
}

type ListDataStreamsResponseBody struct {
	Headers *ListDataStreamsResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListDataStreamsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDataStreamsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataStreamsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataStreamsResponseBody) SetHeaders(v *ListDataStreamsResponseBodyHeaders) *ListDataStreamsResponseBody {
	s.Headers = v
	return s
}

func (s *ListDataStreamsResponseBody) SetRequestId(v string) *ListDataStreamsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataStreamsResponseBody) SetResult(v []*ListDataStreamsResponseBodyResult) *ListDataStreamsResponseBody {
	s.Result = v
	return s
}

type ListDataStreamsResponseBodyHeaders struct {
	// example:
	//
	// 100
	XManagedCount *int32 `json:"X-Managed-Count,omitempty" xml:"X-Managed-Count,omitempty"`
	// example:
	//
	// 143993923932990
	XManagedStorageSize *int64 `json:"X-Managed-StorageSize,omitempty" xml:"X-Managed-StorageSize,omitempty"`
}

func (s ListDataStreamsResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListDataStreamsResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListDataStreamsResponseBodyHeaders) SetXManagedCount(v int32) *ListDataStreamsResponseBodyHeaders {
	s.XManagedCount = &v
	return s
}

func (s *ListDataStreamsResponseBodyHeaders) SetXManagedStorageSize(v int64) *ListDataStreamsResponseBodyHeaders {
	s.XManagedStorageSize = &v
	return s
}

type ListDataStreamsResponseBodyResult struct {
	// example:
	//
	// Green
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// example:
	//
	// rollver1
	IlmPolicyName *string `json:"ilmPolicyName,omitempty" xml:"ilmPolicyName,omitempty"`
	// example:
	//
	// template1
	IndexTemplateName *string                                     `json:"indexTemplateName,omitempty" xml:"indexTemplateName,omitempty"`
	Indices           []*ListDataStreamsResponseBodyResultIndices `json:"indices,omitempty" xml:"indices,omitempty" type:"Repeated"`
	// example:
	//
	// 1788239393298
	ManagedStorageSize *int64 `json:"managedStorageSize,omitempty" xml:"managedStorageSize,omitempty"`
	// example:
	//
	// my-index-0001
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// 1788239393298
	TotalStorageSize *int64 `json:"totalStorageSize,omitempty" xml:"totalStorageSize,omitempty"`
}

func (s ListDataStreamsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDataStreamsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDataStreamsResponseBodyResult) SetHealth(v string) *ListDataStreamsResponseBodyResult {
	s.Health = &v
	return s
}

func (s *ListDataStreamsResponseBodyResult) SetIlmPolicyName(v string) *ListDataStreamsResponseBodyResult {
	s.IlmPolicyName = &v
	return s
}

func (s *ListDataStreamsResponseBodyResult) SetIndexTemplateName(v string) *ListDataStreamsResponseBodyResult {
	s.IndexTemplateName = &v
	return s
}

func (s *ListDataStreamsResponseBodyResult) SetIndices(v []*ListDataStreamsResponseBodyResultIndices) *ListDataStreamsResponseBodyResult {
	s.Indices = v
	return s
}

func (s *ListDataStreamsResponseBodyResult) SetManagedStorageSize(v int64) *ListDataStreamsResponseBodyResult {
	s.ManagedStorageSize = &v
	return s
}

func (s *ListDataStreamsResponseBodyResult) SetName(v string) *ListDataStreamsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListDataStreamsResponseBodyResult) SetTotalStorageSize(v int64) *ListDataStreamsResponseBodyResult {
	s.TotalStorageSize = &v
	return s
}

type ListDataStreamsResponseBodyResultIndices struct {
	// example:
	//
	// 2018-07-13T03:58:07.253Z
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// Green
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// example:
	//
	// false
	IsManaged *bool `json:"isManaged,omitempty" xml:"isManaged,omitempty"`
	// example:
	//
	// following
	ManagedStatus *string `json:"managedStatus,omitempty" xml:"managedStatus,omitempty"`
	// example:
	//
	// Log1
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// 15393899
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListDataStreamsResponseBodyResultIndices) String() string {
	return tea.Prettify(s)
}

func (s ListDataStreamsResponseBodyResultIndices) GoString() string {
	return s.String()
}

func (s *ListDataStreamsResponseBodyResultIndices) SetCreateTime(v string) *ListDataStreamsResponseBodyResultIndices {
	s.CreateTime = &v
	return s
}

func (s *ListDataStreamsResponseBodyResultIndices) SetHealth(v string) *ListDataStreamsResponseBodyResultIndices {
	s.Health = &v
	return s
}

func (s *ListDataStreamsResponseBodyResultIndices) SetIsManaged(v bool) *ListDataStreamsResponseBodyResultIndices {
	s.IsManaged = &v
	return s
}

func (s *ListDataStreamsResponseBodyResultIndices) SetManagedStatus(v string) *ListDataStreamsResponseBodyResultIndices {
	s.ManagedStatus = &v
	return s
}

func (s *ListDataStreamsResponseBodyResultIndices) SetName(v string) *ListDataStreamsResponseBodyResultIndices {
	s.Name = &v
	return s
}

func (s *ListDataStreamsResponseBodyResultIndices) SetSize(v int64) *ListDataStreamsResponseBodyResultIndices {
	s.Size = &v
	return s
}

type ListDataStreamsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataStreamsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataStreamsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataStreamsResponse) GoString() string {
	return s.String()
}

func (s *ListDataStreamsResponse) SetHeaders(v map[string]*string) *ListDataStreamsResponse {
	s.Headers = v
	return s
}

func (s *ListDataStreamsResponse) SetStatusCode(v int32) *ListDataStreamsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataStreamsResponse) SetBody(v *ListDataStreamsResponseBody) *ListDataStreamsResponse {
	s.Body = v
	return s
}

type ListDataTasksResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result []*ListDataTasksResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDataTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataTasksResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataTasksResponseBody) SetRequestId(v string) *ListDataTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataTasksResponseBody) SetResult(v []*ListDataTasksResponseBodyResult) *ListDataTasksResponseBody {
	s.Result = v
	return s
}

type ListDataTasksResponseBodyResult struct {
	// The time when the site monitoring task was created.
	//
	// example:
	//
	// 2020-07-30 06:32:18
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// The information of the target cluster.
	SinkCluster *ListDataTasksResponseBodyResultSinkCluster `json:"sinkCluster,omitempty" xml:"sinkCluster,omitempty" type:"Struct"`
	// The information about the source cluster.
	SourceCluster *ListDataTasksResponseBodyResultSourceCluster `json:"sourceCluster,omitempty" xml:"sourceCluster,omitempty" type:"Struct"`
	// The status of the task.
	//
	// example:
	//
	// SUCCESS
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The ID of the task.
	//
	// example:
	//
	// et_cn_mfv1233r47272****
	TaskId *string `json:"taskId,omitempty" xml:"taskId,omitempty"`
}

func (s ListDataTasksResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDataTasksResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDataTasksResponseBodyResult) SetCreateTime(v string) *ListDataTasksResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *ListDataTasksResponseBodyResult) SetSinkCluster(v *ListDataTasksResponseBodyResultSinkCluster) *ListDataTasksResponseBodyResult {
	s.SinkCluster = v
	return s
}

func (s *ListDataTasksResponseBodyResult) SetSourceCluster(v *ListDataTasksResponseBodyResultSourceCluster) *ListDataTasksResponseBodyResult {
	s.SourceCluster = v
	return s
}

func (s *ListDataTasksResponseBodyResult) SetStatus(v string) *ListDataTasksResponseBodyResult {
	s.Status = &v
	return s
}

func (s *ListDataTasksResponseBodyResult) SetTaskId(v string) *ListDataTasksResponseBodyResult {
	s.TaskId = &v
	return s
}

type ListDataTasksResponseBodyResultSinkCluster struct {
	// The type of the target cluster. Default value: elasticsearch.
	//
	// example:
	//
	// 1
	DataSourceType *string `json:"dataSourceType,omitempty" xml:"dataSourceType,omitempty"`
	// The public network access address of the target cluster.
	//
	// example:
	//
	// http://192.168.xx.xx:4101
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// The target index.
	//
	// example:
	//
	// product_info
	Index *string `json:"index,omitempty" xml:"index,omitempty"`
	// The type of the destination index.
	//
	// example:
	//
	// _doc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The ID of the VPC to which the cluster belongs.
	//
	// example:
	//
	// vpc-2ze55voww95g82gak****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// The instance ID or Server Load Balancer (SLB) ID of the current cluster.
	//
	// example:
	//
	// es-cn-09k1rnu3g0002****-worker
	VpcInstanceId *string `json:"vpcInstanceId,omitempty" xml:"vpcInstanceId,omitempty"`
	// The access port number of the cluster.
	//
	// example:
	//
	// 9200
	VpcInstancePort *string `json:"vpcInstancePort,omitempty" xml:"vpcInstancePort,omitempty"`
}

func (s ListDataTasksResponseBodyResultSinkCluster) String() string {
	return tea.Prettify(s)
}

func (s ListDataTasksResponseBodyResultSinkCluster) GoString() string {
	return s.String()
}

func (s *ListDataTasksResponseBodyResultSinkCluster) SetDataSourceType(v string) *ListDataTasksResponseBodyResultSinkCluster {
	s.DataSourceType = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSinkCluster) SetEndpoint(v string) *ListDataTasksResponseBodyResultSinkCluster {
	s.Endpoint = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSinkCluster) SetIndex(v string) *ListDataTasksResponseBodyResultSinkCluster {
	s.Index = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSinkCluster) SetType(v string) *ListDataTasksResponseBodyResultSinkCluster {
	s.Type = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSinkCluster) SetVpcId(v string) *ListDataTasksResponseBodyResultSinkCluster {
	s.VpcId = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSinkCluster) SetVpcInstanceId(v string) *ListDataTasksResponseBodyResultSinkCluster {
	s.VpcInstanceId = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSinkCluster) SetVpcInstancePort(v string) *ListDataTasksResponseBodyResultSinkCluster {
	s.VpcInstancePort = &v
	return s
}

type ListDataTasksResponseBodyResultSourceCluster struct {
	// The type of the source cluster. Default value: elasticsearch.
	//
	// example:
	//
	// 1
	DataSourceType *string `json:"dataSourceType,omitempty" xml:"dataSourceType,omitempty"`
	// The index whose data you want to migrate.
	//
	// example:
	//
	// product_info
	Index *string `json:"index,omitempty" xml:"index,omitempty"`
	// The Mapping configuration of the cluster.
	//
	// example:
	//
	// {\\"_doc\\":{\\"properties\\":{\\"user\\":{\\"properties\\":{\\"last\\":{\\"type\\":\\"text\\",...}}}}}}
	Mapping *string `json:"mapping,omitempty" xml:"mapping,omitempty"`
	// The routing field to index the table. It is set to the primary key by default.
	//
	// example:
	//
	// _id
	Routing *string `json:"routing,omitempty" xml:"routing,omitempty"`
	// The Settings of the cluster.
	//
	// example:
	//
	// {\\n  \\"index\\": {\\n    \\"replication\\": {\\n}.....}}
	Settings *string `json:"settings,omitempty" xml:"settings,omitempty"`
	// The type of the destination index.
	//
	// example:
	//
	// _doc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListDataTasksResponseBodyResultSourceCluster) String() string {
	return tea.Prettify(s)
}

func (s ListDataTasksResponseBodyResultSourceCluster) GoString() string {
	return s.String()
}

func (s *ListDataTasksResponseBodyResultSourceCluster) SetDataSourceType(v string) *ListDataTasksResponseBodyResultSourceCluster {
	s.DataSourceType = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSourceCluster) SetIndex(v string) *ListDataTasksResponseBodyResultSourceCluster {
	s.Index = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSourceCluster) SetMapping(v string) *ListDataTasksResponseBodyResultSourceCluster {
	s.Mapping = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSourceCluster) SetRouting(v string) *ListDataTasksResponseBodyResultSourceCluster {
	s.Routing = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSourceCluster) SetSettings(v string) *ListDataTasksResponseBodyResultSourceCluster {
	s.Settings = &v
	return s
}

func (s *ListDataTasksResponseBodyResultSourceCluster) SetType(v string) *ListDataTasksResponseBodyResultSourceCluster {
	s.Type = &v
	return s
}

type ListDataTasksResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataTasksResponse) GoString() string {
	return s.String()
}

func (s *ListDataTasksResponse) SetHeaders(v map[string]*string) *ListDataTasksResponse {
	s.Headers = v
	return s
}

func (s *ListDataTasksResponse) SetStatusCode(v int32) *ListDataTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataTasksResponse) SetBody(v *ListDataTasksResponseBody) *ListDataTasksResponse {
	s.Body = v
	return s
}

type ListDefaultCollectorConfigurationsRequest struct {
	// The shipper type. Valid values:
	//
	// 	- fileBeat
	//
	// 	- metricBeat
	//
	// 	- heartBeat
	//
	// 	- auditBeat
	//
	// This parameter is required.
	//
	// example:
	//
	// fileBeat
	ResType *string `json:"resType,omitempty" xml:"resType,omitempty"`
	// The shipper version. The shipper version varies based on the type of the machine on which the shipper is deployed. Valid values:
	//
	// 	- ECS: 6.8.5_with_community
	//
	// 	- ACK: 6.8.13_with_community
	//
	// This parameter is required.
	//
	// example:
	//
	// 6.8.5_with_community
	ResVersion *string `json:"resVersion,omitempty" xml:"resVersion,omitempty"`
	// The type of the machine on which the shipper is deployed. If you do not configure this parameter, the default configuration files of shippers deployed on all types of machines are returned. Valid values:
	//
	// 	- ECS: ECS instance
	//
	// 	- ACK: ACK cluster
	//
	// example:
	//
	// ECS
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
}

func (s ListDefaultCollectorConfigurationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultCollectorConfigurationsRequest) GoString() string {
	return s.String()
}

func (s *ListDefaultCollectorConfigurationsRequest) SetResType(v string) *ListDefaultCollectorConfigurationsRequest {
	s.ResType = &v
	return s
}

func (s *ListDefaultCollectorConfigurationsRequest) SetResVersion(v string) *ListDefaultCollectorConfigurationsRequest {
	s.ResVersion = &v
	return s
}

func (s *ListDefaultCollectorConfigurationsRequest) SetSourceType(v string) *ListDefaultCollectorConfigurationsRequest {
	s.SourceType = &v
	return s
}

type ListDefaultCollectorConfigurationsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 8BAE3C32-8E4A-47D6-B4B0-95B5DE643BF5
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListDefaultCollectorConfigurationsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDefaultCollectorConfigurationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultCollectorConfigurationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDefaultCollectorConfigurationsResponseBody) SetRequestId(v string) *ListDefaultCollectorConfigurationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDefaultCollectorConfigurationsResponseBody) SetResult(v []*ListDefaultCollectorConfigurationsResponseBodyResult) *ListDefaultCollectorConfigurationsResponseBody {
	s.Result = v
	return s
}

type ListDefaultCollectorConfigurationsResponseBodyResult struct {
	// The content of the configuration file.
	//
	// example:
	//
	// - key: log\\n  title: Log file content\\n  description: >\\n    Contains log file lines.\\n  fields:\\n ......
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// The name of the configuration file.
	//
	// example:
	//
	// fields.yml
	FileName *string `json:"fileName,omitempty" xml:"fileName,omitempty"`
}

func (s ListDefaultCollectorConfigurationsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultCollectorConfigurationsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDefaultCollectorConfigurationsResponseBodyResult) SetContent(v string) *ListDefaultCollectorConfigurationsResponseBodyResult {
	s.Content = &v
	return s
}

func (s *ListDefaultCollectorConfigurationsResponseBodyResult) SetFileName(v string) *ListDefaultCollectorConfigurationsResponseBodyResult {
	s.FileName = &v
	return s
}

type ListDefaultCollectorConfigurationsResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDefaultCollectorConfigurationsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDefaultCollectorConfigurationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultCollectorConfigurationsResponse) GoString() string {
	return s.String()
}

func (s *ListDefaultCollectorConfigurationsResponse) SetHeaders(v map[string]*string) *ListDefaultCollectorConfigurationsResponse {
	s.Headers = v
	return s
}

func (s *ListDefaultCollectorConfigurationsResponse) SetStatusCode(v int32) *ListDefaultCollectorConfigurationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDefaultCollectorConfigurationsResponse) SetBody(v *ListDefaultCollectorConfigurationsResponseBody) *ListDefaultCollectorConfigurationsResponse {
	s.Body = v
	return s
}

type ListDeprecatedTemplatesRequest struct {
	// example:
	//
	// component-openstore-index-template
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// 5
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// if can be null:
	// true
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListDeprecatedTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDeprecatedTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListDeprecatedTemplatesRequest) SetName(v string) *ListDeprecatedTemplatesRequest {
	s.Name = &v
	return s
}

func (s *ListDeprecatedTemplatesRequest) SetPage(v int32) *ListDeprecatedTemplatesRequest {
	s.Page = &v
	return s
}

func (s *ListDeprecatedTemplatesRequest) SetSize(v int32) *ListDeprecatedTemplatesRequest {
	s.Size = &v
	return s
}

type ListDeprecatedTemplatesResponseBody struct {
	Headers *ListDeprecatedTemplatesResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListDeprecatedTemplatesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDeprecatedTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDeprecatedTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDeprecatedTemplatesResponseBody) SetHeaders(v *ListDeprecatedTemplatesResponseBodyHeaders) *ListDeprecatedTemplatesResponseBody {
	s.Headers = v
	return s
}

func (s *ListDeprecatedTemplatesResponseBody) SetRequestId(v string) *ListDeprecatedTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDeprecatedTemplatesResponseBody) SetResult(v []*ListDeprecatedTemplatesResponseBodyResult) *ListDeprecatedTemplatesResponseBody {
	s.Result = v
	return s
}

type ListDeprecatedTemplatesResponseBodyHeaders struct {
	// example:
	//
	// 5
	XTotalCount *int64 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListDeprecatedTemplatesResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListDeprecatedTemplatesResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListDeprecatedTemplatesResponseBodyHeaders) SetXTotalCount(v int64) *ListDeprecatedTemplatesResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListDeprecatedTemplatesResponseBodyResult struct {
	// example:
	//
	// false
	DataStream    *bool     `json:"dataStream,omitempty" xml:"dataStream,omitempty"`
	IndexPatterns []*string `json:"indexPatterns,omitempty" xml:"indexPatterns,omitempty" type:"Repeated"`
	// example:
	//
	// openstore-index-template
	IndexTemplate *string `json:"indexTemplate,omitempty" xml:"indexTemplate,omitempty"`
	// example:
	//
	// 100
	Order    *int64                                             `json:"order,omitempty" xml:"order,omitempty"`
	Template *ListDeprecatedTemplatesResponseBodyResultTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
	// example:
	//
	// 70000
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s ListDeprecatedTemplatesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDeprecatedTemplatesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDeprecatedTemplatesResponseBodyResult) SetDataStream(v bool) *ListDeprecatedTemplatesResponseBodyResult {
	s.DataStream = &v
	return s
}

func (s *ListDeprecatedTemplatesResponseBodyResult) SetIndexPatterns(v []*string) *ListDeprecatedTemplatesResponseBodyResult {
	s.IndexPatterns = v
	return s
}

func (s *ListDeprecatedTemplatesResponseBodyResult) SetIndexTemplate(v string) *ListDeprecatedTemplatesResponseBodyResult {
	s.IndexTemplate = &v
	return s
}

func (s *ListDeprecatedTemplatesResponseBodyResult) SetOrder(v int64) *ListDeprecatedTemplatesResponseBodyResult {
	s.Order = &v
	return s
}

func (s *ListDeprecatedTemplatesResponseBodyResult) SetTemplate(v *ListDeprecatedTemplatesResponseBodyResultTemplate) *ListDeprecatedTemplatesResponseBodyResult {
	s.Template = v
	return s
}

func (s *ListDeprecatedTemplatesResponseBodyResult) SetVersion(v string) *ListDeprecatedTemplatesResponseBodyResult {
	s.Version = &v
	return s
}

type ListDeprecatedTemplatesResponseBodyResultTemplate struct {
	// example:
	//
	// "{}"
	Aliases *string `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// "{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}"
	Mappings *string `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// "{\\"index.number_of_shards\\":\\"1\\"}"
	Settings *string `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s ListDeprecatedTemplatesResponseBodyResultTemplate) String() string {
	return tea.Prettify(s)
}

func (s ListDeprecatedTemplatesResponseBodyResultTemplate) GoString() string {
	return s.String()
}

func (s *ListDeprecatedTemplatesResponseBodyResultTemplate) SetAliases(v string) *ListDeprecatedTemplatesResponseBodyResultTemplate {
	s.Aliases = &v
	return s
}

func (s *ListDeprecatedTemplatesResponseBodyResultTemplate) SetMappings(v string) *ListDeprecatedTemplatesResponseBodyResultTemplate {
	s.Mappings = &v
	return s
}

func (s *ListDeprecatedTemplatesResponseBodyResultTemplate) SetSettings(v string) *ListDeprecatedTemplatesResponseBodyResultTemplate {
	s.Settings = &v
	return s
}

type ListDeprecatedTemplatesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDeprecatedTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDeprecatedTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDeprecatedTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListDeprecatedTemplatesResponse) SetHeaders(v map[string]*string) *ListDeprecatedTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListDeprecatedTemplatesResponse) SetStatusCode(v int32) *ListDeprecatedTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDeprecatedTemplatesResponse) SetBody(v *ListDeprecatedTemplatesResponseBody) *ListDeprecatedTemplatesResponse {
	s.Body = v
	return s
}

type ListDiagnoseIndicesRequest struct {
	// The language. Multiple languages are supported.
	//
	// example:
	//
	// en
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s ListDiagnoseIndicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseIndicesRequest) GoString() string {
	return s.String()
}

func (s *ListDiagnoseIndicesRequest) SetLang(v string) *ListDiagnoseIndicesRequest {
	s.Lang = &v
	return s
}

type ListDiagnoseIndicesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// F05ED12E-140A-4ACB-B059-3A508A69F2E1
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDiagnoseIndicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseIndicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDiagnoseIndicesResponseBody) SetRequestId(v string) *ListDiagnoseIndicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDiagnoseIndicesResponseBody) SetResult(v []*string) *ListDiagnoseIndicesResponseBody {
	s.Result = v
	return s
}

type ListDiagnoseIndicesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDiagnoseIndicesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDiagnoseIndicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseIndicesResponse) GoString() string {
	return s.String()
}

func (s *ListDiagnoseIndicesResponse) SetHeaders(v map[string]*string) *ListDiagnoseIndicesResponse {
	s.Headers = v
	return s
}

func (s *ListDiagnoseIndicesResponse) SetStatusCode(v int32) *ListDiagnoseIndicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDiagnoseIndicesResponse) SetBody(v *ListDiagnoseIndicesResponseBody) *ListDiagnoseIndicesResponse {
	s.Body = v
	return s
}

type ListDiagnoseReportRequest struct {
	// SYSTEM
	//
	// example:
	//
	// true
	Detail *bool `json:"detail,omitempty" xml:"detail,omitempty"`
	// 1
	//
	// This parameter is required.
	//
	// example:
	//
	// 1595174399999
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// 1594569600000
	//
	// example:
	//
	// spanish
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
	// 20
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// true
	//
	// example:
	//
	// 20
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// 1595174399999
	//
	// This parameter is required.
	//
	// example:
	//
	// 1594569600000
	StartTime *int64 `json:"startTime,omitempty" xml:"startTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// SYSTEM
	Trigger *string `json:"trigger,omitempty" xml:"trigger,omitempty"`
}

func (s ListDiagnoseReportRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportRequest) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportRequest) SetDetail(v bool) *ListDiagnoseReportRequest {
	s.Detail = &v
	return s
}

func (s *ListDiagnoseReportRequest) SetEndTime(v int64) *ListDiagnoseReportRequest {
	s.EndTime = &v
	return s
}

func (s *ListDiagnoseReportRequest) SetLang(v string) *ListDiagnoseReportRequest {
	s.Lang = &v
	return s
}

func (s *ListDiagnoseReportRequest) SetPage(v int32) *ListDiagnoseReportRequest {
	s.Page = &v
	return s
}

func (s *ListDiagnoseReportRequest) SetSize(v int32) *ListDiagnoseReportRequest {
	s.Size = &v
	return s
}

func (s *ListDiagnoseReportRequest) SetStartTime(v int64) *ListDiagnoseReportRequest {
	s.StartTime = &v
	return s
}

func (s *ListDiagnoseReportRequest) SetTrigger(v string) *ListDiagnoseReportRequest {
	s.Trigger = &v
	return s
}

type ListDiagnoseReportResponseBody struct {
	// The total number of entries returned.
	Headers *ListDiagnoseReportResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The header of the response.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The trigger mode of health diagnostics. Valid values:
	//
	// 	- SYSTEM: The system is automatically triggered.
	//
	// 	- INNER: internal trigger
	//
	// 	- USER: manually triggered by the user
	Result []*ListDiagnoseReportResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDiagnoseReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportResponseBody) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportResponseBody) SetHeaders(v *ListDiagnoseReportResponseBodyHeaders) *ListDiagnoseReportResponseBody {
	s.Headers = v
	return s
}

func (s *ListDiagnoseReportResponseBody) SetRequestId(v string) *ListDiagnoseReportResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDiagnoseReportResponseBody) SetResult(v []*ListDiagnoseReportResponseBodyResult) *ListDiagnoseReportResponseBody {
	s.Result = v
	return s
}

type ListDiagnoseReportResponseBodyHeaders struct {
	// The returned results.
	//
	// example:
	//
	// 15
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListDiagnoseReportResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportResponseBodyHeaders) SetXTotalCount(v int32) *ListDiagnoseReportResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListDiagnoseReportResponseBodyResult struct {
	// The ID of the report.
	//
	// example:
	//
	// 1535745731000
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// The name of the item.
	DiagnoseItems []*ListDiagnoseReportResponseBodyResultDiagnoseItems `json:"diagnoseItems,omitempty" xml:"diagnoseItems,omitempty" type:"Repeated"`
	// Reports the list of diagnostic item information.
	//
	// example:
	//
	// YELLOW
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// The overall health of the cluster in the report. Supported: GREEN, YELLOW, RED, and UNKNOWN.
	//
	// example:
	//
	// es-cn-abc
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.
	//
	// example:
	//
	// trigger__2020-08-17T17:09:02f
	ReportId *string `json:"reportId,omitempty" xml:"reportId,omitempty"`
	// The ID of the instance for diagnosis.
	//
	// example:
	//
	// SUCCESS
	State *string `json:"state,omitempty" xml:"state,omitempty"`
	// The timestamp when the report was created.
	//
	// example:
	//
	// USER
	Trigger *string `json:"trigger,omitempty" xml:"trigger,omitempty"`
}

func (s ListDiagnoseReportResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportResponseBodyResult) SetCreateTime(v int64) *ListDiagnoseReportResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResult) SetDiagnoseItems(v []*ListDiagnoseReportResponseBodyResultDiagnoseItems) *ListDiagnoseReportResponseBodyResult {
	s.DiagnoseItems = v
	return s
}

func (s *ListDiagnoseReportResponseBodyResult) SetHealth(v string) *ListDiagnoseReportResponseBodyResult {
	s.Health = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResult) SetInstanceId(v string) *ListDiagnoseReportResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResult) SetReportId(v string) *ListDiagnoseReportResponseBodyResult {
	s.ReportId = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResult) SetState(v string) *ListDiagnoseReportResponseBodyResult {
	s.State = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResult) SetTrigger(v string) *ListDiagnoseReportResponseBodyResult {
	s.Trigger = &v
	return s
}

type ListDiagnoseReportResponseBodyResultDiagnoseItems struct {
	// The type of the diagnostic result. Valid values:
	//
	// 	- TEXT: text description
	//
	// 	- CONSOLE_API: console-triggered
	//
	// 	- ES_API: API triggered
	Detail *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail `json:"detail,omitempty" xml:"detail,omitempty" type:"Struct"`
	// The details of the diagnostic item.
	//
	// example:
	//
	// YELLOW
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// The health of the diagnostic item. Supported: GREEN, YELLOW, RED, and UNKNOWN.
	//
	// example:
	//
	// IndexAliasUseDiagnostic
	Item *string `json:"item,omitempty" xml:"item,omitempty"`
}

func (s ListDiagnoseReportResponseBodyResultDiagnoseItems) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportResponseBodyResultDiagnoseItems) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItems) SetDetail(v *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) *ListDiagnoseReportResponseBodyResultDiagnoseItems {
	s.Detail = v
	return s
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItems) SetHealth(v string) *ListDiagnoseReportResponseBodyResultDiagnoseItems {
	s.Health = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItems) SetItem(v string) *ListDiagnoseReportResponseBodyResultDiagnoseItems {
	s.Item = &v
	return s
}

type ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail struct {
	// The diagnosis.
	//
	// example:
	//
	// Check whether the number of replica shards is optimal and easy to maintain
	Desc *string `json:"desc,omitempty" xml:"desc,omitempty"`
	// The description of the diagnostic item.
	//
	// example:
	//
	// Number of Replica Shards
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The suggestion for the diagnosis.
	//
	// example:
	//
	// You may need to adjust the numbers of replica shards of some indices as follows:  [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]
	Result *string `json:"result,omitempty" xml:"result,omitempty"`
	// example:
	//
	// You can call the following function in the Elasticsearch API....
	Suggest *string `json:"suggest,omitempty" xml:"suggest,omitempty"`
	// The full name of the diagnostic item.
	//
	// example:
	//
	// ES_API
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetDesc(v string) *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Desc = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetName(v string) *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Name = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetResult(v string) *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Result = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetSuggest(v string) *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Suggest = &v
	return s
}

func (s *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail) SetType(v string) *ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail {
	s.Type = &v
	return s
}

type ListDiagnoseReportResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDiagnoseReportResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDiagnoseReportResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportResponse) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportResponse) SetHeaders(v map[string]*string) *ListDiagnoseReportResponse {
	s.Headers = v
	return s
}

func (s *ListDiagnoseReportResponse) SetStatusCode(v int32) *ListDiagnoseReportResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDiagnoseReportResponse) SetBody(v *ListDiagnoseReportResponseBody) *ListDiagnoseReportResponse {
	s.Body = v
	return s
}

type ListDiagnoseReportIdsRequest struct {
	// The end of the time range to query. The value must be a UNIX timestamp.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1595174399999
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// The language of the reports.
	//
	// example:
	//
	// spanish
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
	// The number of the page to return. Valid values: 1 to 200. Default value: 1.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 500. Default value: 10.
	//
	// example:
	//
	// 15
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The beginning of the time range to query. The value must be a UNIX timestamp.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1595088000000
	StartTime *int64 `json:"startTime,omitempty" xml:"startTime,omitempty"`
	// The method that is used to trigger health diagnostics. Valid values: SYSTEM, INNER, and USER.
	//
	// example:
	//
	// SYSTEM
	Trigger *string `json:"trigger,omitempty" xml:"trigger,omitempty"`
}

func (s ListDiagnoseReportIdsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportIdsRequest) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportIdsRequest) SetEndTime(v int64) *ListDiagnoseReportIdsRequest {
	s.EndTime = &v
	return s
}

func (s *ListDiagnoseReportIdsRequest) SetLang(v string) *ListDiagnoseReportIdsRequest {
	s.Lang = &v
	return s
}

func (s *ListDiagnoseReportIdsRequest) SetPage(v int32) *ListDiagnoseReportIdsRequest {
	s.Page = &v
	return s
}

func (s *ListDiagnoseReportIdsRequest) SetSize(v int32) *ListDiagnoseReportIdsRequest {
	s.Size = &v
	return s
}

func (s *ListDiagnoseReportIdsRequest) SetStartTime(v int64) *ListDiagnoseReportIdsRequest {
	s.StartTime = &v
	return s
}

func (s *ListDiagnoseReportIdsRequest) SetTrigger(v string) *ListDiagnoseReportIdsRequest {
	s.Trigger = &v
	return s
}

type ListDiagnoseReportIdsResponseBody struct {
	// The header of the response.
	Headers *ListDiagnoseReportIdsResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDiagnoseReportIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportIdsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportIdsResponseBody) SetHeaders(v *ListDiagnoseReportIdsResponseBodyHeaders) *ListDiagnoseReportIdsResponseBody {
	s.Headers = v
	return s
}

func (s *ListDiagnoseReportIdsResponseBody) SetRequestId(v string) *ListDiagnoseReportIdsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDiagnoseReportIdsResponseBody) SetResult(v []*string) *ListDiagnoseReportIdsResponseBody {
	s.Result = v
	return s
}

type ListDiagnoseReportIdsResponseBodyHeaders struct {
	// The total number of entries returned.
	//
	// example:
	//
	// 1
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListDiagnoseReportIdsResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportIdsResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportIdsResponseBodyHeaders) SetXTotalCount(v int32) *ListDiagnoseReportIdsResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListDiagnoseReportIdsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDiagnoseReportIdsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDiagnoseReportIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnoseReportIdsResponse) GoString() string {
	return s.String()
}

func (s *ListDiagnoseReportIdsResponse) SetHeaders(v map[string]*string) *ListDiagnoseReportIdsResponse {
	s.Headers = v
	return s
}

func (s *ListDiagnoseReportIdsResponse) SetStatusCode(v int32) *ListDiagnoseReportIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDiagnoseReportIdsResponse) SetBody(v *ListDiagnoseReportIdsResponseBody) *ListDiagnoseReportIdsResponse {
	s.Body = v
	return s
}

type ListDiagnosisItemsRequest struct {
	// example:
	//
	// en
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s ListDiagnosisItemsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnosisItemsRequest) GoString() string {
	return s.String()
}

func (s *ListDiagnosisItemsRequest) SetLang(v string) *ListDiagnosisItemsRequest {
	s.Lang = &v
	return s
}

type ListDiagnosisItemsResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListDiagnosisItemsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDiagnosisItemsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnosisItemsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDiagnosisItemsResponseBody) SetRequestId(v string) *ListDiagnosisItemsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDiagnosisItemsResponseBody) SetResult(v []*ListDiagnosisItemsResponseBodyResult) *ListDiagnosisItemsResponseBody {
	s.Result = v
	return s
}

type ListDiagnosisItemsResponseBodyResult struct {
	// example:
	//
	// BulkReject
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// ClusterBulkRejectDiagnostic
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// example:
	//
	// BulkReject
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ListDiagnosisItemsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnosisItemsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDiagnosisItemsResponseBodyResult) SetDescription(v string) *ListDiagnosisItemsResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListDiagnosisItemsResponseBodyResult) SetKey(v string) *ListDiagnosisItemsResponseBodyResult {
	s.Key = &v
	return s
}

func (s *ListDiagnosisItemsResponseBodyResult) SetName(v string) *ListDiagnosisItemsResponseBodyResult {
	s.Name = &v
	return s
}

type ListDiagnosisItemsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDiagnosisItemsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDiagnosisItemsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDiagnosisItemsResponse) GoString() string {
	return s.String()
}

func (s *ListDiagnosisItemsResponse) SetHeaders(v map[string]*string) *ListDiagnosisItemsResponse {
	s.Headers = v
	return s
}

func (s *ListDiagnosisItemsResponse) SetStatusCode(v int32) *ListDiagnosisItemsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDiagnosisItemsResponse) SetBody(v *ListDiagnosisItemsResponseBody) *ListDiagnosisItemsResponse {
	s.Body = v
	return s
}

type ListDictInformationRequest struct {
	// example:
	//
	// ALIWS
	AnalyzerType *string `json:"analyzerType,omitempty" xml:"analyzerType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// search-cloud-test-cn-****
	BucketName *string `json:"bucketName,omitempty" xml:"bucketName,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// oss/dic_0.dic
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
}

func (s ListDictInformationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDictInformationRequest) GoString() string {
	return s.String()
}

func (s *ListDictInformationRequest) SetAnalyzerType(v string) *ListDictInformationRequest {
	s.AnalyzerType = &v
	return s
}

func (s *ListDictInformationRequest) SetBucketName(v string) *ListDictInformationRequest {
	s.BucketName = &v
	return s
}

func (s *ListDictInformationRequest) SetKey(v string) *ListDictInformationRequest {
	s.Key = &v
	return s
}

type ListDictInformationResponseBody struct {
	// example:
	//
	// 7C4334EA-D22B-48BD-AE28-08EE68******
	RequestId *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *ListDictInformationResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s ListDictInformationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDictInformationResponseBody) GoString() string {
	return s.String()
}

func (s *ListDictInformationResponseBody) SetRequestId(v string) *ListDictInformationResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDictInformationResponseBody) SetResult(v *ListDictInformationResponseBodyResult) *ListDictInformationResponseBody {
	s.Result = v
	return s
}

type ListDictInformationResponseBodyResult struct {
	// example:
	//
	// 2202301
	FileSize  *int64                                          `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	OssObject *ListDictInformationResponseBodyResultOssObject `json:"ossObject,omitempty" xml:"ossObject,omitempty" type:"Struct"`
	// example:
	//
	// STOP
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListDictInformationResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDictInformationResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDictInformationResponseBodyResult) SetFileSize(v int64) *ListDictInformationResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *ListDictInformationResponseBodyResult) SetOssObject(v *ListDictInformationResponseBodyResultOssObject) *ListDictInformationResponseBodyResult {
	s.OssObject = v
	return s
}

func (s *ListDictInformationResponseBodyResult) SetType(v string) *ListDictInformationResponseBodyResult {
	s.Type = &v
	return s
}

type ListDictInformationResponseBodyResultOssObject struct {
	// example:
	//
	// es-osstest*
	BucketName *string `json:"bucketName,omitempty" xml:"bucketName,omitempty"`
	// example:
	//
	// 2ABAB5E70BBF631145647F6BE533****
	Etag *string `json:"etag,omitempty" xml:"etag,omitempty"`
	// example:
	//
	// oss/dict_0*.dic
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
}

func (s ListDictInformationResponseBodyResultOssObject) String() string {
	return tea.Prettify(s)
}

func (s ListDictInformationResponseBodyResultOssObject) GoString() string {
	return s.String()
}

func (s *ListDictInformationResponseBodyResultOssObject) SetBucketName(v string) *ListDictInformationResponseBodyResultOssObject {
	s.BucketName = &v
	return s
}

func (s *ListDictInformationResponseBodyResultOssObject) SetEtag(v string) *ListDictInformationResponseBodyResultOssObject {
	s.Etag = &v
	return s
}

func (s *ListDictInformationResponseBodyResultOssObject) SetKey(v string) *ListDictInformationResponseBodyResultOssObject {
	s.Key = &v
	return s
}

type ListDictInformationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDictInformationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDictInformationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDictInformationResponse) GoString() string {
	return s.String()
}

func (s *ListDictInformationResponse) SetHeaders(v map[string]*string) *ListDictInformationResponse {
	s.Headers = v
	return s
}

func (s *ListDictInformationResponse) SetStatusCode(v int32) *ListDictInformationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDictInformationResponse) SetBody(v *ListDictInformationResponseBody) *ListDictInformationResponse {
	s.Body = v
	return s
}

type ListDictsRequest struct {
	// The type of the dictionary. Valid values:
	//
	// 	- IK: IK dictionary after a standard update
	//
	// 	- IK_HOT: IK dictionary after a rolling update
	//
	// 	- SYNONYMS: synonym dictionary
	//
	// 	- ALIWS: Alibaba Cloud dictionary
	//
	// This parameter is required.
	//
	// example:
	//
	// IK
	AnalyzerType *string `json:"analyzerType,omitempty" xml:"analyzerType,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s ListDictsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDictsRequest) GoString() string {
	return s.String()
}

func (s *ListDictsRequest) SetAnalyzerType(v string) *ListDictsRequest {
	s.AnalyzerType = &v
	return s
}

func (s *ListDictsRequest) SetName(v string) *ListDictsRequest {
	s.Name = &v
	return s
}

type ListDictsResponseBody struct {
	// The header of the response.
	Headers *ListDictsResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 2937F832-F39E-41EF-89BA-B528342A2A3A
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListDictsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListDictsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDictsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDictsResponseBody) SetHeaders(v *ListDictsResponseBodyHeaders) *ListDictsResponseBody {
	s.Headers = v
	return s
}

func (s *ListDictsResponseBody) SetRequestId(v string) *ListDictsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDictsResponseBody) SetResult(v []*ListDictsResponseBodyResult) *ListDictsResponseBody {
	s.Result = v
	return s
}

type ListDictsResponseBodyHeaders struct {
	// The total number of entries returned.
	//
	// example:
	//
	// 1
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListDictsResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListDictsResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListDictsResponseBodyHeaders) SetXTotalCount(v int32) *ListDictsResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListDictsResponseBodyResult struct {
	// The link that is used to download the dictionary over the Internet. The link is valid for 90s.
	//
	// example:
	//
	// http://test_bucket.oss-cn-hangzhou.aliyuncs.com/AliyunEs/test.dic?Expires=162573****&OSSAccessKeyId=LTAI*****V9&Signature=PNPO********BBGsJDO4V3VfU4sE%3D
	DownloadUrl *string `json:"downloadUrl,omitempty" xml:"downloadUrl,omitempty"`
	// The size of the dictionary file. Unit: byte.
	//
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type.
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The type of the IK dictionary. Valid values:
	//
	// 	- MAIN: main dictionary
	//
	// 	- STOP: stopword list
	//
	// example:
	//
	// MAIN
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListDictsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListDictsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListDictsResponseBodyResult) SetDownloadUrl(v string) *ListDictsResponseBodyResult {
	s.DownloadUrl = &v
	return s
}

func (s *ListDictsResponseBodyResult) SetFileSize(v int64) *ListDictsResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *ListDictsResponseBodyResult) SetName(v string) *ListDictsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListDictsResponseBodyResult) SetSourceType(v string) *ListDictsResponseBodyResult {
	s.SourceType = &v
	return s
}

func (s *ListDictsResponseBodyResult) SetType(v string) *ListDictsResponseBodyResult {
	s.Type = &v
	return s
}

type ListDictsResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDictsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDictsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDictsResponse) GoString() string {
	return s.String()
}

func (s *ListDictsResponse) SetHeaders(v map[string]*string) *ListDictsResponse {
	s.Headers = v
	return s
}

func (s *ListDictsResponse) SetStatusCode(v int32) *ListDictsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDictsResponse) SetBody(v *ListDictsResponseBody) *ListDictsResponse {
	s.Body = v
	return s
}

type ListEcsInstancesRequest struct {
	// test
	//
	// example:
	//
	// ["i-bp13y63575oypr9d****","i-bp1gyhphjaj73jsr****"]
	EcsInstanceIds *string `json:"ecsInstanceIds,omitempty" xml:"ecsInstanceIds,omitempty"`
	// [{ "tagKey":"a","tagValue":"b"}]
	//
	// example:
	//
	// test
	EcsInstanceName *string `json:"ecsInstanceName,omitempty" xml:"ecsInstanceName,omitempty"`
	// 10
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// ["i-bp13y63575oypr9d\\*\\*\\*\\*","i-bp1gyhphjaj73jsr\\*\\*\\*\\*"]
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// vpc-bp16k1dvzxtmagcva\\*\\*\\*\\*
	//
	// example:
	//
	// [{ "tagKey":"a","tagValue":"b"}]
	Tags *string `json:"tags,omitempty" xml:"tags,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// vpc-bp16k1dvzxtmagcva****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s ListEcsInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesRequest) SetEcsInstanceIds(v string) *ListEcsInstancesRequest {
	s.EcsInstanceIds = &v
	return s
}

func (s *ListEcsInstancesRequest) SetEcsInstanceName(v string) *ListEcsInstancesRequest {
	s.EcsInstanceName = &v
	return s
}

func (s *ListEcsInstancesRequest) SetPage(v int32) *ListEcsInstancesRequest {
	s.Page = &v
	return s
}

func (s *ListEcsInstancesRequest) SetSize(v int32) *ListEcsInstancesRequest {
	s.Size = &v
	return s
}

func (s *ListEcsInstancesRequest) SetTags(v string) *ListEcsInstancesRequest {
	s.Tags = &v
	return s
}

func (s *ListEcsInstancesRequest) SetVpcId(v string) *ListEcsInstancesRequest {
	s.VpcId = &v
	return s
}

type ListEcsInstancesResponseBody struct {
	// The number of returned records.
	Headers *ListEcsInstancesResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The header of the response.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Cloud Assistant the installation status, support:
	//
	// 	- true: The Prometheus agent was installed.
	//
	// 	- false: The Prometheus agent was not installed.
	Result []*ListEcsInstancesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListEcsInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBody) SetHeaders(v *ListEcsInstancesResponseBodyHeaders) *ListEcsInstancesResponseBody {
	s.Headers = v
	return s
}

func (s *ListEcsInstancesResponseBody) SetRequestId(v string) *ListEcsInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEcsInstancesResponseBody) SetResult(v []*ListEcsInstancesResponseBodyResult) *ListEcsInstancesResponseBody {
	s.Result = v
	return s
}

type ListEcsInstancesResponseBodyHeaders struct {
	// The returned data.
	//
	// example:
	//
	// 11
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListEcsInstancesResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBodyHeaders) SetXTotalCount(v int32) *ListEcsInstancesResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListEcsInstancesResponseBodyResult struct {
	// The name of the ECS instance.
	//
	// example:
	//
	// true
	CloudAssistantStatus *string `json:"cloudAssistantStatus,omitempty" xml:"cloudAssistantStatus,omitempty"`
	// The ID of the collector instance.
	Collectors []*ListEcsInstancesResponseBodyResultCollectors `json:"collectors,omitempty" xml:"collectors,omitempty" type:"Repeated"`
	// The tags of the ECS instance.
	//
	// example:
	//
	// i-bp14ncqge8wy3l3d****
	EcsInstanceId *string `json:"ecsInstanceId,omitempty" xml:"ecsInstanceId,omitempty"`
	// The ID of the ECS instance.
	//
	// example:
	//
	// ecsTestName
	EcsInstanceName *string `json:"ecsInstanceName,omitempty" xml:"ecsInstanceName,omitempty"`
	// The type of the IP address that is used by the instance. Valid values:
	//
	// 	- public: public endpoint
	//
	// 	- private: private network address
	IpAddress []*ListEcsInstancesResponseBodyResultIpAddress `json:"ipAddress,omitempty" xml:"ipAddress,omitempty" type:"Repeated"`
	// The status of the ECS instance. Valid values:
	//
	// 	- running: The master instance is running
	//
	// 	- starting
	//
	// 	- stopping: The task is being stopped.
	//
	// 	- stopped: The node is stopped.
	//
	// example:
	//
	// linux
	OsType *string `json:"osType,omitempty" xml:"osType,omitempty"`
	// The IP address of the ECS instance.
	//
	// example:
	//
	// running
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The operating system type of the ECS instance. Valid values:
	//
	// 	- windows:Windows operating system
	//
	// 	- linux:Linux operating system
	//
	// example:
	//
	// [ { "tagKey": "a", "tagValue": "b" } ]
	Tags *string `json:"tags,omitempty" xml:"tags,omitempty"`
}

func (s ListEcsInstancesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBodyResult) SetCloudAssistantStatus(v string) *ListEcsInstancesResponseBodyResult {
	s.CloudAssistantStatus = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResult) SetCollectors(v []*ListEcsInstancesResponseBodyResultCollectors) *ListEcsInstancesResponseBodyResult {
	s.Collectors = v
	return s
}

func (s *ListEcsInstancesResponseBodyResult) SetEcsInstanceId(v string) *ListEcsInstancesResponseBodyResult {
	s.EcsInstanceId = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResult) SetEcsInstanceName(v string) *ListEcsInstancesResponseBodyResult {
	s.EcsInstanceName = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResult) SetIpAddress(v []*ListEcsInstancesResponseBodyResultIpAddress) *ListEcsInstancesResponseBodyResult {
	s.IpAddress = v
	return s
}

func (s *ListEcsInstancesResponseBodyResult) SetOsType(v string) *ListEcsInstancesResponseBodyResult {
	s.OsType = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResult) SetStatus(v string) *ListEcsInstancesResponseBodyResult {
	s.Status = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResult) SetTags(v string) *ListEcsInstancesResponseBodyResult {
	s.Tags = &v
	return s
}

type ListEcsInstancesResponseBodyResultCollectors struct {
	CollectorPaths []*string `json:"collectorPaths,omitempty" xml:"collectorPaths,omitempty" type:"Repeated"`
	// The content of the file.
	Configs []*ListEcsInstancesResponseBodyResultCollectorsConfigs `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// The ID of the Alibaba Cloud account.
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
	// Whether Monitoring is enabled. This field is displayed when the **configType*	- is **collectorTargetInstance*	- and the **instanceType*	- is **Elasticsearch**. Valid values:
	//
	// 	- true
	//
	// 	- false
	ExtendConfigs []*ListEcsInstancesResponseBodyResultCollectorsExtendConfigs `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// The status of the collector. Valid values:
	//
	// 	- activating: The project is taking effect.
	//
	// 	- active: The instance has taken effect.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtCreatedTime *string `json:"gmtCreatedTime,omitempty" xml:"gmtCreatedTime,omitempty"`
	// Specifies whether to verify and create a crawer. Valid values:
	//
	// 	- true: only verifies and does not create a
	//
	// 	- false: verifies and creates a
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtUpdateTime *string `json:"gmtUpdateTime,omitempty" xml:"gmtUpdateTime,omitempty"`
	// The configuration file information of the collector.
	//
	// example:
	//
	// ct-testAbc
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The ID of the Virtual Private Cloud to which the collector belongs.
	//
	// example:
	//
	// 16852***488*****
	OwnerId *string `json:"ownerId,omitempty" xml:"ownerId,omitempty"`
	// The time when the collector was updated.
	//
	// example:
	//
	// ct-cn-0v3xj86085dvq****
	ResId *string `json:"resId,omitempty" xml:"resId,omitempty"`
	// The version of the collector. If the machine type of the collector is ECS, only **6.8.5_with_community*	- is supported.
	//
	// example:
	//
	// fileBeat
	ResType *string `json:"resType,omitempty" xml:"resType,omitempty"`
	// The time when the crawl collector was created.
	//
	// example:
	//
	// 6.8.5_with_community
	ResVersion *string `json:"resVersion,omitempty" xml:"resVersion,omitempty"`
	// The name of the collector.
	//
	// example:
	//
	// activing
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The type of the collector. FileBeat, metricBeat, heartBeat, and auditBeat are supported.
	//
	// example:
	//
	// vpc-bp16k1dvzxtm******
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s ListEcsInstancesResponseBodyResultCollectors) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBodyResultCollectors) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetCollectorPaths(v []*string) *ListEcsInstancesResponseBodyResultCollectors {
	s.CollectorPaths = v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetConfigs(v []*ListEcsInstancesResponseBodyResultCollectorsConfigs) *ListEcsInstancesResponseBodyResultCollectors {
	s.Configs = v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetDryRun(v bool) *ListEcsInstancesResponseBodyResultCollectors {
	s.DryRun = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetExtendConfigs(v []*ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) *ListEcsInstancesResponseBodyResultCollectors {
	s.ExtendConfigs = v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetGmtCreatedTime(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.GmtCreatedTime = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetGmtUpdateTime(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.GmtUpdateTime = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetName(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.Name = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetOwnerId(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.OwnerId = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetResId(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.ResId = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetResType(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.ResType = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetResVersion(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.ResVersion = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetStatus(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.Status = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectors) SetVpcId(v string) *ListEcsInstancesResponseBodyResultCollectors {
	s.VpcId = &v
	return s
}

type ListEcsInstancesResponseBodyResultCollectorsConfigs struct {
	// The name of the file.
	//
	// example:
	//
	// - key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// The information about the extended parameter.
	//
	// example:
	//
	// fields.yml
	FileName *string `json:"fileName,omitempty" xml:"fileName,omitempty"`
}

func (s ListEcsInstancesResponseBodyResultCollectorsConfigs) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBodyResultCollectorsConfigs) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBodyResultCollectorsConfigs) SetContent(v string) *ListEcsInstancesResponseBodyResultCollectorsConfigs {
	s.Content = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsConfigs) SetFileName(v string) *ListEcsInstancesResponseBodyResultCollectorsConfigs {
	s.FileName = &v
	return s
}

type ListEcsInstancesResponseBodyResultCollectorsExtendConfigs struct {
	// The instance type specified by Collector Output. Supports Elasticsearch and Logstash. Displayed when the **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// collectorDeployMachine
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// The ID of the host group. Displayed when the **configType*	- is **collectorDeployMachine**.
	//
	// example:
	//
	// true
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" xml:"enableMonitoring,omitempty"`
	// The configuration type. Valid values:
	//
	// 	- collectorTargetInstance: Collector Output
	//
	// 	- collectorDeployMachine: Collector Deployment Machine
	//
	// 	- Collector Elasticsearch ForKibana: Elasticsearch instance information that supports the Kibana dashboard
	//
	// example:
	//
	// default_ct-cn-5i2l75bz4776****
	GroupId *string `json:"groupId,omitempty" xml:"groupId,omitempty"`
	// The path in which Filebeat is collected.
	Hosts []*string `json:"hosts,omitempty" xml:"hosts,omitempty" type:"Repeated"`
	// The list of ECS instances on which the collector is deployed. Displayed when the **configType*	- is **collectorDeployMachines*	- and the **type*	- is **ECSInstanceId**.
	//
	// example:
	//
	// es-cn-nif1z89fz003i****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The transmission protocol, which must be the same as the access protocol of the instance specified by Output. HTTP and HTTPS. Displayed when the **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// elasticsearch
	InstanceType *string `json:"instanceType,omitempty" xml:"instanceType,omitempty"`
	// The status of each crawl on the ECS instance. Valid values:
	//
	// 	- heartOk: The heartbeat is normal.
	//
	// 	- heartLost: The heartbeat is abnormal.
	//
	// 	- uninstalled
	//
	// 	- failed: The installation failed.
	Machines []*ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines `json:"machines,omitempty" xml:"machines,omitempty" type:"Repeated"`
	// The username that is used to access the instance. The default value is elastic. Displayed when the **configType*	- is **collectorTargetInstance*	- or **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// The ID of the instance that is associated with the crawker. If the **configType*	- parameter is set to **collectorTargetInstance**, the value of this parameter is the ID of the output collector. If the **configType*	- parameter is set to **collectorDeployMachines*	- and the **type*	- parameter is set to **ACKCluster**, the value of this parameter is the ID of the ACK cluster.
	//
	// example:
	//
	// ECSInstanceId
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The type of the machine on which the Collector is deployed. This parameter is displayed when the **configType*	- is **collectorDeployMachine**. Valid values:
	//
	// 	- ECSInstanceId:ECS
	//
	// 	- ACKCluster: Container Kubernetes
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetConfigType(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.ConfigType = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetEnableMonitoring(v bool) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.EnableMonitoring = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetGroupId(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.GroupId = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetHosts(v []*string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.Hosts = v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetInstanceId(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.InstanceId = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetInstanceType(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.InstanceType = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetMachines(v []*ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.Machines = v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetProtocol(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.Protocol = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetType(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.Type = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs) SetUserName(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigs {
	s.UserName = &v
	return s
}

type ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines struct {
	// The IDs of ECS instances.
	//
	// example:
	//
	// heartOk
	AgentStatus *string `json:"agentStatus,omitempty" xml:"agentStatus,omitempty"`
	// The list of access addresses of the specified instance for the output of the collector. Displayed when the **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// i-bp13y63575oypr9d****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
}

func (s ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines) SetAgentStatus(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines {
	s.AgentStatus = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines) SetInstanceId(v string) *ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines {
	s.InstanceId = &v
	return s
}

type ListEcsInstancesResponseBodyResultIpAddress struct {
	// The information about the collectors on the ECS instance.
	//
	// example:
	//
	// 172.16.xx.xx
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// The IP address of the endpoint.
	//
	// example:
	//
	// private
	IpType *string `json:"ipType,omitempty" xml:"ipType,omitempty"`
}

func (s ListEcsInstancesResponseBodyResultIpAddress) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponseBodyResultIpAddress) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponseBodyResultIpAddress) SetHost(v string) *ListEcsInstancesResponseBodyResultIpAddress {
	s.Host = &v
	return s
}

func (s *ListEcsInstancesResponseBodyResultIpAddress) SetIpType(v string) *ListEcsInstancesResponseBodyResultIpAddress {
	s.IpType = &v
	return s
}

type ListEcsInstancesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListEcsInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListEcsInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEcsInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListEcsInstancesResponse) SetHeaders(v map[string]*string) *ListEcsInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListEcsInstancesResponse) SetStatusCode(v int32) *ListEcsInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEcsInstancesResponse) SetBody(v *ListEcsInstancesResponseBody) *ListEcsInstancesResponse {
	s.Body = v
	return s
}

type ListExtendfilesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListExtendfilesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListExtendfilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListExtendfilesResponseBody) GoString() string {
	return s.String()
}

func (s *ListExtendfilesResponseBody) SetRequestId(v string) *ListExtendfilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListExtendfilesResponseBody) SetResult(v []*ListExtendfilesResponseBodyResult) *ListExtendfilesResponseBody {
	s.Result = v
	return s
}

type ListExtendfilesResponseBodyResult struct {
	// The path of the driver file.
	FilePath *string `json:"filePath,omitempty" xml:"filePath,omitempty"`
	// The size of the driver file.
	//
	// example:
	//
	// 968668
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the driver file.
	//
	// example:
	//
	// mysql-connector-java-5.1.35.jar
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type.
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
}

func (s ListExtendfilesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListExtendfilesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListExtendfilesResponseBodyResult) SetFilePath(v string) *ListExtendfilesResponseBodyResult {
	s.FilePath = &v
	return s
}

func (s *ListExtendfilesResponseBodyResult) SetFileSize(v int64) *ListExtendfilesResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *ListExtendfilesResponseBodyResult) SetName(v string) *ListExtendfilesResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListExtendfilesResponseBodyResult) SetSourceType(v string) *ListExtendfilesResponseBodyResult {
	s.SourceType = &v
	return s
}

type ListExtendfilesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListExtendfilesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListExtendfilesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListExtendfilesResponse) GoString() string {
	return s.String()
}

func (s *ListExtendfilesResponse) SetHeaders(v map[string]*string) *ListExtendfilesResponse {
	s.Headers = v
	return s
}

func (s *ListExtendfilesResponse) SetStatusCode(v int32) *ListExtendfilesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListExtendfilesResponse) SetBody(v *ListExtendfilesResponseBody) *ListExtendfilesResponse {
	s.Body = v
	return s
}

type ListILMPoliciesRequest struct {
	// example:
	//
	// policy-1
	PolicyName *string `json:"policyName,omitempty" xml:"policyName,omitempty"`
}

func (s ListILMPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListILMPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListILMPoliciesRequest) SetPolicyName(v string) *ListILMPoliciesRequest {
	s.PolicyName = &v
	return s
}

type ListILMPoliciesResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListILMPoliciesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListILMPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListILMPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListILMPoliciesResponseBody) SetRequestId(v string) *ListILMPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListILMPoliciesResponseBody) SetResult(v []*ListILMPoliciesResponseBodyResult) *ListILMPoliciesResponseBody {
	s.Result = v
	return s
}

type ListILMPoliciesResponseBodyResult struct {
	// example:
	//
	// policy-1
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// {"hot":{"minAge":"0ms","actions":{"rollover":{"maxSize":"50gb","maxAge":"30d"},"setPriority":{"priority":100}}},"delete":{"minAge":"3d","actions":{"delete":{}}}}
	Phases map[string]interface{} `json:"phases,omitempty" xml:"phases,omitempty"`
}

func (s ListILMPoliciesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListILMPoliciesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListILMPoliciesResponseBodyResult) SetName(v string) *ListILMPoliciesResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListILMPoliciesResponseBodyResult) SetPhases(v map[string]interface{}) *ListILMPoliciesResponseBodyResult {
	s.Phases = v
	return s
}

type ListILMPoliciesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListILMPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListILMPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListILMPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListILMPoliciesResponse) SetHeaders(v map[string]*string) *ListILMPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListILMPoliciesResponse) SetStatusCode(v int32) *ListILMPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListILMPoliciesResponse) SetBody(v *ListILMPoliciesResponseBody) *ListILMPoliciesResponse {
	s.Body = v
	return s
}

type ListIndexTemplatesRequest struct {
	// example:
	//
	// my-template
	IndexTemplate *string `json:"indexTemplate,omitempty" xml:"indexTemplate,omitempty"`
	// example:
	//
	// 5
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// example:
	//
	// 50
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListIndexTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIndexTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListIndexTemplatesRequest) SetIndexTemplate(v string) *ListIndexTemplatesRequest {
	s.IndexTemplate = &v
	return s
}

func (s *ListIndexTemplatesRequest) SetPage(v int32) *ListIndexTemplatesRequest {
	s.Page = &v
	return s
}

func (s *ListIndexTemplatesRequest) SetSize(v int32) *ListIndexTemplatesRequest {
	s.Size = &v
	return s
}

type ListIndexTemplatesResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListIndexTemplatesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListIndexTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIndexTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListIndexTemplatesResponseBody) SetRequestId(v string) *ListIndexTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListIndexTemplatesResponseBody) SetResult(v []*ListIndexTemplatesResponseBodyResult) *ListIndexTemplatesResponseBody {
	s.Result = v
	return s
}

type ListIndexTemplatesResponseBodyResult struct {
	// example:
	//
	// true
	DataStream *bool `json:"dataStream,omitempty" xml:"dataStream,omitempty"`
	// example:
	//
	// my_ilm_policy
	IlmPolicy     *string   `json:"ilmPolicy,omitempty" xml:"ilmPolicy,omitempty"`
	IndexPatterns []*string `json:"indexPatterns,omitempty" xml:"indexPatterns,omitempty" type:"Repeated"`
	// example:
	//
	// my-template
	IndexTemplate *string `json:"indexTemplate,omitempty" xml:"indexTemplate,omitempty"`
	// example:
	//
	// 100
	Priority *int32                                        `json:"priority,omitempty" xml:"priority,omitempty"`
	Template *ListIndexTemplatesResponseBodyResultTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
}

func (s ListIndexTemplatesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListIndexTemplatesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListIndexTemplatesResponseBodyResult) SetDataStream(v bool) *ListIndexTemplatesResponseBodyResult {
	s.DataStream = &v
	return s
}

func (s *ListIndexTemplatesResponseBodyResult) SetIlmPolicy(v string) *ListIndexTemplatesResponseBodyResult {
	s.IlmPolicy = &v
	return s
}

func (s *ListIndexTemplatesResponseBodyResult) SetIndexPatterns(v []*string) *ListIndexTemplatesResponseBodyResult {
	s.IndexPatterns = v
	return s
}

func (s *ListIndexTemplatesResponseBodyResult) SetIndexTemplate(v string) *ListIndexTemplatesResponseBodyResult {
	s.IndexTemplate = &v
	return s
}

func (s *ListIndexTemplatesResponseBodyResult) SetPriority(v int32) *ListIndexTemplatesResponseBodyResult {
	s.Priority = &v
	return s
}

func (s *ListIndexTemplatesResponseBodyResult) SetTemplate(v *ListIndexTemplatesResponseBodyResultTemplate) *ListIndexTemplatesResponseBodyResult {
	s.Template = v
	return s
}

type ListIndexTemplatesResponseBodyResultTemplate struct {
	// example:
	//
	// {\\"index.number_of_shards\\":\\"1\\"}
	Aliases *string `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// {\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}
	Mappings *string `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// {\\"mydata\\":{}}
	Settings *string `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s ListIndexTemplatesResponseBodyResultTemplate) String() string {
	return tea.Prettify(s)
}

func (s ListIndexTemplatesResponseBodyResultTemplate) GoString() string {
	return s.String()
}

func (s *ListIndexTemplatesResponseBodyResultTemplate) SetAliases(v string) *ListIndexTemplatesResponseBodyResultTemplate {
	s.Aliases = &v
	return s
}

func (s *ListIndexTemplatesResponseBodyResultTemplate) SetMappings(v string) *ListIndexTemplatesResponseBodyResultTemplate {
	s.Mappings = &v
	return s
}

func (s *ListIndexTemplatesResponseBodyResultTemplate) SetSettings(v string) *ListIndexTemplatesResponseBodyResultTemplate {
	s.Settings = &v
	return s
}

type ListIndexTemplatesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListIndexTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListIndexTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIndexTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListIndexTemplatesResponse) SetHeaders(v map[string]*string) *ListIndexTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListIndexTemplatesResponse) SetStatusCode(v int32) *ListIndexTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIndexTemplatesResponse) SetBody(v *ListIndexTemplatesResponseBody) *ListIndexTemplatesResponse {
	s.Body = v
	return s
}

type ListInstanceRequest struct {
	// cn-hangzhou-i
	//
	// example:
	//
	// aliyunes_test1
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// advanced
	//
	// example:
	//
	// 6.7_with_X-Pack
	EsVersion *string `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	// The number of data nodes.
	//
	// example:
	//
	// advanced
	InstanceCategory *string `json:"instanceCategory,omitempty" xml:"instanceCategory,omitempty"`
	// postpaid
	//
	// example:
	//
	// es-cn-v641a0ta3000g****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// [{"tagKey":"key1","tagValue":"value1"}]
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// Specifies whether to include dedicated master nodes. Valid values:
	//
	// 	- true: The files contain data that is dumped to the IA storage medium.
	//
	// 	- false: The files do not contain data that is dumped to the IA storage medium.
	//
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// rg-aekzvowej3i****
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// vpc-bp16k1dvzxtmagcva\\*\\*\\*\\*
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The header of the response.
	//
	// example:
	//
	// [{"tagKey":"key1","tagValue":"value1"}]
	Tags *string `json:"tags,omitempty" xml:"tags,omitempty"`
	// The number of entries returned per page.
	//
	// example:
	//
	// vpc-bp16k1dvzxtmagcva****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// The returned data.
	//
	// example:
	//
	// cn-hangzhou-i
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s ListInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceRequest) SetDescription(v string) *ListInstanceRequest {
	s.Description = &v
	return s
}

func (s *ListInstanceRequest) SetEsVersion(v string) *ListInstanceRequest {
	s.EsVersion = &v
	return s
}

func (s *ListInstanceRequest) SetInstanceCategory(v string) *ListInstanceRequest {
	s.InstanceCategory = &v
	return s
}

func (s *ListInstanceRequest) SetInstanceId(v string) *ListInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceRequest) SetPage(v int32) *ListInstanceRequest {
	s.Page = &v
	return s
}

func (s *ListInstanceRequest) SetPaymentType(v string) *ListInstanceRequest {
	s.PaymentType = &v
	return s
}

func (s *ListInstanceRequest) SetResourceGroupId(v string) *ListInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListInstanceRequest) SetSize(v int32) *ListInstanceRequest {
	s.Size = &v
	return s
}

func (s *ListInstanceRequest) SetTags(v string) *ListInstanceRequest {
	s.Tags = &v
	return s
}

func (s *ListInstanceRequest) SetVpcId(v string) *ListInstanceRequest {
	s.VpcId = &v
	return s
}

func (s *ListInstanceRequest) SetZoneId(v string) *ListInstanceRequest {
	s.ZoneId = &v
	return s
}

type ListInstanceResponseBody struct {
	// The status of the instance. Valid values:
	//
	// 	- active: normal
	//
	// 	- activating: taking effect
	//
	// 	- inactive: frozen
	//
	// 	- invalid: invalid
	Headers *ListInstanceResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The time when the node is created.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether it is a service VPC.
	Result []*ListInstanceResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBody) SetHeaders(v *ListInstanceResponseBodyHeaders) *ListInstanceResponseBody {
	s.Headers = v
	return s
}

func (s *ListInstanceResponseBody) SetRequestId(v string) *ListInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceResponseBody) SetResult(v []*ListInstanceResponseBodyResult) *ListInstanceResponseBody {
	s.Result = v
	return s
}

type ListInstanceResponseBodyHeaders struct {
	// Specifies whether to include dedicated master nodes (obsolete). Valid values:
	//
	// 	- true: The files contain data that is dumped to the IA storage medium.
	//
	// 	- false: The files do not contain data that is dumped to the IA storage medium.
	//
	// example:
	//
	// 10
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListInstanceResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyHeaders) SetXTotalCount(v int32) *ListInstanceResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListInstanceResponseBodyResult struct {
	// The billing method of the instance. Valid values:
	//
	// 	- **prepaid**: subscription
	//
	// 	- **postpaid**: pay-as-you-go
	//
	// example:
	//
	// false
	AdvancedDedicateMaster *bool   `json:"advancedDedicateMaster,omitempty" xml:"advancedDedicateMaster,omitempty"`
	ArchType               *string `json:"archType,omitempty" xml:"archType,omitempty"`
	// The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).
	ClientNodeConfiguration *ListInstanceResponseBodyResultClientNodeConfiguration `json:"clientNodeConfiguration,omitempty" xml:"clientNodeConfiguration,omitempty" type:"Struct"`
	// The status of the pay-as-you-go service that is overlaid on a subscription instance. Valid values:
	//
	// 	- **active**: normal
	//
	// 	- **closed**: Close
	//
	// 	- **indebt**: Overdue payments are frozen
	//
	// example:
	//
	// 2018-07-13T03:58:07.253Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The edition of the dedicated KMS instance.
	//
	// example:
	//
	// false
	DedicateMaster *bool `json:"dedicateMaster,omitempty" xml:"dedicateMaster,omitempty"`
	// The key of the tag.
	//
	// example:
	//
	// es-cn-abc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The configuration of Kibana nodes.
	ElasticDataNodeConfiguration *ListInstanceResponseBodyResultElasticDataNodeConfiguration `json:"elasticDataNodeConfiguration,omitempty" xml:"elasticDataNodeConfiguration,omitempty" type:"Struct"`
	EndTime                      *int64                                                      `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// The value of the tag.
	//
	// example:
	//
	// 6.7_with_X-Pack
	EsVersion *string `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	// The configurations of elastic data nodes.
	ExtendConfigs []map[string]interface{} `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).
	//
	// example:
	//
	// es-cn-v641a0ta3000g****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The configuration of cluster extension parameters.
	//
	// example:
	//
	// true
	IsNewDeployment *string `json:"isNewDeployment,omitempty" xml:"isNewDeployment,omitempty"`
	// The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).
	KibanaConfiguration      *ListInstanceResponseBodyResultKibanaConfiguration `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty" type:"Struct"`
	KibanaIPWhitelist        []*string                                          `json:"kibanaIPWhitelist,omitempty" xml:"kibanaIPWhitelist,omitempty" type:"Repeated"`
	KibanaPrivateIPWhitelist []*string                                          `json:"kibanaPrivateIPWhitelist,omitempty" xml:"kibanaPrivateIPWhitelist,omitempty" type:"Repeated"`
	// The VPC ID of the cluster.
	MasterConfiguration *ListInstanceResponseBodyResultMasterConfiguration `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty" type:"Struct"`
	// The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).
	NetworkConfig *ListInstanceResponseBodyResultNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	// The ID of the resource group.
	//
	// example:
	//
	// 2
	NodeAmount *int32 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// The VPC ID of the cluster.
	NodeSpec *ListInstanceResponseBodyResultNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// The time when the instance was last updated.
	//
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// The tags of the instance. Each tag is a key-value pair.
	//
	// example:
	//
	// active
	PostpaidServiceStatus     *string   `json:"postpaidServiceStatus,omitempty" xml:"postpaidServiceStatus,omitempty"`
	PrivateNetworkIpWhiteList []*string `json:"privateNetworkIpWhiteList,omitempty" xml:"privateNetworkIpWhiteList,omitempty" type:"Repeated"`
	PublicIpWhitelist         []*string `json:"publicIpWhitelist,omitempty" xml:"publicIpWhitelist,omitempty" type:"Repeated"`
	// The ID of the instance.
	//
	// example:
	//
	// rg-aekzvowej3i****
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// Specifies whether to deploy the new architecture.
	//
	// example:
	//
	// true
	ServiceVpc *bool `json:"serviceVpc,omitempty" xml:"serviceVpc,omitempty"`
	// The name of the instance.
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The number of nodes.
	Tags []*ListInstanceResponseBodyResultTags `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	// Coordination node configuration.
	//
	// example:
	//
	// 2018-07-18T10:10:04.484Z
	UpdatedAt *string `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	// example:
	//
	// vpc-bp1uag5jj38c****
	VpcInstanceId *string `json:"vpcInstanceId,omitempty" xml:"vpcInstanceId,omitempty"`
}

func (s ListInstanceResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResult) SetAdvancedDedicateMaster(v bool) *ListInstanceResponseBodyResult {
	s.AdvancedDedicateMaster = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetArchType(v string) *ListInstanceResponseBodyResult {
	s.ArchType = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetClientNodeConfiguration(v *ListInstanceResponseBodyResultClientNodeConfiguration) *ListInstanceResponseBodyResult {
	s.ClientNodeConfiguration = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetCreatedAt(v string) *ListInstanceResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetDedicateMaster(v bool) *ListInstanceResponseBodyResult {
	s.DedicateMaster = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetDescription(v string) *ListInstanceResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetElasticDataNodeConfiguration(v *ListInstanceResponseBodyResultElasticDataNodeConfiguration) *ListInstanceResponseBodyResult {
	s.ElasticDataNodeConfiguration = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetEndTime(v int64) *ListInstanceResponseBodyResult {
	s.EndTime = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetEsVersion(v string) *ListInstanceResponseBodyResult {
	s.EsVersion = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetExtendConfigs(v []map[string]interface{}) *ListInstanceResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetInstanceId(v string) *ListInstanceResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetIsNewDeployment(v string) *ListInstanceResponseBodyResult {
	s.IsNewDeployment = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetKibanaConfiguration(v *ListInstanceResponseBodyResultKibanaConfiguration) *ListInstanceResponseBodyResult {
	s.KibanaConfiguration = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetKibanaIPWhitelist(v []*string) *ListInstanceResponseBodyResult {
	s.KibanaIPWhitelist = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetKibanaPrivateIPWhitelist(v []*string) *ListInstanceResponseBodyResult {
	s.KibanaPrivateIPWhitelist = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetMasterConfiguration(v *ListInstanceResponseBodyResultMasterConfiguration) *ListInstanceResponseBodyResult {
	s.MasterConfiguration = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetNetworkConfig(v *ListInstanceResponseBodyResultNetworkConfig) *ListInstanceResponseBodyResult {
	s.NetworkConfig = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetNodeAmount(v int32) *ListInstanceResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetNodeSpec(v *ListInstanceResponseBodyResultNodeSpec) *ListInstanceResponseBodyResult {
	s.NodeSpec = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetPaymentType(v string) *ListInstanceResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetPostpaidServiceStatus(v string) *ListInstanceResponseBodyResult {
	s.PostpaidServiceStatus = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetPrivateNetworkIpWhiteList(v []*string) *ListInstanceResponseBodyResult {
	s.PrivateNetworkIpWhiteList = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetPublicIpWhitelist(v []*string) *ListInstanceResponseBodyResult {
	s.PublicIpWhitelist = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetResourceGroupId(v string) *ListInstanceResponseBodyResult {
	s.ResourceGroupId = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetServiceVpc(v bool) *ListInstanceResponseBodyResult {
	s.ServiceVpc = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetStatus(v string) *ListInstanceResponseBodyResult {
	s.Status = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetTags(v []*ListInstanceResponseBodyResultTags) *ListInstanceResponseBodyResult {
	s.Tags = v
	return s
}

func (s *ListInstanceResponseBodyResult) SetUpdatedAt(v string) *ListInstanceResponseBodyResult {
	s.UpdatedAt = &v
	return s
}

func (s *ListInstanceResponseBodyResult) SetVpcInstanceId(v string) *ListInstanceResponseBodyResult {
	s.VpcInstanceId = &v
	return s
}

type ListInstanceResponseBodyResultClientNodeConfiguration struct {
	// The size of the node storage space. Unit: GB.
	//
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// Specifies whether to enable disk encryption for the node. Valid values:
	//
	// 	- true: enables instant image cache.
	//
	// 	- false: disables reuse of image cache layers.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type of the node. Valid values:
	//
	// 	- cloud_ssd: SSD.
	//
	// 	- cloud_essd: ESSD.
	//
	// 	- cloud_efficiency: ultra disk
	//
	// example:
	//
	// cloud_efficiency
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The number of nodes.
	//
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s ListInstanceResponseBodyResultClientNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultClientNodeConfiguration) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultClientNodeConfiguration) SetAmount(v int32) *ListInstanceResponseBodyResultClientNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *ListInstanceResponseBodyResultClientNodeConfiguration) SetDisk(v int32) *ListInstanceResponseBodyResultClientNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *ListInstanceResponseBodyResultClientNodeConfiguration) SetDiskType(v string) *ListInstanceResponseBodyResultClientNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *ListInstanceResponseBodyResultClientNodeConfiguration) SetSpec(v string) *ListInstanceResponseBodyResultClientNodeConfiguration {
	s.Spec = &v
	return s
}

func (s *ListInstanceResponseBodyResultClientNodeConfiguration) SetSpecInfo(v string) *ListInstanceResponseBodyResultClientNodeConfiguration {
	s.SpecInfo = &v
	return s
}

type ListInstanceResponseBodyResultElasticDataNodeConfiguration struct {
	// The number of nodes.
	//
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The size of the node storage space. Unit: GB.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type of the node.
	//
	// example:
	//
	// true
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// The configuration of dedicated master nodes.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).
	//
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s ListInstanceResponseBodyResultElasticDataNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultElasticDataNodeConfiguration) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultElasticDataNodeConfiguration) SetAmount(v int32) *ListInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.Amount = &v
	return s
}

func (s *ListInstanceResponseBodyResultElasticDataNodeConfiguration) SetDisk(v int32) *ListInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.Disk = &v
	return s
}

func (s *ListInstanceResponseBodyResultElasticDataNodeConfiguration) SetDiskEncryption(v bool) *ListInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.DiskEncryption = &v
	return s
}

func (s *ListInstanceResponseBodyResultElasticDataNodeConfiguration) SetDiskType(v string) *ListInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.DiskType = &v
	return s
}

func (s *ListInstanceResponseBodyResultElasticDataNodeConfiguration) SetSpec(v string) *ListInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.Spec = &v
	return s
}

func (s *ListInstanceResponseBodyResultElasticDataNodeConfiguration) SetSpecInfo(v string) *ListInstanceResponseBodyResultElasticDataNodeConfiguration {
	s.SpecInfo = &v
	return s
}

type ListInstanceResponseBodyResultKibanaConfiguration struct {
	// The size of the node storage space. Unit: GB.
	//
	// example:
	//
	// 1
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The network configurations.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The number of nodes.
	//
	// example:
	//
	// elasticsearch.n4.small
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s ListInstanceResponseBodyResultKibanaConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultKibanaConfiguration) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultKibanaConfiguration) SetAmount(v int32) *ListInstanceResponseBodyResultKibanaConfiguration {
	s.Amount = &v
	return s
}

func (s *ListInstanceResponseBodyResultKibanaConfiguration) SetDisk(v int32) *ListInstanceResponseBodyResultKibanaConfiguration {
	s.Disk = &v
	return s
}

func (s *ListInstanceResponseBodyResultKibanaConfiguration) SetDiskType(v string) *ListInstanceResponseBodyResultKibanaConfiguration {
	s.DiskType = &v
	return s
}

func (s *ListInstanceResponseBodyResultKibanaConfiguration) SetSpec(v string) *ListInstanceResponseBodyResultKibanaConfiguration {
	s.Spec = &v
	return s
}

func (s *ListInstanceResponseBodyResultKibanaConfiguration) SetSpecInfo(v string) *ListInstanceResponseBodyResultKibanaConfiguration {
	s.SpecInfo = &v
	return s
}

type ListInstanceResponseBodyResultMasterConfiguration struct {
	// The network type. Only Virtual Private Cloud (VPC) is supported.
	//
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The vSwitch ID of the cluster.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The configuration of data nodes.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The zone where the cluster resides.
	//
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s ListInstanceResponseBodyResultMasterConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultMasterConfiguration) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultMasterConfiguration) SetAmount(v int32) *ListInstanceResponseBodyResultMasterConfiguration {
	s.Amount = &v
	return s
}

func (s *ListInstanceResponseBodyResultMasterConfiguration) SetDisk(v int32) *ListInstanceResponseBodyResultMasterConfiguration {
	s.Disk = &v
	return s
}

func (s *ListInstanceResponseBodyResultMasterConfiguration) SetDiskType(v string) *ListInstanceResponseBodyResultMasterConfiguration {
	s.DiskType = &v
	return s
}

func (s *ListInstanceResponseBodyResultMasterConfiguration) SetSpec(v string) *ListInstanceResponseBodyResultMasterConfiguration {
	s.Spec = &v
	return s
}

func (s *ListInstanceResponseBodyResultMasterConfiguration) SetSpecInfo(v string) *ListInstanceResponseBodyResultMasterConfiguration {
	s.SpecInfo = &v
	return s
}

type ListInstanceResponseBodyResultNetworkConfig struct {
	// The storage type of the node. Valid values:
	//
	// 	- cloud_ssd: standard SSD
	//
	// 	- cloud_efficiency: ultra disk
	//
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The storage space of the node. Unit: GB.
	//
	// example:
	//
	// vpc-abc
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// Specifies whether to use disk encryption. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// cn-hangzhou-e
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// The performance level of the ESSD. This parameter is required when the diskType parameter is set to cloud_essd. Valid values: PL1, PL2, and PL3.
	//
	// example:
	//
	// vsw-def
	VswitchId        *string                                                        `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
	WhiteIpGroupList []*ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList `json:"whiteIpGroupList,omitempty" xml:"whiteIpGroupList,omitempty" type:"Repeated"`
}

func (s ListInstanceResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultNetworkConfig) SetType(v string) *ListInstanceResponseBodyResultNetworkConfig {
	s.Type = &v
	return s
}

func (s *ListInstanceResponseBodyResultNetworkConfig) SetVpcId(v string) *ListInstanceResponseBodyResultNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *ListInstanceResponseBodyResultNetworkConfig) SetVsArea(v string) *ListInstanceResponseBodyResultNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *ListInstanceResponseBodyResultNetworkConfig) SetVswitchId(v string) *ListInstanceResponseBodyResultNetworkConfig {
	s.VswitchId = &v
	return s
}

func (s *ListInstanceResponseBodyResultNetworkConfig) SetWhiteIpGroupList(v []*ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) *ListInstanceResponseBodyResultNetworkConfig {
	s.WhiteIpGroupList = v
	return s
}

type ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList struct {
	// example:
	//
	// default
	GroupName *string   `json:"groupName,omitempty" xml:"groupName,omitempty"`
	Ips       []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
	// example:
	//
	// PUBLIC_KIBANA
	WhiteIpType *string `json:"whiteIpType,omitempty" xml:"whiteIpType,omitempty"`
}

func (s ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) SetGroupName(v string) *ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.GroupName = &v
	return s
}

func (s *ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) SetIps(v []*string) *ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.Ips = v
	return s
}

func (s *ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList) SetWhiteIpType(v string) *ListInstanceResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.WhiteIpType = &v
	return s
}

type ListInstanceResponseBodyResultNodeSpec struct {
	// example:
	//
	// 50
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// false
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// PL1
	PerformanceLevel *string `json:"performanceLevel,omitempty" xml:"performanceLevel,omitempty"`
	// example:
	//
	// elasticsearch.n4.small
	Spec     *string `json:"spec,omitempty" xml:"spec,omitempty"`
	SpecInfo *string `json:"specInfo,omitempty" xml:"specInfo,omitempty"`
}

func (s ListInstanceResponseBodyResultNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultNodeSpec) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultNodeSpec) SetDisk(v int32) *ListInstanceResponseBodyResultNodeSpec {
	s.Disk = &v
	return s
}

func (s *ListInstanceResponseBodyResultNodeSpec) SetDiskEncryption(v bool) *ListInstanceResponseBodyResultNodeSpec {
	s.DiskEncryption = &v
	return s
}

func (s *ListInstanceResponseBodyResultNodeSpec) SetDiskType(v string) *ListInstanceResponseBodyResultNodeSpec {
	s.DiskType = &v
	return s
}

func (s *ListInstanceResponseBodyResultNodeSpec) SetPerformanceLevel(v string) *ListInstanceResponseBodyResultNodeSpec {
	s.PerformanceLevel = &v
	return s
}

func (s *ListInstanceResponseBodyResultNodeSpec) SetSpec(v string) *ListInstanceResponseBodyResultNodeSpec {
	s.Spec = &v
	return s
}

func (s *ListInstanceResponseBodyResultNodeSpec) SetSpecInfo(v string) *ListInstanceResponseBodyResultNodeSpec {
	s.SpecInfo = &v
	return s
}

type ListInstanceResponseBodyResultTags struct {
	// The size of the node storage space. Unit: GB.
	//
	// example:
	//
	// env
	TagKey *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	// The storage type of the node. Only ultra disks (cloud_efficiency) are supported.
	//
	// example:
	//
	// dev
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s ListInstanceResponseBodyResultTags) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponseBodyResultTags) GoString() string {
	return s.String()
}

func (s *ListInstanceResponseBodyResultTags) SetTagKey(v string) *ListInstanceResponseBodyResultTags {
	s.TagKey = &v
	return s
}

func (s *ListInstanceResponseBodyResultTags) SetTagValue(v string) *ListInstanceResponseBodyResultTags {
	s.TagValue = &v
	return s
}

type ListInstanceResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceResponse) SetHeaders(v map[string]*string) *ListInstanceResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceResponse) SetStatusCode(v int32) *ListInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceResponse) SetBody(v *ListInstanceResponseBody) *ListInstanceResponse {
	s.Body = v
	return s
}

type ListInstanceHistoryEventsRequest struct {
	Body []*ListInstanceHistoryEventsRequestBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// example:
	//
	// 1645596516000
	EventCreateEndTime *string `json:"eventCreateEndTime,omitempty" xml:"eventCreateEndTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventCreateStartTime *string   `json:"eventCreateStartTime,omitempty" xml:"eventCreateStartTime,omitempty"`
	EventCycleStatus     []*string `json:"eventCycleStatus,omitempty" xml:"eventCycleStatus,omitempty" type:"Repeated"`
	// example:
	//
	// 1645596516000
	EventExecuteEndTime *string `json:"eventExecuteEndTime,omitempty" xml:"eventExecuteEndTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventExecuteStartTime *string `json:"eventExecuteStartTime,omitempty" xml:"eventExecuteStartTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventFinashEndTime *string `json:"eventFinashEndTime,omitempty" xml:"eventFinashEndTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventFinashStartTime *string   `json:"eventFinashStartTime,omitempty" xml:"eventFinashStartTime,omitempty"`
	EventLevel           []*string `json:"eventLevel,omitempty" xml:"eventLevel,omitempty" type:"Repeated"`
	EventType            []*string `json:"eventType,omitempty" xml:"eventType,omitempty" type:"Repeated"`
	// example:
	//
	// es-cn-2r42l7a740005****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// 10.1.xx.xx
	NodeIP *string `json:"nodeIP,omitempty" xml:"nodeIP,omitempty"`
	// example:
	//
	// 0
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListInstanceHistoryEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsRequest) SetBody(v []*ListInstanceHistoryEventsRequestBody) *ListInstanceHistoryEventsRequest {
	s.Body = v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventCreateEndTime(v string) *ListInstanceHistoryEventsRequest {
	s.EventCreateEndTime = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventCreateStartTime(v string) *ListInstanceHistoryEventsRequest {
	s.EventCreateStartTime = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventCycleStatus(v []*string) *ListInstanceHistoryEventsRequest {
	s.EventCycleStatus = v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventExecuteEndTime(v string) *ListInstanceHistoryEventsRequest {
	s.EventExecuteEndTime = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventExecuteStartTime(v string) *ListInstanceHistoryEventsRequest {
	s.EventExecuteStartTime = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventFinashEndTime(v string) *ListInstanceHistoryEventsRequest {
	s.EventFinashEndTime = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventFinashStartTime(v string) *ListInstanceHistoryEventsRequest {
	s.EventFinashStartTime = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventLevel(v []*string) *ListInstanceHistoryEventsRequest {
	s.EventLevel = v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetEventType(v []*string) *ListInstanceHistoryEventsRequest {
	s.EventType = v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetInstanceId(v string) *ListInstanceHistoryEventsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetNodeIP(v string) *ListInstanceHistoryEventsRequest {
	s.NodeIP = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetPage(v int32) *ListInstanceHistoryEventsRequest {
	s.Page = &v
	return s
}

func (s *ListInstanceHistoryEventsRequest) SetSize(v int32) *ListInstanceHistoryEventsRequest {
	s.Size = &v
	return s
}

type ListInstanceHistoryEventsRequestBody struct {
	// example:
	//
	// true
	Desc *bool `json:"desc,omitempty" xml:"desc,omitempty"`
	// example:
	//
	// event_time
	SortField *string `json:"sortField,omitempty" xml:"sortField,omitempty"`
}

func (s ListInstanceHistoryEventsRequestBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsRequestBody) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsRequestBody) SetDesc(v bool) *ListInstanceHistoryEventsRequestBody {
	s.Desc = &v
	return s
}

func (s *ListInstanceHistoryEventsRequestBody) SetSortField(v string) *ListInstanceHistoryEventsRequestBody {
	s.SortField = &v
	return s
}

type ListInstanceHistoryEventsShrinkRequest struct {
	Body []*ListInstanceHistoryEventsShrinkRequestBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// example:
	//
	// 1645596516000
	EventCreateEndTime *string `json:"eventCreateEndTime,omitempty" xml:"eventCreateEndTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventCreateStartTime   *string `json:"eventCreateStartTime,omitempty" xml:"eventCreateStartTime,omitempty"`
	EventCycleStatusShrink *string `json:"eventCycleStatus,omitempty" xml:"eventCycleStatus,omitempty"`
	// example:
	//
	// 1645596516000
	EventExecuteEndTime *string `json:"eventExecuteEndTime,omitempty" xml:"eventExecuteEndTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventExecuteStartTime *string `json:"eventExecuteStartTime,omitempty" xml:"eventExecuteStartTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventFinashEndTime *string `json:"eventFinashEndTime,omitempty" xml:"eventFinashEndTime,omitempty"`
	// example:
	//
	// 1645596516000
	EventFinashStartTime *string `json:"eventFinashStartTime,omitempty" xml:"eventFinashStartTime,omitempty"`
	EventLevelShrink     *string `json:"eventLevel,omitempty" xml:"eventLevel,omitempty"`
	EventTypeShrink      *string `json:"eventType,omitempty" xml:"eventType,omitempty"`
	// example:
	//
	// es-cn-2r42l7a740005****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// 10.1.xx.xx
	NodeIP *string `json:"nodeIP,omitempty" xml:"nodeIP,omitempty"`
	// example:
	//
	// 0
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListInstanceHistoryEventsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetBody(v []*ListInstanceHistoryEventsShrinkRequestBody) *ListInstanceHistoryEventsShrinkRequest {
	s.Body = v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventCreateEndTime(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventCreateEndTime = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventCreateStartTime(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventCreateStartTime = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventCycleStatusShrink(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventCycleStatusShrink = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventExecuteEndTime(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventExecuteEndTime = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventExecuteStartTime(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventExecuteStartTime = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventFinashEndTime(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventFinashEndTime = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventFinashStartTime(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventFinashStartTime = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventLevelShrink(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventLevelShrink = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetEventTypeShrink(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.EventTypeShrink = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetInstanceId(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetNodeIP(v string) *ListInstanceHistoryEventsShrinkRequest {
	s.NodeIP = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetPage(v int32) *ListInstanceHistoryEventsShrinkRequest {
	s.Page = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequest) SetSize(v int32) *ListInstanceHistoryEventsShrinkRequest {
	s.Size = &v
	return s
}

type ListInstanceHistoryEventsShrinkRequestBody struct {
	// example:
	//
	// true
	Desc *bool `json:"desc,omitempty" xml:"desc,omitempty"`
	// example:
	//
	// event_time
	SortField *string `json:"sortField,omitempty" xml:"sortField,omitempty"`
}

func (s ListInstanceHistoryEventsShrinkRequestBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsShrinkRequestBody) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsShrinkRequestBody) SetDesc(v bool) *ListInstanceHistoryEventsShrinkRequestBody {
	s.Desc = &v
	return s
}

func (s *ListInstanceHistoryEventsShrinkRequestBody) SetSortField(v string) *ListInstanceHistoryEventsShrinkRequestBody {
	s.SortField = &v
	return s
}

type ListInstanceHistoryEventsResponseBody struct {
	Headers *ListInstanceHistoryEventsResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// example:
	//
	// D1A6830A-F59B-4E05-BFAC-9496C21DBBA7
	RequestId *string                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListInstanceHistoryEventsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListInstanceHistoryEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsResponseBody) SetHeaders(v *ListInstanceHistoryEventsResponseBodyHeaders) *ListInstanceHistoryEventsResponseBody {
	s.Headers = v
	return s
}

func (s *ListInstanceHistoryEventsResponseBody) SetRequestId(v string) *ListInstanceHistoryEventsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBody) SetResult(v []*ListInstanceHistoryEventsResponseBodyResult) *ListInstanceHistoryEventsResponseBody {
	s.Result = v
	return s
}

type ListInstanceHistoryEventsResponseBodyHeaders struct {
	// example:
	//
	// 15
	XTotalCount *int64 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
	// example:
	//
	// 2
	XTotalFailed *int64 `json:"X-Total-Failed,omitempty" xml:"X-Total-Failed,omitempty"`
	// example:
	//
	// 13
	XTotalSuccess *int64 `json:"X-Total-Success,omitempty" xml:"X-Total-Success,omitempty"`
}

func (s ListInstanceHistoryEventsResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsResponseBodyHeaders) SetXTotalCount(v int64) *ListInstanceHistoryEventsResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyHeaders) SetXTotalFailed(v int64) *ListInstanceHistoryEventsResponseBodyHeaders {
	s.XTotalFailed = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyHeaders) SetXTotalSuccess(v int64) *ListInstanceHistoryEventsResponseBodyHeaders {
	s.XTotalSuccess = &v
	return s
}

type ListInstanceHistoryEventsResponseBodyResult struct {
	// example:
	//
	// i-2ze8s9cjdf2cv969****
	EcsId *string `json:"ecsId,omitempty" xml:"ecsId,omitempty"`
	// example:
	//
	// 2017-12-07T00:00:00Z
	EventCreateTime *string `json:"eventCreateTime,omitempty" xml:"eventCreateTime,omitempty"`
	// example:
	//
	// EXECUTED
	EventCycleStatus *string `json:"eventCycleStatus,omitempty" xml:"eventCycleStatus,omitempty"`
	// example:
	//
	// 2017-12-07T00:00:00Z
	EventExecuteTime *string `json:"eventExecuteTime,omitempty" xml:"eventExecuteTime,omitempty"`
	// example:
	//
	// 2017-12-07T00:00:00Z
	EventFinashTime *string `json:"eventFinashTime,omitempty" xml:"eventFinashTime,omitempty"`
	// example:
	//
	// INFO
	EventLevel *string `json:"eventLevel,omitempty" xml:"eventLevel,omitempty"`
	// example:
	//
	// ECS:AUTO_RESTART
	EventType *string `json:"eventType,omitempty" xml:"eventType,omitempty"`
	// example:
	//
	// es-cn-2r42l7a740005****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// 10.1.xx.xx
	NodeIP *string `json:"nodeIP,omitempty" xml:"nodeIP,omitempty"`
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"regionId,omitempty" xml:"regionId,omitempty"`
}

func (s ListInstanceHistoryEventsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetEcsId(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.EcsId = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetEventCreateTime(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.EventCreateTime = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetEventCycleStatus(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.EventCycleStatus = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetEventExecuteTime(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.EventExecuteTime = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetEventFinashTime(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.EventFinashTime = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetEventLevel(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.EventLevel = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetEventType(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.EventType = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetInstanceId(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetNodeIP(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.NodeIP = &v
	return s
}

func (s *ListInstanceHistoryEventsResponseBodyResult) SetRegionId(v string) *ListInstanceHistoryEventsResponseBodyResult {
	s.RegionId = &v
	return s
}

type ListInstanceHistoryEventsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListInstanceHistoryEventsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListInstanceHistoryEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryEventsResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryEventsResponse) SetHeaders(v map[string]*string) *ListInstanceHistoryEventsResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceHistoryEventsResponse) SetStatusCode(v int32) *ListInstanceHistoryEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceHistoryEventsResponse) SetBody(v *ListInstanceHistoryEventsResponseBody) *ListInstanceHistoryEventsResponse {
	s.Body = v
	return s
}

type ListInstanceIndicesRequest struct {
	// false
	//
	// example:
	//
	// false
	All *bool `json:"all,omitempty" xml:"all,omitempty"`
	// 15
	//
	// example:
	//
	// false
	IsManaged *bool `json:"isManaged,omitempty" xml:"isManaged,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// false
	IsOpenstore *bool `json:"isOpenstore,omitempty" xml:"isOpenstore,omitempty"`
	// 1
	//
	// example:
	//
	// log-0001
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The header of the response.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The total size of the index in Cloud Hosting. Unit: bytes.
	//
	// example:
	//
	// 15
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListInstanceIndicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceIndicesRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceIndicesRequest) SetAll(v bool) *ListInstanceIndicesRequest {
	s.All = &v
	return s
}

func (s *ListInstanceIndicesRequest) SetIsManaged(v bool) *ListInstanceIndicesRequest {
	s.IsManaged = &v
	return s
}

func (s *ListInstanceIndicesRequest) SetIsOpenstore(v bool) *ListInstanceIndicesRequest {
	s.IsOpenstore = &v
	return s
}

func (s *ListInstanceIndicesRequest) SetName(v string) *ListInstanceIndicesRequest {
	s.Name = &v
	return s
}

func (s *ListInstanceIndicesRequest) SetPage(v int32) *ListInstanceIndicesRequest {
	s.Page = &v
	return s
}

func (s *ListInstanceIndicesRequest) SetSize(v int32) *ListInstanceIndicesRequest {
	s.Size = &v
	return s
}

type ListInstanceIndicesResponseBody struct {
	// The total size of the OpenStore cold stage index for this instance. Unit: bytes.
	Headers *ListInstanceIndicesResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The total number of indexes in Cloud Hosting.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total storage space occupied by the current index. Unit: bytes.
	Result []*ListInstanceIndicesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListInstanceIndicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceIndicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceIndicesResponseBody) SetHeaders(v *ListInstanceIndicesResponseBodyHeaders) *ListInstanceIndicesResponseBody {
	s.Headers = v
	return s
}

func (s *ListInstanceIndicesResponseBody) SetRequestId(v string) *ListInstanceIndicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceIndicesResponseBody) SetResult(v []*ListInstanceIndicesResponseBodyResult) *ListInstanceIndicesResponseBody {
	s.Result = v
	return s
}

type ListInstanceIndicesResponseBodyHeaders struct {
	// The details of the index list.
	//
	// example:
	//
	// 15
	XManagedCount *int32 `json:"X-Managed-Count,omitempty" xml:"X-Managed-Count,omitempty"`
	// The total number of indexes in the OpenStore cold phase.
	//
	// example:
	//
	// 18093942932
	XManagedStorageSize *int64 `json:"X-Managed-StorageSize,omitempty" xml:"X-Managed-StorageSize,omitempty"`
	// The time when the index list was queried.
	//
	// example:
	//
	// 5
	XOSSCount *int32 `json:"X-OSS-Count,omitempty" xml:"X-OSS-Count,omitempty"`
	// This parameter is deprecated.
	//
	// example:
	//
	// 9093942932
	XOSSStorageSize *int64 `json:"X-OSS-StorageSize,omitempty" xml:"X-OSS-StorageSize,omitempty"`
}

func (s ListInstanceIndicesResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceIndicesResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListInstanceIndicesResponseBodyHeaders) SetXManagedCount(v int32) *ListInstanceIndicesResponseBodyHeaders {
	s.XManagedCount = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyHeaders) SetXManagedStorageSize(v int64) *ListInstanceIndicesResponseBodyHeaders {
	s.XManagedStorageSize = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyHeaders) SetXOSSCount(v int32) *ListInstanceIndicesResponseBodyHeaders {
	s.XOSSCount = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyHeaders) SetXOSSStorageSize(v int64) *ListInstanceIndicesResponseBodyHeaders {
	s.XOSSStorageSize = &v
	return s
}

type ListInstanceIndicesResponseBodyResult struct {
	// The name of the Elasticsearch index.
	//
	// example:
	//
	// 2021-01-11T05:49:41.114Z
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// green
	Health *string `json:"health,omitempty" xml:"health,omitempty"`
	// example:
	//
	// {    "indices": {         ".ds-console-2021.08.18-000002": {             "index": ".ds-console-2021.08.18-000002",             "managed": true,             "policy": "console",             "lifecycle_date_millis": 1629277498775,             "age": "2.64h",             "phase": "hot",             "phase_time_millis": 1629277450334,             "action": "complete",             "action_time_millis": 1629278605586,             "step": "complete",             "step_time_millis": 1629278605586,             "phase_execution": {                 "policy": "console",                 "phase_definition": {                     "min_age": "0s",                     "actions": {                         "rollover": {                             "max_size": "1gb",                             "max_age": "1d",                             "max_docs": 10000                         },                         "set_priority": {                             "priority": 1000                         }                     }                 },                 "version": 1,                 "modified_date_in_millis": 1629277370953             }         }     } }
	IlmExplain *string `json:"ilmExplain,omitempty" xml:"ilmExplain,omitempty"`
	// The managed status of the index. The following three statuses are supported:
	//
	// 	- following: Hosting.
	//
	// 	- closing: The instance is being unhosted.
	//
	// 	- closed: unmanaged.
	//
	// example:
	//
	// false
	IsManaged *string `json:"isManaged,omitempty" xml:"isManaged,omitempty"`
	// The current storage lifecycle. Value meaning:
	//
	// 	- warm: warm.
	//
	// 	- cold: the cold phase.
	//
	// 	- hot: hot phase.
	//
	// 	- delete: deletes a stage.
	//
	// >  If this parameter is empty, the current index is not managed by the lifecycle.
	//
	// example:
	//
	// closing
	ManagedStatus *string `json:"managedStatus,omitempty" xml:"managedStatus,omitempty"`
	// The full lifecycle status of the current index.
	//
	// example:
	//
	// .kibana_task_manager_1
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// warm
	Phase *string `json:"phase,omitempty" xml:"phase,omitempty"`
	// The running status of the index. The following three statuses are supported:
	//
	// 	- green: healthy.
	//
	// 	- yellow: alerts.
	//
	// 	- red: an exception.
	//
	// example:
	//
	// 49298589
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListInstanceIndicesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceIndicesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListInstanceIndicesResponseBodyResult) SetCreateTime(v string) *ListInstanceIndicesResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyResult) SetHealth(v string) *ListInstanceIndicesResponseBodyResult {
	s.Health = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyResult) SetIlmExplain(v string) *ListInstanceIndicesResponseBodyResult {
	s.IlmExplain = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyResult) SetIsManaged(v string) *ListInstanceIndicesResponseBodyResult {
	s.IsManaged = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyResult) SetManagedStatus(v string) *ListInstanceIndicesResponseBodyResult {
	s.ManagedStatus = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyResult) SetName(v string) *ListInstanceIndicesResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyResult) SetPhase(v string) *ListInstanceIndicesResponseBodyResult {
	s.Phase = &v
	return s
}

func (s *ListInstanceIndicesResponseBodyResult) SetSize(v int64) *ListInstanceIndicesResponseBodyResult {
	s.Size = &v
	return s
}

type ListInstanceIndicesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListInstanceIndicesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListInstanceIndicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceIndicesResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceIndicesResponse) SetHeaders(v map[string]*string) *ListInstanceIndicesResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceIndicesResponse) SetStatusCode(v int32) *ListInstanceIndicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceIndicesResponse) SetBody(v *ListInstanceIndicesResponseBody) *ListInstanceIndicesResponse {
	s.Body = v
	return s
}

type ListKibanaPluginsRequest struct {
	// The number of the page to return. Default value: 1.
	//
	// example:
	//
	// 1
	Page *string `json:"page,omitempty" xml:"page,omitempty"`
	// The number of entries to return on each page.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListKibanaPluginsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPluginsRequest) GoString() string {
	return s.String()
}

func (s *ListKibanaPluginsRequest) SetPage(v string) *ListKibanaPluginsRequest {
	s.Page = &v
	return s
}

func (s *ListKibanaPluginsRequest) SetSize(v int32) *ListKibanaPluginsRequest {
	s.Size = &v
	return s
}

type ListKibanaPluginsResponseBody struct {
	// The request header.
	Headers *ListKibanaPluginsResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 11234B4A-34CE-473B-8E61-AD95702E****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the plug-ins.
	Result []*ListKibanaPluginsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListKibanaPluginsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPluginsResponseBody) GoString() string {
	return s.String()
}

func (s *ListKibanaPluginsResponseBody) SetHeaders(v *ListKibanaPluginsResponseBodyHeaders) *ListKibanaPluginsResponseBody {
	s.Headers = v
	return s
}

func (s *ListKibanaPluginsResponseBody) SetRequestId(v string) *ListKibanaPluginsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListKibanaPluginsResponseBody) SetResult(v []*ListKibanaPluginsResponseBodyResult) *ListKibanaPluginsResponseBody {
	s.Result = v
	return s
}

type ListKibanaPluginsResponseBodyHeaders struct {
	// The total number of entries returned.
	//
	// example:
	//
	// 3
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListKibanaPluginsResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPluginsResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListKibanaPluginsResponseBodyHeaders) SetXTotalCount(v int32) *ListKibanaPluginsResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListKibanaPluginsResponseBodyResult struct {
	// The description of the plug-in.
	//
	// example:
	//
	// Customize DSL statements to query data.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The name of the plug-in.
	//
	// example:
	//
	// bsearch_querybuilder
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source of the plug-in.
	//
	// example:
	//
	// SYSTEM
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
	// The URL of the introduction to the plug-in. The value null is supported.
	//
	// example:
	//
	// https://xxxx
	SpecificationUrl *string `json:"specificationUrl,omitempty" xml:"specificationUrl,omitempty"`
	// The installation status of the plug-in.
	//
	// example:
	//
	// INSTALLED
	State *string `json:"state,omitempty" xml:"state,omitempty"`
}

func (s ListKibanaPluginsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPluginsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListKibanaPluginsResponseBodyResult) SetDescription(v string) *ListKibanaPluginsResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListKibanaPluginsResponseBodyResult) SetName(v string) *ListKibanaPluginsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListKibanaPluginsResponseBodyResult) SetSource(v string) *ListKibanaPluginsResponseBodyResult {
	s.Source = &v
	return s
}

func (s *ListKibanaPluginsResponseBodyResult) SetSpecificationUrl(v string) *ListKibanaPluginsResponseBodyResult {
	s.SpecificationUrl = &v
	return s
}

func (s *ListKibanaPluginsResponseBodyResult) SetState(v string) *ListKibanaPluginsResponseBodyResult {
	s.State = &v
	return s
}

type ListKibanaPluginsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListKibanaPluginsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListKibanaPluginsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPluginsResponse) GoString() string {
	return s.String()
}

func (s *ListKibanaPluginsResponse) SetHeaders(v map[string]*string) *ListKibanaPluginsResponse {
	s.Headers = v
	return s
}

func (s *ListKibanaPluginsResponse) SetStatusCode(v int32) *ListKibanaPluginsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListKibanaPluginsResponse) SetBody(v *ListKibanaPluginsResponseBody) *ListKibanaPluginsResponse {
	s.Body = v
	return s
}

type ListKibanaPvlNetworkResponseBody struct {
	// request id
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListKibanaPvlNetworkResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListKibanaPvlNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPvlNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *ListKibanaPvlNetworkResponseBody) SetRequestId(v string) *ListKibanaPvlNetworkResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListKibanaPvlNetworkResponseBody) SetResult(v []*ListKibanaPvlNetworkResponseBodyResult) *ListKibanaPvlNetworkResponseBody {
	s.Result = v
	return s
}

type ListKibanaPvlNetworkResponseBodyResult struct {
	// example:
	//
	// 2024-03-07T06:26:28Z
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// ep-bp1tah7zbrwmkjef****
	EndpointId *string `json:"endpointId,omitempty" xml:"endpointId,omitempty"`
	// example:
	//
	// es-cn-xxdjfia****-kibana
	EndpointName *string `json:"endpointName,omitempty" xml:"endpointName,omitempty"`
	// example:
	//
	// Connected
	EndpointStatus *string `json:"endpointStatus,omitempty" xml:"endpointStatus,omitempty"`
	// example:
	//
	// es-cn-27a3mul6l***-kibana-internal
	PvlId          *string                                                 `json:"pvlId,omitempty" xml:"pvlId,omitempty"`
	SecurityGroups []*string                                               `json:"securityGroups,omitempty" xml:"securityGroups,omitempty" type:"Repeated"`
	VSwitchIdsZone []*ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone `json:"vSwitchIdsZone,omitempty" xml:"vSwitchIdsZone,omitempty" type:"Repeated"`
	// example:
	//
	// vpc-bp16k1dvzxtma*****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s ListKibanaPvlNetworkResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPvlNetworkResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetCreateTime(v string) *ListKibanaPvlNetworkResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetEndpointId(v string) *ListKibanaPvlNetworkResponseBodyResult {
	s.EndpointId = &v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetEndpointName(v string) *ListKibanaPvlNetworkResponseBodyResult {
	s.EndpointName = &v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetEndpointStatus(v string) *ListKibanaPvlNetworkResponseBodyResult {
	s.EndpointStatus = &v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetPvlId(v string) *ListKibanaPvlNetworkResponseBodyResult {
	s.PvlId = &v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetSecurityGroups(v []*string) *ListKibanaPvlNetworkResponseBodyResult {
	s.SecurityGroups = v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetVSwitchIdsZone(v []*ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone) *ListKibanaPvlNetworkResponseBodyResult {
	s.VSwitchIdsZone = v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResult) SetVpcId(v string) *ListKibanaPvlNetworkResponseBodyResult {
	s.VpcId = &v
	return s
}

type ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone struct {
	// example:
	//
	// vsw-xdefafns***
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
	// example:
	//
	// cn-hangzhou-e
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone) GoString() string {
	return s.String()
}

func (s *ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone) SetVswitchId(v string) *ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone {
	s.VswitchId = &v
	return s
}

func (s *ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone) SetZoneId(v string) *ListKibanaPvlNetworkResponseBodyResultVSwitchIdsZone {
	s.ZoneId = &v
	return s
}

type ListKibanaPvlNetworkResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListKibanaPvlNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListKibanaPvlNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s ListKibanaPvlNetworkResponse) GoString() string {
	return s.String()
}

func (s *ListKibanaPvlNetworkResponse) SetHeaders(v map[string]*string) *ListKibanaPvlNetworkResponse {
	s.Headers = v
	return s
}

func (s *ListKibanaPvlNetworkResponse) SetStatusCode(v int32) *ListKibanaPvlNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *ListKibanaPvlNetworkResponse) SetBody(v *ListKibanaPvlNetworkResponseBody) *ListKibanaPvlNetworkResponse {
	s.Body = v
	return s
}

type ListLogstashRequest struct {
	// rg-acfm2h5vbzd\\*\\*\\*\\*
	//
	// example:
	//
	// ls-cn-abc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// [{"tagKey":"key1","tagValue":"value1"}]
	//
	// example:
	//
	// ls-cn-n6w1o5jq****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// ls-cn-n6w1o5jq\\*\\*\\*\\*
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// Details of the request header.
	//
	// example:
	//
	// rg-acfm2h5vbzd****
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// 5.5.3_with_X-Pack
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The number of entries returned per page.
	//
	// example:
	//
	// [{"tagKey":"key1","tagValue":"value1"}]
	Tags *string `json:"tags,omitempty" xml:"tags,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 5.5.3_with_X-Pack
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s ListLogstashRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashRequest) GoString() string {
	return s.String()
}

func (s *ListLogstashRequest) SetDescription(v string) *ListLogstashRequest {
	s.Description = &v
	return s
}

func (s *ListLogstashRequest) SetInstanceId(v string) *ListLogstashRequest {
	s.InstanceId = &v
	return s
}

func (s *ListLogstashRequest) SetPage(v int32) *ListLogstashRequest {
	s.Page = &v
	return s
}

func (s *ListLogstashRequest) SetResourceGroupId(v string) *ListLogstashRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListLogstashRequest) SetSize(v int32) *ListLogstashRequest {
	s.Size = &v
	return s
}

func (s *ListLogstashRequest) SetTags(v string) *ListLogstashRequest {
	s.Tags = &v
	return s
}

func (s *ListLogstashRequest) SetVersion(v string) *ListLogstashRequest {
	s.Version = &v
	return s
}

type ListLogstashResponseBody struct {
	// The billing method of the instance. Supported: prepaid (subscription) and postpaid (pay-as-you-go).
	Headers *ListLogstashResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// Detailed information about the matching instances.
	//
	// example:
	//
	// AC442F2F-5068-4434-AA21-E78947A9****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the VPC.
	Result []*ListLogstashResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListLogstashResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogstashResponseBody) SetHeaders(v *ListLogstashResponseBodyHeaders) *ListLogstashResponseBody {
	s.Headers = v
	return s
}

func (s *ListLogstashResponseBody) SetRequestId(v string) *ListLogstashResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLogstashResponseBody) SetResult(v []*ListLogstashResponseBodyResult) *ListLogstashResponseBody {
	s.Result = v
	return s
}

type ListLogstashResponseBodyHeaders struct {
	// The number of data nodes.
	//
	// example:
	//
	// 10
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListLogstashResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListLogstashResponseBodyHeaders) SetXTotalCount(v int32) *ListLogstashResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListLogstashResponseBodyResult struct {
	// The configuration information of the data node.
	Tags []*ListLogstashResponseBodyResultTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the instance.
	//
	// example:
	//
	// 2018-07-13T03:58:07.253Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The time when the instance was last updated.
	//
	// example:
	//
	// ls-cn-abc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The tag value of the cloud disk.
	//
	// example:
	//
	// ls-cn-n6w1o5jq****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The network type. Currently, only Virtual Private Cloud (VPC) is supported.
	NetworkConfig *ListLogstashResponseBodyResultNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	// The state of the instance. Valid values: Normal, Active, Inactive, and Invalid.
	//
	// example:
	//
	// 2
	NodeAmount *int32 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// Specifies whether to use disk encryption. Valid values:
	//
	// 	- true: Enables the concurrent query feature for queries other than aggregate queries.
	//
	// 	- false: Disables the concurrent query feature for queries other than aggregate queries.
	NodeSpec *ListLogstashResponseBodyResultNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// The time when the instance was created.
	//
	// example:
	//
	// postpaid
	PaymentType     *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// The version of the instance. Currently, only 6.7.0_with_X-Pack and 7.4.0_with_X-Pack are supported.
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The tag of the instance. Valid values:
	//
	// example:
	//
	// 2018-07-18T10:10:04.484Z
	UpdatedAt *string `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
	// The tag key of the cloud disk.
	//
	// example:
	//
	// 6.7.0_with_X-Pack
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s ListLogstashResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListLogstashResponseBodyResult) SetTags(v []*ListLogstashResponseBodyResultTags) *ListLogstashResponseBodyResult {
	s.Tags = v
	return s
}

func (s *ListLogstashResponseBodyResult) SetCreatedAt(v string) *ListLogstashResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetDescription(v string) *ListLogstashResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetInstanceId(v string) *ListLogstashResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetNetworkConfig(v *ListLogstashResponseBodyResultNetworkConfig) *ListLogstashResponseBodyResult {
	s.NetworkConfig = v
	return s
}

func (s *ListLogstashResponseBodyResult) SetNodeAmount(v int32) *ListLogstashResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetNodeSpec(v *ListLogstashResponseBodyResultNodeSpec) *ListLogstashResponseBodyResult {
	s.NodeSpec = v
	return s
}

func (s *ListLogstashResponseBodyResult) SetPaymentType(v string) *ListLogstashResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetResourceGroupId(v string) *ListLogstashResponseBodyResult {
	s.ResourceGroupId = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetStatus(v string) *ListLogstashResponseBodyResult {
	s.Status = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetUpdatedAt(v string) *ListLogstashResponseBodyResult {
	s.UpdatedAt = &v
	return s
}

func (s *ListLogstashResponseBodyResult) SetVersion(v string) *ListLogstashResponseBodyResult {
	s.Version = &v
	return s
}

type ListLogstashResponseBodyResultTags struct {
	// The disk size of the node.
	//
	// example:
	//
	// env
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The instance type of the ECS instance.
	//
	// example:
	//
	// dev
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListLogstashResponseBodyResultTags) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashResponseBodyResultTags) GoString() string {
	return s.String()
}

func (s *ListLogstashResponseBodyResultTags) SetTagKey(v string) *ListLogstashResponseBodyResultTags {
	s.TagKey = &v
	return s
}

func (s *ListLogstashResponseBodyResultTags) SetTagValue(v string) *ListLogstashResponseBodyResultTags {
	s.TagValue = &v
	return s
}

type ListLogstashResponseBodyResultNetworkConfig struct {
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The ID of the vSwitch.
	//
	// example:
	//
	// vpc-abc
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// example:
	//
	// cn-hangzhou-*
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// example:
	//
	// vsw-def
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s ListLogstashResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *ListLogstashResponseBodyResultNetworkConfig) SetType(v string) *ListLogstashResponseBodyResultNetworkConfig {
	s.Type = &v
	return s
}

func (s *ListLogstashResponseBodyResultNetworkConfig) SetVpcId(v string) *ListLogstashResponseBodyResultNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *ListLogstashResponseBodyResultNetworkConfig) SetVsArea(v string) *ListLogstashResponseBodyResultNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *ListLogstashResponseBodyResultNetworkConfig) SetVswitchId(v string) *ListLogstashResponseBodyResultNetworkConfig {
	s.VswitchId = &v
	return s
}

type ListLogstashResponseBodyResultNodeSpec struct {
	// The network configurations.
	//
	// example:
	//
	// 50
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The ID of the VPC.
	//
	// example:
	//
	// false
	DiskEncryption *bool `json:"diskEncryption,omitempty" xml:"diskEncryption,omitempty"`
	// The zone where the cluster resides.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The type of the disk.
	//
	// example:
	//
	// logstash.n4.small
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s ListLogstashResponseBodyResultNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashResponseBodyResultNodeSpec) GoString() string {
	return s.String()
}

func (s *ListLogstashResponseBodyResultNodeSpec) SetDisk(v int32) *ListLogstashResponseBodyResultNodeSpec {
	s.Disk = &v
	return s
}

func (s *ListLogstashResponseBodyResultNodeSpec) SetDiskEncryption(v bool) *ListLogstashResponseBodyResultNodeSpec {
	s.DiskEncryption = &v
	return s
}

func (s *ListLogstashResponseBodyResultNodeSpec) SetDiskType(v string) *ListLogstashResponseBodyResultNodeSpec {
	s.DiskType = &v
	return s
}

func (s *ListLogstashResponseBodyResultNodeSpec) SetSpec(v string) *ListLogstashResponseBodyResultNodeSpec {
	s.Spec = &v
	return s
}

type ListLogstashResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLogstashResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLogstashResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashResponse) GoString() string {
	return s.String()
}

func (s *ListLogstashResponse) SetHeaders(v map[string]*string) *ListLogstashResponse {
	s.Headers = v
	return s
}

func (s *ListLogstashResponse) SetStatusCode(v int32) *ListLogstashResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogstashResponse) SetBody(v *ListLogstashResponseBody) *ListLogstashResponse {
	s.Body = v
	return s
}

type ListLogstashLogRequest struct {
	// 20
	//
	// example:
	//
	// 1531910852074
	BeginTime *int64 `json:"beginTime,omitempty" xml:"beginTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 1531910852074
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// The returned data.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// 1
	//
	// This parameter is required.
	//
	// example:
	//
	// host:10.7.xx.xx AND level:info AND content:opening
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// The severity level of the log entry. Including trace, debug, info, warn, error, etc. (GC logs have no level).
	//
	// example:
	//
	// 20
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// 1531910852074
	//
	// This parameter is required.
	//
	// example:
	//
	// LOGSTASH_INSTANCE_LOG
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListLogstashLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashLogRequest) GoString() string {
	return s.String()
}

func (s *ListLogstashLogRequest) SetBeginTime(v int64) *ListLogstashLogRequest {
	s.BeginTime = &v
	return s
}

func (s *ListLogstashLogRequest) SetEndTime(v int64) *ListLogstashLogRequest {
	s.EndTime = &v
	return s
}

func (s *ListLogstashLogRequest) SetPage(v int32) *ListLogstashLogRequest {
	s.Page = &v
	return s
}

func (s *ListLogstashLogRequest) SetQuery(v string) *ListLogstashLogRequest {
	s.Query = &v
	return s
}

func (s *ListLogstashLogRequest) SetSize(v int32) *ListLogstashLogRequest {
	s.Size = &v
	return s
}

func (s *ListLogstashLogRequest) SetType(v string) *ListLogstashLogRequest {
	s.Type = &v
	return s
}

type ListLogstashLogResponseBody struct {
	// The details of the log.
	//
	// example:
	//
	// 7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The timestamp of log generation. Unit: ms.
	Result []*ListLogstashLogResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListLogstashLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashLogResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogstashLogResponseBody) SetRequestId(v string) *ListLogstashLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLogstashLogResponseBody) SetResult(v []*ListLogstashLogResponseBodyResult) *ListLogstashLogResponseBody {
	s.Result = v
	return s
}

type ListLogstashLogResponseBodyResult struct {
	// The IP address of the node that generates the log.
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// example:
	//
	// 192.168.xx.xx
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// example:
	//
	// ls-cn-v0h1kzca****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The ID of the instance.
	//
	// example:
	//
	// info
	Level *string `json:"level,omitempty" xml:"level,omitempty"`
	// example:
	//
	// 1531985112420
	Timestamp *int64 `json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

func (s ListLogstashLogResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashLogResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListLogstashLogResponseBodyResult) SetContent(v string) *ListLogstashLogResponseBodyResult {
	s.Content = &v
	return s
}

func (s *ListLogstashLogResponseBodyResult) SetHost(v string) *ListLogstashLogResponseBodyResult {
	s.Host = &v
	return s
}

func (s *ListLogstashLogResponseBodyResult) SetInstanceId(v string) *ListLogstashLogResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListLogstashLogResponseBodyResult) SetLevel(v string) *ListLogstashLogResponseBodyResult {
	s.Level = &v
	return s
}

func (s *ListLogstashLogResponseBodyResult) SetTimestamp(v int64) *ListLogstashLogResponseBodyResult {
	s.Timestamp = &v
	return s
}

type ListLogstashLogResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLogstashLogResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLogstashLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashLogResponse) GoString() string {
	return s.String()
}

func (s *ListLogstashLogResponse) SetHeaders(v map[string]*string) *ListLogstashLogResponse {
	s.Headers = v
	return s
}

func (s *ListLogstashLogResponse) SetStatusCode(v int32) *ListLogstashLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogstashLogResponse) SetBody(v *ListLogstashLogResponseBody) *ListLogstashLogResponse {
	s.Body = v
	return s
}

type ListLogstashPluginsRequest struct {
	// USER
	//
	// example:
	//
	// logstash-filter-clone
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 10
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The returned results.
	//
	// example:
	//
	// 3
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The description of the plug-in.
	//
	// example:
	//
	// USER
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
}

func (s ListLogstashPluginsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashPluginsRequest) GoString() string {
	return s.String()
}

func (s *ListLogstashPluginsRequest) SetName(v string) *ListLogstashPluginsRequest {
	s.Name = &v
	return s
}

func (s *ListLogstashPluginsRequest) SetPage(v int32) *ListLogstashPluginsRequest {
	s.Page = &v
	return s
}

func (s *ListLogstashPluginsRequest) SetSize(v int32) *ListLogstashPluginsRequest {
	s.Size = &v
	return s
}

func (s *ListLogstashPluginsRequest) SetSource(v string) *ListLogstashPluginsRequest {
	s.Source = &v
	return s
}

type ListLogstashPluginsResponseBody struct {
	// The address of the documentation for the plug-in.
	//
	// example:
	//
	// 99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the plug-in. Valid values:
	//
	// 	- INSTALLED: Installed
	//
	// 	- UNINSTALLED: Not installed
	//
	// 	- INSTALLING: The instance is being installed.
	//
	// 	- UNINSTALLING: The instance is being uninstalled.
	//
	// 	- UPGRADING: The backup gateway is being upgraded.
	//
	// 	- FAILED: Installation failed
	//
	// 	- UNKNOWN: The cluster is lost and cannot be created.
	Result []*ListLogstashPluginsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListLogstashPluginsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashPluginsResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogstashPluginsResponseBody) SetRequestId(v string) *ListLogstashPluginsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLogstashPluginsResponseBody) SetResult(v []*ListLogstashPluginsResponseBodyResult) *ListLogstashPluginsResponseBody {
	s.Result = v
	return s
}

type ListLogstashPluginsResponseBodyResult struct {
	// The source of the plug-in.
	//
	// example:
	//
	// The clone filter is for duplicating events.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// logstash-filter-clone
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// SYSTEM
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
	// The name of the plug-in.
	//
	// example:
	//
	// https://xxx.html
	SpecificationUrl *string `json:"specificationUrl,omitempty" xml:"specificationUrl,omitempty"`
	// example:
	//
	// INSTALLED
	State *string `json:"state,omitempty" xml:"state,omitempty"`
}

func (s ListLogstashPluginsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashPluginsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListLogstashPluginsResponseBodyResult) SetDescription(v string) *ListLogstashPluginsResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListLogstashPluginsResponseBodyResult) SetName(v string) *ListLogstashPluginsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListLogstashPluginsResponseBodyResult) SetSource(v string) *ListLogstashPluginsResponseBodyResult {
	s.Source = &v
	return s
}

func (s *ListLogstashPluginsResponseBodyResult) SetSpecificationUrl(v string) *ListLogstashPluginsResponseBodyResult {
	s.SpecificationUrl = &v
	return s
}

func (s *ListLogstashPluginsResponseBodyResult) SetState(v string) *ListLogstashPluginsResponseBodyResult {
	s.State = &v
	return s
}

type ListLogstashPluginsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLogstashPluginsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLogstashPluginsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogstashPluginsResponse) GoString() string {
	return s.String()
}

func (s *ListLogstashPluginsResponse) SetHeaders(v map[string]*string) *ListLogstashPluginsResponse {
	s.Headers = v
	return s
}

func (s *ListLogstashPluginsResponse) SetStatusCode(v int32) *ListLogstashPluginsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogstashPluginsResponse) SetBody(v *ListLogstashPluginsResponseBody) *ListLogstashPluginsResponse {
	s.Body = v
	return s
}

type ListNodesRequest struct {
	// The IDs of the ECS instances.
	//
	// example:
	//
	// i-bp1ei8ysh7orb6eq****
	EcsInstanceIds *string `json:"ecsInstanceIds,omitempty" xml:"ecsInstanceIds,omitempty"`
	// The name of the ECS instance.
	//
	// example:
	//
	// test
	EcsInstanceName *string `json:"ecsInstanceName,omitempty" xml:"ecsInstanceName,omitempty"`
	// The number of the page to return.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The number of entries to return on each page.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The tags of the ECS instance. You must configure tagKey and tagValue.
	//
	// example:
	//
	// [{"tagKey":"abc","tagValue":"xyz"}]
	Tags *string `json:"tags,omitempty" xml:"tags,omitempty"`
}

func (s ListNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNodesRequest) GoString() string {
	return s.String()
}

func (s *ListNodesRequest) SetEcsInstanceIds(v string) *ListNodesRequest {
	s.EcsInstanceIds = &v
	return s
}

func (s *ListNodesRequest) SetEcsInstanceName(v string) *ListNodesRequest {
	s.EcsInstanceName = &v
	return s
}

func (s *ListNodesRequest) SetPage(v int32) *ListNodesRequest {
	s.Page = &v
	return s
}

func (s *ListNodesRequest) SetSize(v int32) *ListNodesRequest {
	s.Size = &v
	return s
}

func (s *ListNodesRequest) SetTags(v string) *ListNodesRequest {
	s.Tags = &v
	return s
}

type ListNodesResponseBody struct {
	// The header of the response.
	Headers *ListNodesResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// E1FD7642-7C40-4FF2-9C0F-21F1A1746F70
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListNodesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBody) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBody) SetHeaders(v *ListNodesResponseBodyHeaders) *ListNodesResponseBody {
	s.Headers = v
	return s
}

func (s *ListNodesResponseBody) SetRequestId(v string) *ListNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNodesResponseBody) SetResult(v []*ListNodesResponseBodyResult) *ListNodesResponseBody {
	s.Result = v
	return s
}

type ListNodesResponseBodyHeaders struct {
	// The number of entries returned.
	//
	// example:
	//
	// 10
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListNodesResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBodyHeaders) SetXTotalCount(v int32) *ListNodesResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListNodesResponseBodyResult struct {
	// The status of the shipper on the ECS instance. Valid values:
	//
	// 	- heartOk: The heartbeat is normal.
	//
	// 	- heartLost: The heartbeat is abnormal.
	//
	// 	- uninstalled: The shipper is not installed.
	//
	// 	- failed: The shipper fails to be installed.
	//
	// example:
	//
	// heartOk
	AgentStatus *string `json:"agentStatus,omitempty" xml:"agentStatus,omitempty"`
	// Indicates whether the Cloud Assistant client is installed. Valid values:
	//
	// 	- true: installed
	//
	// 	- false: not installed
	//
	// example:
	//
	// true
	CloudAssistantStatus *string `json:"cloudAssistantStatus,omitempty" xml:"cloudAssistantStatus,omitempty"`
	// The ID of the ECS instance.
	//
	// example:
	//
	// i-bp13y63575oypr****
	EcsInstanceId *string `json:"ecsInstanceId,omitempty" xml:"ecsInstanceId,omitempty"`
	// The name of the ECS instance.
	//
	// example:
	//
	// ECS_beat
	EcsInstanceName *string `json:"ecsInstanceName,omitempty" xml:"ecsInstanceName,omitempty"`
	// The IP addresses of the ECS instance.
	IpAddress []*ListNodesResponseBodyResultIpAddress `json:"ipAddress,omitempty" xml:"ipAddress,omitempty" type:"Repeated"`
	// The operating system type of the ECS instance. Valid values:
	//
	// 	- windows: Windows Server
	//
	// 	- linux: Linux
	//
	// example:
	//
	// linux
	OsType *string `json:"osType,omitempty" xml:"osType,omitempty"`
	// The status of the ECS instance. Valid values:
	//
	// 	- running: The instance is running.
	//
	// 	- starting: The instance is being started.
	//
	// 	- stopping: The instance is being stopped.
	//
	// 	- stopped: The instance is stopped.
	//
	// example:
	//
	// running
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The tags of the ECS instance.
	Tags []*ListNodesResponseBodyResultTags `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
}

func (s ListNodesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBodyResult) SetAgentStatus(v string) *ListNodesResponseBodyResult {
	s.AgentStatus = &v
	return s
}

func (s *ListNodesResponseBodyResult) SetCloudAssistantStatus(v string) *ListNodesResponseBodyResult {
	s.CloudAssistantStatus = &v
	return s
}

func (s *ListNodesResponseBodyResult) SetEcsInstanceId(v string) *ListNodesResponseBodyResult {
	s.EcsInstanceId = &v
	return s
}

func (s *ListNodesResponseBodyResult) SetEcsInstanceName(v string) *ListNodesResponseBodyResult {
	s.EcsInstanceName = &v
	return s
}

func (s *ListNodesResponseBodyResult) SetIpAddress(v []*ListNodesResponseBodyResultIpAddress) *ListNodesResponseBodyResult {
	s.IpAddress = v
	return s
}

func (s *ListNodesResponseBodyResult) SetOsType(v string) *ListNodesResponseBodyResult {
	s.OsType = &v
	return s
}

func (s *ListNodesResponseBodyResult) SetStatus(v string) *ListNodesResponseBodyResult {
	s.Status = &v
	return s
}

func (s *ListNodesResponseBodyResult) SetTags(v []*ListNodesResponseBodyResultTags) *ListNodesResponseBodyResult {
	s.Tags = v
	return s
}

type ListNodesResponseBodyResultIpAddress struct {
	// The IP address.
	//
	// example:
	//
	// 192.168.xx.xx
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// The type of the IP address. Valid values:
	//
	// 	- public: public IP address
	//
	// 	- private: private IP address
	//
	// example:
	//
	// public
	IpType *string `json:"ipType,omitempty" xml:"ipType,omitempty"`
}

func (s ListNodesResponseBodyResultIpAddress) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBodyResultIpAddress) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBodyResultIpAddress) SetHost(v string) *ListNodesResponseBodyResultIpAddress {
	s.Host = &v
	return s
}

func (s *ListNodesResponseBodyResultIpAddress) SetIpType(v string) *ListNodesResponseBodyResultIpAddress {
	s.IpType = &v
	return s
}

type ListNodesResponseBodyResultTags struct {
	// The key of the tag.
	//
	// example:
	//
	// abc
	TagKey *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	// The value of the tag.
	//
	// example:
	//
	// xyz
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s ListNodesResponseBodyResultTags) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBodyResultTags) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBodyResultTags) SetTagKey(v string) *ListNodesResponseBodyResultTags {
	s.TagKey = &v
	return s
}

func (s *ListNodesResponseBodyResultTags) SetTagValue(v string) *ListNodesResponseBodyResultTags {
	s.TagValue = &v
	return s
}

type ListNodesResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponse) GoString() string {
	return s.String()
}

func (s *ListNodesResponse) SetHeaders(v map[string]*string) *ListNodesResponse {
	s.Headers = v
	return s
}

func (s *ListNodesResponse) SetStatusCode(v int32) *ListNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNodesResponse) SetBody(v *ListNodesResponseBody) *ListNodesResponse {
	s.Body = v
	return s
}

type ListPipelineRequest struct {
	// The header of the response.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// pipeline_test
	PipelineId *string `json:"pipelineId,omitempty" xml:"pipelineId,omitempty"`
	// The total number of returned entries.
	//
	// example:
	//
	// 15
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListPipelineRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineRequest) GoString() string {
	return s.String()
}

func (s *ListPipelineRequest) SetPage(v int32) *ListPipelineRequest {
	s.Page = &v
	return s
}

func (s *ListPipelineRequest) SetPipelineId(v string) *ListPipelineRequest {
	s.PipelineId = &v
	return s
}

func (s *ListPipelineRequest) SetSize(v int32) *ListPipelineRequest {
	s.Size = &v
	return s
}

type ListPipelineResponseBody struct {
	// The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.
	Headers *ListPipelineResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The response.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The time when the pipeline was created.
	Result []*ListPipelineResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListPipelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineResponseBody) GoString() string {
	return s.String()
}

func (s *ListPipelineResponseBody) SetHeaders(v *ListPipelineResponseBodyHeaders) *ListPipelineResponseBody {
	s.Headers = v
	return s
}

func (s *ListPipelineResponseBody) SetRequestId(v string) *ListPipelineResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPipelineResponseBody) SetResult(v []*ListPipelineResponseBodyResult) *ListPipelineResponseBody {
	s.Result = v
	return s
}

type ListPipelineResponseBodyHeaders struct {
	// The time when the pipeline was updated.
	//
	// example:
	//
	// 2
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListPipelineResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListPipelineResponseBodyHeaders) SetXTotalCount(v int32) *ListPipelineResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListPipelineResponseBodyResult struct {
	// example:
	//
	// 2020-08-05T03:10:38.188Z
	GmtCreatedTime *string `json:"gmtCreatedTime,omitempty" xml:"gmtCreatedTime,omitempty"`
	// example:
	//
	// 2020-08-05T08:43:31.757Z
	GmtUpdateTime *string `json:"gmtUpdateTime,omitempty" xml:"gmtUpdateTime,omitempty"`
	// The status of the pipeline. Supported:
	//
	// 	- NOT_DEPLOYED: The node is not deployed.
	//
	// 	- RUNNING
	//
	// 	- DELETED: Deleted. The console does not display this status.
	//
	// example:
	//
	// pipeline_test
	PipelineId *string `json:"pipelineId,omitempty" xml:"pipelineId,omitempty"`
	// example:
	//
	// NOT_DEPLOYED
	PipelineStatus *string `json:"pipelineStatus,omitempty" xml:"pipelineStatus,omitempty"`
}

func (s ListPipelineResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListPipelineResponseBodyResult) SetGmtCreatedTime(v string) *ListPipelineResponseBodyResult {
	s.GmtCreatedTime = &v
	return s
}

func (s *ListPipelineResponseBodyResult) SetGmtUpdateTime(v string) *ListPipelineResponseBodyResult {
	s.GmtUpdateTime = &v
	return s
}

func (s *ListPipelineResponseBodyResult) SetPipelineId(v string) *ListPipelineResponseBodyResult {
	s.PipelineId = &v
	return s
}

func (s *ListPipelineResponseBodyResult) SetPipelineStatus(v string) *ListPipelineResponseBodyResult {
	s.PipelineStatus = &v
	return s
}

type ListPipelineResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListPipelineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListPipelineResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineResponse) GoString() string {
	return s.String()
}

func (s *ListPipelineResponse) SetHeaders(v map[string]*string) *ListPipelineResponse {
	s.Headers = v
	return s
}

func (s *ListPipelineResponse) SetStatusCode(v int32) *ListPipelineResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPipelineResponse) SetBody(v *ListPipelineResponseBody) *ListPipelineResponse {
	s.Body = v
	return s
}

type ListPipelineIdsRequest struct {
	// example:
	//
	// {     "userName":"elastic",     "password":"xxxxxx" }
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListPipelineIdsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineIdsRequest) GoString() string {
	return s.String()
}

func (s *ListPipelineIdsRequest) SetBody(v string) *ListPipelineIdsRequest {
	s.Body = &v
	return s
}

type ListPipelineIdsResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListPipelineIdsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListPipelineIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineIdsResponseBody) GoString() string {
	return s.String()
}

func (s *ListPipelineIdsResponseBody) SetRequestId(v string) *ListPipelineIdsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPipelineIdsResponseBody) SetResult(v []*ListPipelineIdsResponseBodyResult) *ListPipelineIdsResponseBody {
	s.Result = v
	return s
}

type ListPipelineIdsResponseBodyResult struct {
	// example:
	//
	// true
	Available *bool `json:"available,omitempty" xml:"available,omitempty"`
	// example:
	//
	// OK
	Code *string `json:"code,omitempty" xml:"code,omitempty"`
	// example:
	//
	// OK
	Message *string `json:"message,omitempty" xml:"message,omitempty"`
	// example:
	//
	// testKibanaManagement
	PipelineId *string `json:"pipelineId,omitempty" xml:"pipelineId,omitempty"`
}

func (s ListPipelineIdsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineIdsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListPipelineIdsResponseBodyResult) SetAvailable(v bool) *ListPipelineIdsResponseBodyResult {
	s.Available = &v
	return s
}

func (s *ListPipelineIdsResponseBodyResult) SetCode(v string) *ListPipelineIdsResponseBodyResult {
	s.Code = &v
	return s
}

func (s *ListPipelineIdsResponseBodyResult) SetMessage(v string) *ListPipelineIdsResponseBodyResult {
	s.Message = &v
	return s
}

func (s *ListPipelineIdsResponseBodyResult) SetPipelineId(v string) *ListPipelineIdsResponseBodyResult {
	s.PipelineId = &v
	return s
}

type ListPipelineIdsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListPipelineIdsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListPipelineIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPipelineIdsResponse) GoString() string {
	return s.String()
}

func (s *ListPipelineIdsResponse) SetHeaders(v map[string]*string) *ListPipelineIdsResponse {
	s.Headers = v
	return s
}

func (s *ListPipelineIdsResponse) SetStatusCode(v int32) *ListPipelineIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPipelineIdsResponse) SetBody(v *ListPipelineIdsResponseBody) *ListPipelineIdsResponse {
	s.Body = v
	return s
}

type ListPluginsRequest struct {
	// SYSTEM
	//
	// example:
	//
	// analysis-ik
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 1
	Page *string `json:"page,omitempty" xml:"page,omitempty"`
	// The header of the response.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The total number of entries returned.
	//
	// example:
	//
	// SYSTEM
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
}

func (s ListPluginsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPluginsRequest) GoString() string {
	return s.String()
}

func (s *ListPluginsRequest) SetName(v string) *ListPluginsRequest {
	s.Name = &v
	return s
}

func (s *ListPluginsRequest) SetPage(v string) *ListPluginsRequest {
	s.Page = &v
	return s
}

func (s *ListPluginsRequest) SetSize(v int32) *ListPluginsRequest {
	s.Size = &v
	return s
}

func (s *ListPluginsRequest) SetSource(v string) *ListPluginsRequest {
	s.Source = &v
	return s
}

type ListPluginsResponseBody struct {
	// The description of the plug-in.
	Headers *ListPluginsResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The return results.
	//
	// example:
	//
	// 5A5D8E74-565C-43DC-B031-29289FA9****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the plug-in.
	Result []*ListPluginsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListPluginsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPluginsResponseBody) GoString() string {
	return s.String()
}

func (s *ListPluginsResponseBody) SetHeaders(v *ListPluginsResponseBodyHeaders) *ListPluginsResponseBody {
	s.Headers = v
	return s
}

func (s *ListPluginsResponseBody) SetRequestId(v string) *ListPluginsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPluginsResponseBody) SetResult(v []*ListPluginsResponseBodyResult) *ListPluginsResponseBody {
	s.Result = v
	return s
}

type ListPluginsResponseBodyHeaders struct {
	// The address of the plug-in description document.
	//
	// example:
	//
	// 2
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListPluginsResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListPluginsResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListPluginsResponseBodyHeaders) SetXTotalCount(v int32) *ListPluginsResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListPluginsResponseBodyResult struct {
	// The source type of the plug-in.
	//
	// example:
	//
	// IK analysis plug-in for Elasticsearch.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// analysis-ik
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// SYSTEM
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
	// The name of the plug-in.
	//
	// example:
	//
	// https://xxxx.html
	SpecificationUrl *string `json:"specificationUrl,omitempty" xml:"specificationUrl,omitempty"`
	// example:
	//
	// INSTALLED
	State *string `json:"state,omitempty" xml:"state,omitempty"`
}

func (s ListPluginsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListPluginsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListPluginsResponseBodyResult) SetDescription(v string) *ListPluginsResponseBodyResult {
	s.Description = &v
	return s
}

func (s *ListPluginsResponseBodyResult) SetName(v string) *ListPluginsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *ListPluginsResponseBodyResult) SetSource(v string) *ListPluginsResponseBodyResult {
	s.Source = &v
	return s
}

func (s *ListPluginsResponseBodyResult) SetSpecificationUrl(v string) *ListPluginsResponseBodyResult {
	s.SpecificationUrl = &v
	return s
}

func (s *ListPluginsResponseBodyResult) SetState(v string) *ListPluginsResponseBodyResult {
	s.State = &v
	return s
}

type ListPluginsResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListPluginsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListPluginsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPluginsResponse) GoString() string {
	return s.String()
}

func (s *ListPluginsResponse) SetHeaders(v map[string]*string) *ListPluginsResponse {
	s.Headers = v
	return s
}

func (s *ListPluginsResponse) SetStatusCode(v int32) *ListPluginsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPluginsResponse) SetBody(v *ListPluginsResponseBody) *ListPluginsResponse {
	s.Body = v
	return s
}

type ListSearchLogRequest struct {
	// 20
	//
	// example:
	//
	// 1531910852074
	BeginTime *int64 `json:"beginTime,omitempty" xml:"beginTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 1531910852074
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// The header of the response.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// 1
	//
	// This parameter is required.
	//
	// example:
	//
	// host:172.16.\*\*.*	- AND content:netty
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// The number of entries returned per page.
	//
	// example:
	//
	// 20
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// 1531910852074
	//
	// This parameter is required.
	//
	// example:
	//
	// INSTANCELOG
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListSearchLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSearchLogRequest) GoString() string {
	return s.String()
}

func (s *ListSearchLogRequest) SetBeginTime(v int64) *ListSearchLogRequest {
	s.BeginTime = &v
	return s
}

func (s *ListSearchLogRequest) SetEndTime(v int64) *ListSearchLogRequest {
	s.EndTime = &v
	return s
}

func (s *ListSearchLogRequest) SetPage(v int32) *ListSearchLogRequest {
	s.Page = &v
	return s
}

func (s *ListSearchLogRequest) SetQuery(v string) *ListSearchLogRequest {
	s.Query = &v
	return s
}

func (s *ListSearchLogRequest) SetSize(v int32) *ListSearchLogRequest {
	s.Size = &v
	return s
}

func (s *ListSearchLogRequest) SetType(v string) *ListSearchLogRequest {
	s.Type = &v
	return s
}

type ListSearchLogResponseBody struct {
	// The level of the log. Valid values:
	//
	// 	- warn: warning log
	//
	// 	- info: information log
	//
	// 	- error: error log
	//
	// 	- trace: trace logs
	//
	// 	- debug: debug logs
	//
	// The level information has been migrated to the contentCollection field.
	Headers *ListSearchLogResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The list of logs returned by the request.
	//
	// example:
	//
	// 7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The content of the log entry. Migrated to the contentCollection field.
	Result []*ListSearchLogResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListSearchLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSearchLogResponseBody) GoString() string {
	return s.String()
}

func (s *ListSearchLogResponseBody) SetHeaders(v *ListSearchLogResponseBodyHeaders) *ListSearchLogResponseBody {
	s.Headers = v
	return s
}

func (s *ListSearchLogResponseBody) SetRequestId(v string) *ListSearchLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSearchLogResponseBody) SetResult(v []*ListSearchLogResponseBodyResult) *ListSearchLogResponseBody {
	s.Result = v
	return s
}

type ListSearchLogResponseBodyHeaders struct {
	// The IP address of the node that generates the log.
	//
	// example:
	//
	// 1000
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListSearchLogResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListSearchLogResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListSearchLogResponseBodyHeaders) SetXTotalCount(v int32) *ListSearchLogResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListSearchLogResponseBodyResult struct {
	// The ID of the instance.
	//
	// example:
	//
	// [GC (Allocation Failure) 2018-07-19T17:24:20.682+0800: 7516.513: [ParNew: 6604768K->81121K(7341504K), 0.0760606 secs] 7226662K->703015K(31813056K), 0.0762507 secs] [Times: user=0.52 sys=0.00, real=0.07 secs]
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// example:
	//
	// {"level": "info", "host": "192.168.\*\*.**", "time": "2019-03-18T08:16:12.741Z","content": "[o.e.c.r.a.AllocationService] [MnNASM_] Cluster health status changed from [YELLOW] to [GREEN] (reason: [shards started [[my_index][3]] ...])."}
	ContentCollection map[string]interface{} `json:"contentCollection,omitempty" xml:"contentCollection,omitempty"`
	// Details of the log entry. Different content fields are returned for different log types.
	//
	// example:
	//
	// 192.168.\*\*.**
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// example:
	//
	// es-cn-n6w1o1x0w001c****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The timestamp when the log is generated. Unit: ms.
	//
	// example:
	//
	// info
	Level *string `json:"level,omitempty" xml:"level,omitempty"`
	// example:
	//
	// 1531985112420
	Timestamp *int64 `json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

func (s ListSearchLogResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListSearchLogResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListSearchLogResponseBodyResult) SetContent(v string) *ListSearchLogResponseBodyResult {
	s.Content = &v
	return s
}

func (s *ListSearchLogResponseBodyResult) SetContentCollection(v map[string]interface{}) *ListSearchLogResponseBodyResult {
	s.ContentCollection = v
	return s
}

func (s *ListSearchLogResponseBodyResult) SetHost(v string) *ListSearchLogResponseBodyResult {
	s.Host = &v
	return s
}

func (s *ListSearchLogResponseBodyResult) SetInstanceId(v string) *ListSearchLogResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListSearchLogResponseBodyResult) SetLevel(v string) *ListSearchLogResponseBodyResult {
	s.Level = &v
	return s
}

func (s *ListSearchLogResponseBodyResult) SetTimestamp(v int64) *ListSearchLogResponseBodyResult {
	s.Timestamp = &v
	return s
}

type ListSearchLogResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSearchLogResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSearchLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSearchLogResponse) GoString() string {
	return s.String()
}

func (s *ListSearchLogResponse) SetHeaders(v map[string]*string) *ListSearchLogResponse {
	s.Headers = v
	return s
}

func (s *ListSearchLogResponse) SetStatusCode(v int32) *ListSearchLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSearchLogResponse) SetBody(v *ListSearchLogResponseBody) *ListSearchLogResponse {
	s.Body = v
	return s
}

type ListShardRecoveriesRequest struct {
	// Specifies whether to return information about data restoration of shards. Valid values:
	//
	// 	- true: returns information about data restoration of shards that are being restored.
	//
	// 	- false: returns information about data restoration of all shards.
	//
	// example:
	//
	// true
	ActiveOnly *bool `json:"activeOnly,omitempty" xml:"activeOnly,omitempty"`
}

func (s ListShardRecoveriesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListShardRecoveriesRequest) GoString() string {
	return s.String()
}

func (s *ListShardRecoveriesRequest) SetActiveOnly(v bool) *ListShardRecoveriesRequest {
	s.ActiveOnly = &v
	return s
}

type ListShardRecoveriesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*ListShardRecoveriesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListShardRecoveriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListShardRecoveriesResponseBody) GoString() string {
	return s.String()
}

func (s *ListShardRecoveriesResponseBody) SetRequestId(v string) *ListShardRecoveriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListShardRecoveriesResponseBody) SetResult(v []*ListShardRecoveriesResponseBodyResult) *ListShardRecoveriesResponseBody {
	s.Result = v
	return s
}

type ListShardRecoveriesResponseBodyResult struct {
	// The data restoration progress.
	//
	// example:
	//
	// 80%
	BytesPercent *string `json:"bytesPercent,omitempty" xml:"bytesPercent,omitempty"`
	// The total amount of data that is restored.
	//
	// example:
	//
	// 12086
	BytesTotal *int64 `json:"bytesTotal,omitempty" xml:"bytesTotal,omitempty"`
	// The file execution progress.
	//
	// example:
	//
	// 80.0%
	FilesPercent *string `json:"filesPercent,omitempty" xml:"filesPercent,omitempty"`
	// The total number of files.
	//
	// example:
	//
	// 79
	FilesTotal *int64 `json:"filesTotal,omitempty" xml:"filesTotal,omitempty"`
	// The name of the index.
	//
	// example:
	//
	// my-index-000001
	Index *string `json:"index,omitempty" xml:"index,omitempty"`
	// The IP address of the source node.
	//
	// example:
	//
	// 192.168.XX.XX
	SourceHost *string `json:"sourceHost,omitempty" xml:"sourceHost,omitempty"`
	// The name of the source node.
	//
	// example:
	//
	// 2Kni3dJ
	SourceNode *string `json:"sourceNode,omitempty" xml:"sourceNode,omitempty"`
	// The data restoration status. Valid values:
	//
	// 	- done: Data restoration is complete.
	//
	// 	- finalize: Data is being cleared.
	//
	// 	- index: Index metadata is being read, and bytes are being copied from source to destination.
	//
	// 	- init: Data restoration is not started.
	//
	// 	- start: Data restoration is started.
	//
	// 	- translog: Translogs are being redone.
	//
	// example:
	//
	// done
	Stage *string `json:"stage,omitempty" xml:"stage,omitempty"`
	// The IP address of the destination node.
	//
	// example:
	//
	// 192.168.XX.XX
	TargetHost *string `json:"targetHost,omitempty" xml:"targetHost,omitempty"`
	// The name of the destination node.
	//
	// example:
	//
	// YVVKLmW
	TargetNode *string `json:"targetNode,omitempty" xml:"targetNode,omitempty"`
	// The number of translog operations to be restored.
	//
	// example:
	//
	// 12086
	TranslogOps *int64 `json:"translogOps,omitempty" xml:"translogOps,omitempty"`
	// The restoration progress of translog operations.
	//
	// example:
	//
	// 80%
	TranslogOpsPercent *string `json:"translogOpsPercent,omitempty" xml:"translogOpsPercent,omitempty"`
}

func (s ListShardRecoveriesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListShardRecoveriesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListShardRecoveriesResponseBodyResult) SetBytesPercent(v string) *ListShardRecoveriesResponseBodyResult {
	s.BytesPercent = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetBytesTotal(v int64) *ListShardRecoveriesResponseBodyResult {
	s.BytesTotal = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetFilesPercent(v string) *ListShardRecoveriesResponseBodyResult {
	s.FilesPercent = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetFilesTotal(v int64) *ListShardRecoveriesResponseBodyResult {
	s.FilesTotal = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetIndex(v string) *ListShardRecoveriesResponseBodyResult {
	s.Index = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetSourceHost(v string) *ListShardRecoveriesResponseBodyResult {
	s.SourceHost = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetSourceNode(v string) *ListShardRecoveriesResponseBodyResult {
	s.SourceNode = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetStage(v string) *ListShardRecoveriesResponseBodyResult {
	s.Stage = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetTargetHost(v string) *ListShardRecoveriesResponseBodyResult {
	s.TargetHost = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetTargetNode(v string) *ListShardRecoveriesResponseBodyResult {
	s.TargetNode = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetTranslogOps(v int64) *ListShardRecoveriesResponseBodyResult {
	s.TranslogOps = &v
	return s
}

func (s *ListShardRecoveriesResponseBodyResult) SetTranslogOpsPercent(v string) *ListShardRecoveriesResponseBodyResult {
	s.TranslogOpsPercent = &v
	return s
}

type ListShardRecoveriesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListShardRecoveriesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListShardRecoveriesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListShardRecoveriesResponse) GoString() string {
	return s.String()
}

func (s *ListShardRecoveriesResponse) SetHeaders(v map[string]*string) *ListShardRecoveriesResponse {
	s.Headers = v
	return s
}

func (s *ListShardRecoveriesResponse) SetStatusCode(v int32) *ListShardRecoveriesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListShardRecoveriesResponse) SetBody(v *ListShardRecoveriesResponseBody) *ListShardRecoveriesResponse {
	s.Body = v
	return s
}

type ListSnapshotReposByInstanceIdResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result []*ListSnapshotReposByInstanceIdResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListSnapshotReposByInstanceIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotReposByInstanceIdResponseBody) GoString() string {
	return s.String()
}

func (s *ListSnapshotReposByInstanceIdResponseBody) SetRequestId(v string) *ListSnapshotReposByInstanceIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSnapshotReposByInstanceIdResponseBody) SetResult(v []*ListSnapshotReposByInstanceIdResponseBodyResult) *ListSnapshotReposByInstanceIdResponseBody {
	s.Result = v
	return s
}

type ListSnapshotReposByInstanceIdResponseBodyResult struct {
	// Reference instance ID.
	//
	// example:
	//
	// es-cn-6ja1ro4jt000c****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The address of the repository.
	//
	// example:
	//
	// es-cn-6ja1ro4jt000c****
	RepoPath *string `json:"repoPath,omitempty" xml:"repoPath,omitempty"`
	// Reference warehouse name.
	//
	// example:
	//
	// aliyun_snapshot_from_es-cn-6ja1ro4jt000c****
	SnapWarehouse *string `json:"snapWarehouse,omitempty" xml:"snapWarehouse,omitempty"`
	// Reference warehouse status. available indicates that it is valid. unavailable indicates that it is invalid.
	//
	// example:
	//
	// available
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s ListSnapshotReposByInstanceIdResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotReposByInstanceIdResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListSnapshotReposByInstanceIdResponseBodyResult) SetInstanceId(v string) *ListSnapshotReposByInstanceIdResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *ListSnapshotReposByInstanceIdResponseBodyResult) SetRepoPath(v string) *ListSnapshotReposByInstanceIdResponseBodyResult {
	s.RepoPath = &v
	return s
}

func (s *ListSnapshotReposByInstanceIdResponseBodyResult) SetSnapWarehouse(v string) *ListSnapshotReposByInstanceIdResponseBodyResult {
	s.SnapWarehouse = &v
	return s
}

func (s *ListSnapshotReposByInstanceIdResponseBodyResult) SetStatus(v string) *ListSnapshotReposByInstanceIdResponseBodyResult {
	s.Status = &v
	return s
}

type ListSnapshotReposByInstanceIdResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSnapshotReposByInstanceIdResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSnapshotReposByInstanceIdResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotReposByInstanceIdResponse) GoString() string {
	return s.String()
}

func (s *ListSnapshotReposByInstanceIdResponse) SetHeaders(v map[string]*string) *ListSnapshotReposByInstanceIdResponse {
	s.Headers = v
	return s
}

func (s *ListSnapshotReposByInstanceIdResponse) SetStatusCode(v int32) *ListSnapshotReposByInstanceIdResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSnapshotReposByInstanceIdResponse) SetBody(v *ListSnapshotReposByInstanceIdResponseBody) *ListSnapshotReposByInstanceIdResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The number of the returned page.
	//
	// example:
	//
	// 1d2db86sca4384811e0b5e8707e******
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// Deprecated
	//
	// 1d2db86sca4384811e0b5e8707e\\*\\*\\*\\*\\*\\*
	//
	// example:
	//
	// 1
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// ["es-cn-aaa","es-cn-bbb"]
	ResourceIds *string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// [{"key":"env","value","dev"},{"key":"dev", "value":"IT"}]
	//
	// This parameter is required.
	//
	// example:
	//
	// INSTANCE
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Deprecated
	//
	// ["es-cn-aaa","es-cn-bbb"]
	//
	// example:
	//
	// 10
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The header of the response. This parameter is empty and is for reference only. You cannot force this parameter to be relied on in the program.
	//
	// >  The return examples does not contain this parameter.
	//
	// example:
	//
	// [{"key":"env","value","dev"},{"key":"dev",  "value":"IT"}]
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetPage(v int32) *ListTagResourcesRequest {
	s.Page = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceIds(v string) *ListTagResourcesRequest {
	s.ResourceIds = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetSize(v int32) *ListTagResourcesRequest {
	s.Size = &v
	return s
}

func (s *ListTagResourcesRequest) SetTags(v string) *ListTagResourcesRequest {
	s.Tags = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The labels of the resource.
	Headers *ListTagResourcesResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Struct"`
	// The number of resources to query.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// A list of resources that have tags.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6D******
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The type of the resource. Fixed to `ALIYUN::ELASTICSEARCH::INSTANCE`.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetHeaders(v *ListTagResourcesResponseBodyHeaders) *ListTagResourcesResponseBody {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponseBody) SetPageSize(v int32) *ListTagResourcesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyHeaders struct {
	// The value of the tag.
	//
	// example:
	//
	// 10
	XTotalCount *int32 `json:"X-Total-Count,omitempty" xml:"X-Total-Count,omitempty"`
}

func (s ListTagResourcesResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyHeaders) SetXTotalCount(v int32) *ListTagResourcesResponseBodyHeaders {
	s.XTotalCount = &v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	// Indicates the ID of a resource.
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// example:
	//
	// es-cn-oew1q8bev0002****
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// example:
	//
	// ALIYUN::ELASTICSEARCH::INSTANCE
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// example:
	//
	// env
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag key.
	//
	// example:
	//
	// dev
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListTagsRequest struct {
	// The return results.
	//
	// example:
	//
	// 20
	PageSize *int32 `json:"pageSize,omitempty" xml:"pageSize,omitempty"`
	// The tag value of the ENI.
	//
	// example:
	//
	// INSTANCE
	ResourceType *string `json:"resourceType,omitempty" xml:"resourceType,omitempty"`
}

func (s ListTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagsRequest) GoString() string {
	return s.String()
}

func (s *ListTagsRequest) SetPageSize(v int32) *ListTagsRequest {
	s.PageSize = &v
	return s
}

func (s *ListTagsRequest) SetResourceType(v string) *ListTagsRequest {
	s.ResourceType = &v
	return s
}

type ListTagsResponseBody struct {
	// The key of the tag.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*ListTagsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagsResponseBody) SetRequestId(v string) *ListTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagsResponseBody) SetResult(v []*ListTagsResponseBodyResult) *ListTagsResponseBody {
	s.Result = v
	return s
}

type ListTagsResponseBodyResult struct {
	// example:
	//
	// env
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// example:
	//
	// dev
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListTagsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListTagsResponseBodyResult) SetTagKey(v string) *ListTagsResponseBodyResult {
	s.TagKey = &v
	return s
}

func (s *ListTagsResponseBodyResult) SetTagValue(v string) *ListTagsResponseBodyResult {
	s.TagValue = &v
	return s
}

type ListTagsResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTagsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagsResponse) GoString() string {
	return s.String()
}

func (s *ListTagsResponse) SetHeaders(v map[string]*string) *ListTagsResponse {
	s.Headers = v
	return s
}

func (s *ListTagsResponse) SetStatusCode(v int32) *ListTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagsResponse) SetBody(v *ListTagsResponseBody) *ListTagsResponse {
	s.Body = v
	return s
}

type ListVpcEndpointsRequest struct {
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The number of entries to return on each page. Default value: 20.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListVpcEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointsRequest) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointsRequest) SetPage(v int32) *ListVpcEndpointsRequest {
	s.Page = &v
	return s
}

func (s *ListVpcEndpointsRequest) SetSize(v int32) *ListVpcEndpointsRequest {
	s.Size = &v
	return s
}

type ListVpcEndpointsResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the endpoints.
	Result []*ListVpcEndpointsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s ListVpcEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointsResponseBody) SetRequestId(v string) *ListVpcEndpointsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVpcEndpointsResponseBody) SetResult(v []*ListVpcEndpointsResponseBodyResult) *ListVpcEndpointsResponseBody {
	s.Result = v
	return s
}

type ListVpcEndpointsResponseBodyResult struct {
	// The status of the endpoint connection. Valid values:
	//
	// 	- Pending
	//
	// 	- Connecting
	//
	// 	- Connected
	//
	// 	- Disconnecting
	//
	// 	- Disconnected
	//
	// 	- Deleting
	//
	// 	- ServiceDeleted
	//
	// example:
	//
	// Disconnected
	ConnectionStatus *string `json:"connectionStatus,omitempty" xml:"connectionStatus,omitempty"`
	// The time when the endpoint was created.
	//
	// example:
	//
	// 2021-07-22T01:19:24Z
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// The business status of the endpoint. Valid values:
	//
	// 	- Normal
	//
	// 	- FinancialLocked
	//
	// example:
	//
	// Normal
	EndpointBusinessStatus *string `json:"endpointBusinessStatus,omitempty" xml:"endpointBusinessStatus,omitempty"`
	// The domain name of the endpoint. The domain name is used for connection configuration.
	//
	// example:
	//
	// ep-bp18s6wy9420wdi4****.epsrv-bp1bz3efowa4kc0****.cn-hangzhou.privatelink.aliyuncs.com
	EndpointDomain *string `json:"endpointDomain,omitempty" xml:"endpointDomain,omitempty"`
	// The ID of the endpoint.
	//
	// example:
	//
	// ep-bp1tah7zbrwmkjef****
	EndpointId *string `json:"endpointId,omitempty" xml:"endpointId,omitempty"`
	// The name of the endpoint.
	//
	// example:
	//
	// test
	EndpointName *string `json:"endpointName,omitempty" xml:"endpointName,omitempty"`
	// The status of the endpoint. Valid values:
	//
	// 	- Creating
	//
	// 	- Active
	//
	// 	- Pending
	//
	// 	- Deleting
	//
	// example:
	//
	// Active
	EndpointStatus *string `json:"endpointStatus,omitempty" xml:"endpointStatus,omitempty"`
	// The ID of the endpoint service with which the endpoint is associated.
	//
	// example:
	//
	// epsrv-bp1w0p3jdirbfmt6****
	ServiceId *string `json:"serviceId,omitempty" xml:"serviceId,omitempty"`
	// The name of the endpoint service with which the endpoint is associated.
	//
	// example:
	//
	// com.aliyuncs.privatelink.cn-hangzhou.epsrv-bp1w0p3jdirbfmt6****
	ServiceName *string `json:"serviceName,omitempty" xml:"serviceName,omitempty"`
}

func (s ListVpcEndpointsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointsResponseBodyResult) SetConnectionStatus(v string) *ListVpcEndpointsResponseBodyResult {
	s.ConnectionStatus = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetCreateTime(v string) *ListVpcEndpointsResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetEndpointBusinessStatus(v string) *ListVpcEndpointsResponseBodyResult {
	s.EndpointBusinessStatus = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetEndpointDomain(v string) *ListVpcEndpointsResponseBodyResult {
	s.EndpointDomain = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetEndpointId(v string) *ListVpcEndpointsResponseBodyResult {
	s.EndpointId = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetEndpointName(v string) *ListVpcEndpointsResponseBodyResult {
	s.EndpointName = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetEndpointStatus(v string) *ListVpcEndpointsResponseBodyResult {
	s.EndpointStatus = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetServiceId(v string) *ListVpcEndpointsResponseBodyResult {
	s.ServiceId = &v
	return s
}

func (s *ListVpcEndpointsResponseBodyResult) SetServiceName(v string) *ListVpcEndpointsResponseBodyResult {
	s.ServiceName = &v
	return s
}

type ListVpcEndpointsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListVpcEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListVpcEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVpcEndpointsResponse) GoString() string {
	return s.String()
}

func (s *ListVpcEndpointsResponse) SetHeaders(v map[string]*string) *ListVpcEndpointsResponse {
	s.Headers = v
	return s
}

func (s *ListVpcEndpointsResponse) SetStatusCode(v int32) *ListVpcEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVpcEndpointsResponse) SetBody(v *ListVpcEndpointsResponseBody) *ListVpcEndpointsResponse {
	s.Body = v
	return s
}

type MigrateToOtherZoneRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// Verify whether the zone node can be migrated. true indicates that the data is only verified and the migration task is not executed. false indicates that the migration task is executed after the verification is successful.
	//
	// This parameter is required.
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
}

func (s MigrateToOtherZoneRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateToOtherZoneRequest) GoString() string {
	return s.String()
}

func (s *MigrateToOtherZoneRequest) SetBody(v string) *MigrateToOtherZoneRequest {
	s.Body = &v
	return s
}

func (s *MigrateToOtherZoneRequest) SetDryRun(v bool) *MigrateToOtherZoneRequest {
	s.DryRun = &v
	return s
}

type MigrateToOtherZoneResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: migration succeeded
	//
	// 	- false: The migration fails
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s MigrateToOtherZoneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateToOtherZoneResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateToOtherZoneResponseBody) SetRequestId(v string) *MigrateToOtherZoneResponseBody {
	s.RequestId = &v
	return s
}

func (s *MigrateToOtherZoneResponseBody) SetResult(v bool) *MigrateToOtherZoneResponseBody {
	s.Result = &v
	return s
}

type MigrateToOtherZoneResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MigrateToOtherZoneResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s MigrateToOtherZoneResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateToOtherZoneResponse) GoString() string {
	return s.String()
}

func (s *MigrateToOtherZoneResponse) SetHeaders(v map[string]*string) *MigrateToOtherZoneResponse {
	s.Headers = v
	return s
}

func (s *MigrateToOtherZoneResponse) SetStatusCode(v int32) *MigrateToOtherZoneResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateToOtherZoneResponse) SetBody(v *MigrateToOtherZoneResponseBody) *MigrateToOtherZoneResponse {
	s.Body = v
	return s
}

type ModifyDeployMachineRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyDeployMachineRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDeployMachineRequest) GoString() string {
	return s.String()
}

func (s *ModifyDeployMachineRequest) SetClientToken(v string) *ModifyDeployMachineRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDeployMachineRequest) SetBody(v string) *ModifyDeployMachineRequest {
	s.Body = &v
	return s
}

type ModifyDeployMachineResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// C37CE536-6C0F-4778-9B59-6D94C7F7EB63
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the ECS instances are changed. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ModifyDeployMachineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDeployMachineResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDeployMachineResponseBody) SetRequestId(v string) *ModifyDeployMachineResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDeployMachineResponseBody) SetResult(v bool) *ModifyDeployMachineResponseBody {
	s.Result = &v
	return s
}

type ModifyDeployMachineResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyDeployMachineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyDeployMachineResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDeployMachineResponse) GoString() string {
	return s.String()
}

func (s *ModifyDeployMachineResponse) SetHeaders(v map[string]*string) *ModifyDeployMachineResponse {
	s.Headers = v
	return s
}

func (s *ModifyDeployMachineResponse) SetStatusCode(v int32) *ModifyDeployMachineResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDeployMachineResponse) SetBody(v *ModifyDeployMachineResponseBody) *ModifyDeployMachineResponse {
	s.Body = v
	return s
}

type ModifyElastictaskRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyElastictaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyElastictaskRequest) GoString() string {
	return s.String()
}

func (s *ModifyElastictaskRequest) SetBody(v string) *ModifyElastictaskRequest {
	s.Body = &v
	return s
}

type ModifyElastictaskResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *ModifyElastictaskResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s ModifyElastictaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyElastictaskResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyElastictaskResponseBody) SetRequestId(v string) *ModifyElastictaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyElastictaskResponseBody) SetResult(v *ModifyElastictaskResponseBodyResult) *ModifyElastictaskResponseBody {
	s.Result = v
	return s
}

type ModifyElastictaskResponseBodyResult struct {
	ElasticExpansionTask *ModifyElastictaskResponseBodyResultElasticExpansionTask `json:"elasticExpansionTask,omitempty" xml:"elasticExpansionTask,omitempty" type:"Struct"`
	ElasticShrinkTask    *ModifyElastictaskResponseBodyResultElasticShrinkTask    `json:"elasticShrinkTask,omitempty" xml:"elasticShrinkTask,omitempty" type:"Struct"`
}

func (s ModifyElastictaskResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ModifyElastictaskResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ModifyElastictaskResponseBodyResult) SetElasticExpansionTask(v *ModifyElastictaskResponseBodyResultElasticExpansionTask) *ModifyElastictaskResponseBodyResult {
	s.ElasticExpansionTask = v
	return s
}

func (s *ModifyElastictaskResponseBodyResult) SetElasticShrinkTask(v *ModifyElastictaskResponseBodyResultElasticShrinkTask) *ModifyElastictaskResponseBodyResult {
	s.ElasticShrinkTask = v
	return s
}

type ModifyElastictaskResponseBodyResultElasticExpansionTask struct {
	// example:
	//
	// 0 0 0 ? 	- MON
	CronExpression *string `json:"cronExpression,omitempty" xml:"cronExpression,omitempty"`
	// example:
	//
	// 2
	ElasticNodeCount *int32 `json:"elasticNodeCount,omitempty" xml:"elasticNodeCount,omitempty"`
	// example:
	//
	// 2
	ReplicaCount  *int32    `json:"replicaCount,omitempty" xml:"replicaCount,omitempty"`
	TargetIndices []*string `json:"targetIndices,omitempty" xml:"targetIndices,omitempty" type:"Repeated"`
	// example:
	//
	// crontab
	TriggerType *string `json:"triggerType,omitempty" xml:"triggerType,omitempty"`
}

func (s ModifyElastictaskResponseBodyResultElasticExpansionTask) String() string {
	return tea.Prettify(s)
}

func (s ModifyElastictaskResponseBodyResultElasticExpansionTask) GoString() string {
	return s.String()
}

func (s *ModifyElastictaskResponseBodyResultElasticExpansionTask) SetCronExpression(v string) *ModifyElastictaskResponseBodyResultElasticExpansionTask {
	s.CronExpression = &v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticExpansionTask) SetElasticNodeCount(v int32) *ModifyElastictaskResponseBodyResultElasticExpansionTask {
	s.ElasticNodeCount = &v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticExpansionTask) SetReplicaCount(v int32) *ModifyElastictaskResponseBodyResultElasticExpansionTask {
	s.ReplicaCount = &v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticExpansionTask) SetTargetIndices(v []*string) *ModifyElastictaskResponseBodyResultElasticExpansionTask {
	s.TargetIndices = v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticExpansionTask) SetTriggerType(v string) *ModifyElastictaskResponseBodyResultElasticExpansionTask {
	s.TriggerType = &v
	return s
}

type ModifyElastictaskResponseBodyResultElasticShrinkTask struct {
	// example:
	//
	// 4 4 4 ? 	- WED
	CronExpression *string `json:"cronExpression,omitempty" xml:"cronExpression,omitempty"`
	// example:
	//
	// 2
	ElasticNodeCount *int32 `json:"elasticNodeCount,omitempty" xml:"elasticNodeCount,omitempty"`
	// example:
	//
	// 2
	ReplicaCount  *int32    `json:"replicaCount,omitempty" xml:"replicaCount,omitempty"`
	TargetIndices []*string `json:"targetIndices,omitempty" xml:"targetIndices,omitempty" type:"Repeated"`
	// example:
	//
	// crontab
	TriggerType *string `json:"triggerType,omitempty" xml:"triggerType,omitempty"`
}

func (s ModifyElastictaskResponseBodyResultElasticShrinkTask) String() string {
	return tea.Prettify(s)
}

func (s ModifyElastictaskResponseBodyResultElasticShrinkTask) GoString() string {
	return s.String()
}

func (s *ModifyElastictaskResponseBodyResultElasticShrinkTask) SetCronExpression(v string) *ModifyElastictaskResponseBodyResultElasticShrinkTask {
	s.CronExpression = &v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticShrinkTask) SetElasticNodeCount(v int32) *ModifyElastictaskResponseBodyResultElasticShrinkTask {
	s.ElasticNodeCount = &v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticShrinkTask) SetReplicaCount(v int32) *ModifyElastictaskResponseBodyResultElasticShrinkTask {
	s.ReplicaCount = &v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticShrinkTask) SetTargetIndices(v []*string) *ModifyElastictaskResponseBodyResultElasticShrinkTask {
	s.TargetIndices = v
	return s
}

func (s *ModifyElastictaskResponseBodyResultElasticShrinkTask) SetTriggerType(v string) *ModifyElastictaskResponseBodyResultElasticShrinkTask {
	s.TriggerType = &v
	return s
}

type ModifyElastictaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyElastictaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyElastictaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyElastictaskResponse) GoString() string {
	return s.String()
}

func (s *ModifyElastictaskResponse) SetHeaders(v map[string]*string) *ModifyElastictaskResponse {
	s.Headers = v
	return s
}

func (s *ModifyElastictaskResponse) SetStatusCode(v int32) *ModifyElastictaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyElastictaskResponse) SetBody(v *ModifyElastictaskResponseBody) *ModifyElastictaskResponse {
	s.Body = v
	return s
}

type ModifyInstanceMaintainTimeRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// example:
	//
	// {     "openMaintainTime": true,     "maintainStartTime": "03:00Z",     "maintainEndTime": "04:00Z" }
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyInstanceMaintainTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceMaintainTimeRequest) GoString() string {
	return s.String()
}

func (s *ModifyInstanceMaintainTimeRequest) SetClientToken(v string) *ModifyInstanceMaintainTimeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyInstanceMaintainTimeRequest) SetBody(v string) *ModifyInstanceMaintainTimeRequest {
	s.Body = &v
	return s
}

type ModifyInstanceMaintainTimeResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ModifyInstanceMaintainTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceMaintainTimeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyInstanceMaintainTimeResponseBody) SetRequestId(v string) *ModifyInstanceMaintainTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyInstanceMaintainTimeResponseBody) SetResult(v bool) *ModifyInstanceMaintainTimeResponseBody {
	s.Result = &v
	return s
}

type ModifyInstanceMaintainTimeResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyInstanceMaintainTimeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyInstanceMaintainTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceMaintainTimeResponse) GoString() string {
	return s.String()
}

func (s *ModifyInstanceMaintainTimeResponse) SetHeaders(v map[string]*string) *ModifyInstanceMaintainTimeResponse {
	s.Headers = v
	return s
}

func (s *ModifyInstanceMaintainTimeResponse) SetStatusCode(v int32) *ModifyInstanceMaintainTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyInstanceMaintainTimeResponse) SetBody(v *ModifyInstanceMaintainTimeResponseBody) *ModifyInstanceMaintainTimeResponse {
	s.Body = v
	return s
}

type ModifyWhiteIpsRequest struct {
	// The information about the IP address whitelist that you want to update. You can specify only one whitelist.
	//
	// > You cannot configure both the whiteIpList and whiteIpGroup parameters.
	//
	// example:
	//
	// Cover
	ModifyMode *string `json:"modifyMode,omitempty" xml:"modifyMode,omitempty"`
	// The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.
	//
	// > You cannot configure both the whiteIpList and whiteIpGroup parameters.
	//
	// example:
	//
	// PUBLIC
	NetworkType *string `json:"networkType,omitempty" xml:"networkType,omitempty"`
	// The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
	// The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.
	WhiteIpGroup *ModifyWhiteIpsRequestWhiteIpGroup `json:"whiteIpGroup,omitempty" xml:"whiteIpGroup,omitempty" type:"Struct"`
	// The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.
	WhiteIpList []*string `json:"whiteIpList,omitempty" xml:"whiteIpList,omitempty" type:"Repeated"`
	// The network type. This parameter is required if you configure the whiteIpList parameter. Valid values:
	//
	// 	- PRIVATE
	//
	// 	- PUBLIC
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s ModifyWhiteIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhiteIpsRequest) GoString() string {
	return s.String()
}

func (s *ModifyWhiteIpsRequest) SetModifyMode(v string) *ModifyWhiteIpsRequest {
	s.ModifyMode = &v
	return s
}

func (s *ModifyWhiteIpsRequest) SetNetworkType(v string) *ModifyWhiteIpsRequest {
	s.NetworkType = &v
	return s
}

func (s *ModifyWhiteIpsRequest) SetNodeType(v string) *ModifyWhiteIpsRequest {
	s.NodeType = &v
	return s
}

func (s *ModifyWhiteIpsRequest) SetWhiteIpGroup(v *ModifyWhiteIpsRequestWhiteIpGroup) *ModifyWhiteIpsRequest {
	s.WhiteIpGroup = v
	return s
}

func (s *ModifyWhiteIpsRequest) SetWhiteIpList(v []*string) *ModifyWhiteIpsRequest {
	s.WhiteIpList = v
	return s
}

func (s *ModifyWhiteIpsRequest) SetClientToken(v string) *ModifyWhiteIpsRequest {
	s.ClientToken = &v
	return s
}

type ModifyWhiteIpsRequestWhiteIpGroup struct {
	// The type of the IP address whitelist. Valid values:
	//
	// 	- PRIVATE_KIBANA
	//
	// 	- PRIVATE_ES
	//
	// 	- PUBLIC_ES
	//
	// 	- PUBLIC_KIBANA
	//
	// example:
	//
	// test_group
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	// The returned result.
	Ips []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
	// The request ID.
	//
	// example:
	//
	// PRIVATE_ES
	WhiteIpType *string `json:"whiteIpType,omitempty" xml:"whiteIpType,omitempty"`
}

func (s ModifyWhiteIpsRequestWhiteIpGroup) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhiteIpsRequestWhiteIpGroup) GoString() string {
	return s.String()
}

func (s *ModifyWhiteIpsRequestWhiteIpGroup) SetGroupName(v string) *ModifyWhiteIpsRequestWhiteIpGroup {
	s.GroupName = &v
	return s
}

func (s *ModifyWhiteIpsRequestWhiteIpGroup) SetIps(v []*string) *ModifyWhiteIpsRequestWhiteIpGroup {
	s.Ips = v
	return s
}

func (s *ModifyWhiteIpsRequestWhiteIpGroup) SetWhiteIpType(v string) *ModifyWhiteIpsRequestWhiteIpGroup {
	s.WhiteIpType = &v
	return s
}

type ModifyWhiteIpsResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1DERFG
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ModifyWhiteIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhiteIpsResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWhiteIpsResponseBody) SetRequestId(v string) *ModifyWhiteIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyWhiteIpsResponseBody) SetResult(v bool) *ModifyWhiteIpsResponseBody {
	s.Result = &v
	return s
}

type ModifyWhiteIpsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWhiteIpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWhiteIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWhiteIpsResponse) GoString() string {
	return s.String()
}

func (s *ModifyWhiteIpsResponse) SetHeaders(v map[string]*string) *ModifyWhiteIpsResponse {
	s.Headers = v
	return s
}

func (s *ModifyWhiteIpsResponse) SetStatusCode(v int32) *ModifyWhiteIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWhiteIpsResponse) SetBody(v *ModifyWhiteIpsResponseBody) *ModifyWhiteIpsResponse {
	s.Body = v
	return s
}

type MoveResourceGroupRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s MoveResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupRequest) SetBody(v string) *MoveResourceGroupRequest {
	s.Body = &v
	return s
}

func (s *MoveResourceGroupRequest) SetClientToken(v string) *MoveResourceGroupRequest {
	s.ClientToken = &v
	return s
}

type MoveResourceGroupResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *MoveResourceGroupResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s MoveResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBody) SetRequestId(v string) *MoveResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *MoveResourceGroupResponseBody) SetResult(v *MoveResourceGroupResponseBodyResult) *MoveResourceGroupResponseBody {
	s.Result = v
	return s
}

type MoveResourceGroupResponseBodyResult struct {
	// The time when the cluster was created.
	//
	// example:
	//
	// 2020-07-06T10:18:48.662Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The name of the cluster.
	//
	// example:
	//
	// es-cn-abc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The configurations of IK dictionaries.
	DictList []*MoveResourceGroupResponseBodyResultDictList `json:"dictList,omitempty" xml:"dictList,omitempty" type:"Repeated"`
	// The internal endpoint of the cluster.
	//
	// example:
	//
	// es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com
	Domain *string `json:"domain,omitempty" xml:"domain,omitempty"`
	// The version of the cluster.
	//
	// example:
	//
	// 6.7.0_with_X-Pack
	EsVersion *string `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	// The ID of the cluster.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The configurations of Kibana nodes.
	KibanaConfiguration *MoveResourceGroupResponseBodyResultKibanaConfiguration `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty" type:"Struct"`
	// The public endpoint of the Kibana console of the cluster.
	//
	// example:
	//
	// es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com
	KibanaDomain *string `json:"kibanaDomain,omitempty" xml:"kibanaDomain,omitempty"`
	// The port number that is used to access the Kibana console of the cluster over the Internet.
	//
	// example:
	//
	// 5601
	KibanaPort *int32 `json:"kibanaPort,omitempty" xml:"kibanaPort,omitempty"`
	// The configurations of dedicated master nodes.
	MasterConfiguration *MoveResourceGroupResponseBodyResultMasterConfiguration `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty" type:"Struct"`
	// The network configurations.
	NetworkConfig *MoveResourceGroupResponseBodyResultNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	// The number of data nodes in the cluster.
	//
	// example:
	//
	// 2
	NodeAmount *int32 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// The configurations of data nodes.
	NodeSpec *MoveResourceGroupResponseBodyResultNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// The billing method of the cluster. Valid values:
	//
	// 	- prepaid: subscription
	//
	// 	- postpaid: pay-as-you-go
	//
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// The public endpoint of the cluster.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com
	PublicDomain *string `json:"publicDomain,omitempty" xml:"publicDomain,omitempty"`
	// The port number that is used to access the cluster over the Internet.
	//
	// example:
	//
	// 9200
	PublicPort *int32 `json:"publicPort,omitempty" xml:"publicPort,omitempty"`
	// The status of the cluster. Valid values:
	//
	// 	- active: The cluster is normal.
	//
	// 	- activating: The cluster is being activated.
	//
	// 	- Inactive: The cluster is frozen.
	//
	// 	- invalid: The cluster is valid.
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The configurations of synonym dictionaries.
	SynonymsDicts []*MoveResourceGroupResponseBodyResultSynonymsDicts `json:"synonymsDicts,omitempty" xml:"synonymsDicts,omitempty" type:"Repeated"`
	// The time when the cluster was last updated.
	//
	// example:
	//
	// 2018-07-18T10:10:04.484Z
	UpdatedAt *string `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
}

func (s MoveResourceGroupResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBodyResult) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBodyResult) SetCreatedAt(v string) *MoveResourceGroupResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetDescription(v string) *MoveResourceGroupResponseBodyResult {
	s.Description = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetDictList(v []*MoveResourceGroupResponseBodyResultDictList) *MoveResourceGroupResponseBodyResult {
	s.DictList = v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetDomain(v string) *MoveResourceGroupResponseBodyResult {
	s.Domain = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetEsVersion(v string) *MoveResourceGroupResponseBodyResult {
	s.EsVersion = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetInstanceId(v string) *MoveResourceGroupResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetKibanaConfiguration(v *MoveResourceGroupResponseBodyResultKibanaConfiguration) *MoveResourceGroupResponseBodyResult {
	s.KibanaConfiguration = v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetKibanaDomain(v string) *MoveResourceGroupResponseBodyResult {
	s.KibanaDomain = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetKibanaPort(v int32) *MoveResourceGroupResponseBodyResult {
	s.KibanaPort = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetMasterConfiguration(v *MoveResourceGroupResponseBodyResultMasterConfiguration) *MoveResourceGroupResponseBodyResult {
	s.MasterConfiguration = v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetNetworkConfig(v *MoveResourceGroupResponseBodyResultNetworkConfig) *MoveResourceGroupResponseBodyResult {
	s.NetworkConfig = v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetNodeAmount(v int32) *MoveResourceGroupResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetNodeSpec(v *MoveResourceGroupResponseBodyResultNodeSpec) *MoveResourceGroupResponseBodyResult {
	s.NodeSpec = v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetPaymentType(v string) *MoveResourceGroupResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetPublicDomain(v string) *MoveResourceGroupResponseBodyResult {
	s.PublicDomain = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetPublicPort(v int32) *MoveResourceGroupResponseBodyResult {
	s.PublicPort = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetStatus(v string) *MoveResourceGroupResponseBodyResult {
	s.Status = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetSynonymsDicts(v []*MoveResourceGroupResponseBodyResultSynonymsDicts) *MoveResourceGroupResponseBodyResult {
	s.SynonymsDicts = v
	return s
}

func (s *MoveResourceGroupResponseBodyResult) SetUpdatedAt(v string) *MoveResourceGroupResponseBodyResult {
	s.UpdatedAt = &v
	return s
}

type MoveResourceGroupResponseBodyResultDictList struct {
	// The size of the dictionary file. Unit: bytes.
	//
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The type of the source of the dictionary file. Valid values:
	//
	// 	- OSS: Object Storage Service (OSS). You must make sure that the access control list (ACL) of the related OSS bucket is public read.
	//
	// 	- ORIGIN: previously uploaded dictionary.
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The type of the dictionary. Valid values:
	//
	// 	- STOP: stopword list
	//
	// 	- MAIN: main dictionary
	//
	// 	- SYNONYMS: synonym dictionary
	//
	// 	- ALI_WS: Alibaba Cloud dictionary
	//
	// example:
	//
	// MAIN
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s MoveResourceGroupResponseBodyResultDictList) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBodyResultDictList) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBodyResultDictList) SetFileSize(v int64) *MoveResourceGroupResponseBodyResultDictList {
	s.FileSize = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultDictList) SetName(v string) *MoveResourceGroupResponseBodyResultDictList {
	s.Name = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultDictList) SetSourceType(v string) *MoveResourceGroupResponseBodyResultDictList {
	s.SourceType = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultDictList) SetType(v string) *MoveResourceGroupResponseBodyResultDictList {
	s.Type = &v
	return s
}

type MoveResourceGroupResponseBodyResultKibanaConfiguration struct {
	// The number of nodes.
	//
	// example:
	//
	// 1
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The storage capacity. Unit: GB.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The specification category.
	//
	// example:
	//
	// elasticsearch.n4.small
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s MoveResourceGroupResponseBodyResultKibanaConfiguration) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBodyResultKibanaConfiguration) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBodyResultKibanaConfiguration) SetAmount(v int32) *MoveResourceGroupResponseBodyResultKibanaConfiguration {
	s.Amount = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultKibanaConfiguration) SetDisk(v int32) *MoveResourceGroupResponseBodyResultKibanaConfiguration {
	s.Disk = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultKibanaConfiguration) SetDiskType(v string) *MoveResourceGroupResponseBodyResultKibanaConfiguration {
	s.DiskType = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultKibanaConfiguration) SetSpec(v string) *MoveResourceGroupResponseBodyResultKibanaConfiguration {
	s.Spec = &v
	return s
}

type MoveResourceGroupResponseBodyResultMasterConfiguration struct {
	// The number of nodes.
	//
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The storage capacity. Unit: GB.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The specification category.
	//
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s MoveResourceGroupResponseBodyResultMasterConfiguration) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBodyResultMasterConfiguration) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBodyResultMasterConfiguration) SetAmount(v int32) *MoveResourceGroupResponseBodyResultMasterConfiguration {
	s.Amount = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultMasterConfiguration) SetDisk(v int32) *MoveResourceGroupResponseBodyResultMasterConfiguration {
	s.Disk = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultMasterConfiguration) SetDiskType(v string) *MoveResourceGroupResponseBodyResultMasterConfiguration {
	s.DiskType = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultMasterConfiguration) SetSpec(v string) *MoveResourceGroupResponseBodyResultMasterConfiguration {
	s.Spec = &v
	return s
}

type MoveResourceGroupResponseBodyResultNetworkConfig struct {
	// The network type. Only the VPC is supported.
	//
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The ID of the virtual private cloud (VPC).
	//
	// example:
	//
	// vpc-bp16k1dvzxtmagcva****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// The zone where the cluster resides.
	//
	// example:
	//
	// cn-hangzhou-i
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// The ID of the vSwitch.
	//
	// example:
	//
	// vsw-bp1k4ec6s7sjdbudw****
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s MoveResourceGroupResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBodyResultNetworkConfig) SetType(v string) *MoveResourceGroupResponseBodyResultNetworkConfig {
	s.Type = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultNetworkConfig) SetVpcId(v string) *MoveResourceGroupResponseBodyResultNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultNetworkConfig) SetVsArea(v string) *MoveResourceGroupResponseBodyResultNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultNetworkConfig) SetVswitchId(v string) *MoveResourceGroupResponseBodyResultNetworkConfig {
	s.VswitchId = &v
	return s
}

type MoveResourceGroupResponseBodyResultNodeSpec struct {
	// The storage capacity. Unit: GB.
	//
	// example:
	//
	// 50
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The specification category.
	//
	// example:
	//
	// elasticsearch.n4.small
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s MoveResourceGroupResponseBodyResultNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBodyResultNodeSpec) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBodyResultNodeSpec) SetDisk(v int32) *MoveResourceGroupResponseBodyResultNodeSpec {
	s.Disk = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultNodeSpec) SetDiskType(v string) *MoveResourceGroupResponseBodyResultNodeSpec {
	s.DiskType = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultNodeSpec) SetSpec(v string) *MoveResourceGroupResponseBodyResultNodeSpec {
	s.Spec = &v
	return s
}

type MoveResourceGroupResponseBodyResultSynonymsDicts struct {
	// The size of the dictionary file. Unit: bytes.
	//
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The type of the source of the dictionary file. Valid values:
	//
	// 	- OSS: Object Storage Service (OSS). You must make sure that the ACL of the related OSS bucket is public read.
	//
	// 	- ORIGIN: previously uploaded dictionary.
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The type of the dictionary. Valid values:
	//
	// 	- STOP: stopword list
	//
	// 	- MAIN: main dictionary
	//
	// 	- SYNONYMS: synonym dictionary
	//
	// 	- ALI_WS: Alibaba Cloud dictionary
	//
	// example:
	//
	// STOP
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s MoveResourceGroupResponseBodyResultSynonymsDicts) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBodyResultSynonymsDicts) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBodyResultSynonymsDicts) SetFileSize(v int64) *MoveResourceGroupResponseBodyResultSynonymsDicts {
	s.FileSize = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultSynonymsDicts) SetName(v string) *MoveResourceGroupResponseBodyResultSynonymsDicts {
	s.Name = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultSynonymsDicts) SetSourceType(v string) *MoveResourceGroupResponseBodyResultSynonymsDicts {
	s.SourceType = &v
	return s
}

func (s *MoveResourceGroupResponseBodyResultSynonymsDicts) SetType(v string) *MoveResourceGroupResponseBodyResultSynonymsDicts {
	s.Type = &v
	return s
}

type MoveResourceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MoveResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s MoveResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponse) SetHeaders(v map[string]*string) *MoveResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *MoveResourceGroupResponse) SetStatusCode(v int32) *MoveResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveResourceGroupResponse) SetBody(v *MoveResourceGroupResponseBody) *MoveResourceGroupResponse {
	s.Body = v
	return s
}

type OpenDiagnosisRequest struct {
	// The ID of the request.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// example:
	//
	// en
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s OpenDiagnosisRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenDiagnosisRequest) GoString() string {
	return s.String()
}

func (s *OpenDiagnosisRequest) SetClientToken(v string) *OpenDiagnosisRequest {
	s.ClientToken = &v
	return s
}

func (s *OpenDiagnosisRequest) SetLang(v string) *OpenDiagnosisRequest {
	s.Lang = &v
	return s
}

type OpenDiagnosisResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s OpenDiagnosisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenDiagnosisResponseBody) GoString() string {
	return s.String()
}

func (s *OpenDiagnosisResponseBody) SetRequestId(v string) *OpenDiagnosisResponseBody {
	s.RequestId = &v
	return s
}

func (s *OpenDiagnosisResponseBody) SetResult(v bool) *OpenDiagnosisResponseBody {
	s.Result = &v
	return s
}

type OpenDiagnosisResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *OpenDiagnosisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s OpenDiagnosisResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenDiagnosisResponse) GoString() string {
	return s.String()
}

func (s *OpenDiagnosisResponse) SetHeaders(v map[string]*string) *OpenDiagnosisResponse {
	s.Headers = v
	return s
}

func (s *OpenDiagnosisResponse) SetStatusCode(v int32) *OpenDiagnosisResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenDiagnosisResponse) SetBody(v *OpenDiagnosisResponseBody) *OpenDiagnosisResponse {
	s.Body = v
	return s
}

type OpenHttpsRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s OpenHttpsRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenHttpsRequest) GoString() string {
	return s.String()
}

func (s *OpenHttpsRequest) SetClientToken(v string) *OpenHttpsRequest {
	s.ClientToken = &v
	return s
}

type OpenHttpsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: open the HTTPS protocol successfully
	//
	// 	- false: open the HTTPS protocol failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s OpenHttpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenHttpsResponseBody) GoString() string {
	return s.String()
}

func (s *OpenHttpsResponseBody) SetRequestId(v string) *OpenHttpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *OpenHttpsResponseBody) SetResult(v bool) *OpenHttpsResponseBody {
	s.Result = &v
	return s
}

type OpenHttpsResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *OpenHttpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s OpenHttpsResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenHttpsResponse) GoString() string {
	return s.String()
}

func (s *OpenHttpsResponse) SetHeaders(v map[string]*string) *OpenHttpsResponse {
	s.Headers = v
	return s
}

func (s *OpenHttpsResponse) SetStatusCode(v int32) *OpenHttpsResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenHttpsResponse) SetBody(v *OpenHttpsResponseBody) *OpenHttpsResponse {
	s.Body = v
	return s
}

type PostEmonTryAlarmRuleRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s PostEmonTryAlarmRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s PostEmonTryAlarmRuleRequest) GoString() string {
	return s.String()
}

func (s *PostEmonTryAlarmRuleRequest) SetBody(v string) *PostEmonTryAlarmRuleRequest {
	s.Body = &v
	return s
}

type PostEmonTryAlarmRuleResponseBody struct {
	// example:
	//
	// 200
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// example:
	//
	// ""
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// example:
	//
	// 3EC5731F-0944-4E4F-9DD5-1F976B3FCC3D
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PostEmonTryAlarmRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PostEmonTryAlarmRuleResponseBody) GoString() string {
	return s.String()
}

func (s *PostEmonTryAlarmRuleResponseBody) SetCode(v string) *PostEmonTryAlarmRuleResponseBody {
	s.Code = &v
	return s
}

func (s *PostEmonTryAlarmRuleResponseBody) SetMessage(v string) *PostEmonTryAlarmRuleResponseBody {
	s.Message = &v
	return s
}

func (s *PostEmonTryAlarmRuleResponseBody) SetRequestId(v string) *PostEmonTryAlarmRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *PostEmonTryAlarmRuleResponseBody) SetSuccess(v bool) *PostEmonTryAlarmRuleResponseBody {
	s.Success = &v
	return s
}

type PostEmonTryAlarmRuleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *PostEmonTryAlarmRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s PostEmonTryAlarmRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s PostEmonTryAlarmRuleResponse) GoString() string {
	return s.String()
}

func (s *PostEmonTryAlarmRuleResponse) SetHeaders(v map[string]*string) *PostEmonTryAlarmRuleResponse {
	s.Headers = v
	return s
}

func (s *PostEmonTryAlarmRuleResponse) SetStatusCode(v int32) *PostEmonTryAlarmRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *PostEmonTryAlarmRuleResponse) SetBody(v *PostEmonTryAlarmRuleResponseBody) *PostEmonTryAlarmRuleResponse {
	s.Body = v
	return s
}

type RecommendTemplatesRequest struct {
	// *
	//
	// *
	//
	// *
	//
	// *
	//
	// *
	//
	// **
	//
	// ****
	//
	// This parameter is required.
	//
	// example:
	//
	// general
	UsageScenario *string `json:"usageScenario,omitempty" xml:"usageScenario,omitempty"`
}

func (s RecommendTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s RecommendTemplatesRequest) GoString() string {
	return s.String()
}

func (s *RecommendTemplatesRequest) SetUsageScenario(v string) *RecommendTemplatesRequest {
	s.UsageScenario = &v
	return s
}

type RecommendTemplatesResponseBody struct {
	// example:
	//
	// 66B060CF-7381-49C7-9B89-7757927FDA16
	RequestId *string                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*RecommendTemplatesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s RecommendTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecommendTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *RecommendTemplatesResponseBody) SetRequestId(v string) *RecommendTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *RecommendTemplatesResponseBody) SetResult(v []*RecommendTemplatesResponseBodyResult) *RecommendTemplatesResponseBody {
	s.Result = v
	return s
}

type RecommendTemplatesResponseBodyResult struct {
	// example:
	//
	// {\\n\\t\\"persistent\\": {\\n\\t\\t\\"search\\": {\\n\\t\\t\\t\\"max_buckets\\": \\"10000\\"\\n\\t\\t}\\n\\t}\\n}
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// *
	//
	// *
	//
	// *
	//
	// *
	//
	// **
	//
	// ****
	//
	// example:
	//
	// dynamicSettings
	TemplateName *string `json:"templateName,omitempty" xml:"templateName,omitempty"`
}

func (s RecommendTemplatesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s RecommendTemplatesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *RecommendTemplatesResponseBodyResult) SetContent(v string) *RecommendTemplatesResponseBodyResult {
	s.Content = &v
	return s
}

func (s *RecommendTemplatesResponseBodyResult) SetTemplateName(v string) *RecommendTemplatesResponseBodyResult {
	s.TemplateName = &v
	return s
}

type RecommendTemplatesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RecommendTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RecommendTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s RecommendTemplatesResponse) GoString() string {
	return s.String()
}

func (s *RecommendTemplatesResponse) SetHeaders(v map[string]*string) *RecommendTemplatesResponse {
	s.Headers = v
	return s
}

func (s *RecommendTemplatesResponse) SetStatusCode(v int32) *RecommendTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *RecommendTemplatesResponse) SetBody(v *RecommendTemplatesResponseBody) *RecommendTemplatesResponse {
	s.Body = v
	return s
}

type ReinstallCollectorRequest struct {
	// The request body parameters. For more information, see the Request body section in this topic.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Indicates whether the shipper is installed. Valid values:
	//
	// 	- true: The shipper is installed.
	//
	// 	- false: The shipper fails to be installed.
	//
	// example:
	//
	// {
	//
	//   "restartType": "nodeEcsId",
	//
	//   "nodes":["i-bp1gyhphjaj73jsr****","i-bp10piq1mkfnyw9t****"]
	//
	// }
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ReinstallCollectorRequest) String() string {
	return tea.Prettify(s)
}

func (s ReinstallCollectorRequest) GoString() string {
	return s.String()
}

func (s *ReinstallCollectorRequest) SetClientToken(v string) *ReinstallCollectorRequest {
	s.ClientToken = &v
	return s
}

func (s *ReinstallCollectorRequest) SetBody(v string) *ReinstallCollectorRequest {
	s.Body = &v
	return s
}

type ReinstallCollectorResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ReinstallCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReinstallCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *ReinstallCollectorResponseBody) SetRequestId(v string) *ReinstallCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReinstallCollectorResponseBody) SetResult(v bool) *ReinstallCollectorResponseBody {
	s.Result = &v
	return s
}

type ReinstallCollectorResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ReinstallCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ReinstallCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s ReinstallCollectorResponse) GoString() string {
	return s.String()
}

func (s *ReinstallCollectorResponse) SetHeaders(v map[string]*string) *ReinstallCollectorResponse {
	s.Headers = v
	return s
}

func (s *ReinstallCollectorResponse) SetStatusCode(v int32) *ReinstallCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *ReinstallCollectorResponse) SetBody(v *ReinstallCollectorResponseBody) *ReinstallCollectorResponse {
	s.Body = v
	return s
}

type RemoveApmResponseBody struct {
	// example:
	//
	// 29A879FB-86BF-54CA-9426-B769A099E1A1
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s RemoveApmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveApmResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveApmResponseBody) SetRequestId(v string) *RemoveApmResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveApmResponseBody) SetResult(v bool) *RemoveApmResponseBody {
	s.Result = &v
	return s
}

type RemoveApmResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RemoveApmResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RemoveApmResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveApmResponse) GoString() string {
	return s.String()
}

func (s *RemoveApmResponse) SetHeaders(v map[string]*string) *RemoveApmResponse {
	s.Headers = v
	return s
}

func (s *RemoveApmResponse) SetStatusCode(v int32) *RemoveApmResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveApmResponse) SetBody(v *RemoveApmResponseBody) *RemoveApmResponse {
	s.Body = v
	return s
}

type RenewInstanceRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B350****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s RenewInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RenewInstanceRequest) GoString() string {
	return s.String()
}

func (s *RenewInstanceRequest) SetBody(v string) *RenewInstanceRequest {
	s.Body = &v
	return s
}

func (s *RenewInstanceRequest) SetClientToken(v string) *RenewInstanceRequest {
	s.ClientToken = &v
	return s
}

type RenewInstanceResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: renewal successfully
	//
	// 	- false: renewal failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s RenewInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RenewInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RenewInstanceResponseBody) SetRequestId(v string) *RenewInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *RenewInstanceResponseBody) SetResult(v bool) *RenewInstanceResponseBody {
	s.Result = &v
	return s
}

type RenewInstanceResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RenewInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RenewInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RenewInstanceResponse) GoString() string {
	return s.String()
}

func (s *RenewInstanceResponse) SetHeaders(v map[string]*string) *RenewInstanceResponse {
	s.Headers = v
	return s
}

func (s *RenewInstanceResponse) SetStatusCode(v int32) *RenewInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RenewInstanceResponse) SetBody(v *RenewInstanceResponseBody) *RenewInstanceResponse {
	s.Body = v
	return s
}

type RenewLogstashRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s RenewLogstashRequest) String() string {
	return tea.Prettify(s)
}

func (s RenewLogstashRequest) GoString() string {
	return s.String()
}

func (s *RenewLogstashRequest) SetBody(v string) *RenewLogstashRequest {
	s.Body = &v
	return s
}

func (s *RenewLogstashRequest) SetClientToken(v string) *RenewLogstashRequest {
	s.ClientToken = &v
	return s
}

type RenewLogstashResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result. Valid values:
	//
	// 	- true: The cluster is renewed.
	//
	// 	- false: The cluster fails to be renewed.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s RenewLogstashResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RenewLogstashResponseBody) GoString() string {
	return s.String()
}

func (s *RenewLogstashResponseBody) SetRequestId(v string) *RenewLogstashResponseBody {
	s.RequestId = &v
	return s
}

func (s *RenewLogstashResponseBody) SetResult(v bool) *RenewLogstashResponseBody {
	s.Result = &v
	return s
}

type RenewLogstashResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RenewLogstashResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RenewLogstashResponse) String() string {
	return tea.Prettify(s)
}

func (s RenewLogstashResponse) GoString() string {
	return s.String()
}

func (s *RenewLogstashResponse) SetHeaders(v map[string]*string) *RenewLogstashResponse {
	s.Headers = v
	return s
}

func (s *RenewLogstashResponse) SetStatusCode(v int32) *RenewLogstashResponse {
	s.StatusCode = &v
	return s
}

func (s *RenewLogstashResponse) SetBody(v *RenewLogstashResponseBody) *RenewLogstashResponse {
	s.Body = v
	return s
}

type RestartCollectorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s RestartCollectorRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartCollectorRequest) GoString() string {
	return s.String()
}

func (s *RestartCollectorRequest) SetClientToken(v string) *RestartCollectorRequest {
	s.ClientToken = &v
	return s
}

type RestartCollectorResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 84B4038A-AF38-4BF4-9FAD-EA92A4FFF00A
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the shipper is restarted. Valid values:
	//
	// 	- true: The shipper is restarted.
	//
	// 	- false: The shipper fails to be restarted.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s RestartCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *RestartCollectorResponseBody) SetRequestId(v string) *RestartCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartCollectorResponseBody) SetResult(v bool) *RestartCollectorResponseBody {
	s.Result = &v
	return s
}

type RestartCollectorResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RestartCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RestartCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartCollectorResponse) GoString() string {
	return s.String()
}

func (s *RestartCollectorResponse) SetHeaders(v map[string]*string) *RestartCollectorResponse {
	s.Headers = v
	return s
}

func (s *RestartCollectorResponse) SetStatusCode(v int32) *RestartCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartCollectorResponse) SetBody(v *RestartCollectorResponseBody) *RestartCollectorResponse {
	s.Body = v
	return s
}

type RestartInstanceRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. The maximum length of the token is 64 ASCII characters.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// Specifies whether to ignore the status of the instance and forcibly restart the instance.
	//
	// example:
	//
	// false
	Force *bool `json:"force,omitempty" xml:"force,omitempty"`
}

func (s RestartInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceRequest) GoString() string {
	return s.String()
}

func (s *RestartInstanceRequest) SetBody(v string) *RestartInstanceRequest {
	s.Body = &v
	return s
}

func (s *RestartInstanceRequest) SetClientToken(v string) *RestartInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *RestartInstanceRequest) SetForce(v bool) *RestartInstanceRequest {
	s.Force = &v
	return s
}

type RestartInstanceResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result *RestartInstanceResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s RestartInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBody) SetRequestId(v string) *RestartInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartInstanceResponseBody) SetResult(v *RestartInstanceResponseBodyResult) *RestartInstanceResponseBody {
	s.Result = v
	return s
}

type RestartInstanceResponseBodyResult struct {
	// The time when the instance was created.
	//
	// example:
	//
	// 2020-07-06T10:18:48.662Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The name of the instance.
	//
	// example:
	//
	// es-cn-abc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The configuration of the IK dictionaries.
	DictList []*RestartInstanceResponseBodyResultDictList `json:"dictList,omitempty" xml:"dictList,omitempty" type:"Repeated"`
	// The intranet access address of the instance.
	//
	// example:
	//
	// es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com
	Domain *string `json:"domain,omitempty" xml:"domain,omitempty"`
	// The version of the instance.
	//
	// example:
	//
	// 6.7.0_with_X-Pack
	EsVersion *string `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	// The ID of the instance.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The configuration of Kibana nodes.
	KibanaConfiguration *RestartInstanceResponseBodyResultKibanaConfiguration `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty" type:"Struct"`
	// The public network access address of Kibana.
	//
	// example:
	//
	// es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com
	KibanaDomain *string `json:"kibanaDomain,omitempty" xml:"kibanaDomain,omitempty"`
	// The public port of the Kibana network.
	//
	// example:
	//
	// 5601
	KibanaPort *int32 `json:"kibanaPort,omitempty" xml:"kibanaPort,omitempty"`
	// The configuration of dedicated master nodes.
	MasterConfiguration *RestartInstanceResponseBodyResultMasterConfiguration `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty" type:"Struct"`
	// The network configuration.
	NetworkConfig *RestartInstanceResponseBodyResultNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
	// The number of data nodes.
	//
	// example:
	//
	// 2
	NodeAmount *int32 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// The configuration of data nodes.
	NodeSpec *RestartInstanceResponseBodyResultNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// The billing method of the created ECS instance.
	//
	// Valid values: prepaid and postpaid.
	//
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// The public network access address.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com
	PublicDomain *string `json:"publicDomain,omitempty" xml:"publicDomain,omitempty"`
	// The public network port.
	//
	// example:
	//
	// 9200
	PublicPort *int32 `json:"publicPort,omitempty" xml:"publicPort,omitempty"`
	// The state of the cluster.
	//
	// Supported: active (normal), activating (initializing), inactive (blocked), and invalid (expired).
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The configuration of the synonym dictionaries.
	SynonymsDicts []*RestartInstanceResponseBodyResultSynonymsDicts `json:"synonymsDicts,omitempty" xml:"synonymsDicts,omitempty" type:"Repeated"`
	// The time when the instance was last updated.
	//
	// example:
	//
	// 2018-07-18T10:10:04.484Z
	UpdatedAt *string `json:"updatedAt,omitempty" xml:"updatedAt,omitempty"`
}

func (s RestartInstanceResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBodyResult) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBodyResult) SetCreatedAt(v string) *RestartInstanceResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetDescription(v string) *RestartInstanceResponseBodyResult {
	s.Description = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetDictList(v []*RestartInstanceResponseBodyResultDictList) *RestartInstanceResponseBodyResult {
	s.DictList = v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetDomain(v string) *RestartInstanceResponseBodyResult {
	s.Domain = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetEsVersion(v string) *RestartInstanceResponseBodyResult {
	s.EsVersion = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetInstanceId(v string) *RestartInstanceResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetKibanaConfiguration(v *RestartInstanceResponseBodyResultKibanaConfiguration) *RestartInstanceResponseBodyResult {
	s.KibanaConfiguration = v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetKibanaDomain(v string) *RestartInstanceResponseBodyResult {
	s.KibanaDomain = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetKibanaPort(v int32) *RestartInstanceResponseBodyResult {
	s.KibanaPort = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetMasterConfiguration(v *RestartInstanceResponseBodyResultMasterConfiguration) *RestartInstanceResponseBodyResult {
	s.MasterConfiguration = v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetNetworkConfig(v *RestartInstanceResponseBodyResultNetworkConfig) *RestartInstanceResponseBodyResult {
	s.NetworkConfig = v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetNodeAmount(v int32) *RestartInstanceResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetNodeSpec(v *RestartInstanceResponseBodyResultNodeSpec) *RestartInstanceResponseBodyResult {
	s.NodeSpec = v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetPaymentType(v string) *RestartInstanceResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetPublicDomain(v string) *RestartInstanceResponseBodyResult {
	s.PublicDomain = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetPublicPort(v int32) *RestartInstanceResponseBodyResult {
	s.PublicPort = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetStatus(v string) *RestartInstanceResponseBodyResult {
	s.Status = &v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetSynonymsDicts(v []*RestartInstanceResponseBodyResultSynonymsDicts) *RestartInstanceResponseBodyResult {
	s.SynonymsDicts = v
	return s
}

func (s *RestartInstanceResponseBodyResult) SetUpdatedAt(v string) *RestartInstanceResponseBodyResult {
	s.UpdatedAt = &v
	return s
}

type RestartInstanceResponseBodyResultDictList struct {
	// The size of the Dictionary File. Unit: bytes.
	//
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type. Valid values:
	//
	// 	- OSS: OSS open storage (need to ensure that OSS storage space is public readable.)
	//
	// 	- ORIGIN: Open source Elasticsearch
	//
	// 	- UPLOAD: Uploaded files
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The type of the dictionary. Valid values:
	//
	// 	- STOP: The STOP word.
	//
	// 	- MAIN: MAIN Dictionary
	//
	// 	- SYNONYMS: SYNONYMS
	//
	// 	- ALI_WS: an Alibaba Dictionary.
	//
	// example:
	//
	// MAIN
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s RestartInstanceResponseBodyResultDictList) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBodyResultDictList) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBodyResultDictList) SetFileSize(v int64) *RestartInstanceResponseBodyResultDictList {
	s.FileSize = &v
	return s
}

func (s *RestartInstanceResponseBodyResultDictList) SetName(v string) *RestartInstanceResponseBodyResultDictList {
	s.Name = &v
	return s
}

func (s *RestartInstanceResponseBodyResultDictList) SetSourceType(v string) *RestartInstanceResponseBodyResultDictList {
	s.SourceType = &v
	return s
}

func (s *RestartInstanceResponseBodyResultDictList) SetType(v string) *RestartInstanceResponseBodyResultDictList {
	s.Type = &v
	return s
}

type RestartInstanceResponseBodyResultKibanaConfiguration struct {
	// The number of performance metrics.
	//
	// example:
	//
	// 1
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The size of the node storage space. Unit: GB.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type of the node.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The specification of data nodes.
	//
	// example:
	//
	// elasticsearch.n4.small
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s RestartInstanceResponseBodyResultKibanaConfiguration) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBodyResultKibanaConfiguration) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBodyResultKibanaConfiguration) SetAmount(v int32) *RestartInstanceResponseBodyResultKibanaConfiguration {
	s.Amount = &v
	return s
}

func (s *RestartInstanceResponseBodyResultKibanaConfiguration) SetDisk(v int32) *RestartInstanceResponseBodyResultKibanaConfiguration {
	s.Disk = &v
	return s
}

func (s *RestartInstanceResponseBodyResultKibanaConfiguration) SetDiskType(v string) *RestartInstanceResponseBodyResultKibanaConfiguration {
	s.DiskType = &v
	return s
}

func (s *RestartInstanceResponseBodyResultKibanaConfiguration) SetSpec(v string) *RestartInstanceResponseBodyResultKibanaConfiguration {
	s.Spec = &v
	return s
}

type RestartInstanceResponseBodyResultMasterConfiguration struct {
	// The number of nodes in the cluster.
	//
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The size of the node storage space. Unit: GB.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type of the node. This tool only supports cloud_ssd (cloud SSD) disks.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The node specifications of the cluster.
	//
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s RestartInstanceResponseBodyResultMasterConfiguration) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBodyResultMasterConfiguration) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBodyResultMasterConfiguration) SetAmount(v int32) *RestartInstanceResponseBodyResultMasterConfiguration {
	s.Amount = &v
	return s
}

func (s *RestartInstanceResponseBodyResultMasterConfiguration) SetDisk(v int32) *RestartInstanceResponseBodyResultMasterConfiguration {
	s.Disk = &v
	return s
}

func (s *RestartInstanceResponseBodyResultMasterConfiguration) SetDiskType(v string) *RestartInstanceResponseBodyResultMasterConfiguration {
	s.DiskType = &v
	return s
}

func (s *RestartInstanceResponseBodyResultMasterConfiguration) SetSpec(v string) *RestartInstanceResponseBodyResultMasterConfiguration {
	s.Spec = &v
	return s
}

type RestartInstanceResponseBodyResultNetworkConfig struct {
	// The network type. Only Virtual Private Cloud (VPC) is supported.
	//
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The ID of the VPC.
	//
	// example:
	//
	// vpc-bp16k1dvzxtmagcva****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// The zone where the instance is deployed.
	//
	// example:
	//
	// cn-hangzhou-i
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// The ID of the vSwitch associated with the specified VPC.
	//
	// example:
	//
	// vsw-bp1k4ec6s7sjdbudw****
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
}

func (s RestartInstanceResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBodyResultNetworkConfig) SetType(v string) *RestartInstanceResponseBodyResultNetworkConfig {
	s.Type = &v
	return s
}

func (s *RestartInstanceResponseBodyResultNetworkConfig) SetVpcId(v string) *RestartInstanceResponseBodyResultNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *RestartInstanceResponseBodyResultNetworkConfig) SetVsArea(v string) *RestartInstanceResponseBodyResultNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *RestartInstanceResponseBodyResultNetworkConfig) SetVswitchId(v string) *RestartInstanceResponseBodyResultNetworkConfig {
	s.VswitchId = &v
	return s
}

type RestartInstanceResponseBodyResultNodeSpec struct {
	// The storage space size per data node. Unit: GB.
	//
	// example:
	//
	// 50
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The storage type of the node. Valid values: cloud_ssd and cloud_efficiency.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The specification of data nodes.
	//
	// example:
	//
	// elasticsearch.n4.small
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s RestartInstanceResponseBodyResultNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBodyResultNodeSpec) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBodyResultNodeSpec) SetDisk(v int32) *RestartInstanceResponseBodyResultNodeSpec {
	s.Disk = &v
	return s
}

func (s *RestartInstanceResponseBodyResultNodeSpec) SetDiskType(v string) *RestartInstanceResponseBodyResultNodeSpec {
	s.DiskType = &v
	return s
}

func (s *RestartInstanceResponseBodyResultNodeSpec) SetSpec(v string) *RestartInstanceResponseBodyResultNodeSpec {
	s.Spec = &v
	return s
}

type RestartInstanceResponseBodyResultSynonymsDicts struct {
	// The size of the Dictionary File. Unit: bytes.
	//
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type. Valid values:
	//
	// 	- OSS:OSS open storage (the OSS storage space must be publicly readable.)
	//
	// 	- ORIGIN: open-source Elasticsearch
	//
	// 	- UPLOAD
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The type of the dictionary. Valid values:
	//
	// 	- STOP: The STOP word.
	//
	// 	- MAIN: MAIN Dictionary
	//
	// 	- SYNONYMS: SYNONYMS
	//
	// 	- ALI_WS: an Alibaba Dictionary.
	//
	// example:
	//
	// STOP
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s RestartInstanceResponseBodyResultSynonymsDicts) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBodyResultSynonymsDicts) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBodyResultSynonymsDicts) SetFileSize(v int64) *RestartInstanceResponseBodyResultSynonymsDicts {
	s.FileSize = &v
	return s
}

func (s *RestartInstanceResponseBodyResultSynonymsDicts) SetName(v string) *RestartInstanceResponseBodyResultSynonymsDicts {
	s.Name = &v
	return s
}

func (s *RestartInstanceResponseBodyResultSynonymsDicts) SetSourceType(v string) *RestartInstanceResponseBodyResultSynonymsDicts {
	s.SourceType = &v
	return s
}

func (s *RestartInstanceResponseBodyResultSynonymsDicts) SetType(v string) *RestartInstanceResponseBodyResultSynonymsDicts {
	s.Type = &v
	return s
}

type RestartInstanceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RestartInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RestartInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponse) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponse) SetHeaders(v map[string]*string) *RestartInstanceResponse {
	s.Headers = v
	return s
}

func (s *RestartInstanceResponse) SetStatusCode(v int32) *RestartInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartInstanceResponse) SetBody(v *RestartInstanceResponseBody) *RestartInstanceResponse {
	s.Body = v
	return s
}

type RestartLogstashRequest struct {
	// example:
	//
	// 20%
	BatchCount *float64 `json:"batchCount,omitempty" xml:"batchCount,omitempty"`
	// example:
	//
	// false
	BlueGreenDep *bool     `json:"blueGreenDep,omitempty" xml:"blueGreenDep,omitempty"`
	NodeTypes    []*string `json:"nodeTypes,omitempty" xml:"nodeTypes,omitempty" type:"Repeated"`
	Nodes        []*string `json:"nodes,omitempty" xml:"nodes,omitempty" type:"Repeated"`
	// example:
	//
	// instance
	RestartType *string `json:"restartType,omitempty" xml:"restartType,omitempty"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// example:
	//
	// true
	Force *bool `json:"force,omitempty" xml:"force,omitempty"`
}

func (s RestartLogstashRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartLogstashRequest) GoString() string {
	return s.String()
}

func (s *RestartLogstashRequest) SetBatchCount(v float64) *RestartLogstashRequest {
	s.BatchCount = &v
	return s
}

func (s *RestartLogstashRequest) SetBlueGreenDep(v bool) *RestartLogstashRequest {
	s.BlueGreenDep = &v
	return s
}

func (s *RestartLogstashRequest) SetNodeTypes(v []*string) *RestartLogstashRequest {
	s.NodeTypes = v
	return s
}

func (s *RestartLogstashRequest) SetNodes(v []*string) *RestartLogstashRequest {
	s.Nodes = v
	return s
}

func (s *RestartLogstashRequest) SetRestartType(v string) *RestartLogstashRequest {
	s.RestartType = &v
	return s
}

func (s *RestartLogstashRequest) SetClientToken(v string) *RestartLogstashRequest {
	s.ClientToken = &v
	return s
}

func (s *RestartLogstashRequest) SetForce(v bool) *RestartLogstashRequest {
	s.Force = &v
	return s
}

type RestartLogstashResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *Logstash `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s RestartLogstashResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartLogstashResponseBody) GoString() string {
	return s.String()
}

func (s *RestartLogstashResponseBody) SetRequestId(v string) *RestartLogstashResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartLogstashResponseBody) SetResult(v *Logstash) *RestartLogstashResponseBody {
	s.Result = v
	return s
}

type RestartLogstashResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RestartLogstashResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RestartLogstashResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartLogstashResponse) GoString() string {
	return s.String()
}

func (s *RestartLogstashResponse) SetHeaders(v map[string]*string) *RestartLogstashResponse {
	s.Headers = v
	return s
}

func (s *RestartLogstashResponse) SetStatusCode(v int32) *RestartLogstashResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartLogstashResponse) SetBody(v *RestartLogstashResponseBody) *RestartLogstashResponse {
	s.Body = v
	return s
}

type ResumeElasticsearchTaskRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s ResumeElasticsearchTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ResumeElasticsearchTaskRequest) GoString() string {
	return s.String()
}

func (s *ResumeElasticsearchTaskRequest) SetClientToken(v string) *ResumeElasticsearchTaskRequest {
	s.ClientToken = &v
	return s
}

type ResumeElasticsearchTaskResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: resume the interrupted change successfully
	//
	// 	- false: resume the interrupted change successfully failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ResumeElasticsearchTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResumeElasticsearchTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ResumeElasticsearchTaskResponseBody) SetRequestId(v string) *ResumeElasticsearchTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResumeElasticsearchTaskResponseBody) SetResult(v bool) *ResumeElasticsearchTaskResponseBody {
	s.Result = &v
	return s
}

type ResumeElasticsearchTaskResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ResumeElasticsearchTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ResumeElasticsearchTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ResumeElasticsearchTaskResponse) GoString() string {
	return s.String()
}

func (s *ResumeElasticsearchTaskResponse) SetHeaders(v map[string]*string) *ResumeElasticsearchTaskResponse {
	s.Headers = v
	return s
}

func (s *ResumeElasticsearchTaskResponse) SetStatusCode(v int32) *ResumeElasticsearchTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ResumeElasticsearchTaskResponse) SetBody(v *ResumeElasticsearchTaskResponseBody) *ResumeElasticsearchTaskResponse {
	s.Body = v
	return s
}

type ResumeLogstashTaskRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s ResumeLogstashTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ResumeLogstashTaskRequest) GoString() string {
	return s.String()
}

func (s *ResumeLogstashTaskRequest) SetClientToken(v string) *ResumeLogstashTaskRequest {
	s.ClientToken = &v
	return s
}

type ResumeLogstashTaskResponseBody struct {
	// The error code returned. If the API operation is successfully called, this parameter is not returned.
	//
	// example:
	//
	// InstanceNotFound
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned. If the API operation is successfully called, this parameter is not returned.
	//
	// example:
	//
	// The specified cluster does not exist. Check the cluster status and try again.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 0FA05123-745C-42FD-A69B-AFF48EF9****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the change task is resumed. Valid values:
	//
	// 	- true: The change task is resumed.
	//
	// 	- false: The change task fails to be resumed.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ResumeLogstashTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResumeLogstashTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ResumeLogstashTaskResponseBody) SetCode(v string) *ResumeLogstashTaskResponseBody {
	s.Code = &v
	return s
}

func (s *ResumeLogstashTaskResponseBody) SetMessage(v string) *ResumeLogstashTaskResponseBody {
	s.Message = &v
	return s
}

func (s *ResumeLogstashTaskResponseBody) SetRequestId(v string) *ResumeLogstashTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResumeLogstashTaskResponseBody) SetResult(v bool) *ResumeLogstashTaskResponseBody {
	s.Result = &v
	return s
}

type ResumeLogstashTaskResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ResumeLogstashTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ResumeLogstashTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ResumeLogstashTaskResponse) GoString() string {
	return s.String()
}

func (s *ResumeLogstashTaskResponse) SetHeaders(v map[string]*string) *ResumeLogstashTaskResponse {
	s.Headers = v
	return s
}

func (s *ResumeLogstashTaskResponse) SetStatusCode(v int32) *ResumeLogstashTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ResumeLogstashTaskResponse) SetBody(v *ResumeLogstashTaskResponseBody) *ResumeLogstashTaskResponse {
	s.Body = v
	return s
}

type RolloverDataStreamRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s RolloverDataStreamRequest) String() string {
	return tea.Prettify(s)
}

func (s RolloverDataStreamRequest) GoString() string {
	return s.String()
}

func (s *RolloverDataStreamRequest) SetClientToken(v string) *RolloverDataStreamRequest {
	s.ClientToken = &v
	return s
}

type RolloverDataStreamResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s RolloverDataStreamResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RolloverDataStreamResponseBody) GoString() string {
	return s.String()
}

func (s *RolloverDataStreamResponseBody) SetRequestId(v string) *RolloverDataStreamResponseBody {
	s.RequestId = &v
	return s
}

func (s *RolloverDataStreamResponseBody) SetResult(v bool) *RolloverDataStreamResponseBody {
	s.Result = &v
	return s
}

type RolloverDataStreamResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RolloverDataStreamResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RolloverDataStreamResponse) String() string {
	return tea.Prettify(s)
}

func (s RolloverDataStreamResponse) GoString() string {
	return s.String()
}

func (s *RolloverDataStreamResponse) SetHeaders(v map[string]*string) *RolloverDataStreamResponse {
	s.Headers = v
	return s
}

func (s *RolloverDataStreamResponse) SetStatusCode(v int32) *RolloverDataStreamResponse {
	s.StatusCode = &v
	return s
}

func (s *RolloverDataStreamResponse) SetBody(v *RolloverDataStreamResponseBody) *RolloverDataStreamResponse {
	s.Body = v
	return s
}

type RunPipelinesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RunPipelinesRequest) String() string {
	return tea.Prettify(s)
}

func (s RunPipelinesRequest) GoString() string {
	return s.String()
}

func (s *RunPipelinesRequest) SetClientToken(v string) *RunPipelinesRequest {
	s.ClientToken = &v
	return s
}

func (s *RunPipelinesRequest) SetBody(v string) *RunPipelinesRequest {
	s.Body = &v
	return s
}

type RunPipelinesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result. Valid values:
	//
	// 	- true: successful
	//
	// 	- false: failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s RunPipelinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RunPipelinesResponseBody) GoString() string {
	return s.String()
}

func (s *RunPipelinesResponseBody) SetRequestId(v string) *RunPipelinesResponseBody {
	s.RequestId = &v
	return s
}

func (s *RunPipelinesResponseBody) SetResult(v bool) *RunPipelinesResponseBody {
	s.Result = &v
	return s
}

type RunPipelinesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RunPipelinesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RunPipelinesResponse) String() string {
	return tea.Prettify(s)
}

func (s RunPipelinesResponse) GoString() string {
	return s.String()
}

func (s *RunPipelinesResponse) SetHeaders(v map[string]*string) *RunPipelinesResponse {
	s.Headers = v
	return s
}

func (s *RunPipelinesResponse) SetStatusCode(v int32) *RunPipelinesResponse {
	s.StatusCode = &v
	return s
}

func (s *RunPipelinesResponse) SetBody(v *RunPipelinesResponseBody) *RunPipelinesResponse {
	s.Body = v
	return s
}

type ShrinkNodeRequest struct {
	Body []*ShrinkNodeRequestBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// example:
	//
	// 2
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// example:
	//
	// false
	IgnoreStatus *bool `json:"ignoreStatus,omitempty" xml:"ignoreStatus,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
}

func (s ShrinkNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s ShrinkNodeRequest) GoString() string {
	return s.String()
}

func (s *ShrinkNodeRequest) SetBody(v []*ShrinkNodeRequestBody) *ShrinkNodeRequest {
	s.Body = v
	return s
}

func (s *ShrinkNodeRequest) SetClientToken(v string) *ShrinkNodeRequest {
	s.ClientToken = &v
	return s
}

func (s *ShrinkNodeRequest) SetCount(v int32) *ShrinkNodeRequest {
	s.Count = &v
	return s
}

func (s *ShrinkNodeRequest) SetIgnoreStatus(v bool) *ShrinkNodeRequest {
	s.IgnoreStatus = &v
	return s
}

func (s *ShrinkNodeRequest) SetNodeType(v string) *ShrinkNodeRequest {
	s.NodeType = &v
	return s
}

type ShrinkNodeRequestBody struct {
	// example:
	//
	// 192.168.xx.xx
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// example:
	//
	// es-cn-pl32xxxxxxx-data-f-1
	HostName *string `json:"hostName,omitempty" xml:"hostName,omitempty"`
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
	// example:
	//
	// cn-shanghai-c
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s ShrinkNodeRequestBody) String() string {
	return tea.Prettify(s)
}

func (s ShrinkNodeRequestBody) GoString() string {
	return s.String()
}

func (s *ShrinkNodeRequestBody) SetHost(v string) *ShrinkNodeRequestBody {
	s.Host = &v
	return s
}

func (s *ShrinkNodeRequestBody) SetHostName(v string) *ShrinkNodeRequestBody {
	s.HostName = &v
	return s
}

func (s *ShrinkNodeRequestBody) SetNodeType(v string) *ShrinkNodeRequestBody {
	s.NodeType = &v
	return s
}

func (s *ShrinkNodeRequestBody) SetPort(v int32) *ShrinkNodeRequestBody {
	s.Port = &v
	return s
}

func (s *ShrinkNodeRequestBody) SetZoneId(v string) *ShrinkNodeRequestBody {
	s.ZoneId = &v
	return s
}

type ShrinkNodeResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ShrinkNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ShrinkNodeResponseBody) GoString() string {
	return s.String()
}

func (s *ShrinkNodeResponseBody) SetRequestId(v string) *ShrinkNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ShrinkNodeResponseBody) SetResult(v bool) *ShrinkNodeResponseBody {
	s.Result = &v
	return s
}

type ShrinkNodeResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ShrinkNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ShrinkNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s ShrinkNodeResponse) GoString() string {
	return s.String()
}

func (s *ShrinkNodeResponse) SetHeaders(v map[string]*string) *ShrinkNodeResponse {
	s.Headers = v
	return s
}

func (s *ShrinkNodeResponse) SetStatusCode(v int32) *ShrinkNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *ShrinkNodeResponse) SetBody(v *ShrinkNodeResponseBody) *ShrinkNodeResponse {
	s.Body = v
	return s
}

type StartApmResponseBody struct {
	// example:
	//
	// 526F30AB-4A43-55BA-910F-ACD275FD5F14
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s StartApmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartApmResponseBody) GoString() string {
	return s.String()
}

func (s *StartApmResponseBody) SetRequestId(v string) *StartApmResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartApmResponseBody) SetResult(v bool) *StartApmResponseBody {
	s.Result = &v
	return s
}

type StartApmResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartApmResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartApmResponse) String() string {
	return tea.Prettify(s)
}

func (s StartApmResponse) GoString() string {
	return s.String()
}

func (s *StartApmResponse) SetHeaders(v map[string]*string) *StartApmResponse {
	s.Headers = v
	return s
}

func (s *StartApmResponse) SetStatusCode(v int32) *StartApmResponse {
	s.StatusCode = &v
	return s
}

func (s *StartApmResponse) SetBody(v *StartApmResponseBody) *StartApmResponse {
	s.Body = v
	return s
}

type StartCollectorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s StartCollectorRequest) String() string {
	return tea.Prettify(s)
}

func (s StartCollectorRequest) GoString() string {
	return s.String()
}

func (s *StartCollectorRequest) SetClientToken(v string) *StartCollectorRequest {
	s.ClientToken = &v
	return s
}

type StartCollectorResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s StartCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *StartCollectorResponseBody) SetRequestId(v string) *StartCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartCollectorResponseBody) SetResult(v bool) *StartCollectorResponseBody {
	s.Result = &v
	return s
}

type StartCollectorResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s StartCollectorResponse) GoString() string {
	return s.String()
}

func (s *StartCollectorResponse) SetHeaders(v map[string]*string) *StartCollectorResponse {
	s.Headers = v
	return s
}

func (s *StartCollectorResponse) SetStatusCode(v int32) *StartCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *StartCollectorResponse) SetBody(v *StartCollectorResponseBody) *StartCollectorResponse {
	s.Body = v
	return s
}

type StopApmResponseBody struct {
	// example:
	//
	// FEC32FE6-4697-5110-9668-C6016EAEB5DE
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s StopApmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopApmResponseBody) GoString() string {
	return s.String()
}

func (s *StopApmResponseBody) SetRequestId(v string) *StopApmResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopApmResponseBody) SetResult(v bool) *StopApmResponseBody {
	s.Result = &v
	return s
}

type StopApmResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopApmResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopApmResponse) String() string {
	return tea.Prettify(s)
}

func (s StopApmResponse) GoString() string {
	return s.String()
}

func (s *StopApmResponse) SetHeaders(v map[string]*string) *StopApmResponse {
	s.Headers = v
	return s
}

func (s *StopApmResponse) SetStatusCode(v int32) *StopApmResponse {
	s.StatusCode = &v
	return s
}

func (s *StopApmResponse) SetBody(v *StopApmResponseBody) *StopApmResponse {
	s.Body = v
	return s
}

type StopCollectorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s StopCollectorRequest) String() string {
	return tea.Prettify(s)
}

func (s StopCollectorRequest) GoString() string {
	return s.String()
}

func (s *StopCollectorRequest) SetClientToken(v string) *StopCollectorRequest {
	s.ClientToken = &v
	return s
}

type StopCollectorResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s StopCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *StopCollectorResponseBody) SetRequestId(v string) *StopCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopCollectorResponseBody) SetResult(v bool) *StopCollectorResponseBody {
	s.Result = &v
	return s
}

type StopCollectorResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s StopCollectorResponse) GoString() string {
	return s.String()
}

func (s *StopCollectorResponse) SetHeaders(v map[string]*string) *StopCollectorResponse {
	s.Headers = v
	return s
}

func (s *StopCollectorResponse) SetStatusCode(v int32) *StopCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *StopCollectorResponse) SetBody(v *StopCollectorResponseBody) *StopCollectorResponse {
	s.Body = v
	return s
}

type StopPipelinesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopPipelinesRequest) String() string {
	return tea.Prettify(s)
}

func (s StopPipelinesRequest) GoString() string {
	return s.String()
}

func (s *StopPipelinesRequest) SetClientToken(v string) *StopPipelinesRequest {
	s.ClientToken = &v
	return s
}

func (s *StopPipelinesRequest) SetBody(v string) *StopPipelinesRequest {
	s.Body = &v
	return s
}

type StopPipelinesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result. Valid values:
	//
	// 	- true: The pipelines are stopped.
	//
	// 	- false: The pipelines fail to be stopped.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s StopPipelinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopPipelinesResponseBody) GoString() string {
	return s.String()
}

func (s *StopPipelinesResponseBody) SetRequestId(v string) *StopPipelinesResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopPipelinesResponseBody) SetResult(v bool) *StopPipelinesResponseBody {
	s.Result = &v
	return s
}

type StopPipelinesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopPipelinesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopPipelinesResponse) String() string {
	return tea.Prettify(s)
}

func (s StopPipelinesResponse) GoString() string {
	return s.String()
}

func (s *StopPipelinesResponse) SetHeaders(v map[string]*string) *StopPipelinesResponse {
	s.Headers = v
	return s
}

func (s *StopPipelinesResponse) SetStatusCode(v int32) *StopPipelinesResponse {
	s.StatusCode = &v
	return s
}

func (s *StopPipelinesResponse) SetBody(v *StopPipelinesResponseBody) *StopPipelinesResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// A tag.
	//
	// This parameter is required.
	ResourceIds []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	// The request ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// INSTANCE
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The value of the tag.
	//
	// This parameter is required.
	Tags []*TagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetResourceIds(v []*string) *TagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTags(v []*TagResourcesRequestTags) *TagResourcesRequest {
	s.Tags = v
	return s
}

type TagResourcesRequestTags struct {
	// The returned object.
	//
	// This parameter is required.
	//
	// example:
	//
	// env
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// Indicates whether tags are added to the clusters. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// This parameter is required.
	//
	// example:
	//
	// IT
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s TagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTags) SetKey(v string) *TagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTags) SetValue(v string) *TagResourcesRequestTags {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// example:
	//
	// 3D8795D9-8FF5-46B2-86E6-E3B407*******
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *TagResourcesResponseBody) SetResult(v bool) *TagResourcesResponseBody {
	s.Result = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type TransferNodeRequest struct {
	Body []*TransferNodeRequestBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
}

func (s TransferNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s TransferNodeRequest) GoString() string {
	return s.String()
}

func (s *TransferNodeRequest) SetBody(v []*TransferNodeRequestBody) *TransferNodeRequest {
	s.Body = v
	return s
}

func (s *TransferNodeRequest) SetClientToken(v string) *TransferNodeRequest {
	s.ClientToken = &v
	return s
}

func (s *TransferNodeRequest) SetNodeType(v string) *TransferNodeRequest {
	s.NodeType = &v
	return s
}

type TransferNodeRequestBody struct {
	// example:
	//
	// 192.168.xx.xx
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
	// example:
	//
	// cn-shanghai-c
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s TransferNodeRequestBody) String() string {
	return tea.Prettify(s)
}

func (s TransferNodeRequestBody) GoString() string {
	return s.String()
}

func (s *TransferNodeRequestBody) SetHost(v string) *TransferNodeRequestBody {
	s.Host = &v
	return s
}

func (s *TransferNodeRequestBody) SetPort(v int32) *TransferNodeRequestBody {
	s.Port = &v
	return s
}

func (s *TransferNodeRequestBody) SetZoneId(v string) *TransferNodeRequestBody {
	s.ZoneId = &v
	return s
}

type TransferNodeResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s TransferNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TransferNodeResponseBody) GoString() string {
	return s.String()
}

func (s *TransferNodeResponseBody) SetRequestId(v string) *TransferNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *TransferNodeResponseBody) SetResult(v bool) *TransferNodeResponseBody {
	s.Result = &v
	return s
}

type TransferNodeResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TransferNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TransferNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s TransferNodeResponse) GoString() string {
	return s.String()
}

func (s *TransferNodeResponse) SetHeaders(v map[string]*string) *TransferNodeResponse {
	s.Headers = v
	return s
}

func (s *TransferNodeResponse) SetStatusCode(v int32) *TransferNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *TransferNodeResponse) SetBody(v *TransferNodeResponseBody) *TransferNodeResponse {
	s.Body = v
	return s
}

type TriggerNetworkRequest struct {
	// This parameter is required.
	//
	// example:
	//
	// OPEN
	ActionType *string `json:"actionType,omitempty" xml:"actionType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// PUBLIC
	NetworkType *string `json:"networkType,omitempty" xml:"networkType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// KIBANA
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
	// example:
	//
	// 407d02b74c49beb5bfdac7ec8bde2488
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s TriggerNetworkRequest) String() string {
	return tea.Prettify(s)
}

func (s TriggerNetworkRequest) GoString() string {
	return s.String()
}

func (s *TriggerNetworkRequest) SetActionType(v string) *TriggerNetworkRequest {
	s.ActionType = &v
	return s
}

func (s *TriggerNetworkRequest) SetNetworkType(v string) *TriggerNetworkRequest {
	s.NetworkType = &v
	return s
}

func (s *TriggerNetworkRequest) SetNodeType(v string) *TriggerNetworkRequest {
	s.NodeType = &v
	return s
}

func (s *TriggerNetworkRequest) SetClientToken(v string) *TriggerNetworkRequest {
	s.ClientToken = &v
	return s
}

type TriggerNetworkResponseBody struct {
	// example:
	//
	// 5A5D8E74-565C-43DC-B031-29289FA****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s TriggerNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TriggerNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *TriggerNetworkResponseBody) SetRequestId(v string) *TriggerNetworkResponseBody {
	s.RequestId = &v
	return s
}

func (s *TriggerNetworkResponseBody) SetResult(v bool) *TriggerNetworkResponseBody {
	s.Result = &v
	return s
}

type TriggerNetworkResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TriggerNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TriggerNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s TriggerNetworkResponse) GoString() string {
	return s.String()
}

func (s *TriggerNetworkResponse) SetHeaders(v map[string]*string) *TriggerNetworkResponse {
	s.Headers = v
	return s
}

func (s *TriggerNetworkResponse) SetStatusCode(v int32) *TriggerNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *TriggerNetworkResponse) SetBody(v *TriggerNetworkResponseBody) *TriggerNetworkResponse {
	s.Body = v
	return s
}

type UninstallKibanaPluginRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UninstallKibanaPluginRequest) String() string {
	return tea.Prettify(s)
}

func (s UninstallKibanaPluginRequest) GoString() string {
	return s.String()
}

func (s *UninstallKibanaPluginRequest) SetBody(v string) *UninstallKibanaPluginRequest {
	s.Body = &v
	return s
}

func (s *UninstallKibanaPluginRequest) SetClientToken(v string) *UninstallKibanaPluginRequest {
	s.ClientToken = &v
	return s
}

type UninstallKibanaPluginResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result shows a list of uninstalled plug-ins.
	Result []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UninstallKibanaPluginResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UninstallKibanaPluginResponseBody) GoString() string {
	return s.String()
}

func (s *UninstallKibanaPluginResponseBody) SetRequestId(v string) *UninstallKibanaPluginResponseBody {
	s.RequestId = &v
	return s
}

func (s *UninstallKibanaPluginResponseBody) SetResult(v []*string) *UninstallKibanaPluginResponseBody {
	s.Result = v
	return s
}

type UninstallKibanaPluginResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UninstallKibanaPluginResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UninstallKibanaPluginResponse) String() string {
	return tea.Prettify(s)
}

func (s UninstallKibanaPluginResponse) GoString() string {
	return s.String()
}

func (s *UninstallKibanaPluginResponse) SetHeaders(v map[string]*string) *UninstallKibanaPluginResponse {
	s.Headers = v
	return s
}

func (s *UninstallKibanaPluginResponse) SetStatusCode(v int32) *UninstallKibanaPluginResponse {
	s.StatusCode = &v
	return s
}

func (s *UninstallKibanaPluginResponse) SetBody(v *UninstallKibanaPluginResponseBody) *UninstallKibanaPluginResponse {
	s.Body = v
	return s
}

type UninstallLogstashPluginRequest struct {
	// example:
	//
	// ["logstash-input-datahub", "logstash-input-maxcompute" ]
	Body []*string `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UninstallLogstashPluginRequest) String() string {
	return tea.Prettify(s)
}

func (s UninstallLogstashPluginRequest) GoString() string {
	return s.String()
}

func (s *UninstallLogstashPluginRequest) SetBody(v []*string) *UninstallLogstashPluginRequest {
	s.Body = v
	return s
}

func (s *UninstallLogstashPluginRequest) SetClientToken(v string) *UninstallLogstashPluginRequest {
	s.ClientToken = &v
	return s
}

type UninstallLogstashPluginResponseBody struct {
	Headers map[string]interface{} `json:"Headers,omitempty" xml:"Headers,omitempty"`
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UninstallLogstashPluginResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UninstallLogstashPluginResponseBody) GoString() string {
	return s.String()
}

func (s *UninstallLogstashPluginResponseBody) SetHeaders(v map[string]interface{}) *UninstallLogstashPluginResponseBody {
	s.Headers = v
	return s
}

func (s *UninstallLogstashPluginResponseBody) SetRequestId(v string) *UninstallLogstashPluginResponseBody {
	s.RequestId = &v
	return s
}

func (s *UninstallLogstashPluginResponseBody) SetResult(v []*string) *UninstallLogstashPluginResponseBody {
	s.Result = v
	return s
}

type UninstallLogstashPluginResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UninstallLogstashPluginResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UninstallLogstashPluginResponse) String() string {
	return tea.Prettify(s)
}

func (s UninstallLogstashPluginResponse) GoString() string {
	return s.String()
}

func (s *UninstallLogstashPluginResponse) SetHeaders(v map[string]*string) *UninstallLogstashPluginResponse {
	s.Headers = v
	return s
}

func (s *UninstallLogstashPluginResponse) SetStatusCode(v int32) *UninstallLogstashPluginResponse {
	s.StatusCode = &v
	return s
}

func (s *UninstallLogstashPluginResponse) SetBody(v *UninstallLogstashPluginResponseBody) *UninstallLogstashPluginResponse {
	s.Body = v
	return s
}

type UninstallPluginRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	Force       *bool   `json:"force,omitempty" xml:"force,omitempty"`
}

func (s UninstallPluginRequest) String() string {
	return tea.Prettify(s)
}

func (s UninstallPluginRequest) GoString() string {
	return s.String()
}

func (s *UninstallPluginRequest) SetBody(v string) *UninstallPluginRequest {
	s.Body = &v
	return s
}

func (s *UninstallPluginRequest) SetClientToken(v string) *UninstallPluginRequest {
	s.ClientToken = &v
	return s
}

func (s *UninstallPluginRequest) SetForce(v bool) *UninstallPluginRequest {
	s.Force = &v
	return s
}

type UninstallPluginResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of plug-ins to be unloaded. If the unloading fails, an exception is returned.
	Result []*string `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UninstallPluginResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UninstallPluginResponseBody) GoString() string {
	return s.String()
}

func (s *UninstallPluginResponseBody) SetRequestId(v string) *UninstallPluginResponseBody {
	s.RequestId = &v
	return s
}

func (s *UninstallPluginResponseBody) SetResult(v []*string) *UninstallPluginResponseBody {
	s.Result = v
	return s
}

type UninstallPluginResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UninstallPluginResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UninstallPluginResponse) String() string {
	return tea.Prettify(s)
}

func (s UninstallPluginResponse) GoString() string {
	return s.String()
}

func (s *UninstallPluginResponse) SetHeaders(v map[string]*string) *UninstallPluginResponse {
	s.Headers = v
	return s
}

func (s *UninstallPluginResponse) SetStatusCode(v int32) *UninstallPluginResponse {
	s.StatusCode = &v
	return s
}

func (s *UninstallPluginResponse) SetBody(v *UninstallPluginResponseBody) *UninstallPluginResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to delete all parts. Default value: **false*	- . This parameter is valid only when **TagKeys*	- is not specified.
	//
	// example:
	//
	// false
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The resource list that you want to delete.
	//
	// example:
	//
	// ["es-cn-09k1rocex0006****","es-cn-oew1rgiev0009****"]
	ResourceIds *string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// The type of the resource. Fixed to **INSTANCE*	- .
	//
	// example:
	//
	// INSTANCE
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The list of tags that you want to delete. The list can contain up to 20 subitems.
	//
	// example:
	//
	// ["tagKey1","tagKey2"]
	TagKeys *string `json:"TagKeys,omitempty" xml:"TagKeys,omitempty"`
	Body    *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceIds(v string) *UntagResourcesRequest {
	s.ResourceIds = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKeys(v string) *UntagResourcesRequest {
	s.TagKeys = &v
	return s
}

func (s *UntagResourcesRequest) SetBody(v string) *UntagResourcesRequest {
	s.Body = &v
	return s
}

type UntagResourcesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6D******
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: deleted
	//
	// 	- false: Failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UntagResourcesResponseBody) SetResult(v bool) *UntagResourcesResponseBody {
	s.Result = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAdminPasswordRequest struct {
	// example:
	//
	// es_password
	EsAdminPassword *string `json:"esAdminPassword,omitempty" xml:"esAdminPassword,omitempty"`
	// Indicates whether the password was updated. Valid values:
	//
	// 	- true: The call was successful.
	//
	// 	- false: The call failed.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateAdminPasswordRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdminPasswordRequest) GoString() string {
	return s.String()
}

func (s *UpdateAdminPasswordRequest) SetEsAdminPassword(v string) *UpdateAdminPasswordRequest {
	s.EsAdminPassword = &v
	return s
}

func (s *UpdateAdminPasswordRequest) SetClientToken(v string) *UpdateAdminPasswordRequest {
	s.ClientToken = &v
	return s
}

type UpdateAdminPasswordResponseBody struct {
	// example:
	//
	// 0FA05123-745C-42FD-A69B-AFF48EF9****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateAdminPasswordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdminPasswordResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAdminPasswordResponseBody) SetRequestId(v string) *UpdateAdminPasswordResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAdminPasswordResponseBody) SetResult(v bool) *UpdateAdminPasswordResponseBody {
	s.Result = &v
	return s
}

type UpdateAdminPasswordResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateAdminPasswordResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAdminPasswordResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdminPasswordResponse) GoString() string {
	return s.String()
}

func (s *UpdateAdminPasswordResponse) SetHeaders(v map[string]*string) *UpdateAdminPasswordResponse {
	s.Headers = v
	return s
}

func (s *UpdateAdminPasswordResponse) SetStatusCode(v int32) *UpdateAdminPasswordResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAdminPasswordResponse) SetBody(v *UpdateAdminPasswordResponseBody) *UpdateAdminPasswordResponse {
	s.Body = v
	return s
}

type UpdateAdvancedSettingRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateAdvancedSettingRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdvancedSettingRequest) GoString() string {
	return s.String()
}

func (s *UpdateAdvancedSettingRequest) SetBody(v string) *UpdateAdvancedSettingRequest {
	s.Body = &v
	return s
}

func (s *UpdateAdvancedSettingRequest) SetClientToken(v string) *UpdateAdvancedSettingRequest {
	s.ClientToken = &v
	return s
}

type UpdateAdvancedSettingResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: garbage collector configuration changed successfully
	//
	// 	- false: garbage collector configuration changed successfully failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateAdvancedSettingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdvancedSettingResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAdvancedSettingResponseBody) SetRequestId(v string) *UpdateAdvancedSettingResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAdvancedSettingResponseBody) SetResult(v bool) *UpdateAdvancedSettingResponseBody {
	s.Result = &v
	return s
}

type UpdateAdvancedSettingResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateAdvancedSettingResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAdvancedSettingResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdvancedSettingResponse) GoString() string {
	return s.String()
}

func (s *UpdateAdvancedSettingResponse) SetHeaders(v map[string]*string) *UpdateAdvancedSettingResponse {
	s.Headers = v
	return s
}

func (s *UpdateAdvancedSettingResponse) SetStatusCode(v int32) *UpdateAdvancedSettingResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAdvancedSettingResponse) SetBody(v *UpdateAdvancedSettingResponseBody) *UpdateAdvancedSettingResponse {
	s.Body = v
	return s
}

type UpdateAliwsDictRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateAliwsDictRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAliwsDictRequest) GoString() string {
	return s.String()
}

func (s *UpdateAliwsDictRequest) SetBody(v string) *UpdateAliwsDictRequest {
	s.Body = &v
	return s
}

func (s *UpdateAliwsDictRequest) SetClientToken(v string) *UpdateAliwsDictRequest {
	s.ClientToken = &v
	return s
}

type UpdateAliwsDictResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*UpdateAliwsDictResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UpdateAliwsDictResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAliwsDictResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAliwsDictResponseBody) SetRequestId(v string) *UpdateAliwsDictResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAliwsDictResponseBody) SetResult(v []*UpdateAliwsDictResponseBodyResult) *UpdateAliwsDictResponseBody {
	s.Result = v
	return s
}

type UpdateAliwsDictResponseBodyResult struct {
	// The size of the dictionary file. Unit: bytes.
	//
	// example:
	//
	// 6226
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the uploaded dictionary file.
	//
	// example:
	//
	// aliws_ext_dict.txt
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type of the dictionary file. Valid values:
	//
	// 	- OSS
	//
	// 	- ORIGIN
	//
	// example:
	//
	// OSS
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The dictionary type. The value is fixed as ALI_WS.
	//
	// example:
	//
	// ALI_WS
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateAliwsDictResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateAliwsDictResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateAliwsDictResponseBodyResult) SetFileSize(v int64) *UpdateAliwsDictResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *UpdateAliwsDictResponseBodyResult) SetName(v string) *UpdateAliwsDictResponseBodyResult {
	s.Name = &v
	return s
}

func (s *UpdateAliwsDictResponseBodyResult) SetSourceType(v string) *UpdateAliwsDictResponseBodyResult {
	s.SourceType = &v
	return s
}

func (s *UpdateAliwsDictResponseBodyResult) SetType(v string) *UpdateAliwsDictResponseBodyResult {
	s.Type = &v
	return s
}

type UpdateAliwsDictResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateAliwsDictResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAliwsDictResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAliwsDictResponse) GoString() string {
	return s.String()
}

func (s *UpdateAliwsDictResponse) SetHeaders(v map[string]*string) *UpdateAliwsDictResponse {
	s.Headers = v
	return s
}

func (s *UpdateAliwsDictResponse) SetStatusCode(v int32) *UpdateAliwsDictResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAliwsDictResponse) SetBody(v *UpdateAliwsDictResponseBody) *UpdateAliwsDictResponse {
	s.Body = v
	return s
}

type UpdateApmRequest struct {
	// example:
	//
	// APMtest
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// es-cn-i7m2fsfhc001x****
	OutputES *string `json:"outputES,omitempty" xml:"outputES,omitempty"`
	// example:
	//
	// ESPassword****
	OutputESPassword *string `json:"outputESPassword,omitempty" xml:"outputESPassword,omitempty"`
	// example:
	//
	// elastic
	OutputESUserName *string `json:"outputESUserName,omitempty" xml:"outputESUserName,omitempty"`
	// example:
	//
	// AMPPassword****
	Token *string `json:"token,omitempty" xml:"token,omitempty"`
}

func (s UpdateApmRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateApmRequest) GoString() string {
	return s.String()
}

func (s *UpdateApmRequest) SetDescription(v string) *UpdateApmRequest {
	s.Description = &v
	return s
}

func (s *UpdateApmRequest) SetOutputES(v string) *UpdateApmRequest {
	s.OutputES = &v
	return s
}

func (s *UpdateApmRequest) SetOutputESPassword(v string) *UpdateApmRequest {
	s.OutputESPassword = &v
	return s
}

func (s *UpdateApmRequest) SetOutputESUserName(v string) *UpdateApmRequest {
	s.OutputESUserName = &v
	return s
}

func (s *UpdateApmRequest) SetToken(v string) *UpdateApmRequest {
	s.Token = &v
	return s
}

type UpdateApmResponseBody struct {
	// example:
	//
	// 18061926-CC50-5F9B-9600-034C29F1D5B0
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateApmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateApmResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateApmResponseBody) SetRequestId(v string) *UpdateApmResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateApmResponseBody) SetResult(v bool) *UpdateApmResponseBody {
	s.Result = &v
	return s
}

type UpdateApmResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateApmResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateApmResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateApmResponse) GoString() string {
	return s.String()
}

func (s *UpdateApmResponse) SetHeaders(v map[string]*string) *UpdateApmResponse {
	s.Headers = v
	return s
}

func (s *UpdateApmResponse) SetStatusCode(v int32) *UpdateApmResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateApmResponse) SetBody(v *UpdateApmResponseBody) *UpdateApmResponse {
	s.Body = v
	return s
}

type UpdateBlackIpsRequest struct {
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateBlackIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackIpsRequest) GoString() string {
	return s.String()
}

func (s *UpdateBlackIpsRequest) SetClientToken(v string) *UpdateBlackIpsRequest {
	s.ClientToken = &v
	return s
}

type UpdateBlackIpsResponseBody struct {
	RequestId *string                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *UpdateBlackIpsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateBlackIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackIpsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBlackIpsResponseBody) SetRequestId(v string) *UpdateBlackIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateBlackIpsResponseBody) SetResult(v *UpdateBlackIpsResponseBodyResult) *UpdateBlackIpsResponseBody {
	s.Result = v
	return s
}

type UpdateBlackIpsResponseBodyResult struct {
	EsIPBlacklist []*string `json:"esIPBlacklist,omitempty" xml:"esIPBlacklist,omitempty" type:"Repeated"`
}

func (s UpdateBlackIpsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackIpsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateBlackIpsResponseBodyResult) SetEsIPBlacklist(v []*string) *UpdateBlackIpsResponseBodyResult {
	s.EsIPBlacklist = v
	return s
}

type UpdateBlackIpsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateBlackIpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateBlackIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBlackIpsResponse) GoString() string {
	return s.String()
}

func (s *UpdateBlackIpsResponse) SetHeaders(v map[string]*string) *UpdateBlackIpsResponse {
	s.Headers = v
	return s
}

func (s *UpdateBlackIpsResponse) SetStatusCode(v int32) *UpdateBlackIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBlackIpsResponse) SetBody(v *UpdateBlackIpsResponseBody) *UpdateBlackIpsResponse {
	s.Body = v
	return s
}

type UpdateCollectorRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateCollectorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorRequest) GoString() string {
	return s.String()
}

func (s *UpdateCollectorRequest) SetClientToken(v string) *UpdateCollectorRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCollectorRequest) SetBody(v string) *UpdateCollectorRequest {
	s.Body = &v
	return s
}

type UpdateCollectorResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *UpdateCollectorResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateCollectorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCollectorResponseBody) SetRequestId(v string) *UpdateCollectorResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateCollectorResponseBody) SetResult(v *UpdateCollectorResponseBodyResult) *UpdateCollectorResponseBody {
	s.Result = v
	return s
}

type UpdateCollectorResponseBodyResult struct {
	CollectorPaths []*string `json:"collectorPaths,omitempty" xml:"collectorPaths,omitempty" type:"Repeated"`
	// The information about the configuration file for the shipper.
	Configs []*UpdateCollectorResponseBodyResultConfigs `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// Indicates whether the shipper is checked and updated. Valid values:
	//
	// 	- true: The shipper is only checked.
	//
	// 	- false: The shipper is checked and updated.
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
	// The extended parameters that are configured for the shipper.
	ExtendConfigs []*UpdateCollectorResponseBodyResultExtendConfigs `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// The time when the shipper was created.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtCreatedTime *string `json:"gmtCreatedTime,omitempty" xml:"gmtCreatedTime,omitempty"`
	// The time when the shipper was updated.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtUpdateTime *string `json:"gmtUpdateTime,omitempty" xml:"gmtUpdateTime,omitempty"`
	// The name of the shipper.
	//
	// example:
	//
	// ct-test
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The account ID.
	//
	// example:
	//
	// 16852099488*****
	OwnerId *string `json:"ownerId,omitempty" xml:"ownerId,omitempty"`
	// The shipper ID.
	//
	// example:
	//
	// ct-cn-0v3xj86085dvq****
	ResId *string `json:"resId,omitempty" xml:"resId,omitempty"`
	// The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.
	//
	// example:
	//
	// fileBeat
	ResType *string `json:"resType,omitempty" xml:"resType,omitempty"`
	// The version of the shipper.
	//
	// example:
	//
	// 6.8.5_with_community
	ResVersion *string `json:"resVersion,omitempty" xml:"resVersion,omitempty"`
	// The status of the shipper. Valid values:
	//
	// 	- activing: The shipper is being initialized.
	//
	// 	- active: The shipper is in effect.
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The ID of the VPC in which the shipper resides.
	//
	// example:
	//
	// vpc-bp16k1dvzxtma*****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s UpdateCollectorResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateCollectorResponseBodyResult) SetCollectorPaths(v []*string) *UpdateCollectorResponseBodyResult {
	s.CollectorPaths = v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetConfigs(v []*UpdateCollectorResponseBodyResultConfigs) *UpdateCollectorResponseBodyResult {
	s.Configs = v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetDryRun(v bool) *UpdateCollectorResponseBodyResult {
	s.DryRun = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetExtendConfigs(v []*UpdateCollectorResponseBodyResultExtendConfigs) *UpdateCollectorResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetGmtCreatedTime(v string) *UpdateCollectorResponseBodyResult {
	s.GmtCreatedTime = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetGmtUpdateTime(v string) *UpdateCollectorResponseBodyResult {
	s.GmtUpdateTime = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetName(v string) *UpdateCollectorResponseBodyResult {
	s.Name = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetOwnerId(v string) *UpdateCollectorResponseBodyResult {
	s.OwnerId = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetResId(v string) *UpdateCollectorResponseBodyResult {
	s.ResId = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetResType(v string) *UpdateCollectorResponseBodyResult {
	s.ResType = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetResVersion(v string) *UpdateCollectorResponseBodyResult {
	s.ResVersion = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetStatus(v string) *UpdateCollectorResponseBodyResult {
	s.Status = &v
	return s
}

func (s *UpdateCollectorResponseBodyResult) SetVpcId(v string) *UpdateCollectorResponseBodyResult {
	s.VpcId = &v
	return s
}

type UpdateCollectorResponseBodyResultConfigs struct {
	// The content of the configuration file.
	//
	// example:
	//
	// filebeat.inputs:xxx
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// The name of the configuration file.
	//
	// example:
	//
	// filebeat.yml
	FileName *string `json:"fileName,omitempty" xml:"fileName,omitempty"`
}

func (s UpdateCollectorResponseBodyResultConfigs) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorResponseBodyResultConfigs) GoString() string {
	return s.String()
}

func (s *UpdateCollectorResponseBodyResultConfigs) SetContent(v string) *UpdateCollectorResponseBodyResultConfigs {
	s.Content = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultConfigs) SetFileName(v string) *UpdateCollectorResponseBodyResultConfigs {
	s.FileName = &v
	return s
}

type UpdateCollectorResponseBodyResultExtendConfigs struct {
	// The type of the configuration items. Valid values:
	//
	// 	- collectorTargetInstance: indicates the information about the output of the shipper.
	//
	// 	- collectorDeployMachine: indicates the information about the machine on which the shipper is installed.
	//
	// 	- collectorElasticsearchForKibana: indicates the information about the Elasticsearch cluster for which Kibana Dashboard is enabled.
	//
	// example:
	//
	// collectorDeployMachine
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// Indicates whether Kibana Monitoring is enabled. This parameter is returned only when **configType*	- is set to **collectorTargetInstance*	- and **instanceType*	- is set to **elasticsearch**. Valid values: true and false.
	//
	// example:
	//
	// true
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" xml:"enableMonitoring,omitempty"`
	// The machine group ID. This parameter is returned only when **configType*	- is set to **collectorDeployMachine**.
	//
	// example:
	//
	// default_ct-cn-5i2l75bz4776****
	GroupId *string `json:"groupId,omitempty" xml:"groupId,omitempty"`
	// The address that is used to access Kibana over an internal network after you enable Kibana Dashboard. This parameter is returned only when **configType*	- is set to **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601
	Host  *string   `json:"host,omitempty" xml:"host,omitempty"`
	Hosts []*string `json:"hosts,omitempty" xml:"hosts,omitempty" type:"Repeated"`
	// The ID of the object that is associated with the shipper. If **configType*	- is set to **collectorTargetInstance**, the value of this parameter is the ID of the output of the shipper. If **configType*	- is set to **collectorDeployMachines*	- and **type*	- is set to **ACKCluster**, the value of this parameter is the ID of an ACK cluster.
	//
	// example:
	//
	// es-cn-nif1z89fz003i****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The type of the output of the shipper. Valid values: elasticsearch and logstash. This parameter is returned only when **configType*	- is set to **collectorTargetInstance**.
	//
	// example:
	//
	// elasticsearch
	InstanceType *string `json:"instanceType,omitempty" xml:"instanceType,omitempty"`
	// The address that is used to access Kibana over the Internet after you enable Kibana Dashboard. This parameter is returned only when **configType*	- is set to **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601
	KibanaHost *string `json:"kibanaHost,omitempty" xml:"kibanaHost,omitempty"`
	// This parameter is returned only when configType is set to collectorDeployMachine.
	//
	// This parameter indicates the information about the ECS instances or ACK clusters on which the shipper is installed.
	Machines []*UpdateCollectorResponseBodyResultExtendConfigsMachines `json:"machines,omitempty" xml:"machines,omitempty" type:"Repeated"`
	// The transfer protocol that is used. It is the same as the protocol over which you can access the output of the shipper. Valid values: HTTP and HTTPS. This parameter is returned only when **configType*	- is set to **collectorTargetInstance**.
	//
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// The number of pods from which logs are successfully collected in the ACK cluster. This parameter is returned only when **configType*	- is set to **collectorDeployMachines*	- and **type*	- is set to **ACKCluster**.
	//
	// example:
	//
	// 8
	SuccessPodsCount *string `json:"successPodsCount,omitempty" xml:"successPodsCount,omitempty"`
	// The number of pods from which logs needed to be collected in the ACK cluster. This parameter is returned only when **configType*	- is set to **collectorDeployMachines*	- and **type*	- is set to **ACKCluster**.
	//
	// example:
	//
	// 10
	TotalPodsCount *string `json:"totalPodsCount,omitempty" xml:"totalPodsCount,omitempty"`
	// The type of the machine on which the shipper is installed. This parameter is returned only when **configType*	- is set to **collectorDeployMachine**. Valid values:
	//
	// 	- ECSInstanceId
	//
	// 	- ACKCluster
	//
	// example:
	//
	// ECSInstanceId
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The username that is used to access the output of the shipper. Default value: elastic. This parameter is returned only when **configType*	- is set to **collectorTargetInstance*	- or **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s UpdateCollectorResponseBodyResultExtendConfigs) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorResponseBodyResultExtendConfigs) GoString() string {
	return s.String()
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetConfigType(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.ConfigType = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetEnableMonitoring(v bool) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.EnableMonitoring = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetGroupId(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.GroupId = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetHost(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.Host = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetHosts(v []*string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.Hosts = v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetInstanceId(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.InstanceId = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetInstanceType(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.InstanceType = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetKibanaHost(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.KibanaHost = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetMachines(v []*UpdateCollectorResponseBodyResultExtendConfigsMachines) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.Machines = v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetProtocol(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.Protocol = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetSuccessPodsCount(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.SuccessPodsCount = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetTotalPodsCount(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.TotalPodsCount = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetType(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.Type = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigs) SetUserName(v string) *UpdateCollectorResponseBodyResultExtendConfigs {
	s.UserName = &v
	return s
}

type UpdateCollectorResponseBodyResultExtendConfigsMachines struct {
	// The installation status of the shipper on an ECS instance. Valid values:
	//
	// 	- heartOk
	//
	// 	- heartLost
	//
	// 	- uninstalled
	//
	// 	- failed
	//
	// example:
	//
	// heartOk
	AgentStatus *string `json:"agentStatus,omitempty" xml:"agentStatus,omitempty"`
	// The ID of the ECS instance on which the shipper is installed.
	//
	// example:
	//
	// i-bp13y63575oypr9d****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
}

func (s UpdateCollectorResponseBodyResultExtendConfigsMachines) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorResponseBodyResultExtendConfigsMachines) GoString() string {
	return s.String()
}

func (s *UpdateCollectorResponseBodyResultExtendConfigsMachines) SetAgentStatus(v string) *UpdateCollectorResponseBodyResultExtendConfigsMachines {
	s.AgentStatus = &v
	return s
}

func (s *UpdateCollectorResponseBodyResultExtendConfigsMachines) SetInstanceId(v string) *UpdateCollectorResponseBodyResultExtendConfigsMachines {
	s.InstanceId = &v
	return s
}

type UpdateCollectorResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateCollectorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateCollectorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorResponse) GoString() string {
	return s.String()
}

func (s *UpdateCollectorResponse) SetHeaders(v map[string]*string) *UpdateCollectorResponse {
	s.Headers = v
	return s
}

func (s *UpdateCollectorResponse) SetStatusCode(v int32) *UpdateCollectorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCollectorResponse) SetBody(v *UpdateCollectorResponseBody) *UpdateCollectorResponse {
	s.Body = v
	return s
}

type UpdateCollectorNameRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateCollectorNameRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorNameRequest) GoString() string {
	return s.String()
}

func (s *UpdateCollectorNameRequest) SetClientToken(v string) *UpdateCollectorNameRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCollectorNameRequest) SetBody(v string) *UpdateCollectorNameRequest {
	s.Body = &v
	return s
}

type UpdateCollectorNameResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *UpdateCollectorNameResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateCollectorNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorNameResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCollectorNameResponseBody) SetRequestId(v string) *UpdateCollectorNameResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateCollectorNameResponseBody) SetResult(v *UpdateCollectorNameResponseBodyResult) *UpdateCollectorNameResponseBody {
	s.Result = v
	return s
}

type UpdateCollectorNameResponseBodyResult struct {
	CollectorPaths []*string `json:"collectorPaths,omitempty" xml:"collectorPaths,omitempty" type:"Repeated"`
	// The information about the configuration file of the shipper.
	Configs []*UpdateCollectorNameResponseBodyResultConfigs `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// Indicates whether a dry run is performed. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
	// The extended configurations of the shipper.
	ExtendConfigs []*UpdateCollectorNameResponseBodyResultExtendConfigs `json:"extendConfigs,omitempty" xml:"extendConfigs,omitempty" type:"Repeated"`
	// The time when the shipper was created.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtCreatedTime *string `json:"gmtCreatedTime,omitempty" xml:"gmtCreatedTime,omitempty"`
	// The time when the shipper was updated.
	//
	// example:
	//
	// 2020-06-20T07:26:47.000+0000
	GmtUpdateTime *string `json:"gmtUpdateTime,omitempty" xml:"gmtUpdateTime,omitempty"`
	// The name of the shipper.
	//
	// example:
	//
	// ct-test
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The account ID.
	//
	// example:
	//
	// 16852099488*****
	OwnerId *string `json:"ownerId,omitempty" xml:"ownerId,omitempty"`
	// The ID of the shipper.
	//
	// example:
	//
	// ct-cn-77uqof2s7rg5c****
	ResId *string `json:"resId,omitempty" xml:"resId,omitempty"`
	// The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and audiBeat.
	//
	// example:
	//
	// fileBeat
	ResType *string `json:"resType,omitempty" xml:"resType,omitempty"`
	// The version of the shipper. The version of a shipper depends on the type of the machine on which the shipper is deployed.
	//
	// 	- Elastic Compute Service (ECS) instance: 6.8.5_with_community
	//
	// 	- Container Service for Kubernetes (ACK) cluster: 6.8.13_with_community
	//
	// example:
	//
	// 6.8.5_with_community
	ResVersion *string `json:"resVersion,omitempty" xml:"resVersion,omitempty"`
	// The status of the shipper. Valid values: activating and active.
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The ID of the virtual private cloud (VPC) where the shipper resides.
	//
	// example:
	//
	// vpc-bp16k1dvzxtma*****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s UpdateCollectorNameResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorNameResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateCollectorNameResponseBodyResult) SetCollectorPaths(v []*string) *UpdateCollectorNameResponseBodyResult {
	s.CollectorPaths = v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetConfigs(v []*UpdateCollectorNameResponseBodyResultConfigs) *UpdateCollectorNameResponseBodyResult {
	s.Configs = v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetDryRun(v bool) *UpdateCollectorNameResponseBodyResult {
	s.DryRun = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetExtendConfigs(v []*UpdateCollectorNameResponseBodyResultExtendConfigs) *UpdateCollectorNameResponseBodyResult {
	s.ExtendConfigs = v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetGmtCreatedTime(v string) *UpdateCollectorNameResponseBodyResult {
	s.GmtCreatedTime = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetGmtUpdateTime(v string) *UpdateCollectorNameResponseBodyResult {
	s.GmtUpdateTime = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetName(v string) *UpdateCollectorNameResponseBodyResult {
	s.Name = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetOwnerId(v string) *UpdateCollectorNameResponseBodyResult {
	s.OwnerId = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetResId(v string) *UpdateCollectorNameResponseBodyResult {
	s.ResId = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetResType(v string) *UpdateCollectorNameResponseBodyResult {
	s.ResType = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetResVersion(v string) *UpdateCollectorNameResponseBodyResult {
	s.ResVersion = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetStatus(v string) *UpdateCollectorNameResponseBodyResult {
	s.Status = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResult) SetVpcId(v string) *UpdateCollectorNameResponseBodyResult {
	s.VpcId = &v
	return s
}

type UpdateCollectorNameResponseBodyResultConfigs struct {
	// The content of the file.
	//
	// example:
	//
	// - key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....
	Content *string `json:"content,omitempty" xml:"content,omitempty"`
	// The name of the file.
	//
	// example:
	//
	// fields.yml
	FileName *string `json:"fileName,omitempty" xml:"fileName,omitempty"`
}

func (s UpdateCollectorNameResponseBodyResultConfigs) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorNameResponseBodyResultConfigs) GoString() string {
	return s.String()
}

func (s *UpdateCollectorNameResponseBodyResultConfigs) SetContent(v string) *UpdateCollectorNameResponseBodyResultConfigs {
	s.Content = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultConfigs) SetFileName(v string) *UpdateCollectorNameResponseBodyResultConfigs {
	s.FileName = &v
	return s
}

type UpdateCollectorNameResponseBodyResultExtendConfigs struct {
	// The configuration type. Valid values:
	//
	// 	- collectorTargetInstance
	//
	// 	- collectorDeployMachine
	//
	// 	- collectorElasticsearchForKibana
	//
	// example:
	//
	// collectorDeployMachine
	ConfigType *string `json:"configType,omitempty" xml:"configType,omitempty"`
	// Indicates whether monitoring is enabled. This parameter is returned if the value of **configType*	- is **collectorTargetInstance*	- and the value of **instanceType*	- is **elasticsearch**. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	EnableMonitoring *bool `json:"enableMonitoring,omitempty" xml:"enableMonitoring,omitempty"`
	// The ID of the machine group. This parameter is returned if the value of **configType*	- is **collectorDeployMachine**.
	//
	// example:
	//
	// default_ct-cn-5i2l75bz4776****
	GroupId *string `json:"groupId,omitempty" xml:"groupId,omitempty"`
	// The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType*	- is **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// es-cn-4591jumei000u****-kibana.internal.elasticsearch.aliyuncs.com:5601
	Host  *string   `json:"host,omitempty" xml:"host,omitempty"`
	Hosts []*string `json:"hosts,omitempty" xml:"hosts,omitempty" type:"Repeated"`
	// The ID of the resource that is associated with the shipper. If the value of **configType*	- is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.
	//
	// example:
	//
	// es-cn-n6w1o1****
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType*	- is **collectorTargetInstance**.
	//
	// example:
	//
	// elasticsearch
	InstanceType *string `json:"instanceType,omitempty" xml:"instanceType,omitempty"`
	// The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType*	- is **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// https://es-cn-4591jumei000u****.kibana.elasticsearch.aliyuncs.com:5601
	KibanaHost *string `json:"kibanaHost,omitempty" xml:"kibanaHost,omitempty"`
	// The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ECSInstanceId**.
	Machines []*UpdateCollectorNameResponseBodyResultExtendConfigsMachines `json:"machines,omitempty" xml:"machines,omitempty" type:"Repeated"`
	// The transmission protocol. Valid values: **HTTP*	- and **HTTPS**.
	//
	// example:
	//
	// HTTP
	Protocol *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	// The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ACKCluster**.
	//
	// example:
	//
	// 8
	SuccessPodsCount *string `json:"successPodsCount,omitempty" xml:"successPodsCount,omitempty"`
	// The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType*	- is **collectorDeployMachine*	- and the value of **type*	- is **ACKCluster**.
	//
	// example:
	//
	// 10
	TotalPodsCount *string `json:"totalPodsCount,omitempty" xml:"totalPodsCount,omitempty"`
	// The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType*	- is **collectorDeployMachine**. Valid values:
	//
	// 	- ECSInstanceId
	//
	// 	- ACKCluster
	//
	// example:
	//
	// ECSInstanceId
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType*	- is **collectorTargetInstance*	- or **collectorElasticsearchForKibana**.
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s UpdateCollectorNameResponseBodyResultExtendConfigs) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorNameResponseBodyResultExtendConfigs) GoString() string {
	return s.String()
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetConfigType(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.ConfigType = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetEnableMonitoring(v bool) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.EnableMonitoring = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetGroupId(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.GroupId = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetHost(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.Host = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetHosts(v []*string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.Hosts = v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetInstanceId(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.InstanceId = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetInstanceType(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.InstanceType = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetKibanaHost(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.KibanaHost = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetMachines(v []*UpdateCollectorNameResponseBodyResultExtendConfigsMachines) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.Machines = v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetProtocol(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.Protocol = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetSuccessPodsCount(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.SuccessPodsCount = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetTotalPodsCount(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.TotalPodsCount = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetType(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.Type = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigs) SetUserName(v string) *UpdateCollectorNameResponseBodyResultExtendConfigs {
	s.UserName = &v
	return s
}

type UpdateCollectorNameResponseBodyResultExtendConfigsMachines struct {
	// The status of the shipper on the ECS instance. Valid values: **heartOk**, **heartLost**, **uninstalled**, and **failed**.
	//
	// example:
	//
	// heartOk
	AgentStatus *string `json:"agentStatus,omitempty" xml:"agentStatus,omitempty"`
	// The IDs of the ECS instances.
	//
	// example:
	//
	// c1b9fde5172b84f82b9928e825a7b8988
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
}

func (s UpdateCollectorNameResponseBodyResultExtendConfigsMachines) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorNameResponseBodyResultExtendConfigsMachines) GoString() string {
	return s.String()
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigsMachines) SetAgentStatus(v string) *UpdateCollectorNameResponseBodyResultExtendConfigsMachines {
	s.AgentStatus = &v
	return s
}

func (s *UpdateCollectorNameResponseBodyResultExtendConfigsMachines) SetInstanceId(v string) *UpdateCollectorNameResponseBodyResultExtendConfigsMachines {
	s.InstanceId = &v
	return s
}

type UpdateCollectorNameResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateCollectorNameResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateCollectorNameResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCollectorNameResponse) GoString() string {
	return s.String()
}

func (s *UpdateCollectorNameResponse) SetHeaders(v map[string]*string) *UpdateCollectorNameResponse {
	s.Headers = v
	return s
}

func (s *UpdateCollectorNameResponse) SetStatusCode(v int32) *UpdateCollectorNameResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCollectorNameResponse) SetBody(v *UpdateCollectorNameResponseBody) *UpdateCollectorNameResponse {
	s.Body = v
	return s
}

type UpdateComponentIndexRequest struct {
	// example:
	//
	// { "description": "set number of shards to one" }
	Meta     map[string]interface{}               `json:"_meta,omitempty" xml:"_meta,omitempty"`
	Template *UpdateComponentIndexRequestTemplate `json:"template,omitempty" xml:"template,omitempty" type:"Struct"`
}

func (s UpdateComponentIndexRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateComponentIndexRequest) GoString() string {
	return s.String()
}

func (s *UpdateComponentIndexRequest) SetMeta(v map[string]interface{}) *UpdateComponentIndexRequest {
	s.Meta = v
	return s
}

func (s *UpdateComponentIndexRequest) SetTemplate(v *UpdateComponentIndexRequestTemplate) *UpdateComponentIndexRequest {
	s.Template = v
	return s
}

type UpdateComponentIndexRequestTemplate struct {
	// example:
	//
	// {}
	Aliases map[string]interface{} `json:"aliases,omitempty" xml:"aliases,omitempty"`
	// example:
	//
	// { "properties": { "@timestamp": { "type": "date" } } }
	Mappings map[string]interface{} `json:"mappings,omitempty" xml:"mappings,omitempty"`
	// example:
	//
	// { "index.number_of_replicas": 0 }
	Settings map[string]interface{} `json:"settings,omitempty" xml:"settings,omitempty"`
}

func (s UpdateComponentIndexRequestTemplate) String() string {
	return tea.Prettify(s)
}

func (s UpdateComponentIndexRequestTemplate) GoString() string {
	return s.String()
}

func (s *UpdateComponentIndexRequestTemplate) SetAliases(v map[string]interface{}) *UpdateComponentIndexRequestTemplate {
	s.Aliases = v
	return s
}

func (s *UpdateComponentIndexRequestTemplate) SetMappings(v map[string]interface{}) *UpdateComponentIndexRequestTemplate {
	s.Mappings = v
	return s
}

func (s *UpdateComponentIndexRequestTemplate) SetSettings(v map[string]interface{}) *UpdateComponentIndexRequestTemplate {
	s.Settings = v
	return s
}

type UpdateComponentIndexResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC47D9
	RequestId *string `json:"requestId,omitempty" xml:"requestId,omitempty"`
}

func (s UpdateComponentIndexResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateComponentIndexResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateComponentIndexResponseBody) SetRequestId(v string) *UpdateComponentIndexResponseBody {
	s.RequestId = &v
	return s
}

type UpdateComponentIndexResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateComponentIndexResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateComponentIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateComponentIndexResponse) GoString() string {
	return s.String()
}

func (s *UpdateComponentIndexResponse) SetHeaders(v map[string]*string) *UpdateComponentIndexResponse {
	s.Headers = v
	return s
}

func (s *UpdateComponentIndexResponse) SetStatusCode(v int32) *UpdateComponentIndexResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateComponentIndexResponse) SetBody(v *UpdateComponentIndexResponseBody) *UpdateComponentIndexResponse {
	s.Body = v
	return s
}

type UpdateDescriptionRequest struct {
	// example:
	//
	// aliyunes_name_test
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The new name of the instance.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B350****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateDescriptionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDescriptionRequest) GoString() string {
	return s.String()
}

func (s *UpdateDescriptionRequest) SetDescription(v string) *UpdateDescriptionRequest {
	s.Description = &v
	return s
}

func (s *UpdateDescriptionRequest) SetClientToken(v string) *UpdateDescriptionRequest {
	s.ClientToken = &v
	return s
}

type UpdateDescriptionResponseBody struct {
	// example:
	//
	// FDF34727-1664-44C1-A8DA-3EB72D60****
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *UpdateDescriptionResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateDescriptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDescriptionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDescriptionResponseBody) SetRequestId(v string) *UpdateDescriptionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDescriptionResponseBody) SetResult(v *UpdateDescriptionResponseBodyResult) *UpdateDescriptionResponseBody {
	s.Result = v
	return s
}

type UpdateDescriptionResponseBodyResult struct {
	// example:
	//
	// aliyunes_test_name
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
}

func (s UpdateDescriptionResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateDescriptionResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateDescriptionResponseBodyResult) SetDescription(v string) *UpdateDescriptionResponseBodyResult {
	s.Description = &v
	return s
}

type UpdateDescriptionResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDescriptionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDescriptionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDescriptionResponse) GoString() string {
	return s.String()
}

func (s *UpdateDescriptionResponse) SetHeaders(v map[string]*string) *UpdateDescriptionResponse {
	s.Headers = v
	return s
}

func (s *UpdateDescriptionResponse) SetStatusCode(v int32) *UpdateDescriptionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDescriptionResponse) SetBody(v *UpdateDescriptionResponseBody) *UpdateDescriptionResponse {
	s.Body = v
	return s
}

type UpdateDiagnosisSettingsRequest struct {
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
	// The language of the response. Default value: en.
	//
	// example:
	//
	// en
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
}

func (s UpdateDiagnosisSettingsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDiagnosisSettingsRequest) GoString() string {
	return s.String()
}

func (s *UpdateDiagnosisSettingsRequest) SetClientToken(v string) *UpdateDiagnosisSettingsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateDiagnosisSettingsRequest) SetBody(v string) *UpdateDiagnosisSettingsRequest {
	s.Body = &v
	return s
}

func (s *UpdateDiagnosisSettingsRequest) SetLang(v string) *UpdateDiagnosisSettingsRequest {
	s.Lang = &v
	return s
}

type UpdateDiagnosisSettingsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: update successfully
	//
	// 	- false: update failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateDiagnosisSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDiagnosisSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDiagnosisSettingsResponseBody) SetRequestId(v string) *UpdateDiagnosisSettingsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDiagnosisSettingsResponseBody) SetResult(v bool) *UpdateDiagnosisSettingsResponseBody {
	s.Result = &v
	return s
}

type UpdateDiagnosisSettingsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDiagnosisSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDiagnosisSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDiagnosisSettingsResponse) GoString() string {
	return s.String()
}

func (s *UpdateDiagnosisSettingsResponse) SetHeaders(v map[string]*string) *UpdateDiagnosisSettingsResponse {
	s.Headers = v
	return s
}

func (s *UpdateDiagnosisSettingsResponse) SetStatusCode(v int32) *UpdateDiagnosisSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDiagnosisSettingsResponse) SetBody(v *UpdateDiagnosisSettingsResponseBody) *UpdateDiagnosisSettingsResponse {
	s.Body = v
	return s
}

type UpdateDictRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateDictRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDictRequest) GoString() string {
	return s.String()
}

func (s *UpdateDictRequest) SetBody(v string) *UpdateDictRequest {
	s.Body = &v
	return s
}

func (s *UpdateDictRequest) SetClientToken(v string) *UpdateDictRequest {
	s.ClientToken = &v
	return s
}

type UpdateDictResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*UpdateDictResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UpdateDictResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDictResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDictResponseBody) SetRequestId(v string) *UpdateDictResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDictResponseBody) SetResult(v []*UpdateDictResponseBodyResult) *UpdateDictResponseBody {
	s.Result = v
	return s
}

type UpdateDictResponseBodyResult struct {
	// The size of the dictionary file. Unit: bytes.
	//
	// example:
	//
	// 2782602
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// SYSTEM_MAIN.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type of the dictionary file. Valid values:
	//
	// 	- OSS
	//
	// 	- ORIGIN
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The dictionary type. Valid values:
	//
	// 	- MAIN: IK main dicrionary
	//
	// 	- STOP: IK stopword list
	//
	// example:
	//
	// MAIN
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateDictResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateDictResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateDictResponseBodyResult) SetFileSize(v int64) *UpdateDictResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *UpdateDictResponseBodyResult) SetName(v string) *UpdateDictResponseBodyResult {
	s.Name = &v
	return s
}

func (s *UpdateDictResponseBodyResult) SetSourceType(v string) *UpdateDictResponseBodyResult {
	s.SourceType = &v
	return s
}

func (s *UpdateDictResponseBodyResult) SetType(v string) *UpdateDictResponseBodyResult {
	s.Type = &v
	return s
}

type UpdateDictResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDictResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDictResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDictResponse) GoString() string {
	return s.String()
}

func (s *UpdateDictResponse) SetHeaders(v map[string]*string) *UpdateDictResponse {
	s.Headers = v
	return s
}

func (s *UpdateDictResponse) SetStatusCode(v int32) *UpdateDictResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDictResponse) SetBody(v *UpdateDictResponseBody) *UpdateDictResponse {
	s.Body = v
	return s
}

type UpdateDynamicSettingsRequest struct {
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	RegionId    *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
	Mode        *string `json:"mode,omitempty" xml:"mode,omitempty"`
}

func (s UpdateDynamicSettingsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDynamicSettingsRequest) GoString() string {
	return s.String()
}

func (s *UpdateDynamicSettingsRequest) SetClientToken(v string) *UpdateDynamicSettingsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateDynamicSettingsRequest) SetRegionId(v string) *UpdateDynamicSettingsRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateDynamicSettingsRequest) SetBody(v string) *UpdateDynamicSettingsRequest {
	s.Body = &v
	return s
}

func (s *UpdateDynamicSettingsRequest) SetMode(v string) *UpdateDynamicSettingsRequest {
	s.Mode = &v
	return s
}

type UpdateDynamicSettingsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *bool   `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateDynamicSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDynamicSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDynamicSettingsResponseBody) SetRequestId(v string) *UpdateDynamicSettingsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDynamicSettingsResponseBody) SetResult(v bool) *UpdateDynamicSettingsResponseBody {
	s.Result = &v
	return s
}

type UpdateDynamicSettingsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDynamicSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDynamicSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDynamicSettingsResponse) GoString() string {
	return s.String()
}

func (s *UpdateDynamicSettingsResponse) SetHeaders(v map[string]*string) *UpdateDynamicSettingsResponse {
	s.Headers = v
	return s
}

func (s *UpdateDynamicSettingsResponse) SetStatusCode(v int32) *UpdateDynamicSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDynamicSettingsResponse) SetBody(v *UpdateDynamicSettingsResponseBody) *UpdateDynamicSettingsResponse {
	s.Body = v
	return s
}

type UpdateExtendConfigRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateExtendConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateExtendConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateExtendConfigRequest) SetClientToken(v string) *UpdateExtendConfigRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateExtendConfigRequest) SetBody(v string) *UpdateExtendConfigRequest {
	s.Body = &v
	return s
}

type UpdateExtendConfigResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateExtendConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateExtendConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateExtendConfigResponseBody) SetRequestId(v string) *UpdateExtendConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateExtendConfigResponseBody) SetResult(v bool) *UpdateExtendConfigResponseBody {
	s.Result = &v
	return s
}

type UpdateExtendConfigResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateExtendConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateExtendConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateExtendConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateExtendConfigResponse) SetHeaders(v map[string]*string) *UpdateExtendConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateExtendConfigResponse) SetStatusCode(v int32) *UpdateExtendConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateExtendConfigResponse) SetBody(v *UpdateExtendConfigResponseBody) *UpdateExtendConfigResponse {
	s.Body = v
	return s
}

type UpdateExtendfilesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateExtendfilesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateExtendfilesRequest) GoString() string {
	return s.String()
}

func (s *UpdateExtendfilesRequest) SetClientToken(v string) *UpdateExtendfilesRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateExtendfilesRequest) SetBody(v string) *UpdateExtendfilesRequest {
	s.Body = &v
	return s
}

type UpdateExtendfilesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*UpdateExtendfilesResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UpdateExtendfilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateExtendfilesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateExtendfilesResponseBody) SetRequestId(v string) *UpdateExtendfilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateExtendfilesResponseBody) SetResult(v []*UpdateExtendfilesResponseBodyResult) *UpdateExtendfilesResponseBody {
	s.Result = v
	return s
}

type UpdateExtendfilesResponseBodyResult struct {
	// The size of the driver file. Unit: byte.
	//
	// example:
	//
	// 1853083
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the driver file.
	//
	// example:
	//
	// mysql-connector-java-6.0.2.jar
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source of the driver file. This parameter is fixed as ORIGIN, which indicates that the driver file is retained.
	//
	// example:
	//
	// ORIGIN
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
}

func (s UpdateExtendfilesResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateExtendfilesResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateExtendfilesResponseBodyResult) SetFileSize(v int64) *UpdateExtendfilesResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *UpdateExtendfilesResponseBodyResult) SetName(v string) *UpdateExtendfilesResponseBodyResult {
	s.Name = &v
	return s
}

func (s *UpdateExtendfilesResponseBodyResult) SetSourceType(v string) *UpdateExtendfilesResponseBodyResult {
	s.SourceType = &v
	return s
}

type UpdateExtendfilesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateExtendfilesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateExtendfilesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateExtendfilesResponse) GoString() string {
	return s.String()
}

func (s *UpdateExtendfilesResponse) SetHeaders(v map[string]*string) *UpdateExtendfilesResponse {
	s.Headers = v
	return s
}

func (s *UpdateExtendfilesResponse) SetStatusCode(v int32) *UpdateExtendfilesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateExtendfilesResponse) SetBody(v *UpdateExtendfilesResponseBody) *UpdateExtendfilesResponse {
	s.Body = v
	return s
}

type UpdateHotIkDictsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateHotIkDictsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateHotIkDictsRequest) GoString() string {
	return s.String()
}

func (s *UpdateHotIkDictsRequest) SetBody(v string) *UpdateHotIkDictsRequest {
	s.Body = &v
	return s
}

func (s *UpdateHotIkDictsRequest) SetClientToken(v string) *UpdateHotIkDictsRequest {
	s.ClientToken = &v
	return s
}

type UpdateHotIkDictsResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*UpdateHotIkDictsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UpdateHotIkDictsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateHotIkDictsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateHotIkDictsResponseBody) SetRequestId(v string) *UpdateHotIkDictsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateHotIkDictsResponseBody) SetResult(v []*UpdateHotIkDictsResponseBodyResult) *UpdateHotIkDictsResponseBody {
	s.Result = v
	return s
}

type UpdateHotIkDictsResponseBodyResult struct {
	// The size of the dictionary file. Unit: bytes.
	//
	// example:
	//
	// 6
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// deploy_0.dic
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type of the dictionary file. Valid values:
	//
	// 	- OSS
	//
	// 	- ORIGIN
	//
	// example:
	//
	// OSS
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The type of the dictionaries. Valid values:
	//
	// 	- MAIN: IK main dictionary
	//
	// 	- STOP: IK stopword list
	//
	// example:
	//
	// MAIN
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateHotIkDictsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateHotIkDictsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateHotIkDictsResponseBodyResult) SetFileSize(v int64) *UpdateHotIkDictsResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *UpdateHotIkDictsResponseBodyResult) SetName(v string) *UpdateHotIkDictsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *UpdateHotIkDictsResponseBodyResult) SetSourceType(v string) *UpdateHotIkDictsResponseBodyResult {
	s.SourceType = &v
	return s
}

func (s *UpdateHotIkDictsResponseBodyResult) SetType(v string) *UpdateHotIkDictsResponseBodyResult {
	s.Type = &v
	return s
}

type UpdateHotIkDictsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateHotIkDictsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateHotIkDictsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateHotIkDictsResponse) GoString() string {
	return s.String()
}

func (s *UpdateHotIkDictsResponse) SetHeaders(v map[string]*string) *UpdateHotIkDictsResponse {
	s.Headers = v
	return s
}

func (s *UpdateHotIkDictsResponse) SetStatusCode(v int32) *UpdateHotIkDictsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateHotIkDictsResponse) SetBody(v *UpdateHotIkDictsResponseBody) *UpdateHotIkDictsResponse {
	s.Body = v
	return s
}

type UpdateILMPolicyRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateILMPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateILMPolicyRequest) GoString() string {
	return s.String()
}

func (s *UpdateILMPolicyRequest) SetClientToken(v string) *UpdateILMPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateILMPolicyRequest) SetBody(v string) *UpdateILMPolicyRequest {
	s.Body = &v
	return s
}

type UpdateILMPolicyResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// my-policy
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateILMPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateILMPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateILMPolicyResponseBody) SetRequestId(v string) *UpdateILMPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateILMPolicyResponseBody) SetResult(v string) *UpdateILMPolicyResponseBody {
	s.Result = &v
	return s
}

type UpdateILMPolicyResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateILMPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateILMPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateILMPolicyResponse) GoString() string {
	return s.String()
}

func (s *UpdateILMPolicyResponse) SetHeaders(v map[string]*string) *UpdateILMPolicyResponse {
	s.Headers = v
	return s
}

func (s *UpdateILMPolicyResponse) SetStatusCode(v int32) *UpdateILMPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateILMPolicyResponse) SetBody(v *UpdateILMPolicyResponseBody) *UpdateILMPolicyResponse {
	s.Body = v
	return s
}

type UpdateIndexTemplateRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateIndexTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIndexTemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateIndexTemplateRequest) SetClientToken(v string) *UpdateIndexTemplateRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateIndexTemplateRequest) SetBody(v string) *UpdateIndexTemplateRequest {
	s.Body = &v
	return s
}

type UpdateIndexTemplateResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// my-template
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateIndexTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIndexTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIndexTemplateResponseBody) SetRequestId(v string) *UpdateIndexTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateIndexTemplateResponseBody) SetResult(v string) *UpdateIndexTemplateResponseBody {
	s.Result = &v
	return s
}

type UpdateIndexTemplateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateIndexTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateIndexTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIndexTemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateIndexTemplateResponse) SetHeaders(v map[string]*string) *UpdateIndexTemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateIndexTemplateResponse) SetStatusCode(v int32) *UpdateIndexTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIndexTemplateResponse) SetBody(v *UpdateIndexTemplateResponseBody) *UpdateIndexTemplateResponse {
	s.Body = v
	return s
}

type UpdateInstanceRequest struct {
	ClientNodeConfiguration      *ClientNodeConfiguration      `json:"clientNodeConfiguration,omitempty" xml:"clientNodeConfiguration,omitempty"`
	ElasticDataNodeConfiguration *ElasticDataNodeConfiguration `json:"elasticDataNodeConfiguration,omitempty" xml:"elasticDataNodeConfiguration,omitempty"`
	// example:
	//
	// advanced
	InstanceCategory    *string                  `json:"instanceCategory,omitempty" xml:"instanceCategory,omitempty"`
	KibanaConfiguration *KibanaNodeConfiguration `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty"`
	MasterConfiguration *MasterNodeConfiguration `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty"`
	// example:
	//
	// 3
	NodeAmount            *int32                 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	NodeSpec              *NodeSpec              `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty"`
	WarmNodeConfiguration *WarmNodeConfiguration `json:"warmNodeConfiguration,omitempty" xml:"warmNodeConfiguration,omitempty"`
	// The result of the request.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// example:
	//
	// false
	Force *bool `json:"force,omitempty" xml:"force,omitempty"`
	// The number of data nodes.
	//
	// example:
	//
	// upgrade
	OrderActionType *string `json:"orderActionType,omitempty" xml:"orderActionType,omitempty"`
}

func (s UpdateInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceRequest) GoString() string {
	return s.String()
}

func (s *UpdateInstanceRequest) SetClientNodeConfiguration(v *ClientNodeConfiguration) *UpdateInstanceRequest {
	s.ClientNodeConfiguration = v
	return s
}

func (s *UpdateInstanceRequest) SetElasticDataNodeConfiguration(v *ElasticDataNodeConfiguration) *UpdateInstanceRequest {
	s.ElasticDataNodeConfiguration = v
	return s
}

func (s *UpdateInstanceRequest) SetInstanceCategory(v string) *UpdateInstanceRequest {
	s.InstanceCategory = &v
	return s
}

func (s *UpdateInstanceRequest) SetKibanaConfiguration(v *KibanaNodeConfiguration) *UpdateInstanceRequest {
	s.KibanaConfiguration = v
	return s
}

func (s *UpdateInstanceRequest) SetMasterConfiguration(v *MasterNodeConfiguration) *UpdateInstanceRequest {
	s.MasterConfiguration = v
	return s
}

func (s *UpdateInstanceRequest) SetNodeAmount(v int32) *UpdateInstanceRequest {
	s.NodeAmount = &v
	return s
}

func (s *UpdateInstanceRequest) SetNodeSpec(v *NodeSpec) *UpdateInstanceRequest {
	s.NodeSpec = v
	return s
}

func (s *UpdateInstanceRequest) SetWarmNodeConfiguration(v *WarmNodeConfiguration) *UpdateInstanceRequest {
	s.WarmNodeConfiguration = v
	return s
}

func (s *UpdateInstanceRequest) SetClientToken(v string) *UpdateInstanceRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateInstanceRequest) SetForce(v bool) *UpdateInstanceRequest {
	s.Force = &v
	return s
}

func (s *UpdateInstanceRequest) SetOrderActionType(v string) *UpdateInstanceRequest {
	s.OrderActionType = &v
	return s
}

type UpdateInstanceResponseBody struct {
	Code    *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The time when the instance was created.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The state of the instance. Valid values:
	//
	// 	- active: normal
	//
	// 	- activating: taking effect
	//
	// 	- inactive: frozen
	//
	// 	- invalid: invalid
	Result *UpdateInstanceResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponseBody) SetCode(v string) *UpdateInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateInstanceResponseBody) SetMessage(v string) *UpdateInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateInstanceResponseBody) SetRequestId(v string) *UpdateInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateInstanceResponseBody) SetResult(v *UpdateInstanceResponseBodyResult) *UpdateInstanceResponseBody {
	s.Result = v
	return s
}

type UpdateInstanceResponseBodyResult struct {
	// The private domain name of the instance.
	//
	// example:
	//
	// 2018-07-13T03:58:07.253Z
	CreatedAt *string `json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The configuration of data nodes.
	//
	// example:
	//
	// test
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The ID of the instance.
	//
	// example:
	//
	// es-cn-abc.elasticsearch.aliyuncs.com
	Domain *string `json:"domain,omitempty" xml:"domain,omitempty"`
	// The node specifications.
	//
	// example:
	//
	// 5.5.3_with_X-Pack
	EsVersion *string `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	// The storage space of the node. Unit: GB.
	//
	// example:
	//
	// es-cn-abc
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// The size of the node storage space.
	KibanaConfiguration *UpdateInstanceResponseBodyResultKibanaConfiguration `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty" type:"Struct"`
	// The storage space of the node. Unit: GB.
	MasterConfiguration *UpdateInstanceResponseBodyResultMasterConfiguration `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty" type:"Struct"`
	// The billing method of the instance. Valid values:
	//
	// 	- prepaid: subscription
	//
	// 	- postpaid: pay-as-you-go
	//
	// example:
	//
	// 2
	NodeAmount *int32 `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	// The storage type of the node. Valid values:
	//
	// 	- cloud_ssd: standard SSD
	//
	// 	- cloud_efficiency: ultra disk
	NodeSpec *UpdateInstanceResponseBodyResultNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// The edition of the dedicated KMS instance.
	//
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// The name of the instance.
	//
	// example:
	//
	// active
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s UpdateInstanceResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponseBodyResult) SetCreatedAt(v string) *UpdateInstanceResponseBodyResult {
	s.CreatedAt = &v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetDescription(v string) *UpdateInstanceResponseBodyResult {
	s.Description = &v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetDomain(v string) *UpdateInstanceResponseBodyResult {
	s.Domain = &v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetEsVersion(v string) *UpdateInstanceResponseBodyResult {
	s.EsVersion = &v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetInstanceId(v string) *UpdateInstanceResponseBodyResult {
	s.InstanceId = &v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetKibanaConfiguration(v *UpdateInstanceResponseBodyResultKibanaConfiguration) *UpdateInstanceResponseBodyResult {
	s.KibanaConfiguration = v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetMasterConfiguration(v *UpdateInstanceResponseBodyResultMasterConfiguration) *UpdateInstanceResponseBodyResult {
	s.MasterConfiguration = v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetNodeAmount(v int32) *UpdateInstanceResponseBodyResult {
	s.NodeAmount = &v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetNodeSpec(v *UpdateInstanceResponseBodyResultNodeSpec) *UpdateInstanceResponseBodyResult {
	s.NodeSpec = v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetPaymentType(v string) *UpdateInstanceResponseBodyResult {
	s.PaymentType = &v
	return s
}

func (s *UpdateInstanceResponseBodyResult) SetStatus(v string) *UpdateInstanceResponseBodyResult {
	s.Status = &v
	return s
}

type UpdateInstanceResponseBodyResultKibanaConfiguration struct {
	// The configuration of dedicated master nodes.
	//
	// example:
	//
	// 1
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// The node specifications.
	//
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The number of nodes.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The storage type of the node. This parameter can be ignored.
	//
	// example:
	//
	// elasticsearch.n4.small
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s UpdateInstanceResponseBodyResultKibanaConfiguration) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponseBodyResultKibanaConfiguration) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponseBodyResultKibanaConfiguration) SetAmount(v int32) *UpdateInstanceResponseBodyResultKibanaConfiguration {
	s.Amount = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultKibanaConfiguration) SetDisk(v int32) *UpdateInstanceResponseBodyResultKibanaConfiguration {
	s.Disk = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultKibanaConfiguration) SetDiskType(v string) *UpdateInstanceResponseBodyResultKibanaConfiguration {
	s.DiskType = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultKibanaConfiguration) SetSpec(v string) *UpdateInstanceResponseBodyResultKibanaConfiguration {
	s.Spec = &v
	return s
}

type UpdateInstanceResponseBodyResultMasterConfiguration struct {
	// example:
	//
	// 3
	Amount *int32 `json:"amount,omitempty" xml:"amount,omitempty"`
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.
	//
	// example:
	//
	// elasticsearch.sn2ne.large
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s UpdateInstanceResponseBodyResultMasterConfiguration) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponseBodyResultMasterConfiguration) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponseBodyResultMasterConfiguration) SetAmount(v int32) *UpdateInstanceResponseBodyResultMasterConfiguration {
	s.Amount = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultMasterConfiguration) SetDisk(v int32) *UpdateInstanceResponseBodyResultMasterConfiguration {
	s.Disk = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultMasterConfiguration) SetDiskType(v string) *UpdateInstanceResponseBodyResultMasterConfiguration {
	s.DiskType = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultMasterConfiguration) SetSpec(v string) *UpdateInstanceResponseBodyResultMasterConfiguration {
	s.Spec = &v
	return s
}

type UpdateInstanceResponseBodyResultNodeSpec struct {
	// The node specifications.
	//
	// example:
	//
	// 40
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// The number of nodes.
	//
	// example:
	//
	// cloud_ssd
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// The configuration of Kibana nodes.
	//
	// example:
	//
	// elasticsearch.sn2ne.xlarge
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s UpdateInstanceResponseBodyResultNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponseBodyResultNodeSpec) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponseBodyResultNodeSpec) SetDisk(v int32) *UpdateInstanceResponseBodyResultNodeSpec {
	s.Disk = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultNodeSpec) SetDiskType(v string) *UpdateInstanceResponseBodyResultNodeSpec {
	s.DiskType = &v
	return s
}

func (s *UpdateInstanceResponseBodyResultNodeSpec) SetSpec(v string) *UpdateInstanceResponseBodyResultNodeSpec {
	s.Spec = &v
	return s
}

type UpdateInstanceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponse) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponse) SetHeaders(v map[string]*string) *UpdateInstanceResponse {
	s.Headers = v
	return s
}

func (s *UpdateInstanceResponse) SetStatusCode(v int32) *UpdateInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateInstanceResponse) SetBody(v *UpdateInstanceResponseBody) *UpdateInstanceResponse {
	s.Body = v
	return s
}

type UpdateInstanceChargeTypeRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateInstanceChargeTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceChargeTypeRequest) GoString() string {
	return s.String()
}

func (s *UpdateInstanceChargeTypeRequest) SetBody(v string) *UpdateInstanceChargeTypeRequest {
	s.Body = &v
	return s
}

func (s *UpdateInstanceChargeTypeRequest) SetClientToken(v string) *UpdateInstanceChargeTypeRequest {
	s.ClientToken = &v
	return s
}

type UpdateInstanceChargeTypeResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: conversion successful
	//
	// 	- false: conversion failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateInstanceChargeTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceChargeTypeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateInstanceChargeTypeResponseBody) SetRequestId(v string) *UpdateInstanceChargeTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateInstanceChargeTypeResponseBody) SetResult(v bool) *UpdateInstanceChargeTypeResponseBody {
	s.Result = &v
	return s
}

type UpdateInstanceChargeTypeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateInstanceChargeTypeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateInstanceChargeTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceChargeTypeResponse) GoString() string {
	return s.String()
}

func (s *UpdateInstanceChargeTypeResponse) SetHeaders(v map[string]*string) *UpdateInstanceChargeTypeResponse {
	s.Headers = v
	return s
}

func (s *UpdateInstanceChargeTypeResponse) SetStatusCode(v int32) *UpdateInstanceChargeTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateInstanceChargeTypeResponse) SetBody(v *UpdateInstanceChargeTypeResponseBody) *UpdateInstanceChargeTypeResponse {
	s.Body = v
	return s
}

type UpdateInstanceSettingsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateInstanceSettingsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceSettingsRequest) GoString() string {
	return s.String()
}

func (s *UpdateInstanceSettingsRequest) SetBody(v string) *UpdateInstanceSettingsRequest {
	s.Body = &v
	return s
}

func (s *UpdateInstanceSettingsRequest) SetClientToken(v string) *UpdateInstanceSettingsRequest {
	s.ClientToken = &v
	return s
}

type UpdateInstanceSettingsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// BB1C321A-211C-4FD7-BD8B-7F2FABE2****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateInstanceSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateInstanceSettingsResponseBody) SetRequestId(v string) *UpdateInstanceSettingsResponseBody {
	s.RequestId = &v
	return s
}

type UpdateInstanceSettingsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateInstanceSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateInstanceSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceSettingsResponse) GoString() string {
	return s.String()
}

func (s *UpdateInstanceSettingsResponse) SetHeaders(v map[string]*string) *UpdateInstanceSettingsResponse {
	s.Headers = v
	return s
}

func (s *UpdateInstanceSettingsResponse) SetStatusCode(v int32) *UpdateInstanceSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateInstanceSettingsResponse) SetBody(v *UpdateInstanceSettingsResponseBody) *UpdateInstanceSettingsResponse {
	s.Body = v
	return s
}

type UpdateKibanaPvlNetworkRequest struct {
	// example:
	//
	// es-cn-27a3mul6l00***-kibana
	EndpointName   *string   `json:"endpointName,omitempty" xml:"endpointName,omitempty"`
	SecurityGroups []*string `json:"securityGroups,omitempty" xml:"securityGroups,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// es-cn-27a3mul6l0***-kibana-internal
	PvlId *string `json:"pvlId,omitempty" xml:"pvlId,omitempty"`
}

func (s UpdateKibanaPvlNetworkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaPvlNetworkRequest) GoString() string {
	return s.String()
}

func (s *UpdateKibanaPvlNetworkRequest) SetEndpointName(v string) *UpdateKibanaPvlNetworkRequest {
	s.EndpointName = &v
	return s
}

func (s *UpdateKibanaPvlNetworkRequest) SetSecurityGroups(v []*string) *UpdateKibanaPvlNetworkRequest {
	s.SecurityGroups = v
	return s
}

func (s *UpdateKibanaPvlNetworkRequest) SetPvlId(v string) *UpdateKibanaPvlNetworkRequest {
	s.PvlId = &v
	return s
}

type UpdateKibanaPvlNetworkResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateKibanaPvlNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaPvlNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateKibanaPvlNetworkResponseBody) SetRequestId(v string) *UpdateKibanaPvlNetworkResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateKibanaPvlNetworkResponseBody) SetResult(v bool) *UpdateKibanaPvlNetworkResponseBody {
	s.Result = &v
	return s
}

type UpdateKibanaPvlNetworkResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateKibanaPvlNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateKibanaPvlNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaPvlNetworkResponse) GoString() string {
	return s.String()
}

func (s *UpdateKibanaPvlNetworkResponse) SetHeaders(v map[string]*string) *UpdateKibanaPvlNetworkResponse {
	s.Headers = v
	return s
}

func (s *UpdateKibanaPvlNetworkResponse) SetStatusCode(v int32) *UpdateKibanaPvlNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateKibanaPvlNetworkResponse) SetBody(v *UpdateKibanaPvlNetworkResponseBody) *UpdateKibanaPvlNetworkResponse {
	s.Body = v
	return s
}

type UpdateKibanaSettingsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B350****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateKibanaSettingsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaSettingsRequest) GoString() string {
	return s.String()
}

func (s *UpdateKibanaSettingsRequest) SetBody(v string) *UpdateKibanaSettingsRequest {
	s.Body = &v
	return s
}

func (s *UpdateKibanaSettingsRequest) SetClientToken(v string) *UpdateKibanaSettingsRequest {
	s.ClientToken = &v
	return s
}

type UpdateKibanaSettingsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DC*****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Return results:
	//
	// 	- true: The Kibana language modified successfully
	//
	// 	- false: The Kibana language modified failed
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateKibanaSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateKibanaSettingsResponseBody) SetRequestId(v string) *UpdateKibanaSettingsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateKibanaSettingsResponseBody) SetResult(v bool) *UpdateKibanaSettingsResponseBody {
	s.Result = &v
	return s
}

type UpdateKibanaSettingsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateKibanaSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateKibanaSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaSettingsResponse) GoString() string {
	return s.String()
}

func (s *UpdateKibanaSettingsResponse) SetHeaders(v map[string]*string) *UpdateKibanaSettingsResponse {
	s.Headers = v
	return s
}

func (s *UpdateKibanaSettingsResponse) SetStatusCode(v int32) *UpdateKibanaSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateKibanaSettingsResponse) SetBody(v *UpdateKibanaSettingsResponseBody) *UpdateKibanaSettingsResponse {
	s.Body = v
	return s
}

type UpdateKibanaWhiteIpsRequest struct {
	// The IP address whitelists. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.
	//
	// You cannot configure both the kibanaIPWhitelist and whiteIpGroup parameters.
	KibanaIPWhitelist []*string `json:"kibanaIPWhitelist,omitempty" xml:"kibanaIPWhitelist,omitempty" type:"Repeated"`
	// The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.
	WhiteIpGroup *UpdateKibanaWhiteIpsRequestWhiteIpGroup `json:"whiteIpGroup,omitempty" xml:"whiteIpGroup,omitempty" type:"Struct"`
	// The update mode. Valid values:
	//
	// 	- Cover: overwrites the IP addresses in the specified IP address whitelist with the IP addresses specified by using the ips parameter. This is the default value.
	//
	// 	- Append: adds the IP addresses specified by using the ips parameter to the specified IP address whitelist.
	//
	// 	- Delete: deletes the IP addresses specified by using the ips parameter from the specified IP address whitelist. At least one IP address must be retained for the whitelist.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The body of the request.
	//
	// example:
	//
	// Cover
	ModifyMode *string `json:"modifyMode,omitempty" xml:"modifyMode,omitempty"`
}

func (s UpdateKibanaWhiteIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaWhiteIpsRequest) GoString() string {
	return s.String()
}

func (s *UpdateKibanaWhiteIpsRequest) SetKibanaIPWhitelist(v []*string) *UpdateKibanaWhiteIpsRequest {
	s.KibanaIPWhitelist = v
	return s
}

func (s *UpdateKibanaWhiteIpsRequest) SetWhiteIpGroup(v *UpdateKibanaWhiteIpsRequestWhiteIpGroup) *UpdateKibanaWhiteIpsRequest {
	s.WhiteIpGroup = v
	return s
}

func (s *UpdateKibanaWhiteIpsRequest) SetClientToken(v string) *UpdateKibanaWhiteIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateKibanaWhiteIpsRequest) SetModifyMode(v string) *UpdateKibanaWhiteIpsRequest {
	s.ModifyMode = &v
	return s
}

type UpdateKibanaWhiteIpsRequestWhiteIpGroup struct {
	// The type of the whitelist. Set the value to PUBLIC_KIBANA. This value indicates a public IP address whitelist.
	//
	// example:
	//
	// test_group_name
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	// The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.
	Ips []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
	// The IP addresses in the whitelist.
	//
	// example:
	//
	// PUBLIC_KIBANA
	WhiteIpType *string `json:"whiteIpType,omitempty" xml:"whiteIpType,omitempty"`
}

func (s UpdateKibanaWhiteIpsRequestWhiteIpGroup) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaWhiteIpsRequestWhiteIpGroup) GoString() string {
	return s.String()
}

func (s *UpdateKibanaWhiteIpsRequestWhiteIpGroup) SetGroupName(v string) *UpdateKibanaWhiteIpsRequestWhiteIpGroup {
	s.GroupName = &v
	return s
}

func (s *UpdateKibanaWhiteIpsRequestWhiteIpGroup) SetIps(v []*string) *UpdateKibanaWhiteIpsRequestWhiteIpGroup {
	s.Ips = v
	return s
}

func (s *UpdateKibanaWhiteIpsRequestWhiteIpGroup) SetWhiteIpType(v string) *UpdateKibanaWhiteIpsRequestWhiteIpGroup {
	s.WhiteIpType = &v
	return s
}

type UpdateKibanaWhiteIpsResponseBody struct {
	// The details of the Elasticsearch cluster.
	//
	// example:
	//
	// E5EF11F1-DBAE-4020-AC24-DFA6C4345CAE
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The private IP address whitelists for access to the Kibana console of the cluster.
	Result *UpdateKibanaWhiteIpsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateKibanaWhiteIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaWhiteIpsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateKibanaWhiteIpsResponseBody) SetRequestId(v string) *UpdateKibanaWhiteIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBody) SetResult(v *UpdateKibanaWhiteIpsResponseBodyResult) *UpdateKibanaWhiteIpsResponseBody {
	s.Result = v
	return s
}

type UpdateKibanaWhiteIpsResponseBodyResult struct {
	// The public IP address whitelists for access to the Kibana console of the cluster.
	KibanaIPWhitelist []*string `json:"kibanaIPWhitelist,omitempty" xml:"kibanaIPWhitelist,omitempty" type:"Repeated"`
	// The private IP address whitelists for access to the Kibana console of the cluster.
	KibanaPrivateIPWhitelist []*string `json:"kibanaPrivateIPWhitelist,omitempty" xml:"kibanaPrivateIPWhitelist,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC).
	NetworkConfig *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
}

func (s UpdateKibanaWhiteIpsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaWhiteIpsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateKibanaWhiteIpsResponseBodyResult) SetKibanaIPWhitelist(v []*string) *UpdateKibanaWhiteIpsResponseBodyResult {
	s.KibanaIPWhitelist = v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResult) SetKibanaPrivateIPWhitelist(v []*string) *UpdateKibanaWhiteIpsResponseBodyResult {
	s.KibanaPrivateIPWhitelist = v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResult) SetNetworkConfig(v *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) *UpdateKibanaWhiteIpsResponseBodyResult {
	s.NetworkConfig = v
	return s
}

type UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig struct {
	// The IP address whitelists.
	//
	// example:
	//
	// vpc
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// The ID of the vSwitch.
	//
	// example:
	//
	// vpc-bp1jy348ibzulk6hn****
	VpcId *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
	// The network type.
	//
	// example:
	//
	// cn-hangzhou-h
	VsArea *string `json:"vsArea,omitempty" xml:"vsArea,omitempty"`
	// The region ID.
	//
	// example:
	//
	// vsw-bp1a0mifpletdd1da****
	VswitchId *string `json:"vswitchId,omitempty" xml:"vswitchId,omitempty"`
	// The IP address whitelists.
	WhiteIpGroupList []*UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList `json:"whiteIpGroupList,omitempty" xml:"whiteIpGroupList,omitempty" type:"Repeated"`
}

func (s UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) SetType(v string) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig {
	s.Type = &v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) SetVpcId(v string) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig {
	s.VpcId = &v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) SetVsArea(v string) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig {
	s.VsArea = &v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) SetVswitchId(v string) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig {
	s.VswitchId = &v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig) SetWhiteIpGroupList(v []*UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig {
	s.WhiteIpGroupList = v
	return s
}

type UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList struct {
	// The IP addresses in the whitelist.
	//
	// example:
	//
	// test_group_name
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	// The IP addresses in the whitelist.
	Ips []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
	// example:
	//
	// PUBLIC_KIBANA
	WhiteIpType *string `json:"whiteIpType,omitempty" xml:"whiteIpType,omitempty"`
}

func (s UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) GoString() string {
	return s.String()
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) SetGroupName(v string) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.GroupName = &v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) SetIps(v []*string) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.Ips = v
	return s
}

func (s *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) SetWhiteIpType(v string) *UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.WhiteIpType = &v
	return s
}

type UpdateKibanaWhiteIpsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateKibanaWhiteIpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateKibanaWhiteIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateKibanaWhiteIpsResponse) GoString() string {
	return s.String()
}

func (s *UpdateKibanaWhiteIpsResponse) SetHeaders(v map[string]*string) *UpdateKibanaWhiteIpsResponse {
	s.Headers = v
	return s
}

func (s *UpdateKibanaWhiteIpsResponse) SetStatusCode(v int32) *UpdateKibanaWhiteIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateKibanaWhiteIpsResponse) SetBody(v *UpdateKibanaWhiteIpsResponseBody) *UpdateKibanaWhiteIpsResponse {
	s.Body = v
	return s
}

type UpdateLogstashRequest struct {
	// example:
	//
	// 3
	NodeAmount *int32                         `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	NodeSpec   *UpdateLogstashRequestNodeSpec `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty" type:"Struct"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateLogstashRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogstashRequest) SetNodeAmount(v int32) *UpdateLogstashRequest {
	s.NodeAmount = &v
	return s
}

func (s *UpdateLogstashRequest) SetNodeSpec(v *UpdateLogstashRequestNodeSpec) *UpdateLogstashRequest {
	s.NodeSpec = v
	return s
}

func (s *UpdateLogstashRequest) SetClientToken(v string) *UpdateLogstashRequest {
	s.ClientToken = &v
	return s
}

type UpdateLogstashRequestNodeSpec struct {
	// example:
	//
	// 20
	Disk *int32 `json:"disk,omitempty" xml:"disk,omitempty"`
	// example:
	//
	// cloud_efficiency
	DiskType *string `json:"diskType,omitempty" xml:"diskType,omitempty"`
	// example:
	//
	// elasticsearch.sn1ne.large
	Spec *string `json:"spec,omitempty" xml:"spec,omitempty"`
}

func (s UpdateLogstashRequestNodeSpec) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashRequestNodeSpec) GoString() string {
	return s.String()
}

func (s *UpdateLogstashRequestNodeSpec) SetDisk(v int32) *UpdateLogstashRequestNodeSpec {
	s.Disk = &v
	return s
}

func (s *UpdateLogstashRequestNodeSpec) SetDiskType(v string) *UpdateLogstashRequestNodeSpec {
	s.DiskType = &v
	return s
}

func (s *UpdateLogstashRequestNodeSpec) SetSpec(v string) *UpdateLogstashRequestNodeSpec {
	s.Spec = &v
	return s
}

type UpdateLogstashResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateLogstashResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateLogstashResponseBody) SetRequestId(v string) *UpdateLogstashResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateLogstashResponseBody) SetResult(v bool) *UpdateLogstashResponseBody {
	s.Result = &v
	return s
}

type UpdateLogstashResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateLogstashResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateLogstashResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogstashResponse) SetHeaders(v map[string]*string) *UpdateLogstashResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogstashResponse) SetStatusCode(v int32) *UpdateLogstashResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateLogstashResponse) SetBody(v *UpdateLogstashResponseBody) *UpdateLogstashResponse {
	s.Body = v
	return s
}

type UpdateLogstashChargeTypeRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateLogstashChargeTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashChargeTypeRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogstashChargeTypeRequest) SetBody(v string) *UpdateLogstashChargeTypeRequest {
	s.Body = &v
	return s
}

func (s *UpdateLogstashChargeTypeRequest) SetClientToken(v string) *UpdateLogstashChargeTypeRequest {
	s.ClientToken = &v
	return s
}

type UpdateLogstashChargeTypeResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the billing method of the cluster is switched. Valid values:
	//
	// 	- true: The billing method is switched.
	//
	// 	- false: The billing method fails to be switched.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateLogstashChargeTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashChargeTypeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateLogstashChargeTypeResponseBody) SetRequestId(v string) *UpdateLogstashChargeTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateLogstashChargeTypeResponseBody) SetResult(v bool) *UpdateLogstashChargeTypeResponseBody {
	s.Result = &v
	return s
}

type UpdateLogstashChargeTypeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateLogstashChargeTypeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateLogstashChargeTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashChargeTypeResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogstashChargeTypeResponse) SetHeaders(v map[string]*string) *UpdateLogstashChargeTypeResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogstashChargeTypeResponse) SetStatusCode(v int32) *UpdateLogstashChargeTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateLogstashChargeTypeResponse) SetBody(v *UpdateLogstashChargeTypeResponseBody) *UpdateLogstashChargeTypeResponse {
	s.Body = v
	return s
}

type UpdateLogstashDescriptionRequest struct {
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateLogstashDescriptionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashDescriptionRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogstashDescriptionRequest) SetDescription(v string) *UpdateLogstashDescriptionRequest {
	s.Description = &v
	return s
}

func (s *UpdateLogstashDescriptionRequest) SetClientToken(v string) *UpdateLogstashDescriptionRequest {
	s.ClientToken = &v
	return s
}

type UpdateLogstashDescriptionResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The result returned.
	Result *UpdateLogstashDescriptionResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateLogstashDescriptionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashDescriptionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateLogstashDescriptionResponseBody) SetRequestId(v string) *UpdateLogstashDescriptionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateLogstashDescriptionResponseBody) SetResult(v *UpdateLogstashDescriptionResponseBodyResult) *UpdateLogstashDescriptionResponseBody {
	s.Result = v
	return s
}

type UpdateLogstashDescriptionResponseBodyResult struct {
	// The name of the cluster.
	//
	// example:
	//
	// logstash_name
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
}

func (s UpdateLogstashDescriptionResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashDescriptionResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateLogstashDescriptionResponseBodyResult) SetDescription(v string) *UpdateLogstashDescriptionResponseBodyResult {
	s.Description = &v
	return s
}

type UpdateLogstashDescriptionResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateLogstashDescriptionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateLogstashDescriptionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashDescriptionResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogstashDescriptionResponse) SetHeaders(v map[string]*string) *UpdateLogstashDescriptionResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogstashDescriptionResponse) SetStatusCode(v int32) *UpdateLogstashDescriptionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateLogstashDescriptionResponse) SetBody(v *UpdateLogstashDescriptionResponseBody) *UpdateLogstashDescriptionResponse {
	s.Body = v
	return s
}

type UpdateLogstashSettingsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateLogstashSettingsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashSettingsRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogstashSettingsRequest) SetBody(v string) *UpdateLogstashSettingsRequest {
	s.Body = &v
	return s
}

func (s *UpdateLogstashSettingsRequest) SetClientToken(v string) *UpdateLogstashSettingsRequest {
	s.ClientToken = &v
	return s
}

type UpdateLogstashSettingsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 71D0D1DA-B22F-58CB-AF5B-D1657A6A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateLogstashSettingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashSettingsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateLogstashSettingsResponseBody) SetRequestId(v string) *UpdateLogstashSettingsResponseBody {
	s.RequestId = &v
	return s
}

type UpdateLogstashSettingsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateLogstashSettingsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateLogstashSettingsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogstashSettingsResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogstashSettingsResponse) SetHeaders(v map[string]*string) *UpdateLogstashSettingsResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogstashSettingsResponse) SetStatusCode(v int32) *UpdateLogstashSettingsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateLogstashSettingsResponse) SetBody(v *UpdateLogstashSettingsResponseBody) *UpdateLogstashSettingsResponse {
	s.Body = v
	return s
}

type UpdatePipelineManagementConfigRequest struct {
	Endpoints    []*string `json:"endpoints,omitempty" xml:"endpoints,omitempty" type:"Repeated"`
	EsInstanceId *string   `json:"esInstanceId,omitempty" xml:"esInstanceId,omitempty"`
	// example:
	//
	// ******
	Password    *string   `json:"password,omitempty" xml:"password,omitempty"`
	PipelineIds []*string `json:"pipelineIds,omitempty" xml:"pipelineIds,omitempty" type:"Repeated"`
	// example:
	//
	// ES
	PipelineManagementType *string `json:"pipelineManagementType,omitempty" xml:"pipelineManagementType,omitempty"`
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdatePipelineManagementConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePipelineManagementConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdatePipelineManagementConfigRequest) SetEndpoints(v []*string) *UpdatePipelineManagementConfigRequest {
	s.Endpoints = v
	return s
}

func (s *UpdatePipelineManagementConfigRequest) SetEsInstanceId(v string) *UpdatePipelineManagementConfigRequest {
	s.EsInstanceId = &v
	return s
}

func (s *UpdatePipelineManagementConfigRequest) SetPassword(v string) *UpdatePipelineManagementConfigRequest {
	s.Password = &v
	return s
}

func (s *UpdatePipelineManagementConfigRequest) SetPipelineIds(v []*string) *UpdatePipelineManagementConfigRequest {
	s.PipelineIds = v
	return s
}

func (s *UpdatePipelineManagementConfigRequest) SetPipelineManagementType(v string) *UpdatePipelineManagementConfigRequest {
	s.PipelineManagementType = &v
	return s
}

func (s *UpdatePipelineManagementConfigRequest) SetUserName(v string) *UpdatePipelineManagementConfigRequest {
	s.UserName = &v
	return s
}

func (s *UpdatePipelineManagementConfigRequest) SetClientToken(v string) *UpdatePipelineManagementConfigRequest {
	s.ClientToken = &v
	return s
}

type UpdatePipelineManagementConfigResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdatePipelineManagementConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePipelineManagementConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePipelineManagementConfigResponseBody) SetRequestId(v string) *UpdatePipelineManagementConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePipelineManagementConfigResponseBody) SetResult(v bool) *UpdatePipelineManagementConfigResponseBody {
	s.Result = &v
	return s
}

type UpdatePipelineManagementConfigResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdatePipelineManagementConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdatePipelineManagementConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePipelineManagementConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdatePipelineManagementConfigResponse) SetHeaders(v map[string]*string) *UpdatePipelineManagementConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdatePipelineManagementConfigResponse) SetStatusCode(v int32) *UpdatePipelineManagementConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePipelineManagementConfigResponse) SetBody(v *UpdatePipelineManagementConfigResponseBody) *UpdatePipelineManagementConfigResponse {
	s.Body = v
	return s
}

type UpdatePipelinesRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// Specifies whether to deploy the pipeline immediately.
	//
	// example:
	//
	// false
	Trigger *bool `json:"trigger,omitempty" xml:"trigger,omitempty"`
}

func (s UpdatePipelinesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePipelinesRequest) GoString() string {
	return s.String()
}

func (s *UpdatePipelinesRequest) SetBody(v string) *UpdatePipelinesRequest {
	s.Body = &v
	return s
}

func (s *UpdatePipelinesRequest) SetClientToken(v string) *UpdatePipelinesRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdatePipelinesRequest) SetTrigger(v bool) *UpdatePipelinesRequest {
	s.Trigger = &v
	return s
}

type UpdatePipelinesResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the pipeline is updated. Valid values:
	//
	// 	- true: The pipeline is updated.
	//
	// 	- false: The pipeline fails to be updated.
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdatePipelinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePipelinesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePipelinesResponseBody) SetRequestId(v string) *UpdatePipelinesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePipelinesResponseBody) SetResult(v bool) *UpdatePipelinesResponseBody {
	s.Result = &v
	return s
}

type UpdatePipelinesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdatePipelinesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdatePipelinesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePipelinesResponse) GoString() string {
	return s.String()
}

func (s *UpdatePipelinesResponse) SetHeaders(v map[string]*string) *UpdatePipelinesResponse {
	s.Headers = v
	return s
}

func (s *UpdatePipelinesResponse) SetStatusCode(v int32) *UpdatePipelinesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePipelinesResponse) SetBody(v *UpdatePipelinesResponseBody) *UpdatePipelinesResponse {
	s.Body = v
	return s
}

type UpdatePrivateNetworkWhiteIpsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The results that are returned.
	//
	// example:
	//
	// Cover
	ModifyMode *string `json:"modifyMode,omitempty" xml:"modifyMode,omitempty"`
}

func (s UpdatePrivateNetworkWhiteIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrivateNetworkWhiteIpsRequest) GoString() string {
	return s.String()
}

func (s *UpdatePrivateNetworkWhiteIpsRequest) SetBody(v string) *UpdatePrivateNetworkWhiteIpsRequest {
	s.Body = &v
	return s
}

func (s *UpdatePrivateNetworkWhiteIpsRequest) SetClientToken(v string) *UpdatePrivateNetworkWhiteIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdatePrivateNetworkWhiteIpsRequest) SetModifyMode(v string) *UpdatePrivateNetworkWhiteIpsRequest {
	s.ModifyMode = &v
	return s
}

type UpdatePrivateNetworkWhiteIpsResponseBody struct {
	// example:
	//
	// 6DEBE5EE-0368-4757-8F82-EF9C3972****
	RequestId *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *UpdatePrivateNetworkWhiteIpsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdatePrivateNetworkWhiteIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrivateNetworkWhiteIpsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePrivateNetworkWhiteIpsResponseBody) SetRequestId(v string) *UpdatePrivateNetworkWhiteIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePrivateNetworkWhiteIpsResponseBody) SetResult(v *UpdatePrivateNetworkWhiteIpsResponseBodyResult) *UpdatePrivateNetworkWhiteIpsResponseBody {
	s.Result = v
	return s
}

type UpdatePrivateNetworkWhiteIpsResponseBodyResult struct {
	PrivateNetworkIpWhiteList []*string `json:"privateNetworkIpWhiteList,omitempty" xml:"privateNetworkIpWhiteList,omitempty" type:"Repeated"`
}

func (s UpdatePrivateNetworkWhiteIpsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrivateNetworkWhiteIpsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdatePrivateNetworkWhiteIpsResponseBodyResult) SetPrivateNetworkIpWhiteList(v []*string) *UpdatePrivateNetworkWhiteIpsResponseBodyResult {
	s.PrivateNetworkIpWhiteList = v
	return s
}

type UpdatePrivateNetworkWhiteIpsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdatePrivateNetworkWhiteIpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdatePrivateNetworkWhiteIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrivateNetworkWhiteIpsResponse) GoString() string {
	return s.String()
}

func (s *UpdatePrivateNetworkWhiteIpsResponse) SetHeaders(v map[string]*string) *UpdatePrivateNetworkWhiteIpsResponse {
	s.Headers = v
	return s
}

func (s *UpdatePrivateNetworkWhiteIpsResponse) SetStatusCode(v int32) *UpdatePrivateNetworkWhiteIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePrivateNetworkWhiteIpsResponse) SetBody(v *UpdatePrivateNetworkWhiteIpsResponseBody) *UpdatePrivateNetworkWhiteIpsResponse {
	s.Body = v
	return s
}

type UpdatePublicNetworkRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdatePublicNetworkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicNetworkRequest) GoString() string {
	return s.String()
}

func (s *UpdatePublicNetworkRequest) SetBody(v string) *UpdatePublicNetworkRequest {
	s.Body = &v
	return s
}

func (s *UpdatePublicNetworkRequest) SetClientToken(v string) *UpdatePublicNetworkRequest {
	s.ClientToken = &v
	return s
}

type UpdatePublicNetworkResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 2A88ECA1-D827-4581-AD39-05149586****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result *UpdatePublicNetworkResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdatePublicNetworkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicNetworkResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePublicNetworkResponseBody) SetRequestId(v string) *UpdatePublicNetworkResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePublicNetworkResponseBody) SetResult(v *UpdatePublicNetworkResponseBodyResult) *UpdatePublicNetworkResponseBody {
	s.Result = v
	return s
}

type UpdatePublicNetworkResponseBodyResult struct {
	// The status of the public network access switch.
	//
	// example:
	//
	// false
	EnablePublic *bool `json:"enablePublic,omitempty" xml:"enablePublic,omitempty"`
}

func (s UpdatePublicNetworkResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicNetworkResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdatePublicNetworkResponseBodyResult) SetEnablePublic(v bool) *UpdatePublicNetworkResponseBodyResult {
	s.EnablePublic = &v
	return s
}

type UpdatePublicNetworkResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdatePublicNetworkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdatePublicNetworkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicNetworkResponse) GoString() string {
	return s.String()
}

func (s *UpdatePublicNetworkResponse) SetHeaders(v map[string]*string) *UpdatePublicNetworkResponse {
	s.Headers = v
	return s
}

func (s *UpdatePublicNetworkResponse) SetStatusCode(v int32) *UpdatePublicNetworkResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePublicNetworkResponse) SetBody(v *UpdatePublicNetworkResponseBody) *UpdatePublicNetworkResponse {
	s.Body = v
	return s
}

type UpdatePublicWhiteIpsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The results that are returned.
	//
	// example:
	//
	// Cover
	ModifyMode *string `json:"modifyMode,omitempty" xml:"modifyMode,omitempty"`
}

func (s UpdatePublicWhiteIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicWhiteIpsRequest) GoString() string {
	return s.String()
}

func (s *UpdatePublicWhiteIpsRequest) SetBody(v string) *UpdatePublicWhiteIpsRequest {
	s.Body = &v
	return s
}

func (s *UpdatePublicWhiteIpsRequest) SetClientToken(v string) *UpdatePublicWhiteIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdatePublicWhiteIpsRequest) SetModifyMode(v string) *UpdatePublicWhiteIpsRequest {
	s.ModifyMode = &v
	return s
}

type UpdatePublicWhiteIpsResponseBody struct {
	// example:
	//
	// C82758DD-282F-4D48-934F-92170A33****
	RequestId *string                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *UpdatePublicWhiteIpsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdatePublicWhiteIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicWhiteIpsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePublicWhiteIpsResponseBody) SetRequestId(v string) *UpdatePublicWhiteIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePublicWhiteIpsResponseBody) SetResult(v *UpdatePublicWhiteIpsResponseBodyResult) *UpdatePublicWhiteIpsResponseBody {
	s.Result = v
	return s
}

type UpdatePublicWhiteIpsResponseBodyResult struct {
	PublicIpWhitelist []*string `json:"publicIpWhitelist,omitempty" xml:"publicIpWhitelist,omitempty" type:"Repeated"`
}

func (s UpdatePublicWhiteIpsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicWhiteIpsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdatePublicWhiteIpsResponseBodyResult) SetPublicIpWhitelist(v []*string) *UpdatePublicWhiteIpsResponseBodyResult {
	s.PublicIpWhitelist = v
	return s
}

type UpdatePublicWhiteIpsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdatePublicWhiteIpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdatePublicWhiteIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePublicWhiteIpsResponse) GoString() string {
	return s.String()
}

func (s *UpdatePublicWhiteIpsResponse) SetHeaders(v map[string]*string) *UpdatePublicWhiteIpsResponse {
	s.Headers = v
	return s
}

func (s *UpdatePublicWhiteIpsResponse) SetStatusCode(v int32) *UpdatePublicWhiteIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePublicWhiteIpsResponse) SetBody(v *UpdatePublicWhiteIpsResponseBody) *UpdatePublicWhiteIpsResponse {
	s.Body = v
	return s
}

type UpdateReadWritePolicyRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateReadWritePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateReadWritePolicyRequest) GoString() string {
	return s.String()
}

func (s *UpdateReadWritePolicyRequest) SetClientToken(v string) *UpdateReadWritePolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateReadWritePolicyRequest) SetBody(v string) *UpdateReadWritePolicyRequest {
	s.Body = &v
	return s
}

type UpdateReadWritePolicyResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateReadWritePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateReadWritePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateReadWritePolicyResponseBody) SetRequestId(v string) *UpdateReadWritePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateReadWritePolicyResponseBody) SetResult(v bool) *UpdateReadWritePolicyResponseBody {
	s.Result = &v
	return s
}

type UpdateReadWritePolicyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateReadWritePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateReadWritePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateReadWritePolicyResponse) GoString() string {
	return s.String()
}

func (s *UpdateReadWritePolicyResponse) SetHeaders(v map[string]*string) *UpdateReadWritePolicyResponse {
	s.Headers = v
	return s
}

func (s *UpdateReadWritePolicyResponse) SetStatusCode(v int32) *UpdateReadWritePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateReadWritePolicyResponse) SetBody(v *UpdateReadWritePolicyResponseBody) *UpdateReadWritePolicyResponse {
	s.Body = v
	return s
}

type UpdateSnapshotSettingRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateSnapshotSettingRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSnapshotSettingRequest) GoString() string {
	return s.String()
}

func (s *UpdateSnapshotSettingRequest) SetBody(v string) *UpdateSnapshotSettingRequest {
	s.Body = &v
	return s
}

type UpdateSnapshotSettingResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return results.
	Result *UpdateSnapshotSettingResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateSnapshotSettingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSnapshotSettingResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSnapshotSettingResponseBody) SetRequestId(v string) *UpdateSnapshotSettingResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSnapshotSettingResponseBody) SetResult(v *UpdateSnapshotSettingResponseBodyResult) *UpdateSnapshotSettingResponseBody {
	s.Result = v
	return s
}

type UpdateSnapshotSettingResponseBodyResult struct {
	// Specifies whether to enable automatic backup.
	//
	// example:
	//
	// true
	Enable *bool `json:"enable,omitempty" xml:"enable,omitempty"`
	// The start time of automatic backup.
	//
	// example:
	//
	// 0 0 01 ? 	- 	- *
	QuartzRegex *string `json:"quartzRegex,omitempty" xml:"quartzRegex,omitempty"`
}

func (s UpdateSnapshotSettingResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateSnapshotSettingResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateSnapshotSettingResponseBodyResult) SetEnable(v bool) *UpdateSnapshotSettingResponseBodyResult {
	s.Enable = &v
	return s
}

func (s *UpdateSnapshotSettingResponseBodyResult) SetQuartzRegex(v string) *UpdateSnapshotSettingResponseBodyResult {
	s.QuartzRegex = &v
	return s
}

type UpdateSnapshotSettingResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateSnapshotSettingResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateSnapshotSettingResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSnapshotSettingResponse) GoString() string {
	return s.String()
}

func (s *UpdateSnapshotSettingResponse) SetHeaders(v map[string]*string) *UpdateSnapshotSettingResponse {
	s.Headers = v
	return s
}

func (s *UpdateSnapshotSettingResponse) SetStatusCode(v int32) *UpdateSnapshotSettingResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSnapshotSettingResponse) SetBody(v *UpdateSnapshotSettingResponseBody) *UpdateSnapshotSettingResponse {
	s.Body = v
	return s
}

type UpdateSynonymsDictsRequest struct {
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s UpdateSynonymsDictsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSynonymsDictsRequest) GoString() string {
	return s.String()
}

func (s *UpdateSynonymsDictsRequest) SetBody(v string) *UpdateSynonymsDictsRequest {
	s.Body = &v
	return s
}

func (s *UpdateSynonymsDictsRequest) SetClientToken(v string) *UpdateSynonymsDictsRequest {
	s.ClientToken = &v
	return s
}

type UpdateSynonymsDictsResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 7C5622CC-B312-426F-85AA-B0271*******
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result []*UpdateSynonymsDictsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UpdateSynonymsDictsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSynonymsDictsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSynonymsDictsResponseBody) SetRequestId(v string) *UpdateSynonymsDictsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSynonymsDictsResponseBody) SetResult(v []*UpdateSynonymsDictsResponseBodyResult) *UpdateSynonymsDictsResponseBody {
	s.Result = v
	return s
}

type UpdateSynonymsDictsResponseBodyResult struct {
	// The size of the dictionary file. Unit: bytes.
	//
	// example:
	//
	// 220
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// The name of the dictionary file.
	//
	// example:
	//
	// deploy_0.txt
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The source type of the dictionary file. Valid values:
	//
	// 	- OSS
	//
	// 	- ORIGIN
	//
	// example:
	//
	// OSS
	SourceType *string `json:"sourceType,omitempty" xml:"sourceType,omitempty"`
	// The dictionary type. The value is fixed as SYNONYMS.
	//
	// example:
	//
	// SYNONYMS
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateSynonymsDictsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateSynonymsDictsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateSynonymsDictsResponseBodyResult) SetFileSize(v int64) *UpdateSynonymsDictsResponseBodyResult {
	s.FileSize = &v
	return s
}

func (s *UpdateSynonymsDictsResponseBodyResult) SetName(v string) *UpdateSynonymsDictsResponseBodyResult {
	s.Name = &v
	return s
}

func (s *UpdateSynonymsDictsResponseBodyResult) SetSourceType(v string) *UpdateSynonymsDictsResponseBodyResult {
	s.SourceType = &v
	return s
}

func (s *UpdateSynonymsDictsResponseBodyResult) SetType(v string) *UpdateSynonymsDictsResponseBodyResult {
	s.Type = &v
	return s
}

type UpdateSynonymsDictsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateSynonymsDictsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateSynonymsDictsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSynonymsDictsResponse) GoString() string {
	return s.String()
}

func (s *UpdateSynonymsDictsResponse) SetHeaders(v map[string]*string) *UpdateSynonymsDictsResponse {
	s.Headers = v
	return s
}

func (s *UpdateSynonymsDictsResponse) SetStatusCode(v int32) *UpdateSynonymsDictsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSynonymsDictsResponse) SetBody(v *UpdateSynonymsDictsResponseBody) *UpdateSynonymsDictsResponse {
	s.Body = v
	return s
}

type UpdateTemplateRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// example:
	//
	// {     "content": "{\\n\\t\\"persistent\\":{\\n\\t\\t\\"search\\":{\\n\\t\\t\\t\\"max_buckets\\":\\"10000\\"\\n\\t\\t}\\n\\t}\\n}" }
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateTemplateRequest) SetClientToken(v string) *UpdateTemplateRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTemplateRequest) SetBody(v string) *UpdateTemplateRequest {
	s.Body = &v
	return s
}

type UpdateTemplateResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTemplateResponseBody) SetRequestId(v string) *UpdateTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTemplateResponseBody) SetResult(v bool) *UpdateTemplateResponseBody {
	s.Result = &v
	return s
}

type UpdateTemplateResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateTemplateResponse) SetHeaders(v map[string]*string) *UpdateTemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateTemplateResponse) SetStatusCode(v int32) *UpdateTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTemplateResponse) SetBody(v *UpdateTemplateResponseBody) *UpdateTemplateResponse {
	s.Body = v
	return s
}

type UpdateWhiteIpsRequest struct {
	// The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.
	EsIPWhitelist []*string `json:"esIPWhitelist,omitempty" xml:"esIPWhitelist,omitempty" type:"Repeated"`
	// The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.
	WhiteIpGroup *UpdateWhiteIpsRequestWhiteIpGroup `json:"whiteIpGroup,omitempty" xml:"whiteIpGroup,omitempty" type:"Struct"`
	// The IP addresses in the whitelist.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.
	//
	// >  You cannot configure both the esIPWhitelist and whiteIpGroup parameters.
	//
	// example:
	//
	// Cover
	ModifyMode *string `json:"modifyMode,omitempty" xml:"modifyMode,omitempty"`
}

func (s UpdateWhiteIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateWhiteIpsRequest) GoString() string {
	return s.String()
}

func (s *UpdateWhiteIpsRequest) SetEsIPWhitelist(v []*string) *UpdateWhiteIpsRequest {
	s.EsIPWhitelist = v
	return s
}

func (s *UpdateWhiteIpsRequest) SetWhiteIpGroup(v *UpdateWhiteIpsRequestWhiteIpGroup) *UpdateWhiteIpsRequest {
	s.WhiteIpGroup = v
	return s
}

func (s *UpdateWhiteIpsRequest) SetClientToken(v string) *UpdateWhiteIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateWhiteIpsRequest) SetModifyMode(v string) *UpdateWhiteIpsRequest {
	s.ModifyMode = &v
	return s
}

type UpdateWhiteIpsRequestWhiteIpGroup struct {
	// The type of the whitelist. Set the value to **PRIVATE_ES**. This value indicates a private IP address whitelist.
	//
	// example:
	//
	// test_group
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	// The returned result.
	Ips []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
	// The returned result.
	//
	// example:
	//
	// PRIVATE_ES
	WhiteIpType *string `json:"whiteIpType,omitempty" xml:"whiteIpType,omitempty"`
}

func (s UpdateWhiteIpsRequestWhiteIpGroup) String() string {
	return tea.Prettify(s)
}

func (s UpdateWhiteIpsRequestWhiteIpGroup) GoString() string {
	return s.String()
}

func (s *UpdateWhiteIpsRequestWhiteIpGroup) SetGroupName(v string) *UpdateWhiteIpsRequestWhiteIpGroup {
	s.GroupName = &v
	return s
}

func (s *UpdateWhiteIpsRequestWhiteIpGroup) SetIps(v []*string) *UpdateWhiteIpsRequestWhiteIpGroup {
	s.Ips = v
	return s
}

func (s *UpdateWhiteIpsRequestWhiteIpGroup) SetWhiteIpType(v string) *UpdateWhiteIpsRequestWhiteIpGroup {
	s.WhiteIpType = &v
	return s
}

type UpdateWhiteIpsResponseBody struct {
	// The updated whitelist.
	//
	// example:
	//
	// 8D58B014-BBD7-4D80-B219-00B9D5C6860C
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The network configurations.
	Result *UpdateWhiteIpsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s UpdateWhiteIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateWhiteIpsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateWhiteIpsResponseBody) SetRequestId(v string) *UpdateWhiteIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateWhiteIpsResponseBody) SetResult(v *UpdateWhiteIpsResponseBodyResult) *UpdateWhiteIpsResponseBody {
	s.Result = v
	return s
}

type UpdateWhiteIpsResponseBodyResult struct {
	// The list of whitelists.
	EsIPWhitelist []*string `json:"esIPWhitelist,omitempty" xml:"esIPWhitelist,omitempty" type:"Repeated"`
	// The name of the whitelist. By default, the default whitelist is included.
	NetworkConfig *UpdateWhiteIpsResponseBodyResultNetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty" type:"Struct"`
}

func (s UpdateWhiteIpsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpdateWhiteIpsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpdateWhiteIpsResponseBodyResult) SetEsIPWhitelist(v []*string) *UpdateWhiteIpsResponseBodyResult {
	s.EsIPWhitelist = v
	return s
}

func (s *UpdateWhiteIpsResponseBodyResult) SetNetworkConfig(v *UpdateWhiteIpsResponseBodyResultNetworkConfig) *UpdateWhiteIpsResponseBodyResult {
	s.NetworkConfig = v
	return s
}

type UpdateWhiteIpsResponseBodyResultNetworkConfig struct {
	// The IP addresses in the whitelist.
	WhiteIpGroupList []*UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList `json:"whiteIpGroupList,omitempty" xml:"whiteIpGroupList,omitempty" type:"Repeated"`
}

func (s UpdateWhiteIpsResponseBodyResultNetworkConfig) String() string {
	return tea.Prettify(s)
}

func (s UpdateWhiteIpsResponseBodyResultNetworkConfig) GoString() string {
	return s.String()
}

func (s *UpdateWhiteIpsResponseBodyResultNetworkConfig) SetWhiteIpGroupList(v []*UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) *UpdateWhiteIpsResponseBodyResultNetworkConfig {
	s.WhiteIpGroupList = v
	return s
}

type UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList struct {
	// The type of the whitelist. The value of this parameter is fixed as PRIVATE_ES, which indicates a private IP address whitelist.
	//
	// example:
	//
	// test_group
	GroupName *string   `json:"groupName,omitempty" xml:"groupName,omitempty"`
	Ips       []*string `json:"ips,omitempty" xml:"ips,omitempty" type:"Repeated"`
	// example:
	//
	// PRIVATE_ES
	WhiteIpType *string `json:"whiteIpType,omitempty" xml:"whiteIpType,omitempty"`
}

func (s UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) String() string {
	return tea.Prettify(s)
}

func (s UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) GoString() string {
	return s.String()
}

func (s *UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) SetGroupName(v string) *UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.GroupName = &v
	return s
}

func (s *UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) SetIps(v []*string) *UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.Ips = v
	return s
}

func (s *UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList) SetWhiteIpType(v string) *UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList {
	s.WhiteIpType = &v
	return s
}

type UpdateWhiteIpsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateWhiteIpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateWhiteIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateWhiteIpsResponse) GoString() string {
	return s.String()
}

func (s *UpdateWhiteIpsResponse) SetHeaders(v map[string]*string) *UpdateWhiteIpsResponse {
	s.Headers = v
	return s
}

func (s *UpdateWhiteIpsResponse) SetStatusCode(v int32) *UpdateWhiteIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateWhiteIpsResponse) SetBody(v *UpdateWhiteIpsResponseBody) *UpdateWhiteIpsResponse {
	s.Body = v
	return s
}

type UpdateXpackMonitorConfigRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// example:
	//
	// true
	Enable    *bool     `json:"enable,omitempty" xml:"enable,omitempty"`
	Endpoints []*string `json:"endpoints,omitempty" xml:"endpoints,omitempty" type:"Repeated"`
	// if can be null:
	// true
	//
	// example:
	//
	// ******
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
	// if can be null:
	// true
	//
	// example:
	//
	// elastic
	UserName *string `json:"userName,omitempty" xml:"userName,omitempty"`
}

func (s UpdateXpackMonitorConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateXpackMonitorConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateXpackMonitorConfigRequest) SetClientToken(v string) *UpdateXpackMonitorConfigRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateXpackMonitorConfigRequest) SetEnable(v bool) *UpdateXpackMonitorConfigRequest {
	s.Enable = &v
	return s
}

func (s *UpdateXpackMonitorConfigRequest) SetEndpoints(v []*string) *UpdateXpackMonitorConfigRequest {
	s.Endpoints = v
	return s
}

func (s *UpdateXpackMonitorConfigRequest) SetPassword(v string) *UpdateXpackMonitorConfigRequest {
	s.Password = &v
	return s
}

func (s *UpdateXpackMonitorConfigRequest) SetUserName(v string) *UpdateXpackMonitorConfigRequest {
	s.UserName = &v
	return s
}

type UpdateXpackMonitorConfigResponseBody struct {
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateXpackMonitorConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateXpackMonitorConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateXpackMonitorConfigResponseBody) SetRequestId(v string) *UpdateXpackMonitorConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateXpackMonitorConfigResponseBody) SetResult(v bool) *UpdateXpackMonitorConfigResponseBody {
	s.Result = &v
	return s
}

type UpdateXpackMonitorConfigResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateXpackMonitorConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateXpackMonitorConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateXpackMonitorConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateXpackMonitorConfigResponse) SetHeaders(v map[string]*string) *UpdateXpackMonitorConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateXpackMonitorConfigResponse) SetStatusCode(v int32) *UpdateXpackMonitorConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateXpackMonitorConfigResponse) SetBody(v *UpdateXpackMonitorConfigResponseBody) *UpdateXpackMonitorConfigResponse {
	s.Body = v
	return s
}

type UpgradeEngineVersionRequest struct {
	Plugins []*UpgradeEngineVersionRequestPlugins `json:"plugins,omitempty" xml:"plugins,omitempty" type:"Repeated"`
	// example:
	//
	// engineVersion
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// example:
	//
	// 6.7
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
	// The moderation results.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
	// The monitoring type. Valid values:
	//
	// 	- checkClusterHealth: Cluster Health Status
	//
	// 	- checkConfigCompatible: Configuration Compatibility Status
	//
	// 	- checkClusterResource: resource space status
	//
	// 	- checkClusterSnapshot: Whether a snapshot exists
	//
	// example:
	//
	// false
	DryRun *bool `json:"dryRun,omitempty" xml:"dryRun,omitempty"`
}

func (s UpgradeEngineVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEngineVersionRequest) GoString() string {
	return s.String()
}

func (s *UpgradeEngineVersionRequest) SetPlugins(v []*UpgradeEngineVersionRequestPlugins) *UpgradeEngineVersionRequest {
	s.Plugins = v
	return s
}

func (s *UpgradeEngineVersionRequest) SetType(v string) *UpgradeEngineVersionRequest {
	s.Type = &v
	return s
}

func (s *UpgradeEngineVersionRequest) SetVersion(v string) *UpgradeEngineVersionRequest {
	s.Version = &v
	return s
}

func (s *UpgradeEngineVersionRequest) SetClientToken(v string) *UpgradeEngineVersionRequest {
	s.ClientToken = &v
	return s
}

func (s *UpgradeEngineVersionRequest) SetDryRun(v bool) *UpgradeEngineVersionRequest {
	s.DryRun = &v
	return s
}

type UpgradeEngineVersionRequestPlugins struct {
	FileVersion *string `json:"fileVersion,omitempty" xml:"fileVersion,omitempty"`
	Name        *string `json:"name,omitempty" xml:"name,omitempty"`
	Version     *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s UpgradeEngineVersionRequestPlugins) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEngineVersionRequestPlugins) GoString() string {
	return s.String()
}

func (s *UpgradeEngineVersionRequestPlugins) SetFileVersion(v string) *UpgradeEngineVersionRequestPlugins {
	s.FileVersion = &v
	return s
}

func (s *UpgradeEngineVersionRequestPlugins) SetName(v string) *UpgradeEngineVersionRequestPlugins {
	s.Name = &v
	return s
}

func (s *UpgradeEngineVersionRequestPlugins) SetVersion(v string) *UpgradeEngineVersionRequestPlugins {
	s.Version = &v
	return s
}

type UpgradeEngineVersionResponseBody struct {
	// The verification information.
	//
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DC*****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The type of the error. Valid values:
	//
	// 	- clusterStatus: the health status of the cluster.
	//
	// 	- clusterConfigYml: Cluster YML File
	//
	// 	- clusterConfigPlugins: Cluster Configuration File
	//
	// 	- clusterResource: cluster resources
	//
	// 	- clusterSnapshot: cluster snapshot
	Result []*UpgradeEngineVersionResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s UpgradeEngineVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEngineVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeEngineVersionResponseBody) SetRequestId(v string) *UpgradeEngineVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeEngineVersionResponseBody) SetResult(v []*UpgradeEngineVersionResponseBodyResult) *UpgradeEngineVersionResponseBody {
	s.Result = v
	return s
}

type UpgradeEngineVersionResponseBodyResult struct {
	// example:
	//
	// success
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// The error message returned.
	ValidateResult []*UpgradeEngineVersionResponseBodyResultValidateResult `json:"validateResult,omitempty" xml:"validateResult,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	//
	// example:
	//
	// checkClusterHealth
	ValidateType *string `json:"validateType,omitempty" xml:"validateType,omitempty"`
}

func (s UpgradeEngineVersionResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEngineVersionResponseBodyResult) GoString() string {
	return s.String()
}

func (s *UpgradeEngineVersionResponseBodyResult) SetStatus(v string) *UpgradeEngineVersionResponseBodyResult {
	s.Status = &v
	return s
}

func (s *UpgradeEngineVersionResponseBodyResult) SetValidateResult(v []*UpgradeEngineVersionResponseBodyResultValidateResult) *UpgradeEngineVersionResponseBodyResult {
	s.ValidateResult = v
	return s
}

func (s *UpgradeEngineVersionResponseBodyResult) SetValidateType(v string) *UpgradeEngineVersionResponseBodyResult {
	s.ValidateType = &v
	return s
}

type UpgradeEngineVersionResponseBodyResultValidateResult struct {
	// example:
	//
	// ClusterStatusNotHealth
	ErrorCode *string `json:"errorCode,omitempty" xml:"errorCode,omitempty"`
	// example:
	//
	// The cluster status is not health
	ErrorMsg *string `json:"errorMsg,omitempty" xml:"errorMsg,omitempty"`
	// The verification is passed. Valid values:
	//
	// 	- success: through
	//
	// 	- failed: failed
	//
	// example:
	//
	// clusterStatus
	ErrorType *string `json:"errorType,omitempty" xml:"errorType,omitempty"`
}

func (s UpgradeEngineVersionResponseBodyResultValidateResult) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEngineVersionResponseBodyResultValidateResult) GoString() string {
	return s.String()
}

func (s *UpgradeEngineVersionResponseBodyResultValidateResult) SetErrorCode(v string) *UpgradeEngineVersionResponseBodyResultValidateResult {
	s.ErrorCode = &v
	return s
}

func (s *UpgradeEngineVersionResponseBodyResultValidateResult) SetErrorMsg(v string) *UpgradeEngineVersionResponseBodyResultValidateResult {
	s.ErrorMsg = &v
	return s
}

func (s *UpgradeEngineVersionResponseBodyResultValidateResult) SetErrorType(v string) *UpgradeEngineVersionResponseBodyResultValidateResult {
	s.ErrorType = &v
	return s
}

type UpgradeEngineVersionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpgradeEngineVersionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpgradeEngineVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEngineVersionResponse) GoString() string {
	return s.String()
}

func (s *UpgradeEngineVersionResponse) SetHeaders(v map[string]*string) *UpgradeEngineVersionResponse {
	s.Headers = v
	return s
}

func (s *UpgradeEngineVersionResponse) SetStatusCode(v int32) *UpgradeEngineVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeEngineVersionResponse) SetBody(v *UpgradeEngineVersionResponseBody) *UpgradeEngineVersionResponse {
	s.Body = v
	return s
}

type ValidateConnectionRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Body        *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ValidateConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s ValidateConnectionRequest) GoString() string {
	return s.String()
}

func (s *ValidateConnectionRequest) SetClientToken(v string) *ValidateConnectionRequest {
	s.ClientToken = &v
	return s
}

func (s *ValidateConnectionRequest) SetBody(v string) *ValidateConnectionRequest {
	s.Body = &v
	return s
}

type ValidateConnectionResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the connectivity is normal. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ValidateConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ValidateConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *ValidateConnectionResponseBody) SetRequestId(v string) *ValidateConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ValidateConnectionResponseBody) SetResult(v bool) *ValidateConnectionResponseBody {
	s.Result = &v
	return s
}

type ValidateConnectionResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ValidateConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ValidateConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s ValidateConnectionResponse) GoString() string {
	return s.String()
}

func (s *ValidateConnectionResponse) SetHeaders(v map[string]*string) *ValidateConnectionResponse {
	s.Headers = v
	return s
}

func (s *ValidateConnectionResponse) SetStatusCode(v int32) *ValidateConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *ValidateConnectionResponse) SetBody(v *ValidateConnectionResponseBody) *ValidateConnectionResponse {
	s.Body = v
	return s
}

type ValidateShrinkNodesRequest struct {
	Body []*ValidateShrinkNodesRequestBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// example:
	//
	// 2
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// false
	IgnoreStatus *bool `json:"ignoreStatus,omitempty" xml:"ignoreStatus,omitempty"`
	// Returned results:
	//
	// 	- true: can be scaled in
	//
	// 	- false: cannot be scaled in.
	//
	// This parameter is required.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
}

func (s ValidateShrinkNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s ValidateShrinkNodesRequest) GoString() string {
	return s.String()
}

func (s *ValidateShrinkNodesRequest) SetBody(v []*ValidateShrinkNodesRequestBody) *ValidateShrinkNodesRequest {
	s.Body = v
	return s
}

func (s *ValidateShrinkNodesRequest) SetCount(v int32) *ValidateShrinkNodesRequest {
	s.Count = &v
	return s
}

func (s *ValidateShrinkNodesRequest) SetIgnoreStatus(v bool) *ValidateShrinkNodesRequest {
	s.IgnoreStatus = &v
	return s
}

func (s *ValidateShrinkNodesRequest) SetNodeType(v string) *ValidateShrinkNodesRequest {
	s.NodeType = &v
	return s
}

type ValidateShrinkNodesRequestBody struct {
	// example:
	//
	// 192.168.xx.xx
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// example:
	//
	// es-cn-pl32xxxxxxx-data-f-1
	HostName *string `json:"hostName,omitempty" xml:"hostName,omitempty"`
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
	// example:
	//
	// cn-shanghai-c
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s ValidateShrinkNodesRequestBody) String() string {
	return tea.Prettify(s)
}

func (s ValidateShrinkNodesRequestBody) GoString() string {
	return s.String()
}

func (s *ValidateShrinkNodesRequestBody) SetHost(v string) *ValidateShrinkNodesRequestBody {
	s.Host = &v
	return s
}

func (s *ValidateShrinkNodesRequestBody) SetHostName(v string) *ValidateShrinkNodesRequestBody {
	s.HostName = &v
	return s
}

func (s *ValidateShrinkNodesRequestBody) SetNodeType(v string) *ValidateShrinkNodesRequestBody {
	s.NodeType = &v
	return s
}

func (s *ValidateShrinkNodesRequestBody) SetPort(v int32) *ValidateShrinkNodesRequestBody {
	s.Port = &v
	return s
}

func (s *ValidateShrinkNodesRequestBody) SetZoneId(v string) *ValidateShrinkNodesRequestBody {
	s.ZoneId = &v
	return s
}

type ValidateShrinkNodesResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ValidateShrinkNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ValidateShrinkNodesResponseBody) GoString() string {
	return s.String()
}

func (s *ValidateShrinkNodesResponseBody) SetRequestId(v string) *ValidateShrinkNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ValidateShrinkNodesResponseBody) SetResult(v bool) *ValidateShrinkNodesResponseBody {
	s.Result = &v
	return s
}

type ValidateShrinkNodesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ValidateShrinkNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ValidateShrinkNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s ValidateShrinkNodesResponse) GoString() string {
	return s.String()
}

func (s *ValidateShrinkNodesResponse) SetHeaders(v map[string]*string) *ValidateShrinkNodesResponse {
	s.Headers = v
	return s
}

func (s *ValidateShrinkNodesResponse) SetStatusCode(v int32) *ValidateShrinkNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *ValidateShrinkNodesResponse) SetBody(v *ValidateShrinkNodesResponseBody) *ValidateShrinkNodesResponse {
	s.Body = v
	return s
}

type ValidateSlrPermissionRequest struct {
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// AliyunServiceRoleForElasticsearchCollector
	Rolename *string `json:"rolename,omitempty" xml:"rolename,omitempty"`
}

func (s ValidateSlrPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s ValidateSlrPermissionRequest) GoString() string {
	return s.String()
}

func (s *ValidateSlrPermissionRequest) SetClientToken(v string) *ValidateSlrPermissionRequest {
	s.ClientToken = &v
	return s
}

func (s *ValidateSlrPermissionRequest) SetRolename(v string) *ValidateSlrPermissionRequest {
	s.Rolename = &v
	return s
}

type ValidateSlrPermissionResponseBody struct {
	// example:
	//
	// BC4ED7DD-8C84-49B5-8A95-456F82E44D13
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ValidateSlrPermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ValidateSlrPermissionResponseBody) GoString() string {
	return s.String()
}

func (s *ValidateSlrPermissionResponseBody) SetRequestId(v string) *ValidateSlrPermissionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ValidateSlrPermissionResponseBody) SetResult(v bool) *ValidateSlrPermissionResponseBody {
	s.Result = &v
	return s
}

type ValidateSlrPermissionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ValidateSlrPermissionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ValidateSlrPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s ValidateSlrPermissionResponse) GoString() string {
	return s.String()
}

func (s *ValidateSlrPermissionResponse) SetHeaders(v map[string]*string) *ValidateSlrPermissionResponse {
	s.Headers = v
	return s
}

func (s *ValidateSlrPermissionResponse) SetStatusCode(v int32) *ValidateSlrPermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *ValidateSlrPermissionResponse) SetBody(v *ValidateSlrPermissionResponseBody) *ValidateSlrPermissionResponse {
	s.Body = v
	return s
}

type ValidateTransferableNodesRequest struct {
	Body []*ValidateTransferableNodesRequestBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// WORKER
	NodeType *string `json:"nodeType,omitempty" xml:"nodeType,omitempty"`
}

func (s ValidateTransferableNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s ValidateTransferableNodesRequest) GoString() string {
	return s.String()
}

func (s *ValidateTransferableNodesRequest) SetBody(v []*ValidateTransferableNodesRequestBody) *ValidateTransferableNodesRequest {
	s.Body = v
	return s
}

func (s *ValidateTransferableNodesRequest) SetNodeType(v string) *ValidateTransferableNodesRequest {
	s.NodeType = &v
	return s
}

type ValidateTransferableNodesRequestBody struct {
	// example:
	//
	// 172.16.xx.xx
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// example:
	//
	// 9200
	Port *int32 `json:"port,omitempty" xml:"port,omitempty"`
	// example:
	//
	// cn-shanghai-c
	ZoneId *string `json:"zoneId,omitempty" xml:"zoneId,omitempty"`
}

func (s ValidateTransferableNodesRequestBody) String() string {
	return tea.Prettify(s)
}

func (s ValidateTransferableNodesRequestBody) GoString() string {
	return s.String()
}

func (s *ValidateTransferableNodesRequestBody) SetHost(v string) *ValidateTransferableNodesRequestBody {
	s.Host = &v
	return s
}

func (s *ValidateTransferableNodesRequestBody) SetPort(v int32) *ValidateTransferableNodesRequestBody {
	s.Port = &v
	return s
}

func (s *ValidateTransferableNodesRequestBody) SetZoneId(v string) *ValidateTransferableNodesRequestBody {
	s.ZoneId = &v
	return s
}

type ValidateTransferableNodesResponseBody struct {
	// example:
	//
	// F99407AB-2FA9-489E-A259-40CF6DCC****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// true
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ValidateTransferableNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ValidateTransferableNodesResponseBody) GoString() string {
	return s.String()
}

func (s *ValidateTransferableNodesResponseBody) SetRequestId(v string) *ValidateTransferableNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ValidateTransferableNodesResponseBody) SetResult(v bool) *ValidateTransferableNodesResponseBody {
	s.Result = &v
	return s
}

type ValidateTransferableNodesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ValidateTransferableNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ValidateTransferableNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s ValidateTransferableNodesResponse) GoString() string {
	return s.String()
}

func (s *ValidateTransferableNodesResponse) SetHeaders(v map[string]*string) *ValidateTransferableNodesResponse {
	s.Headers = v
	return s
}

func (s *ValidateTransferableNodesResponse) SetStatusCode(v int32) *ValidateTransferableNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *ValidateTransferableNodesResponse) SetBody(v *ValidateTransferableNodesResponseBody) *ValidateTransferableNodesResponse {
	s.Body = v
	return s
}

type CreateInstanceRequest struct {
	ClientNodeConfiguration *ClientNodeConfiguration `json:"clientNodeConfiguration,omitempty" xml:"clientNodeConfiguration,omitempty"`
	// example:
	//
	// es
	Description                  *string                       `json:"description,omitempty" xml:"description,omitempty"`
	ElasticDataNodeConfiguration *ElasticDataNodeConfiguration `json:"elasticDataNodeConfiguration,omitempty" xml:"elasticDataNodeConfiguration,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// es_password
	EsAdminPassword *string `json:"esAdminPassword,omitempty" xml:"esAdminPassword,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 5.5.3_with_X-Pack
	EsVersion *string `json:"esVersion,omitempty" xml:"esVersion,omitempty"`
	// example:
	//
	// advanced
	InstanceCategory    *string                  `json:"instanceCategory,omitempty" xml:"instanceCategory,omitempty"`
	KibanaConfiguration *KibanaNodeConfiguration `json:"kibanaConfiguration,omitempty" xml:"kibanaConfiguration,omitempty"`
	MasterConfiguration *MasterNodeConfiguration `json:"masterConfiguration,omitempty" xml:"masterConfiguration,omitempty"`
	// This parameter is required.
	NetworkConfig *NetworkConfig `json:"networkConfig,omitempty" xml:"networkConfig,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 3
	NodeAmount  *int32       `json:"nodeAmount,omitempty" xml:"nodeAmount,omitempty"`
	NodeSpec    *NodeSpec    `json:"nodeSpec,omitempty" xml:"nodeSpec,omitempty"`
	PaymentInfo *PaymentInfo `json:"paymentInfo,omitempty" xml:"paymentInfo,omitempty"`
	// example:
	//
	// postpaid
	PaymentType *string `json:"paymentType,omitempty" xml:"paymentType,omitempty"`
	// example:
	//
	// rg-aekzu7tsu4nem4q
	ResourceGroupId       *string                      `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	Tags                  []*CreateInstanceRequestTags `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	WarmNodeConfiguration *WarmNodeConfiguration       `json:"warmNodeConfiguration,omitempty" xml:"warmNodeConfiguration,omitempty"`
	// example:
	//
	// 2
	ZoneCount *int32 `json:"zoneCount,omitempty" xml:"zoneCount,omitempty"`
	// example:
	//
	// 5A2CFF0E-5718-45B5-9D4D-70B3FF****
	ClientToken *string `json:"clientToken,omitempty" xml:"clientToken,omitempty"`
}

func (s CreateInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateInstanceRequest) SetClientNodeConfiguration(v *ClientNodeConfiguration) *CreateInstanceRequest {
	s.ClientNodeConfiguration = v
	return s
}

func (s *CreateInstanceRequest) SetDescription(v string) *CreateInstanceRequest {
	s.Description = &v
	return s
}

func (s *CreateInstanceRequest) SetElasticDataNodeConfiguration(v *ElasticDataNodeConfiguration) *CreateInstanceRequest {
	s.ElasticDataNodeConfiguration = v
	return s
}

func (s *CreateInstanceRequest) SetEsAdminPassword(v string) *CreateInstanceRequest {
	s.EsAdminPassword = &v
	return s
}

func (s *CreateInstanceRequest) SetEsVersion(v string) *CreateInstanceRequest {
	s.EsVersion = &v
	return s
}

func (s *CreateInstanceRequest) SetInstanceCategory(v string) *CreateInstanceRequest {
	s.InstanceCategory = &v
	return s
}

func (s *CreateInstanceRequest) SetKibanaConfiguration(v *KibanaNodeConfiguration) *CreateInstanceRequest {
	s.KibanaConfiguration = v
	return s
}

func (s *CreateInstanceRequest) SetMasterConfiguration(v *MasterNodeConfiguration) *CreateInstanceRequest {
	s.MasterConfiguration = v
	return s
}

func (s *CreateInstanceRequest) SetNetworkConfig(v *NetworkConfig) *CreateInstanceRequest {
	s.NetworkConfig = v
	return s
}

func (s *CreateInstanceRequest) SetNodeAmount(v int32) *CreateInstanceRequest {
	s.NodeAmount = &v
	return s
}

func (s *CreateInstanceRequest) SetNodeSpec(v *NodeSpec) *CreateInstanceRequest {
	s.NodeSpec = v
	return s
}

func (s *CreateInstanceRequest) SetPaymentInfo(v *PaymentInfo) *CreateInstanceRequest {
	s.PaymentInfo = v
	return s
}

func (s *CreateInstanceRequest) SetPaymentType(v string) *CreateInstanceRequest {
	s.PaymentType = &v
	return s
}

func (s *CreateInstanceRequest) SetResourceGroupId(v string) *CreateInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateInstanceRequest) SetTags(v []*CreateInstanceRequestTags) *CreateInstanceRequest {
	s.Tags = v
	return s
}

func (s *CreateInstanceRequest) SetWarmNodeConfiguration(v *WarmNodeConfiguration) *CreateInstanceRequest {
	s.WarmNodeConfiguration = v
	return s
}

func (s *CreateInstanceRequest) SetZoneCount(v int32) *CreateInstanceRequest {
	s.ZoneCount = &v
	return s
}

func (s *CreateInstanceRequest) SetClientToken(v string) *CreateInstanceRequest {
	s.ClientToken = &v
	return s
}

type CreateInstanceRequestTags struct {
	TagKey   *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s CreateInstanceRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateInstanceRequestTags) GoString() string {
	return s.String()
}

func (s *CreateInstanceRequestTags) SetTagKey(v string) *CreateInstanceRequestTags {
	s.TagKey = &v
	return s
}

func (s *CreateInstanceRequestTags) SetTagValue(v string) *CreateInstanceRequestTags {
	s.TagValue = &v
	return s
}

type CreateInstanceResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateInstanceResponse) SetHeaders(v map[string]*string) *CreateInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateInstanceResponse) SetStatusCode(v int32) *CreateInstanceResponse {
	s.StatusCode = &v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.SignatureAlgorithm = tea.String("v2")
	client.EndpointRule = tea.String("regional")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("elasticsearch"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Restores nodes in disabled zones. This operation is available only for multi-zone Elasticsearch clusters.
//
// @param request - ActivateZonesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ActivateZonesResponse
func (client *Client) ActivateZonesWithOptions(InstanceId *string, request *ActivateZonesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ActivateZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ActivateZones"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/recover-zones"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ActivateZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Restores nodes in disabled zones. This operation is available only for multi-zone Elasticsearch clusters.
//
// @param request - ActivateZonesRequest
//
// @return ActivateZonesResponse
func (client *Client) ActivateZones(InstanceId *string, request *ActivateZonesRequest) (_result *ActivateZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ActivateZonesResponse{}
	_body, _err := client.ActivateZonesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - AddConnectableClusterRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddConnectableClusterResponse
func (client *Client) AddConnectableClusterWithOptions(InstanceId *string, request *AddConnectableClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AddConnectableClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("AddConnectableCluster"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/connected-clusters"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &AddConnectableClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - AddConnectableClusterRequest
//
// @return AddConnectableClusterResponse
func (client *Client) AddConnectableCluster(InstanceId *string, request *AddConnectableClusterRequest) (_result *AddConnectableClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AddConnectableClusterResponse{}
	_body, _err := client.AddConnectableClusterWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call the AddSnapshotRepo to create a reference repository when configuring a cross-cluster OSS repository.
//
// @param request - AddSnapshotRepoRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddSnapshotRepoResponse
func (client *Client) AddSnapshotRepoWithOptions(InstanceId *string, request *AddSnapshotRepoRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AddSnapshotRepoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("AddSnapshotRepo"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/snapshot-repos"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &AddSnapshotRepoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call the AddSnapshotRepo to create a reference repository when configuring a cross-cluster OSS repository.
//
// @param request - AddSnapshotRepoRequest
//
// @return AddSnapshotRepoResponse
func (client *Client) AddSnapshotRepo(InstanceId *string, request *AddSnapshotRepoRequest) (_result *AddSnapshotRepoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AddSnapshotRepoResponse{}
	_body, _err := client.AddSnapshotRepoWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Restores an Elasticsearch cluster that is frozen after it is released.
//
// @param request - CancelDeletionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelDeletionResponse
func (client *Client) CancelDeletionWithOptions(InstanceId *string, request *CancelDeletionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CancelDeletionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelDeletion"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/cancel-deletion"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelDeletionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Restores an Elasticsearch cluster that is frozen after it is released.
//
// @param request - CancelDeletionRequest
//
// @return CancelDeletionResponse
func (client *Client) CancelDeletion(InstanceId *string, request *CancelDeletionRequest) (_result *CancelDeletionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CancelDeletionResponse{}
	_body, _err := client.CancelDeletionWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Restores a Logstash cluster that is frozen after it is released.
//
// @param request - CancelLogstashDeletionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelLogstashDeletionResponse
func (client *Client) CancelLogstashDeletionWithOptions(InstanceId *string, request *CancelLogstashDeletionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CancelLogstashDeletionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelLogstashDeletion"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/cancel-deletion"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelLogstashDeletionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Restores a Logstash cluster that is frozen after it is released.
//
// @param request - CancelLogstashDeletionRequest
//
// @return CancelLogstashDeletionResponse
func (client *Client) CancelLogstashDeletion(InstanceId *string, request *CancelLogstashDeletionRequest) (_result *CancelLogstashDeletionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CancelLogstashDeletionResponse{}
	_body, _err := client.CancelLogstashDeletionWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - CancelTaskRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelTaskResponse
func (client *Client) CancelTaskWithOptions(InstanceId *string, request *CancelTaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CancelTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["taskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelTask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/cancel-task"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - CancelTaskRequest
//
// @return CancelTaskResponse
func (client *Client) CancelTask(InstanceId *string, request *CancelTaskRequest) (_result *CancelTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CancelTaskResponse{}
	_body, _err := client.CancelTaskWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CapacityPlanRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CapacityPlanResponse
func (client *Client) CapacityPlanWithOptions(request *CapacityPlanRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CapacityPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ComplexQueryAvailable)) {
		body["complexQueryAvailable"] = request.ComplexQueryAvailable
	}

	if !tea.BoolValue(util.IsUnset(request.DataInfo)) {
		body["dataInfo"] = request.DataInfo
	}

	if !tea.BoolValue(util.IsUnset(request.Metric)) {
		body["metric"] = request.Metric
	}

	if !tea.BoolValue(util.IsUnset(request.UsageScenario)) {
		body["usageScenario"] = request.UsageScenario
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CapacityPlan"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/assist/actions/capacity-plan"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("Anonymous"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CapacityPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CapacityPlanRequest
//
// @return CapacityPlanResponse
func (client *Client) CapacityPlan(request *CapacityPlanRequest) (_result *CapacityPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CapacityPlanResponse{}
	_body, _err := client.CapacityPlanWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CloseDiagnosisRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CloseDiagnosisResponse
func (client *Client) CloseDiagnosisWithOptions(InstanceId *string, request *CloseDiagnosisRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CloseDiagnosisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloseDiagnosis"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/close-diagnosis"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CloseDiagnosisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CloseDiagnosisRequest
//
// @return CloseDiagnosisResponse
func (client *Client) CloseDiagnosis(InstanceId *string, request *CloseDiagnosisRequest) (_result *CloseDiagnosisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CloseDiagnosisResponse{}
	_body, _err := client.CloseDiagnosisWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - CloseHttpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CloseHttpsResponse
func (client *Client) CloseHttpsWithOptions(InstanceId *string, request *CloseHttpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CloseHttpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloseHttps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/close-https"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CloseHttpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - CloseHttpsRequest
//
// @return CloseHttpsResponse
func (client *Client) CloseHttps(InstanceId *string, request *CloseHttpsRequest) (_result *CloseHttpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CloseHttpsResponse{}
	_body, _err := client.CloseHttpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CloseManagedIndexRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CloseManagedIndexResponse
func (client *Client) CloseManagedIndexWithOptions(InstanceId *string, Index *string, request *CloseManagedIndexRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CloseManagedIndexResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloseManagedIndex"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/indices/" + tea.StringValue(openapiutil.GetEncodeParam(Index)) + "/close-managed"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CloseManagedIndexResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CloseManagedIndexRequest
//
// @return CloseManagedIndexResponse
func (client *Client) CloseManagedIndex(InstanceId *string, Index *string, request *CloseManagedIndexRequest) (_result *CloseManagedIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CloseManagedIndexResponse{}
	_body, _err := client.CloseManagedIndexWithOptions(InstanceId, Index, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateCollectorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateCollectorResponse
func (client *Client) CreateCollectorWithOptions(request *CreateCollectorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateCollectorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CollectorPaths)) {
		body["collectorPaths"] = request.CollectorPaths
	}

	if !tea.BoolValue(util.IsUnset(request.Configs)) {
		body["configs"] = request.Configs
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		body["dryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.ExtendConfigs)) {
		body["extendConfigs"] = request.ExtendConfigs
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ResType)) {
		body["resType"] = request.ResType
	}

	if !tea.BoolValue(util.IsUnset(request.ResVersion)) {
		body["resVersion"] = request.ResVersion
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		body["vpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateCollectorRequest
//
// @return CreateCollectorResponse
func (client *Client) CreateCollector(request *CreateCollectorRequest) (_result *CreateCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateCollectorResponse{}
	_body, _err := client.CreateCollectorWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Elasticsearch
//
// @param request - CreateComponentIndexRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateComponentIndexResponse
func (client *Client) CreateComponentIndexWithOptions(InstanceId *string, name *string, request *CreateComponentIndexRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateComponentIndexResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Meta)) {
		body["_meta"] = request.Meta
	}

	if !tea.BoolValue(util.IsUnset(request.Template)) {
		body["template"] = request.Template
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateComponentIndex"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/component-index/" + tea.StringValue(openapiutil.GetEncodeParam(name))),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateComponentIndexResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Elasticsearch
//
// @param request - CreateComponentIndexRequest
//
// @return CreateComponentIndexResponse
func (client *Client) CreateComponentIndex(InstanceId *string, name *string, request *CreateComponentIndexRequest) (_result *CreateComponentIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateComponentIndexResponse{}
	_body, _err := client.CreateComponentIndexWithOptions(InstanceId, name, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateDataStreamRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDataStreamResponse
func (client *Client) CreateDataStreamWithOptions(InstanceId *string, request *CreateDataStreamRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateDataStreamResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataStream"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/data-streams"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataStreamResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateDataStreamRequest
//
// @return CreateDataStreamResponse
func (client *Client) CreateDataStream(InstanceId *string, request *CreateDataStreamRequest) (_result *CreateDataStreamResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateDataStreamResponse{}
	_body, _err := client.CreateDataStreamWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateILMPolicyRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateILMPolicyResponse
func (client *Client) CreateILMPolicyWithOptions(InstanceId *string, request *CreateILMPolicyRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateILMPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("CreateILMPolicy"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/ilm-policies"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateILMPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateILMPolicyRequest
//
// @return CreateILMPolicyResponse
func (client *Client) CreateILMPolicy(InstanceId *string, request *CreateILMPolicyRequest) (_result *CreateILMPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateILMPolicyResponse{}
	_body, _err := client.CreateILMPolicyWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateIndexTemplateRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIndexTemplateResponse
func (client *Client) CreateIndexTemplateWithOptions(InstanceId *string, request *CreateIndexTemplateRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateIndexTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataStream)) {
		body["dataStream"] = request.DataStream
	}

	if !tea.BoolValue(util.IsUnset(request.IlmPolicy)) {
		body["ilmPolicy"] = request.IlmPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.IndexPatterns)) {
		body["indexPatterns"] = request.IndexPatterns
	}

	if !tea.BoolValue(util.IsUnset(request.IndexTemplate)) {
		body["indexTemplate"] = request.IndexTemplate
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		body["priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.Template)) {
		body["template"] = request.Template
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIndexTemplate"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/index-templates"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIndexTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - CreateIndexTemplateRequest
//
// @return CreateIndexTemplateResponse
func (client *Client) CreateIndexTemplate(InstanceId *string, request *CreateIndexTemplateRequest) (_result *CreateIndexTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateIndexTemplateResponse{}
	_body, _err := client.CreateIndexTemplateWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// logstash
//
// @param request - CreateLogstashRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLogstashResponse
func (client *Client) CreateLogstashWithOptions(request *CreateLogstashRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateLogstashResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkConfig)) {
		body["networkConfig"] = request.NetworkConfig
	}

	if !tea.BoolValue(util.IsUnset(request.NodeAmount)) {
		body["nodeAmount"] = request.NodeAmount
	}

	if !tea.BoolValue(util.IsUnset(request.NodeSpec)) {
		body["nodeSpec"] = request.NodeSpec
	}

	if !tea.BoolValue(util.IsUnset(request.PaymentInfo)) {
		body["paymentInfo"] = request.PaymentInfo
	}

	if !tea.BoolValue(util.IsUnset(request.PaymentType)) {
		body["paymentType"] = request.PaymentType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		body["resourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Version)) {
		body["version"] = request.Version
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLogstash"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLogstashResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// logstash
//
// @param request - CreateLogstashRequest
//
// @return CreateLogstashResponse
func (client *Client) CreateLogstash(request *CreateLogstashRequest) (_result *CreateLogstashResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateLogstashResponse{}
	_body, _err := client.CreateLogstashWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - CreatePipelinesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreatePipelinesResponse
func (client *Client) CreatePipelinesWithOptions(InstanceId *string, request *CreatePipelinesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreatePipelinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Trigger)) {
		query["trigger"] = request.Trigger
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    util.ToArray(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePipelines"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipelines"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePipelinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - CreatePipelinesRequest
//
// @return CreatePipelinesResponse
func (client *Client) CreatePipelines(InstanceId *string, request *CreatePipelinesRequest) (_result *CreatePipelinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreatePipelinesResponse{}
	_body, _err := client.CreatePipelinesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - CreateSnapshotRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateSnapshotResponse
func (client *Client) CreateSnapshotWithOptions(InstanceId *string, request *CreateSnapshotRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateSnapshotResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSnapshot"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/snapshots"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSnapshotResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - CreateSnapshotRequest
//
// @return CreateSnapshotResponse
func (client *Client) CreateSnapshot(InstanceId *string, request *CreateSnapshotRequest) (_result *CreateSnapshotResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateSnapshotResponse{}
	_body, _err := client.CreateSnapshotWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// VPC
//
// Description:
//
// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D\\*\\*\\*
//
// @param request - CreateVpcEndpointRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVpcEndpointResponse
func (client *Client) CreateVpcEndpointWithOptions(InstanceId *string, request *CreateVpcEndpointRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateVpcEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["dryRun"] = request.DryRun
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		body["serviceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		body["zoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVpcEndpoint"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/vpc-endpoints"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVpcEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// VPC
//
// Description:
//
// 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D\\*\\*\\*
//
// @param request - CreateVpcEndpointRequest
//
// @return CreateVpcEndpointResponse
func (client *Client) CreateVpcEndpoint(InstanceId *string, request *CreateVpcEndpointRequest) (_result *CreateVpcEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateVpcEndpointResponse{}
	_body, _err := client.CreateVpcEndpointWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call deactivatezones to offline part of the zone when multiple zones are available. And you need to migrate the nodes in the offline zone to other zones.
//
// @param request - DeactivateZonesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeactivateZonesResponse
func (client *Client) DeactivateZonesWithOptions(InstanceId *string, request *DeactivateZonesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeactivateZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("DeactivateZones"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/down-zones"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactivateZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call deactivatezones to offline part of the zone when multiple zones are available. And you need to migrate the nodes in the offline zone to other zones.
//
// @param request - DeactivateZonesRequest
//
// @return DeactivateZonesResponse
func (client *Client) DeactivateZones(InstanceId *string, request *DeactivateZonesRequest) (_result *DeactivateZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeactivateZonesResponse{}
	_body, _err := client.DeactivateZonesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a shipper.
//
// @param request - DeleteCollectorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteCollectorResponse
func (client *Client) DeleteCollectorWithOptions(ResId *string, request *DeleteCollectorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteCollectorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a shipper.
//
// @param request - DeleteCollectorRequest
//
// @return DeleteCollectorResponse
func (client *Client) DeleteCollector(ResId *string, request *DeleteCollectorRequest) (_result *DeleteCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteCollectorResponse{}
	_body, _err := client.DeleteCollectorWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteComponentIndexResponse
func (client *Client) DeleteComponentIndexWithOptions(InstanceId *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteComponentIndexResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteComponentIndex"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/component-index/" + tea.StringValue(openapiutil.GetEncodeParam(name))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteComponentIndexResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @return DeleteComponentIndexResponse
func (client *Client) DeleteComponentIndex(InstanceId *string, name *string) (_result *DeleteComponentIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteComponentIndexResponse{}
	_body, _err := client.DeleteComponentIndexWithOptions(InstanceId, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - DeleteConnectedClusterRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteConnectedClusterResponse
func (client *Client) DeleteConnectedClusterWithOptions(InstanceId *string, request *DeleteConnectedClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteConnectedClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectedInstanceId)) {
		query["connectedInstanceId"] = request.ConnectedInstanceId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConnectedCluster"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/connected-clusters"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteConnectedClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - DeleteConnectedClusterRequest
//
// @return DeleteConnectedClusterResponse
func (client *Client) DeleteConnectedCluster(InstanceId *string, request *DeleteConnectedClusterRequest) (_result *DeleteConnectedClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteConnectedClusterResponse{}
	_body, _err := client.DeleteConnectedClusterWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - DeleteDataStreamRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDataStreamResponse
func (client *Client) DeleteDataStreamWithOptions(InstanceId *string, DataStream *string, request *DeleteDataStreamRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteDataStreamResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDataStream"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/data-streams/" + tea.StringValue(openapiutil.GetEncodeParam(DataStream))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDataStreamResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - DeleteDataStreamRequest
//
// @return DeleteDataStreamResponse
func (client *Client) DeleteDataStream(InstanceId *string, DataStream *string, request *DeleteDataStreamRequest) (_result *DeleteDataStreamResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteDataStreamResponse{}
	_body, _err := client.DeleteDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - DeleteDataTaskRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDataTaskResponse
func (client *Client) DeleteDataTaskWithOptions(InstanceId *string, request *DeleteDataTaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteDataTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["taskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDataTask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/data-task"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDataTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - DeleteDataTaskRequest
//
// @return DeleteDataTaskResponse
func (client *Client) DeleteDataTask(InstanceId *string, request *DeleteDataTaskRequest) (_result *DeleteDataTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteDataTaskResponse{}
	_body, _err := client.DeleteDataTaskWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDeprecatedTemplateResponse
func (client *Client) DeleteDeprecatedTemplateWithOptions(InstanceId *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteDeprecatedTemplateResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeprecatedTemplate"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/deprecated-templates/" + tea.StringValue(openapiutil.GetEncodeParam(name))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeprecatedTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @return DeleteDeprecatedTemplateResponse
func (client *Client) DeleteDeprecatedTemplate(InstanceId *string, name *string) (_result *DeleteDeprecatedTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteDeprecatedTemplateResponse{}
	_body, _err := client.DeleteDeprecatedTemplateWithOptions(InstanceId, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteILMPolicyResponse
func (client *Client) DeleteILMPolicyWithOptions(InstanceId *string, PolicyName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteILMPolicyResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteILMPolicy"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/ilm-policies/" + tea.StringValue(openapiutil.GetEncodeParam(PolicyName))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteILMPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return DeleteILMPolicyResponse
func (client *Client) DeleteILMPolicy(InstanceId *string, PolicyName *string) (_result *DeleteILMPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteILMPolicyResponse{}
	_body, _err := client.DeleteILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIndexTemplateResponse
func (client *Client) DeleteIndexTemplateWithOptions(InstanceId *string, IndexTemplate *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteIndexTemplateResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIndexTemplate"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/index-templates/" + tea.StringValue(openapiutil.GetEncodeParam(IndexTemplate))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIndexTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @return DeleteIndexTemplateResponse
func (client *Client) DeleteIndexTemplate(InstanceId *string, IndexTemplate *string) (_result *DeleteIndexTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteIndexTemplateResponse{}
	_body, _err := client.DeleteIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - DeleteInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteInstanceResponse
func (client *Client) DeleteInstanceWithOptions(InstanceId *string, request *DeleteInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteType)) {
		query["deleteType"] = request.DeleteType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - DeleteInstanceRequest
//
// @return DeleteInstanceResponse
func (client *Client) DeleteInstance(InstanceId *string, request *DeleteInstanceRequest) (_result *DeleteInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteInstanceResponse{}
	_body, _err := client.DeleteInstanceWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Releases a Logstash cluster.
//
// Description:
//
// Before you call this operation, take note of the following information: After the cluster is released, the physical resources used by the cluster are reclaimed. The data stored in the cluster is deleted and cannot be recovered. The disks attached to the nodes in the cluster and the snapshots created for the cluster are released.
//
// @param request - DeleteLogstashRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteLogstashResponse
func (client *Client) DeleteLogstashWithOptions(InstanceId *string, request *DeleteLogstashRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteLogstashResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteType)) {
		query["deleteType"] = request.DeleteType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLogstash"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLogstashResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Releases a Logstash cluster.
//
// Description:
//
// Before you call this operation, take note of the following information: After the cluster is released, the physical resources used by the cluster are reclaimed. The data stored in the cluster is deleted and cannot be recovered. The disks attached to the nodes in the cluster and the snapshots created for the cluster are released.
//
// @param request - DeleteLogstashRequest
//
// @return DeleteLogstashResponse
func (client *Client) DeleteLogstash(InstanceId *string, request *DeleteLogstashRequest) (_result *DeleteLogstashResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteLogstashResponse{}
	_body, _err := client.DeleteLogstashWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a pipeline that is configured for a Logstash cluster.
//
// @param request - DeletePipelinesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeletePipelinesResponse
func (client *Client) DeletePipelinesWithOptions(InstanceId *string, request *DeletePipelinesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeletePipelinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.PipelineIds)) {
		query["pipelineIds"] = request.PipelineIds
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePipelines"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipelines"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePipelinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a pipeline that is configured for a Logstash cluster.
//
// @param request - DeletePipelinesRequest
//
// @return DeletePipelinesResponse
func (client *Client) DeletePipelines(InstanceId *string, request *DeletePipelinesRequest) (_result *DeletePipelinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeletePipelinesResponse{}
	_body, _err := client.DeletePipelinesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - DeleteSnapshotRepoRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteSnapshotRepoResponse
func (client *Client) DeleteSnapshotRepoWithOptions(InstanceId *string, request *DeleteSnapshotRepoRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteSnapshotRepoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RepoPath)) {
		query["repoPath"] = request.RepoPath
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSnapshotRepo"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/snapshot-repos"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSnapshotRepoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - DeleteSnapshotRepoRequest
//
// @return DeleteSnapshotRepoResponse
func (client *Client) DeleteSnapshotRepo(InstanceId *string, request *DeleteSnapshotRepoRequest) (_result *DeleteSnapshotRepoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteSnapshotRepoResponse{}
	_body, _err := client.DeleteSnapshotRepoWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// vpc
//
// @param request - DeleteVpcEndpointRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVpcEndpointResponse
func (client *Client) DeleteVpcEndpointWithOptions(InstanceId *string, EndpointId *string, request *DeleteVpcEndpointRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteVpcEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVpcEndpoint"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/vpc-endpoints/" + tea.StringValue(openapiutil.GetEncodeParam(EndpointId))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVpcEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// vpc
//
// @param request - DeleteVpcEndpointRequest
//
// @return DeleteVpcEndpointResponse
func (client *Client) DeleteVpcEndpoint(InstanceId *string, EndpointId *string, request *DeleteVpcEndpointRequest) (_result *DeleteVpcEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteVpcEndpointResponse{}
	_body, _err := client.DeleteVpcEndpointWithOptions(InstanceId, EndpointId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information of ES-operator that is installed for a specified Container Service for Kubernetes (ACK) cluster.
//
// Description:
//
// > Before you install a shipper on an ACK cluster, you can call this operation to query the installation status of ES-operator for the ACK cluster.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAckOperatorResponse
func (client *Client) DescribeAckOperatorWithOptions(ClusterId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeAckOperatorResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAckOperator"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/ack-clusters/" + tea.StringValue(openapiutil.GetEncodeParam(ClusterId)) + "/operator"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAckOperatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information of ES-operator that is installed for a specified Container Service for Kubernetes (ACK) cluster.
//
// Description:
//
// > Before you install a shipper on an ACK cluster, you can call this operation to query the installation status of ES-operator for the ACK cluster.
//
// @return DescribeAckOperatorResponse
func (client *Client) DescribeAckOperator(ClusterId *string) (_result *DescribeAckOperatorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeAckOperatorResponse{}
	_body, _err := client.DescribeAckOperatorWithOptions(ClusterId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// DescribeApm
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeApmResponse
func (client *Client) DescribeApmWithOptions(instanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeApmResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeApm"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/apm/" + tea.StringValue(openapiutil.GetEncodeParam(instanceId))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeApmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// DescribeApm
//
// @return DescribeApmResponse
func (client *Client) DescribeApm(instanceId *string) (_result *DescribeApmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeApmResponse{}
	_body, _err := client.DescribeApmWithOptions(instanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a shipper.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeCollectorResponse
func (client *Client) DescribeCollectorWithOptions(ResId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeCollectorResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of a shipper.
//
// @return DescribeCollectorResponse
func (client *Client) DescribeCollector(ResId *string) (_result *DescribeCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeCollectorResponse{}
	_body, _err := client.DescribeCollectorWithOptions(ResId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeComponentIndexResponse
func (client *Client) DescribeComponentIndexWithOptions(InstanceId *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeComponentIndexResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeComponentIndex"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/component-index/" + tea.StringValue(openapiutil.GetEncodeParam(name))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeComponentIndexResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @return DescribeComponentIndexResponse
func (client *Client) DescribeComponentIndex(InstanceId *string, name *string) (_result *DescribeComponentIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeComponentIndexResponse{}
	_body, _err := client.DescribeComponentIndexWithOptions(InstanceId, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - DescribeConnectableClustersRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeConnectableClustersResponse
func (client *Client) DescribeConnectableClustersWithOptions(InstanceId *string, request *DescribeConnectableClustersRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeConnectableClustersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlreadySetItems)) {
		query["alreadySetItems"] = request.AlreadySetItems
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeConnectableClusters"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/connectable-clusters"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeConnectableClustersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - DescribeConnectableClustersRequest
//
// @return DescribeConnectableClustersResponse
func (client *Client) DescribeConnectableClusters(InstanceId *string, request *DescribeConnectableClustersRequest) (_result *DescribeConnectableClustersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeConnectableClustersResponse{}
	_body, _err := client.DescribeConnectableClustersWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// DescribeDeprecatedTemplate
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDeprecatedTemplateResponse
func (client *Client) DescribeDeprecatedTemplateWithOptions(InstanceId *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeDeprecatedTemplateResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDeprecatedTemplate"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/deprecated-templates/" + tea.StringValue(openapiutil.GetEncodeParam(name))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDeprecatedTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// DescribeDeprecatedTemplate
//
// @return DescribeDeprecatedTemplateResponse
func (client *Client) DescribeDeprecatedTemplate(InstanceId *string, name *string) (_result *DescribeDeprecatedTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeDeprecatedTemplateResponse{}
	_body, _err := client.DescribeDeprecatedTemplateWithOptions(InstanceId, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - DescribeDiagnoseReportRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDiagnoseReportResponse
func (client *Client) DescribeDiagnoseReportWithOptions(InstanceId *string, ReportId *string, request *DescribeDiagnoseReportRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeDiagnoseReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDiagnoseReport"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/reports/" + tea.StringValue(openapiutil.GetEncodeParam(ReportId))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDiagnoseReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - DescribeDiagnoseReportRequest
//
// @return DescribeDiagnoseReportResponse
func (client *Client) DescribeDiagnoseReport(InstanceId *string, ReportId *string, request *DescribeDiagnoseReportRequest) (_result *DescribeDiagnoseReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeDiagnoseReportResponse{}
	_body, _err := client.DescribeDiagnoseReportWithOptions(InstanceId, ReportId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - DescribeDiagnosisSettingsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDiagnosisSettingsResponse
func (client *Client) DescribeDiagnosisSettingsWithOptions(InstanceId *string, request *DescribeDiagnosisSettingsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeDiagnosisSettingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDiagnosisSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/settings"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDiagnosisSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - DescribeDiagnosisSettingsRequest
//
// @return DescribeDiagnosisSettingsResponse
func (client *Client) DescribeDiagnosisSettings(InstanceId *string, request *DescribeDiagnosisSettingsRequest) (_result *DescribeDiagnosisSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeDiagnosisSettingsResponse{}
	_body, _err := client.DescribeDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDynamicSettingsResponse
func (client *Client) DescribeDynamicSettingsWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeDynamicSettingsResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDynamicSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/dynamic-settings"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDynamicSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @return DescribeDynamicSettingsResponse
func (client *Client) DescribeDynamicSettings(InstanceId *string) (_result *DescribeDynamicSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeDynamicSettingsResponse{}
	_body, _err := client.DescribeDynamicSettingsWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the health status of an Elasticsearch cluster.
//
// Description:
//
// An Elasticsearch cluster can be in a health state indicated by one of the following colors:
//
// 	- GREEN: Primary shards and replica shards for the primary shards are normally allocated.
//
// 	- YELLOW: Primary shards are normally allocated, but replica shards for the primary shards are not normally allocated.
//
// 	- RED: Primary shards are not normally allocated.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeElasticsearchHealthResponse
func (client *Client) DescribeElasticsearchHealthWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeElasticsearchHealthResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeElasticsearchHealth"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/elasticsearch-health"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeElasticsearchHealthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the health status of an Elasticsearch cluster.
//
// Description:
//
// An Elasticsearch cluster can be in a health state indicated by one of the following colors:
//
// 	- GREEN: Primary shards and replica shards for the primary shards are normally allocated.
//
// 	- YELLOW: Primary shards are normally allocated, but replica shards for the primary shards are not normally allocated.
//
// 	- RED: Primary shards are not normally allocated.
//
// @return DescribeElasticsearchHealthResponse
func (client *Client) DescribeElasticsearchHealth(InstanceId *string) (_result *DescribeElasticsearchHealthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeElasticsearchHealthResponse{}
	_body, _err := client.DescribeElasticsearchHealthWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeILMPolicyResponse
func (client *Client) DescribeILMPolicyWithOptions(InstanceId *string, PolicyName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeILMPolicyResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeILMPolicy"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/ilm-policies/" + tea.StringValue(openapiutil.GetEncodeParam(PolicyName))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeILMPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return DescribeILMPolicyResponse
func (client *Client) DescribeILMPolicy(InstanceId *string, PolicyName *string) (_result *DescribeILMPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeILMPolicyResponse{}
	_body, _err := client.DescribeILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeIndexTemplateResponse
func (client *Client) DescribeIndexTemplateWithOptions(InstanceId *string, IndexTemplate *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeIndexTemplateResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIndexTemplate"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/index-templates/" + tea.StringValue(openapiutil.GetEncodeParam(IndexTemplate))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIndexTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return DescribeIndexTemplateResponse
func (client *Client) DescribeIndexTemplate(InstanceId *string, IndexTemplate *string) (_result *DescribeIndexTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeIndexTemplateResponse{}
	_body, _err := client.DescribeIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// The name of the dictionary file.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeInstanceResponse
func (client *Client) DescribeInstanceWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeInstanceResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// The name of the dictionary file.
//
// @return DescribeInstanceResponse
func (client *Client) DescribeInstance(InstanceId *string) (_result *DescribeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeInstanceResponse{}
	_body, _err := client.DescribeInstanceWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ElasticsearchKibanasettings
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeKibanaSettingsResponse
func (client *Client) DescribeKibanaSettingsWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeKibanaSettingsResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeKibanaSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/kibana-settings"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeKibanaSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ElasticsearchKibanasettings
//
// @return DescribeKibanaSettingsResponse
func (client *Client) DescribeKibanaSettings(InstanceId *string) (_result *DescribeKibanaSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeKibanaSettingsResponse{}
	_body, _err := client.DescribeKibanaSettingsWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeLogstashResponse
func (client *Client) DescribeLogstashWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeLogstashResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLogstash"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLogstashResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @return DescribeLogstashResponse
func (client *Client) DescribeLogstash(InstanceId *string) (_result *DescribeLogstashResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeLogstashResponse{}
	_body, _err := client.DescribeLogstashWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePipelineResponse
func (client *Client) DescribePipelineWithOptions(InstanceId *string, PipelineId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribePipelineResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePipeline"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipelines/" + tea.StringValue(openapiutil.GetEncodeParam(PipelineId))),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePipelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return DescribePipelineResponse
func (client *Client) DescribePipeline(InstanceId *string, PipelineId *string) (_result *DescribePipelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribePipelineResponse{}
	_body, _err := client.DescribePipelineWithOptions(InstanceId, PipelineId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the management configurations of pipelines in a Logstash cluster.
//
// @param request - DescribePipelineManagementConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePipelineManagementConfigResponse
func (client *Client) DescribePipelineManagementConfigWithOptions(InstanceId *string, request *DescribePipelineManagementConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribePipelineManagementConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePipelineManagementConfig"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipeline-management-config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePipelineManagementConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the management configurations of pipelines in a Logstash cluster.
//
// @param request - DescribePipelineManagementConfigRequest
//
// @return DescribePipelineManagementConfigResponse
func (client *Client) DescribePipelineManagementConfig(InstanceId *string, request *DescribePipelineManagementConfigRequest) (_result *DescribePipelineManagementConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribePipelineManagementConfigResponse{}
	_body, _err := client.DescribePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRegionsResponse
func (client *Client) DescribeRegionsWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/regions"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return DescribeRegionsResponse
func (client *Client) DescribeRegions() (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSnapshotSettingResponse
func (client *Client) DescribeSnapshotSettingWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeSnapshotSettingResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSnapshotSetting"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/snapshot-setting"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSnapshotSettingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return DescribeSnapshotSettingResponse
func (client *Client) DescribeSnapshotSetting(InstanceId *string) (_result *DescribeSnapshotSettingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeSnapshotSettingResponse{}
	_body, _err := client.DescribeSnapshotSettingWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeTemplatesResponse
func (client *Client) DescribeTemplatesWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeTemplatesResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTemplates"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/templates"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return DescribeTemplatesResponse
func (client *Client) DescribeTemplates(InstanceId *string) (_result *DescribeTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeTemplatesResponse{}
	_body, _err := client.DescribeTemplatesWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configurations of the X-Pack Monitoring feature of a Logstash cluster.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeXpackMonitorConfigResponse
func (client *Client) DescribeXpackMonitorConfigWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeXpackMonitorConfigResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeXpackMonitorConfig"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/xpack-monitor-config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeXpackMonitorConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the configurations of the X-Pack Monitoring feature of a Logstash cluster.
//
// @return DescribeXpackMonitorConfigResponse
func (client *Client) DescribeXpackMonitorConfig(InstanceId *string) (_result *DescribeXpackMonitorConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeXpackMonitorConfigResponse{}
	_body, _err := client.DescribeXpackMonitorConfigWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - DiagnoseInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DiagnoseInstanceResponse
func (client *Client) DiagnoseInstanceWithOptions(InstanceId *string, request *DiagnoseInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DiagnoseInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DiagnoseItems)) {
		body["diagnoseItems"] = request.DiagnoseItems
	}

	if !tea.BoolValue(util.IsUnset(request.Indices)) {
		body["indices"] = request.Indices
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		body["type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DiagnoseInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/diagnose"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DiagnoseInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - DiagnoseInstanceRequest
//
// @return DiagnoseInstanceResponse
func (client *Client) DiagnoseInstance(InstanceId *string, request *DiagnoseInstanceRequest) (_result *DiagnoseInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DiagnoseInstanceResponse{}
	_body, _err := client.DiagnoseInstanceWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// kibana
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableKibanaPvlNetworkResponse
func (client *Client) DisableKibanaPvlNetworkWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DisableKibanaPvlNetworkResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DisableKibanaPvlNetwork"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/disable-kibana-private"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableKibanaPvlNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// kibana
//
// @return DisableKibanaPvlNetworkResponse
func (client *Client) DisableKibanaPvlNetwork(InstanceId *string) (_result *DisableKibanaPvlNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DisableKibanaPvlNetworkResponse{}
	_body, _err := client.DisableKibanaPvlNetworkWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// v3 kibana
//
// @param request - EnableKibanaPvlNetworkRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableKibanaPvlNetworkResponse
func (client *Client) EnableKibanaPvlNetworkWithOptions(InstanceId *string, request *EnableKibanaPvlNetworkRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *EnableKibanaPvlNetworkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointName)) {
		body["endpointName"] = request.EndpointName
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroups)) {
		body["securityGroups"] = request.SecurityGroups
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIdsZone)) {
		body["vSwitchIdsZone"] = request.VSwitchIdsZone
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		body["vpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableKibanaPvlNetwork"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/enable-kibana-private"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableKibanaPvlNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// v3 kibana
//
// @param request - EnableKibanaPvlNetworkRequest
//
// @return EnableKibanaPvlNetworkResponse
func (client *Client) EnableKibanaPvlNetwork(InstanceId *string, request *EnableKibanaPvlNetworkRequest) (_result *EnableKibanaPvlNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &EnableKibanaPvlNetworkResponse{}
	_body, _err := client.EnableKibanaPvlNetworkWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the estimated time that is required to restart a Logstash cluster.
//
// @param request - EstimatedLogstashRestartTimeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EstimatedLogstashRestartTimeResponse
func (client *Client) EstimatedLogstashRestartTimeWithOptions(InstanceId *string, request *EstimatedLogstashRestartTimeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *EstimatedLogstashRestartTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["force"] = request.Force
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("EstimatedLogstashRestartTime"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/estimated-time/restart-time"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &EstimatedLogstashRestartTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the estimated time that is required to restart a Logstash cluster.
//
// @param request - EstimatedLogstashRestartTimeRequest
//
// @return EstimatedLogstashRestartTimeResponse
func (client *Client) EstimatedLogstashRestartTime(InstanceId *string, request *EstimatedLogstashRestartTimeRequest) (_result *EstimatedLogstashRestartTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &EstimatedLogstashRestartTimeResponse{}
	_body, _err := client.EstimatedLogstashRestartTimeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the estimated time that is required to restart an Elasticsearch cluster.
//
// @param request - EstimatedRestartTimeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EstimatedRestartTimeResponse
func (client *Client) EstimatedRestartTimeWithOptions(InstanceId *string, request *EstimatedRestartTimeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *EstimatedRestartTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["force"] = request.Force
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("EstimatedRestartTime"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/estimated-time/restart-time"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &EstimatedRestartTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the estimated time that is required to restart an Elasticsearch cluster.
//
// @param request - EstimatedRestartTimeRequest
//
// @return EstimatedRestartTimeResponse
func (client *Client) EstimatedRestartTime(InstanceId *string, request *EstimatedRestartTimeRequest) (_result *EstimatedRestartTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &EstimatedRestartTimeResponse{}
	_body, _err := client.EstimatedRestartTimeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call GetClusterDataInformation to obtain the data information about the cluster.
//
// @param request - GetClusterDataInformationRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetClusterDataInformationResponse
func (client *Client) GetClusterDataInformationWithOptions(request *GetClusterDataInformationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetClusterDataInformationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("GetClusterDataInformation"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/cluster/data-information"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetClusterDataInformationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call GetClusterDataInformation to obtain the data information about the cluster.
//
// @param request - GetClusterDataInformationRequest
//
// @return GetClusterDataInformationResponse
func (client *Client) GetClusterDataInformation(request *GetClusterDataInformationRequest) (_result *GetClusterDataInformationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetClusterDataInformationResponse{}
	_body, _err := client.GetClusterDataInformationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetElastictaskResponse
func (client *Client) GetElastictaskWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetElastictaskResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetElastictask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/elastic-task"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetElastictaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return GetElastictaskResponse
func (client *Client) GetElastictask(InstanceId *string) (_result *GetElastictaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetElastictaskResponse{}
	_body, _err := client.GetElastictaskWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Grafana
//
// @param request - GetEmonGrafanaAlertsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetEmonGrafanaAlertsResponse
func (client *Client) GetEmonGrafanaAlertsWithOptions(ProjectId *string, request *GetEmonGrafanaAlertsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetEmonGrafanaAlertsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("GetEmonGrafanaAlerts"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/emon/projects/" + tea.StringValue(openapiutil.GetEncodeParam(ProjectId)) + "/grafana/proxy/api/alerts"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEmonGrafanaAlertsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Grafana
//
// @param request - GetEmonGrafanaAlertsRequest
//
// @return GetEmonGrafanaAlertsResponse
func (client *Client) GetEmonGrafanaAlerts(ProjectId *string, request *GetEmonGrafanaAlertsRequest) (_result *GetEmonGrafanaAlertsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetEmonGrafanaAlertsResponse{}
	_body, _err := client.GetEmonGrafanaAlertsWithOptions(ProjectId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Grafana
//
// @param request - GetEmonGrafanaDashboardsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetEmonGrafanaDashboardsResponse
func (client *Client) GetEmonGrafanaDashboardsWithOptions(ProjectId *string, request *GetEmonGrafanaDashboardsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetEmonGrafanaDashboardsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("GetEmonGrafanaDashboards"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/emon/projects/" + tea.StringValue(openapiutil.GetEncodeParam(ProjectId)) + "/grafana/proxy/api/search"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEmonGrafanaDashboardsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Grafana
//
// @param request - GetEmonGrafanaDashboardsRequest
//
// @return GetEmonGrafanaDashboardsResponse
func (client *Client) GetEmonGrafanaDashboards(ProjectId *string, request *GetEmonGrafanaDashboardsRequest) (_result *GetEmonGrafanaDashboardsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetEmonGrafanaDashboardsResponse{}
	_body, _err := client.GetEmonGrafanaDashboardsWithOptions(ProjectId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - GetEmonMonitorDataRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetEmonMonitorDataResponse
func (client *Client) GetEmonMonitorDataWithOptions(ProjectId *string, request *GetEmonMonitorDataRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetEmonMonitorDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("GetEmonMonitorData"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/emon/projects/" + tea.StringValue(openapiutil.GetEncodeParam(ProjectId)) + "/metrics/query"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEmonMonitorDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - GetEmonMonitorDataRequest
//
// @return GetEmonMonitorDataResponse
func (client *Client) GetEmonMonitorData(ProjectId *string, request *GetEmonMonitorDataRequest) (_result *GetEmonMonitorDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetEmonMonitorDataResponse{}
	_body, _err := client.GetEmonMonitorDataWithOptions(ProjectId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// OpenStore
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetOpenStoreUsageResponse
func (client *Client) GetOpenStoreUsageWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetOpenStoreUsageResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetOpenStoreUsage"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/openstore/usage"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOpenStoreUsageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// OpenStore
//
// @return GetOpenStoreUsageResponse
func (client *Client) GetOpenStoreUsage(InstanceId *string) (_result *GetOpenStoreUsageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetOpenStoreUsageResponse{}
	_body, _err := client.GetOpenStoreUsageWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// The maximum number of nodes.
//
// @param request - GetRegionConfigurationRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetRegionConfigurationResponse
func (client *Client) GetRegionConfigurationWithOptions(request *GetRegionConfigurationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetRegionConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["zoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRegionConfiguration"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/region"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRegionConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// The maximum number of nodes.
//
// @param request - GetRegionConfigurationRequest
//
// @return GetRegionConfigurationResponse
func (client *Client) GetRegionConfiguration(request *GetRegionConfigurationRequest) (_result *GetRegionConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetRegionConfigurationResponse{}
	_body, _err := client.GetRegionConfigurationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetRegionalInstanceConfigResponse
func (client *Client) GetRegionalInstanceConfigWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetRegionalInstanceConfigResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetRegionalInstanceConfig"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/regions/instance-config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRegionalInstanceConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @return GetRegionalInstanceConfigResponse
func (client *Client) GetRegionalInstanceConfig() (_result *GetRegionalInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetRegionalInstanceConfigResponse{}
	_body, _err := client.GetRegionalInstanceConfigWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - GetSuggestShrinkableNodesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetSuggestShrinkableNodesResponse
func (client *Client) GetSuggestShrinkableNodesWithOptions(InstanceId *string, request *GetSuggestShrinkableNodesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetSuggestShrinkableNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreStatus)) {
		query["ignoreStatus"] = request.IgnoreStatus
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["nodeType"] = request.NodeType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSuggestShrinkableNodes"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/suggest-shrinkable-nodes"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSuggestShrinkableNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - GetSuggestShrinkableNodesRequest
//
// @return GetSuggestShrinkableNodesResponse
func (client *Client) GetSuggestShrinkableNodes(InstanceId *string, request *GetSuggestShrinkableNodesRequest) (_result *GetSuggestShrinkableNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetSuggestShrinkableNodesResponse{}
	_body, _err := client.GetSuggestShrinkableNodesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - GetTransferableNodesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetTransferableNodesResponse
func (client *Client) GetTransferableNodesWithOptions(InstanceId *string, request *GetTransferableNodesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetTransferableNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["nodeType"] = request.NodeType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTransferableNodes"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/transferable-nodes"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTransferableNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - GetTransferableNodesRequest
//
// @return GetTransferableNodesResponse
func (client *Client) GetTransferableNodes(InstanceId *string, request *GetTransferableNodesRequest) (_result *GetTransferableNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetTransferableNodesResponse{}
	_body, _err := client.GetTransferableNodesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a service-linked role.
//
// Description:
//
// > Before you perform auto scaling for a cluster at the China site (aliyun.com) or you use shippers to collect logs, you must create a service-linked role.
//
// @param request - InitializeOperationRoleRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InitializeOperationRoleResponse
func (client *Client) InitializeOperationRoleWithOptions(request *InitializeOperationRoleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InitializeOperationRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("InitializeOperationRole"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/user/slr"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InitializeOperationRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a service-linked role.
//
// Description:
//
// > Before you perform auto scaling for a cluster at the China site (aliyun.com) or you use shippers to collect logs, you must create a service-linked role.
//
// @param request - InitializeOperationRoleRequest
//
// @return InitializeOperationRoleResponse
func (client *Client) InitializeOperationRole(request *InitializeOperationRoleRequest) (_result *InitializeOperationRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InitializeOperationRoleResponse{}
	_body, _err := client.InitializeOperationRoleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Installs ES-operator for a Container Service for Kubernetes (ACK) cluster.
//
// Description:
//
// > Before you install a shipper for an ACK cluster, you must call this operation to install ES-operator for the cluster.
//
// @param request - InstallAckOperatorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InstallAckOperatorResponse
func (client *Client) InstallAckOperatorWithOptions(ClusterId *string, request *InstallAckOperatorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InstallAckOperatorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("InstallAckOperator"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/ack-clusters/" + tea.StringValue(openapiutil.GetEncodeParam(ClusterId)) + "/operator"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallAckOperatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Installs ES-operator for a Container Service for Kubernetes (ACK) cluster.
//
// Description:
//
// > Before you install a shipper for an ACK cluster, you must call this operation to install ES-operator for the cluster.
//
// @param request - InstallAckOperatorRequest
//
// @return InstallAckOperatorResponse
func (client *Client) InstallAckOperator(ClusterId *string, request *InstallAckOperatorRequest) (_result *InstallAckOperatorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InstallAckOperatorResponse{}
	_body, _err := client.InstallAckOperatorWithOptions(ClusterId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call InstallKibanaSystemPlugin to install the Kibana plug-in. The Kibana specification must be 2-Core 4 GB or higher.
//
// @param request - InstallKibanaSystemPluginRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InstallKibanaSystemPluginResponse
func (client *Client) InstallKibanaSystemPluginWithOptions(InstanceId *string, request *InstallKibanaSystemPluginRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InstallKibanaSystemPluginResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("InstallKibanaSystemPlugin"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/kibana-plugins/system/actions/install"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallKibanaSystemPluginResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call InstallKibanaSystemPlugin to install the Kibana plug-in. The Kibana specification must be 2-Core 4 GB or higher.
//
// @param request - InstallKibanaSystemPluginRequest
//
// @return InstallKibanaSystemPluginResponse
func (client *Client) InstallKibanaSystemPlugin(InstanceId *string, request *InstallKibanaSystemPluginRequest) (_result *InstallKibanaSystemPluginResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InstallKibanaSystemPluginResponse{}
	_body, _err := client.InstallKibanaSystemPluginWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// The returned data also contains **Headers*	- parameters, indicating that header information is returned.
//
// Description:
//
// ls-cn-oew1qbgl\\*\\*\\*\\*
//
// @param request - InstallLogstashSystemPluginRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InstallLogstashSystemPluginResponse
func (client *Client) InstallLogstashSystemPluginWithOptions(InstanceId *string, request *InstallLogstashSystemPluginRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InstallLogstashSystemPluginResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("InstallLogstashSystemPlugin"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/plugins/system/actions/install"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallLogstashSystemPluginResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// The returned data also contains **Headers*	- parameters, indicating that header information is returned.
//
// Description:
//
// ls-cn-oew1qbgl\\*\\*\\*\\*
//
// @param request - InstallLogstashSystemPluginRequest
//
// @return InstallLogstashSystemPluginResponse
func (client *Client) InstallLogstashSystemPlugin(InstanceId *string, request *InstallLogstashSystemPluginRequest) (_result *InstallLogstashSystemPluginResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InstallLogstashSystemPluginResponse{}
	_body, _err := client.InstallLogstashSystemPluginWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call InstallSystemPlugin to install a system preset plug-in.
//
// @param request - InstallSystemPluginRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InstallSystemPluginResponse
func (client *Client) InstallSystemPluginWithOptions(InstanceId *string, request *InstallSystemPluginRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InstallSystemPluginResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("InstallSystemPlugin"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/plugins/system/actions/install"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallSystemPluginResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call InstallSystemPlugin to install a system preset plug-in.
//
// @param request - InstallSystemPluginRequest
//
// @return InstallSystemPluginResponse
func (client *Client) InstallSystemPlugin(InstanceId *string, request *InstallSystemPluginRequest) (_result *InstallSystemPluginResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InstallSystemPluginResponse{}
	_body, _err := client.InstallSystemPluginWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Installs custom plug-ins that are uploaded to the Elasticsearch console.
//
// @param request - InstallUserPluginsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InstallUserPluginsResponse
func (client *Client) InstallUserPluginsWithOptions(InstanceId *string, request *InstallUserPluginsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InstallUserPluginsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("InstallUserPlugins"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/plugins/user/actions/install"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallUserPluginsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Installs custom plug-ins that are uploaded to the Elasticsearch console.
//
// @param request - InstallUserPluginsRequest
//
// @return InstallUserPluginsResponse
func (client *Client) InstallUserPlugins(InstanceId *string, request *InstallUserPluginsRequest) (_result *InstallUserPluginsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InstallUserPluginsResponse{}
	_body, _err := client.InstallUserPluginsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - InterruptElasticsearchTaskRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InterruptElasticsearchTaskResponse
func (client *Client) InterruptElasticsearchTaskWithOptions(InstanceId *string, request *InterruptElasticsearchTaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InterruptElasticsearchTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InterruptElasticsearchTask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/interrupt"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InterruptElasticsearchTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - InterruptElasticsearchTaskRequest
//
// @return InterruptElasticsearchTaskResponse
func (client *Client) InterruptElasticsearchTask(InstanceId *string, request *InterruptElasticsearchTaskRequest) (_result *InterruptElasticsearchTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InterruptElasticsearchTaskResponse{}
	_body, _err := client.InterruptElasticsearchTaskWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// After the task is suspended, the Logstash cluster is in the suspended state.
//
// @param request - InterruptLogstashTaskRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return InterruptLogstashTaskResponse
func (client *Client) InterruptLogstashTaskWithOptions(InstanceId *string, request *InterruptLogstashTaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InterruptLogstashTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InterruptLogstashTask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/interrupt"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InterruptLogstashTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// After the task is suspended, the Logstash cluster is in the suspended state.
//
// @param request - InterruptLogstashTaskRequest
//
// @return InterruptLogstashTaskResponse
func (client *Client) InterruptLogstashTask(InstanceId *string, request *InterruptLogstashTaskRequest) (_result *InterruptLogstashTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InterruptLogstashTaskResponse{}
	_body, _err := client.InterruptLogstashTaskWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of Container Service for Kubernetes (ACK) clusters.
//
// @param request - ListAckClustersRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAckClustersResponse
func (client *Client) ListAckClustersWithOptions(request *ListAckClustersRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAckClustersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["vpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAckClusters"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/ack-clusters"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAckClustersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of Container Service for Kubernetes (ACK) clusters.
//
// @param request - ListAckClustersRequest
//
// @return ListAckClustersResponse
func (client *Client) ListAckClusters(request *ListAckClustersRequest) (_result *ListAckClustersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAckClustersResponse{}
	_body, _err := client.ListAckClustersWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries all namespaces in a specified Container Service for Kubernetes (ACK) cluster.
//
// Description:
//
// > When you install a shipper on an ACK cluster, you must specify a namespace. You can call this operation to query all namespaces in the ACK cluster, and select a namespace based on your business requirements.
//
// @param request - ListAckNamespacesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAckNamespacesResponse
func (client *Client) ListAckNamespacesWithOptions(ClusterId *string, request *ListAckNamespacesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAckNamespacesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAckNamespaces"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/ack-clusters/" + tea.StringValue(openapiutil.GetEncodeParam(ClusterId)) + "/namespaces"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAckNamespacesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries all namespaces in a specified Container Service for Kubernetes (ACK) cluster.
//
// Description:
//
// > When you install a shipper on an ACK cluster, you must specify a namespace. You can call this operation to query all namespaces in the ACK cluster, and select a namespace based on your business requirements.
//
// @param request - ListAckNamespacesRequest
//
// @return ListAckNamespacesResponse
func (client *Client) ListAckNamespaces(ClusterId *string, request *ListAckNamespacesRequest) (_result *ListAckNamespacesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAckNamespacesResponse{}
	_body, _err := client.ListAckNamespacesWithOptions(ClusterId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
//  
//
// @param request - ListActionRecordsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListActionRecordsResponse
func (client *Client) ListActionRecordsWithOptions(InstanceId *string, request *ListActionRecordsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListActionRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionNames)) {
		query["actionNames"] = request.ActionNames
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["endTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.RequestId)) {
		query["requestId"] = request.RequestId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["startTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["userId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListActionRecords"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/action-records"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListActionRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
//  
//
// @param request - ListActionRecordsRequest
//
// @return ListActionRecordsResponse
func (client *Client) ListActionRecords(InstanceId *string, request *ListActionRecordsRequest) (_result *ListActionRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListActionRecordsResponse{}
	_body, _err := client.ListActionRecordsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// es-cn-tl32cpgwa002l\\*\\*\\*\\*
//
// @param request - ListAllNodeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAllNodeResponse
func (client *Client) ListAllNodeWithOptions(InstanceId *string, request *ListAllNodeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAllNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Extended)) {
		query["extended"] = request.Extended
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAllNode"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/nodes"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAllNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// es-cn-tl32cpgwa002l\\*\\*\\*\\*
//
// @param request - ListAllNodeRequest
//
// @return ListAllNodeResponse
func (client *Client) ListAllNode(InstanceId *string, request *ListAllNodeRequest) (_result *ListAllNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAllNodeResponse{}
	_body, _err := client.ListAllNodeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// OSS
//
// @param request - ListAlternativeSnapshotReposRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAlternativeSnapshotReposResponse
func (client *Client) ListAlternativeSnapshotReposWithOptions(InstanceId *string, request *ListAlternativeSnapshotReposRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAlternativeSnapshotReposResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlreadySetItems)) {
		query["alreadySetItems"] = request.AlreadySetItems
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAlternativeSnapshotRepos"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/alternative-snapshot-repos"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAlternativeSnapshotReposResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// OSS
//
// @param request - ListAlternativeSnapshotReposRequest
//
// @return ListAlternativeSnapshotReposResponse
func (client *Client) ListAlternativeSnapshotRepos(InstanceId *string, request *ListAlternativeSnapshotReposRequest) (_result *ListAlternativeSnapshotReposResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAlternativeSnapshotReposResponse{}
	_body, _err := client.ListAlternativeSnapshotReposWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ListApm
//
// @param request - ListApmRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListApmResponse
func (client *Client) ListApmWithOptions(request *ListApmRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListApmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["instanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Output)) {
		query["output"] = request.Output
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListApm"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/apm"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListApmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ListApm
//
// @param request - ListApmRequest
//
// @return ListApmResponse
func (client *Client) ListApm(request *ListApmRequest) (_result *ListApmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListApmResponse{}
	_body, _err := client.ListApmWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the Elasticsearch clusters that can be associated with a Logstash cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAvailableEsInstanceIdsResponse
func (client *Client) ListAvailableEsInstanceIdsWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAvailableEsInstanceIdsResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListAvailableEsInstanceIds"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/available-elasticsearch-for-centralized-management"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAvailableEsInstanceIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the Elasticsearch clusters that can be associated with a Logstash cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
//
// @return ListAvailableEsInstanceIdsResponse
func (client *Client) ListAvailableEsInstanceIds(InstanceId *string) (_result *ListAvailableEsInstanceIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAvailableEsInstanceIdsResponse{}
	_body, _err := client.ListAvailableEsInstanceIdsWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries shippers.
//
// @param request - ListCollectorsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListCollectorsResponse
func (client *Client) ListCollectorsWithOptions(request *ListCollectorsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListCollectorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["instanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.ResId)) {
		query["resId"] = request.ResId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["sourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCollectors"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCollectorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries shippers.
//
// @param request - ListCollectorsRequest
//
// @return ListCollectorsResponse
func (client *Client) ListCollectors(request *ListCollectorsRequest) (_result *ListCollectorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListCollectorsResponse{}
	_body, _err := client.ListCollectorsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - ListComponentIndicesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListComponentIndicesResponse
func (client *Client) ListComponentIndicesWithOptions(InstanceId *string, request *ListComponentIndicesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListComponentIndicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListComponentIndices"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/component-index"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListComponentIndicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - ListComponentIndicesRequest
//
// @return ListComponentIndicesResponse
func (client *Client) ListComponentIndices(InstanceId *string, request *ListComponentIndicesRequest) (_result *ListComponentIndicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListComponentIndicesResponse{}
	_body, _err := client.ListComponentIndicesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListConnectedClustersResponse
func (client *Client) ListConnectedClustersWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListConnectedClustersResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListConnectedClusters"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/connected-clusters"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConnectedClustersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @return ListConnectedClustersResponse
func (client *Client) ListConnectedClusters(InstanceId *string) (_result *ListConnectedClustersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListConnectedClustersResponse{}
	_body, _err := client.ListConnectedClustersWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ListDataStreamsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDataStreamsResponse
func (client *Client) ListDataStreamsWithOptions(InstanceId *string, request *ListDataStreamsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDataStreamsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IsManaged)) {
		query["isManaged"] = request.IsManaged
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataStreams"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/data-streams"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataStreamsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ListDataStreamsRequest
//
// @return ListDataStreamsResponse
func (client *Client) ListDataStreams(InstanceId *string, request *ListDataStreamsRequest) (_result *ListDataStreamsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDataStreamsResponse{}
	_body, _err := client.ListDataStreamsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDataTasksResponse
func (client *Client) ListDataTasksWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDataTasksResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataTasks"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/data-task"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @return ListDataTasksResponse
func (client *Client) ListDataTasks(InstanceId *string) (_result *ListDataTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDataTasksResponse{}
	_body, _err := client.ListDataTasksWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the default configuration files of shippers.
//
// @param request - ListDefaultCollectorConfigurationsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDefaultCollectorConfigurationsResponse
func (client *Client) ListDefaultCollectorConfigurationsWithOptions(request *ListDefaultCollectorConfigurationsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDefaultCollectorConfigurationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResType)) {
		query["resType"] = request.ResType
	}

	if !tea.BoolValue(util.IsUnset(request.ResVersion)) {
		query["resVersion"] = request.ResVersion
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["sourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDefaultCollectorConfigurations"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/beats/default-configurations"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDefaultCollectorConfigurationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the default configuration files of shippers.
//
// @param request - ListDefaultCollectorConfigurationsRequest
//
// @return ListDefaultCollectorConfigurationsResponse
func (client *Client) ListDefaultCollectorConfigurations(request *ListDefaultCollectorConfigurationsRequest) (_result *ListDefaultCollectorConfigurationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDefaultCollectorConfigurationsResponse{}
	_body, _err := client.ListDefaultCollectorConfigurationsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ListDeprecatedTemplates
//
// @param request - ListDeprecatedTemplatesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDeprecatedTemplatesResponse
func (client *Client) ListDeprecatedTemplatesWithOptions(InstanceId *string, request *ListDeprecatedTemplatesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDeprecatedTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDeprecatedTemplates"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/deprecated-templates"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDeprecatedTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ListDeprecatedTemplates
//
// @param request - ListDeprecatedTemplatesRequest
//
// @return ListDeprecatedTemplatesResponse
func (client *Client) ListDeprecatedTemplates(InstanceId *string, request *ListDeprecatedTemplatesRequest) (_result *ListDeprecatedTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDeprecatedTemplatesResponse{}
	_body, _err := client.ListDeprecatedTemplatesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the indexes for health diagnosis performed on an Elasticsearch cluster.
//
// @param request - ListDiagnoseIndicesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDiagnoseIndicesResponse
func (client *Client) ListDiagnoseIndicesWithOptions(InstanceId *string, request *ListDiagnoseIndicesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDiagnoseIndicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDiagnoseIndices"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/indices"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDiagnoseIndicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the indexes for health diagnosis performed on an Elasticsearch cluster.
//
// @param request - ListDiagnoseIndicesRequest
//
// @return ListDiagnoseIndicesResponse
func (client *Client) ListDiagnoseIndices(InstanceId *string, request *ListDiagnoseIndicesRequest) (_result *ListDiagnoseIndicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDiagnoseIndicesResponse{}
	_body, _err := client.ListDiagnoseIndicesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListDiagnoseReportRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDiagnoseReportResponse
func (client *Client) ListDiagnoseReportWithOptions(InstanceId *string, request *ListDiagnoseReportRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDiagnoseReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Detail)) {
		query["detail"] = request.Detail
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["endTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["startTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Trigger)) {
		query["trigger"] = request.Trigger
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDiagnoseReport"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/reports"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDiagnoseReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListDiagnoseReportRequest
//
// @return ListDiagnoseReportResponse
func (client *Client) ListDiagnoseReport(InstanceId *string, request *ListDiagnoseReportRequest) (_result *ListDiagnoseReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDiagnoseReportResponse{}
	_body, _err := client.ListDiagnoseReportWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the IDs of the historical intelligent O&M reports of an Elasticsearch cluster.
//
// @param request - ListDiagnoseReportIdsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDiagnoseReportIdsResponse
func (client *Client) ListDiagnoseReportIdsWithOptions(InstanceId *string, request *ListDiagnoseReportIdsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDiagnoseReportIdsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["endTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["startTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Trigger)) {
		query["trigger"] = request.Trigger
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDiagnoseReportIds"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/report-ids"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDiagnoseReportIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the IDs of the historical intelligent O&M reports of an Elasticsearch cluster.
//
// @param request - ListDiagnoseReportIdsRequest
//
// @return ListDiagnoseReportIdsResponse
func (client *Client) ListDiagnoseReportIds(InstanceId *string, request *ListDiagnoseReportIdsRequest) (_result *ListDiagnoseReportIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDiagnoseReportIdsResponse{}
	_body, _err := client.ListDiagnoseReportIdsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// The diagnostic item is used to check whether data write requests of a cluster are accumulated. If data write requests are accumulated, a bulk rejection occurs. This may cause data loss and severely consume system resources.
//
// @param request - ListDiagnosisItemsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDiagnosisItemsResponse
func (client *Client) ListDiagnosisItemsWithOptions(request *ListDiagnosisItemsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDiagnosisItemsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDiagnosisItems"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/items"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDiagnosisItemsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// The diagnostic item is used to check whether data write requests of a cluster are accumulated. If data write requests are accumulated, a bulk rejection occurs. This may cause data loss and severely consume system resources.
//
// @param request - ListDiagnosisItemsRequest
//
// @return ListDiagnosisItemsResponse
func (client *Client) ListDiagnosisItems(request *ListDiagnosisItemsRequest) (_result *ListDiagnosisItemsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDiagnosisItemsResponse{}
	_body, _err := client.ListDiagnosisItemsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ListDictInformationRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDictInformationResponse
func (client *Client) ListDictInformationWithOptions(InstanceId *string, request *ListDictInformationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDictInformationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AnalyzerType)) {
		query["analyzerType"] = request.AnalyzerType
	}

	if !tea.BoolValue(util.IsUnset(request.BucketName)) {
		query["bucketName"] = request.BucketName
	}

	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["key"] = request.Key
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDictInformation"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/dict/_info"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDictInformationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ListDictInformationRequest
//
// @return ListDictInformationResponse
func (client *Client) ListDictInformation(InstanceId *string, request *ListDictInformationRequest) (_result *ListDictInformationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDictInformationResponse{}
	_body, _err := client.ListDictInformationWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a specified type of dictionary.
//
// @param request - ListDictsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDictsResponse
func (client *Client) ListDictsWithOptions(InstanceId *string, request *ListDictsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDictsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AnalyzerType)) {
		query["analyzerType"] = request.AnalyzerType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDicts"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/dicts"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDictsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of a specified type of dictionary.
//
// @param request - ListDictsRequest
//
// @return ListDictsResponse
func (client *Client) ListDicts(InstanceId *string, request *ListDictsRequest) (_result *ListDictsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDictsResponse{}
	_body, _err := client.ListDictsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Description:
//
// *Important*	- To call this operation, you must create the Aliyun Elasticsearch AccessingOOSRole and the system service role AliyunOOSAccessingECS 4ESRole to Elasticsearch the service account to obtain the ECS access permissions of the primary account. For more information, see [Collect ECS service logs](https://help.aliyun.com/document_detail/146446.html).
//
// @param request - ListEcsInstancesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListEcsInstancesResponse
func (client *Client) ListEcsInstancesWithOptions(request *ListEcsInstancesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListEcsInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EcsInstanceIds)) {
		query["ecsInstanceIds"] = request.EcsInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.EcsInstanceName)) {
		query["ecsInstanceName"] = request.EcsInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["vpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEcsInstances"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/ecs"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEcsInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Description:
//
// *Important*	- To call this operation, you must create the Aliyun Elasticsearch AccessingOOSRole and the system service role AliyunOOSAccessingECS 4ESRole to Elasticsearch the service account to obtain the ECS access permissions of the primary account. For more information, see [Collect ECS service logs](https://help.aliyun.com/document_detail/146446.html).
//
// @param request - ListEcsInstancesRequest
//
// @return ListEcsInstancesResponse
func (client *Client) ListEcsInstances(request *ListEcsInstancesRequest) (_result *ListEcsInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListEcsInstancesResponse{}
	_body, _err := client.ListEcsInstancesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the driver files of a Logstash cluster.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListExtendfilesResponse
func (client *Client) ListExtendfilesWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListExtendfilesResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListExtendfiles"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/extendfiles"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListExtendfilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the driver files of a Logstash cluster.
//
// @return ListExtendfilesResponse
func (client *Client) ListExtendfiles(InstanceId *string) (_result *ListExtendfilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListExtendfilesResponse{}
	_body, _err := client.ListExtendfilesWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ListILMPoliciesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListILMPoliciesResponse
func (client *Client) ListILMPoliciesWithOptions(InstanceId *string, request *ListILMPoliciesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListILMPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		query["policyName"] = request.PolicyName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListILMPolicies"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/ilm-policies"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListILMPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ListILMPoliciesRequest
//
// @return ListILMPoliciesResponse
func (client *Client) ListILMPolicies(InstanceId *string, request *ListILMPoliciesRequest) (_result *ListILMPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListILMPoliciesResponse{}
	_body, _err := client.ListILMPoliciesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ListIndexTemplatesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListIndexTemplatesResponse
func (client *Client) ListIndexTemplatesWithOptions(InstanceId *string, request *ListIndexTemplatesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListIndexTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IndexTemplate)) {
		query["indexTemplate"] = request.IndexTemplate
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIndexTemplates"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/index-templates"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIndexTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ListIndexTemplatesRequest
//
// @return ListIndexTemplatesResponse
func (client *Client) ListIndexTemplates(InstanceId *string, request *ListIndexTemplatesRequest) (_result *ListIndexTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListIndexTemplatesResponse{}
	_body, _err := client.ListIndexTemplatesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Elasticsearch
//
// @param request - ListInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListInstanceResponse
func (client *Client) ListInstanceWithOptions(request *ListInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EsVersion)) {
		query["esVersion"] = request.EsVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceCategory)) {
		query["instanceCategory"] = request.InstanceCategory
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["instanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.PaymentType)) {
		query["paymentType"] = request.PaymentType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["resourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["vpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["zoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Elasticsearch
//
// @param request - ListInstanceRequest
//
// @return ListInstanceResponse
func (client *Client) ListInstance(request *ListInstanceRequest) (_result *ListInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListInstanceResponse{}
	_body, _err := client.ListInstanceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param tmpReq - ListInstanceHistoryEventsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListInstanceHistoryEventsResponse
func (client *Client) ListInstanceHistoryEventsWithOptions(tmpReq *ListInstanceHistoryEventsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListInstanceHistoryEventsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListInstanceHistoryEventsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.EventCycleStatus)) {
		request.EventCycleStatusShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.EventCycleStatus, tea.String("eventCycleStatus"), tea.String("simple"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.EventLevel)) {
		request.EventLevelShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.EventLevel, tea.String("eventLevel"), tea.String("simple"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.EventType)) {
		request.EventTypeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.EventType, tea.String("eventType"), tea.String("simple"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventCreateEndTime)) {
		query["eventCreateEndTime"] = request.EventCreateEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventCreateStartTime)) {
		query["eventCreateStartTime"] = request.EventCreateStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventCycleStatusShrink)) {
		query["eventCycleStatus"] = request.EventCycleStatusShrink
	}

	if !tea.BoolValue(util.IsUnset(request.EventExecuteEndTime)) {
		query["eventExecuteEndTime"] = request.EventExecuteEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventExecuteStartTime)) {
		query["eventExecuteStartTime"] = request.EventExecuteStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventFinashEndTime)) {
		query["eventFinashEndTime"] = request.EventFinashEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventFinashStartTime)) {
		query["eventFinashStartTime"] = request.EventFinashStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventLevelShrink)) {
		query["eventLevel"] = request.EventLevelShrink
	}

	if !tea.BoolValue(util.IsUnset(request.EventTypeShrink)) {
		query["eventType"] = request.EventTypeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["instanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeIP)) {
		query["nodeIP"] = request.NodeIP
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    util.ToArray(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceHistoryEvents"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/events"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceHistoryEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListInstanceHistoryEventsRequest
//
// @return ListInstanceHistoryEventsResponse
func (client *Client) ListInstanceHistoryEvents(request *ListInstanceHistoryEventsRequest) (_result *ListInstanceHistoryEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListInstanceHistoryEventsResponse{}
	_body, _err := client.ListInstanceHistoryEventsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListInstanceIndicesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListInstanceIndicesResponse
func (client *Client) ListInstanceIndicesWithOptions(InstanceId *string, request *ListInstanceIndicesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListInstanceIndicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["all"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.IsManaged)) {
		query["isManaged"] = request.IsManaged
	}

	if !tea.BoolValue(util.IsUnset(request.IsOpenstore)) {
		query["isOpenstore"] = request.IsOpenstore
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceIndices"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/indices"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceIndicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListInstanceIndicesRequest
//
// @return ListInstanceIndicesResponse
func (client *Client) ListInstanceIndices(InstanceId *string, request *ListInstanceIndicesRequest) (_result *ListInstanceIndicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListInstanceIndicesResponse{}
	_body, _err := client.ListInstanceIndicesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of Kibana plug-ins.
//
// @param request - ListKibanaPluginsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListKibanaPluginsResponse
func (client *Client) ListKibanaPluginsWithOptions(InstanceId *string, request *ListKibanaPluginsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListKibanaPluginsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListKibanaPlugins"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/kibana-plugins"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListKibanaPluginsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of Kibana plug-ins.
//
// @param request - ListKibanaPluginsRequest
//
// @return ListKibanaPluginsResponse
func (client *Client) ListKibanaPlugins(InstanceId *string, request *ListKibanaPluginsRequest) (_result *ListKibanaPluginsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListKibanaPluginsResponse{}
	_body, _err := client.ListKibanaPluginsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// kibana
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListKibanaPvlNetworkResponse
func (client *Client) ListKibanaPvlNetworkWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListKibanaPvlNetworkResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListKibanaPvlNetwork"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/get-kibana-private"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListKibanaPvlNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// kibana
//
// @return ListKibanaPvlNetworkResponse
func (client *Client) ListKibanaPvlNetwork(InstanceId *string) (_result *ListKibanaPvlNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListKibanaPvlNetworkResponse{}
	_body, _err := client.ListKibanaPvlNetworkWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - ListLogstashRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListLogstashResponse
func (client *Client) ListLogstashWithOptions(request *ListLogstashRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListLogstashResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["instanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["resourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Version)) {
		query["version"] = request.Version
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogstash"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogstashResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - ListLogstashRequest
//
// @return ListLogstashResponse
func (client *Client) ListLogstash(request *ListLogstashRequest) (_result *ListLogstashResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListLogstashResponse{}
	_body, _err := client.ListLogstashWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - ListLogstashLogRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListLogstashLogResponse
func (client *Client) ListLogstashLogWithOptions(InstanceId *string, request *ListLogstashLogRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListLogstashLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginTime)) {
		query["beginTime"] = request.BeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["endTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		query["query"] = request.Query
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogstashLog"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/search-log"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogstashLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - ListLogstashLogRequest
//
// @return ListLogstashLogResponse
func (client *Client) ListLogstashLog(InstanceId *string, request *ListLogstashLogRequest) (_result *ListLogstashLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListLogstashLogResponse{}
	_body, _err := client.ListLogstashLogWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - ListLogstashPluginsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListLogstashPluginsResponse
func (client *Client) ListLogstashPluginsWithOptions(InstanceId *string, request *ListLogstashPluginsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListLogstashPluginsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogstashPlugins"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/plugins"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogstashPluginsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - ListLogstashPluginsRequest
//
// @return ListLogstashPluginsResponse
func (client *Client) ListLogstashPlugins(InstanceId *string, request *ListLogstashPluginsRequest) (_result *ListLogstashPluginsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListLogstashPluginsResponse{}
	_body, _err := client.ListLogstashPluginsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the statuses of Elastic Compute Service (ECS) instances on which a shipper is installed.
//
// @param request - ListNodesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListNodesResponse
func (client *Client) ListNodesWithOptions(ResId *string, request *ListNodesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EcsInstanceIds)) {
		query["ecsInstanceIds"] = request.EcsInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.EcsInstanceName)) {
		query["ecsInstanceName"] = request.EcsInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNodes"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId)) + "/nodes"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the statuses of Elastic Compute Service (ECS) instances on which a shipper is installed.
//
// @param request - ListNodesRequest
//
// @return ListNodesResponse
func (client *Client) ListNodes(ResId *string, request *ListNodesRequest) (_result *ListNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListNodesResponse{}
	_body, _err := client.ListNodesWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ListPipelineRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListPipelineResponse
func (client *Client) ListPipelineWithOptions(InstanceId *string, request *ListPipelineRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListPipelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.PipelineId)) {
		query["pipelineId"] = request.PipelineId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPipeline"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipelines"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPipelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ListPipelineRequest
//
// @return ListPipelineResponse
func (client *Client) ListPipeline(InstanceId *string, request *ListPipelineRequest) (_result *ListPipelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListPipelineResponse{}
	_body, _err := client.ListPipelineWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// The error message returned.
//
// @param request - ListPipelineIdsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListPipelineIdsResponse
func (client *Client) ListPipelineIdsWithOptions(InstanceId *string, request *ListPipelineIdsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListPipelineIdsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ListPipelineIds"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipeline-ids"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPipelineIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// The error message returned.
//
// @param request - ListPipelineIdsRequest
//
// @return ListPipelineIdsResponse
func (client *Client) ListPipelineIds(InstanceId *string, request *ListPipelineIdsRequest) (_result *ListPipelineIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListPipelineIdsResponse{}
	_body, _err := client.ListPipelineIdsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - ListPluginsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListPluginsResponse
func (client *Client) ListPluginsWithOptions(InstanceId *string, request *ListPluginsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListPluginsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPlugins"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/plugins"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPluginsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - ListPluginsRequest
//
// @return ListPluginsResponse
func (client *Client) ListPlugins(InstanceId *string, request *ListPluginsRequest) (_result *ListPluginsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListPluginsResponse{}
	_body, _err := client.ListPluginsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Elasticsearch
//
// @param request - ListSearchLogRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListSearchLogResponse
func (client *Client) ListSearchLogWithOptions(InstanceId *string, request *ListSearchLogRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListSearchLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginTime)) {
		query["beginTime"] = request.BeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["endTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		query["query"] = request.Query
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSearchLog"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/search-log"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSearchLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Elasticsearch
//
// @param request - ListSearchLogRequest
//
// @return ListSearchLogResponse
func (client *Client) ListSearchLog(InstanceId *string, request *ListSearchLogRequest) (_result *ListSearchLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListSearchLogResponse{}
	_body, _err := client.ListSearchLogWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about shards that are being restored or shards that are restored. By default, this operation returns only the information about shards that are being restored after you call this operation.
//
// Description:
//
// > The restoration of a shard is a process of synchronizing data from a primary shard to a replica shard. After the restoration is complete, the replica shard is available for data searches.
//
// @param request - ListShardRecoveriesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListShardRecoveriesResponse
func (client *Client) ListShardRecoveriesWithOptions(InstanceId *string, request *ListShardRecoveriesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListShardRecoveriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActiveOnly)) {
		query["activeOnly"] = request.ActiveOnly
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListShardRecoveries"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/cat-recovery"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListShardRecoveriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about shards that are being restored or shards that are restored. By default, this operation returns only the information about shards that are being restored after you call this operation.
//
// Description:
//
// > The restoration of a shard is a process of synchronizing data from a primary shard to a replica shard. After the restoration is complete, the replica shard is available for data searches.
//
// @param request - ListShardRecoveriesRequest
//
// @return ListShardRecoveriesResponse
func (client *Client) ListShardRecoveries(InstanceId *string, request *ListShardRecoveriesRequest) (_result *ListShardRecoveriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListShardRecoveriesResponse{}
	_body, _err := client.ListShardRecoveriesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListSnapshotReposByInstanceIdResponse
func (client *Client) ListSnapshotReposByInstanceIdWithOptions(InstanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListSnapshotReposByInstanceIdResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListSnapshotReposByInstanceId"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/snapshot-repos"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSnapshotReposByInstanceIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @return ListSnapshotReposByInstanceIdResponse
func (client *Client) ListSnapshotReposByInstanceId(InstanceId *string) (_result *ListSnapshotReposByInstanceIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListSnapshotReposByInstanceIdResponse{}
	_body, _err := client.ListSnapshotReposByInstanceIdWithOptions(InstanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListTagResourcesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/tags"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListTagResourcesRequest
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListTagsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTagsResponse
func (client *Client) ListTagsWithOptions(request *ListTagsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["pageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["resourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTags"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/tags/all-tags"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ListTagsRequest
//
// @return ListTagsResponse
func (client *Client) ListTags(request *ListTagsRequest) (_result *ListTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListTagsResponse{}
	_body, _err := client.ListTagsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the statuses of endpoints in the virtual private cloud (VPC) within the Elasticsearch service account.
//
// @param request - ListVpcEndpointsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVpcEndpointsResponse
func (client *Client) ListVpcEndpointsWithOptions(InstanceId *string, request *ListVpcEndpointsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListVpcEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListVpcEndpoints"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/vpc-endpoints"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListVpcEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the statuses of endpoints in the virtual private cloud (VPC) within the Elasticsearch service account.
//
// @param request - ListVpcEndpointsRequest
//
// @return ListVpcEndpointsResponse
func (client *Client) ListVpcEndpoints(InstanceId *string, request *ListVpcEndpointsRequest) (_result *ListVpcEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListVpcEndpointsResponse{}
	_body, _err := client.ListVpcEndpointsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call the MigrateToOtherZone to migrate the nodes in the specified zone to the destination zone.
//
// Description:
//
// If the specifications in your zone are insufficient, you can upgrade your instance to nodes in another zone. Before calling this interface, you must ensure that:
//
// 	- The error message returned because the current account is in a zone that has sufficient resources.
//
//     After migrating nodes with current specifications to another zone, you need to manually [upgrade cluster](https://help.aliyun.com/document_detail/96650.html) because the cluster will not be upgraded during the migration process. Therefore, select a zone with sufficient resources to avoid cluster upgrade failure. We recommend that you choose new zones that are in lower alphabetical order. For example, for cn-hangzhou-e and cn-hangzhou-h zones, choose cn-hangzhou-h first.
//
// 	- The cluster is in the healthy state.
//
//     Can be passed`  GET _cat/health?v  `command to view the health status of the cluster.
//
// @param request - MigrateToOtherZoneRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return MigrateToOtherZoneResponse
func (client *Client) MigrateToOtherZoneWithOptions(InstanceId *string, request *MigrateToOtherZoneRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *MigrateToOtherZoneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["dryRun"] = request.DryRun
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateToOtherZone"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/migrate-zones"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateToOtherZoneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call the MigrateToOtherZone to migrate the nodes in the specified zone to the destination zone.
//
// Description:
//
// If the specifications in your zone are insufficient, you can upgrade your instance to nodes in another zone. Before calling this interface, you must ensure that:
//
// 	- The error message returned because the current account is in a zone that has sufficient resources.
//
//     After migrating nodes with current specifications to another zone, you need to manually [upgrade cluster](https://help.aliyun.com/document_detail/96650.html) because the cluster will not be upgraded during the migration process. Therefore, select a zone with sufficient resources to avoid cluster upgrade failure. We recommend that you choose new zones that are in lower alphabetical order. For example, for cn-hangzhou-e and cn-hangzhou-h zones, choose cn-hangzhou-h first.
//
// 	- The cluster is in the healthy state.
//
//     Can be passed`  GET _cat/health?v  `command to view the health status of the cluster.
//
// @param request - MigrateToOtherZoneRequest
//
// @return MigrateToOtherZoneResponse
func (client *Client) MigrateToOtherZone(InstanceId *string, request *MigrateToOtherZoneRequest) (_result *MigrateToOtherZoneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &MigrateToOtherZoneResponse{}
	_body, _err := client.MigrateToOtherZoneWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the Elastic Compute Service (ECS) instances on which a shipper is installed.
//
// @param request - ModifyDeployMachineRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyDeployMachineResponse
func (client *Client) ModifyDeployMachineWithOptions(ResId *string, request *ModifyDeployMachineRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ModifyDeployMachineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDeployMachine"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId)) + "/actions/modify-deploy-machines"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDeployMachineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Changes the Elastic Compute Service (ECS) instances on which a shipper is installed.
//
// @param request - ModifyDeployMachineRequest
//
// @return ModifyDeployMachineResponse
func (client *Client) ModifyDeployMachine(ResId *string, request *ModifyDeployMachineRequest) (_result *ModifyDeployMachineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ModifyDeployMachineResponse{}
	_body, _err := client.ModifyDeployMachineWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ModifyElastictaskRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyElastictaskResponse
func (client *Client) ModifyElastictaskWithOptions(InstanceId *string, request *ModifyElastictaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ModifyElastictaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyElastictask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/elastic-task"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyElastictaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ModifyElastictaskRequest
//
// @return ModifyElastictaskResponse
func (client *Client) ModifyElastictask(InstanceId *string, request *ModifyElastictaskRequest) (_result *ModifyElastictaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ModifyElastictaskResponse{}
	_body, _err := client.ModifyElastictaskWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ## RequestBody
//
// You must also specify the following parameters in the RequestBody parameter to specify the maintenance window information.
//
// | Parameter | Type | Required | Example | Description |
//
// | --------- | ---- | -------- | ------- | ----------- |
//
// | maintainStartTime | String | No | 02:00Z | The start time of the maintenance window. Specify the time in the HH:mmZ format. The time must be in UTC. |
//
// | maintainEndTime | String | No | 06:00Z | The end time of the maintenance window. Specify the time in the HH:mmZ format. The time must be displayed in UTC. |
//
// | openMaintainTime | boolean | Yes | true | Specifies whether to enable the maintenance window feature. Only **true*	- is supported, indicating that the feature is enabled. |
//
// Examples:
//
// ```
//
// {
//
//     "openMaintainTime": true,
//
//     "maintainStartTime": "03:00Z",
//
//     "maintainEndTime": "04:00Z"
//
// }
//
// ```
//
// Description:
//
// es-cn-n6w1o1x0w001c\\*\\*\\*\\*
//
// @param request - ModifyInstanceMaintainTimeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyInstanceMaintainTimeResponse
func (client *Client) ModifyInstanceMaintainTimeWithOptions(InstanceId *string, request *ModifyInstanceMaintainTimeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ModifyInstanceMaintainTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyInstanceMaintainTime"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/modify-maintaintime"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyInstanceMaintainTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ## RequestBody
//
// You must also specify the following parameters in the RequestBody parameter to specify the maintenance window information.
//
// | Parameter | Type | Required | Example | Description |
//
// | --------- | ---- | -------- | ------- | ----------- |
//
// | maintainStartTime | String | No | 02:00Z | The start time of the maintenance window. Specify the time in the HH:mmZ format. The time must be in UTC. |
//
// | maintainEndTime | String | No | 06:00Z | The end time of the maintenance window. Specify the time in the HH:mmZ format. The time must be displayed in UTC. |
//
// | openMaintainTime | boolean | Yes | true | Specifies whether to enable the maintenance window feature. Only **true*	- is supported, indicating that the feature is enabled. |
//
// Examples:
//
// ```
//
// {
//
//     "openMaintainTime": true,
//
//     "maintainStartTime": "03:00Z",
//
//     "maintainEndTime": "04:00Z"
//
// }
//
// ```
//
// Description:
//
// es-cn-n6w1o1x0w001c\\*\\*\\*\\*
//
// @param request - ModifyInstanceMaintainTimeRequest
//
// @return ModifyInstanceMaintainTimeResponse
func (client *Client) ModifyInstanceMaintainTime(InstanceId *string, request *ModifyInstanceMaintainTimeRequest) (_result *ModifyInstanceMaintainTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ModifyInstanceMaintainTimeResponse{}
	_body, _err := client.ModifyInstanceMaintainTimeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
//
// 	- If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
//
// 	- If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
//
// 	- If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
//
// Description:
//
// The ID of the cluster.
//
// @param request - ModifyWhiteIpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyWhiteIpsResponse
func (client *Client) ModifyWhiteIpsWithOptions(InstanceId *string, request *ModifyWhiteIpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ModifyWhiteIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ModifyMode)) {
		body["modifyMode"] = request.ModifyMode
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		body["networkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		body["nodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.WhiteIpGroup)) {
		body["whiteIpGroup"] = request.WhiteIpGroup
	}

	if !tea.BoolValue(util.IsUnset(request.WhiteIpList)) {
		body["whiteIpList"] = request.WhiteIpList
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWhiteIps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/modify-white-ips"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWhiteIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
//
// 	- If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
//
// 	- If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
//
// 	- If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
//
// Description:
//
// The ID of the cluster.
//
// @param request - ModifyWhiteIpsRequest
//
// @return ModifyWhiteIpsResponse
func (client *Client) ModifyWhiteIps(InstanceId *string, request *ModifyWhiteIpsRequest) (_result *ModifyWhiteIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ModifyWhiteIpsResponse{}
	_body, _err := client.ModifyWhiteIpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Migrates an Elasticsearch cluster to a specified resource group.
//
// @param request - MoveResourceGroupRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return MoveResourceGroupResponse
func (client *Client) MoveResourceGroupWithOptions(InstanceId *string, request *MoveResourceGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *MoveResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("MoveResourceGroup"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/resourcegroup"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Migrates an Elasticsearch cluster to a specified resource group.
//
// @param request - MoveResourceGroupRequest
//
// @return MoveResourceGroupResponse
func (client *Client) MoveResourceGroup(InstanceId *string, request *MoveResourceGroupRequest) (_result *MoveResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.MoveResourceGroupWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - OpenDiagnosisRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenDiagnosisResponse
func (client *Client) OpenDiagnosisWithOptions(InstanceId *string, request *OpenDiagnosisRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *OpenDiagnosisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenDiagnosis"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/open-diagnosis"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenDiagnosisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - OpenDiagnosisRequest
//
// @return OpenDiagnosisResponse
func (client *Client) OpenDiagnosis(InstanceId *string, request *OpenDiagnosisRequest) (_result *OpenDiagnosisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &OpenDiagnosisResponse{}
	_body, _err := client.OpenDiagnosisWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Description:
//
// >  To ensure data security, we recommend that you enable HTTPS.
//
// @param request - OpenHttpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenHttpsResponse
func (client *Client) OpenHttpsWithOptions(InstanceId *string, request *OpenHttpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *OpenHttpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenHttps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/open-https"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenHttpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Description:
//
// >  To ensure data security, we recommend that you enable HTTPS.
//
// @param request - OpenHttpsRequest
//
// @return OpenHttpsResponse
func (client *Client) OpenHttps(InstanceId *string, request *OpenHttpsRequest) (_result *OpenHttpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &OpenHttpsResponse{}
	_body, _err := client.OpenHttpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - PostEmonTryAlarmRuleRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PostEmonTryAlarmRuleResponse
func (client *Client) PostEmonTryAlarmRuleWithOptions(ProjectId *string, AlarmGroupId *string, request *PostEmonTryAlarmRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *PostEmonTryAlarmRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("PostEmonTryAlarmRule"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/emon/projects/" + tea.StringValue(openapiutil.GetEncodeParam(ProjectId)) + "/alarm-groups/" + tea.StringValue(openapiutil.GetEncodeParam(AlarmGroupId)) + "/alarm-rules/_test"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &PostEmonTryAlarmRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - PostEmonTryAlarmRuleRequest
//
// @return PostEmonTryAlarmRuleResponse
func (client *Client) PostEmonTryAlarmRule(ProjectId *string, AlarmGroupId *string, request *PostEmonTryAlarmRuleRequest) (_result *PostEmonTryAlarmRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &PostEmonTryAlarmRuleResponse{}
	_body, _err := client.PostEmonTryAlarmRuleWithOptions(ProjectId, AlarmGroupId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - RecommendTemplatesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RecommendTemplatesResponse
func (client *Client) RecommendTemplatesWithOptions(InstanceId *string, request *RecommendTemplatesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RecommendTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UsageScenario)) {
		query["usageScenario"] = request.UsageScenario
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecommendTemplates"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/recommended-templates"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RecommendTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - RecommendTemplatesRequest
//
// @return RecommendTemplatesResponse
func (client *Client) RecommendTemplates(InstanceId *string, request *RecommendTemplatesRequest) (_result *RecommendTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RecommendTemplatesResponse{}
	_body, _err := client.RecommendTemplatesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Installs a shipper that failed to be installed when you create the shipper.
//
// @param request - ReinstallCollectorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ReinstallCollectorResponse
func (client *Client) ReinstallCollectorWithOptions(ResId *string, request *ReinstallCollectorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ReinstallCollectorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ReinstallCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId)) + "/actions/reinstall"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ReinstallCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Installs a shipper that failed to be installed when you create the shipper.
//
// @param request - ReinstallCollectorRequest
//
// @return ReinstallCollectorResponse
func (client *Client) ReinstallCollector(ResId *string, request *ReinstallCollectorRequest) (_result *ReinstallCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ReinstallCollectorResponse{}
	_body, _err := client.ReinstallCollectorWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// RemoveApm
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RemoveApmResponse
func (client *Client) RemoveApmWithOptions(instanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RemoveApmResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveApm"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/apm/" + tea.StringValue(openapiutil.GetEncodeParam(instanceId))),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveApmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// RemoveApm
//
// @return RemoveApmResponse
func (client *Client) RemoveApm(instanceId *string) (_result *RemoveApmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RemoveApmResponse{}
	_body, _err := client.RemoveApmWithOptions(instanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call RenewInstance to renew a subscription instance.
//
// @param request - RenewInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RenewInstanceResponse
func (client *Client) RenewInstanceWithOptions(InstanceId *string, request *RenewInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RenewInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("RenewInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/renew"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RenewInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call RenewInstance to renew a subscription instance.
//
// @param request - RenewInstanceRequest
//
// @return RenewInstanceResponse
func (client *Client) RenewInstance(InstanceId *string, request *RenewInstanceRequest) (_result *RenewInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RenewInstanceResponse{}
	_body, _err := client.RenewInstanceWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Renews a Logstash cluster.
//
// @param request - RenewLogstashRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RenewLogstashResponse
func (client *Client) RenewLogstashWithOptions(InstanceId *string, request *RenewLogstashRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RenewLogstashResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("RenewLogstash"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/renew"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RenewLogstashResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Renews a Logstash cluster.
//
// @param request - RenewLogstashRequest
//
// @return RenewLogstashResponse
func (client *Client) RenewLogstash(InstanceId *string, request *RenewLogstashRequest) (_result *RenewLogstashResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RenewLogstashResponse{}
	_body, _err := client.RenewLogstashWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Restarts a shipper.
//
// @param request - RestartCollectorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RestartCollectorResponse
func (client *Client) RestartCollectorWithOptions(ResId *string, request *RestartCollectorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RestartCollectorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId)) + "/actions/restart"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Restarts a shipper.
//
// @param request - RestartCollectorRequest
//
// @return RestartCollectorResponse
func (client *Client) RestartCollector(ResId *string, request *RestartCollectorRequest) (_result *RestartCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RestartCollectorResponse{}
	_body, _err := client.RestartCollectorWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// You can call this operation to restart a specified Elasticsearch instance.
//
// Description:
//
// >  After the instance is restarted, the instance enters the activating state. After the instance is restarted, its status changes to active. Alibaba Cloud Elasticsearch supports restarting a single node. Restarting a node can be divided into normal restart and blue-green restart.
//
// @param request - RestartInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RestartInstanceResponse
func (client *Client) RestartInstanceWithOptions(InstanceId *string, request *RestartInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RestartInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["force"] = request.Force
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("RestartInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/restart"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// You can call this operation to restart a specified Elasticsearch instance.
//
// Description:
//
// >  After the instance is restarted, the instance enters the activating state. After the instance is restarted, its status changes to active. Alibaba Cloud Elasticsearch supports restarting a single node. Restarting a node can be divided into normal restart and blue-green restart.
//
// @param request - RestartInstanceRequest
//
// @return RestartInstanceResponse
func (client *Client) RestartInstance(InstanceId *string, request *RestartInstanceRequest) (_result *RestartInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RestartInstanceResponse{}
	_body, _err := client.RestartInstanceWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - RestartLogstashRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RestartLogstashResponse
func (client *Client) RestartLogstashWithOptions(InstanceId *string, request *RestartLogstashRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RestartLogstashResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["force"] = request.Force
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BatchCount)) {
		body["batchCount"] = request.BatchCount
	}

	if !tea.BoolValue(util.IsUnset(request.BlueGreenDep)) {
		body["blueGreenDep"] = request.BlueGreenDep
	}

	if !tea.BoolValue(util.IsUnset(request.NodeTypes)) {
		body["nodeTypes"] = request.NodeTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Nodes)) {
		body["nodes"] = request.Nodes
	}

	if !tea.BoolValue(util.IsUnset(request.RestartType)) {
		body["restartType"] = request.RestartType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartLogstash"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/restart"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartLogstashResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - RestartLogstashRequest
//
// @return RestartLogstashResponse
func (client *Client) RestartLogstash(InstanceId *string, request *RestartLogstashRequest) (_result *RestartLogstashResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RestartLogstashResponse{}
	_body, _err := client.RestartLogstashWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ResumeElasticsearchTaskRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ResumeElasticsearchTaskResponse
func (client *Client) ResumeElasticsearchTaskWithOptions(InstanceId *string, request *ResumeElasticsearchTaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ResumeElasticsearchTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResumeElasticsearchTask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/resume"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ResumeElasticsearchTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ResumeElasticsearchTaskRequest
//
// @return ResumeElasticsearchTaskResponse
func (client *Client) ResumeElasticsearchTask(InstanceId *string, request *ResumeElasticsearchTaskRequest) (_result *ResumeElasticsearchTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ResumeElasticsearchTaskResponse{}
	_body, _err := client.ResumeElasticsearchTaskWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Resumes a change task of a Logstash cluster. After the task is resumed, the Logstash cluster is in the activating state.
//
// @param request - ResumeLogstashTaskRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ResumeLogstashTaskResponse
func (client *Client) ResumeLogstashTaskWithOptions(InstanceId *string, request *ResumeLogstashTaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ResumeLogstashTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResumeLogstashTask"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/resume"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ResumeLogstashTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Resumes a change task of a Logstash cluster. After the task is resumed, the Logstash cluster is in the activating state.
//
// @param request - ResumeLogstashTaskRequest
//
// @return ResumeLogstashTaskResponse
func (client *Client) ResumeLogstashTask(InstanceId *string, request *ResumeLogstashTaskRequest) (_result *ResumeLogstashTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ResumeLogstashTaskResponse{}
	_body, _err := client.ResumeLogstashTaskWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - RolloverDataStreamRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RolloverDataStreamResponse
func (client *Client) RolloverDataStreamWithOptions(InstanceId *string, DataStream *string, request *RolloverDataStreamRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RolloverDataStreamResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RolloverDataStream"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/data-streams/" + tea.StringValue(openapiutil.GetEncodeParam(DataStream)) + "/rollover"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RolloverDataStreamResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - RolloverDataStreamRequest
//
// @return RolloverDataStreamResponse
func (client *Client) RolloverDataStream(InstanceId *string, DataStream *string, request *RolloverDataStreamRequest) (_result *RolloverDataStreamResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RolloverDataStreamResponse{}
	_body, _err := client.RolloverDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Runs pipelines in a Logstash cluster.
//
// @param request - RunPipelinesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RunPipelinesResponse
func (client *Client) RunPipelinesWithOptions(InstanceId *string, request *RunPipelinesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RunPipelinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("RunPipelines"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipelines/action/run"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RunPipelinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Runs pipelines in a Logstash cluster.
//
// @param request - RunPipelinesRequest
//
// @return RunPipelinesResponse
func (client *Client) RunPipelines(InstanceId *string, request *RunPipelinesRequest) (_result *RunPipelinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RunPipelinesResponse{}
	_body, _err := client.RunPipelinesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - ShrinkNodeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ShrinkNodeResponse
func (client *Client) ShrinkNodeWithOptions(InstanceId *string, request *ShrinkNodeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ShrinkNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreStatus)) {
		query["ignoreStatus"] = request.IgnoreStatus
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["nodeType"] = request.NodeType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    util.ToArray(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("ShrinkNode"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/shrink"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ShrinkNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - ShrinkNodeRequest
//
// @return ShrinkNodeResponse
func (client *Client) ShrinkNode(InstanceId *string, request *ShrinkNodeRequest) (_result *ShrinkNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ShrinkNodeResponse{}
	_body, _err := client.ShrinkNodeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// StartApm
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartApmResponse
func (client *Client) StartApmWithOptions(instanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartApmResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StartApm"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/apm/" + tea.StringValue(openapiutil.GetEncodeParam(instanceId)) + "/actions/start"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StartApmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// StartApm
//
// @return StartApmResponse
func (client *Client) StartApm(instanceId *string) (_result *StartApmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartApmResponse{}
	_body, _err := client.StartApmWithOptions(instanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Starts a collector to collect data.
//
// @param request - StartCollectorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartCollectorResponse
func (client *Client) StartCollectorWithOptions(ResId *string, request *StartCollectorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartCollectorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId)) + "/actions/start"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StartCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Starts a collector to collect data.
//
// @param request - StartCollectorRequest
//
// @return StartCollectorResponse
func (client *Client) StartCollector(ResId *string, request *StartCollectorRequest) (_result *StartCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartCollectorResponse{}
	_body, _err := client.StartCollectorWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// StopApm
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopApmResponse
func (client *Client) StopApmWithOptions(instanceId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopApmResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StopApm"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/apm/" + tea.StringValue(openapiutil.GetEncodeParam(instanceId)) + "/actions/stop"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StopApmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// StopApm
//
// @return StopApmResponse
func (client *Client) StopApm(instanceId *string) (_result *StopApmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopApmResponse{}
	_body, _err := client.StopApmWithOptions(instanceId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Stops a shipper.
//
// @param request - StopCollectorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopCollectorResponse
func (client *Client) StopCollectorWithOptions(ResId *string, request *StopCollectorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopCollectorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId)) + "/actions/stop"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StopCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Stops a shipper.
//
// @param request - StopCollectorRequest
//
// @return StopCollectorResponse
func (client *Client) StopCollector(ResId *string, request *StopCollectorRequest) (_result *StopCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopCollectorResponse{}
	_body, _err := client.StopCollectorWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Stops pipelines in a Logstash cluster.
//
// @param request - StopPipelinesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopPipelinesResponse
func (client *Client) StopPipelinesWithOptions(InstanceId *string, request *StopPipelinesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopPipelinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("StopPipelines"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipelines/action/stop"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StopPipelinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Stops pipelines in a Logstash cluster.
//
// @param request - StopPipelinesRequest
//
// @return StopPipelinesResponse
func (client *Client) StopPipelines(InstanceId *string, request *StopPipelinesRequest) (_result *StopPipelinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopPipelinesResponse{}
	_body, _err := client.StopPipelinesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// The information about the clusters and tags.
//
// @param request - TagResourcesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TagResourcesResponse
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		body["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		body["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		body["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/tags"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// The information about the clusters and tags.
//
// @param request - TagResourcesRequest
//
// @return TagResourcesResponse
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - TransferNodeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TransferNodeResponse
func (client *Client) TransferNodeWithOptions(InstanceId *string, request *TransferNodeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *TransferNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["nodeType"] = request.NodeType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    util.ToArray(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("TransferNode"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/transfer"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &TransferNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - TransferNodeRequest
//
// @return TransferNodeResponse
func (client *Client) TransferNode(InstanceId *string, request *TransferNodeRequest) (_result *TransferNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &TransferNodeResponse{}
	_body, _err := client.TransferNodeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ESKibana
//
// @param request - TriggerNetworkRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TriggerNetworkResponse
func (client *Client) TriggerNetworkWithOptions(InstanceId *string, request *TriggerNetworkRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *TriggerNetworkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionType)) {
		body["actionType"] = request.ActionType
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		body["networkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		body["nodeType"] = request.NodeType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TriggerNetwork"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/network-trigger"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &TriggerNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ESKibana
//
// @param request - TriggerNetworkRequest
//
// @return TriggerNetworkResponse
func (client *Client) TriggerNetwork(InstanceId *string, request *TriggerNetworkRequest) (_result *TriggerNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &TriggerNetworkResponse{}
	_body, _err := client.TriggerNetworkWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call the UninstallKibanaPlugin to uninstall the Kibana plug-in.
//
// @param request - UninstallKibanaPluginRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UninstallKibanaPluginResponse
func (client *Client) UninstallKibanaPluginWithOptions(InstanceId *string, request *UninstallKibanaPluginRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UninstallKibanaPluginResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UninstallKibanaPlugin"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/kibana-plugins/actions/uninstall"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UninstallKibanaPluginResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call the UninstallKibanaPlugin to uninstall the Kibana plug-in.
//
// @param request - UninstallKibanaPluginRequest
//
// @return UninstallKibanaPluginResponse
func (client *Client) UninstallKibanaPlugin(InstanceId *string, request *UninstallKibanaPluginRequest) (_result *UninstallKibanaPluginResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UninstallKibanaPluginResponse{}
	_body, _err := client.UninstallKibanaPluginWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - UninstallLogstashPluginRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UninstallLogstashPluginResponse
func (client *Client) UninstallLogstashPluginWithOptions(InstanceId *string, request *UninstallLogstashPluginRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UninstallLogstashPluginResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UninstallLogstashPlugin"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/plugins/actions/uninstall"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UninstallLogstashPluginResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - UninstallLogstashPluginRequest
//
// @return UninstallLogstashPluginResponse
func (client *Client) UninstallLogstashPlugin(InstanceId *string, request *UninstallLogstashPluginRequest) (_result *UninstallLogstashPluginResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UninstallLogstashPluginResponse{}
	_body, _err := client.UninstallLogstashPluginWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UninstallPlugin to uninstall the preset plug-in.
//
// @param request - UninstallPluginRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UninstallPluginResponse
func (client *Client) UninstallPluginWithOptions(InstanceId *string, request *UninstallPluginRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UninstallPluginResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["force"] = request.Force
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UninstallPlugin"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/plugins/actions/uninstall"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UninstallPluginResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UninstallPlugin to uninstall the preset plug-in.
//
// @param request - UninstallPluginRequest
//
// @return UninstallPluginResponse
func (client *Client) UninstallPlugin(InstanceId *string, request *UninstallPluginRequest) (_result *UninstallPluginResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UninstallPluginResponse{}
	_body, _err := client.UninstallPluginWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// When you call this operation, take note of the following items:
//
// 	- You can only delete user tags.
//
// > User labels are manually added to instances by users. A system Tag is a tag that Alibaba Cloud services add to instances. System labels are divided into visible labels and invisible labels.
//
// 	- If you delete a resource tag relationship that is not associated with any resources, you must delete the tags.
//
// @param request - UntagResourcesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UntagResourcesResponse
func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeys)) {
		query["TagKeys"] = request.TagKeys
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/tags"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// When you call this operation, take note of the following items:
//
// 	- You can only delete user tags.
//
// > User labels are manually added to instances by users. A system Tag is a tag that Alibaba Cloud services add to instances. System labels are divided into visible labels and invisible labels.
//
// 	- If you delete a resource tag relationship that is not associated with any resources, you must delete the tags.
//
// @param request - UntagResourcesRequest
//
// @return UntagResourcesResponse
func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
//
// @param request - UpdateAdminPasswordRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAdminPasswordResponse
func (client *Client) UpdateAdminPasswordWithOptions(InstanceId *string, request *UpdateAdminPasswordRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAdminPasswordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EsAdminPassword)) {
		body["esAdminPassword"] = request.EsAdminPassword
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAdminPassword"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/admin-pwd"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAdminPasswordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
//
// @param request - UpdateAdminPasswordRequest
//
// @return UpdateAdminPasswordResponse
func (client *Client) UpdateAdminPassword(InstanceId *string, request *UpdateAdminPasswordRequest) (_result *UpdateAdminPasswordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAdminPasswordResponse{}
	_body, _err := client.UpdateAdminPasswordWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UpdateAdvancedSetting to change the garbage collector configuration for the specified instance.
//
// @param request - UpdateAdvancedSettingRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAdvancedSettingResponse
func (client *Client) UpdateAdvancedSettingWithOptions(InstanceId *string, request *UpdateAdvancedSettingRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAdvancedSettingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAdvancedSetting"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/update-advanced-setting"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAdvancedSettingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UpdateAdvancedSetting to change the garbage collector configuration for the specified instance.
//
// @param request - UpdateAdvancedSettingRequest
//
// @return UpdateAdvancedSettingResponse
func (client *Client) UpdateAdvancedSetting(InstanceId *string, request *UpdateAdvancedSettingRequest) (_result *UpdateAdvancedSettingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAdvancedSettingResponse{}
	_body, _err := client.UpdateAdvancedSettingWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the dictionary file of the analysis-aliws plug-in.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- Elasticsearch V5.X clusters do not support the analysis-aliws plug-in.
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateAliwsDictRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAliwsDictResponse
func (client *Client) UpdateAliwsDictWithOptions(InstanceId *string, request *UpdateAliwsDictRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAliwsDictResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAliwsDict"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/aliws-dict"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAliwsDictResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the dictionary file of the analysis-aliws plug-in.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- Elasticsearch V5.X clusters do not support the analysis-aliws plug-in.
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateAliwsDictRequest
//
// @return UpdateAliwsDictResponse
func (client *Client) UpdateAliwsDict(InstanceId *string, request *UpdateAliwsDictRequest) (_result *UpdateAliwsDictResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAliwsDictResponse{}
	_body, _err := client.UpdateAliwsDictWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// APM
//
// @param request - UpdateApmRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateApmResponse
func (client *Client) UpdateApmWithOptions(instanceId *string, request *UpdateApmRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateApmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.OutputES)) {
		body["outputES"] = request.OutputES
	}

	if !tea.BoolValue(util.IsUnset(request.OutputESPassword)) {
		body["outputESPassword"] = request.OutputESPassword
	}

	if !tea.BoolValue(util.IsUnset(request.OutputESUserName)) {
		body["outputESUserName"] = request.OutputESUserName
	}

	if !tea.BoolValue(util.IsUnset(request.Token)) {
		body["token"] = request.Token
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateApm"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/apm/" + tea.StringValue(openapiutil.GetEncodeParam(instanceId))),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateApmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// APM
//
// @param request - UpdateApmRequest
//
// @return UpdateApmResponse
func (client *Client) UpdateApm(instanceId *string, request *UpdateApmRequest) (_result *UpdateApmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateApmResponse{}
	_body, _err := client.UpdateApmWithOptions(instanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI UpdateBlackIps is deprecated
//
// Summary:
//
// ES
//
// @param request - UpdateBlackIpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateBlackIpsResponse
// Deprecated
func (client *Client) UpdateBlackIpsWithOptions(InstanceId *string, request *UpdateBlackIpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateBlackIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBlackIps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/black-ips"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBlackIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Deprecated: OpenAPI UpdateBlackIps is deprecated
//
// Summary:
//
// ES
//
// @param request - UpdateBlackIpsRequest
//
// @return UpdateBlackIpsResponse
// Deprecated
func (client *Client) UpdateBlackIps(InstanceId *string, request *UpdateBlackIpsRequest) (_result *UpdateBlackIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateBlackIpsResponse{}
	_body, _err := client.UpdateBlackIpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the configurations of a shipper.
//
// @param request - UpdateCollectorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateCollectorResponse
func (client *Client) UpdateCollectorWithOptions(ResId *string, request *UpdateCollectorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateCollectorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCollector"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId))),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCollectorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the configurations of a shipper.
//
// @param request - UpdateCollectorRequest
//
// @return UpdateCollectorResponse
func (client *Client) UpdateCollector(ResId *string, request *UpdateCollectorRequest) (_result *UpdateCollectorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateCollectorResponse{}
	_body, _err := client.UpdateCollectorWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the name of a shipper.
//
// @param request - UpdateCollectorNameRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateCollectorNameResponse
func (client *Client) UpdateCollectorNameWithOptions(ResId *string, request *UpdateCollectorNameRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateCollectorNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCollectorName"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/collectors/" + tea.StringValue(openapiutil.GetEncodeParam(ResId)) + "/actions/rename"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCollectorNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Changes the name of a shipper.
//
// @param request - UpdateCollectorNameRequest
//
// @return UpdateCollectorNameResponse
func (client *Client) UpdateCollectorName(ResId *string, request *UpdateCollectorNameRequest) (_result *UpdateCollectorNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateCollectorNameResponse{}
	_body, _err := client.UpdateCollectorNameWithOptions(ResId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateComponentIndexRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateComponentIndexResponse
func (client *Client) UpdateComponentIndexWithOptions(InstanceId *string, name *string, request *UpdateComponentIndexRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateComponentIndexResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Meta)) {
		body["_meta"] = request.Meta
	}

	if !tea.BoolValue(util.IsUnset(request.Template)) {
		body["template"] = request.Template
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateComponentIndex"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/component-index/" + tea.StringValue(openapiutil.GetEncodeParam(name))),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateComponentIndexResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateComponentIndexRequest
//
// @return UpdateComponentIndexResponse
func (client *Client) UpdateComponentIndex(InstanceId *string, name *string, request *UpdateComponentIndexRequest) (_result *UpdateComponentIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateComponentIndexResponse{}
	_body, _err := client.UpdateComponentIndexWithOptions(InstanceId, name, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// elasticsearch
//
// @param request - UpdateDescriptionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateDescriptionResponse
func (client *Client) UpdateDescriptionWithOptions(InstanceId *string, request *UpdateDescriptionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateDescriptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDescription"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/description"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDescriptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// elasticsearch
//
// @param request - UpdateDescriptionRequest
//
// @return UpdateDescriptionResponse
func (client *Client) UpdateDescription(InstanceId *string, request *UpdateDescriptionRequest) (_result *UpdateDescriptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateDescriptionResponse{}
	_body, _err := client.UpdateDescriptionWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UpdateDiagnosisSettings to update the instance of intelligent operation&maintenance (O&M) scene settings.
//
// @param request - UpdateDiagnosisSettingsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateDiagnosisSettingsResponse
func (client *Client) UpdateDiagnosisSettingsWithOptions(InstanceId *string, request *UpdateDiagnosisSettingsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateDiagnosisSettingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDiagnosisSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/diagnosis/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/settings"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDiagnosisSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UpdateDiagnosisSettings to update the instance of intelligent operation&maintenance (O&M) scene settings.
//
// @param request - UpdateDiagnosisSettingsRequest
//
// @return UpdateDiagnosisSettingsResponse
func (client *Client) UpdateDiagnosisSettings(InstanceId *string, request *UpdateDiagnosisSettingsRequest) (_result *UpdateDiagnosisSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateDiagnosisSettingsResponse{}
	_body, _err := client.UpdateDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a dictionary of an Elasticsearch cluster.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateDictRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateDictResponse
func (client *Client) UpdateDictWithOptions(InstanceId *string, request *UpdateDictRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateDictResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDict"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/dict"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDictResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a dictionary of an Elasticsearch cluster.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateDictRequest
//
// @return UpdateDictResponse
func (client *Client) UpdateDict(InstanceId *string, request *UpdateDictRequest) (_result *UpdateDictResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateDictResponse{}
	_body, _err := client.UpdateDictWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - UpdateDynamicSettingsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateDynamicSettingsResponse
func (client *Client) UpdateDynamicSettingsWithOptions(InstanceId *string, request *UpdateDynamicSettingsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateDynamicSettingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["mode"] = request.Mode
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDynamicSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/dynamic-settings"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDynamicSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - UpdateDynamicSettingsRequest
//
// @return UpdateDynamicSettingsResponse
func (client *Client) UpdateDynamicSettings(InstanceId *string, request *UpdateDynamicSettingsRequest) (_result *UpdateDynamicSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateDynamicSettingsResponse{}
	_body, _err := client.UpdateDynamicSettingsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - UpdateExtendConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateExtendConfigResponse
func (client *Client) UpdateExtendConfigWithOptions(InstanceId *string, request *UpdateExtendConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateExtendConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateExtendConfig"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/extend-configs/actions/update"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateExtendConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - UpdateExtendConfigRequest
//
// @return UpdateExtendConfigResponse
func (client *Client) UpdateExtendConfig(InstanceId *string, request *UpdateExtendConfigRequest) (_result *UpdateExtendConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateExtendConfigResponse{}
	_body, _err := client.UpdateExtendConfigWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the driver files of a Logstash cluster.
//
// Description:
//
// When you call this operation, take note of the following items: You can call this operation only to delete the driver files that are uploaded to a Logstash cluster in the Alibaba Cloud Management Console. You can add or modify driver files only in the Alibaba Cloud Management Console.
//
// @param request - UpdateExtendfilesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateExtendfilesResponse
func (client *Client) UpdateExtendfilesWithOptions(InstanceId *string, request *UpdateExtendfilesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateExtendfilesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateExtendfiles"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/extendfiles"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateExtendfilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the driver files of a Logstash cluster.
//
// Description:
//
// When you call this operation, take note of the following items: You can call this operation only to delete the driver files that are uploaded to a Logstash cluster in the Alibaba Cloud Management Console. You can add or modify driver files only in the Alibaba Cloud Management Console.
//
// @param request - UpdateExtendfilesRequest
//
// @return UpdateExtendfilesResponse
func (client *Client) UpdateExtendfiles(InstanceId *string, request *UpdateExtendfilesRequest) (_result *UpdateExtendfilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateExtendfilesResponse{}
	_body, _err := client.UpdateExtendfilesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Performs a rolling update for the IK dictionaries of an Elasticsearch cluster.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateHotIkDictsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateHotIkDictsResponse
func (client *Client) UpdateHotIkDictsWithOptions(InstanceId *string, request *UpdateHotIkDictsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateHotIkDictsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateHotIkDicts"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/ik-hot-dict"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateHotIkDictsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Performs a rolling update for the IK dictionaries of an Elasticsearch cluster.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateHotIkDictsRequest
//
// @return UpdateHotIkDictsResponse
func (client *Client) UpdateHotIkDicts(InstanceId *string, request *UpdateHotIkDictsRequest) (_result *UpdateHotIkDictsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateHotIkDictsResponse{}
	_body, _err := client.UpdateHotIkDictsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateILMPolicyRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateILMPolicyResponse
func (client *Client) UpdateILMPolicyWithOptions(InstanceId *string, PolicyName *string, request *UpdateILMPolicyRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateILMPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateILMPolicy"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/ilm-policies/" + tea.StringValue(openapiutil.GetEncodeParam(PolicyName))),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateILMPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateILMPolicyRequest
//
// @return UpdateILMPolicyResponse
func (client *Client) UpdateILMPolicy(InstanceId *string, PolicyName *string, request *UpdateILMPolicyRequest) (_result *UpdateILMPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateILMPolicyResponse{}
	_body, _err := client.UpdateILMPolicyWithOptions(InstanceId, PolicyName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateIndexTemplateRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateIndexTemplateResponse
func (client *Client) UpdateIndexTemplateWithOptions(InstanceId *string, IndexTemplate *string, request *UpdateIndexTemplateRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateIndexTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIndexTemplate"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/index-templates/" + tea.StringValue(openapiutil.GetEncodeParam(IndexTemplate))),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIndexTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateIndexTemplateRequest
//
// @return UpdateIndexTemplateResponse
func (client *Client) UpdateIndexTemplate(InstanceId *string, IndexTemplate *string, request *UpdateIndexTemplateRequest) (_result *UpdateIndexTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateIndexTemplateResponse{}
	_body, _err := client.UpdateIndexTemplateWithOptions(InstanceId, IndexTemplate, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// es-cn-n6w1ptcb30009\\*\\*\\*\\*
//
// @param request - UpdateInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateInstanceResponse
func (client *Client) UpdateInstanceWithOptions(InstanceId *string, request *UpdateInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.OrderActionType)) {
		query["orderActionType"] = request.OrderActionType
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientNodeConfiguration)) {
		body["clientNodeConfiguration"] = request.ClientNodeConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.ElasticDataNodeConfiguration)) {
		body["elasticDataNodeConfiguration"] = request.ElasticDataNodeConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceCategory)) {
		body["instanceCategory"] = request.InstanceCategory
	}

	if !tea.BoolValue(util.IsUnset(request.KibanaConfiguration)) {
		body["kibanaConfiguration"] = request.KibanaConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.MasterConfiguration)) {
		body["masterConfiguration"] = request.MasterConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.NodeAmount)) {
		body["nodeAmount"] = request.NodeAmount
	}

	if !tea.BoolValue(util.IsUnset(request.NodeSpec)) {
		body["nodeSpec"] = request.NodeSpec
	}

	if !tea.BoolValue(util.IsUnset(request.WarmNodeConfiguration)) {
		body["warmNodeConfiguration"] = request.WarmNodeConfiguration
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId))),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// es-cn-n6w1ptcb30009\\*\\*\\*\\*
//
// @param request - UpdateInstanceRequest
//
// @return UpdateInstanceResponse
func (client *Client) UpdateInstance(InstanceId *string, request *UpdateInstanceRequest) (_result *UpdateInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateInstanceResponse{}
	_body, _err := client.UpdateInstanceWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UpdateInstanceChargeType to change the billing method of a pay-as-you-go instance to subscription.
//
// @param request - UpdateInstanceChargeTypeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateInstanceChargeTypeResponse
func (client *Client) UpdateInstanceChargeTypeWithOptions(InstanceId *string, request *UpdateInstanceChargeTypeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateInstanceChargeTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateInstanceChargeType"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/convert-pay-type"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateInstanceChargeTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UpdateInstanceChargeType to change the billing method of a pay-as-you-go instance to subscription.
//
// @param request - UpdateInstanceChargeTypeRequest
//
// @return UpdateInstanceChargeTypeResponse
func (client *Client) UpdateInstanceChargeType(InstanceId *string, request *UpdateInstanceChargeTypeRequest) (_result *UpdateInstanceChargeTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateInstanceChargeTypeResponse{}
	_body, _err := client.UpdateInstanceChargeTypeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UpdateInstanceSettings to update the YML configuration of a specified instance.
//
// Description:
//
// When you call this operation, take note of the following items:
//
// When the instance is in the activating, invalid, or inactive state, you cannot update the configuration.
//
// @param request - UpdateInstanceSettingsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateInstanceSettingsResponse
func (client *Client) UpdateInstanceSettingsWithOptions(InstanceId *string, request *UpdateInstanceSettingsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateInstanceSettingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateInstanceSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/instance-settings"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateInstanceSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UpdateInstanceSettings to update the YML configuration of a specified instance.
//
// Description:
//
// When you call this operation, take note of the following items:
//
// When the instance is in the activating, invalid, or inactive state, you cannot update the configuration.
//
// @param request - UpdateInstanceSettingsRequest
//
// @return UpdateInstanceSettingsResponse
func (client *Client) UpdateInstanceSettings(InstanceId *string, request *UpdateInstanceSettingsRequest) (_result *UpdateInstanceSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateInstanceSettingsResponse{}
	_body, _err := client.UpdateInstanceSettingsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// kibana
//
// @param request - UpdateKibanaPvlNetworkRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateKibanaPvlNetworkResponse
func (client *Client) UpdateKibanaPvlNetworkWithOptions(InstanceId *string, request *UpdateKibanaPvlNetworkRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateKibanaPvlNetworkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PvlId)) {
		query["pvlId"] = request.PvlId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointName)) {
		body["endpointName"] = request.EndpointName
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroups)) {
		body["securityGroups"] = request.SecurityGroups
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateKibanaPvlNetwork"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/update-kibana-private"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateKibanaPvlNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// kibana
//
// @param request - UpdateKibanaPvlNetworkRequest
//
// @return UpdateKibanaPvlNetworkResponse
func (client *Client) UpdateKibanaPvlNetwork(InstanceId *string, request *UpdateKibanaPvlNetworkRequest) (_result *UpdateKibanaPvlNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateKibanaPvlNetworkResponse{}
	_body, _err := client.UpdateKibanaPvlNetworkWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UpdateKibanaSettings to modify the Kibana configuration. Currently, you can only modify the Kibana language configuration.
//
// @param request - UpdateKibanaSettingsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateKibanaSettingsResponse
func (client *Client) UpdateKibanaSettingsWithOptions(InstanceId *string, request *UpdateKibanaSettingsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateKibanaSettingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateKibanaSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/update-kibana-settings"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateKibanaSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UpdateKibanaSettings to modify the Kibana configuration. Currently, you can only modify the Kibana language configuration.
//
// @param request - UpdateKibanaSettingsRequest
//
// @return UpdateKibanaSettingsResponse
func (client *Client) UpdateKibanaSettings(InstanceId *string, request *UpdateKibanaSettingsRequest) (_result *UpdateKibanaSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateKibanaSettingsResponse{}
	_body, _err := client.UpdateKibanaSettingsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates an IP address whitelist for access to the Kibana console of a specified Elasticsearch cluster.
//
// Description:
//
//   Before you call this operation, you must make sure that the cluster is not in the activating, invalid, or inactive state.
//
// 	- You can update an IP address whitelist by using the following parameters:
//
//     	- kibanaIPWhitelist
//
//     	- modifyMode and whiteIpGroup
//
// 	- You cannot specify private IP addresses for public IP address whitelists and cannot specify public IP addresses for private IP address whitelists.
//
// @param request - UpdateKibanaWhiteIpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateKibanaWhiteIpsResponse
func (client *Client) UpdateKibanaWhiteIpsWithOptions(InstanceId *string, request *UpdateKibanaWhiteIpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateKibanaWhiteIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ModifyMode)) {
		query["modifyMode"] = request.ModifyMode
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.KibanaIPWhitelist)) {
		body["kibanaIPWhitelist"] = request.KibanaIPWhitelist
	}

	if !tea.BoolValue(util.IsUnset(request.WhiteIpGroup)) {
		body["whiteIpGroup"] = request.WhiteIpGroup
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateKibanaWhiteIps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/kibana-white-ips"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateKibanaWhiteIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates an IP address whitelist for access to the Kibana console of a specified Elasticsearch cluster.
//
// Description:
//
//   Before you call this operation, you must make sure that the cluster is not in the activating, invalid, or inactive state.
//
// 	- You can update an IP address whitelist by using the following parameters:
//
//     	- kibanaIPWhitelist
//
//     	- modifyMode and whiteIpGroup
//
// 	- You cannot specify private IP addresses for public IP address whitelists and cannot specify public IP addresses for private IP address whitelists.
//
// @param request - UpdateKibanaWhiteIpsRequest
//
// @return UpdateKibanaWhiteIpsResponse
func (client *Client) UpdateKibanaWhiteIps(InstanceId *string, request *UpdateKibanaWhiteIpsRequest) (_result *UpdateKibanaWhiteIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateKibanaWhiteIpsResponse{}
	_body, _err := client.UpdateKibanaWhiteIpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - UpdateLogstashRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogstashResponse
func (client *Client) UpdateLogstashWithOptions(InstanceId *string, request *UpdateLogstashRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogstashResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeAmount)) {
		body["nodeAmount"] = request.NodeAmount
	}

	if !tea.BoolValue(util.IsUnset(request.NodeSpec)) {
		body["nodeSpec"] = request.NodeSpec
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogstash"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId))),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateLogstashResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - UpdateLogstashRequest
//
// @return UpdateLogstashResponse
func (client *Client) UpdateLogstash(InstanceId *string, request *UpdateLogstashRequest) (_result *UpdateLogstashResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogstashResponse{}
	_body, _err := client.UpdateLogstashWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Switches the billing method of a Logstash cluster from pay-as-you-go to subscription.
//
// @param request - UpdateLogstashChargeTypeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogstashChargeTypeResponse
func (client *Client) UpdateLogstashChargeTypeWithOptions(InstanceId *string, request *UpdateLogstashChargeTypeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogstashChargeTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogstashChargeType"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/convert-pay-type"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateLogstashChargeTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Switches the billing method of a Logstash cluster from pay-as-you-go to subscription.
//
// @param request - UpdateLogstashChargeTypeRequest
//
// @return UpdateLogstashChargeTypeResponse
func (client *Client) UpdateLogstashChargeType(InstanceId *string, request *UpdateLogstashChargeTypeRequest) (_result *UpdateLogstashChargeTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogstashChargeTypeResponse{}
	_body, _err := client.UpdateLogstashChargeTypeWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the name of a specified Logstash cluster.
//
// Description:
//
// When you call this operation, take note of the following items: You cannot change the name of a cluster that is in the activating, invalid, or inactive state.
//
// @param request - UpdateLogstashDescriptionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogstashDescriptionResponse
func (client *Client) UpdateLogstashDescriptionWithOptions(InstanceId *string, request *UpdateLogstashDescriptionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogstashDescriptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogstashDescription"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/description"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateLogstashDescriptionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Changes the name of a specified Logstash cluster.
//
// Description:
//
// When you call this operation, take note of the following items: You cannot change the name of a cluster that is in the activating, invalid, or inactive state.
//
// @param request - UpdateLogstashDescriptionRequest
//
// @return UpdateLogstashDescriptionResponse
func (client *Client) UpdateLogstashDescription(InstanceId *string, request *UpdateLogstashDescriptionRequest) (_result *UpdateLogstashDescriptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogstashDescriptionResponse{}
	_body, _err := client.UpdateLogstashDescriptionWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the configuration of a specified Logstash cluster.
//
// Description:
//
// When you call this operation, take note of the following items:
//
// If the instance is in the Active (activating), Invalid (invalid), and Inactive (inactive) state, the information cannot be updated.
//
// @param request - UpdateLogstashSettingsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogstashSettingsResponse
func (client *Client) UpdateLogstashSettingsWithOptions(InstanceId *string, request *UpdateLogstashSettingsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogstashSettingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogstashSettings"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/instance-settings"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateLogstashSettingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the configuration of a specified Logstash cluster.
//
// Description:
//
// When you call this operation, take note of the following items:
//
// If the instance is in the Active (activating), Invalid (invalid), and Inactive (inactive) state, the information cannot be updated.
//
// @param request - UpdateLogstashSettingsRequest
//
// @return UpdateLogstashSettingsResponse
func (client *Client) UpdateLogstashSettings(InstanceId *string, request *UpdateLogstashSettingsRequest) (_result *UpdateLogstashSettingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogstashSettingsResponse{}
	_body, _err := client.UpdateLogstashSettingsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - UpdatePipelineManagementConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdatePipelineManagementConfigResponse
func (client *Client) UpdatePipelineManagementConfigWithOptions(InstanceId *string, request *UpdatePipelineManagementConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdatePipelineManagementConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Endpoints)) {
		body["endpoints"] = request.Endpoints
	}

	if !tea.BoolValue(util.IsUnset(request.EsInstanceId)) {
		body["esInstanceId"] = request.EsInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		body["password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.PipelineIds)) {
		body["pipelineIds"] = request.PipelineIds
	}

	if !tea.BoolValue(util.IsUnset(request.PipelineManagementType)) {
		body["pipelineManagementType"] = request.PipelineManagementType
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		body["userName"] = request.UserName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePipelineManagementConfig"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipeline-management-config"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePipelineManagementConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Logstash
//
// @param request - UpdatePipelineManagementConfigRequest
//
// @return UpdatePipelineManagementConfigResponse
func (client *Client) UpdatePipelineManagementConfig(InstanceId *string, request *UpdatePipelineManagementConfigRequest) (_result *UpdatePipelineManagementConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdatePipelineManagementConfigResponse{}
	_body, _err := client.UpdatePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a pipeline of a Logstash cluster.
//
// @param request - UpdatePipelinesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdatePipelinesResponse
func (client *Client) UpdatePipelinesWithOptions(InstanceId *string, request *UpdatePipelinesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdatePipelinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Trigger)) {
		query["trigger"] = request.Trigger
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePipelines"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/pipelines"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePipelinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a pipeline of a Logstash cluster.
//
// @param request - UpdatePipelinesRequest
//
// @return UpdatePipelinesResponse
func (client *Client) UpdatePipelines(InstanceId *string, request *UpdatePipelinesRequest) (_result *UpdatePipelinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdatePipelinesResponse{}
	_body, _err := client.UpdatePipelinesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ## RequestBody
//
// | Property | Type | Required | Example | Description |
//
// | -------- | ---- | -------- | ------- | ----------- |
//
// | privateNetworkIpWhiteList | List<String> | No | ["0.0.XX.XX","10.2.XX.XX","192.168.XX.XX/25"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.
//
// You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
//
// | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.
//
// You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
//
// |  groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// |  ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// > **Notice*	- The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
//
// - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
//
// - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
//
// Description:
//
// >  In the following returned example, only the parameters in the returned data list are guaranteed to be included, and the parameters not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
//
// @param request - UpdatePrivateNetworkWhiteIpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdatePrivateNetworkWhiteIpsResponse
func (client *Client) UpdatePrivateNetworkWhiteIpsWithOptions(InstanceId *string, request *UpdatePrivateNetworkWhiteIpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdatePrivateNetworkWhiteIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ModifyMode)) {
		query["modifyMode"] = request.ModifyMode
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePrivateNetworkWhiteIps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/private-network-white-ips"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePrivateNetworkWhiteIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ## RequestBody
//
// | Property | Type | Required | Example | Description |
//
// | -------- | ---- | -------- | ------- | ----------- |
//
// | privateNetworkIpWhiteList | List<String> | No | ["0.0.XX.XX","10.2.XX.XX","192.168.XX.XX/25"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.
//
// You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
//
// | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.
//
// You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
//
// |  groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// |  ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// > **Notice*	- The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
//
// - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
//
// - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
//
// Description:
//
// >  In the following returned example, only the parameters in the returned data list are guaranteed to be included, and the parameters not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
//
// @param request - UpdatePrivateNetworkWhiteIpsRequest
//
// @return UpdatePrivateNetworkWhiteIpsResponse
func (client *Client) UpdatePrivateNetworkWhiteIps(InstanceId *string, request *UpdatePrivateNetworkWhiteIpsRequest) (_result *UpdatePrivateNetworkWhiteIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdatePrivateNetworkWhiteIpsResponse{}
	_body, _err := client.UpdatePrivateNetworkWhiteIpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UpdatePublicNetwork to open or close the public network address of the specified elasticsearch instance.
//
// Description:
//
// When you call this operation, take note of the following items:
//
// When the instance is in the activating, invalid, or inactive state, its configuration cannot be updated.
//
// @param request - UpdatePublicNetworkRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdatePublicNetworkResponse
func (client *Client) UpdatePublicNetworkWithOptions(InstanceId *string, request *UpdatePublicNetworkRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdatePublicNetworkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePublicNetwork"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/public-network"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePublicNetworkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UpdatePublicNetwork to open or close the public network address of the specified elasticsearch instance.
//
// Description:
//
// When you call this operation, take note of the following items:
//
// When the instance is in the activating, invalid, or inactive state, its configuration cannot be updated.
//
// @param request - UpdatePublicNetworkRequest
//
// @return UpdatePublicNetworkResponse
func (client *Client) UpdatePublicNetwork(InstanceId *string, request *UpdatePublicNetworkRequest) (_result *UpdatePublicNetworkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdatePublicNetworkResponse{}
	_body, _err := client.UpdatePublicNetworkWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ## RequestBody
//
// | Property | Type | Required | Example | Description |
//
// | -------- | ---- | -------- | ------- | ----------- |
//
// | publicIpWhitelist | List<String> | Yes | ["0.0.0.0/0","0.0.0.0/1"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.
//
// You cannot configure both publicIpWhitelist and whiteIpGroup. |
//
// | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.
//
// You cannot configure both publicIpWhitelist and whiteIpGroup. |
//
// |  groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// |  ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// > **Notice*	- The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
//
// - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
//
// - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
//
// Description:
//
// >  In the following example, only the parameters in the returned data list are guaranteed to be included. The parameters that are not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
//
// @param request - UpdatePublicWhiteIpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdatePublicWhiteIpsResponse
func (client *Client) UpdatePublicWhiteIpsWithOptions(InstanceId *string, request *UpdatePublicWhiteIpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdatePublicWhiteIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ModifyMode)) {
		query["modifyMode"] = request.ModifyMode
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePublicWhiteIps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/public-white-ips"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePublicWhiteIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ## RequestBody
//
// | Property | Type | Required | Example | Description |
//
// | -------- | ---- | -------- | ------- | ----------- |
//
// | publicIpWhitelist | List<String> | Yes | ["0.0.0.0/0","0.0.0.0/1"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.
//
// You cannot configure both publicIpWhitelist and whiteIpGroup. |
//
// | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.
//
// You cannot configure both publicIpWhitelist and whiteIpGroup. |
//
// |  groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// |  ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
//
// > **Notice*	- The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
//
// - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
//
// - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
//
// Description:
//
// >  In the following example, only the parameters in the returned data list are guaranteed to be included. The parameters that are not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
//
// @param request - UpdatePublicWhiteIpsRequest
//
// @return UpdatePublicWhiteIpsResponse
func (client *Client) UpdatePublicWhiteIps(InstanceId *string, request *UpdatePublicWhiteIpsRequest) (_result *UpdatePublicWhiteIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdatePublicWhiteIpsResponse{}
	_body, _err := client.UpdatePublicWhiteIpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateReadWritePolicyRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateReadWritePolicyResponse
func (client *Client) UpdateReadWritePolicyWithOptions(InstanceId *string, request *UpdateReadWritePolicyRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateReadWritePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateReadWritePolicy"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/update-read-write-policy"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateReadWritePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// @param request - UpdateReadWritePolicyRequest
//
// @return UpdateReadWritePolicyResponse
func (client *Client) UpdateReadWritePolicy(InstanceId *string, request *UpdateReadWritePolicyRequest) (_result *UpdateReadWritePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateReadWritePolicyResponse{}
	_body, _err := client.UpdateReadWritePolicyWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Call UpdateSnapshotSetting to update the data backup configuration of the specified instance.
//
// @param request - UpdateSnapshotSettingRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateSnapshotSettingResponse
func (client *Client) UpdateSnapshotSettingWithOptions(InstanceId *string, request *UpdateSnapshotSettingRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateSnapshotSettingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSnapshotSetting"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/snapshot-setting"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSnapshotSettingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Call UpdateSnapshotSetting to update the data backup configuration of the specified instance.
//
// @param request - UpdateSnapshotSettingRequest
//
// @return UpdateSnapshotSettingResponse
func (client *Client) UpdateSnapshotSetting(InstanceId *string, request *UpdateSnapshotSettingRequest) (_result *UpdateSnapshotSettingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateSnapshotSettingResponse{}
	_body, _err := client.UpdateSnapshotSettingWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the synonym dictionaries of an Elasticsearch cluster.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateSynonymsDictsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateSynonymsDictsResponse
func (client *Client) UpdateSynonymsDictsWithOptions(InstanceId *string, request *UpdateSynonymsDictsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateSynonymsDictsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSynonymsDicts"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/synonymsDict"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSynonymsDictsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the synonym dictionaries of an Elasticsearch cluster.
//
// Description:
//
// Before you call this operation, take note of the following items:
//
// 	- If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
//
// 	- If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
//
// @param request - UpdateSynonymsDictsRequest
//
// @return UpdateSynonymsDictsResponse
func (client *Client) UpdateSynonymsDicts(InstanceId *string, request *UpdateSynonymsDictsRequest) (_result *UpdateSynonymsDictsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateSynonymsDictsResponse{}
	_body, _err := client.UpdateSynonymsDictsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - UpdateTemplateRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateTemplateResponse
func (client *Client) UpdateTemplateWithOptions(InstanceId *string, TemplateName *string, request *UpdateTemplateRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTemplate"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/templates/" + tea.StringValue(openapiutil.GetEncodeParam(TemplateName))),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - UpdateTemplateRequest
//
// @return UpdateTemplateResponse
func (client *Client) UpdateTemplate(InstanceId *string, TemplateName *string, request *UpdateTemplateRequest) (_result *UpdateTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateTemplateResponse{}
	_body, _err := client.UpdateTemplateWithOptions(InstanceId, TemplateName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
//
// 	- If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
//
// 	- If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
//
// 	- If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
//
// Description:
//
// > For more information about the parameters displayed in the following sample code but not provided in the preceding tables, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force your program to obtain these parameters.
//
// @param request - UpdateWhiteIpsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateWhiteIpsResponse
func (client *Client) UpdateWhiteIpsWithOptions(InstanceId *string, request *UpdateWhiteIpsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateWhiteIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ModifyMode)) {
		query["modifyMode"] = request.ModifyMode
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EsIPWhitelist)) {
		body["esIPWhitelist"] = request.EsIPWhitelist
	}

	if !tea.BoolValue(util.IsUnset(request.WhiteIpGroup)) {
		body["whiteIpGroup"] = request.WhiteIpGroup
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateWhiteIps"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/white-ips"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateWhiteIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
//
// 	- If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
//
// 	- If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
//
// 	- If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
//
// Description:
//
// > For more information about the parameters displayed in the following sample code but not provided in the preceding tables, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force your program to obtain these parameters.
//
// @param request - UpdateWhiteIpsRequest
//
// @return UpdateWhiteIpsResponse
func (client *Client) UpdateWhiteIps(InstanceId *string, request *UpdateWhiteIpsRequest) (_result *UpdateWhiteIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateWhiteIpsResponse{}
	_body, _err := client.UpdateWhiteIpsWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// LogstashX-Pack
//
// @param request - UpdateXpackMonitorConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateXpackMonitorConfigResponse
func (client *Client) UpdateXpackMonitorConfigWithOptions(InstanceId *string, request *UpdateXpackMonitorConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateXpackMonitorConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		body["enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.Endpoints)) {
		body["endpoints"] = request.Endpoints
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		body["password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		body["userName"] = request.UserName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateXpackMonitorConfig"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/xpack-monitor-config"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateXpackMonitorConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// LogstashX-Pack
//
// @param request - UpdateXpackMonitorConfigRequest
//
// @return UpdateXpackMonitorConfigResponse
func (client *Client) UpdateXpackMonitorConfig(InstanceId *string, request *UpdateXpackMonitorConfigRequest) (_result *UpdateXpackMonitorConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateXpackMonitorConfigResponse{}
	_body, _err := client.UpdateXpackMonitorConfigWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
//
// @param request - UpgradeEngineVersionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpgradeEngineVersionResponse
func (client *Client) UpgradeEngineVersionWithOptions(InstanceId *string, request *UpgradeEngineVersionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpgradeEngineVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["dryRun"] = request.DryRun
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Plugins)) {
		body["plugins"] = request.Plugins
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		body["type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.Version)) {
		body["version"] = request.Version
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeEngineVersion"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/actions/upgrade-version"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeEngineVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// ES
//
// Description:
//
// 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
//
// @param request - UpgradeEngineVersionRequest
//
// @return UpgradeEngineVersionResponse
func (client *Client) UpgradeEngineVersion(InstanceId *string, request *UpgradeEngineVersionRequest) (_result *UpgradeEngineVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpgradeEngineVersionResponse{}
	_body, _err := client.UpgradeEngineVersionWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Tests the connectivity between a Logstash cluster and its associated Elasticsearch cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
//
// Description:
//
// > Before you enable the X-Pack Monitoring feature for a Logstash cluster, you must associate the Logstash cluster with an Elasticsearch cluster. This way, you can view the monitoring data of the Logstash cluster in the Kibana console of the Elasticsearch cluster.
//
// @param request - ValidateConnectionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ValidateConnectionResponse
func (client *Client) ValidateConnectionWithOptions(InstanceId *string, request *ValidateConnectionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ValidateConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ValidateConnection"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/logstashes/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/validate-connection"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ValidateConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Tests the connectivity between a Logstash cluster and its associated Elasticsearch cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
//
// Description:
//
// > Before you enable the X-Pack Monitoring feature for a Logstash cluster, you must associate the Logstash cluster with an Elasticsearch cluster. This way, you can view the monitoring data of the Logstash cluster in the Kibana console of the Elasticsearch cluster.
//
// @param request - ValidateConnectionRequest
//
// @return ValidateConnectionResponse
func (client *Client) ValidateConnection(InstanceId *string, request *ValidateConnectionRequest) (_result *ValidateConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ValidateConnectionResponse{}
	_body, _err := client.ValidateConnectionWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ValidateShrinkNodesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ValidateShrinkNodesResponse
func (client *Client) ValidateShrinkNodesWithOptions(InstanceId *string, request *ValidateShrinkNodesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ValidateShrinkNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreStatus)) {
		query["ignoreStatus"] = request.IgnoreStatus
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["nodeType"] = request.NodeType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    util.ToArray(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("ValidateShrinkNodes"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/validate-shrink-nodes"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ValidateShrinkNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ValidateShrinkNodesRequest
//
// @return ValidateShrinkNodesResponse
func (client *Client) ValidateShrinkNodes(InstanceId *string, request *ValidateShrinkNodesRequest) (_result *ValidateShrinkNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ValidateShrinkNodesResponse{}
	_body, _err := client.ValidateShrinkNodesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - ValidateSlrPermissionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ValidateSlrPermissionResponse
func (client *Client) ValidateSlrPermissionWithOptions(request *ValidateSlrPermissionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ValidateSlrPermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Rolename)) {
		query["rolename"] = request.Rolename
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ValidateSlrPermission"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/user/servicerolepermission"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ValidateSlrPermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// @param request - ValidateSlrPermissionRequest
//
// @return ValidateSlrPermissionResponse
func (client *Client) ValidateSlrPermission(request *ValidateSlrPermissionRequest) (_result *ValidateSlrPermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ValidateSlrPermissionResponse{}
	_body, _err := client.ValidateSlrPermissionWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ValidateTransferableNodesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ValidateTransferableNodesResponse
func (client *Client) ValidateTransferableNodesWithOptions(InstanceId *string, request *ValidateTransferableNodesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ValidateTransferableNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["nodeType"] = request.NodeType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    util.ToArray(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("ValidateTransferableNodes"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances/" + tea.StringValue(openapiutil.GetEncodeParam(InstanceId)) + "/validate-transfer-nodes"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ValidateTransferableNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 
//
// @param request - ValidateTransferableNodesRequest
//
// @return ValidateTransferableNodesResponse
func (client *Client) ValidateTransferableNodes(InstanceId *string, request *ValidateTransferableNodesRequest) (_result *ValidateTransferableNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ValidateTransferableNodesResponse{}
	_body, _err := client.ValidateTransferableNodesWithOptions(InstanceId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// The configurations of dedicated master nodes.
//
// Description:
//
// The configurations of warm nodes.
//
// @param request - CreateInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateInstanceResponse
func (client *Client) CreateInstanceWithOptions(request *CreateInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["clientToken"] = request.ClientToken
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientNodeConfiguration)) {
		body["clientNodeConfiguration"] = request.ClientNodeConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ElasticDataNodeConfiguration)) {
		body["elasticDataNodeConfiguration"] = request.ElasticDataNodeConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.EsAdminPassword)) {
		body["esAdminPassword"] = request.EsAdminPassword
	}

	if !tea.BoolValue(util.IsUnset(request.EsVersion)) {
		body["esVersion"] = request.EsVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceCategory)) {
		body["instanceCategory"] = request.InstanceCategory
	}

	if !tea.BoolValue(util.IsUnset(request.KibanaConfiguration)) {
		body["kibanaConfiguration"] = request.KibanaConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.MasterConfiguration)) {
		body["masterConfiguration"] = request.MasterConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkConfig)) {
		body["networkConfig"] = request.NetworkConfig
	}

	if !tea.BoolValue(util.IsUnset(request.NodeAmount)) {
		body["nodeAmount"] = request.NodeAmount
	}

	if !tea.BoolValue(util.IsUnset(request.NodeSpec)) {
		body["nodeSpec"] = request.NodeSpec
	}

	if !tea.BoolValue(util.IsUnset(request.PaymentInfo)) {
		body["paymentInfo"] = request.PaymentInfo
	}

	if !tea.BoolValue(util.IsUnset(request.PaymentType)) {
		body["paymentType"] = request.PaymentType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		body["resourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		body["tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.WarmNodeConfiguration)) {
		body["warmNodeConfiguration"] = request.WarmNodeConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneCount)) {
		body["zoneCount"] = request.ZoneCount
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("createInstance"),
		Version:     tea.String("2017-06-13"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/openapi/instances"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// The configurations of dedicated master nodes.
//
// Description:
//
// The configurations of warm nodes.
//
// @param request - CreateInstanceRequest
//
// @return CreateInstanceResponse
func (client *Client) CreateInstance(request *CreateInstanceRequest) (_result *CreateInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateInstanceResponse{}
	_body, _err := client.CreateInstanceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
