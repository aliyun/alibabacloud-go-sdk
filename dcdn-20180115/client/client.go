// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddDcdnDomainRequest struct {
	// The URL that is used for health checks.
	CheckUrl *string `json:"CheckUrl,omitempty" xml:"CheckUrl,omitempty"`
	// The domain name that you want to add. You can specify only one domain name in each request.
	//
	// Wildcard domain names are supported. A wildcard domain name must start with a period (.), such as .example.com.
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. If you do not specify a value for this parameter, the system automatically assigns the ID of the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Scene           *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The acceleration region. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: outside the Chinese mainland
	// *   **global**: global
	//
	// Default value: **domestic**.
	Scope         *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The information about the tags.
	Tag []*AddDcdnDomainRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The top-level domain.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s AddDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *AddDcdnDomainRequest) SetCheckUrl(v string) *AddDcdnDomainRequest {
	s.CheckUrl = &v
	return s
}

func (s *AddDcdnDomainRequest) SetDomainName(v string) *AddDcdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *AddDcdnDomainRequest) SetFunctionType(v string) *AddDcdnDomainRequest {
	s.FunctionType = &v
	return s
}

func (s *AddDcdnDomainRequest) SetOwnerAccount(v string) *AddDcdnDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddDcdnDomainRequest) SetOwnerId(v int64) *AddDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *AddDcdnDomainRequest) SetResourceGroupId(v string) *AddDcdnDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddDcdnDomainRequest) SetScene(v string) *AddDcdnDomainRequest {
	s.Scene = &v
	return s
}

func (s *AddDcdnDomainRequest) SetScope(v string) *AddDcdnDomainRequest {
	s.Scope = &v
	return s
}

func (s *AddDcdnDomainRequest) SetSecurityToken(v string) *AddDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *AddDcdnDomainRequest) SetSources(v string) *AddDcdnDomainRequest {
	s.Sources = &v
	return s
}

func (s *AddDcdnDomainRequest) SetTag(v []*AddDcdnDomainRequestTag) *AddDcdnDomainRequest {
	s.Tag = v
	return s
}

func (s *AddDcdnDomainRequest) SetTopLevelDomain(v string) *AddDcdnDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type AddDcdnDomainRequestTag struct {
	// The key of a tag. Valid values of N: **1 to 20**.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of a tag. Valid values of N: **1 to 20**.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddDcdnDomainRequestTag) String() string {
	return tea.Prettify(s)
}

func (s AddDcdnDomainRequestTag) GoString() string {
	return s.String()
}

func (s *AddDcdnDomainRequestTag) SetKey(v string) *AddDcdnDomainRequestTag {
	s.Key = &v
	return s
}

func (s *AddDcdnDomainRequestTag) SetValue(v string) *AddDcdnDomainRequestTag {
	s.Value = &v
	return s
}

type AddDcdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddDcdnDomainResponseBody) SetRequestId(v string) *AddDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type AddDcdnDomainResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *AddDcdnDomainResponse) SetHeaders(v map[string]*string) *AddDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *AddDcdnDomainResponse) SetStatusCode(v int32) *AddDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDcdnDomainResponse) SetBody(v *AddDcdnDomainResponseBody) *AddDcdnDomainResponse {
	s.Body = v
	return s
}

type AddDcdnIpaDomainRequest struct {
	// The URL that is used for health checks.
	CheckUrl *string `json:"CheckUrl,omitempty" xml:"CheckUrl,omitempty"`
	// The domain name to be added to IPA.
	//
	// A wildcard domain that starts with a period (.) is supported, such as .example.com.
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The protocol. Valid values:
	//
	// *   **udp**
	// *   **tcp**
	//
	// **
	//
	// **Description** For example: `{"protocol":"udp"}`.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The ID of the resource group. If you do not specify a value for this parameter, the system automatically assigns the ID of the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The acceleration region. Default value: domestic. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: outside the Chinese mainland
	// *   **global**: global
	Scope         *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The top-level domain.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s AddDcdnIpaDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDcdnIpaDomainRequest) GoString() string {
	return s.String()
}

func (s *AddDcdnIpaDomainRequest) SetCheckUrl(v string) *AddDcdnIpaDomainRequest {
	s.CheckUrl = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetDomainName(v string) *AddDcdnIpaDomainRequest {
	s.DomainName = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetOwnerAccount(v string) *AddDcdnIpaDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetOwnerId(v int64) *AddDcdnIpaDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetProtocol(v string) *AddDcdnIpaDomainRequest {
	s.Protocol = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetResourceGroupId(v string) *AddDcdnIpaDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetScope(v string) *AddDcdnIpaDomainRequest {
	s.Scope = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetSecurityToken(v string) *AddDcdnIpaDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetSources(v string) *AddDcdnIpaDomainRequest {
	s.Sources = &v
	return s
}

func (s *AddDcdnIpaDomainRequest) SetTopLevelDomain(v string) *AddDcdnIpaDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type AddDcdnIpaDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDcdnIpaDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDcdnIpaDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddDcdnIpaDomainResponseBody) SetRequestId(v string) *AddDcdnIpaDomainResponseBody {
	s.RequestId = &v
	return s
}

type AddDcdnIpaDomainResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDcdnIpaDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDcdnIpaDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDcdnIpaDomainResponse) GoString() string {
	return s.String()
}

func (s *AddDcdnIpaDomainResponse) SetHeaders(v map[string]*string) *AddDcdnIpaDomainResponse {
	s.Headers = v
	return s
}

func (s *AddDcdnIpaDomainResponse) SetStatusCode(v int32) *AddDcdnIpaDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDcdnIpaDomainResponse) SetBody(v *AddDcdnIpaDomainResponseBody) *AddDcdnIpaDomainResponse {
	s.Body = v
	return s
}

type BatchAddDcdnDomainRequest struct {
	// The URL that is used for health checks.
	CheckUrl *string `json:"CheckUrl,omitempty" xml:"CheckUrl,omitempty"`
	// You can add up to 20 domain names to DCDN for each of your Alibaba Cloud account. If you specify multiple domain names, separate them with commas (,).
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource group. If you do not specify a value for this parameter, the system uses the ID of the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The acceleration region. Default value: domestic. Valid values:
	//
	// *   domestic: Chinese mainland
	// *   overseas: global (excluding the Chinese mainland)
	// *   global: global
	Scope         *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The top-level domain.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s BatchAddDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchAddDcdnDomainRequest) SetCheckUrl(v string) *BatchAddDcdnDomainRequest {
	s.CheckUrl = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetDomainName(v string) *BatchAddDcdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetOwnerAccount(v string) *BatchAddDcdnDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetOwnerId(v int64) *BatchAddDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetResourceGroupId(v string) *BatchAddDcdnDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetScope(v string) *BatchAddDcdnDomainRequest {
	s.Scope = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetSecurityToken(v string) *BatchAddDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetSources(v string) *BatchAddDcdnDomainRequest {
	s.Sources = &v
	return s
}

func (s *BatchAddDcdnDomainRequest) SetTopLevelDomain(v string) *BatchAddDcdnDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type BatchAddDcdnDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchAddDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchAddDcdnDomainResponseBody) SetRequestId(v string) *BatchAddDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchAddDcdnDomainResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchAddDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchAddDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchAddDcdnDomainResponse) SetHeaders(v map[string]*string) *BatchAddDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchAddDcdnDomainResponse) SetStatusCode(v int32) *BatchAddDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchAddDcdnDomainResponse) SetBody(v *BatchAddDcdnDomainResponseBody) *BatchAddDcdnDomainResponse {
	s.Body = v
	return s
}

type BatchCreateDcdnWafRulesRequest struct {
	// The configurations of the protection rule.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// ## Description of the RuleConfigs parameter
	//
	// - RuleConfigs is a list slice, in which each struct represents a rule.
	// - The fields in the RuleConfigs parameter vary based on the type of the protection policy whose ID is specified by the PolicyId parameter.
	//
	//
	// ## Scenario 1:web RegEx protection (waf_group)
	//
	// | Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | status | String | No | on | Specifies whether to enable the protection rule. Valid values: on and off. Default value: on. |
	// | action | String | Yes | block | Specifies the action of the rule. Valid values: block and monitor. |
	// Sample code for waf_group
	//
	// ```
	// // You can configure only one rule for a protection policy of the waf_group type.
	// [
	//   {
	//     "status": "on",
	//     "action": "block"
	//   }
	// ]
	// ```
	//
	// ## Scenario 2: custom rules (custom_acl)
	//
	// | Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | name | string | Yes | acl_1 | The name of the protection rule. The name can be up to 64 characters in length and can contain letters, digits, and underscores (_). |
	// | status | string | No | on | Valid values: on and off. Default value: on. |
	// | conditions | Condition | Yes | [ {"key": "URI", "subKey": "","opValue": "contain",  "values": "/login.php" }] | The trigger condition. For more information, see **Table 1 Fields in the Conditions parameter**. |
	// | ccStatus | string | Yes | off | Specifies whether to enable rate limiting. Valid values: on and off. |
	// | rateLimit | RateLimit | No | { "target": "Header", "subKey": "User-Agent", "interval": 5, "threshold": 2, "ttl": 1800} | The rules of rate limiting. If you set ccStatus to on, you must configure this parameter. For more information, see **Table 2 Fields in the rateLimit parameter**. |
	// | effect | string | No | service | The effective scope of the rate limiting blacklist. If you set ccStatus to on, you must configure this parameter. Valid values: rule (takes effect for the current rule) and service (takes effect globally). |
	// | action | string | Yes | deny | The action of the rule. Valid values: deny, js (JavaScript verification), and monitor. |
	// Table 1 Fields in the Conditions parameter
	//
	// | Field | Type | Required | Example | Description |
	// | ----- | ---- | -------- | ------- | ----------- |
	// | Key | string | Yes | Query String Parameter | The match field. For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// | subKey | string | No | action | The match subfield. For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// | opValue | String | Yes | eq | The logical symbol. For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// | values | String | No | js | The match content. Separate multiple values with commas (,). For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// Table 2 Fields in the rateLimit parameter
	//
	// | Field | Type | Required | Example | Description |
	// | ----- | ---- | -------- | ------- | ----------- |
	// | target | string | Yes | Header | The statistical field of rate limiting. IP: calculates the frequency at which requests are sent from a specified IP address. Header: calculates the frequency of requests that contain the specified header. Query String Parameter: calculates the frequency of requests that contain the specified parameter. Cookie Name: calculates the frequency of requests that contain the specified cookie. Session: calculates the frequency of requests that are transmitted over a specified session. |
	// | subKey | string | No | User-Agent | The subfield of the target field. If you set target to Header, Query String Parameter, or Cookie Name, you must configure subKey. |
	// | Interval | Integer | Yes | 5 | The statistical interval. Valid values: 5 to 1800. Unit: seconds. |
	// | threshold | Integer | Yes | 2 | The trigger threshold of rate limiting. Valid values: 2 to 500000. Unit: requests. |
	// | ttl | Integer | Yes | 1800 | The validity period of the blacklist. Valid values: 60 to 86400. Unit: seconds. |
	// | status | RateLimitStatus | No | {"code": "404", "ratio": 10} | The information about the HTTP status code. For more information, see **Table 3 Fields in the RateLimitStatus parameter**. |
	// Table 3 Fields in the RateLimitStatus parameter
	//
	// | Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | codet | string | Yes | 404 | The HTTP status code returned. |
	// | ratio | Integer | No | 10 | The percentage of HTTP status codes. Valid values: 1 to 100. You can configure only one of the ratio and count fields. |
	// | count | Integer | No | 10 | The number of times that the HTTP status code that was returned. Valid values: 2 to 50000. You can configure only one of the ratio and count fields. |
	// Sample code for custom_acl
	//
	// ```
	// [
	//   // Access control
	//   {
	//     "name": "acl_1",
	//     "status": "off",
	//     "conditions":
	//     [
	//       {
	//         "key": "Query String Parameter",
	//         "subKey": "action",
	//         "opValue": "eq",
	//         "values": "js"
	//       }
	//     ],
	//     "ccStatus": "off",
	//     "action": "js"
	//   },
	//   // Rate limiting
	//   {
	//     "name": "cc_1",
	//     "status": "on",
	//   	"conditions":
	//     [
	//       {
	//         "key": "URI",
	//         "subKey": "",
	//         "opValue": "contain",
	//         "values": "/login.php"
	//       },
	//       {
	//         "key": "IP",
	//         "subKey": "",
	//         "opValue": "ip-contain",
	//         "values": "192.168.0.1/24"
	//       }
	//     ],
	//     "ccStatus": "on",
	//     "ratelimit":
	//     {
	//       "target": "Header",
	//       "subKey": "User-Agent",
	//       "interval": 5,
	//       "threshold": 2,
	//       "ttl": 1800,
	//       "status":
	//       {
	//         "code": "404",
	//         "ratio": 10
	//       }
	//     },
	//     "effect": "service",
	//     "action": "deny"
	//   }
	// ]
	// ```
	//
	// ## Scenario 3: whitelist (whitelist)
	//
	// | Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | name | string | Yes | on | The name of the protection rule. The name can be up to 64 characters in length and can contain letters, digits, and underscores (_). |
	// | status | string | No | on | Specifies whether to enable the protection rule. Default value: on. Valid values: on and off. off: disables the multiplexing feature for ports. |
	// | conditions | Condition | Yes | [{ "key": "Http-Method","subKey": "","opValue": "match-one", "values": "GET,POST,DELETE" }] | The trigger condition of the rule. For more information, see **Table 1 Fields in the Conditions parameter**. |
	// | tags | String | Yes | [ "waf_group",  "custom_acl"] | The types of the protection policies. |
	// | regularTypes | String | No | [  [ "sqli", "xss","code_exec", "crlf", "lfilei",  "rfilei", "webshell","vvip", "other"] | The type of the regular expression. If the value of the tags field contains waf_group, you can specify this field. Valid values: ["sqli", "xss", "code_exec", "crlf", "lfilei", "rfilei", "webshell", "vvip", and "other"]. |
	// | regularRules | String | No | [   "100001", "100002", "100003"] | The regular expression. If the value of the tags field contains waf_group, you can specify this field. You can configure only regularRules or regularTypes. The value must be a string that consists of six digits. |
	// Sample code for whitelist:
	//
	// ```
	// [
	//   // Skip all protection policies.
	//   {
	//     "name": "wl_all",
	//     "status": "on",
	//     "conditions":
	//     [
	//       {
	//         "key": "Http-Method",
	//         "subKey": "",
	//         "opValue": "match-one",
	//         "values": "GET,POST,DELETE"
	//       }
	//     ],
	//     "tags":
	//     [
	//       "waf_group",
	//       "custom_acl",
	//       "ip_blacklist",
	//       "region_block"
	//     ]
	//   },
	//   // Skip the ID of the rule that is specified in waf_group.
	//   {
	//     "name": "wl_waf_id",
	//     "status": "off",
	//     "conditions":
	//     [
	//       {
	//         "key": "Cookie Name",
	//         "subKey": "cdn-sec",
	//         "opValue": "prefix-match",
	//         "values": "a7sdsa9dsa8d8sa"
	//       },
	//       {
	//         "key": "Referer",
	//         "subKey": "",
	//         "opValue": "none",
	//         "values": ""
	//       }
	//     ],
	//     "tags":
	//     [
	//       "waf_group"
	//     ],
	//     "regularRules":
	//     [
	//       "100001",
	//       "100002",
	//       "100003"
	//     ]
	//   },
	//   {
	//   // Skip the type of rules that is specified in waf_group.
	//     "name": "wl_waf_type",
	//     "status": "on",
	//     "conditions":
	//     [
	//       {
	//         "key": "Query String",
	//         "subKey": "",
	//         "opValue": "exists",
	//         "values": ""
	//       }
	//     ],
	//     "tags":
	//     [
	//       "waf_group"
	//     ],
	//     "regularTypes":
	//     [
	//       "sqli",
	//       "xss",
	//       "code_exec",
	//       "crlf",
	//       "lfilei",
	//       "rfilei",
	//       "webshell",
	//       "vvip",
	//       "other"
	//     ]
	//   },
	//   // Skip custom rules.
	//   {
	//     "name": "wl_custom_acl",
	//     "status": "on",
	//     "conditions":
	//     [
	//       {
	//         "key": "Http-Method",
	//         "subKey": "",
	//         "opValue": "match-one",
	//         "values": "GET,POST,DELETE"
	//       }
	//     ],
	//     "tags":
	//     [
	//       "custom_acl"
	//     ]
	//   },
	//   // Skip IP addresses in the blacklist.
	//   {
	//     "name": "wl_ip_blacklist",
	//     "status": "on",
	//     "conditions":
	//     [
	//       {
	//         "key": "Http-Method",
	//         "subKey": "",
	//         "opValue": "match-one",
	//         "values": "GET,POST,DELETE"
	//       }
	//     ],
	//     "tags":
	//     [
	//       "ip_blacklist"
	//     ]
	//   },
	//   // Skip the region blocking
	//   {
	//     "name": "wl_region_block",
	//     "status": "on",
	//     "conditions":
	//     [
	//       {
	//         "key": "Http-Method",
	//         "subKey": "",
	//         "opValue": "match-one",
	//         "values": "GET,POST,DELETE"
	//       }
	//     ],
	//     "tags":
	//     [
	//       "region_block"
	//     ]
	//   }
	// ]
	// ```
	//
	// ## Scenario 4:IP address blacklist (ip_blacklist)
	//
	// | Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | name | string | Yes | ipblacklist | The name of the protection rule. The name can be up to 64 characters in length and can contain letters, digits, and underscores (_). |
	// | status | string | No | on | Specifies whether to enable the protection rule. Valid values: on and off. Default value: on. |
	// | remoteAddr | []String | Yes | ["192.168.0.1","10.10.10.10/24","::1","abcd::abcd","BCDE::BCDE"] | Filter by IP address. For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// | action | string | Yes | deny | The action of the rule. Valid values: deny and monitor. |
	// Sample code for ipblacklist:
	//
	// ```
	// [
	//     {
	//     "name": "ipblacklist",
	//     "status": "on",
	//     "remoteAddr": ["192.168.0.1","10.10.10.10/24","::1","abcd::abcd","BCDE::BCDE"],
	//     "action": "deny"
	//   }
	// ]
	// ```
	//
	// ## Protection scenario 5: region blocking (region_block)
	//
	// | Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | status | string | No | on | Specifies whether to enable the protection rule. Valid values: on and off. Default value: on. |
	// | cnRegionList | string | No | 110000,TW,MO | The blocked regions in the Chinese mainland, separated by commas (,). For more information about the regions that can be blocked, see [DescribeDcdnWafGeoInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/describe-dcdn-waf-geo-info). |
	// | otherRegionList | string | No | JP,GB | Blocked regions outside the Chinese mainland, separated by commas (,). For more information about the regions that can be blocked, see [DescribeDcdnWafGeoInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/describe-dcdn-waf-geo-info). |
	// | action | string | Yes | deny | The action of the rule. Valid values: deny and monitor. |
	// >  You must specify at least one of the ProcessId or ProcessName parameters.  Sample code for region_block:
	//
	// ```
	// [
	//     {
	//     "status": "on",
	//     "cnRegionList": "110000,TW,MO",
	//     "otherRegionList": "JP,GB",
	//     "action": "deny"
	//   }
	// ]
	// ```
	//
	// ## Scenario 6: Bot management (bot)
	//
	// **Rule template**All rules have the four parameters in the following table. For more information, see the rule classification.
	//
	// | Parameter | Type | Required | Description |
	// | --------- | ---- | -------- | ----------- |
	// | type | String | Yes | The type of the rule. For more information, see the rule classification. |
	// | status | String | Yes | The status of the rule. Valid values: on and off. |
	// | config | TargetType | No | Rule configuration. For more information, see Rule classification. |
	// | action | String | No | Rule actions. For more information, see Rule classification. |
	// **Rule category 1: protection target type**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | target_type | The type of the rule. Set the value to target_type. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Set the value to on. |
	// | config | TargetType | No | {"target":"app"} | The configuration of the rule. Format:
	//
	// (Required) target: the type of the protection target. Valid values: web (web pages and browsers) and app (apps). |
	// | action | String | No | Empty | The action of the rule, which is not involved here. Leave the value empty. |
	// Configuration example of the protection target type:
	//
	// ```
	// [
	//   {
	//     "type":"target_type",
	//     "status":"on",
	//     "config":{"target":"app"},
	//     "action":""
	//   }
	// ]
	// ```
	// **Rule classification 2: Web SDK integration**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | web_sdk | The type of the rule. Set the value to web_sdk. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Set the value to on. |
	// | config | WebSdk | No | {"mode":"automatic","crossDomain":"example.com"} | The configuration of the rule. Format:
	//
	// (Required) mode : the integration mode of the Web SDK. Valid values: automatic and manual.
	//
	// (Optional) crossDomain: cross-domain resource calling. This parameter takes effect only when the value of mode is automatic. |
	// | action | String | No | Empty | The action of the rule, which is not involved here. Leave the value empty. |
	// Configuration example of Web SDK integration:
	//
	// ```
	// [
	//   {
	//     "type":"web_sdk",
	//     "status":"on",
	//     "config":{"mode":"automatic","crossDomain":"example.com"},
	//     "action":""
	//   }
	// ]
	// ```
	// **Rule classification 3: protection target characteristics**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | traffic_feature | The type of the rule. Set the value to traffic_feature. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Set the value to on. |
	// | config | TrafficFeature | Yes | {"conditions":[{"key":"Header","subKey":"User-Agent","opValue":"contain","values":"Chrome"},{"key":"IP","subKey":"","opValue":"ip-contain","values":"192.168.0.1/24"}]} | The configuration of the rule. For more information, see **condition**. |
	// | action | String | No | Empty | The action of the rule, which is not involved here. Leave the value empty. |
	// **condition** (match condition)
	//
	// | Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | key | String | Yes | Header | The match field. For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// | subKey | String | No | User-Agent | The match subfield. For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// | opValue | String | Yes | contain | The operator. For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// | values | String | No | Chrome | The match content. Separate multiple values with commas (,). For more information, see [DescribeDcdnWafFilterInfo](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/obtain-the-matching-conditions-of-custom-protection-rules). |
	// Configuration example of protection target characteristics:
	//
	// ```
	// [
	//   {
	//     "type":"traffic_feature",
	//     "status":"on",
	//     "config":{"conditions":[{"key":"Header","subKey":"User-Agent","opValue":"contain","values":"Chrome"},{"key":"IP","subKey":"","opValue":"ip-contain","values":"192.168.0.1/24"}]},
	//     "action":""
	//   }
	// ]
	// ```
	// **Rule classification 4: legitimate Bot management**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | intelligence_crawler | The type of the rule. Set the value to intelligence_crawler. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Set the value to on. |
	// | config | IntelligenceCrawler | No | {"name":"intelligence_crawler_baidu"} | The configuration of the rule. For more information, see **name (spider whitelist)**. |
	// | action | String | Yes | bypass | The action of the rule. Set the value to bypass. |
	// **name (spider whitelist)**| Value | Description |
	// | ----- | ----------- |
	// | intelligence_crawler_all | Whitelist for authorized search engines, such as Google, Bing, Baidu, Sogou, 360, and Yandex. |
	// | intelligence_crawler_baidu | Baidu spider whitelist |
	// | intelligence_crawler_sogou | Sogou spider whitelist |
	// | intelligence_crawler_360 | 360 spider whitelist |
	// | intelligence_crawler_google | Google spider whitelist |
	// | intelligence_crawler_bing | Bing spider whitelist |
	// | intelligence_crawler_yandex | Yandex spider whitelist |
	// Configuration example of legitimate Bot management:
	//
	// ```
	// [
	//   {
	//     "type":"intelligence_crawler",
	//     "status":"on",
	//     "config":{"name":"intelligence_crawler_baidu"},
	//     "action":"bypass"
	//   },
	//   {
	//     "type":"intelligence_crawler",
	//     "status":"on",
	//     "config":{"name":"intelligence_crawler_google"},
	//     "action":"bypass"
	//   }
	// ]
	// ```
	// **Rule classification 5: script-based Bot block (JavaScript)**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | js | The type of the rule. Set the value to js. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | Js | No | Empty | The configuration of the rule, which is not involved here. Leave the value empty. |
	// | action | String | Yes | js | The action of the rule. Set the value to js (JavaScript verification). |
	// Configuration example of script-based Bot block (JavaScript)
	//
	// ```
	// [
	//   {
	//     "type":"js",
	//     "status":"on",
	//     "config":{},
	//     "action":"js"
	//   }
	// ]
	// ```
	// **Rule classification 6: advanced Bot defense (dynamic token-based authentication)**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | sigchl | The type of the rule. Set the value to sigchl. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | Sigchl | No | {"sigchl":["sig","replay","driver"]} | The configuration of the rule. Format:
	//
	// (Required) sigchl : signature-based verification for request data. Valid values: sig (signature verification exception),replay (signature timestamp exception), and driver(WebDriver attack). |
	// | action | String | Yes | sigchl | The action of the rule. Set the value to sigchl (block). |
	// Configuration example of advanced Bot defense (dynamic token-based authentication):
	//
	// ```
	// [
	//   {
	//     "type":"sigchl",
	//     "status":"on",
	//     "config":{"sigchl":["sig","replay","driver"]},
	//     "action":"sigchl"
	//   }
	// ]
	// ```
	// **Rule classification 7: intelligent protection**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | algorithm | The type of the rule. Set the value to algorithm. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | Algorithm | No | Empty | The configuration of the rule, which is not involved here. Leave the value empty. |
	// | action | String | Yes | captcha | The action of the rule. Valid values: monitor and captcha. |
	// Configuration example of intelligent protection:
	//
	// ```
	// [
	//   {
	//     "type":"algorithm",
	//     "status":"on",
	//     "config":{},
	//     "action":"captcha"
	//   }
	// ]
	// ```
	// **Rule classification 8: IP address throttling**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | custom_cc_ip | The type of the rule. Set the value to custom_cc_ip. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | CustomCcIp | Yes | {"interval":20,"target":"IP","threshold":50,"ttl":2800} | The configuration of the rule. For more information, see **Fields in the config parameter of IP address throttling**. |
	// | action | String | Yes | monitor | The action of the rule. Valid values: deny, monitor, and captcha (only for web). |
	// **Fields in the config parameter of IP address throttling**| Field | Type | Required | Example | Description |
	// | ----- | ---- | -------- | ------- | ----------- |
	// | target | String | Yes | IP | The statistical field of rate limiting. Set the value to IP. |
	// | subKey | String | No | Empty | The subfield of the target field, which is not involved here. Leave the value empty. |
	// | Interval | Integer | Yes | 20 | The statistical interval. Valid values: 5 to 1800. Unit: seconds. |
	// | threshold | Integer | Yes | 50 | The trigger threshold of rate limiting. Valid values: 2 to 50000. Unit: calls. |
	// | ttl | Integer | Yes | 2800 | The validity period of the blacklist. Valid values: 60 to 86400. Unit: seconds. |
	// Configuration example of IP address throttling
	//
	// ```
	// [
	//   {
	//     "type":"custom_cc_ip",
	//     "status":"on",
	//     "config":{"interval":20,"target":"IP","threshold":50,"ttl":2800},
	//     "action":"monitor"
	//   },
	//   {
	//     "type":"custom_cc_ip",
	//     "status":"on",
	//     "config":{"interval":10,"target":"IP","threshold":30,"ttl":1800},
	//     "action":"monitor"
	//   }
	// ]
	// ```
	// **Rule classification 9: device throttling**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | custom_cc_dev | The type of the rule. Set the value to custom_cc_dev. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | CustomCcDev | Yes | {"interval":20,"target":"Header","subKey":"aliwaf_wxbb_umid","threshold":50,"ttl":2800} | The configuration of the rule. For more information, see **Fields in the config parameter of device throttling**. |
	// | action | String | Yes | monitor | The action of the rule. Valid values: deny and monitor. |
	// **Fields in the config parameter of device throttling**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | target | String | Yes | Header | The statistical field of rate limiting. Set the value to Header. |
	// | subKey | String | No | aliwaf_wxbb_umid | The subfield of the target field. Set the value to aliwaf_wxbb_umid. |
	// | Interval | Integer | Yes | 20 | The statistical interval. Valid values: 5 to 1800. Unit: seconds. |
	// | threshold | Integer | Yes | 50 | The trigger threshold of rate limiting. Valid values: 2 to 50000. Unit: calls. |
	// | ttl | Integer | Yes | 2800 | The validity period of the blacklist. Valid values: 60 to 86400. Unit: seconds. |
	// Configuration example of device throttling
	//
	// ```
	// [
	//   {
	//     "type":"custom_cc_dev",
	//     "status":"on",
	//     "config":{"interval":20,"target":"Header","subKey":"aliwaf_wxbb_umid","threshold":50,"ttl":2800},
	//     "action":"monitor"
	//   },
	//   {
	//     "type":"custom_cc_dev",
	//     "status":"on",
	//     "config":{"interval":20,"target":"Header","subKey":"aliwaf_wxbb_umid","threshold":50,"ttl":2800},
	//     "action":"deny"
	//   }
	// ]
	// ```
	// **Rule classification 10: custom session-based throttling**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | custom_cc | The type of the rule. Set the value to custom_cc. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | CustomCcIp | Yes | {"interval":10,"target":"Query String Parameter","subKey":"arg","threshold":30,"ttl":1800} | The configuration of the rule. For more information, see **Fields in the config parameter of custom session-based throttling**. |
	// | action | String | Yes | monitor | The action of the rule. Valid values: deny, monitor, and captcha (only for web). |
	// **Fields in the config parameter of custom session-based throttling**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | target | String | Yes | Query String Parameter | The statistical fields for frequency control. Valid values: Header, calculates the frequency of requests that contain the specified header; Query String Parameter, calculates the frequency of requests that contain the specified parameter; Cookie Name, calculates the frequency of requests that contain the specified cookie; and Session, calculates the frequency of requests that are transmitted over a specified session. |
	// | subKey | String | No | arg | The subfield of the target field. You can customize the value. |
	// | Interval | Integer | Yes | 10 | The statistical interval. Valid values: 5 to 1800. Unit: seconds. |
	// | threshold | Integer | Yes | 30 | The trigger threshold of rate limiting. Valid values: 2 to 50000. Unit: calls. |
	// | ttl | Integer | Yes | 2800 | The validity period of the blacklist. Valid values: 60 to 86400. Unit: seconds. |
	// Configuration example of custom session-based throttling
	//
	// ```
	// [
	//   {
	//     "type":"custom_cc",
	//     "status":"on",
	//     "config":{"interval":10,"target":"Query String Parameter","subKey":"arg","threshold":30,"ttl":1800},
	//     "action":"deny"
	//   },
	//   {
	//     "type":"custom_cc",
	//     "status":"on",
	//     "config":{"interval":10,"target":"Query String Parameter","subKey":"arg","threshold":30,"ttl":1800},
	//     "action":"captcha"
	//   }
	// ]
	// ```
	// **Rule classification 11: Bot threat intelligence library**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | intelligence | The type of the rule. Set the value to intelligence. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | Intelligence | No | Empty | The configuration of the rule, which is not involved here. Leave the value empty. |
	// | action | String | Yes | captcha | The action of the rule. Valid values: monitor and captcha. |
	// Configuration example of bot threat intelligence library:
	//
	// ```
	// [
	//   {
	//     "type":"intelligence",
	//     "status":"on",
	//     "config":{},
	//     "action":"captcha"
	//   }
	// ]
	// ```
	// **Rule classification 12: data center blacklist**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | intelligence_idc | The type of the rule. Set the value to intelligence_idc. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | IntelligenceIdc | Yes | {"name":"intelligence_idc_alibaba"} | The configuration of the rule. For more information, see **Values of name**. |
	// | action | String | Yes | captcha | The action of the rule. Valid values: deny, monitor, and captcha. |
	// **Values of name**| Value | Description |
	// | ----- | ----------- |
	// | intelligence_idc_alibaba | Data center IP address library-Alibaba Cloud |
	// | intelligence_idc_tencent | Data center IP address library-Tencent Cloud |
	// | intelligence_idc_mtyun | Data center IP address library-Meituan Open Services |
	// | intelligence_idc_vnet | Data center IP address library-21Vianet |
	// | intelligence_idc_other | Data center IP address library-Others |
	// Configuration example of data center blacklist
	//
	// ```
	// [
	//   {
	//     "type":"intelligence_idc",
	//     "status":"on",
	//     "config":{"name":"intelligence_idc_alibaba"},
	//     "action":"captcha"
	//   },
	//   {
	//     "type":"intelligence_idc",
	//     "status":"on",
	//     "config":{"name":"intelligence_idc_tencent"},
	//     "action":"captcha"
	//   }
	// ]
	// ```
	// **Rule classification 13: fake spider blocking**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | intelligence_fake_crawler | The type of the rule. Set the value to intelligence_fake_crawler. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Valid values: on and off. |
	// | config | IntelligenceFakeCrawler | No | Empty | The configuration of the rule, which is not involved here. Leave the value empty. |
	// | action | String | Yes | deny | The action of the rule. Set the value to deny. |
	// Configuration example of fake spider blocking:
	//
	// ```
	// [
	//   {
	//     "type": "intelligence_fake_crawler",
	//     "status": "on",
	//     "config":{},
	//     "action": "deny"
	//   }
	// ]
	// ```
	// **Rule classification 14: Bot characteristic detection**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | app_sdk | The type of the rule. Set the value to app_sdk. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Set the value to on. |
	// | config | AppSdk | Yes | {"featureAbnormal":["simulator","proxy","root","debugged","hook","virtual","antiReplay","signInvalid"],"customSignStatus":"on","customSign":{"key":"header","value":"ua"}} | The configuration of the rule. For more information, see **Fields in the config parameter of Bot characteristic detection**. |
	// | action | String | Yes | monitor | The action of the rule. Valid values: deny and monitor. |
	// **Fields in the config parameter of Bot characteristic detection**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | featureAbnormal | []String | Yes | simulator | signInvalid: The app signature is invalid.
	//
	// antiReplay: The signature expired.
	//
	// simulator: Uses a simulator.
	//
	// proxy: Uses a proxy.
	//
	// root: Root device.
	//
	// debugged: The debugging mode.
	//
	// hook: The app is hooked.
	//
	// virtual : Multiboxing. |
	// | customSignStatus | String | No | on | Specifies whether to enable the custom signature field. Valid values: on and off. |
	// | customSign | CustomSign | No | {"key":"header","value":"ua"} | The custom signature field. Format:
	//
	//   (Required) key : the name of the field. Valid values: header, arg, and cookie.
	//
	//  (Required) value: the value of the field. |
	// Configuration example of Bot characteristic detection:
	//
	// ```
	// [
	//   {
	//     "type": "app_sdk",
	//     "status": "on",
	//     "config": {"featureAbnormal":["simulator","proxy","root","debugged","hook","virtual","antiReplay","signInvalid"],"customSignStatus":"on","customSign":{"key":"header","value":"ua"}},
	//     "action": "monitor"
	//   }
	// ]
	// ```
	// **Rule classification 15: advanced protection (secondary packaging detection)**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | type | String | Yes | app_package | The type of the rule. Set the value to app_package. |
	// | status | String | Yes | on | Specifies whether to enable the rule. Set the value to on. |
	// | config | AppPackage | No | {"packageSigns":[{"name":"aaaaa","sign":"bbbb"},{"name":"cccc","sign":"dddd"}]} | The configuration of the rule. For more information, see **Fields in the packageSigns parameter**. |
	// | action | String | Yes | monitor | The action of the rule. Valid values: deny and monitor. |
	// **Fields in the packageSigns parameter**| Parameter | Type | Required | Example | Description |
	// | --------- | ---- | -------- | ------- | ----------- |
	// | name | String | Yes | aaaaa | The valid package name. |
	// | sign | String | No | bbbb | The signature of the package. |
	// Configuration examples of advanced protection (secondary packaging detection):
	//
	// ```
	// [
	//   {
	//     "type": "app_package",
	//     "status": "on",
	//     "config": {"packageSigns":[{"name":"aaaaa","sign":"bbbb"},{"name":"cccc","sign":"dddd"}]},
	//     "action": "deny"
	//   }
	// ]
	// ```
	// **Configuration example of Bot management and web page/browser protection**```
	// [
	//     {
	//         "type": "target_type",
	//         "status": "on",
	//         "config":
	//         {
	//             "target": "web"
	//         },
	//         "action": ""
	//     },
	//     {
	//         "type": "web_sdk",
	//         "status": "on",
	//         "config":
	//         {
	//             "mode": "automatic",
	//             "crossDomain": "example.com"
	//         },
	//         "action": ""
	//     },
	//     {
	//         "type": "traffic_feature",
	//         "status": "on",
	//         "config":
	//         {
	//             "conditions":
	//             [
	//                 {
	//                     "key": "Header",
	//                     "subKey": "User-Agent",
	//                     "opValue": "contain",
	//                     "values": "Chrome"
	//                 },
	//                 {
	//                     "key": "IP",
	//                     "subKey": "",
	//                     "opValue": "ip-contain",
	//                     "values": "192.168.0.1/24"
	//                 }
	//             ]
	//         },
	//         "action": ""
	//     },
	//     {
	//         "type": "intelligence_crawler",
	//         "status": "on",
	//         "config":
	//         {
	//             "name": "intelligence_crawler_baidu"
	//         },
	//         "action": "bypass"
	//     },
	//     {
	//         "type": "intelligence_crawler",
	//         "status": "on",
	//         "config":
	//         {
	//             "name": "intelligence_crawler_google"
	//         },
	//         "action": "bypass"
	//     },
	//     {
	//         "type": "js",
	//         "status": "on",
	//         "config":
	//         {},
	//         "action": "js"
	//     },
	//     {
	//         "type": "sigchl",
	//         "status": "on",
	//         "config":
	//         {
	//             "sigchl":
	//             [
	//                 "sig",
	//                 "replay",
	//                 "driver"
	//             ]
	//         },
	//         "action": "sigchl"
	//     },
	//     {
	//         "type": "algorithm",
	//         "status": "on",
	//         "config":
	//         {},
	//         "action": "captcha"
	//     },
	//     {
	//         "type": "custom_cc_ip",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 20,
	//             "target": "IP",
	//             "threshold": 50,
	//             "ttl": 2800
	//         },
	//         "action": "monitor"
	//     },
	//     {
	//         "type": "custom_cc_ip",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 10,
	//             "target": "IP",
	//             "threshold": 30,
	//             "ttl": 1800
	//         },
	//         "action": "monitor"
	//     },
	//     {
	//         "type": "custom_cc",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 10,
	//             "target": "Query String Parameter",
	//             "subKey": "arg",
	//             "threshold": 30,
	//             "ttl": 1800
	//         },
	//         "action": "deny"
	//     },
	//     {
	//         "type": "custom_cc",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 10,
	//             "target": "Query String Parameter",
	//             "subKey": "arg",
	//             "threshold": 30,
	//             "ttl": 1800
	//         },
	//         "action": "captcha"
	//     },
	//     {
	//         "type": "intelligence",
	//         "status": "on",
	//         "config":
	//         {},
	//         "action": "captcha"
	//     },
	//     {
	//         "type": "intelligence_idc",
	//         "status": "on",
	//         "config":
	//         {
	//             "name": "intelligence_idc_alibaba"
	//         },
	//         "action": "captcha"
	//     },
	//     {
	//         "type": "intelligence_idc",
	//         "status": "on",
	//         "config":
	//         {
	//             "name": "intelligence_idc_tencent"
	//         },
	//         "action": "captcha"
	//     },
	//     {
	//         "type": "intelligence_fake_crawler",
	//         "status": "on",
	//         "config":
	//         {},
	//         "action": "deny"
	//     }
	// ]
	// ```
	// **Configuration example of Bot management and app protection**```
	// json
	// [
	//     {
	//         "type": "target_type",
	//         "status": "on",
	//         "config":
	//         {
	//             "target": "app"
	//         },
	//         "action": ""
	//     },
	//     {
	//         "type": "traffic_feature",
	//         "status": "on",
	//         "config":
	//         {
	//             "conditions":
	//             [
	//                 {
	//                     "key": "Header",
	//                     "subKey": "User-Agent",
	//                     "opValue": "contain",
	//                     "values": "Chrome"
	//                 },
	//                 {
	//                     "key": "IP",
	//                     "subKey": "",
	//                     "opValue": "ip-contain",
	//                     "values": "192.168.0.1/24"
	//                 }
	//             ]
	//         },
	//         "action": ""
	//     },
	//     {
	//         "type": "custom_cc_ip",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 20,
	//             "target": "IP",
	//             "threshold": 50,
	//             "ttl": 2800
	//         },
	//         "action": "monitor"
	//     },
	//     {
	//         "type": "custom_cc_ip",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 10,
	//             "target": "IP",
	//             "threshold": 30,
	//             "ttl": 1800
	//         },
	//         "action": "monitor"
	//     },
	//     {
	//         "type": "custom_cc_dev",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 20,
	//             "target": "Header",
	//             "subKey": "aliwaf_wxbb_umid",
	//             "threshold": 50,
	//             "ttl": 2800
	//         },
	//         "action": "monitor"
	//     },
	//     {
	//         "type": "custom_cc_dev",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 20,
	//             "target": "Header",
	//             "subKey": "aliwaf_wxbb_umid",
	//             "threshold": 50,
	//             "ttl": 2800
	//         },
	//         "action": "deny"
	//     },
	//     {
	//         "type": "custom_cc",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 10,
	//             "target": "Query String Parameter",
	//             "subKey": "arg",
	//             "threshold": 30,
	//             "ttl": 1800
	//         },
	//         "action": "monitor"
	//     },
	//     {
	//         "type": "custom_cc",
	//         "status": "on",
	//         "config":
	//         {
	//             "interval": 10,
	//             "target": "Query String Parameter",
	//             "subKey": "arg",
	//             "threshold": 30,
	//             "ttl": 1800
	//         },
	//         "action": "deny"
	//     },
	//     {
	//         "type": "app_sdk",
	//         "status": "on",
	//         "config":
	//         {
	//             "featureAbnormal":
	//             [
	//                 "simulator",
	//                 "proxy",
	//                 "root",
	//                 "debugged",
	//                 "hook",
	//                 "virtual",
	//                 "antiReplay",
	//                 "signInvalid"
	//             ],
	//             "customSignStatus": "on",
	//             "customSign":
	//             {
	//                 "key": "header",
	//                 "value": "ua"
	//             }
	//         },
	//         "action": "monitor"
	//     },
	//     {
	//         "type": "app_package",
	//         "status": "on",
	//         "config":
	//         {
	//             "packageSigns":
	//             [
	//                 {
	//                     "name": "aaaaa",
	//                     "sign": "bbbb"
	//                 },
	//                 {
	//                     "name": "cccc",
	//                     "sign": "dddd"
	//                 }
	//             ]
	//         },
	//         "action": "deny"
	//     }
	// ]
	// ```
	RuleConfigs *string `json:"RuleConfigs,omitempty" xml:"RuleConfigs,omitempty"`
}

func (s BatchCreateDcdnWafRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateDcdnWafRulesRequest) GoString() string {
	return s.String()
}

func (s *BatchCreateDcdnWafRulesRequest) SetPolicyId(v int64) *BatchCreateDcdnWafRulesRequest {
	s.PolicyId = &v
	return s
}

func (s *BatchCreateDcdnWafRulesRequest) SetRuleConfigs(v string) *BatchCreateDcdnWafRulesRequest {
	s.RuleConfigs = &v
	return s
}

type BatchCreateDcdnWafRulesResponseBody struct {
	// Creates Web Application Firewall (WAF) protection rules.
	RequestId *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	RuleIds   *BatchCreateDcdnWafRulesResponseBodyRuleIds `json:"RuleIds,omitempty" xml:"RuleIds,omitempty" type:"Struct"`
}

func (s BatchCreateDcdnWafRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateDcdnWafRulesResponseBody) GoString() string {
	return s.String()
}

func (s *BatchCreateDcdnWafRulesResponseBody) SetRequestId(v string) *BatchCreateDcdnWafRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchCreateDcdnWafRulesResponseBody) SetRuleIds(v *BatchCreateDcdnWafRulesResponseBodyRuleIds) *BatchCreateDcdnWafRulesResponseBody {
	s.RuleIds = v
	return s
}

type BatchCreateDcdnWafRulesResponseBodyRuleIds struct {
	RuleId []*string `json:"RuleId,omitempty" xml:"RuleId,omitempty" type:"Repeated"`
}

func (s BatchCreateDcdnWafRulesResponseBodyRuleIds) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateDcdnWafRulesResponseBodyRuleIds) GoString() string {
	return s.String()
}

func (s *BatchCreateDcdnWafRulesResponseBodyRuleIds) SetRuleId(v []*string) *BatchCreateDcdnWafRulesResponseBodyRuleIds {
	s.RuleId = v
	return s
}

type BatchCreateDcdnWafRulesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchCreateDcdnWafRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchCreateDcdnWafRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateDcdnWafRulesResponse) GoString() string {
	return s.String()
}

func (s *BatchCreateDcdnWafRulesResponse) SetHeaders(v map[string]*string) *BatchCreateDcdnWafRulesResponse {
	s.Headers = v
	return s
}

func (s *BatchCreateDcdnWafRulesResponse) SetStatusCode(v int32) *BatchCreateDcdnWafRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchCreateDcdnWafRulesResponse) SetBody(v *BatchCreateDcdnWafRulesResponseBody) *BatchCreateDcdnWafRulesResponse {
	s.Body = v
	return s
}

type BatchDeleteDcdnDomainConfigsRequest struct {
	// The accelerated domain names whose configurations you want to delete. Separate multiple accelerated domain names with commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The names of the features that you want to delete. Separate multiple feature names with commas (,). For more information about feature names, see [Feature settings for a domain name](~~410622~~).
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchDeleteDcdnDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDcdnDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *BatchDeleteDcdnDomainConfigsRequest) SetDomainNames(v string) *BatchDeleteDcdnDomainConfigsRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchDeleteDcdnDomainConfigsRequest) SetFunctionNames(v string) *BatchDeleteDcdnDomainConfigsRequest {
	s.FunctionNames = &v
	return s
}

func (s *BatchDeleteDcdnDomainConfigsRequest) SetOwnerAccount(v string) *BatchDeleteDcdnDomainConfigsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchDeleteDcdnDomainConfigsRequest) SetOwnerId(v int64) *BatchDeleteDcdnDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchDeleteDcdnDomainConfigsRequest) SetSecurityToken(v string) *BatchDeleteDcdnDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type BatchDeleteDcdnDomainConfigsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchDeleteDcdnDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDcdnDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchDeleteDcdnDomainConfigsResponseBody) SetRequestId(v string) *BatchDeleteDcdnDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type BatchDeleteDcdnDomainConfigsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchDeleteDcdnDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchDeleteDcdnDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDcdnDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *BatchDeleteDcdnDomainConfigsResponse) SetHeaders(v map[string]*string) *BatchDeleteDcdnDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *BatchDeleteDcdnDomainConfigsResponse) SetStatusCode(v int32) *BatchDeleteDcdnDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchDeleteDcdnDomainConfigsResponse) SetBody(v *BatchDeleteDcdnDomainConfigsResponseBody) *BatchDeleteDcdnDomainConfigsResponse {
	s.Body = v
	return s
}

type BatchDeleteDcdnWafRulesRequest struct {
	// The IDs of the protection rules that you want to delete. Separate multiple IDs with commas (,).
	RuleIds *string `json:"RuleIds,omitempty" xml:"RuleIds,omitempty"`
}

func (s BatchDeleteDcdnWafRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDcdnWafRulesRequest) GoString() string {
	return s.String()
}

func (s *BatchDeleteDcdnWafRulesRequest) SetRuleIds(v string) *BatchDeleteDcdnWafRulesRequest {
	s.RuleIds = &v
	return s
}

type BatchDeleteDcdnWafRulesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchDeleteDcdnWafRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDcdnWafRulesResponseBody) GoString() string {
	return s.String()
}

func (s *BatchDeleteDcdnWafRulesResponseBody) SetRequestId(v string) *BatchDeleteDcdnWafRulesResponseBody {
	s.RequestId = &v
	return s
}

type BatchDeleteDcdnWafRulesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchDeleteDcdnWafRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchDeleteDcdnWafRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDcdnWafRulesResponse) GoString() string {
	return s.String()
}

func (s *BatchDeleteDcdnWafRulesResponse) SetHeaders(v map[string]*string) *BatchDeleteDcdnWafRulesResponse {
	s.Headers = v
	return s
}

func (s *BatchDeleteDcdnWafRulesResponse) SetStatusCode(v int32) *BatchDeleteDcdnWafRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchDeleteDcdnWafRulesResponse) SetBody(v *BatchDeleteDcdnWafRulesResponseBody) *BatchDeleteDcdnWafRulesResponse {
	s.Body = v
	return s
}

type BatchModifyDcdnWafRulesRequest struct {
	// The ID of the protection policy.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The configurations of the protection rule.
	RuleConfigs *string `json:"RuleConfigs,omitempty" xml:"RuleConfigs,omitempty"`
}

func (s BatchModifyDcdnWafRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchModifyDcdnWafRulesRequest) GoString() string {
	return s.String()
}

func (s *BatchModifyDcdnWafRulesRequest) SetPolicyId(v int64) *BatchModifyDcdnWafRulesRequest {
	s.PolicyId = &v
	return s
}

func (s *BatchModifyDcdnWafRulesRequest) SetRuleConfigs(v string) *BatchModifyDcdnWafRulesRequest {
	s.RuleConfigs = &v
	return s
}

type BatchModifyDcdnWafRulesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchModifyDcdnWafRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchModifyDcdnWafRulesResponseBody) GoString() string {
	return s.String()
}

func (s *BatchModifyDcdnWafRulesResponseBody) SetRequestId(v string) *BatchModifyDcdnWafRulesResponseBody {
	s.RequestId = &v
	return s
}

type BatchModifyDcdnWafRulesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchModifyDcdnWafRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchModifyDcdnWafRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchModifyDcdnWafRulesResponse) GoString() string {
	return s.String()
}

func (s *BatchModifyDcdnWafRulesResponse) SetHeaders(v map[string]*string) *BatchModifyDcdnWafRulesResponse {
	s.Headers = v
	return s
}

func (s *BatchModifyDcdnWafRulesResponse) SetStatusCode(v int32) *BatchModifyDcdnWafRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchModifyDcdnWafRulesResponse) SetBody(v *BatchModifyDcdnWafRulesResponseBody) *BatchModifyDcdnWafRulesResponse {
	s.Body = v
	return s
}

type BatchPutDcdnKvRequest struct {
	KvList    []*BatchPutDcdnKvRequestKvList `json:"KvList,omitempty" xml:"KvList,omitempty" type:"Repeated"`
	Namespace *string                        `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s BatchPutDcdnKvRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchPutDcdnKvRequest) GoString() string {
	return s.String()
}

func (s *BatchPutDcdnKvRequest) SetKvList(v []*BatchPutDcdnKvRequestKvList) *BatchPutDcdnKvRequest {
	s.KvList = v
	return s
}

func (s *BatchPutDcdnKvRequest) SetNamespace(v string) *BatchPutDcdnKvRequest {
	s.Namespace = &v
	return s
}

type BatchPutDcdnKvRequestKvList struct {
	Expiration    *int64  `json:"Expiration,omitempty" xml:"Expiration,omitempty"`
	ExpirationTtl *int64  `json:"ExpirationTtl,omitempty" xml:"ExpirationTtl,omitempty"`
	Key           *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value         *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s BatchPutDcdnKvRequestKvList) String() string {
	return tea.Prettify(s)
}

func (s BatchPutDcdnKvRequestKvList) GoString() string {
	return s.String()
}

func (s *BatchPutDcdnKvRequestKvList) SetExpiration(v int64) *BatchPutDcdnKvRequestKvList {
	s.Expiration = &v
	return s
}

func (s *BatchPutDcdnKvRequestKvList) SetExpirationTtl(v int64) *BatchPutDcdnKvRequestKvList {
	s.ExpirationTtl = &v
	return s
}

func (s *BatchPutDcdnKvRequestKvList) SetKey(v string) *BatchPutDcdnKvRequestKvList {
	s.Key = &v
	return s
}

func (s *BatchPutDcdnKvRequestKvList) SetValue(v string) *BatchPutDcdnKvRequestKvList {
	s.Value = &v
	return s
}

type BatchPutDcdnKvShrinkRequest struct {
	KvListShrink *string `json:"KvList,omitempty" xml:"KvList,omitempty"`
	Namespace    *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s BatchPutDcdnKvShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchPutDcdnKvShrinkRequest) GoString() string {
	return s.String()
}

func (s *BatchPutDcdnKvShrinkRequest) SetKvListShrink(v string) *BatchPutDcdnKvShrinkRequest {
	s.KvListShrink = &v
	return s
}

func (s *BatchPutDcdnKvShrinkRequest) SetNamespace(v string) *BatchPutDcdnKvShrinkRequest {
	s.Namespace = &v
	return s
}

type BatchPutDcdnKvResponseBody struct {
	FailKeys    []*string `json:"FailKeys,omitempty" xml:"FailKeys,omitempty" type:"Repeated"`
	RequestId   *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SuccessKeys []*string `json:"SuccessKeys,omitempty" xml:"SuccessKeys,omitempty" type:"Repeated"`
}

func (s BatchPutDcdnKvResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchPutDcdnKvResponseBody) GoString() string {
	return s.String()
}

func (s *BatchPutDcdnKvResponseBody) SetFailKeys(v []*string) *BatchPutDcdnKvResponseBody {
	s.FailKeys = v
	return s
}

func (s *BatchPutDcdnKvResponseBody) SetRequestId(v string) *BatchPutDcdnKvResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchPutDcdnKvResponseBody) SetSuccessKeys(v []*string) *BatchPutDcdnKvResponseBody {
	s.SuccessKeys = v
	return s
}

type BatchPutDcdnKvResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchPutDcdnKvResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchPutDcdnKvResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchPutDcdnKvResponse) GoString() string {
	return s.String()
}

func (s *BatchPutDcdnKvResponse) SetHeaders(v map[string]*string) *BatchPutDcdnKvResponse {
	s.Headers = v
	return s
}

func (s *BatchPutDcdnKvResponse) SetStatusCode(v int32) *BatchPutDcdnKvResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchPutDcdnKvResponse) SetBody(v *BatchPutDcdnKvResponseBody) *BatchPutDcdnKvResponse {
	s.Body = v
	return s
}

type BatchSetDcdnDomainCertificateRequest struct {
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The type of the certificate. Valid values:
	//
	// *   **upload**: a custom certificate that you upload.
	// *   **cas**: a certificate that is acquired through Certificate Management Service.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The accelerated domain name for which you want to configure the HTTPS certificate. The accelerated domain must have HTTPS acceleration enabled. You can specify multiple domain names and separate them with commas (,).
	//
	// > You can configure up to 10 domain names in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The private key. This parameter is required only if you enable the certificate.
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the HTTPS certificate. Valid values:
	//
	// *   \*\*on\*\*: enables the HTTPS certificate.
	// *   **off**: does not enable the HTTPS certificate.
	//
	// This is the default value.
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The content of the certificate. This parameter is required only if you enable the certificate.
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchSetDcdnDomainCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnDomainCertificateRequest) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnDomainCertificateRequest) SetCertName(v string) *BatchSetDcdnDomainCertificateRequest {
	s.CertName = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetCertType(v string) *BatchSetDcdnDomainCertificateRequest {
	s.CertType = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetDomainName(v string) *BatchSetDcdnDomainCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetOwnerId(v int64) *BatchSetDcdnDomainCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetRegion(v string) *BatchSetDcdnDomainCertificateRequest {
	s.Region = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetSSLPri(v string) *BatchSetDcdnDomainCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetSSLProtocol(v string) *BatchSetDcdnDomainCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetSSLPub(v string) *BatchSetDcdnDomainCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateRequest) SetSecurityToken(v string) *BatchSetDcdnDomainCertificateRequest {
	s.SecurityToken = &v
	return s
}

type BatchSetDcdnDomainCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetDcdnDomainCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnDomainCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnDomainCertificateResponseBody) SetRequestId(v string) *BatchSetDcdnDomainCertificateResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetDcdnDomainCertificateResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetDcdnDomainCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetDcdnDomainCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnDomainCertificateResponse) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnDomainCertificateResponse) SetHeaders(v map[string]*string) *BatchSetDcdnDomainCertificateResponse {
	s.Headers = v
	return s
}

func (s *BatchSetDcdnDomainCertificateResponse) SetStatusCode(v int32) *BatchSetDcdnDomainCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetDcdnDomainCertificateResponse) SetBody(v *BatchSetDcdnDomainCertificateResponseBody) *BatchSetDcdnDomainCertificateResponse {
	s.Body = v
	return s
}

type BatchSetDcdnDomainConfigsRequest struct {
	// The accelerated domain names. Specify multiple accelerated domain names with commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The features that you want to configure. Format:
	//
	// >
	//
	// *   **functionName**: The name of the feature. Separate multiple values with commas (,). For more information, see [A list of features](~~410622~~).
	//
	// *   **argName**: The feature parameters for **functionName**.
	//
	// *   **argValue**: The parameter values set for **functionName**.
	//
	//         [
	//          {
	//            "functionArgs": [
	//             {
	//              "argName": "Parameter A",
	//              "argValue": "Parameter value"
	//             },
	//           {
	//             "argName": "Parameter B",
	//             "argValue": "Parameter value"
	//              }
	//          ],
	//          "functionName": "Feature name"
	//             }
	//         ]
	Functions     *string `json:"Functions,omitempty" xml:"Functions,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchSetDcdnDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnDomainConfigsRequest) SetDomainNames(v string) *BatchSetDcdnDomainConfigsRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchSetDcdnDomainConfigsRequest) SetFunctions(v string) *BatchSetDcdnDomainConfigsRequest {
	s.Functions = &v
	return s
}

func (s *BatchSetDcdnDomainConfigsRequest) SetOwnerAccount(v string) *BatchSetDcdnDomainConfigsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchSetDcdnDomainConfigsRequest) SetOwnerId(v int64) *BatchSetDcdnDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchSetDcdnDomainConfigsRequest) SetSecurityToken(v string) *BatchSetDcdnDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type BatchSetDcdnDomainConfigsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetDcdnDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnDomainConfigsResponseBody) SetRequestId(v string) *BatchSetDcdnDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetDcdnDomainConfigsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetDcdnDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetDcdnDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnDomainConfigsResponse) SetHeaders(v map[string]*string) *BatchSetDcdnDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *BatchSetDcdnDomainConfigsResponse) SetStatusCode(v int32) *BatchSetDcdnDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetDcdnDomainConfigsResponse) SetBody(v *BatchSetDcdnDomainConfigsResponseBody) *BatchSetDcdnDomainConfigsResponse {
	s.Body = v
	return s
}

type BatchSetDcdnIpaDomainConfigsRequest struct {
	// The domain names accelerated by IPA. Separate multiple domain names with commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The list of features. `[{"functionArgs":[{"argName":"parameter name","argValue":"parameter value"}],"functionName":"feature name"}]`
	Functions     *string `json:"Functions,omitempty" xml:"Functions,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchSetDcdnIpaDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnIpaDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnIpaDomainConfigsRequest) SetDomainNames(v string) *BatchSetDcdnIpaDomainConfigsRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchSetDcdnIpaDomainConfigsRequest) SetFunctions(v string) *BatchSetDcdnIpaDomainConfigsRequest {
	s.Functions = &v
	return s
}

func (s *BatchSetDcdnIpaDomainConfigsRequest) SetOwnerAccount(v string) *BatchSetDcdnIpaDomainConfigsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchSetDcdnIpaDomainConfigsRequest) SetOwnerId(v int64) *BatchSetDcdnIpaDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchSetDcdnIpaDomainConfigsRequest) SetSecurityToken(v string) *BatchSetDcdnIpaDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type BatchSetDcdnIpaDomainConfigsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetDcdnIpaDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnIpaDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnIpaDomainConfigsResponseBody) SetRequestId(v string) *BatchSetDcdnIpaDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetDcdnIpaDomainConfigsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetDcdnIpaDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetDcdnIpaDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnIpaDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnIpaDomainConfigsResponse) SetHeaders(v map[string]*string) *BatchSetDcdnIpaDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *BatchSetDcdnIpaDomainConfigsResponse) SetStatusCode(v int32) *BatchSetDcdnIpaDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetDcdnIpaDomainConfigsResponse) SetBody(v *BatchSetDcdnIpaDomainConfigsResponseBody) *BatchSetDcdnIpaDomainConfigsResponse {
	s.Body = v
	return s
}

type BatchSetDcdnWafDomainConfigsRequest struct {
	// Specifies the header that records the IP address to be obtained. If the default header is selected, the value of this parameter is empty. If a custom header is selected, the value of this parameter is the value specified by the user. Separate multiple values with commas (,). You can specify a maximum of five values.
	ClientIpTag *string `json:"ClientIpTag,omitempty" xml:"ClientIpTag,omitempty"`
	// The protection status of the domain name. Valid values: on, off, and empty string.
	//
	// *   When you add a domain name, the value of this parameter is **on**, and the value of ClientIpTag takes effect, which is empty if the default header is selected and is the value specified by the user if a custom header is selected.
	// *   When you delete a domain name, the value of this parameter is **off**, and the value of ClientIpTag does not take effect.
	// *   When you only modify the value of ClientIpTag, the value of DefenseStatus is an empty string.
	DefenseStatus *string `json:"DefenseStatus,omitempty" xml:"DefenseStatus,omitempty"`
	// The protected domain names for which you want to change the protection status. You can specify up to 50 domain names. Separate multiple domain names with commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
}

func (s BatchSetDcdnWafDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnWafDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnWafDomainConfigsRequest) SetClientIpTag(v string) *BatchSetDcdnWafDomainConfigsRequest {
	s.ClientIpTag = &v
	return s
}

func (s *BatchSetDcdnWafDomainConfigsRequest) SetDefenseStatus(v string) *BatchSetDcdnWafDomainConfigsRequest {
	s.DefenseStatus = &v
	return s
}

func (s *BatchSetDcdnWafDomainConfigsRequest) SetDomainNames(v string) *BatchSetDcdnWafDomainConfigsRequest {
	s.DomainNames = &v
	return s
}

type BatchSetDcdnWafDomainConfigsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetDcdnWafDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnWafDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnWafDomainConfigsResponseBody) SetRequestId(v string) *BatchSetDcdnWafDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetDcdnWafDomainConfigsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetDcdnWafDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetDcdnWafDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetDcdnWafDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *BatchSetDcdnWafDomainConfigsResponse) SetHeaders(v map[string]*string) *BatchSetDcdnWafDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *BatchSetDcdnWafDomainConfigsResponse) SetStatusCode(v int32) *BatchSetDcdnWafDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetDcdnWafDomainConfigsResponse) SetBody(v *BatchSetDcdnWafDomainConfigsResponseBody) *BatchSetDcdnWafDomainConfigsResponse {
	s.Body = v
	return s
}

type BatchStartDcdnDomainRequest struct {
	// The accelerated domain name. You can specify multiple accelerated domain names and separate them with commas (,).
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStartDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStartDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStartDcdnDomainRequest) SetDomainNames(v string) *BatchStartDcdnDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStartDcdnDomainRequest) SetOwnerId(v int64) *BatchStartDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStartDcdnDomainRequest) SetSecurityToken(v string) *BatchStartDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStartDcdnDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStartDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStartDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStartDcdnDomainResponseBody) SetRequestId(v string) *BatchStartDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStartDcdnDomainResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchStartDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchStartDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStartDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStartDcdnDomainResponse) SetHeaders(v map[string]*string) *BatchStartDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStartDcdnDomainResponse) SetStatusCode(v int32) *BatchStartDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStartDcdnDomainResponse) SetBody(v *BatchStartDcdnDomainResponseBody) *BatchStartDcdnDomainResponse {
	s.Body = v
	return s
}

type BatchStopDcdnDomainRequest struct {
	// The accelerated domain names. If you need to specify multiple accelerated domain names, separate domain names with commas (,).
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStopDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStopDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStopDcdnDomainRequest) SetDomainNames(v string) *BatchStopDcdnDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStopDcdnDomainRequest) SetOwnerId(v int64) *BatchStopDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStopDcdnDomainRequest) SetSecurityToken(v string) *BatchStopDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStopDcdnDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStopDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStopDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStopDcdnDomainResponseBody) SetRequestId(v string) *BatchStopDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStopDcdnDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchStopDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchStopDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStopDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStopDcdnDomainResponse) SetHeaders(v map[string]*string) *BatchStopDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStopDcdnDomainResponse) SetStatusCode(v int32) *BatchStopDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStopDcdnDomainResponse) SetBody(v *BatchStopDcdnDomainResponseBody) *BatchStopDcdnDomainResponse {
	s.Body = v
	return s
}

type CheckDcdnProjectExistRequest struct {
	// The name of a real-time log delivery project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s CheckDcdnProjectExistRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckDcdnProjectExistRequest) GoString() string {
	return s.String()
}

func (s *CheckDcdnProjectExistRequest) SetProjectName(v string) *CheckDcdnProjectExistRequest {
	s.ProjectName = &v
	return s
}

type CheckDcdnProjectExistResponseBody struct {
	// The returned results.
	Content *CheckDcdnProjectExistResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckDcdnProjectExistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckDcdnProjectExistResponseBody) GoString() string {
	return s.String()
}

func (s *CheckDcdnProjectExistResponseBody) SetContent(v *CheckDcdnProjectExistResponseBodyContent) *CheckDcdnProjectExistResponseBody {
	s.Content = v
	return s
}

func (s *CheckDcdnProjectExistResponseBody) SetRequestId(v string) *CheckDcdnProjectExistResponseBody {
	s.RequestId = &v
	return s
}

type CheckDcdnProjectExistResponseBodyContent struct {
	// Indicates whether the real-time log delivery project exists. Valid values:
	//
	// *   **false**
	// *   **true**
	Exist *string `json:"Exist,omitempty" xml:"Exist,omitempty"`
}

func (s CheckDcdnProjectExistResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s CheckDcdnProjectExistResponseBodyContent) GoString() string {
	return s.String()
}

func (s *CheckDcdnProjectExistResponseBodyContent) SetExist(v string) *CheckDcdnProjectExistResponseBodyContent {
	s.Exist = &v
	return s
}

type CheckDcdnProjectExistResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckDcdnProjectExistResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckDcdnProjectExistResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckDcdnProjectExistResponse) GoString() string {
	return s.String()
}

func (s *CheckDcdnProjectExistResponse) SetHeaders(v map[string]*string) *CheckDcdnProjectExistResponse {
	s.Headers = v
	return s
}

func (s *CheckDcdnProjectExistResponse) SetStatusCode(v int32) *CheckDcdnProjectExistResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckDcdnProjectExistResponse) SetBody(v *CheckDcdnProjectExistResponseBody) *CheckDcdnProjectExistResponse {
	s.Body = v
	return s
}

type CommitStagingRoutineCodeRequest struct {
	// The description of the code version.
	CodeDescription *string `json:"CodeDescription,omitempty" xml:"CodeDescription,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CommitStagingRoutineCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s CommitStagingRoutineCodeRequest) GoString() string {
	return s.String()
}

func (s *CommitStagingRoutineCodeRequest) SetCodeDescription(v string) *CommitStagingRoutineCodeRequest {
	s.CodeDescription = &v
	return s
}

func (s *CommitStagingRoutineCodeRequest) SetName(v string) *CommitStagingRoutineCodeRequest {
	s.Name = &v
	return s
}

type CommitStagingRoutineCodeResponseBody struct {
	// The version number of the code.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CommitStagingRoutineCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CommitStagingRoutineCodeResponseBody) GoString() string {
	return s.String()
}

func (s *CommitStagingRoutineCodeResponseBody) SetContent(v map[string]interface{}) *CommitStagingRoutineCodeResponseBody {
	s.Content = v
	return s
}

func (s *CommitStagingRoutineCodeResponseBody) SetRequestId(v string) *CommitStagingRoutineCodeResponseBody {
	s.RequestId = &v
	return s
}

type CommitStagingRoutineCodeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CommitStagingRoutineCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CommitStagingRoutineCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s CommitStagingRoutineCodeResponse) GoString() string {
	return s.String()
}

func (s *CommitStagingRoutineCodeResponse) SetHeaders(v map[string]*string) *CommitStagingRoutineCodeResponse {
	s.Headers = v
	return s
}

func (s *CommitStagingRoutineCodeResponse) SetStatusCode(v int32) *CommitStagingRoutineCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *CommitStagingRoutineCodeResponse) SetBody(v *CommitStagingRoutineCodeResponseBody) *CommitStagingRoutineCodeResponse {
	s.Body = v
	return s
}

type CreateDcdnDeliverTaskRequest struct {
	// The method that is used to send operations reports. Operations reports are sent to you only by email. The settings must be escaped in JSON.
	Deliver *string `json:"Deliver,omitempty" xml:"Deliver,omitempty"`
	// The domain names to be tracked. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
	//
	// > If you do not specify a domain name, the tracking task is created for all domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the tracking task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The operations reports that are tracked by the task. The data must be escaped in JSON.
	Reports *string `json:"Reports,omitempty" xml:"Reports,omitempty"`
	// The parameters that specify the time interval at which the tracking task sends operations reports. The settings must be escaped in JSON.
	Schedule *string `json:"Schedule,omitempty" xml:"Schedule,omitempty"`
}

func (s CreateDcdnDeliverTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnDeliverTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateDcdnDeliverTaskRequest) SetDeliver(v string) *CreateDcdnDeliverTaskRequest {
	s.Deliver = &v
	return s
}

func (s *CreateDcdnDeliverTaskRequest) SetDomainName(v string) *CreateDcdnDeliverTaskRequest {
	s.DomainName = &v
	return s
}

func (s *CreateDcdnDeliverTaskRequest) SetName(v string) *CreateDcdnDeliverTaskRequest {
	s.Name = &v
	return s
}

func (s *CreateDcdnDeliverTaskRequest) SetReports(v string) *CreateDcdnDeliverTaskRequest {
	s.Reports = &v
	return s
}

func (s *CreateDcdnDeliverTaskRequest) SetSchedule(v string) *CreateDcdnDeliverTaskRequest {
	s.Schedule = &v
	return s
}

type CreateDcdnDeliverTaskResponseBody struct {
	// The ID of the tracking task.
	DeliverId *string `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDcdnDeliverTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnDeliverTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDcdnDeliverTaskResponseBody) SetDeliverId(v string) *CreateDcdnDeliverTaskResponseBody {
	s.DeliverId = &v
	return s
}

func (s *CreateDcdnDeliverTaskResponseBody) SetRequestId(v string) *CreateDcdnDeliverTaskResponseBody {
	s.RequestId = &v
	return s
}

type CreateDcdnDeliverTaskResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDcdnDeliverTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDcdnDeliverTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnDeliverTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateDcdnDeliverTaskResponse) SetHeaders(v map[string]*string) *CreateDcdnDeliverTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateDcdnDeliverTaskResponse) SetStatusCode(v int32) *CreateDcdnDeliverTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDcdnDeliverTaskResponse) SetBody(v *CreateDcdnDeliverTaskResponseBody) *CreateDcdnDeliverTaskResponse {
	s.Body = v
	return s
}

type CreateDcdnSLSRealTimeLogDeliveryRequest struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The data center. Valid values:
	//
	// *   cn: China
	// *   sg: Singapore
	// *   in: India
	// *   eu: Europe
	// *   us: United States
	DataCenter *string `json:"DataCenter,omitempty" xml:"DataCenter,omitempty"`
	// The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of a real-time log delivery project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the Log Service Logstore.
	SLSLogStore *string `json:"SLSLogStore,omitempty" xml:"SLSLogStore,omitempty"`
	// The name of the Log Service project.
	SLSProject *string `json:"SLSProject,omitempty" xml:"SLSProject,omitempty"`
	// The region to which real-time logs are delivered.
	SLSRegion *string `json:"SLSRegion,omitempty" xml:"SLSRegion,omitempty"`
	// The sampling rate.
	SamplingRate *string `json:"SamplingRate,omitempty" xml:"SamplingRate,omitempty"`
}

func (s CreateDcdnSLSRealTimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSLSRealTimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetBusinessType(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.BusinessType = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetDataCenter(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.DataCenter = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetDomainName(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.DomainName = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetProjectName(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetSLSLogStore(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.SLSLogStore = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetSLSProject(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.SLSProject = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetSLSRegion(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.SLSRegion = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryRequest) SetSamplingRate(v string) *CreateDcdnSLSRealTimeLogDeliveryRequest {
	s.SamplingRate = &v
	return s
}

type CreateDcdnSLSRealTimeLogDeliveryResponseBody struct {
	// The configuration results of the domain name.
	Content *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponseBody) SetContent(v *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent) *CreateDcdnSLSRealTimeLogDeliveryResponseBody {
	s.Content = v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponseBody) SetRequestId(v string) *CreateDcdnSLSRealTimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent struct {
	Domains []*CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent) GoString() string {
	return s.String()
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent) SetDomains(v []*CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains) *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent {
	s.Domains = v
	return s
}

type CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains struct {
	// The description of the returned result.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The domain name from which real-time logs were collected.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The region to which real-time logs were delivered.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The status of real-time logs.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains) GoString() string {
	return s.String()
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains) SetDesc(v string) *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains {
	s.Desc = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains) SetDomainName(v string) *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains {
	s.DomainName = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains) SetRegion(v string) *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains {
	s.Region = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains) SetStatus(v string) *CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains {
	s.Status = &v
	return s
}

type CreateDcdnSLSRealTimeLogDeliveryResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDcdnSLSRealTimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSLSRealTimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponse) SetHeaders(v map[string]*string) *CreateDcdnSLSRealTimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponse) SetStatusCode(v int32) *CreateDcdnSLSRealTimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDcdnSLSRealTimeLogDeliveryResponse) SetBody(v *CreateDcdnSLSRealTimeLogDeliveryResponseBody) *CreateDcdnSLSRealTimeLogDeliveryResponse {
	s.Body = v
	return s
}

type CreateDcdnSubTaskRequest struct {
	// The domain names to be tracked. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
	//
	// **
	//
	// **If you do not specify a domain name, the custom operations reports are created for all domain names that belong to your Alibaba Cloud account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The IDs of the metrics that you want to include in the report. Separate multiple IDs with commas (,). Valid values:
	//
	// *   **2**: Popular URLs by Request
	// *   **4**: Popular URLs by Traffic
	// *   **6**: Popular Referer by Request
	// *   **8**: Popular Referer by Traffic
	// *   **10**: Popular Back-to-origin URLs by Request
	// *   **12**: Popular Back-to-origin URLs by Traffic
	// *   **14**: Top Client IPs by Request
	// *   **16**: Top Client IPs by Traffic
	// *   **18**: Popular Domain Names by Traffic
	// *   **20**: PV/UV
	// *   **22**: Visit Distribution by Region
	// *   **24**: Distribution of ISPs
	ReportIds *string `json:"ReportIds,omitempty" xml:"ReportIds,omitempty"`
}

func (s CreateDcdnSubTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSubTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateDcdnSubTaskRequest) SetDomainName(v string) *CreateDcdnSubTaskRequest {
	s.DomainName = &v
	return s
}

func (s *CreateDcdnSubTaskRequest) SetReportIds(v string) *CreateDcdnSubTaskRequest {
	s.ReportIds = &v
	return s
}

type CreateDcdnSubTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDcdnSubTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDcdnSubTaskResponseBody) SetRequestId(v string) *CreateDcdnSubTaskResponseBody {
	s.RequestId = &v
	return s
}

type CreateDcdnSubTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDcdnSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDcdnSubTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnSubTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateDcdnSubTaskResponse) SetHeaders(v map[string]*string) *CreateDcdnSubTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateDcdnSubTaskResponse) SetStatusCode(v int32) *CreateDcdnSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDcdnSubTaskResponse) SetBody(v *CreateDcdnSubTaskResponseBody) *CreateDcdnSubTaskResponse {
	s.Body = v
	return s
}

type CreateDcdnWafGroupRequest struct {
	Name       *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Subscribe  *string `json:"Subscribe,omitempty" xml:"Subscribe,omitempty"`
	TemplateId *int64  `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s CreateDcdnWafGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnWafGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateDcdnWafGroupRequest) SetName(v string) *CreateDcdnWafGroupRequest {
	s.Name = &v
	return s
}

func (s *CreateDcdnWafGroupRequest) SetSubscribe(v string) *CreateDcdnWafGroupRequest {
	s.Subscribe = &v
	return s
}

func (s *CreateDcdnWafGroupRequest) SetTemplateId(v int64) *CreateDcdnWafGroupRequest {
	s.TemplateId = &v
	return s
}

type CreateDcdnWafGroupResponseBody struct {
	Id        *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDcdnWafGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnWafGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDcdnWafGroupResponseBody) SetId(v int64) *CreateDcdnWafGroupResponseBody {
	s.Id = &v
	return s
}

func (s *CreateDcdnWafGroupResponseBody) SetRequestId(v string) *CreateDcdnWafGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateDcdnWafGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDcdnWafGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDcdnWafGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnWafGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateDcdnWafGroupResponse) SetHeaders(v map[string]*string) *CreateDcdnWafGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateDcdnWafGroupResponse) SetStatusCode(v int32) *CreateDcdnWafGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDcdnWafGroupResponse) SetBody(v *CreateDcdnWafGroupResponseBody) *CreateDcdnWafGroupResponse {
	s.Body = v
	return s
}

type CreateDcdnWafPolicyRequest struct {
	// The type of the WAF protection policy. Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom protection
	// *   whitelist: IP address whitelist
	// *   ip_blacklist: IP address blacklist
	// *   region_block: region blacklist
	// *   bot: bot management
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The name of the protection policy. The name can be up to 64 characters in length and can contain letters, digits, and underscores (\_).
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The status of the protection policy. Valid values:
	//
	// *   on: The policy is enabled.
	// *   off: The policy is disabled.
	PolicyStatus *string `json:"PolicyStatus,omitempty" xml:"PolicyStatus,omitempty"`
	// Specifies whether to set the current policy as the default policy. Valid values:
	//
	// *   default: sets the current policy as the default policy.
	// *   custom: does not set the current policy as the default policy.
	PolicyType *string `json:"PolicyType,omitempty" xml:"PolicyType,omitempty"`
}

func (s CreateDcdnWafPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnWafPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateDcdnWafPolicyRequest) SetDefenseScene(v string) *CreateDcdnWafPolicyRequest {
	s.DefenseScene = &v
	return s
}

func (s *CreateDcdnWafPolicyRequest) SetPolicyName(v string) *CreateDcdnWafPolicyRequest {
	s.PolicyName = &v
	return s
}

func (s *CreateDcdnWafPolicyRequest) SetPolicyStatus(v string) *CreateDcdnWafPolicyRequest {
	s.PolicyStatus = &v
	return s
}

func (s *CreateDcdnWafPolicyRequest) SetPolicyType(v string) *CreateDcdnWafPolicyRequest {
	s.PolicyType = &v
	return s
}

type CreateDcdnWafPolicyResponseBody struct {
	// The ID of the protection policy that you created.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDcdnWafPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnWafPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDcdnWafPolicyResponseBody) SetPolicyId(v int64) *CreateDcdnWafPolicyResponseBody {
	s.PolicyId = &v
	return s
}

func (s *CreateDcdnWafPolicyResponseBody) SetRequestId(v string) *CreateDcdnWafPolicyResponseBody {
	s.RequestId = &v
	return s
}

type CreateDcdnWafPolicyResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDcdnWafPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDcdnWafPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDcdnWafPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateDcdnWafPolicyResponse) SetHeaders(v map[string]*string) *CreateDcdnWafPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateDcdnWafPolicyResponse) SetStatusCode(v int32) *CreateDcdnWafPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDcdnWafPolicyResponse) SetBody(v *CreateDcdnWafPolicyResponseBody) *CreateDcdnWafPolicyResponse {
	s.Body = v
	return s
}

type CreateRoutineRequest struct {
	// The description of the routine.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configurations of the specified environment.
	EnvConf map[string]interface{} `json:"EnvConf,omitempty" xml:"EnvConf,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateRoutineRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRoutineRequest) GoString() string {
	return s.String()
}

func (s *CreateRoutineRequest) SetDescription(v string) *CreateRoutineRequest {
	s.Description = &v
	return s
}

func (s *CreateRoutineRequest) SetEnvConf(v map[string]interface{}) *CreateRoutineRequest {
	s.EnvConf = v
	return s
}

func (s *CreateRoutineRequest) SetName(v string) *CreateRoutineRequest {
	s.Name = &v
	return s
}

type CreateRoutineShrinkRequest struct {
	// The description of the routine.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configurations of the specified environment.
	EnvConfShrink *string `json:"EnvConf,omitempty" xml:"EnvConf,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateRoutineShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRoutineShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateRoutineShrinkRequest) SetDescription(v string) *CreateRoutineShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateRoutineShrinkRequest) SetEnvConfShrink(v string) *CreateRoutineShrinkRequest {
	s.EnvConfShrink = &v
	return s
}

func (s *CreateRoutineShrinkRequest) SetName(v string) *CreateRoutineShrinkRequest {
	s.Name = &v
	return s
}

type CreateRoutineResponseBody struct {
	// The message returned, such as ""Status": "OK"".
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateRoutineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRoutineResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRoutineResponseBody) SetContent(v map[string]interface{}) *CreateRoutineResponseBody {
	s.Content = v
	return s
}

func (s *CreateRoutineResponseBody) SetRequestId(v string) *CreateRoutineResponseBody {
	s.RequestId = &v
	return s
}

type CreateRoutineResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRoutineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRoutineResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRoutineResponse) GoString() string {
	return s.String()
}

func (s *CreateRoutineResponse) SetHeaders(v map[string]*string) *CreateRoutineResponse {
	s.Headers = v
	return s
}

func (s *CreateRoutineResponse) SetStatusCode(v int32) *CreateRoutineResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRoutineResponse) SetBody(v *CreateRoutineResponseBody) *CreateRoutineResponse {
	s.Body = v
	return s
}

type CreateSlrAndSlsProjectRequest struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) points of presence (POPs)
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The region where Log Service resides. Valid values:
	//
	// *   **cn-hangzhou**
	// *   **cn-shanghai**
	// *   **cn-qingdao**
	// *   **cn-beijing**
	// *   **cn-zhangjiakou**
	// *   **cn-shenzhen**
	// *   **eu-central-1**
	// *   **us-west-1**
	// *   **ap-south-1**
	// *   **ap-southeast-1**
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s CreateSlrAndSlsProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSlrAndSlsProjectRequest) GoString() string {
	return s.String()
}

func (s *CreateSlrAndSlsProjectRequest) SetBusinessType(v string) *CreateSlrAndSlsProjectRequest {
	s.BusinessType = &v
	return s
}

func (s *CreateSlrAndSlsProjectRequest) SetRegion(v string) *CreateSlrAndSlsProjectRequest {
	s.Region = &v
	return s
}

type CreateSlrAndSlsProjectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about Log Service.
	SlsInfo *CreateSlrAndSlsProjectResponseBodySlsInfo `json:"SlsInfo,omitempty" xml:"SlsInfo,omitempty" type:"Struct"`
}

func (s CreateSlrAndSlsProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSlrAndSlsProjectResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSlrAndSlsProjectResponseBody) SetRequestId(v string) *CreateSlrAndSlsProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSlrAndSlsProjectResponseBody) SetSlsInfo(v *CreateSlrAndSlsProjectResponseBodySlsInfo) *CreateSlrAndSlsProjectResponseBody {
	s.SlsInfo = v
	return s
}

type CreateSlrAndSlsProjectResponseBodySlsInfo struct {
	// The endpoint of Log Service.
	EndPoint *string `json:"EndPoint,omitempty" xml:"EndPoint,omitempty"`
	// The Logstore of Log Service.
	LogStore *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	// The project of Log Service.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The region where Log Service resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s CreateSlrAndSlsProjectResponseBodySlsInfo) String() string {
	return tea.Prettify(s)
}

func (s CreateSlrAndSlsProjectResponseBodySlsInfo) GoString() string {
	return s.String()
}

func (s *CreateSlrAndSlsProjectResponseBodySlsInfo) SetEndPoint(v string) *CreateSlrAndSlsProjectResponseBodySlsInfo {
	s.EndPoint = &v
	return s
}

func (s *CreateSlrAndSlsProjectResponseBodySlsInfo) SetLogStore(v string) *CreateSlrAndSlsProjectResponseBodySlsInfo {
	s.LogStore = &v
	return s
}

func (s *CreateSlrAndSlsProjectResponseBodySlsInfo) SetProject(v string) *CreateSlrAndSlsProjectResponseBodySlsInfo {
	s.Project = &v
	return s
}

func (s *CreateSlrAndSlsProjectResponseBodySlsInfo) SetRegion(v string) *CreateSlrAndSlsProjectResponseBodySlsInfo {
	s.Region = &v
	return s
}

type CreateSlrAndSlsProjectResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSlrAndSlsProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSlrAndSlsProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSlrAndSlsProjectResponse) GoString() string {
	return s.String()
}

func (s *CreateSlrAndSlsProjectResponse) SetHeaders(v map[string]*string) *CreateSlrAndSlsProjectResponse {
	s.Headers = v
	return s
}

func (s *CreateSlrAndSlsProjectResponse) SetStatusCode(v int32) *CreateSlrAndSlsProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSlrAndSlsProjectResponse) SetBody(v *CreateSlrAndSlsProjectResponseBody) *CreateSlrAndSlsProjectResponse {
	s.Body = v
	return s
}

type DeleteDcdnDeliverTaskRequest struct {
	// The IDs of the tracking tasks that you want to delete. You can call the [DescribeCdnDeliverList](~~270043~~) operation to query task IDs.
	DeliverId *int64 `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
}

func (s DeleteDcdnDeliverTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnDeliverTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnDeliverTaskRequest) SetDeliverId(v int64) *DeleteDcdnDeliverTaskRequest {
	s.DeliverId = &v
	return s
}

type DeleteDcdnDeliverTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnDeliverTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnDeliverTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnDeliverTaskResponseBody) SetRequestId(v string) *DeleteDcdnDeliverTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnDeliverTaskResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnDeliverTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnDeliverTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnDeliverTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnDeliverTaskResponse) SetHeaders(v map[string]*string) *DeleteDcdnDeliverTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnDeliverTaskResponse) SetStatusCode(v int32) *DeleteDcdnDeliverTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnDeliverTaskResponse) SetBody(v *DeleteDcdnDeliverTaskResponseBody) *DeleteDcdnDeliverTaskResponse {
	s.Body = v
	return s
}

type DeleteDcdnDomainRequest struct {
	// The accelerated domain name to be deleted. You can specify only one domain name.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnDomainRequest) SetDomainName(v string) *DeleteDcdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteDcdnDomainRequest) SetOwnerAccount(v string) *DeleteDcdnDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteDcdnDomainRequest) SetOwnerId(v int64) *DeleteDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDcdnDomainRequest) SetSecurityToken(v string) *DeleteDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type DeleteDcdnDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnDomainResponseBody) SetRequestId(v string) *DeleteDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnDomainResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnDomainResponse) SetHeaders(v map[string]*string) *DeleteDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnDomainResponse) SetStatusCode(v int32) *DeleteDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnDomainResponse) SetBody(v *DeleteDcdnDomainResponseBody) *DeleteDcdnDomainResponse {
	s.Body = v
	return s
}

type DeleteDcdnIpaDomainRequest struct {
	// The accelerated domain name that you want to delete. You can specify only one accelerated domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteDcdnIpaDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnIpaDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnIpaDomainRequest) SetDomainName(v string) *DeleteDcdnIpaDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteDcdnIpaDomainRequest) SetOwnerAccount(v string) *DeleteDcdnIpaDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteDcdnIpaDomainRequest) SetOwnerId(v int64) *DeleteDcdnIpaDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDcdnIpaDomainRequest) SetSecurityToken(v string) *DeleteDcdnIpaDomainRequest {
	s.SecurityToken = &v
	return s
}

type DeleteDcdnIpaDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnIpaDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnIpaDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnIpaDomainResponseBody) SetRequestId(v string) *DeleteDcdnIpaDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnIpaDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnIpaDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnIpaDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnIpaDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnIpaDomainResponse) SetHeaders(v map[string]*string) *DeleteDcdnIpaDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnIpaDomainResponse) SetStatusCode(v int32) *DeleteDcdnIpaDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnIpaDomainResponse) SetBody(v *DeleteDcdnIpaDomainResponseBody) *DeleteDcdnIpaDomainResponse {
	s.Body = v
	return s
}

type DeleteDcdnIpaSpecificConfigRequest struct {
	// The ID of the configuration. You can call the [DescribeDcdnDomainConfigs](~~130625~~) operation to query configuration IDs.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteDcdnIpaSpecificConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnIpaSpecificConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnIpaSpecificConfigRequest) SetConfigId(v string) *DeleteDcdnIpaSpecificConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *DeleteDcdnIpaSpecificConfigRequest) SetDomainName(v string) *DeleteDcdnIpaSpecificConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteDcdnIpaSpecificConfigRequest) SetOwnerId(v int64) *DeleteDcdnIpaSpecificConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDcdnIpaSpecificConfigRequest) SetSecurityToken(v string) *DeleteDcdnIpaSpecificConfigRequest {
	s.SecurityToken = &v
	return s
}

type DeleteDcdnIpaSpecificConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnIpaSpecificConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnIpaSpecificConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnIpaSpecificConfigResponseBody) SetRequestId(v string) *DeleteDcdnIpaSpecificConfigResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnIpaSpecificConfigResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnIpaSpecificConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnIpaSpecificConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnIpaSpecificConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnIpaSpecificConfigResponse) SetHeaders(v map[string]*string) *DeleteDcdnIpaSpecificConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnIpaSpecificConfigResponse) SetStatusCode(v int32) *DeleteDcdnIpaSpecificConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnIpaSpecificConfigResponse) SetBody(v *DeleteDcdnIpaSpecificConfigResponseBody) *DeleteDcdnIpaSpecificConfigResponse {
	s.Body = v
	return s
}

type DeleteDcdnKvRequest struct {
	// The ID of the request.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The namespace that you specify when you call the PutDcdnKvNamespace operation.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteDcdnKvRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnKvRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnKvRequest) SetKey(v string) *DeleteDcdnKvRequest {
	s.Key = &v
	return s
}

func (s *DeleteDcdnKvRequest) SetNamespace(v string) *DeleteDcdnKvRequest {
	s.Namespace = &v
	return s
}

type DeleteDcdnKvResponseBody struct {
	// The name of the key to delete.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnKvResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnKvResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnKvResponseBody) SetRequestId(v string) *DeleteDcdnKvResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnKvResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnKvResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnKvResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnKvResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnKvResponse) SetHeaders(v map[string]*string) *DeleteDcdnKvResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnKvResponse) SetStatusCode(v int32) *DeleteDcdnKvResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnKvResponse) SetBody(v *DeleteDcdnKvResponseBody) *DeleteDcdnKvResponse {
	s.Body = v
	return s
}

type DeleteDcdnKvNamespaceRequest struct {
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteDcdnKvNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnKvNamespaceRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnKvNamespaceRequest) SetNamespace(v string) *DeleteDcdnKvNamespaceRequest {
	s.Namespace = &v
	return s
}

type DeleteDcdnKvNamespaceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnKvNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnKvNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnKvNamespaceResponseBody) SetRequestId(v string) *DeleteDcdnKvNamespaceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnKvNamespaceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnKvNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnKvNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnKvNamespaceResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnKvNamespaceResponse) SetHeaders(v map[string]*string) *DeleteDcdnKvNamespaceResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnKvNamespaceResponse) SetStatusCode(v int32) *DeleteDcdnKvNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnKvNamespaceResponse) SetBody(v *DeleteDcdnKvNamespaceResponseBody) *DeleteDcdnKvNamespaceResponse {
	s.Body = v
	return s
}

type DeleteDcdnRealTimeLogProjectRequest struct {
	// The name of a real-time log delivery project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s DeleteDcdnRealTimeLogProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnRealTimeLogProjectRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnRealTimeLogProjectRequest) SetProjectName(v string) *DeleteDcdnRealTimeLogProjectRequest {
	s.ProjectName = &v
	return s
}

type DeleteDcdnRealTimeLogProjectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnRealTimeLogProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnRealTimeLogProjectResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnRealTimeLogProjectResponseBody) SetRequestId(v string) *DeleteDcdnRealTimeLogProjectResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnRealTimeLogProjectResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnRealTimeLogProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnRealTimeLogProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnRealTimeLogProjectResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnRealTimeLogProjectResponse) SetHeaders(v map[string]*string) *DeleteDcdnRealTimeLogProjectResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnRealTimeLogProjectResponse) SetStatusCode(v int32) *DeleteDcdnRealTimeLogProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnRealTimeLogProjectResponse) SetBody(v *DeleteDcdnRealTimeLogProjectResponseBody) *DeleteDcdnRealTimeLogProjectResponse {
	s.Body = v
	return s
}

type DeleteDcdnSpecificConfigRequest struct {
	// The ID of the configuration. Separate multiple configuration IDs with commas (,). For more information about ConfigId, see [Usage notes on ConfigId](~~410558~~).
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. You can specify only one domain name.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteDcdnSpecificConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSpecificConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSpecificConfigRequest) SetConfigId(v string) *DeleteDcdnSpecificConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *DeleteDcdnSpecificConfigRequest) SetDomainName(v string) *DeleteDcdnSpecificConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteDcdnSpecificConfigRequest) SetOwnerId(v int64) *DeleteDcdnSpecificConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDcdnSpecificConfigRequest) SetSecurityToken(v string) *DeleteDcdnSpecificConfigRequest {
	s.SecurityToken = &v
	return s
}

type DeleteDcdnSpecificConfigResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnSpecificConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSpecificConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSpecificConfigResponseBody) SetRequestId(v string) *DeleteDcdnSpecificConfigResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnSpecificConfigResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnSpecificConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnSpecificConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSpecificConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSpecificConfigResponse) SetHeaders(v map[string]*string) *DeleteDcdnSpecificConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnSpecificConfigResponse) SetStatusCode(v int32) *DeleteDcdnSpecificConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnSpecificConfigResponse) SetBody(v *DeleteDcdnSpecificConfigResponseBody) *DeleteDcdnSpecificConfigResponse {
	s.Body = v
	return s
}

type DeleteDcdnSpecificStagingConfigRequest struct {
	// The ID of the configuration to be deleted. You can specify multiple configuration IDs and separate them with commas (,).
	//
	// You can call the DescribeDcdnDomainStagingConfig operation to query the environment configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. You can specify only one domain name in each call.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteDcdnSpecificStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSpecificStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSpecificStagingConfigRequest) SetConfigId(v string) *DeleteDcdnSpecificStagingConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *DeleteDcdnSpecificStagingConfigRequest) SetDomainName(v string) *DeleteDcdnSpecificStagingConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteDcdnSpecificStagingConfigRequest) SetOwnerId(v int64) *DeleteDcdnSpecificStagingConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDcdnSpecificStagingConfigRequest) SetSecurityToken(v string) *DeleteDcdnSpecificStagingConfigRequest {
	s.SecurityToken = &v
	return s
}

type DeleteDcdnSpecificStagingConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnSpecificStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSpecificStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSpecificStagingConfigResponseBody) SetRequestId(v string) *DeleteDcdnSpecificStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnSpecificStagingConfigResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnSpecificStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnSpecificStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSpecificStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSpecificStagingConfigResponse) SetHeaders(v map[string]*string) *DeleteDcdnSpecificStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnSpecificStagingConfigResponse) SetStatusCode(v int32) *DeleteDcdnSpecificStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnSpecificStagingConfigResponse) SetBody(v *DeleteDcdnSpecificStagingConfigResponseBody) *DeleteDcdnSpecificStagingConfigResponse {
	s.Body = v
	return s
}

type DeleteDcdnSubTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnSubTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSubTaskResponseBody) SetRequestId(v string) *DeleteDcdnSubTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnSubTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnSubTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnSubTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnSubTaskResponse) SetHeaders(v map[string]*string) *DeleteDcdnSubTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnSubTaskResponse) SetStatusCode(v int32) *DeleteDcdnSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnSubTaskResponse) SetBody(v *DeleteDcdnSubTaskResponseBody) *DeleteDcdnSubTaskResponse {
	s.Body = v
	return s
}

type DeleteDcdnWafGroupRequest struct {
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteDcdnWafGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnWafGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnWafGroupRequest) SetId(v int64) *DeleteDcdnWafGroupRequest {
	s.Id = &v
	return s
}

type DeleteDcdnWafGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnWafGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnWafGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnWafGroupResponseBody) SetRequestId(v string) *DeleteDcdnWafGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnWafGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnWafGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnWafGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnWafGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnWafGroupResponse) SetHeaders(v map[string]*string) *DeleteDcdnWafGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnWafGroupResponse) SetStatusCode(v int32) *DeleteDcdnWafGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnWafGroupResponse) SetBody(v *DeleteDcdnWafGroupResponseBody) *DeleteDcdnWafGroupResponse {
	s.Body = v
	return s
}

type DeleteDcdnWafPolicyRequest struct {
	// The ID of the protection policy that you want to delete. You can specify only one ID in each request.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s DeleteDcdnWafPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnWafPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteDcdnWafPolicyRequest) SetPolicyId(v int64) *DeleteDcdnWafPolicyRequest {
	s.PolicyId = &v
	return s
}

type DeleteDcdnWafPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDcdnWafPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnWafPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDcdnWafPolicyResponseBody) SetRequestId(v string) *DeleteDcdnWafPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDcdnWafPolicyResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDcdnWafPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDcdnWafPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDcdnWafPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteDcdnWafPolicyResponse) SetHeaders(v map[string]*string) *DeleteDcdnWafPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteDcdnWafPolicyResponse) SetStatusCode(v int32) *DeleteDcdnWafPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDcdnWafPolicyResponse) SetBody(v *DeleteDcdnWafPolicyResponseBody) *DeleteDcdnWafPolicyResponse {
	s.Body = v
	return s
}

type DeleteRoutineRequest struct {
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DeleteRoutineRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineRequest) GoString() string {
	return s.String()
}

func (s *DeleteRoutineRequest) SetName(v string) *DeleteRoutineRequest {
	s.Name = &v
	return s
}

type DeleteRoutineResponseBody struct {
	// The message returned, such as ""Status": "OK"".
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRoutineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRoutineResponseBody) SetContent(v map[string]interface{}) *DeleteRoutineResponseBody {
	s.Content = v
	return s
}

func (s *DeleteRoutineResponseBody) SetRequestId(v string) *DeleteRoutineResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRoutineResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRoutineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRoutineResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineResponse) GoString() string {
	return s.String()
}

func (s *DeleteRoutineResponse) SetHeaders(v map[string]*string) *DeleteRoutineResponse {
	s.Headers = v
	return s
}

func (s *DeleteRoutineResponse) SetStatusCode(v int32) *DeleteRoutineResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRoutineResponse) SetBody(v *DeleteRoutineResponseBody) *DeleteRoutineResponse {
	s.Body = v
	return s
}

type DeleteRoutineCodeRevisionRequest struct {
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the version that you want to delete.
	SelectCodeRevision *string `json:"SelectCodeRevision,omitempty" xml:"SelectCodeRevision,omitempty"`
}

func (s DeleteRoutineCodeRevisionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineCodeRevisionRequest) GoString() string {
	return s.String()
}

func (s *DeleteRoutineCodeRevisionRequest) SetName(v string) *DeleteRoutineCodeRevisionRequest {
	s.Name = &v
	return s
}

func (s *DeleteRoutineCodeRevisionRequest) SetSelectCodeRevision(v string) *DeleteRoutineCodeRevisionRequest {
	s.SelectCodeRevision = &v
	return s
}

type DeleteRoutineCodeRevisionResponseBody struct {
	// The message returned, such as ""Status": "OK"".
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRoutineCodeRevisionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineCodeRevisionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRoutineCodeRevisionResponseBody) SetContent(v map[string]interface{}) *DeleteRoutineCodeRevisionResponseBody {
	s.Content = v
	return s
}

func (s *DeleteRoutineCodeRevisionResponseBody) SetRequestId(v string) *DeleteRoutineCodeRevisionResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRoutineCodeRevisionResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRoutineCodeRevisionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRoutineCodeRevisionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineCodeRevisionResponse) GoString() string {
	return s.String()
}

func (s *DeleteRoutineCodeRevisionResponse) SetHeaders(v map[string]*string) *DeleteRoutineCodeRevisionResponse {
	s.Headers = v
	return s
}

func (s *DeleteRoutineCodeRevisionResponse) SetStatusCode(v int32) *DeleteRoutineCodeRevisionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRoutineCodeRevisionResponse) SetBody(v *DeleteRoutineCodeRevisionResponseBody) *DeleteRoutineCodeRevisionResponse {
	s.Body = v
	return s
}

type DeleteRoutineConfEnvsRequest struct {
	// The custom canary release environments that you want to delete.
	Envs map[string]interface{} `json:"Envs,omitempty" xml:"Envs,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DeleteRoutineConfEnvsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineConfEnvsRequest) GoString() string {
	return s.String()
}

func (s *DeleteRoutineConfEnvsRequest) SetEnvs(v map[string]interface{}) *DeleteRoutineConfEnvsRequest {
	s.Envs = v
	return s
}

func (s *DeleteRoutineConfEnvsRequest) SetName(v string) *DeleteRoutineConfEnvsRequest {
	s.Name = &v
	return s
}

type DeleteRoutineConfEnvsShrinkRequest struct {
	// The custom canary release environments that you want to delete.
	EnvsShrink *string `json:"Envs,omitempty" xml:"Envs,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DeleteRoutineConfEnvsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineConfEnvsShrinkRequest) GoString() string {
	return s.String()
}

func (s *DeleteRoutineConfEnvsShrinkRequest) SetEnvsShrink(v string) *DeleteRoutineConfEnvsShrinkRequest {
	s.EnvsShrink = &v
	return s
}

func (s *DeleteRoutineConfEnvsShrinkRequest) SetName(v string) *DeleteRoutineConfEnvsShrinkRequest {
	s.Name = &v
	return s
}

type DeleteRoutineConfEnvsResponseBody struct {
	// The message returned, such as ""Status": "OK"".
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRoutineConfEnvsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineConfEnvsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRoutineConfEnvsResponseBody) SetContent(v map[string]interface{}) *DeleteRoutineConfEnvsResponseBody {
	s.Content = v
	return s
}

func (s *DeleteRoutineConfEnvsResponseBody) SetRequestId(v string) *DeleteRoutineConfEnvsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRoutineConfEnvsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRoutineConfEnvsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRoutineConfEnvsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoutineConfEnvsResponse) GoString() string {
	return s.String()
}

func (s *DeleteRoutineConfEnvsResponse) SetHeaders(v map[string]*string) *DeleteRoutineConfEnvsResponse {
	s.Headers = v
	return s
}

func (s *DeleteRoutineConfEnvsResponse) SetStatusCode(v int32) *DeleteRoutineConfEnvsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRoutineConfEnvsResponse) SetBody(v *DeleteRoutineConfEnvsResponseBody) *DeleteRoutineConfEnvsResponse {
	s.Body = v
	return s
}

type DescribeDcdnAclFieldsRequest struct {
	// The access language. Default value: en. Valid values:
	//
	// *   **en**: English
	// *   **zh**: Chinese
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDcdnAclFieldsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnAclFieldsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnAclFieldsRequest) SetLang(v string) *DescribeDcdnAclFieldsRequest {
	s.Lang = &v
	return s
}

type DescribeDcdnAclFieldsResponseBody struct {
	// The details about the rules.
	Content []*DescribeDcdnAclFieldsResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnAclFieldsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnAclFieldsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnAclFieldsResponseBody) SetContent(v []*DescribeDcdnAclFieldsResponseBodyContent) *DescribeDcdnAclFieldsResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnAclFieldsResponseBody) SetRequestId(v string) *DescribeDcdnAclFieldsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnAclFieldsResponseBodyContent struct {
	// The rules and policies that were configured. The JSON string is decoded.
	Fields *string `json:"Fields,omitempty" xml:"Fields,omitempty"`
}

func (s DescribeDcdnAclFieldsResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnAclFieldsResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnAclFieldsResponseBodyContent) SetFields(v string) *DescribeDcdnAclFieldsResponseBodyContent {
	s.Fields = &v
	return s
}

type DescribeDcdnAclFieldsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnAclFieldsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnAclFieldsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnAclFieldsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnAclFieldsResponse) SetHeaders(v map[string]*string) *DescribeDcdnAclFieldsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnAclFieldsResponse) SetStatusCode(v int32) *DescribeDcdnAclFieldsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnAclFieldsResponse) SetBody(v *DescribeDcdnAclFieldsResponseBody) *DescribeDcdnAclFieldsResponse {
	s.Body = v
	return s
}

type DescribeDcdnBgpBpsDataRequest struct {
	// The name of the device. If you specify this parameter, the data of the device is returned. Otherwise, the data of all devices is returned.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The port of the device. If you specify this parameter, the data of the port is returned. Otherwise, the data of all ports is returned. This parameter takes effect only when the **DeviceName** parameter is specified.
	DevicePort *string `json:"DevicePort,omitempty" xml:"DevicePort,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The data collection interval. Unit: seconds. Valid values: 300 and 3600. Default value: 300. The default value of 300 seconds is equal to 5 minutes. The value of this parameter varies based on the time range from the specified start time to the specified end time.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The ISPs. If you need to specify multiple ISPs, separate them with commas (,). If you specify multiple ISPs, the data for the ISPs is aggregated. If you do not specify this parameter, the operation returns the data for all the ISPs.
	//
	// Valid values:
	//
	// *   cu: China Unicom
	// *   cmi: China Mobile
	// *   ct: China Telecom
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum data collection interval is an hour.
	//
	// If you do not set this parameter, data collected in the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnBgpBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpBpsDataRequest) SetDeviceName(v string) *DescribeDcdnBgpBpsDataRequest {
	s.DeviceName = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataRequest) SetDevicePort(v string) *DescribeDcdnBgpBpsDataRequest {
	s.DevicePort = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataRequest) SetEndTime(v string) *DescribeDcdnBgpBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataRequest) SetInterval(v string) *DescribeDcdnBgpBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataRequest) SetIsp(v string) *DescribeDcdnBgpBpsDataRequest {
	s.Isp = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataRequest) SetStartTime(v string) *DescribeDcdnBgpBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnBgpBpsDataResponseBody struct {
	// The BGP bandwidth data that is collected for each interval.
	BgpDataInterval []*DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval `json:"BgpDataInterval,omitempty" xml:"BgpDataInterval,omitempty" type:"Repeated"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnBgpBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpBpsDataResponseBody) SetBgpDataInterval(v []*DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval) *DescribeDcdnBgpBpsDataResponseBody {
	s.BgpDataInterval = v
	return s
}

func (s *DescribeDcdnBgpBpsDataResponseBody) SetEndTime(v string) *DescribeDcdnBgpBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataResponseBody) SetRequestId(v string) *DescribeDcdnBgpBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataResponseBody) SetStartTime(v string) *DescribeDcdnBgpBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval struct {
	// The inbound bandwidth. Unit: bit/s.
	In *float32 `json:"In,omitempty" xml:"In,omitempty"`
	// The outbound bandwidth. Unit: bit/s.
	Out *float32 `json:"Out,omitempty" xml:"Out,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval) SetIn(v float32) *DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval {
	s.In = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval) SetOut(v float32) *DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval {
	s.Out = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval) SetTimeStamp(v string) *DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnBgpBpsDataResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnBgpBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnBgpBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnBgpBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnBgpBpsDataResponse) SetStatusCode(v int32) *DescribeDcdnBgpBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnBgpBpsDataResponse) SetBody(v *DescribeDcdnBgpBpsDataResponseBody) *DescribeDcdnBgpBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnBgpTrafficDataRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The data collection interval. Unit: seconds. Valid values: 300 and 3600. Default value: 300. The default value of 300 seconds is equal to 5 minutes. The value of this parameter varies based on the time range from the specified start time to the specified end time.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The ISP. Separate multiple ISPs with commas (,). If you specify multiple ISPs, the data for the ISPs is aggregated. If you do not specify this parameter, the operation returns the data for all the ISPs.
	//
	// Valid values:
	//
	// *   cu: China Unicom
	// *   cmi: China Mobile
	// *   ct: China Telecom
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum data collection interval is an hour.
	//
	// If you do not set this parameter, data collected in the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnBgpTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpTrafficDataRequest) SetEndTime(v string) *DescribeDcdnBgpTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataRequest) SetInterval(v string) *DescribeDcdnBgpTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataRequest) SetIsp(v string) *DescribeDcdnBgpTrafficDataRequest {
	s.Isp = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataRequest) SetStartTime(v string) *DescribeDcdnBgpTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnBgpTrafficDataResponseBody struct {
	// The BGP traffic at each time interval.
	BgpDataInterval []*DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval `json:"BgpDataInterval,omitempty" xml:"BgpDataInterval,omitempty" type:"Repeated"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnBgpTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpTrafficDataResponseBody) SetBgpDataInterval(v []*DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval) *DescribeDcdnBgpTrafficDataResponseBody {
	s.BgpDataInterval = v
	return s
}

func (s *DescribeDcdnBgpTrafficDataResponseBody) SetEndTime(v string) *DescribeDcdnBgpTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataResponseBody) SetRequestId(v string) *DescribeDcdnBgpTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataResponseBody) SetStartTime(v string) *DescribeDcdnBgpTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval struct {
	// The inbound traffic. Unit: bytes.
	In *int64 `json:"In,omitempty" xml:"In,omitempty"`
	// The outbound traffic. Unit: bytes.
	Out *int64 `json:"Out,omitempty" xml:"Out,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval) SetIn(v int64) *DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval {
	s.In = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval) SetOut(v int64) *DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval {
	s.Out = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval) SetTimeStamp(v string) *DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnBgpTrafficDataResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnBgpTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnBgpTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBgpTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBgpTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnBgpTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnBgpTrafficDataResponse) SetStatusCode(v int32) *DescribeDcdnBgpTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnBgpTrafficDataResponse) SetBody(v *DescribeDcdnBgpTrafficDataResponseBody) *DescribeDcdnBgpTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnBlockedRegionsRequest struct {
	// The language. Valid values: zh, en, and jp.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
}

func (s DescribeDcdnBlockedRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBlockedRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBlockedRegionsRequest) SetLanguage(v string) *DescribeDcdnBlockedRegionsRequest {
	s.Language = &v
	return s
}

type DescribeDcdnBlockedRegionsResponseBody struct {
	// The information about the country or region.
	InfoList *DescribeDcdnBlockedRegionsResponseBodyInfoList `json:"InfoList,omitempty" xml:"InfoList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnBlockedRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBlockedRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBlockedRegionsResponseBody) SetInfoList(v *DescribeDcdnBlockedRegionsResponseBodyInfoList) *DescribeDcdnBlockedRegionsResponseBody {
	s.InfoList = v
	return s
}

func (s *DescribeDcdnBlockedRegionsResponseBody) SetRequestId(v string) *DescribeDcdnBlockedRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnBlockedRegionsResponseBodyInfoList struct {
	InfoItem []*DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem `json:"InfoItem,omitempty" xml:"InfoItem,omitempty" type:"Repeated"`
}

func (s DescribeDcdnBlockedRegionsResponseBodyInfoList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBlockedRegionsResponseBodyInfoList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBlockedRegionsResponseBodyInfoList) SetInfoItem(v []*DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem) *DescribeDcdnBlockedRegionsResponseBodyInfoList {
	s.InfoItem = v
	return s
}

type DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem struct {
	// The larger region to which the country or region belongs.
	Continent *string `json:"Continent,omitempty" xml:"Continent,omitempty"`
	// The abbreviation of the name of the country or region.
	CountriesAndRegions *string `json:"CountriesAndRegions,omitempty" xml:"CountriesAndRegions,omitempty"`
	// The name of the country or region.
	CountriesAndRegionsName *string `json:"CountriesAndRegionsName,omitempty" xml:"CountriesAndRegionsName,omitempty"`
}

func (s DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem) SetContinent(v string) *DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem {
	s.Continent = &v
	return s
}

func (s *DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem) SetCountriesAndRegions(v string) *DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem {
	s.CountriesAndRegions = &v
	return s
}

func (s *DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem) SetCountriesAndRegionsName(v string) *DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem {
	s.CountriesAndRegionsName = &v
	return s
}

type DescribeDcdnBlockedRegionsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnBlockedRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnBlockedRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnBlockedRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnBlockedRegionsResponse) SetHeaders(v map[string]*string) *DescribeDcdnBlockedRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnBlockedRegionsResponse) SetStatusCode(v int32) *DescribeDcdnBlockedRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnBlockedRegionsResponse) SetBody(v *DescribeDcdnBlockedRegionsResponseBody) *DescribeDcdnBlockedRegionsResponse {
	s.Body = v
	return s
}

type DescribeDcdnCertificateDetailRequest struct {
	// The name of the certificate.
	CertName      *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnCertificateDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateDetailRequest) SetCertName(v string) *DescribeDcdnCertificateDetailRequest {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnCertificateDetailRequest) SetOwnerId(v int64) *DescribeDcdnCertificateDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnCertificateDetailRequest) SetSecurityToken(v string) *DescribeDcdnCertificateDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnCertificateDetailResponseBody struct {
	// The content of the certificate.
	Cert *string `json:"Cert,omitempty" xml:"Cert,omitempty"`
	// The ID of the certificate.
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The key of the certificate.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnCertificateDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateDetailResponseBody) SetCert(v string) *DescribeDcdnCertificateDetailResponseBody {
	s.Cert = &v
	return s
}

func (s *DescribeDcdnCertificateDetailResponseBody) SetCertId(v int64) *DescribeDcdnCertificateDetailResponseBody {
	s.CertId = &v
	return s
}

func (s *DescribeDcdnCertificateDetailResponseBody) SetCertName(v string) *DescribeDcdnCertificateDetailResponseBody {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnCertificateDetailResponseBody) SetKey(v string) *DescribeDcdnCertificateDetailResponseBody {
	s.Key = &v
	return s
}

func (s *DescribeDcdnCertificateDetailResponseBody) SetRequestId(v string) *DescribeDcdnCertificateDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnCertificateDetailResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnCertificateDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnCertificateDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateDetailResponse) SetHeaders(v map[string]*string) *DescribeDcdnCertificateDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnCertificateDetailResponse) SetStatusCode(v int32) *DescribeDcdnCertificateDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnCertificateDetailResponse) SetBody(v *DescribeDcdnCertificateDetailResponseBody) *DescribeDcdnCertificateDetailResponse {
	s.Body = v
	return s
}

type DescribeDcdnCertificateListRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	//
	// By default, this operation queries the certificates of all accelerated domain names.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnCertificateListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateListRequest) SetDomainName(v string) *DescribeDcdnCertificateListRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnCertificateListRequest) SetOwnerId(v int64) *DescribeDcdnCertificateListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnCertificateListRequest) SetSecurityToken(v string) *DescribeDcdnCertificateListRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnCertificateListResponseBody struct {
	// Details about certificates.
	CertificateListModel *DescribeDcdnCertificateListResponseBodyCertificateListModel `json:"CertificateListModel,omitempty" xml:"CertificateListModel,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnCertificateListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateListResponseBody) SetCertificateListModel(v *DescribeDcdnCertificateListResponseBodyCertificateListModel) *DescribeDcdnCertificateListResponseBody {
	s.CertificateListModel = v
	return s
}

func (s *DescribeDcdnCertificateListResponseBody) SetRequestId(v string) *DescribeDcdnCertificateListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnCertificateListResponseBodyCertificateListModel struct {
	// Details about each certificate.
	CertList *DescribeDcdnCertificateListResponseBodyCertificateListModelCertList `json:"CertList,omitempty" xml:"CertList,omitempty" type:"Struct"`
	// The number of certificates.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s DescribeDcdnCertificateListResponseBodyCertificateListModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateListResponseBodyCertificateListModel) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModel) SetCertList(v *DescribeDcdnCertificateListResponseBodyCertificateListModelCertList) *DescribeDcdnCertificateListResponseBodyCertificateListModel {
	s.CertList = v
	return s
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModel) SetCount(v int32) *DescribeDcdnCertificateListResponseBodyCertificateListModel {
	s.Count = &v
	return s
}

type DescribeDcdnCertificateListResponseBodyCertificateListModelCertList struct {
	Cert []*DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert `json:"Cert,omitempty" xml:"Cert,omitempty" type:"Repeated"`
}

func (s DescribeDcdnCertificateListResponseBodyCertificateListModelCertList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateListResponseBodyCertificateListModelCertList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModelCertList) SetCert(v []*DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) *DescribeDcdnCertificateListResponseBodyCertificateListModelCertList {
	s.Cert = v
	return s
}

type DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert struct {
	// The ID of the certificate.
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The Common Name (CN) attribute of the certificate. In most cases, the CN is a domain name.
	Common *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// The fingerprint of the certificate.
	Fingerprint *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The timestamp.
	LastTime *int64 `json:"LastTime,omitempty" xml:"LastTime,omitempty"`
}

func (s DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) SetCertId(v int64) *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertId = &v
	return s
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) SetCertName(v string) *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) SetCommon(v string) *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.Common = &v
	return s
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) SetFingerprint(v string) *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.Fingerprint = &v
	return s
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) SetIssuer(v string) *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.Issuer = &v
	return s
}

func (s *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert) SetLastTime(v int64) *DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert {
	s.LastTime = &v
	return s
}

type DescribeDcdnCertificateListResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnCertificateListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnCertificateListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnCertificateListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnCertificateListResponse) SetHeaders(v map[string]*string) *DescribeDcdnCertificateListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnCertificateListResponse) SetStatusCode(v int32) *DescribeDcdnCertificateListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnCertificateListResponse) SetBody(v *DescribeDcdnCertificateListResponseBody) *DescribeDcdnCertificateListResponse {
	s.Body = v
	return s
}

type DescribeDcdnDdosServiceRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnDdosServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDdosServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDdosServiceRequest) SetOwnerId(v int64) *DescribeDcdnDdosServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnDdosServiceRequest) SetSecurityToken(v string) *DescribeDcdnDdosServiceRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnDdosServiceResponseBody struct {
	ChangingAffectTime *string `json:"ChangingAffectTime,omitempty" xml:"ChangingAffectTime,omitempty"`
	ChangingChargeType *string `json:"ChangingChargeType,omitempty" xml:"ChangingChargeType,omitempty"`
	ChangingDomianNum  *int32  `json:"ChangingDomianNum,omitempty" xml:"ChangingDomianNum,omitempty"`
	ChangingEdition    *string `json:"ChangingEdition,omitempty" xml:"ChangingEdition,omitempty"`
	ChangingProtectNum *int32  `json:"ChangingProtectNum,omitempty" xml:"ChangingProtectNum,omitempty"`
	ChargeType         *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	DomianNum          *int32  `json:"DomianNum,omitempty" xml:"DomianNum,omitempty"`
	Edition            *string `json:"Edition,omitempty" xml:"Edition,omitempty"`
	Enabled            *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	EndingTime         *string `json:"EndingTime,omitempty" xml:"EndingTime,omitempty"`
	InstanceId         *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OpeningTime        *string `json:"OpeningTime,omitempty" xml:"OpeningTime,omitempty"`
	ProtectNum         *int32  `json:"ProtectNum,omitempty" xml:"ProtectNum,omitempty"`
	RequestId          *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Status             *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnDdosServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDdosServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDdosServiceResponseBody) SetChangingAffectTime(v string) *DescribeDcdnDdosServiceResponseBody {
	s.ChangingAffectTime = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetChangingChargeType(v string) *DescribeDcdnDdosServiceResponseBody {
	s.ChangingChargeType = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetChangingDomianNum(v int32) *DescribeDcdnDdosServiceResponseBody {
	s.ChangingDomianNum = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetChangingEdition(v string) *DescribeDcdnDdosServiceResponseBody {
	s.ChangingEdition = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetChangingProtectNum(v int32) *DescribeDcdnDdosServiceResponseBody {
	s.ChangingProtectNum = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetChargeType(v string) *DescribeDcdnDdosServiceResponseBody {
	s.ChargeType = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetDomianNum(v int32) *DescribeDcdnDdosServiceResponseBody {
	s.DomianNum = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetEdition(v string) *DescribeDcdnDdosServiceResponseBody {
	s.Edition = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetEnabled(v string) *DescribeDcdnDdosServiceResponseBody {
	s.Enabled = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetEndingTime(v string) *DescribeDcdnDdosServiceResponseBody {
	s.EndingTime = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetInstanceId(v string) *DescribeDcdnDdosServiceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetOpeningTime(v string) *DescribeDcdnDdosServiceResponseBody {
	s.OpeningTime = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetProtectNum(v int32) *DescribeDcdnDdosServiceResponseBody {
	s.ProtectNum = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetRequestId(v string) *DescribeDcdnDdosServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponseBody) SetStatus(v string) *DescribeDcdnDdosServiceResponseBody {
	s.Status = &v
	return s
}

type DescribeDcdnDdosServiceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDdosServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDdosServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDdosServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDdosServiceResponse) SetHeaders(v map[string]*string) *DescribeDcdnDdosServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDdosServiceResponse) SetStatusCode(v int32) *DescribeDcdnDdosServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDdosServiceResponse) SetBody(v *DescribeDcdnDdosServiceResponseBody) *DescribeDcdnDdosServiceResponse {
	s.Body = v
	return s
}

type DescribeDcdnDdosSpecInfoResponseBody struct {
	BandwidthLimit *string                                          `json:"BandwidthLimit,omitempty" xml:"BandwidthLimit,omitempty"`
	Edition        *string                                          `json:"Edition,omitempty" xml:"Edition,omitempty"`
	Enable         *string                                          `json:"Enable,omitempty" xml:"Enable,omitempty"`
	ProtectedArea  *string                                          `json:"ProtectedArea,omitempty" xml:"ProtectedArea,omitempty"`
	QpsLimit       *string                                          `json:"QpsLimit,omitempty" xml:"QpsLimit,omitempty"`
	RequestId      *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SpecInfos      []*DescribeDcdnDdosSpecInfoResponseBodySpecInfos `json:"SpecInfos,omitempty" xml:"SpecInfos,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDdosSpecInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDdosSpecInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDdosSpecInfoResponseBody) SetBandwidthLimit(v string) *DescribeDcdnDdosSpecInfoResponseBody {
	s.BandwidthLimit = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBody) SetEdition(v string) *DescribeDcdnDdosSpecInfoResponseBody {
	s.Edition = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBody) SetEnable(v string) *DescribeDcdnDdosSpecInfoResponseBody {
	s.Enable = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBody) SetProtectedArea(v string) *DescribeDcdnDdosSpecInfoResponseBody {
	s.ProtectedArea = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBody) SetQpsLimit(v string) *DescribeDcdnDdosSpecInfoResponseBody {
	s.QpsLimit = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBody) SetRequestId(v string) *DescribeDcdnDdosSpecInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBody) SetSpecInfos(v []*DescribeDcdnDdosSpecInfoResponseBodySpecInfos) *DescribeDcdnDdosSpecInfoResponseBody {
	s.SpecInfos = v
	return s
}

type DescribeDcdnDdosSpecInfoResponseBodySpecInfos struct {
	Configs []*DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Repeated"`
	Rule    *string                                                 `json:"Rule,omitempty" xml:"Rule,omitempty"`
}

func (s DescribeDcdnDdosSpecInfoResponseBodySpecInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDdosSpecInfoResponseBodySpecInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDdosSpecInfoResponseBodySpecInfos) SetConfigs(v []*DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs) *DescribeDcdnDdosSpecInfoResponseBodySpecInfos {
	s.Configs = v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBodySpecInfos) SetRule(v string) *DescribeDcdnDdosSpecInfoResponseBodySpecInfos {
	s.Rule = &v
	return s
}

type DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs struct {
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	Expr   *string `json:"Expr,omitempty" xml:"Expr,omitempty"`
	Value  *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs) SetConfig(v string) *DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs {
	s.Config = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs) SetExpr(v string) *DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs {
	s.Expr = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs) SetValue(v string) *DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs {
	s.Value = &v
	return s
}

type DescribeDcdnDdosSpecInfoResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDdosSpecInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDdosSpecInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDdosSpecInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDdosSpecInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnDdosSpecInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponse) SetStatusCode(v int32) *DescribeDcdnDdosSpecInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDdosSpecInfoResponse) SetBody(v *DescribeDcdnDdosSpecInfoResponseBody) *DescribeDcdnDdosSpecInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnDeletedDomainsRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeDcdnDeletedDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeletedDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeletedDomainsRequest) SetPageNumber(v int32) *DescribeDcdnDeletedDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnDeletedDomainsRequest) SetPageSize(v int32) *DescribeDcdnDeletedDomainsRequest {
	s.PageSize = &v
	return s
}

type DescribeDcdnDeletedDomainsResponseBody struct {
	// The information about the accelerated domain name.
	Domains *DescribeDcdnDeletedDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page, which is the same as the **PageNumber** parameter in request parameters.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names returned per page, which is the same as the **PageSize** parameter in request parameters.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnDeletedDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeletedDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeletedDomainsResponseBody) SetDomains(v *DescribeDcdnDeletedDomainsResponseBodyDomains) *DescribeDcdnDeletedDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDcdnDeletedDomainsResponseBody) SetPageNumber(v int64) *DescribeDcdnDeletedDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnDeletedDomainsResponseBody) SetPageSize(v int64) *DescribeDcdnDeletedDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnDeletedDomainsResponseBody) SetRequestId(v string) *DescribeDcdnDeletedDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDeletedDomainsResponseBody) SetTotalCount(v int64) *DescribeDcdnDeletedDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnDeletedDomainsResponseBodyDomains struct {
	PageData []*DescribeDcdnDeletedDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDeletedDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeletedDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeletedDomainsResponseBodyDomains) SetPageData(v []*DescribeDcdnDeletedDomainsResponseBodyDomainsPageData) *DescribeDcdnDeletedDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeDcdnDeletedDomainsResponseBodyDomainsPageData struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The time when the accelerated domain name was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
}

func (s DescribeDcdnDeletedDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeletedDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeletedDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeDcdnDeletedDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDeletedDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeDcdnDeletedDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

type DescribeDcdnDeletedDomainsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDeletedDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDeletedDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeletedDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeletedDomainsResponse) SetHeaders(v map[string]*string) *DescribeDcdnDeletedDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDeletedDomainsResponse) SetStatusCode(v int32) *DescribeDcdnDeletedDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDeletedDomainsResponse) SetBody(v *DescribeDcdnDeletedDomainsResponseBody) *DescribeDcdnDeletedDomainsResponse {
	s.Body = v
	return s
}

type DescribeDcdnDeliverListRequest struct {
	// The ID of the tracking task that you want to query. If you do not specify an ID, all tracking tasks are queried.
	DeliverId *int64 `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
}

func (s DescribeDcdnDeliverListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeliverListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeliverListRequest) SetDeliverId(v int64) *DescribeDcdnDeliverListRequest {
	s.DeliverId = &v
	return s
}

type DescribeDcdnDeliverListResponseBody struct {
	// The information about the tracking task.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDeliverListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeliverListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeliverListResponseBody) SetContent(v string) *DescribeDcdnDeliverListResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeDcdnDeliverListResponseBody) SetRequestId(v string) *DescribeDcdnDeliverListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDeliverListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDeliverListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDeliverListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDeliverListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDeliverListResponse) SetHeaders(v map[string]*string) *DescribeDcdnDeliverListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDeliverListResponse) SetStatusCode(v int32) *DescribeDcdnDeliverListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDeliverListResponse) SetBody(v *DescribeDcdnDeliverListResponseBody) *DescribeDcdnDeliverListResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainBpsDataRequest struct {
	// The accelerated domain name.
	//
	// Separate multiple domain names with commas (,). If you do not specify a value for this parameter, bandwidth data of all accelerated domain names is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs. If you do not specify an ISP, bandwidth data of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions. If you do not specify a region, bandwidth data in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataRequest) SetInterval(v string) *DescribeDcdnDomainBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainBpsDataResponseBody struct {
	// The bandwidth data returned at each interval.
	BpsDataPerInterval *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval `json:"BpsDataPerInterval,omitempty" xml:"BpsDataPerInterval,omitempty" type:"Struct"`
	// The time interval between the data entries returned.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataResponseBody) SetBpsDataPerInterval(v *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval) *DescribeDcdnDomainBpsDataResponseBody {
	s.BpsDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval struct {
	DataModule []*DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval) SetDataModule(v []*DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule struct {
	// The bandwidth value. Unit: bit/s.
	Bps *float32 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The bandwidth that was consumed to deliver dynamic content over HTTP. Unit: bit/s.
	DynamicHttpBps *float32 `json:"DynamicHttpBps,omitempty" xml:"DynamicHttpBps,omitempty"`
	// The bandwidth that was consumed to deliver dynamic content over HTTPS. Unit: bit/s.
	DynamicHttpsBps *float32 `json:"DynamicHttpsBps,omitempty" xml:"DynamicHttpsBps,omitempty"`
	// The bandwidth that was consumed to deliver static content over HTTP. Unit: bit/s.
	StaticHttpBps *float32 `json:"StaticHttpBps,omitempty" xml:"StaticHttpBps,omitempty"`
	// The bandwidth that was consumed to deliver static content over HTTPS. Unit: bit/s.
	StaticHttpsBps *float32 `json:"StaticHttpsBps,omitempty" xml:"StaticHttpsBps,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetBps(v float32) *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.Bps = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetDynamicHttpBps(v float32) *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.DynamicHttpBps = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetDynamicHttpsBps(v float32) *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.DynamicHttpsBps = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetStaticHttpBps(v float32) *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.StaticHttpBps = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetStaticHttpsBps(v float32) *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.StaticHttpsBps = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainBpsDataResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataResponse) SetBody(v *DescribeDcdnDomainBpsDataResponseBody) *DescribeDcdnDomainBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainBpsDataByLayerRequest struct {
	// The accelerated domain name. Separate mutiple domain names with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated.
	//
	// If you do not specify a domain name, data of all domain names is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The Internet service provider (ISP) name. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query the ISP name. If you do not specify this parameter, all ISPs are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The layer at which you want to query the bandwidth data. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all.
	//
	// Default value: all.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The region name. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions. If you do not specify this parameter, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum data granularity is 5 minutes.
	//
	// If you do not set this parameter, data in the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainBpsDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataByLayerRequest) SetDomainName(v string) *DescribeDcdnDomainBpsDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerRequest) SetEndTime(v string) *DescribeDcdnDomainBpsDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerRequest) SetInterval(v string) *DescribeDcdnDomainBpsDataByLayerRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerRequest) SetIspNameEn(v string) *DescribeDcdnDomainBpsDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerRequest) SetLayer(v string) *DescribeDcdnDomainBpsDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerRequest) SetLocationNameEn(v string) *DescribeDcdnDomainBpsDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerRequest) SetStartTime(v string) *DescribeDcdnDomainBpsDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainBpsDataByLayerResponseBody struct {
	// The bandwidth returned at each time interval.
	BpsDataInterval *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval `json:"BpsDataInterval,omitempty" xml:"BpsDataInterval,omitempty" type:"Struct"`
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainBpsDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBody) SetBpsDataInterval(v *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval) *DescribeDcdnDomainBpsDataByLayerResponseBody {
	s.BpsDataInterval = v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBody) SetDataInterval(v string) *DescribeDcdnDomainBpsDataByLayerResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBody) SetRequestId(v string) *DescribeDcdnDomainBpsDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval struct {
	DataModule []*DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval) SetDataModule(v []*DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule struct {
	// The traffic that is used to deliver dynamic content. Unit: bytes.
	DynamicTrafficValue *string `json:"DynamicTrafficValue,omitempty" xml:"DynamicTrafficValue,omitempty"`
	// The bandwidth that is used to deliver dynamic content. Unit: bit/s.
	DynamicValue *string `json:"DynamicValue,omitempty" xml:"DynamicValue,omitempty"`
	// The traffic that is used to deliver static content. Unit: bytes.
	StaticTrafficValue *string `json:"StaticTrafficValue,omitempty" xml:"StaticTrafficValue,omitempty"`
	// The bandwidth that is used to deliver static content. Unit: bit/s.
	StaticValue *string `json:"StaticValue,omitempty" xml:"StaticValue,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total traffic. Unit: bytes.
	TrafficValue *string `json:"TrafficValue,omitempty" xml:"TrafficValue,omitempty"`
	// The total bandwidth. Unit: bit/s.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetDynamicTrafficValue(v string) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.DynamicTrafficValue = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetDynamicValue(v string) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.DynamicValue = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetStaticTrafficValue(v string) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.StaticTrafficValue = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetStaticValue(v string) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.StaticValue = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetTrafficValue(v string) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.TrafficValue = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetValue(v string) *DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDcdnDomainBpsDataByLayerResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainBpsDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainBpsDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainBpsDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainBpsDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainBpsDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponse) SetStatusCode(v int32) *DescribeDcdnDomainBpsDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainBpsDataByLayerResponse) SetBody(v *DescribeDcdnDomainBpsDataByLayerResponseBody) *DescribeDcdnDomainBpsDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainByCertificateRequest struct {
	// Specifies whether the domain name list to return match the SSL certificate.
	//
	// - **true**: The domain name list match the SSL certificate.
	// - **false**: The domain name list do not match the SSL certificate.
	Exact *bool `json:"Exact,omitempty" xml:"Exact,omitempty"`
	// The public key of the certificate.
	//
	// You must use Base64 encoding schemes and then the encodeURIComponent method to encode the public key. PEM files are supported.
	SSLPub *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	// Specifies whether the domain name list to return contains only domain names with HTTPS enabled or disabled.
	//
	// *   true: The list contains only domain names with HTTPS enabled.
	// *   false: The list contains only domain names with HTTPS disabled.
	SSLStatus *bool `json:"SSLStatus,omitempty" xml:"SSLStatus,omitempty"`
}

func (s DescribeDcdnDomainByCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainByCertificateRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainByCertificateRequest) SetExact(v bool) *DescribeDcdnDomainByCertificateRequest {
	s.Exact = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateRequest) SetSSLPub(v string) *DescribeDcdnDomainByCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateRequest) SetSSLStatus(v bool) *DescribeDcdnDomainByCertificateRequest {
	s.SSLStatus = &v
	return s
}

type DescribeDcdnDomainByCertificateResponseBody struct {
	// The information about the certificate.
	CertInfos *DescribeDcdnDomainByCertificateResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainByCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainByCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainByCertificateResponseBody) SetCertInfos(v *DescribeDcdnDomainByCertificateResponseBodyCertInfos) *DescribeDcdnDomainByCertificateResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBody) SetRequestId(v string) *DescribeDcdnDomainByCertificateResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainByCertificateResponseBodyCertInfos struct {
	CertInfo []*DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainByCertificateResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainByCertificateResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfos) SetCertInfo(v []*DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) *DescribeDcdnDomainByCertificateResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo struct {
	// Indicates whether the SSL certificate is obsolete. Valid values:
	//
	// *   **yes**: The SSL certificate is obsolete.
	// *   **no**: The SSL certificate is working as expected.
	CertCaIsLegacy *string `json:"CertCaIsLegacy,omitempty" xml:"CertCaIsLegacy,omitempty"`
	// The time at which the certificate expires.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// Indicates whether the SSL certificate is expired. Valid values:
	//
	// *   **yes**: The SSL certificate is expired.
	// *   **no**: The SSL certificate is not expired.
	CertExpired *string `json:"CertExpired,omitempty" xml:"CertExpired,omitempty"`
	// The time at which the certificate became effective.
	CertStartTime *string `json:"CertStartTime,omitempty" xml:"CertStartTime,omitempty"`
	// The name of the SSL certificate owner.
	CertSubjectCommonName *string `json:"CertSubjectCommonName,omitempty" xml:"CertSubjectCommonName,omitempty"`
	// The type of the certificate. **RSA**, **DSA**, and **ECDSA**.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The list of domain names that use the certificate.
	//
	// If one or more domain names are returned, the domain names are matched with the specified certificate. Multiple domain names are separated with commas (,).
	DomainList *string `json:"DomainList,omitempty" xml:"DomainList,omitempty"`
	// The domain names (DNS fields) that match the certificate. Multiple domain names are separated with commas (,).
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
}

func (s DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertCaIsLegacy(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertCaIsLegacy = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertExpired(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertExpired = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertStartTime(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertStartTime = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertSubjectCommonName(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertSubjectCommonName = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetDomainList(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.DomainList = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetDomainNames(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.DomainNames = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo) SetIssuer(v string) *DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo {
	s.Issuer = &v
	return s
}

type DescribeDcdnDomainByCertificateResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainByCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainByCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainByCertificateResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainByCertificateResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainByCertificateResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponse) SetStatusCode(v int32) *DescribeDcdnDomainByCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainByCertificateResponse) SetBody(v *DescribeDcdnDomainByCertificateResponseBody) *DescribeDcdnDomainByCertificateResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainCcActivityLogRequest struct {
	// The accelerated domain name. You can specify one or more domain names. Separate multiple domain names with commas (,).
	//
	// If you leave this parameter empty, the data of all domain names is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The page number of the page returned. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **30**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the defense rule.
	//
	// *   default_normal in normal mode
	// *   default_attack in emergency mode
	// *   A custom rule name in custom mode. Example: test2.
	//
	// If you leave this parameter empty, events that triggered rate limiting based on all rules are queried.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The resolution of the queried data is 5 minutes.
	//
	// If you leave this parameter empty, the data collected over the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The trigger of rate limiting by which you want to query data.
	//
	// If you leave this parameter empty, all events that triggered rate limiting are queried.
	TriggerObject *string `json:"TriggerObject,omitempty" xml:"TriggerObject,omitempty"`
	// The value of the object that triggered rate limiting.
	//
	// If you leave this parameter empty, events that triggered rate limiting based on all rules are queried.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainCcActivityLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCcActivityLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetDomainName(v string) *DescribeDcdnDomainCcActivityLogRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetEndTime(v string) *DescribeDcdnDomainCcActivityLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetPageNumber(v int64) *DescribeDcdnDomainCcActivityLogRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetPageSize(v int64) *DescribeDcdnDomainCcActivityLogRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetRuleName(v string) *DescribeDcdnDomainCcActivityLogRequest {
	s.RuleName = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetStartTime(v string) *DescribeDcdnDomainCcActivityLogRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetTriggerObject(v string) *DescribeDcdnDomainCcActivityLogRequest {
	s.TriggerObject = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogRequest) SetValue(v string) *DescribeDcdnDomainCcActivityLogRequest {
	s.Value = &v
	return s
}

type DescribeDcdnDomainCcActivityLogResponseBody struct {
	// The log data of the event that triggered rate limiting.
	ActivityLog []*DescribeDcdnDomainCcActivityLogResponseBodyActivityLog `json:"ActivityLog,omitempty" xml:"ActivityLog,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageIndex *int64 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeDcdnDomainCcActivityLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCcActivityLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCcActivityLogResponseBody) SetActivityLog(v []*DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) *DescribeDcdnDomainCcActivityLogResponseBody {
	s.ActivityLog = v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBody) SetPageIndex(v int64) *DescribeDcdnDomainCcActivityLogResponseBody {
	s.PageIndex = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBody) SetPageSize(v int64) *DescribeDcdnDomainCcActivityLogResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBody) SetRequestId(v string) *DescribeDcdnDomainCcActivityLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBody) SetTotal(v int64) *DescribeDcdnDomainCcActivityLogResponseBody {
	s.Total = &v
	return s
}

type DescribeDcdnDomainCcActivityLogResponseBodyActivityLog struct {
	// The action that was triggered.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The accelerated domain name whose ICP filing status you want to update.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the rule that was triggered.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The object that triggered the blocking event.
	TriggerObject *string `json:"TriggerObject,omitempty" xml:"TriggerObject,omitempty"`
	// The period of time during which rate limiting remains effective.
	Ttl *int64 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The value of the trigger for rate limiting.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) SetAction(v string) *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog {
	s.Action = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) SetDomainName(v string) *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) SetRuleName(v string) *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog {
	s.RuleName = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) SetTimeStamp(v string) *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) SetTriggerObject(v string) *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog {
	s.TriggerObject = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) SetTtl(v int64) *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog {
	s.Ttl = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog) SetValue(v string) *DescribeDcdnDomainCcActivityLogResponseBodyActivityLog {
	s.Value = &v
	return s
}

type DescribeDcdnDomainCcActivityLogResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainCcActivityLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainCcActivityLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCcActivityLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCcActivityLogResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainCcActivityLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponse) SetStatusCode(v int32) *DescribeDcdnDomainCcActivityLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainCcActivityLogResponse) SetBody(v *DescribeDcdnDomainCcActivityLogResponseBody) *DescribeDcdnDomainCcActivityLogResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainCertificateInfoRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnDomainCertificateInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCertificateInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCertificateInfoRequest) SetDomainName(v string) *DescribeDcdnDomainCertificateInfoRequest {
	s.DomainName = &v
	return s
}

type DescribeDcdnDomainCertificateInfoResponseBody struct {
	// The information about the certificate.
	CertInfos *DescribeDcdnDomainCertificateInfoResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainCertificateInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCertificateInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCertificateInfoResponseBody) SetCertInfos(v *DescribeDcdnDomainCertificateInfoResponseBodyCertInfos) *DescribeDcdnDomainCertificateInfoResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBody) SetRequestId(v string) *DescribeDcdnDomainCertificateInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainCertificateInfoResponseBodyCertInfos struct {
	CertInfo []*DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainCertificateInfoResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCertificateInfoResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfos) SetCertInfo(v []*DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo struct {
	// The domain name that matches the certificate.
	CertDomainName *string `json:"CertDomainName,omitempty" xml:"CertDomainName,omitempty"`
	// The time at which the certificate expires.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The ID of the certificate.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The validity period of the certificate. Unit: **months** or **years**.
	CertLife *string `json:"CertLife,omitempty" xml:"CertLife,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	CertOrg *string `json:"CertOrg,omitempty" xml:"CertOrg,omitempty"`
	// The region where the certificate is used.
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The type of the certificate.
	//
	// *   **cas**: a certificate that is purchased by using Certificates Management Service
	// *   **upload**: a custom certificate that you upload
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of HTTPS. Valid values:
	//
	// *   **on**
	// *   **off**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The public key of the certificate.
	SSLPub *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	// The status of the certificate. Valid values:
	//
	// *   **success**: The certificate has taken effect.
	// *   **checking**: The system is checking whether the domain name is using Dynamic Route for CDN (DCDN).
	// *   **cname_error**: The domain name is not using DCDN.
	// *   **domain_invalid**: The domain name contains invalid characters.
	// *   **unsupport_wildcard**: The wildcard domain name is not supported.
	// *   **applying**: Certificate application is in progress.
	// *   **get_token_timeout**: The certificate application request has timed out.
	// *   **check_token_timeout**: The verification has timed out.
	// *   **get_cert_timeout**: The request to obtain the certificate has timed out.
	// *   **failed**: The certificate application request failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertDomainName(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertDomainName = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertId(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertId = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertLife(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertLife = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertName(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertOrg(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertOrg = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertRegion(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertRegion = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetDomainName(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetSSLProtocol(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.SSLProtocol = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetSSLPub(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.SSLPub = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo) SetStatus(v string) *DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.Status = &v
	return s
}

type DescribeDcdnDomainCertificateInfoResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainCertificateInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainCertificateInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCertificateInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCertificateInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainCertificateInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponse) SetStatusCode(v int32) *DescribeDcdnDomainCertificateInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainCertificateInfoResponse) SetBody(v *DescribeDcdnDomainCertificateInfoResponseBody) *DescribeDcdnDomainCertificateInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainCnameRequest struct {
	// The accelerated domain name. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnDomainCnameRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCnameRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCnameRequest) SetDomainName(v string) *DescribeDcdnDomainCnameRequest {
	s.DomainName = &v
	return s
}

type DescribeDcdnDomainCnameResponseBody struct {
	// The CNAME information.
	CnameDatas *DescribeDcdnDomainCnameResponseBodyCnameDatas `json:"CnameDatas,omitempty" xml:"CnameDatas,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainCnameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCnameResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCnameResponseBody) SetCnameDatas(v *DescribeDcdnDomainCnameResponseBodyCnameDatas) *DescribeDcdnDomainCnameResponseBody {
	s.CnameDatas = v
	return s
}

func (s *DescribeDcdnDomainCnameResponseBody) SetRequestId(v string) *DescribeDcdnDomainCnameResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainCnameResponseBodyCnameDatas struct {
	Data []*DescribeDcdnDomainCnameResponseBodyCnameDatasData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainCnameResponseBodyCnameDatas) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCnameResponseBodyCnameDatas) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCnameResponseBodyCnameDatas) SetData(v []*DescribeDcdnDomainCnameResponseBodyCnameDatasData) *DescribeDcdnDomainCnameResponseBodyCnameDatas {
	s.Data = v
	return s
}

type DescribeDcdnDomainCnameResponseBodyCnameDatasData struct {
	// The CNAME assigned to the domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The accelerated domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The configuration status of the CNAME record. If the operation returns 0 for the parameter, the configuration was successful. Otherwise, the configuration failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnDomainCnameResponseBodyCnameDatasData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCnameResponseBodyCnameDatasData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCnameResponseBodyCnameDatasData) SetCname(v string) *DescribeDcdnDomainCnameResponseBodyCnameDatasData {
	s.Cname = &v
	return s
}

func (s *DescribeDcdnDomainCnameResponseBodyCnameDatasData) SetDomain(v string) *DescribeDcdnDomainCnameResponseBodyCnameDatasData {
	s.Domain = &v
	return s
}

func (s *DescribeDcdnDomainCnameResponseBodyCnameDatasData) SetStatus(v int32) *DescribeDcdnDomainCnameResponseBodyCnameDatasData {
	s.Status = &v
	return s
}

type DescribeDcdnDomainCnameResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainCnameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainCnameResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainCnameResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainCnameResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainCnameResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainCnameResponse) SetStatusCode(v int32) *DescribeDcdnDomainCnameResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainCnameResponse) SetBody(v *DescribeDcdnDomainCnameResponseBody) *DescribeDcdnDomainCnameResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainConfigsRequest struct {
	// The ID of the configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The names of the features to query. Separate features with commas (,).
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainConfigsRequest) SetConfigId(v string) *DescribeDcdnDomainConfigsRequest {
	s.ConfigId = &v
	return s
}

func (s *DescribeDcdnDomainConfigsRequest) SetDomainName(v string) *DescribeDcdnDomainConfigsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainConfigsRequest) SetFunctionNames(v string) *DescribeDcdnDomainConfigsRequest {
	s.FunctionNames = &v
	return s
}

func (s *DescribeDcdnDomainConfigsRequest) SetOwnerId(v int64) *DescribeDcdnDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnDomainConfigsRequest) SetSecurityToken(v string) *DescribeDcdnDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnDomainConfigsResponseBody struct {
	// The configurations of the domain name.
	DomainConfigs *DescribeDcdnDomainConfigsResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainConfigsResponseBody) SetDomainConfigs(v *DescribeDcdnDomainConfigsResponseBodyDomainConfigs) *DescribeDcdnDomainConfigsResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeDcdnDomainConfigsResponseBody) SetRequestId(v string) *DescribeDcdnDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainConfigsResponseBodyDomainConfigs struct {
	DomainConfig []*DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig `json:"DomainConfig,omitempty" xml:"DomainConfig,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigs) SetDomainConfig(v []*DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) *DescribeDcdnDomainConfigsResponseBodyDomainConfigs {
	s.DomainConfig = v
	return s
}

type DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig struct {
	// The ID of the configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The configurations of the features.
	FunctionArgs *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Struct"`
	// The feature name.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The ID of the advanced condition configuration.
	ParentId *string `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The status of the configuration. Valid values:
	//
	// *   **success**: successful
	// *   **testing**: testing
	// *   **failed**: The configuration failed.
	// *   **configuring**: The configuration is in progress.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetConfigId(v string) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.ConfigId = &v
	return s
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionArgs(v *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionArgs = v
	return s
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionName(v string) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionName = &v
	return s
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetParentId(v string) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.ParentId = &v
	return s
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig) SetStatus(v string) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.Status = &v
	return s
}

type DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs struct {
	FunctionArg []*DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg `json:"FunctionArg,omitempty" xml:"FunctionArg,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) SetFunctionArg(v []*DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs {
	s.FunctionArg = v
	return s
}

type DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg struct {
	// The name of the configuration.
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The value of the configuration.
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgName(v string) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgName = &v
	return s
}

func (s *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgValue(v string) *DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgValue = &v
	return s
}

type DescribeDcdnDomainConfigsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainConfigsResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainConfigsResponse) SetStatusCode(v int32) *DescribeDcdnDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainConfigsResponse) SetBody(v *DescribeDcdnDomainConfigsResponseBody) *DescribeDcdnDomainConfigsResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainDetailRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainDetailRequest) SetDomainName(v string) *DescribeDcdnDomainDetailRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainDetailRequest) SetOwnerId(v int64) *DescribeDcdnDomainDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnDomainDetailRequest) SetSecurityToken(v string) *DescribeDcdnDomainDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnDomainDetailResponseBody struct {
	// The information about the accelerated domain name.
	DomainDetail *DescribeDcdnDomainDetailResponseBodyDomainDetail `json:"DomainDetail,omitempty" xml:"DomainDetail,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainDetailResponseBody) SetDomainDetail(v *DescribeDcdnDomainDetailResponseBodyDomainDetail) *DescribeDcdnDomainDetailResponseBody {
	s.DomainDetail = v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBody) SetRequestId(v string) *DescribeDcdnDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainDetailResponseBodyDomainDetail struct {
	// The CNAME that is assigned to the accelerated domain name. You must add the CNAME record to the system of your Domain Name System (DNS) provider to map the accelerated domain name to the CNAME.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The information about the Internet content provider (ICP) filing of the domain name.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   **online**
	// *   **offline**
	// *   **configuring**
	// *   **configure_failed**
	// *   **checking**
	// *   **check_failed**
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// The time when the domain name was added.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the domain name was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the Security Socket Layer (SSL) certificate is enabled. Valid values:
	//
	// *   **on**: **enabled**
	// *   **off**: **disabled**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The public key of the certificate if HTTPS is enabled.
	SSLPub *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	Scene  *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The acceleration region. Default value: domestic. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: global (excluding the Chinese mainland)
	// *   **global**: global
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The information about the origin server.
	Sources *DescribeDcdnDomainDetailResponseBodyDomainDetailSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainDetailResponseBodyDomainDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainDetailResponseBodyDomainDetail) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetCname(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.Cname = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetDescription(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.Description = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetDomainName(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetDomainStatus(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.DomainStatus = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetFunctionType(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.FunctionType = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetGmtCreated(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.GmtCreated = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetGmtModified(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetResourceGroupId(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetSSLProtocol(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.SSLProtocol = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetSSLPub(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.SSLPub = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetScene(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.Scene = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetScope(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.Scope = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetail) SetSources(v *DescribeDcdnDomainDetailResponseBodyDomainDetailSources) *DescribeDcdnDomainDetailResponseBodyDomainDetail {
	s.Sources = v
	return s
}

type DescribeDcdnDomainDetailResponseBodyDomainDetailSources struct {
	Source []*DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainDetailResponseBodyDomainDetailSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainDetailResponseBodyDomainDetailSources) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetailSources) SetSource(v []*DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) *DescribeDcdnDomainDetailResponseBodyDomainDetailSources {
	s.Source = v
	return s
}

type DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The status.
	Enabled *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The port over which requests are redirected to the origin server. Ports 443 and 80 are supported.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server. Valid values:
	//
	// *   **ipaddr**: an origin IP address
	// *   **domain**: an origin domain name
	// *   **oss**: the domain name of an Object Storage Service (OSS) bucket
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) SetContent(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) SetEnabled(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Enabled = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) SetPort(v int32) *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) SetPriority(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) SetType(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource) SetWeight(v string) *DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Weight = &v
	return s
}

type DescribeDcdnDomainDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainDetailResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainDetailResponse) SetStatusCode(v int32) *DescribeDcdnDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainDetailResponse) SetBody(v *DescribeDcdnDomainDetailResponseBody) *DescribeDcdnDomainDetailResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainHitRateDataRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	//
	// If you do not specify a value for this parameter, all domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC.
	//
	// The end time needs to be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity for a query. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHitRateDataRequest) SetDomainName(v string) *DescribeDcdnDomainHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataRequest) SetEndTime(v string) *DescribeDcdnDomainHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataRequest) SetInterval(v string) *DescribeDcdnDomainHitRateDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataRequest) SetStartTime(v string) *DescribeDcdnDomainHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainHitRateDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The byte hit ratio at each time interval. The byte hit ratio is measured in percentage.
	HitRatePerInterval *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval `json:"HitRatePerInterval,omitempty" xml:"HitRatePerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHitRateDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainHitRateDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainHitRateDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainHitRateDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponseBody) SetHitRatePerInterval(v *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval) *DescribeDcdnDomainHitRateDataResponseBody {
	s.HitRatePerInterval = v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainHitRateDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval struct {
	DataModule []*DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval) SetDataModule(v []*DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule) *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule struct {
	// The byte hit ratio.
	ByteHitRate *float32 `json:"ByteHitRate,omitempty" xml:"ByteHitRate,omitempty"`
	// The request hit ratio.
	ReqHitRate *float32 `json:"ReqHitRate,omitempty" xml:"ReqHitRate,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule) SetByteHitRate(v float32) *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule {
	s.ByteHitRate = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule) SetReqHitRate(v float32) *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule {
	s.ReqHitRate = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainHitRateDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainHitRateDataResponse) SetBody(v *DescribeDcdnDomainHitRateDataResponseBody) *DescribeDcdnDomainHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainHttpCodeDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataRequest) SetDomainName(v string) *DescribeDcdnDomainHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataRequest) SetEndTime(v string) *DescribeDcdnDomainHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataRequest) SetInterval(v string) *DescribeDcdnDomainHttpCodeDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataRequest) SetStartTime(v string) *DescribeDcdnDomainHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainHttpCodeDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The proportions of HTTP status codes at each time interval.
	DataPerInterval *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval `json:"DataPerInterval,omitempty" xml:"DataPerInterval,omitempty" type:"Struct"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBody) SetDataPerInterval(v *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval) *DescribeDcdnDomainHttpCodeDataResponseBody {
	s.DataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval struct {
	DataModule []*DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval) SetDataModule(v []*DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule) *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule struct {
	// The proportions of the HTTP status codes.
	HttpCodeDataPerInterval *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval `json:"HttpCodeDataPerInterval,omitempty" xml:"HttpCodeDataPerInterval,omitempty" type:"Struct"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule) SetHttpCodeDataPerInterval(v *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval) *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule {
	s.HttpCodeDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval struct {
	HttpCodeDataModule []*DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule `json:"HttpCodeDataModule,omitempty" xml:"HttpCodeDataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval) SetHttpCodeDataModule(v []*DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule) *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval {
	s.HttpCodeDataModule = v
	return s
}

type DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule struct {
	// The HTTP status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The count of each HTTP status code.
	Count *float32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *float32 `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule) SetCode(v int32) *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule {
	s.Code = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule) SetCount(v float32) *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule {
	s.Count = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule) SetProportion(v float32) *DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule {
	s.Proportion = &v
	return s
}

type DescribeDcdnDomainHttpCodeDataResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataResponse) SetBody(v *DescribeDcdnDomainHttpCodeDataResponseBody) *DescribeDcdnDomainHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainHttpCodeDataByLayerRequest struct {
	// The accelerated domain name. You can specify multiple domain names and separate them with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated. If you do not specify this parameter, data of all accelerated domain names under your account is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC.
	//
	// > The end time needs to be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). You can call the DescribeDcdnRegionAndIsp operation to query the ISP name. If you do not specify a value for this parameter, all ISPs are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The layer at which you want to query the bandwidth data. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all. Default value: all.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The name of the region. You can call the DescribeDcdnRegionAndIsp operation to query the region name. If you do not specify a value for this parameter, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC. The minimum data granularity is 5 minutes. If you do not set this parameter, data in the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainHttpCodeDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerRequest) SetDomainName(v string) *DescribeDcdnDomainHttpCodeDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerRequest) SetEndTime(v string) *DescribeDcdnDomainHttpCodeDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerRequest) SetInterval(v string) *DescribeDcdnDomainHttpCodeDataByLayerRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerRequest) SetIspNameEn(v string) *DescribeDcdnDomainHttpCodeDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerRequest) SetLayer(v string) *DescribeDcdnDomainHttpCodeDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerRequest) SetLocationNameEn(v string) *DescribeDcdnDomainHttpCodeDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerRequest) SetStartTime(v string) *DescribeDcdnDomainHttpCodeDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainHttpCodeDataByLayerResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The distribution of HTTP status codes at each time interval.
	HttpCodeDataInterval *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval `json:"HttpCodeDataInterval,omitempty" xml:"HttpCodeDataInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponseBody) SetDataInterval(v string) *DescribeDcdnDomainHttpCodeDataByLayerResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponseBody) SetHttpCodeDataInterval(v *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) *DescribeDcdnDomainHttpCodeDataByLayerResponseBody {
	s.HttpCodeDataInterval = v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponseBody) SetRequestId(v string) *DescribeDcdnDomainHttpCodeDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval struct {
	DataModule []*DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval) SetDataModule(v []*DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total number of times that HTTP status codes were returned.
	TotalValue *string `json:"TotalValue,omitempty" xml:"TotalValue,omitempty"`
	// The number of times that the HTTP status code was returned.
	Value map[string]interface{} `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) SetTotalValue(v string) *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule {
	s.TotalValue = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule) SetValue(v map[string]interface{}) *DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule {
	s.Value = v
	return s
}

type DescribeDcdnDomainHttpCodeDataByLayerResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainHttpCodeDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainHttpCodeDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainHttpCodeDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponse) SetStatusCode(v int32) *DescribeDcdnDomainHttpCodeDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainHttpCodeDataByLayerResponse) SetBody(v *DescribeDcdnDomainHttpCodeDataByLayerResponseBody) *DescribeDcdnDomainHttpCodeDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainIpaBpsDataRequest struct {
	// The accelerated domain name.
	//
	// Separate multiple domain names with commas (,). If you leave this parameter empty, all accelerated domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Specifies whether to implement padding with zeros. Valid values:
	//
	// *   **true**
	// *   **false**
	FixTimeGap *string `json:"FixTimeGap,omitempty" xml:"FixTimeGap,omitempty"`
	// The time granularity of data entries. Unit: seconds.
	//
	// The time granularity varies with the time range specified by **StartTime** and **EndTime**.
	//
	// *   If the time range between StartTime and EndTime is less than 3 days, the valid values are **300**, **3600**, and **86400**. If you leave this parameter empty, **300** is used.
	// *   If the time range between StartTime and EndTime is greater than or equal to 3 days and less than 31 days, the valid values are **3600** and **86400**. Default value: **3600**.
	// *   If the time range between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// Specifies whether to automatically set the interval. If you set **TimeMerge** to **1**, the value of the **Interval** parameter is automatically assigned based on the **startTime** and **endTime** parameters. You can specify either this parameter or the **Interval** parameter.
	TimeMerge *string `json:"TimeMerge,omitempty" xml:"TimeMerge,omitempty"`
}

func (s DescribeDcdnDomainIpaBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetFixTimeGap(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.FixTimeGap = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetInterval(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataRequest) SetTimeMerge(v string) *DescribeDcdnDomainIpaBpsDataRequest {
	s.TimeMerge = &v
	return s
}

type DescribeDcdnDomainIpaBpsDataResponseBody struct {
	// The bandwidth data returned at each interval.
	BpsDataPerInterval *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval `json:"BpsDataPerInterval,omitempty" xml:"BpsDataPerInterval,omitempty" type:"Struct"`
	// The time interval at which data was collected. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainIpaBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBody) SetBpsDataPerInterval(v *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval) *DescribeDcdnDomainIpaBpsDataResponseBody {
	s.BpsDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainIpaBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainIpaBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainIpaBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainIpaBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainIpaBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval struct {
	DataModule []*DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval) SetDataModule(v []*DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule) *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule struct {
	// The bandwidth value. Unit: bit/s.
	IpaBps *float32 `json:"IpaBps,omitempty" xml:"IpaBps,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule) SetIpaBps(v float32) *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.IpaBps = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainIpaBpsDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainIpaBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainIpaBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainIpaBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainIpaBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainIpaBpsDataResponse) SetBody(v *DescribeDcdnDomainIpaBpsDataResponseBody) *DescribeDcdnDomainIpaBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainIpaConnDataRequest struct {
	// The domain names accelerated by IPA. Separate multiple domain names with commas (,).
	//
	// > If you do not specify this parameter, the merged data of all accelerated domain names is returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Specifies how query results are grouped. By default, this parameter is empty. Valid values:
	//
	// *   domain: Query results are grouped by accelerated domain name.
	// *   An empty string: Query results are not grouped.
	SplitBy *string `json:"SplitBy,omitempty" xml:"SplitBy,omitempty"`
	// The start of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainIpaConnDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaConnDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaConnDataRequest) SetDomainName(v string) *DescribeDcdnDomainIpaConnDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataRequest) SetEndTime(v string) *DescribeDcdnDomainIpaConnDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataRequest) SetSplitBy(v string) *DescribeDcdnDomainIpaConnDataRequest {
	s.SplitBy = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataRequest) SetStartTime(v string) *DescribeDcdnDomainIpaConnDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainIpaConnDataResponseBody struct {
	// The number of user connections at each time interval.
	ConnectionDataPerInterval *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval `json:"ConnectionDataPerInterval,omitempty" xml:"ConnectionDataPerInterval,omitempty" type:"Struct"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainIpaConnDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaConnDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaConnDataResponseBody) SetConnectionDataPerInterval(v *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval) *DescribeDcdnDomainIpaConnDataResponseBody {
	s.ConnectionDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainIpaConnDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainIpaConnDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainIpaConnDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval struct {
	DataModule []*DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval) SetDataModule(v []*DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule) *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule struct {
	// The number of IPA user connections.
	Connections *int64 `json:"Connections,omitempty" xml:"Connections,omitempty"`
	// The accelerated domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule) SetConnections(v int64) *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule {
	s.Connections = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule) SetDomain(v string) *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule {
	s.Domain = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainIpaConnDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainIpaConnDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainIpaConnDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaConnDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaConnDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainIpaConnDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainIpaConnDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainIpaConnDataResponse) SetBody(v *DescribeDcdnDomainIpaConnDataResponseBody) *DescribeDcdnDomainIpaConnDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainIpaTrafficDataRequest struct {
	// The accelerated domain name.
	//
	// Separate multiple domain names with commas (,). If you do not specify a value for this parameter, data for all accelerated domain names is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Specify whether to implement padding with zeros. Valid values:
	//
	// *   **true**
	// *   **false**
	FixTimeGap *string `json:"FixTimeGap,omitempty" xml:"FixTimeGap,omitempty"`
	// The time granularity of data entries. Unit: seconds.
	//
	// The time granularity varies with the time range specified by **StartTime** and **EndTime**.
	//
	// *   If the time range between StartTime and EndTime is less than 3 days, the valid values are **300**, **3600**, and **86400**. If you do not specify a value for this parameter, **300** is used.
	// *   If the time range between StartTime and EndTime is greater than or equal to 3 days and less than 31 days, the valid values are **3600** and **86400**. Default value: **3600**.
	// *   If the time range between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// Specifies whether to automatically calculate the value of the **interval**. If the **timeMerge** parameter is set to **1**, the value of **inteval** is calculated based on **StartTime** and **EndTime**. You can set either this parameter or the **interval** parameter.
	TimeMerge *string `json:"TimeMerge,omitempty" xml:"TimeMerge,omitempty"`
}

func (s DescribeDcdnDomainIpaTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetDomainName(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetEndTime(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetFixTimeGap(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.FixTimeGap = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetInterval(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetStartTime(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataRequest) SetTimeMerge(v string) *DescribeDcdnDomainIpaTrafficDataRequest {
	s.TimeMerge = &v
	return s
}

type DescribeDcdnDomainIpaTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The network traffic that was collected at each interval.
	TrafficDataPerInterval *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval `json:"TrafficDataPerInterval,omitempty" xml:"TrafficDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainIpaTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainIpaTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainIpaTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainIpaTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainIpaTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainIpaTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBody) SetTrafficDataPerInterval(v *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval) *DescribeDcdnDomainIpaTrafficDataResponseBody {
	s.TrafficDataPerInterval = v
	return s
}

type DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval struct {
	DataModule []*DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval) SetDataModule(v []*DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule) *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule struct {
	// The total amount of network traffic.
	IpaTraffic *float32 `json:"IpaTraffic,omitempty" xml:"IpaTraffic,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetIpaTraffic(v float32) *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.IpaTraffic = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainIpaTrafficDataResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainIpaTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainIpaTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIpaTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIpaTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainIpaTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainIpaTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainIpaTrafficDataResponse) SetBody(v *DescribeDcdnDomainIpaTrafficDataResponseBody) *DescribeDcdnDomainIpaTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainIspDataRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	//
	// If you do not specify an accelerated domain name, the data of all accelerated domain names that belong to your account is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainIspDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIspDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIspDataRequest) SetDomainName(v string) *DescribeDcdnDomainIspDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainIspDataRequest) SetEndTime(v string) *DescribeDcdnDomainIspDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIspDataRequest) SetStartTime(v string) *DescribeDcdnDomainIspDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainIspDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The access statistics by ISP.
	Value *DescribeDcdnDomainIspDataResponseBodyValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainIspDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIspDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIspDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainIspDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainIspDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainIspDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainIspDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainIspDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBody) SetValue(v *DescribeDcdnDomainIspDataResponseBodyValue) *DescribeDcdnDomainIspDataResponseBody {
	s.Value = v
	return s
}

type DescribeDcdnDomainIspDataResponseBodyValue struct {
	IspProportionData []*DescribeDcdnDomainIspDataResponseBodyValueIspProportionData `json:"IspProportionData,omitempty" xml:"IspProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainIspDataResponseBodyValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIspDataResponseBodyValue) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIspDataResponseBodyValue) SetIspProportionData(v []*DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) *DescribeDcdnDomainIspDataResponseBodyValue {
	s.IspProportionData = v
	return s
}

type DescribeDcdnDomainIspDataResponseBodyValueIspProportionData struct {
	// The average response size. Unit: bytes.
	AvgObjectSize *string `json:"AvgObjectSize,omitempty" xml:"AvgObjectSize,omitempty"`
	// The average response speed. Unit: byte/ms.
	AvgResponseRate *string `json:"AvgResponseRate,omitempty" xml:"AvgResponseRate,omitempty"`
	// The average response time. Unit: milliseconds.
	AvgResponseTime *string `json:"AvgResponseTime,omitempty" xml:"AvgResponseTime,omitempty"`
	// The bandwidth.
	Bps *string `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The proportion of network traffic. For example, a value of 90 indicates that 90% of network traffic was coming from the specified ISP.
	BytesProportion *string `json:"BytesProportion,omitempty" xml:"BytesProportion,omitempty"`
	// The information about the ISP.
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The name of the ISP.
	IspEname *string `json:"IspEname,omitempty" xml:"IspEname,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
	// The number of queries per second (QPS).
	Qps *string `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The total volume of traffic.
	TotalBytes *string `json:"TotalBytes,omitempty" xml:"TotalBytes,omitempty"`
	// The total number of requests that are destined for your website.
	TotalQuery *string `json:"TotalQuery,omitempty" xml:"TotalQuery,omitempty"`
}

func (s DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetAvgObjectSize(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.AvgObjectSize = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetAvgResponseRate(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.AvgResponseRate = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetAvgResponseTime(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.AvgResponseTime = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetBps(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.Bps = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetBytesProportion(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.BytesProportion = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetIsp(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.Isp = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetIspEname(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.IspEname = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetProportion(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.Proportion = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetQps(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.Qps = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetTotalBytes(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.TotalBytes = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData) SetTotalQuery(v string) *DescribeDcdnDomainIspDataResponseBodyValueIspProportionData {
	s.TotalQuery = &v
	return s
}

type DescribeDcdnDomainIspDataResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainIspDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainIspDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainIspDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainIspDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainIspDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainIspDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainIspDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainIspDataResponse) SetBody(v *DescribeDcdnDomainIspDataResponseBody) *DescribeDcdnDomainIspDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainLogRequest struct {
	// The accelerated domain name that you want to query. You can specify only one domain name in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Pages start from page **1**.
	//
	// Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: **1** to **1000**. Default value: **300**. Maximum value: **1000**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogRequest) SetDomainName(v string) *DescribeDcdnDomainLogRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainLogRequest) SetEndTime(v string) *DescribeDcdnDomainLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainLogRequest) SetPageNumber(v int64) *DescribeDcdnDomainLogRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnDomainLogRequest) SetPageSize(v int64) *DescribeDcdnDomainLogRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnDomainLogRequest) SetStartTime(v string) *DescribeDcdnDomainLogRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainLogResponseBody struct {
	// The log information. The log information is indicated by the DomainLogDetail parameter.
	DomainLogDetails *DescribeDcdnDomainLogResponseBodyDomainLogDetails `json:"DomainLogDetails,omitempty" xml:"DomainLogDetails,omitempty" type:"Struct"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogResponseBody) SetDomainLogDetails(v *DescribeDcdnDomainLogResponseBodyDomainLogDetails) *DescribeDcdnDomainLogResponseBody {
	s.DomainLogDetails = v
	return s
}

func (s *DescribeDcdnDomainLogResponseBody) SetDomainName(v string) *DescribeDcdnDomainLogResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBody) SetRequestId(v string) *DescribeDcdnDomainLogResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainLogResponseBodyDomainLogDetails struct {
	DomainLogDetail []*DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail `json:"DomainLogDetail,omitempty" xml:"DomainLogDetail,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetails) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetails) SetDomainLogDetail(v []*DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail) *DescribeDcdnDomainLogResponseBodyDomainLogDetails {
	s.DomainLogDetail = v
	return s
}

type DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail struct {
	// The total number of entries returned on the current page.
	LogCount *int64 `json:"LogCount,omitempty" xml:"LogCount,omitempty"`
	// The log information. The log information is indicated by the LogInfoDetail parameter.
	LogInfos *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos `json:"LogInfos,omitempty" xml:"LogInfos,omitempty" type:"Struct"`
	// The page information. The page information is indicated by the PageInfoDetail parameter.
	PageInfos *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos `json:"PageInfos,omitempty" xml:"PageInfos,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetLogCount(v int64) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogCount = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetLogInfos(v *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogInfos = v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetPageInfos(v *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.PageInfos = v
	return s
}

type DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos struct {
	LogInfoDetail []*DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail `json:"LogInfoDetail,omitempty" xml:"LogInfoDetail,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) SetLogInfoDetail(v []*DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos {
	s.LogInfoDetail = v
	return s
}

type DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail struct {
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the log file.
	LogName *string `json:"LogName,omitempty" xml:"LogName,omitempty"`
	// The path of the log file.
	//
	// Take note of the Expires field (expiration timestamp) in the response parameter LogPath. If the log download URL expires, you must obtain it again. For more information, see [LogPath field](~~31952~~).
	LogPath *string `json:"LogPath,omitempty" xml:"LogPath,omitempty"`
	// The size of the log file. Unit: bytes.
	LogSize *int64 `json:"LogSize,omitempty" xml:"LogSize,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetEndTime(v string) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogName(v string) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogName = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogPath(v string) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogPath = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogSize(v int64) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogSize = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetStartTime(v string) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos struct {
	// The page number of the returned page.
	PageIndex *int64 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageIndex(v int64) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageIndex = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageSize(v int64) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetTotal(v int64) *DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.Total = &v
	return s
}

type DescribeDcdnDomainLogResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainLogResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainLogResponse) SetStatusCode(v int32) *DescribeDcdnDomainLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainLogResponse) SetBody(v *DescribeDcdnDomainLogResponseBody) *DescribeDcdnDomainLogResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainMultiUsageDataRequest struct {
	// If this parameter is not set, data of all your accelerated domain names is queried.
	//
	// You can specify multiple domain names and separate them with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end time must be later than the start time.
	//
	// *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	// *   The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
	// *   You need to set both the start time and the end time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	// *   The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
	// *   The resolution of the queried data is 5 minutes.
	// *   If you do not set this parameter, data in the last 24 hours is queried.
	// *   You need to set both the start time and the end time.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainMultiUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainMultiUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainMultiUsageDataRequest) SetDomainName(v string) *DescribeDcdnDomainMultiUsageDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataRequest) SetEndTime(v string) *DescribeDcdnDomainMultiUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataRequest) SetStartTime(v string) *DescribeDcdnDomainMultiUsageDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainMultiUsageDataResponseBody struct {
	// The end of the time range that was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about requests collected every 5 minutes.
	RequestPerInterval *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval `json:"RequestPerInterval,omitempty" xml:"RequestPerInterval,omitempty" type:"Struct"`
	// The beginning of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The statistics of network traffic collected every 5 minutes.
	TrafficPerInterval *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval `json:"TrafficPerInterval,omitempty" xml:"TrafficPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainMultiUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainMultiUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainMultiUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainMultiUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBody) SetRequestPerInterval(v *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval) *DescribeDcdnDomainMultiUsageDataResponseBody {
	s.RequestPerInterval = v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainMultiUsageDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBody) SetTrafficPerInterval(v *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval) *DescribeDcdnDomainMultiUsageDataResponseBody {
	s.TrafficPerInterval = v
	return s
}

type DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval struct {
	RequestDataModule []*DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule `json:"RequestDataModule,omitempty" xml:"RequestDataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval) SetRequestDataModule(v []*DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval {
	s.RequestDataModule = v
	return s
}

type DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule struct {
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The number of requests.
	Request *int64 `json:"Request,omitempty" xml:"Request,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The type of the requests. Valid values: StaticHttps, DynamicHttps, DynamicHttp, StaticQuic, and DynamicQuic.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetDomain(v string) *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.Domain = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetRequest(v int64) *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.Request = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetTimeStamp(v string) *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule) SetType(v string) *DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule {
	s.Type = &v
	return s
}

type DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval struct {
	TrafficDataModule []*DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule `json:"TrafficDataModule,omitempty" xml:"TrafficDataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval) SetTrafficDataModule(v []*DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval {
	s.TrafficDataModule = v
	return s
}

type DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule struct {
	// The name of the region.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The number of bits per second.
	Bps *float32 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The type of the network traffic. Valid values: Simple, IPA, and WebSocket.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetArea(v string) *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Area = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetBps(v float32) *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Bps = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetDomain(v string) *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Domain = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetTimeStamp(v string) *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule) SetType(v string) *DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule {
	s.Type = &v
	return s
}

type DescribeDcdnDomainMultiUsageDataResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainMultiUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainMultiUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainMultiUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainMultiUsageDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainMultiUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainMultiUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainMultiUsageDataResponse) SetBody(v *DescribeDcdnDomainMultiUsageDataResponseBody) *DescribeDcdnDomainMultiUsageDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainOriginBpsDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity for a query. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainOriginBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginBpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainOriginBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainOriginBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataRequest) SetInterval(v string) *DescribeDcdnDomainOriginBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainOriginBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainOriginBpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The origin bandwidth data returned at each time interval. Unit: bit/s.
	OriginBpsDataPerInterval *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval `json:"OriginBpsDataPerInterval,omitempty" xml:"OriginBpsDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainOriginBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainOriginBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainOriginBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainOriginBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBody) SetOriginBpsDataPerInterval(v *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval) *DescribeDcdnDomainOriginBpsDataResponseBody {
	s.OriginBpsDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainOriginBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainOriginBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval struct {
	DataModule []*DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval) SetDataModule(v []*DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule struct {
	// The bandwidth that was consumed for fetching dynamic content from the origin over HTTP.
	DynamicHttpOriginBps *float32 `json:"DynamicHttpOriginBps,omitempty" xml:"DynamicHttpOriginBps,omitempty"`
	// The bandwidth that was consumed for fetching dynamic content from the origin over HTTPS.
	DynamicHttpsOriginBps *float32 `json:"DynamicHttpsOriginBps,omitempty" xml:"DynamicHttpsOriginBps,omitempty"`
	// The bandwidth that was consumed for fetching content from the origin.
	OriginBps *float32 `json:"OriginBps,omitempty" xml:"OriginBps,omitempty"`
	// The bandwidth that was consumed for fetching static content from the origin over HTTP.
	StaticHttpOriginBps *float32 `json:"StaticHttpOriginBps,omitempty" xml:"StaticHttpOriginBps,omitempty"`
	// The bandwidth that was consumed for fetching static content from the origin over HTTPS.
	StaticHttpsOriginBps *float32 `json:"StaticHttpsOriginBps,omitempty" xml:"StaticHttpsOriginBps,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) SetDynamicHttpOriginBps(v float32) *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule {
	s.DynamicHttpOriginBps = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) SetDynamicHttpsOriginBps(v float32) *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule {
	s.DynamicHttpsOriginBps = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) SetOriginBps(v float32) *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule {
	s.OriginBps = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) SetStaticHttpOriginBps(v float32) *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule {
	s.StaticHttpOriginBps = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) SetStaticHttpsOriginBps(v float32) *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule {
	s.StaticHttpsOriginBps = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainOriginBpsDataResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainOriginBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainOriginBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainOriginBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainOriginBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainOriginBpsDataResponse) SetBody(v *DescribeDcdnDomainOriginBpsDataResponseBody) *DescribeDcdnDomainOriginBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainOriginTrafficDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries to return. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainOriginTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginTrafficDataRequest) SetDomainName(v string) *DescribeDcdnDomainOriginTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataRequest) SetEndTime(v string) *DescribeDcdnDomainOriginTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataRequest) SetInterval(v string) *DescribeDcdnDomainOriginTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataRequest) SetStartTime(v string) *DescribeDcdnDomainOriginTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainOriginTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The amount of back-to-origin traffic returned at each time interval. Unit: bytes.
	OriginTrafficDataPerInterval *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval `json:"OriginTrafficDataPerInterval,omitempty" xml:"OriginTrafficDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainOriginTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainOriginTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainOriginTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainOriginTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBody) SetOriginTrafficDataPerInterval(v *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval) *DescribeDcdnDomainOriginTrafficDataResponseBody {
	s.OriginTrafficDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainOriginTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainOriginTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval struct {
	DataModule []*DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval) SetDataModule(v []*DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule struct {
	// The amount of back-to-origin traffic that was consumed to deliver dynamic content over HTTP.
	DynamicHttpOriginTraffic *float32 `json:"DynamicHttpOriginTraffic,omitempty" xml:"DynamicHttpOriginTraffic,omitempty"`
	// The amount of back-to-origin traffic that was consumed to deliver dynamic content over HTTPS.
	DynamicHttpsOriginTraffic *float32 `json:"DynamicHttpsOriginTraffic,omitempty" xml:"DynamicHttpsOriginTraffic,omitempty"`
	// The amount of back-to-origin traffic.
	OriginTraffic *float32 `json:"OriginTraffic,omitempty" xml:"OriginTraffic,omitempty"`
	// The amount of back-to-origin traffic that was consumed to deliver static content over HTTP.
	StaticHttpOriginTraffic *float32 `json:"StaticHttpOriginTraffic,omitempty" xml:"StaticHttpOriginTraffic,omitempty"`
	// The amount of back-to-origin traffic that was consumed to deliver static content over HTTPS.
	StaticHttpsOriginTraffic *float32 `json:"StaticHttpsOriginTraffic,omitempty" xml:"StaticHttpsOriginTraffic,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) SetDynamicHttpOriginTraffic(v float32) *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule {
	s.DynamicHttpOriginTraffic = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) SetDynamicHttpsOriginTraffic(v float32) *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule {
	s.DynamicHttpsOriginTraffic = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) SetOriginTraffic(v float32) *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule {
	s.OriginTraffic = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) SetStaticHttpOriginTraffic(v float32) *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule {
	s.StaticHttpOriginTraffic = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) SetStaticHttpsOriginTraffic(v float32) *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule {
	s.StaticHttpsOriginTraffic = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainOriginTrafficDataResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainOriginTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainOriginTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainOriginTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainOriginTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainOriginTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainOriginTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainOriginTrafficDataResponse) SetBody(v *DescribeDcdnDomainOriginTrafficDataResponseBody) *DescribeDcdnDomainOriginTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainPropertyRequest struct {
	// The accelerated domain name that you want to query. You can specify only one domain name in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnDomainPropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPropertyRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPropertyRequest) SetDomainName(v string) *DescribeDcdnDomainPropertyRequest {
	s.DomainName = &v
	return s
}

type DescribeDcdnDomainPropertyResponseBody struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The protocol. Valid values:
	//
	// *   **udp**
	// *   **tcp**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainPropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPropertyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPropertyResponseBody) SetDomainName(v string) *DescribeDcdnDomainPropertyResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainPropertyResponseBody) SetProtocol(v string) *DescribeDcdnDomainPropertyResponseBody {
	s.Protocol = &v
	return s
}

func (s *DescribeDcdnDomainPropertyResponseBody) SetRequestId(v string) *DescribeDcdnDomainPropertyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainPropertyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainPropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainPropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPropertyResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPropertyResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainPropertyResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainPropertyResponse) SetStatusCode(v int32) *DescribeDcdnDomainPropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainPropertyResponse) SetBody(v *DescribeDcdnDomainPropertyResponseBody) *DescribeDcdnDomainPropertyResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainPvDataRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainPvDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPvDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPvDataRequest) SetDomainName(v string) *DescribeDcdnDomainPvDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainPvDataRequest) SetEndTime(v string) *DescribeDcdnDomainPvDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainPvDataRequest) SetStartTime(v string) *DescribeDcdnDomainPvDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainPvDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range that was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of PVs at each interval.
	PvDataInterval *DescribeDcdnDomainPvDataResponseBodyPvDataInterval `json:"PvDataInterval,omitempty" xml:"PvDataInterval,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainPvDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPvDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPvDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainPvDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainPvDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainPvDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainPvDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainPvDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainPvDataResponseBody) SetPvDataInterval(v *DescribeDcdnDomainPvDataResponseBodyPvDataInterval) *DescribeDcdnDomainPvDataResponseBody {
	s.PvDataInterval = v
	return s
}

func (s *DescribeDcdnDomainPvDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainPvDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainPvDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainPvDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainPvDataResponseBodyPvDataInterval struct {
	UsageData []*DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainPvDataResponseBodyPvDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPvDataResponseBodyPvDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPvDataResponseBodyPvDataInterval) SetUsageData(v []*DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData) *DescribeDcdnDomainPvDataResponseBodyPvDataInterval {
	s.UsageData = v
	return s
}

type DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The number of PVs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData) SetTimeStamp(v string) *DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData) SetValue(v string) *DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData {
	s.Value = &v
	return s
}

type DescribeDcdnDomainPvDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainPvDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainPvDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainPvDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainPvDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainPvDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainPvDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainPvDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainPvDataResponse) SetBody(v *DescribeDcdnDomainPvDataResponseBody) *DescribeDcdnDomainPvDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainQpsDataRequest struct {
	// The accelerated domain name.
	//
	// Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity for a query. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainQpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainQpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainQpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataRequest) SetInterval(v string) *DescribeDcdnDomainQpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainQpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainQpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainQpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainQpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The QPS returned at each time interval.
	QpsDataPerInterval *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval `json:"QpsDataPerInterval,omitempty" xml:"QpsDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainQpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainQpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainQpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainQpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBody) SetQpsDataPerInterval(v *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval) *DescribeDcdnDomainQpsDataResponseBody {
	s.QpsDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainQpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainQpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval struct {
	DataModule []*DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval) SetDataModule(v []*DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule struct {
	// The total number of requests.
	Acc *float32 `json:"Acc,omitempty" xml:"Acc,omitempty"`
	// The number of requests for dynamic content delivery over HTTP.
	DynamicHttpAcc *float32 `json:"DynamicHttpAcc,omitempty" xml:"DynamicHttpAcc,omitempty"`
	// The QPS for dynamic content delivery over HTTP.
	DynamicHttpQps *float32 `json:"DynamicHttpQps,omitempty" xml:"DynamicHttpQps,omitempty"`
	// The number of requests for dynamic content delivery over HTTPS.
	DynamicHttpsAcc *float32 `json:"DynamicHttpsAcc,omitempty" xml:"DynamicHttpsAcc,omitempty"`
	// The QPS for dynamic content delivery over HTTPS.
	DynamicHttpsQps *float32 `json:"DynamicHttpsQps,omitempty" xml:"DynamicHttpsQps,omitempty"`
	// The total QPS.
	Qps *float32 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The number of requests for static content delivery over HTTP.
	StaticHttpAcc *float32 `json:"StaticHttpAcc,omitempty" xml:"StaticHttpAcc,omitempty"`
	// The QPS for static content delivery over HTTP.
	StaticHttpQps *float32 `json:"StaticHttpQps,omitempty" xml:"StaticHttpQps,omitempty"`
	// The number of requests for static content delivery over HTTPS.
	StaticHttpsAcc *float32 `json:"StaticHttpsAcc,omitempty" xml:"StaticHttpsAcc,omitempty"`
	// The QPS for static content delivery over HTTPS.
	StaticHttpsQps *float32 `json:"StaticHttpsQps,omitempty" xml:"StaticHttpsQps,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetAcc(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.Acc = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetDynamicHttpAcc(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.DynamicHttpAcc = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetDynamicHttpQps(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.DynamicHttpQps = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetDynamicHttpsAcc(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.DynamicHttpsAcc = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetDynamicHttpsQps(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.DynamicHttpsQps = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetQps(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.Qps = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetStaticHttpAcc(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.StaticHttpAcc = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetStaticHttpQps(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.StaticHttpQps = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetStaticHttpsAcc(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.StaticHttpsAcc = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetStaticHttpsQps(v float32) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.StaticHttpsQps = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainQpsDataResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainQpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainQpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainQpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainQpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataResponse) SetBody(v *DescribeDcdnDomainQpsDataResponseBody) *DescribeDcdnDomainQpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainQpsDataByLayerRequest struct {
	// The QPS returned at each time interval.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The number of queries per second outside the Chinese mainland.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The layer at which the data was collected.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum data granularity is 5 minutes.
	//
	// If you do not set this parameter, data in the last 24 hours is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The accelerated domain name.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The number of requests in the Chinese mainland.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainQpsDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataByLayerRequest) SetDomainName(v string) *DescribeDcdnDomainQpsDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerRequest) SetEndTime(v string) *DescribeDcdnDomainQpsDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerRequest) SetInterval(v string) *DescribeDcdnDomainQpsDataByLayerRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerRequest) SetIspNameEn(v string) *DescribeDcdnDomainQpsDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerRequest) SetLayer(v string) *DescribeDcdnDomainQpsDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerRequest) SetLocationNameEn(v string) *DescribeDcdnDomainQpsDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerRequest) SetStartTime(v string) *DescribeDcdnDomainQpsDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainQpsDataByLayerResponseBody struct {
	// The end of the time range during which data was queried.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The name of the ISP. You can call the DescribeDcdnRegionAndIsp operation to query the ISP name. If you do not specify a value for this parameter, all ISPs are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The layers at which you want to query the QPS. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all.
	//
	// Default value: all.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeDcdnDomainQpsDataByLayer**.
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The name of the region. You can call the DescribeDcdnRegionAndIsp operation to query the region name. If you do not specify a value for this parameter, all regions are queried.
	QpsDataInterval *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval `json:"QpsDataInterval,omitempty" xml:"QpsDataInterval,omitempty" type:"Struct"`
	// The timestamp of the data returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of requests.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainQpsDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBody) SetDataInterval(v string) *DescribeDcdnDomainQpsDataByLayerResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBody) SetDomainName(v string) *DescribeDcdnDomainQpsDataByLayerResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBody) SetEndTime(v string) *DescribeDcdnDomainQpsDataByLayerResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBody) SetLayer(v string) *DescribeDcdnDomainQpsDataByLayerResponseBody {
	s.Layer = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBody) SetQpsDataInterval(v *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval) *DescribeDcdnDomainQpsDataByLayerResponseBody {
	s.QpsDataInterval = v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBody) SetRequestId(v string) *DescribeDcdnDomainQpsDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBody) SetStartTime(v string) *DescribeDcdnDomainQpsDataByLayerResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval struct {
	DataModule []*DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval) SetDataModule(v []*DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule struct {
	// The number of requests outside the Chinese mainland.
	AccDomesticValue *string `json:"AccDomesticValue,omitempty" xml:"AccDomesticValue,omitempty"`
	// The beginning of the time range during which data was queried.
	AccOverseasValue *string `json:"AccOverseasValue,omitempty" xml:"AccOverseasValue,omitempty"`
	// The number of queries per second in the Chinese mainland.
	AccValue *string `json:"AccValue,omitempty" xml:"AccValue,omitempty"`
	// The time interval between the data entries returned. Unit: seconds.
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The total number of queries per second.
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The time interval between the data entries to return. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The accelerated domain name. You can specify multiple domain names and separate them with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated.
	//
	// If you do not specify a domain name, data of all domain names is queried.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetAccDomesticValue(v string) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.AccDomesticValue = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetAccOverseasValue(v string) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.AccOverseasValue = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetAccValue(v string) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.AccValue = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetDomesticValue(v string) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetOverseasValue(v string) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule) SetValue(v string) *DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDcdnDomainQpsDataByLayerResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainQpsDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainQpsDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainQpsDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainQpsDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainQpsDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponse) SetStatusCode(v int32) *DescribeDcdnDomainQpsDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainQpsDataByLayerResponse) SetBody(v *DescribeDcdnDomainQpsDataByLayerResponseBody) *DescribeDcdnDomainQpsDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeBpsDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeBpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainRealTimeBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainRealTimeBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeBpsDataResponseBody struct {
	// The list of the data returned.
	Data *DescribeDcdnDomainRealTimeBpsDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainRealTimeBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponseBody) SetData(v *DescribeDcdnDomainRealTimeBpsDataResponseBodyData) *DescribeDcdnDomainRealTimeBpsDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeBpsDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainRealTimeBpsDataResponseBodyData struct {
	BpsModel []*DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel `json:"BpsModel,omitempty" xml:"BpsModel,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeBpsDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeBpsDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponseBodyData) SetBpsModel(v []*DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel) *DescribeDcdnDomainRealTimeBpsDataResponseBodyData {
	s.BpsModel = v
	return s
}

type DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel struct {
	// The bandwidth, in bit/s.
	Bps *float32 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel) SetBps(v float32) *DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel {
	s.Bps = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainRealTimeBpsDataResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeBpsDataResponse) SetBody(v *DescribeDcdnDomainRealTimeBpsDataResponseBody) *DescribeDcdnDomainRealTimeBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeByteHitRateDataRequest struct {
	// The domain name. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeByteHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeByteHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeByteHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeByteHitRateDataResponseBody struct {
	// The list of byte hit ratios.
	Data *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponseBody) SetData(v *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData) *DescribeDcdnDomainRealTimeByteHitRateDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeByteHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData struct {
	ByteHitRateDataModel []*DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel `json:"ByteHitRateDataModel,omitempty" xml:"ByteHitRateDataModel,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData) SetByteHitRateDataModel(v []*DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData {
	s.ByteHitRateDataModel = v
	return s
}

type DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel struct {
	// The byte hit ratio.
	ByteHitRate *float32 `json:"ByteHitRate,omitempty" xml:"ByteHitRate,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) SetByteHitRate(v float32) *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel {
	s.ByteHitRate = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainRealTimeByteHitRateDataResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeByteHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeByteHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeByteHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeByteHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeByteHitRateDataResponse) SetBody(v *DescribeDcdnDomainRealTimeByteHitRateDataResponseBody) *DescribeDcdnDomainRealTimeByteHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeDetailDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time, and the maximum time range to query is 10 minutes.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of information that you want to query. Separate multiple types with commas (,). Valid values:
	//
	// *   **qps**: queries per second (QPS)
	// *   **bps**: bandwidth
	// *   **http_code**: HTTP status code
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The name of the ISP. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query the ISP name.
	//
	// If you leave this parameter empty, all ISPs are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query the region name.
	//
	// If you leave this parameter empty, all regions are queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// Specifies whether to return a summary value. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// Default value: **false**.
	Merge *string `json:"Merge,omitempty" xml:"Merge,omitempty"`
	// Specifies whether to return a summary value of **LocationNameEn** and **IspNameEn**. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// Default value: **false**.
	MergeLocIsp *string `json:"MergeLocIsp,omitempty" xml:"MergeLocIsp,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeDetailDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeDetailDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetField(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.Field = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetMerge(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.Merge = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetMergeLocIsp(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.MergeLocIsp = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeDetailDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeDetailDataResponseBody struct {
	// The information returned.
	//
	// > The value of this parameter is a JSON string. The following table describes the fields in Data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainRealTimeDetailDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeDetailDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeDetailDataResponseBody) SetData(v string) *DescribeDcdnDomainRealTimeDetailDataResponseBody {
	s.Data = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeDetailDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainRealTimeDetailDataResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeDetailDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeDetailDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeDetailDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeDetailDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeDetailDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeDetailDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeDetailDataResponse) SetBody(v *DescribeDcdnDomainRealTimeDetailDataResponseBody) *DescribeDcdnDomainRealTimeDetailDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeHttpCodeDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainRealTimeHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainRealTimeHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeHttpCodeDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The proportions of the HTTP status codes.
	RealTimeHttpCodeData *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData `json:"RealTimeHttpCodeData,omitempty" xml:"RealTimeHttpCodeData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) SetRealTimeHttpCodeData(v *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody {
	s.RealTimeHttpCodeData = v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData struct {
	UsageData []*DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) SetUsageData(v []*DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData {
	s.UsageData = v
	return s
}

type DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The information about the HTTP status code returned.
	Value *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) SetValue(v *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData {
	s.Value = v
	return s
}

type DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue struct {
	RealTimeCodeProportionData []*DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData `json:"RealTimeCodeProportionData,omitempty" xml:"RealTimeCodeProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) SetRealTimeCodeProportionData(v []*DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue {
	s.RealTimeCodeProportionData = v
	return s
}

type DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData struct {
	// The HTTP status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The count of each HTTP status code.
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetCode(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Code = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetCount(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Count = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetProportion(v string) *DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Proportion = &v
	return s
}

type DescribeDcdnDomainRealTimeHttpCodeDataResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeHttpCodeDataResponse) SetBody(v *DescribeDcdnDomainRealTimeHttpCodeDataResponseBody) *DescribeDcdnDomainRealTimeHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeQpsDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeQpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeQpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeQpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeQpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeQpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainRealTimeQpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainRealTimeQpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeQpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeQpsDataResponseBody struct {
	// The information about the backup set.
	Data *DescribeDcdnDomainRealTimeQpsDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainRealTimeQpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeQpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponseBody) SetData(v *DescribeDcdnDomainRealTimeQpsDataResponseBodyData) *DescribeDcdnDomainRealTimeQpsDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeQpsDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainRealTimeQpsDataResponseBodyData struct {
	QpsModel []*DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel `json:"QpsModel,omitempty" xml:"QpsModel,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeQpsDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeQpsDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponseBodyData) SetQpsModel(v []*DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel) *DescribeDcdnDomainRealTimeQpsDataResponseBodyData {
	s.QpsModel = v
	return s
}

type DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel struct {
	// The number of queries per second (QPS).
	Qps *float32 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel) SetQps(v float32) *DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel {
	s.Qps = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainRealTimeQpsDataResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeQpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeQpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeQpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeQpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeQpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeQpsDataResponse) SetBody(v *DescribeDcdnDomainRealTimeQpsDataResponseBody) *DescribeDcdnDomainRealTimeQpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeReqHitRateDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time needs to be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeReqHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeReqHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeReqHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeReqHitRateDataResponseBody struct {
	// The list of byte hit ratios.
	Data *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponseBody) SetData(v *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData) *DescribeDcdnDomainRealTimeReqHitRateDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeReqHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData struct {
	ReqHitRateDataModel []*DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel `json:"ReqHitRateDataModel,omitempty" xml:"ReqHitRateDataModel,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData) SetReqHitRateDataModel(v []*DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData {
	s.ReqHitRateDataModel = v
	return s
}

type DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel struct {
	// The request hit ratio.
	ReqHitRate *float32 `json:"ReqHitRate,omitempty" xml:"ReqHitRate,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) SetReqHitRate(v float32) *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel {
	s.ReqHitRate = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnDomainRealTimeReqHitRateDataResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeReqHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeReqHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeReqHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeReqHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeReqHitRateDataResponse) SetBody(v *DescribeDcdnDomainRealTimeReqHitRateDataResponseBody) *DescribeDcdnDomainRealTimeReqHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeSrcBpsDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeSrcBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeSrcBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeSrcBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcBpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. The returned value is 60 (1 minute), 300 (5 minutes), or 3600(1 hour). For more information, see **Usage notes**.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The origin bandwidth data returned at each time interval. Unit: bit/s.
	RealTimeSrcBpsDataPerInterval *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval `json:"RealTimeSrcBpsDataPerInterval,omitempty" xml:"RealTimeSrcBpsDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) SetRealTimeSrcBpsDataPerInterval(v *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody {
	s.RealTimeSrcBpsDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval struct {
	DataModule []*DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval) SetDataModule(v []*DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The bandwidth value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule) SetValue(v string) *DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcBpsDataResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeSrcBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeSrcBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcBpsDataResponse) SetBody(v *DescribeDcdnDomainRealTimeSrcBpsDataResponseBody) *DescribeDcdnDomainRealTimeSrcBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The proportions of HTTP status codes at each time interval.
	RealTimeSrcHttpCodeData *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData `json:"RealTimeSrcHttpCodeData,omitempty" xml:"RealTimeSrcHttpCodeData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) SetRealTimeSrcHttpCodeData(v *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody {
	s.RealTimeSrcHttpCodeData = v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData struct {
	UsageData []*DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData) SetUsageData(v []*DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData {
	s.UsageData = v
	return s
}

type DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The proportions of the HTTP status codes.
	Value *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData) SetValue(v *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData {
	s.Value = v
	return s
}

type DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue struct {
	RealTimeSrcCodeProportionData []*DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData `json:"RealTimeSrcCodeProportionData,omitempty" xml:"RealTimeSrcCodeProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue) SetRealTimeSrcCodeProportionData(v []*DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue {
	s.RealTimeSrcCodeProportionData = v
	return s
}

type DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData struct {
	// The HTTP status code returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of HTTP status codes.
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) SetCode(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData {
	s.Code = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) SetCount(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData {
	s.Count = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData) SetProportion(v string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData {
	s.Proportion = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse) SetBody(v *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody) *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeSrcTrafficDataRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600(1 hour). For more information, see **Usage notes**.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The amount of origin traffic returned at each time interval. Unit: bytes.
	RealTimeSrcTrafficDataPerInterval *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval `json:"RealTimeSrcTrafficDataPerInterval,omitempty" xml:"RealTimeSrcTrafficDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) SetRealTimeSrcTrafficDataPerInterval(v *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody {
	s.RealTimeSrcTrafficDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval struct {
	DataModule []*DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval) SetDataModule(v []*DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic value at each time interval.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDcdnDomainRealTimeSrcTrafficDataResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeSrcTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeSrcTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeSrcTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeSrcTrafficDataResponse) SetBody(v *DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody) *DescribeDcdnDomainRealTimeSrcTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRealTimeTrafficDataRequest struct {
	// The accelerated domain name. You can specify one or more domain names and separate them with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time.
	//
	// > If you do not specify StartTime or EndTime, data within the last hour is queried. If you specify both StartTime and EndTime, data within the specified time range is queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > If you do not specify StartTime or EndTime, data within the last hour is queried. If you specify both StartTime and EndTime, data within the specified time range is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeTrafficDataRequest) SetDomainName(v string) *DescribeDcdnDomainRealTimeTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataRequest) SetEndTime(v string) *DescribeDcdnDomainRealTimeTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataRequest) SetStartTime(v string) *DescribeDcdnDomainRealTimeTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeTrafficDataResponseBody struct {
	// The time interval between the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600(1 hour). For more information, see **Usage notes**.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The amount of back-to-origin traffic returned at each interval.
	RealTimeTrafficDataPerInterval *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval `json:"RealTimeTrafficDataPerInterval,omitempty" xml:"RealTimeTrafficDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainRealTimeTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainRealTimeTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainRealTimeTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBody) SetRealTimeTrafficDataPerInterval(v *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) *DescribeDcdnDomainRealTimeTrafficDataResponseBody {
	s.RealTimeTrafficDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRealTimeTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainRealTimeTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval struct {
	DataModule []*DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) SetDataModule(v []*DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic value at each time interval.
	//
	// > The network traffic is measured in bytes.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDcdnDomainRealTimeTrafficDataResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRealTimeTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRealTimeTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRealTimeTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRealTimeTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRealTimeTrafficDataResponse) SetBody(v *DescribeDcdnDomainRealTimeTrafficDataResponseBody) *DescribeDcdnDomainRealTimeTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainRegionDataRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	//
	// If you do not specify an accelerated domain name, the data of all accelerated domain names that belong to your account is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainRegionDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRegionDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRegionDataRequest) SetDomainName(v string) *DescribeDcdnDomainRegionDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataRequest) SetEndTime(v string) *DescribeDcdnDomainRegionDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataRequest) SetStartTime(v string) *DescribeDcdnDomainRegionDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainRegionDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The proportions of requests that were initiated from each region.
	Value *DescribeDcdnDomainRegionDataResponseBodyValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainRegionDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRegionDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRegionDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainRegionDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainRegionDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainRegionDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainRegionDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainRegionDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBody) SetValue(v *DescribeDcdnDomainRegionDataResponseBodyValue) *DescribeDcdnDomainRegionDataResponseBody {
	s.Value = v
	return s
}

type DescribeDcdnDomainRegionDataResponseBodyValue struct {
	RegionProportionData []*DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData `json:"RegionProportionData,omitempty" xml:"RegionProportionData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainRegionDataResponseBodyValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRegionDataResponseBodyValue) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValue) SetRegionProportionData(v []*DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) *DescribeDcdnDomainRegionDataResponseBodyValue {
	s.RegionProportionData = v
	return s
}

type DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData struct {
	// The average response size. Unit: bytes.
	AvgObjectSize *string `json:"AvgObjectSize,omitempty" xml:"AvgObjectSize,omitempty"`
	// The average response speed. Unit: byte/s.
	AvgResponseRate *string `json:"AvgResponseRate,omitempty" xml:"AvgResponseRate,omitempty"`
	// The average response time. Unit: milliseconds.
	AvgResponseTime *string `json:"AvgResponseTime,omitempty" xml:"AvgResponseTime,omitempty"`
	// The bandwidth.
	Bps *string `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The proportion of network traffic. For example, a value of 90 indicates that 90% of network traffic was coming from the specified ISP.
	BytesProportion *string `json:"BytesProportion,omitempty" xml:"BytesProportion,omitempty"`
	// The proportion of requests from the specified region based on the total number of requests in percentile. For example, a value of 90 indicates that 90% of the requests were coming from the specified region.
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
	// The number of queries per second (QPS).
	Qps *string `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The information of the regions.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The name of the region.
	RegionEname *string `json:"RegionEname,omitempty" xml:"RegionEname,omitempty"`
	// The total amount of network traffic.
	TotalBytes *string `json:"TotalBytes,omitempty" xml:"TotalBytes,omitempty"`
	// The total number of requests that are destined for your website.
	TotalQuery *string `json:"TotalQuery,omitempty" xml:"TotalQuery,omitempty"`
}

func (s DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetAvgObjectSize(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.AvgObjectSize = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetAvgResponseRate(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.AvgResponseRate = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetAvgResponseTime(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.AvgResponseTime = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetBps(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.Bps = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetBytesProportion(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.BytesProportion = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetProportion(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.Proportion = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetQps(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.Qps = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetRegion(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.Region = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetRegionEname(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.RegionEname = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetTotalBytes(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.TotalBytes = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData) SetTotalQuery(v string) *DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData {
	s.TotalQuery = &v
	return s
}

type DescribeDcdnDomainRegionDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainRegionDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainRegionDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainRegionDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainRegionDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainRegionDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainRegionDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainRegionDataResponse) SetBody(v *DescribeDcdnDomainRegionDataResponseBody) *DescribeDcdnDomainRegionDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainStagingConfigRequest struct {
	// The names of the features to query. You can specify multiple features and separate them with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
}

func (s DescribeDcdnDomainStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainStagingConfigRequest) SetDomainName(v string) *DescribeDcdnDomainStagingConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainStagingConfigRequest) SetFunctionNames(v string) *DescribeDcdnDomainStagingConfigRequest {
	s.FunctionNames = &v
	return s
}

type DescribeDcdnDomainStagingConfigResponseBody struct {
	// The status of the feature. Valid values:
	//
	// *   success
	// *   testing
	// *   failed
	// *   configuring
	DomainConfigs []*DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Repeated"`
	// The configurations of accelerated domain names returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnDomainStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainStagingConfigResponseBody) SetDomainConfigs(v []*DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs) *DescribeDcdnDomainStagingConfigResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeDcdnDomainStagingConfigResponseBody) SetRequestId(v string) *DescribeDcdnDomainStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs struct {
	// The name of the feature.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The name of the configuration.
	FunctionArgs []*DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Repeated"`
	// The descriptions of a feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The ID of the configuration.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs) SetConfigId(v string) *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs {
	s.ConfigId = &v
	return s
}

func (s *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs) SetFunctionArgs(v []*DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs {
	s.FunctionArgs = v
	return s
}

func (s *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs) SetFunctionName(v string) *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs {
	s.FunctionName = &v
	return s
}

func (s *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs) SetStatus(v string) *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs {
	s.Status = &v
	return s
}

type DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs struct {
	// The value of the configuration.
	ArgName  *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) SetArgName(v string) *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs {
	s.ArgName = &v
	return s
}

func (s *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs) SetArgValue(v string) *DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs {
	s.ArgValue = &v
	return s
}

type DescribeDcdnDomainStagingConfigResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainStagingConfigResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainStagingConfigResponse) SetStatusCode(v int32) *DescribeDcdnDomainStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainStagingConfigResponse) SetBody(v *DescribeDcdnDomainStagingConfigResponseBody) *DescribeDcdnDomainStagingConfigResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainTopReferVisitRequest struct {
	// The accelerated domain name. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The sorting order. Valid values:
	//
	// *   **traf**: by network traffic
	// *   **pv**: by the number of visits
	//
	// Default value: **pv**.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// To query the data on a specified day, use the yyyy-MM-ddT16:00:00Z format.
	//
	// If you do not set this parameter, data collected within the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainTopReferVisitRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopReferVisitRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopReferVisitRequest) SetDomainName(v string) *DescribeDcdnDomainTopReferVisitRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitRequest) SetSortBy(v string) *DescribeDcdnDomainTopReferVisitRequest {
	s.SortBy = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitRequest) SetStartTime(v string) *DescribeDcdnDomainTopReferVisitRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainTopReferVisitResponseBody struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The list of frequently referenced URLs returned.
	TopReferList *DescribeDcdnDomainTopReferVisitResponseBodyTopReferList `json:"TopReferList,omitempty" xml:"TopReferList,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainTopReferVisitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopReferVisitResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopReferVisitResponseBody) SetDomainName(v string) *DescribeDcdnDomainTopReferVisitResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponseBody) SetRequestId(v string) *DescribeDcdnDomainTopReferVisitResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponseBody) SetStartTime(v string) *DescribeDcdnDomainTopReferVisitResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponseBody) SetTopReferList(v *DescribeDcdnDomainTopReferVisitResponseBodyTopReferList) *DescribeDcdnDomainTopReferVisitResponseBody {
	s.TopReferList = v
	return s
}

type DescribeDcdnDomainTopReferVisitResponseBodyTopReferList struct {
	ReferList []*DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList `json:"ReferList,omitempty" xml:"ReferList,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainTopReferVisitResponseBodyTopReferList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopReferVisitResponseBodyTopReferList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopReferVisitResponseBodyTopReferList) SetReferList(v []*DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) *DescribeDcdnDomainTopReferVisitResponseBodyTopReferList {
	s.ReferList = v
	return s
}

type DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList struct {
	// The amount of network traffic. (Unit: bytes)
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete referenced URL.
	ReferDetail *string `json:"ReferDetail,omitempty" xml:"ReferDetail,omitempty"`
	// The number of visits.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits to the URL.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) SetFlow(v string) *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList {
	s.Flow = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) SetFlowProportion(v float32) *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) SetReferDetail(v string) *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList {
	s.ReferDetail = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) SetVisitData(v string) *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList {
	s.VisitData = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList) SetVisitProportion(v float32) *DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList {
	s.VisitProportion = &v
	return s
}

type DescribeDcdnDomainTopReferVisitResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainTopReferVisitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainTopReferVisitResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopReferVisitResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopReferVisitResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainTopReferVisitResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponse) SetStatusCode(v int32) *DescribeDcdnDomainTopReferVisitResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainTopReferVisitResponse) SetBody(v *DescribeDcdnDomainTopReferVisitResponseBody) *DescribeDcdnDomainTopReferVisitResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainTopUrlVisitRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The sorting order. Valid values:
	//
	// *   **traf**: by network traffic
	// *   **pv**: by the number of visits
	//
	// Default value: **pv**
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The start of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	//
	// To query the data on a specified day, use the format: yyyy-MM-ddT16:00:00Z.
	//
	// > If you do not specify this parameter, the data in the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainTopUrlVisitRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitRequest) SetDomainName(v string) *DescribeDcdnDomainTopUrlVisitRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitRequest) SetSortBy(v string) *DescribeDcdnDomainTopUrlVisitRequest {
	s.SortBy = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitRequest) SetStartTime(v string) *DescribeDcdnDomainTopUrlVisitRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBody struct {
	// A list of frequently requested URLs.
	AllUrlList *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList `json:"AllUrlList,omitempty" xml:"AllUrlList,omitempty" type:"Struct"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// A list of URLs for which 2xx status codes were returned.
	Url200List *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List `json:"Url200List,omitempty" xml:"Url200List,omitempty" type:"Struct"`
	// A list of URLs for which 3xx status codes were returned.
	Url300List *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List `json:"Url300List,omitempty" xml:"Url300List,omitempty" type:"Struct"`
	// A list of URLs for which 4xx status codes were returned.
	Url400List *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List `json:"Url400List,omitempty" xml:"Url400List,omitempty" type:"Struct"`
	// A list of URLs for which 5xx status codes were returned.
	Url500List *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List `json:"Url500List,omitempty" xml:"Url500List,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetAllUrlList(v *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.AllUrlList = v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetDomainName(v string) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetRequestId(v string) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetStartTime(v string) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetUrl200List(v *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.Url200List = v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetUrl300List(v *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.Url300List = v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetUrl400List(v *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.Url400List = v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBody) SetUrl500List(v *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List) *DescribeDcdnDomainTopUrlVisitResponseBody {
	s.Url500List = v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList struct {
	UrlList []*DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList) SetUrlList(v []*DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList {
	s.UrlList = v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList struct {
	// The amount of network traffic. (Unit: bytes)
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetFlow(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetFlowProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetUrlDetail(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetVisitData(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList) SetVisitProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List struct {
	UrlList []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List) SetUrlList(v []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List {
	s.UrlList = v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList struct {
	// The amount of network traffic. (Unit: bytes)
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetFlow(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetFlowProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetUrlDetail(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetVisitData(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList) SetVisitProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List struct {
	UrlList []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List) SetUrlList(v []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List {
	s.UrlList = v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList struct {
	// The amount of network traffic. (Unit: bytes)
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetFlow(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetFlowProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetUrlDetail(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetVisitData(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList) SetVisitProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List struct {
	UrlList []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List) SetUrlList(v []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List {
	s.UrlList = v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList struct {
	// The amount of network traffic. (Unit: bytes)
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetFlow(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetFlowProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetUrlDetail(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetVisitData(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList) SetVisitProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List struct {
	UrlList []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List) SetUrlList(v []*DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List {
	s.UrlList = v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList struct {
	// The amount of network traffic. (Unit: bytes)
	Flow *string `json:"Flow,omitempty" xml:"Flow,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	FlowProportion *float32 `json:"FlowProportion,omitempty" xml:"FlowProportion,omitempty"`
	// The complete URL.
	UrlDetail *string `json:"UrlDetail,omitempty" xml:"UrlDetail,omitempty"`
	// The number of visits.
	VisitData *string `json:"VisitData,omitempty" xml:"VisitData,omitempty"`
	// The proportion of visits.
	VisitProportion *float32 `json:"VisitProportion,omitempty" xml:"VisitProportion,omitempty"`
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetFlow(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.Flow = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetFlowProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.FlowProportion = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetUrlDetail(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.UrlDetail = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetVisitData(v string) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.VisitData = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList) SetVisitProportion(v float32) *DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList {
	s.VisitProportion = &v
	return s
}

type DescribeDcdnDomainTopUrlVisitResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainTopUrlVisitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainTopUrlVisitResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTopUrlVisitResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTopUrlVisitResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainTopUrlVisitResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponse) SetStatusCode(v int32) *DescribeDcdnDomainTopUrlVisitResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainTopUrlVisitResponse) SetBody(v *DescribeDcdnDomainTopUrlVisitResponseBody) *DescribeDcdnDomainTopUrlVisitResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainTrafficDataRequest struct {
	// The accelerated domain name.
	//
	// Separate multiple domain names with commas (,). If you do not specify a value for this parameter, network traffic of all accelerated domain names is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the data entries. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs. If you do not specify an ISP, network traffic of all ISPs is queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions. If you do not specify a region, network traffic in all regions is queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTrafficDataRequest) SetDomainName(v string) *DescribeDcdnDomainTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataRequest) SetEndTime(v string) *DescribeDcdnDomainTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataRequest) SetInterval(v string) *DescribeDcdnDomainTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataRequest) SetStartTime(v string) *DescribeDcdnDomainTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The network traffic returned at each time interval. Unit: bytes.
	TrafficDataPerInterval *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval `json:"TrafficDataPerInterval,omitempty" xml:"TrafficDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTrafficDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBody) SetTrafficDataPerInterval(v *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval) *DescribeDcdnDomainTrafficDataResponseBody {
	s.TrafficDataPerInterval = v
	return s
}

type DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval struct {
	DataModule []*DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval) SetDataModule(v []*DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule struct {
	// The network traffic that was consumed to deliver dynamic content over HTTP.
	DynamicHttpTraffic *float32 `json:"DynamicHttpTraffic,omitempty" xml:"DynamicHttpTraffic,omitempty"`
	// The network traffic that was consumed to deliver dynamic content over HTTPS.
	DynamicHttpsTraffic *float32 `json:"DynamicHttpsTraffic,omitempty" xml:"DynamicHttpsTraffic,omitempty"`
	// The network traffic that was consumed to deliver static content over HTTP.
	StaticHttpTraffic *float32 `json:"StaticHttpTraffic,omitempty" xml:"StaticHttpTraffic,omitempty"`
	// The network traffic that was consumed to deliver static content over HTTPS.
	StaticHttpsTraffic *float32 `json:"StaticHttpsTraffic,omitempty" xml:"StaticHttpsTraffic,omitempty"`
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total amount of network traffic.
	Traffic *float32 `json:"Traffic,omitempty" xml:"Traffic,omitempty"`
}

func (s DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetDynamicHttpTraffic(v float32) *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.DynamicHttpTraffic = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetDynamicHttpsTraffic(v float32) *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.DynamicHttpsTraffic = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetStaticHttpTraffic(v float32) *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.StaticHttpTraffic = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetStaticHttpsTraffic(v float32) *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.StaticHttpsTraffic = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetTraffic(v float32) *DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.Traffic = &v
	return s
}

type DescribeDcdnDomainTrafficDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainTrafficDataResponse) SetBody(v *DescribeDcdnDomainTrafficDataResponseBody) *DescribeDcdnDomainTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainUsageDataRequest struct {
	// The billable region. Valid values:
	//
	// *   **CN**: Chinese mainland
	// *   **OverSeas**: outside the Chinese mainland
	// *   **AP1**: Asia Pacific 1
	// *   **AP2**: Asia Pacific 2
	// *   **AP3**: Asia Pacific 3
	// *   **NA**: North America
	// *   **SA**: South America
	// *   **EU**: Europe
	// *   **MEAA**: Middle East and Africa
	// *   **all**: all the preceding billable regions
	//
	// Default value: **CN**
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The protocol by which the data is queried. Valid values:
	//
	// *   **quic**: Quick UDP Internet Connections (QUIC)
	// *   **https**: HTTPS
	// *   **http**: HTTP
	// *   **all**: HTTP, HTTPS, and QUIC
	//
	// Default value: **all**
	DataProtocol *string `json:"DataProtocol,omitempty" xml:"DataProtocol,omitempty"`
	// The accelerated domain name. You can specify up to 100 domain names in each request. Separate multiple domain names with commas (,).
	//
	// > If you do not specify this parameter, the usage data of all accelerated domain names that belong to your Alibaba Cloud account is returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time. The maximum time range that can be queried is 31 days.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of data that you want to query. Valid values:
	//
	// *   **bps**: bandwidth
	// *   **traf**: traffic
	// *   **acc**: requests
	//
	// > If the value is set to **acc**, the **Area** parameter is not supported.
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The time interval between the data entries to return. Unit: seconds.
	//
	// The time interval varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The minimum time granularity at which the data is queried is 5 minutes.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// 
	//
	// - **static**
	// - **dynamic**
	// - **all**
	//
	// **all**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnDomainUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUsageDataRequest) SetArea(v string) *DescribeDcdnDomainUsageDataRequest {
	s.Area = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataRequest) SetDataProtocol(v string) *DescribeDcdnDomainUsageDataRequest {
	s.DataProtocol = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataRequest) SetDomainName(v string) *DescribeDcdnDomainUsageDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataRequest) SetEndTime(v string) *DescribeDcdnDomainUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataRequest) SetField(v string) *DescribeDcdnDomainUsageDataRequest {
	s.Field = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataRequest) SetInterval(v string) *DescribeDcdnDomainUsageDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataRequest) SetStartTime(v string) *DescribeDcdnDomainUsageDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataRequest) SetType(v string) *DescribeDcdnDomainUsageDataRequest {
	s.Type = &v
	return s
}

type DescribeDcdnDomainUsageDataResponseBody struct {
	// The billable region where the usage data was collected.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of the content returned.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The network traffic that was collected at each interval.
	UsageDataPerInterval *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval `json:"UsageDataPerInterval,omitempty" xml:"UsageDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetArea(v string) *DescribeDcdnDomainUsageDataResponseBody {
	s.Area = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainUsageDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainUsageDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainUsageDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetType(v string) *DescribeDcdnDomainUsageDataResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBody) SetUsageDataPerInterval(v *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval) *DescribeDcdnDomainUsageDataResponseBody {
	s.UsageDataPerInterval = v
	return s
}

type DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval struct {
	DataModule []*DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval) SetDataModule(v []*DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule struct {
	// The time of the peak bandwidth value if the **Field** parameter in the request is set to **bps**. Otherwise, this parameter returns the same value as the **TimeStamp** parameter.
	PeakTime *string `json:"PeakTime,omitempty" xml:"PeakTime,omitempty"`
	// The data usage in a specific scenario.
	//
	// > SpecialValue indicates the data usage in a specific scenario. If no special billable item is specified, ignore this parameter.
	SpecialValue *string `json:"SpecialValue,omitempty" xml:"SpecialValue,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The amount of resource usage.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetPeakTime(v string) *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.PeakTime = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetSpecialValue(v string) *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.SpecialValue = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetValue(v string) *DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeDcdnDomainUsageDataResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUsageDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainUsageDataResponse) SetBody(v *DescribeDcdnDomainUsageDataResponseBody) *DescribeDcdnDomainUsageDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainUvDataRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	//
	// If you do not specify a domain name, this operation queries UV data of all accelerated domain names in your account.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainUvDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUvDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUvDataRequest) SetDomainName(v string) *DescribeDcdnDomainUvDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainUvDataRequest) SetEndTime(v string) *DescribeDcdnDomainUvDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainUvDataRequest) SetStartTime(v string) *DescribeDcdnDomainUvDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainUvDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range that was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range that was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The number of UVs at each interval.
	UvDataInterval *DescribeDcdnDomainUvDataResponseBodyUvDataInterval `json:"UvDataInterval,omitempty" xml:"UvDataInterval,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainUvDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUvDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUvDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainUvDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainUvDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainUvDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainUvDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainUvDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainUvDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainUvDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainUvDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainUvDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainUvDataResponseBody) SetUvDataInterval(v *DescribeDcdnDomainUvDataResponseBodyUvDataInterval) *DescribeDcdnDomainUvDataResponseBody {
	s.UvDataInterval = v
	return s
}

type DescribeDcdnDomainUvDataResponseBodyUvDataInterval struct {
	UsageData []*DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainUvDataResponseBodyUvDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUvDataResponseBodyUvDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUvDataResponseBodyUvDataInterval) SetUsageData(v []*DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData) *DescribeDcdnDomainUvDataResponseBodyUvDataInterval {
	s.UsageData = v
	return s
}

type DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData struct {
	// The timestamp of the data returned.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The number of UVs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData) SetTimeStamp(v string) *DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData) SetValue(v string) *DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData {
	s.Value = &v
	return s
}

type DescribeDcdnDomainUvDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainUvDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainUvDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainUvDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainUvDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainUvDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainUvDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainUvDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainUvDataResponse) SetBody(v *DescribeDcdnDomainUvDataResponseBody) *DescribeDcdnDomainUvDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainWebsocketBpsDataRequest struct {
	// The accelerated domain name.
	//
	// Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity for a query. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainWebsocketBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketBpsDataRequest) SetDomainName(v string) *DescribeDcdnDomainWebsocketBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataRequest) SetEndTime(v string) *DescribeDcdnDomainWebsocketBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataRequest) SetInterval(v string) *DescribeDcdnDomainWebsocketBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainWebsocketBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainWebsocketBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataRequest) SetStartTime(v string) *DescribeDcdnDomainWebsocketBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainWebsocketBpsDataResponseBody struct {
	// The bandwidth data returned at each interval.
	BpsDataPerInterval *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval `json:"BpsDataPerInterval,omitempty" xml:"BpsDataPerInterval,omitempty" type:"Struct"`
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainWebsocketBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBody) SetBpsDataPerInterval(v *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval) *DescribeDcdnDomainWebsocketBpsDataResponseBody {
	s.BpsDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainWebsocketBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainWebsocketBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainWebsocketBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainWebsocketBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainWebsocketBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval struct {
	DataModule []*DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval) SetDataModule(v []*DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule) *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The bandwidth value. Unit: bit/s.
	WebsocketBps *float32 `json:"WebsocketBps,omitempty" xml:"WebsocketBps,omitempty"`
}

func (s DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule) SetWebsocketBps(v float32) *DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.WebsocketBps = &v
	return s
}

type DescribeDcdnDomainWebsocketBpsDataResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainWebsocketBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainWebsocketBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainWebsocketBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainWebsocketBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketBpsDataResponse) SetBody(v *DescribeDcdnDomainWebsocketBpsDataResponseBody) *DescribeDcdnDomainWebsocketBpsDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainWebsocketHttpCodeDataRequest struct {
	// The accelerated domain name. You can specify multiple accelerated domain names and separate them with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity for a query. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataRequest) SetDomainName(v string) *DescribeDcdnDomainWebsocketHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataRequest) SetEndTime(v string) *DescribeDcdnDomainWebsocketHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataRequest) SetInterval(v string) *DescribeDcdnDomainWebsocketHttpCodeDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainWebsocketHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainWebsocketHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataRequest) SetStartTime(v string) *DescribeDcdnDomainWebsocketHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainWebsocketHttpCodeDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The HTTP status code.
	HttpCodeDataPerInterval *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval `json:"HttpCodeDataPerInterval,omitempty" xml:"HttpCodeDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) SetHttpCodeDataPerInterval(v *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody {
	s.HttpCodeDataPerInterval = v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval struct {
	DataModule []*DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval) SetDataModule(v []*DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The proportions of the HTTP status codes.
	WebsocketHttpCode *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode `json:"WebsocketHttpCode,omitempty" xml:"WebsocketHttpCode,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule) SetWebsocketHttpCode(v *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule {
	s.WebsocketHttpCode = v
	return s
}

type DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode struct {
	HttpCodeDataModule []*DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule `json:"HttpCodeDataModule,omitempty" xml:"HttpCodeDataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode) SetHttpCodeDataModule(v []*DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode {
	s.HttpCodeDataModule = v
	return s
}

type DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule struct {
	// The HTTP status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The total number of entries returned.
	Count *float32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code.
	Proportion *float32 `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule) SetCode(v int32) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule {
	s.Code = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule) SetCount(v float32) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule {
	s.Count = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule) SetProportion(v float32) *DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule {
	s.Proportion = &v
	return s
}

type DescribeDcdnDomainWebsocketHttpCodeDataResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainWebsocketHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainWebsocketHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketHttpCodeDataResponse) SetBody(v *DescribeDcdnDomainWebsocketHttpCodeDataResponseBody) *DescribeDcdnDomainWebsocketHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnDomainWebsocketTrafficDataRequest struct {
	// The accelerated domain name.
	//
	// Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity for a query. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the ISP.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region.
	//
	// You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnDomainWebsocketTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketTrafficDataRequest) SetDomainName(v string) *DescribeDcdnDomainWebsocketTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataRequest) SetEndTime(v string) *DescribeDcdnDomainWebsocketTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataRequest) SetInterval(v string) *DescribeDcdnDomainWebsocketTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataRequest) SetIspNameEn(v string) *DescribeDcdnDomainWebsocketTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataRequest) SetLocationNameEn(v string) *DescribeDcdnDomainWebsocketTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataRequest) SetStartTime(v string) *DescribeDcdnDomainWebsocketTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnDomainWebsocketTrafficDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The network traffic returned at each time interval. Unit: bytes.
	TrafficDataPerInterval *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval `json:"TrafficDataPerInterval,omitempty" xml:"TrafficDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBody) SetDataInterval(v string) *DescribeDcdnDomainWebsocketTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBody) SetDomainName(v string) *DescribeDcdnDomainWebsocketTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBody) SetEndTime(v string) *DescribeDcdnDomainWebsocketTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBody) SetRequestId(v string) *DescribeDcdnDomainWebsocketTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBody) SetStartTime(v string) *DescribeDcdnDomainWebsocketTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBody) SetTrafficDataPerInterval(v *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval) *DescribeDcdnDomainWebsocketTrafficDataResponseBody {
	s.TrafficDataPerInterval = v
	return s
}

type DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval struct {
	DataModule []*DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval) SetDataModule(v []*DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule) *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule struct {
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total volume of traffic.
	WebsocketTraffic *float32 `json:"WebsocketTraffic,omitempty" xml:"WebsocketTraffic,omitempty"`
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetWebsocketTraffic(v float32) *DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.WebsocketTraffic = &v
	return s
}

type DescribeDcdnDomainWebsocketTrafficDataResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnDomainWebsocketTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnDomainWebsocketTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnDomainWebsocketTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponse) SetStatusCode(v int32) *DescribeDcdnDomainWebsocketTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnDomainWebsocketTrafficDataResponse) SetBody(v *DescribeDcdnDomainWebsocketTrafficDataResponseBody) *DescribeDcdnDomainWebsocketTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnErUsageDataRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the routine.
	RoutineID *string `json:"RoutineID,omitempty" xml:"RoutineID,omitempty"`
	// The specification of the routine. Valid values:
	//
	// *   5ms
	// *   50ms
	// *   100ms
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// Specifies how the results are grouped. If you set this parameter to routine, the returned results are grouped based on the routine ID. If you set this parameter to spec, the returned results are grouped based on the routine specification.
	//
	// > If you leave this parameter empty, the returned results are not grouped.
	SplitBy *string `json:"SplitBy,omitempty" xml:"SplitBy,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnErUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnErUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnErUsageDataRequest) SetEndTime(v string) *DescribeDcdnErUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnErUsageDataRequest) SetRoutineID(v string) *DescribeDcdnErUsageDataRequest {
	s.RoutineID = &v
	return s
}

func (s *DescribeDcdnErUsageDataRequest) SetSpec(v string) *DescribeDcdnErUsageDataRequest {
	s.Spec = &v
	return s
}

func (s *DescribeDcdnErUsageDataRequest) SetSplitBy(v string) *DescribeDcdnErUsageDataRequest {
	s.SplitBy = &v
	return s
}

func (s *DescribeDcdnErUsageDataRequest) SetStartTime(v string) *DescribeDcdnErUsageDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnErUsageDataResponseBody struct {
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The list of the data returned.
	ErAccData *DescribeDcdnErUsageDataResponseBodyErAccData `json:"ErAccData,omitempty" xml:"ErAccData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnErUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnErUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnErUsageDataResponseBody) SetEndTime(v string) *DescribeDcdnErUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnErUsageDataResponseBody) SetErAccData(v *DescribeDcdnErUsageDataResponseBodyErAccData) *DescribeDcdnErUsageDataResponseBody {
	s.ErAccData = v
	return s
}

func (s *DescribeDcdnErUsageDataResponseBody) SetRequestId(v string) *DescribeDcdnErUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnErUsageDataResponseBody) SetStartTime(v string) *DescribeDcdnErUsageDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeDcdnErUsageDataResponseBodyErAccData struct {
	ErAccItem []*DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem `json:"ErAccItem,omitempty" xml:"ErAccItem,omitempty" type:"Repeated"`
}

func (s DescribeDcdnErUsageDataResponseBodyErAccData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnErUsageDataResponseBodyErAccData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnErUsageDataResponseBodyErAccData) SetErAccItem(v []*DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem) *DescribeDcdnErUsageDataResponseBodyErAccData {
	s.ErAccItem = v
	return s
}

type DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem struct {
	// The number of requests.
	ErAcc *int64 `json:"ErAcc,omitempty" xml:"ErAcc,omitempty"`
	// The ID of the routine. This parameter is returned only when SplitBy is set to routine.
	Routine *string `json:"Routine,omitempty" xml:"Routine,omitempty"`
	// The specification of the routine. This parameter is returned only when SplitBy is set to spec.
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The timestamp of the returned data.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem) GoString() string {
	return s.String()
}

func (s *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem) SetErAcc(v int64) *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem {
	s.ErAcc = &v
	return s
}

func (s *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem) SetRoutine(v string) *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem {
	s.Routine = &v
	return s
}

func (s *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem) SetSpec(v string) *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem {
	s.Spec = &v
	return s
}

func (s *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem) SetTimeStamp(v string) *DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnErUsageDataResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnErUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnErUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnErUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnErUsageDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnErUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnErUsageDataResponse) SetStatusCode(v int32) *DescribeDcdnErUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnErUsageDataResponse) SetBody(v *DescribeDcdnErUsageDataResponseBody) *DescribeDcdnErUsageDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnFullDomainsBlockIPConfigRequest struct {
	// The IP address or CIDR block to query. Separate multiple values with commas (,). You can specify up to 50 IP addresses or CIDR blocks.
	IPList *string `json:"IPList,omitempty" xml:"IPList,omitempty"`
}

func (s DescribeDcdnFullDomainsBlockIPConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnFullDomainsBlockIPConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnFullDomainsBlockIPConfigRequest) SetIPList(v string) *DescribeDcdnFullDomainsBlockIPConfigRequest {
	s.IPList = &v
	return s
}

type DescribeDcdnFullDomainsBlockIPConfigResponseBody struct {
	// The response code.
	//
	// The value of Code is not 0 in the following scenarios:
	//
	// *   The format of the IP address is invalid.
	// *   The number of IP addresses exceeds the limit.
	// *   Other abnormal scenarios
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned results. If the operation is successful, URLs of OSS objects are returned. If the operation fails, an error message is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnFullDomainsBlockIPConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnFullDomainsBlockIPConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnFullDomainsBlockIPConfigResponseBody) SetCode(v int32) *DescribeDcdnFullDomainsBlockIPConfigResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPConfigResponseBody) SetMessage(v string) *DescribeDcdnFullDomainsBlockIPConfigResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPConfigResponseBody) SetRequestId(v string) *DescribeDcdnFullDomainsBlockIPConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnFullDomainsBlockIPConfigResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnFullDomainsBlockIPConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnFullDomainsBlockIPConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnFullDomainsBlockIPConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnFullDomainsBlockIPConfigResponse) SetHeaders(v map[string]*string) *DescribeDcdnFullDomainsBlockIPConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPConfigResponse) SetStatusCode(v int32) *DescribeDcdnFullDomainsBlockIPConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPConfigResponse) SetBody(v *DescribeDcdnFullDomainsBlockIPConfigResponseBody) *DescribeDcdnFullDomainsBlockIPConfigResponse {
	s.Body = v
	return s
}

type DescribeDcdnFullDomainsBlockIPHistoryRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IP address or CIDR block to query.
	IPList *string `json:"IPList,omitempty" xml:"IPList,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnFullDomainsBlockIPHistoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnFullDomainsBlockIPHistoryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryRequest) SetEndTime(v string) *DescribeDcdnFullDomainsBlockIPHistoryRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryRequest) SetIPList(v string) *DescribeDcdnFullDomainsBlockIPHistoryRequest {
	s.IPList = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryRequest) SetStartTime(v string) *DescribeDcdnFullDomainsBlockIPHistoryRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnFullDomainsBlockIPHistoryResponseBody struct {
	// The response code.
	//
	// The value of Code is not 0 in the following scenarios:
	//
	// *   The format of the IP address is invalid.
	// *   The format of the time is invalid.
	// *   Other abnormal scenarios
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The description of the status returned.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The result of the operation.
	IPBlockInfo []*DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo `json:"IPBlockInfo,omitempty" xml:"IPBlockInfo,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnFullDomainsBlockIPHistoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnFullDomainsBlockIPHistoryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponseBody) SetCode(v int32) *DescribeDcdnFullDomainsBlockIPHistoryResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponseBody) SetDescription(v string) *DescribeDcdnFullDomainsBlockIPHistoryResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponseBody) SetIPBlockInfo(v []*DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo) *DescribeDcdnFullDomainsBlockIPHistoryResponseBody {
	s.IPBlockInfo = v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponseBody) SetRequestId(v string) *DescribeDcdnFullDomainsBlockIPHistoryResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo struct {
	// The blocked IP address or CIDR block.
	BlockIP *string `json:"BlockIP,omitempty" xml:"BlockIP,omitempty"`
	// The delivery time.
	DeliverTime *string `json:"DeliverTime,omitempty" xml:"DeliverTime,omitempty"`
	// The delivery status.
	//
	// *   Success
	// *   Failed
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo) GoString() string {
	return s.String()
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo) SetBlockIP(v string) *DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo {
	s.BlockIP = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo) SetDeliverTime(v string) *DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo {
	s.DeliverTime = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo) SetStatus(v string) *DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo {
	s.Status = &v
	return s
}

type DescribeDcdnFullDomainsBlockIPHistoryResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnFullDomainsBlockIPHistoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnFullDomainsBlockIPHistoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnFullDomainsBlockIPHistoryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponse) SetHeaders(v map[string]*string) *DescribeDcdnFullDomainsBlockIPHistoryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponse) SetStatusCode(v int32) *DescribeDcdnFullDomainsBlockIPHistoryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnFullDomainsBlockIPHistoryResponse) SetBody(v *DescribeDcdnFullDomainsBlockIPHistoryResponseBody) *DescribeDcdnFullDomainsBlockIPHistoryResponse {
	s.Body = v
	return s
}

type DescribeDcdnHttpsDomainListRequest struct {
	// The status of the certificate. Valid values:
	//
	// *   **ok**: The certificate is working as expected.
	// *   **mismatch**: The certificate does not match the specified domain name.
	// *   **expired**: The certificate has expired.
	// *   **expire_soon**: The certificate is about to expire.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The total number of entries returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The type of the certificate. Valid values:
	//
	// *   **free**: A free certificate.
	// *   **cas**: A certificate that is purchased through Alibaba Cloud SSL Certificates Service.
	// *   **upload**: A user-uploaded certificate.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeDcdnHttpsDomainListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnHttpsDomainListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnHttpsDomainListRequest) SetKeyword(v string) *DescribeDcdnHttpsDomainListRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListRequest) SetPageNumber(v int32) *DescribeDcdnHttpsDomainListRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListRequest) SetPageSize(v int32) *DescribeDcdnHttpsDomainListRequest {
	s.PageSize = &v
	return s
}

type DescribeDcdnHttpsDomainListResponseBody struct {
	// The time when the certificate became effective.
	CertInfos *DescribeDcdnHttpsDomainListResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The returned primary domain name of the certificate.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries to return on each page. Valid values: **1 to 500**. Default value: **20**.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnHttpsDomainListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnHttpsDomainListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnHttpsDomainListResponseBody) SetCertInfos(v *DescribeDcdnHttpsDomainListResponseBodyCertInfos) *DescribeDcdnHttpsDomainListResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBody) SetRequestId(v string) *DescribeDcdnHttpsDomainListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBody) SetTotalCount(v int32) *DescribeDcdnHttpsDomainListResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnHttpsDomainListResponseBodyCertInfos struct {
	CertInfo []*DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeDcdnHttpsDomainListResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnHttpsDomainListResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfos) SetCertInfo(v []*DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) *DescribeDcdnHttpsDomainListResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo struct {
	// The certificate information about the domain name.
	CertCommonName *string `json:"CertCommonName,omitempty" xml:"CertCommonName,omitempty"`
	// The name of the certificate.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The accelerated domain name for which the certificate information was queried.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The time when the certificate expires.
	CertStartTime *string `json:"CertStartTime,omitempty" xml:"CertStartTime,omitempty"`
	// The number of pages to return. Valid values: **1 to 100000**.
	CertStatus *string `json:"CertStatus,omitempty" xml:"CertStatus,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeDcdnHttpsDomainList**.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The keyword used for search.
	CertUpdateTime *string `json:"CertUpdateTime,omitempty" xml:"CertUpdateTime,omitempty"`
	// The time when the certificate was updated.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertCommonName(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertCommonName = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertName(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertStartTime(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertStartTime = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertStatus(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertStatus = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetCertUpdateTime(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.CertUpdateTime = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo) SetDomainName(v string) *DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo {
	s.DomainName = &v
	return s
}

type DescribeDcdnHttpsDomainListResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnHttpsDomainListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnHttpsDomainListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnHttpsDomainListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnHttpsDomainListResponse) SetHeaders(v map[string]*string) *DescribeDcdnHttpsDomainListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponse) SetStatusCode(v int32) *DescribeDcdnHttpsDomainListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnHttpsDomainListResponse) SetBody(v *DescribeDcdnHttpsDomainListResponseBody) *DescribeDcdnHttpsDomainListResponse {
	s.Body = v
	return s
}

type DescribeDcdnIpInfoRequest struct {
	// The IP address. You can specify only one IP address.
	IP *string `json:"IP,omitempty" xml:"IP,omitempty"`
}

func (s DescribeDcdnIpInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpInfoRequest) SetIP(v string) *DescribeDcdnIpInfoRequest {
	s.IP = &v
	return s
}

type DescribeDcdnIpInfoResponseBody struct {
	// Indicates whether the specified IP address is assigned to an Alibaba Cloud DCDN POP.
	//
	// *   True
	// *   False
	DcdnIp *string `json:"DcdnIp,omitempty" xml:"DcdnIp,omitempty"`
	// The ISP to which the specified IP address belongs.
	ISP *string `json:"ISP,omitempty" xml:"ISP,omitempty"`
	// The name of the Internet service provider (ISP).
	IspEname *string `json:"IspEname,omitempty" xml:"IspEname,omitempty"`
	// The Chinese name of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The English name of the region.
	RegionEname *string `json:"RegionEname,omitempty" xml:"RegionEname,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnIpInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpInfoResponseBody) SetDcdnIp(v string) *DescribeDcdnIpInfoResponseBody {
	s.DcdnIp = &v
	return s
}

func (s *DescribeDcdnIpInfoResponseBody) SetISP(v string) *DescribeDcdnIpInfoResponseBody {
	s.ISP = &v
	return s
}

func (s *DescribeDcdnIpInfoResponseBody) SetIspEname(v string) *DescribeDcdnIpInfoResponseBody {
	s.IspEname = &v
	return s
}

func (s *DescribeDcdnIpInfoResponseBody) SetRegion(v string) *DescribeDcdnIpInfoResponseBody {
	s.Region = &v
	return s
}

func (s *DescribeDcdnIpInfoResponseBody) SetRegionEname(v string) *DescribeDcdnIpInfoResponseBody {
	s.RegionEname = &v
	return s
}

func (s *DescribeDcdnIpInfoResponseBody) SetRequestId(v string) *DescribeDcdnIpInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnIpInfoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnIpInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnIpInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnIpInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnIpInfoResponse) SetStatusCode(v int32) *DescribeDcdnIpInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnIpInfoResponse) SetBody(v *DescribeDcdnIpInfoResponseBody) *DescribeDcdnIpInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnIpaDomainConfigsRequest struct {
	// The accelerated domain name. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the feature. Set the value to protogw, which indicates IP Application Accelerator (IPA).
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnIpaDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainConfigsRequest) SetDomainName(v string) *DescribeDcdnIpaDomainConfigsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsRequest) SetFunctionNames(v string) *DescribeDcdnIpaDomainConfigsRequest {
	s.FunctionNames = &v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsRequest) SetOwnerId(v int64) *DescribeDcdnIpaDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsRequest) SetSecurityToken(v string) *DescribeDcdnIpaDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnIpaDomainConfigsResponseBody struct {
	// The configurations of the domain name.
	DomainConfigs *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnIpaDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainConfigsResponseBody) SetDomainConfigs(v *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs) *DescribeDcdnIpaDomainConfigsResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsResponseBody) SetRequestId(v string) *DescribeDcdnIpaDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs struct {
	DomainConfig []*DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig `json:"DomainConfig,omitempty" xml:"DomainConfig,omitempty" type:"Repeated"`
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs) SetDomainConfig(v []*DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs {
	s.DomainConfig = v
	return s
}

type DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig struct {
	// The ID of the configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The list of features.
	FunctionArgs *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Struct"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The configuration status of the feature. Valid values:
	//
	// *   **success**
	// *   **testing**
	// *   **failed**
	// *   **configuring**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig) SetConfigId(v string) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.ConfigId = &v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionArgs(v *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionArgs = v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionName(v string) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionName = &v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig) SetStatus(v string) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.Status = &v
	return s
}

type DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs struct {
	FunctionArg []*DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg `json:"FunctionArg,omitempty" xml:"FunctionArg,omitempty" type:"Repeated"`
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) SetFunctionArg(v []*DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs {
	s.FunctionArg = v
	return s
}

type DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg struct {
	// The name of the configuration.
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The value of the configuration.
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgName(v string) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgName = &v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgValue(v string) *DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgValue = &v
	return s
}

type DescribeDcdnIpaDomainConfigsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnIpaDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnIpaDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainConfigsResponse) SetHeaders(v map[string]*string) *DescribeDcdnIpaDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsResponse) SetStatusCode(v int32) *DescribeDcdnIpaDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnIpaDomainConfigsResponse) SetBody(v *DescribeDcdnIpaDomainConfigsResponseBody) *DescribeDcdnIpaDomainConfigsResponse {
	s.Body = v
	return s
}

type DescribeDcdnIpaDomainDetailRequest struct {
	// The accelerated domain names for which you want to query basic information. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnIpaDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainDetailRequest) SetDomainName(v string) *DescribeDcdnIpaDomainDetailRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailRequest) SetOwnerId(v int64) *DescribeDcdnIpaDomainDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailRequest) SetSecurityToken(v string) *DescribeDcdnIpaDomainDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnIpaDomainDetailResponseBody struct {
	// The details about the accelerated domain name.
	DomainDetail *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail `json:"DomainDetail,omitempty" xml:"DomainDetail,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnIpaDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainDetailResponseBody) SetDomainDetail(v *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) *DescribeDcdnIpaDomainDetailResponseBody {
	s.DomainDetail = v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBody) SetRequestId(v string) *DescribeDcdnIpaDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnIpaDomainDetailResponseBodyDomainDetail struct {
	// Indicates the name of the certificate if the HTTPS protocol is enabled.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The CNAME assigned to the domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The accelerated domain names.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   **online**: enabled
	// *   **offline**: disabled
	// *   **configuring**: configuring
	// *   **configure_failed**: configuration failed
	// *   **checking**: reviewing
	// *   **check_failed:** review failed
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The creation time.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the domain name was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the Security Socket Layer (SSL) certificate is enabled. Valid values:
	//
	// *   **on**
	// *   **off**.
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The public key of the certificate if HTTPS is enabled.
	SSLPub *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	// The acceleration region. Valid values:
	//
	// *   domestic: Chinese mainland
	// *   overseas: outside the Chinese mainland
	// *   global: global
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The information about the origin server.
	Sources *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
}

func (s DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetCertName(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetCname(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.Cname = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetDescription(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.Description = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetDomainName(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetDomainStatus(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.DomainStatus = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetGmtCreated(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.GmtCreated = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetGmtModified(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetResourceGroupId(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetSSLProtocol(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.SSLProtocol = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetSSLPub(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.SSLPub = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetScope(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.Scope = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail) SetSources(v *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetail {
	s.Sources = v
	return s
}

type DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources struct {
	Source []*DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources) SetSource(v []*DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources {
	s.Source = v
	return s
}

type DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The status.
	Enabled *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The custom port. Valid values: **0** to **65535**.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server. Valid values:
	//
	// *   **ipaddr**: an origin IP address
	// *   **domain**: a domain name.
	// *   **oss**: Object Storage Service (OSS) buckets are not supported.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) SetContent(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) SetEnabled(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Enabled = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) SetPort(v int32) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) SetPriority(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) SetType(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource) SetWeight(v string) *DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Weight = &v
	return s
}

type DescribeDcdnIpaDomainDetailResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnIpaDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnIpaDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaDomainDetailResponse) SetHeaders(v map[string]*string) *DescribeDcdnIpaDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponse) SetStatusCode(v int32) *DescribeDcdnIpaDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnIpaDomainDetailResponse) SetBody(v *DescribeDcdnIpaDomainDetailResponseBody) *DescribeDcdnIpaDomainDetailResponse {
	s.Body = v
	return s
}

type DescribeDcdnIpaServiceRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnIpaServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaServiceRequest) SetOwnerId(v int64) *DescribeDcdnIpaServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnIpaServiceRequest) SetSecurityToken(v string) *DescribeDcdnIpaServiceRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnIpaServiceResponseBody struct {
	// The time when the change of the billing method starts to take effect. The time is in GMT. This time appears on the frontend only when it is later than the current time.
	ChangingAffectTime *string `json:"ChangingAffectTime,omitempty" xml:"ChangingAffectTime,omitempty"`
	// The new billing method to take effect. Valid values:
	//
	// *   **PayByTraffic**: pay-by-data-transfer
	// *   **PayByBandwidth**: pay-by-bandwidth
	// *   **PayByBandwidth95**: pay-by-95th percentile bandwidth
	// *   **PayByBandwidth_monthavg**: pay-by-monthly average bandwidth
	// *   **PayByBandwidth_month4th**: pay-by-fourth peak bandwidth per month
	// *   **PayByBandwidth_monthday95avg**: pay-by-monthly average 95th percentile bandwidth
	// *   **PayByBandwidth_nighthalf95**: pay-by-95th percentile bandwidth (50% off during nighttime)
	ChangingChargeType *string `json:"ChangingChargeType,omitempty" xml:"ChangingChargeType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   **PayByTraffic**: pay-by-data-transfer
	// *   **PayByBandwidth**: pay-by-bandwidth
	// *   **PayByBandwidth95**: pay-by-95th percentile bandwidth
	// *   **PayByBandwidth_monthavg**: pay-by-monthly average bandwidth
	// *   **PayByBandwidth_month4th**: pay-by-fourth peak bandwidth per month
	// *   **PayByBandwidth_monthday95avg**: pay-by-monthly average 95th percentile bandwidth
	// *   **PayByBandwidth_nighthalf95**: pay-by-95th percentile bandwidth (50% off during nighttime)
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The time when the DCDN service was activated. The time follows the ISO 8601 standard.
	OpeningTime *string `json:"OpeningTime,omitempty" xml:"OpeningTime,omitempty"`
	// The lock status of secure DCDN.
	OperationLocks *DescribeDcdnIpaServiceResponseBodyOperationLocks `json:"OperationLocks,omitempty" xml:"OperationLocks,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnIpaServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaServiceResponseBody) SetChangingAffectTime(v string) *DescribeDcdnIpaServiceResponseBody {
	s.ChangingAffectTime = &v
	return s
}

func (s *DescribeDcdnIpaServiceResponseBody) SetChangingChargeType(v string) *DescribeDcdnIpaServiceResponseBody {
	s.ChangingChargeType = &v
	return s
}

func (s *DescribeDcdnIpaServiceResponseBody) SetInstanceId(v string) *DescribeDcdnIpaServiceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDcdnIpaServiceResponseBody) SetInternetChargeType(v string) *DescribeDcdnIpaServiceResponseBody {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeDcdnIpaServiceResponseBody) SetOpeningTime(v string) *DescribeDcdnIpaServiceResponseBody {
	s.OpeningTime = &v
	return s
}

func (s *DescribeDcdnIpaServiceResponseBody) SetOperationLocks(v *DescribeDcdnIpaServiceResponseBodyOperationLocks) *DescribeDcdnIpaServiceResponseBody {
	s.OperationLocks = v
	return s
}

func (s *DescribeDcdnIpaServiceResponseBody) SetRequestId(v string) *DescribeDcdnIpaServiceResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnIpaServiceResponseBodyOperationLocks struct {
	LockReason []*DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason `json:"LockReason,omitempty" xml:"LockReason,omitempty" type:"Repeated"`
}

func (s DescribeDcdnIpaServiceResponseBodyOperationLocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaServiceResponseBodyOperationLocks) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaServiceResponseBodyOperationLocks) SetLockReason(v []*DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason) *DescribeDcdnIpaServiceResponseBodyOperationLocks {
	s.LockReason = v
	return s
}

type DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason struct {
	// The reason why the instance is locked. For example, a value of **financial** indicates that an overdue payment exists.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
}

func (s DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason) SetLockReason(v string) *DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason {
	s.LockReason = &v
	return s
}

type DescribeDcdnIpaServiceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnIpaServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnIpaServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaServiceResponse) SetHeaders(v map[string]*string) *DescribeDcdnIpaServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnIpaServiceResponse) SetStatusCode(v int32) *DescribeDcdnIpaServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnIpaServiceResponse) SetBody(v *DescribeDcdnIpaServiceResponseBody) *DescribeDcdnIpaServiceResponse {
	s.Body = v
	return s
}

type DescribeDcdnIpaUserDomainsRequest struct {
	// Specifies whether to display domain names that are under review, failed the review, or failed to be configured. Valid values:
	//
	// *   **true**
	// *   **false**
	CheckDomainShow *bool `json:"CheckDomainShow,omitempty" xml:"CheckDomainShow,omitempty"`
	// The domain name that is used as a keyword to filter domain names. Fuzzy match is supported.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The search method. Default value: full_match. Valid values:
	//
	// *   **fuzzy_match**: fuzzy match
	// *   **pre_match**: prefix match
	// *   **suf_match**: suffix match
	// *   **full_match**: exact match
	DomainSearchType *string `json:"DomainSearchType,omitempty" xml:"DomainSearchType,omitempty"`
	// The status of the domain name. Valid values:
	//
	// *   **online**: enabled
	// *   **offline**: disabled
	// *   **configuring**: configuring
	// *   **configure_failed**: configuration failed
	// *   **checking**: reviewing
	// *   **check_failed:** review failed
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The status of the feature.
	//
	// *   config: The feature is enabled.
	// *   unconfig: The feature is not enabled.
	FuncFilter *string `json:"FuncFilter,omitempty" xml:"FuncFilter,omitempty"`
	// The ID of the feature. For example, a value of 7 specifies the feature of configuring an expiration rule for a specific directory. For more information about feature IDs, see [Parameters for configuring features for domain names](~~410622~~).
	FuncId  *string `json:"FuncId,omitempty" xml:"FuncId,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number of the returned page. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names to return on each page. Default value: **20**. Maximum value: **500**. Valid values: an integer between **1** and **500**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags of the command.
	Tag []*DescribeDcdnIpaUserDomainsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeDcdnIpaUserDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetCheckDomainShow(v bool) *DescribeDcdnIpaUserDomainsRequest {
	s.CheckDomainShow = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetDomainName(v string) *DescribeDcdnIpaUserDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetDomainSearchType(v string) *DescribeDcdnIpaUserDomainsRequest {
	s.DomainSearchType = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetDomainStatus(v string) *DescribeDcdnIpaUserDomainsRequest {
	s.DomainStatus = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetFuncFilter(v string) *DescribeDcdnIpaUserDomainsRequest {
	s.FuncFilter = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetFuncId(v string) *DescribeDcdnIpaUserDomainsRequest {
	s.FuncId = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetOwnerId(v int64) *DescribeDcdnIpaUserDomainsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetPageNumber(v int32) *DescribeDcdnIpaUserDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetPageSize(v int32) *DescribeDcdnIpaUserDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetResourceGroupId(v string) *DescribeDcdnIpaUserDomainsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequest) SetTag(v []*DescribeDcdnIpaUserDomainsRequestTag) *DescribeDcdnIpaUserDomainsRequest {
	s.Tag = v
	return s
}

type DescribeDcdnIpaUserDomainsRequestTag struct {
	// The tag key. Valid values of N: 1 to 20. You can call the TagDcdnResources operation to set a tag for a domain name.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. Valid values of N: 1 to 20.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnIpaUserDomainsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsRequestTag) SetKey(v string) *DescribeDcdnIpaUserDomainsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsRequestTag) SetValue(v string) *DescribeDcdnIpaUserDomainsRequestTag {
	s.Value = &v
	return s
}

type DescribeDcdnIpaUserDomainsResponseBody struct {
	// The array that consists of multiple PageData parameters. The details about each accelerated domain name are included in a separate PageData parameter.
	Domains *DescribeDcdnIpaUserDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnIpaUserDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsResponseBody) SetDomains(v *DescribeDcdnIpaUserDomainsResponseBodyDomains) *DescribeDcdnIpaUserDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBody) SetPageNumber(v int64) *DescribeDcdnIpaUserDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBody) SetPageSize(v int64) *DescribeDcdnIpaUserDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBody) SetRequestId(v string) *DescribeDcdnIpaUserDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBody) SetTotalCount(v int64) *DescribeDcdnIpaUserDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnIpaUserDomainsResponseBodyDomains struct {
	PageData []*DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomains) SetPageData(v []*DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) *DescribeDcdnIpaUserDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData struct {
	// The CNAME assigned to the accelerated domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The reason why the accelerated domain name failed the review.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   **online**: enabled
	// *   **offline**: disabled
	// *   **configuring**: configuring
	// *   **configure_failed**: configuration failed
	// *   **checking**: reviewing
	// *   **check_failed:** review failed
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the accelerated domain name was added to Alibaba Cloud CDN.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the accelerated domain name was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of HTTPS.
	//
	// *   **on**
	// *   **off**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// Indicates whether the accelerated domain name was in a sandbox.
	Sandbox *string `json:"Sandbox,omitempty" xml:"Sandbox,omitempty"`
	// The information about the origin server.
	Sources *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetCname(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetDescription(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetResourceGroupId(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetSSLProtocol(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.SSLProtocol = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetSandbox(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.Sandbox = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData) SetSources(v *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

type DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources struct {
	Source []*DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources) SetSource(v []*DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The port of the origin server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource) SetWeight(v string) *DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Weight = &v
	return s
}

type DescribeDcdnIpaUserDomainsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnIpaUserDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnIpaUserDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnIpaUserDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnIpaUserDomainsResponse) SetHeaders(v map[string]*string) *DescribeDcdnIpaUserDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponse) SetStatusCode(v int32) *DescribeDcdnIpaUserDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnIpaUserDomainsResponse) SetBody(v *DescribeDcdnIpaUserDomainsResponseBody) *DescribeDcdnIpaUserDomainsResponse {
	s.Body = v
	return s
}

type DescribeDcdnKvAccountResponseBody struct {
	// The available capacity of all namespaces.
	CapacityString *string `json:"CapacityString,omitempty" xml:"CapacityString,omitempty"`
	// All namespaces have used capacity.
	CapacityUsedString *string `json:"CapacityUsedString,omitempty" xml:"CapacityUsedString,omitempty"`
	// Details about the namespaces.
	NamespaceList []*DescribeDcdnKvAccountResponseBodyNamespaceList `json:"NamespaceList,omitempty" xml:"NamespaceList,omitempty" type:"Repeated"`
	// The maximum number of namespaces that you can apply for by using your account.
	NamespaceQuota *int32 `json:"NamespaceQuota,omitempty" xml:"NamespaceQuota,omitempty"`
	// The number of namespaces that you applied for by using your account.
	NamespaceUsed *int32 `json:"NamespaceUsed,omitempty" xml:"NamespaceUsed,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the account.
	//
	// *   **online**: enabled
	// *   **offline**: disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnKvAccountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvAccountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvAccountResponseBody) SetCapacityString(v string) *DescribeDcdnKvAccountResponseBody {
	s.CapacityString = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBody) SetCapacityUsedString(v string) *DescribeDcdnKvAccountResponseBody {
	s.CapacityUsedString = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBody) SetNamespaceList(v []*DescribeDcdnKvAccountResponseBodyNamespaceList) *DescribeDcdnKvAccountResponseBody {
	s.NamespaceList = v
	return s
}

func (s *DescribeDcdnKvAccountResponseBody) SetNamespaceQuota(v int32) *DescribeDcdnKvAccountResponseBody {
	s.NamespaceQuota = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBody) SetNamespaceUsed(v int32) *DescribeDcdnKvAccountResponseBody {
	s.NamespaceUsed = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBody) SetRequestId(v string) *DescribeDcdnKvAccountResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBody) SetStatus(v string) *DescribeDcdnKvAccountResponseBody {
	s.Status = &v
	return s
}

type DescribeDcdnKvAccountResponseBodyNamespaceList struct {
	// The available capacity of the namespace.
	CapacityString *string `json:"CapacityString,omitempty" xml:"CapacityString,omitempty"`
	// The namespace has used capacity.
	CapacityUsedString *string `json:"CapacityUsedString,omitempty" xml:"CapacityUsedString,omitempty"`
	// The description of the namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The status of the namespace. Valid values:
	//
	// *   **online**: normal
	// *   **delete**: pending delete
	// *   **deleting**: being deleted
	// *   **deleted**: deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnKvAccountResponseBodyNamespaceList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvAccountResponseBodyNamespaceList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvAccountResponseBodyNamespaceList) SetCapacityString(v string) *DescribeDcdnKvAccountResponseBodyNamespaceList {
	s.CapacityString = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBodyNamespaceList) SetCapacityUsedString(v string) *DescribeDcdnKvAccountResponseBodyNamespaceList {
	s.CapacityUsedString = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBodyNamespaceList) SetDescription(v string) *DescribeDcdnKvAccountResponseBodyNamespaceList {
	s.Description = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBodyNamespaceList) SetNamespace(v string) *DescribeDcdnKvAccountResponseBodyNamespaceList {
	s.Namespace = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBodyNamespaceList) SetNamespaceId(v string) *DescribeDcdnKvAccountResponseBodyNamespaceList {
	s.NamespaceId = &v
	return s
}

func (s *DescribeDcdnKvAccountResponseBodyNamespaceList) SetStatus(v string) *DescribeDcdnKvAccountResponseBodyNamespaceList {
	s.Status = &v
	return s
}

type DescribeDcdnKvAccountResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnKvAccountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnKvAccountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvAccountResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvAccountResponse) SetHeaders(v map[string]*string) *DescribeDcdnKvAccountResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnKvAccountResponse) SetStatusCode(v int32) *DescribeDcdnKvAccountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnKvAccountResponse) SetBody(v *DescribeDcdnKvAccountResponseBody) *DescribeDcdnKvAccountResponse {
	s.Body = v
	return s
}

type DescribeDcdnKvAccountStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the account.
	//
	// *   **online**
	// *   **offline**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnKvAccountStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvAccountStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvAccountStatusResponseBody) SetRequestId(v string) *DescribeDcdnKvAccountStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnKvAccountStatusResponseBody) SetStatus(v string) *DescribeDcdnKvAccountStatusResponseBody {
	s.Status = &v
	return s
}

type DescribeDcdnKvAccountStatusResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnKvAccountStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnKvAccountStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvAccountStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvAccountStatusResponse) SetHeaders(v map[string]*string) *DescribeDcdnKvAccountStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnKvAccountStatusResponse) SetStatusCode(v int32) *DescribeDcdnKvAccountStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnKvAccountStatusResponse) SetBody(v *DescribeDcdnKvAccountStatusResponseBody) *DescribeDcdnKvAccountStatusResponse {
	s.Body = v
	return s
}

type DescribeDcdnKvNamespaceRequest struct {
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DescribeDcdnKvNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvNamespaceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvNamespaceRequest) SetNamespace(v string) *DescribeDcdnKvNamespaceRequest {
	s.Namespace = &v
	return s
}

type DescribeDcdnKvNamespaceResponseBody struct {
	// The available capacity of all namespaces in your account.
	CapacityString *string `json:"CapacityString,omitempty" xml:"CapacityString,omitempty"`
	// The used capacity of all namespaces in your account.
	CapacityUsedString *string `json:"CapacityUsedString,omitempty" xml:"CapacityUsedString,omitempty"`
	// The description of the namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the namespace. Valid values:
	//
	// *   **online**: normal
	// *   **delete**: pending delete
	// *   **deleting**: being deleted
	// *   **deleted**: deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnKvNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvNamespaceResponseBody) SetCapacityString(v string) *DescribeDcdnKvNamespaceResponseBody {
	s.CapacityString = &v
	return s
}

func (s *DescribeDcdnKvNamespaceResponseBody) SetCapacityUsedString(v string) *DescribeDcdnKvNamespaceResponseBody {
	s.CapacityUsedString = &v
	return s
}

func (s *DescribeDcdnKvNamespaceResponseBody) SetDescription(v string) *DescribeDcdnKvNamespaceResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeDcdnKvNamespaceResponseBody) SetNamespace(v string) *DescribeDcdnKvNamespaceResponseBody {
	s.Namespace = &v
	return s
}

func (s *DescribeDcdnKvNamespaceResponseBody) SetNamespaceId(v string) *DescribeDcdnKvNamespaceResponseBody {
	s.NamespaceId = &v
	return s
}

func (s *DescribeDcdnKvNamespaceResponseBody) SetRequestId(v string) *DescribeDcdnKvNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnKvNamespaceResponseBody) SetStatus(v string) *DescribeDcdnKvNamespaceResponseBody {
	s.Status = &v
	return s
}

type DescribeDcdnKvNamespaceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnKvNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnKvNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnKvNamespaceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnKvNamespaceResponse) SetHeaders(v map[string]*string) *DescribeDcdnKvNamespaceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnKvNamespaceResponse) SetStatusCode(v int32) *DescribeDcdnKvNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnKvNamespaceResponse) SetBody(v *DescribeDcdnKvNamespaceResponseBody) *DescribeDcdnKvNamespaceResponse {
	s.Body = v
	return s
}

type DescribeDcdnL2IpsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The CIDR blocks of the POPs.
	Vips []*string `json:"Vips,omitempty" xml:"Vips,omitempty" type:"Repeated"`
}

func (s DescribeDcdnL2IpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnL2IpsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnL2IpsResponseBody) SetRequestId(v string) *DescribeDcdnL2IpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnL2IpsResponseBody) SetVips(v []*string) *DescribeDcdnL2IpsResponseBody {
	s.Vips = v
	return s
}

type DescribeDcdnL2IpsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnL2IpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnL2IpsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnL2IpsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnL2IpsResponse) SetHeaders(v map[string]*string) *DescribeDcdnL2IpsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnL2IpsResponse) SetStatusCode(v int32) *DescribeDcdnL2IpsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnL2IpsResponse) SetBody(v *DescribeDcdnL2IpsResponseBody) *DescribeDcdnL2IpsResponse {
	s.Body = v
	return s
}

type DescribeDcdnL2VipsRequest struct {
	// The domain name. You can specify only one domain name in each request. If you do not specify this parameter, the origin CIDR blocks of all domain names in your account in the whitelist are returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnL2VipsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnL2VipsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnL2VipsRequest) SetDomainName(v string) *DescribeDcdnL2VipsRequest {
	s.DomainName = &v
	return s
}

type DescribeDcdnL2VipsResponseBody struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The virtual IP addresses (VIPs).
	Vips []*string `json:"Vips,omitempty" xml:"Vips,omitempty" type:"Repeated"`
}

func (s DescribeDcdnL2VipsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnL2VipsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnL2VipsResponseBody) SetDomainName(v string) *DescribeDcdnL2VipsResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnL2VipsResponseBody) SetRequestId(v string) *DescribeDcdnL2VipsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnL2VipsResponseBody) SetVips(v []*string) *DescribeDcdnL2VipsResponseBody {
	s.Vips = v
	return s
}

type DescribeDcdnL2VipsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnL2VipsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnL2VipsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnL2VipsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnL2VipsResponse) SetHeaders(v map[string]*string) *DescribeDcdnL2VipsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnL2VipsResponse) SetStatusCode(v int32) *DescribeDcdnL2VipsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnL2VipsResponse) SetBody(v *DescribeDcdnL2VipsResponseBody) *DescribeDcdnL2VipsResponse {
	s.Body = v
	return s
}

type DescribeDcdnRealTimeDeliveryFieldRequest struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
}

func (s DescribeDcdnRealTimeDeliveryFieldRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRealTimeDeliveryFieldRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRealTimeDeliveryFieldRequest) SetBusinessType(v string) *DescribeDcdnRealTimeDeliveryFieldRequest {
	s.BusinessType = &v
	return s
}

type DescribeDcdnRealTimeDeliveryFieldResponseBody struct {
	// The returned results.
	Content *DescribeDcdnRealTimeDeliveryFieldResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnRealTimeDeliveryFieldResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRealTimeDeliveryFieldResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponseBody) SetContent(v *DescribeDcdnRealTimeDeliveryFieldResponseBodyContent) *DescribeDcdnRealTimeDeliveryFieldResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponseBody) SetRequestId(v string) *DescribeDcdnRealTimeDeliveryFieldResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnRealTimeDeliveryFieldResponseBodyContent struct {
	Fields []*DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields `json:"Fields,omitempty" xml:"Fields,omitempty" type:"Repeated"`
}

func (s DescribeDcdnRealTimeDeliveryFieldResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRealTimeDeliveryFieldResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponseBodyContent) SetFields(v []*DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields) *DescribeDcdnRealTimeDeliveryFieldResponseBodyContent {
	s.Fields = v
	return s
}

type DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields struct {
	// The description of the field.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](~~324199~~).
	FieldName *string `json:"FieldName,omitempty" xml:"FieldName,omitempty"`
}

func (s DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields) SetDescription(v string) *DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields {
	s.Description = &v
	return s
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields) SetFieldName(v string) *DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields {
	s.FieldName = &v
	return s
}

type DescribeDcdnRealTimeDeliveryFieldResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnRealTimeDeliveryFieldResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnRealTimeDeliveryFieldResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRealTimeDeliveryFieldResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponse) SetHeaders(v map[string]*string) *DescribeDcdnRealTimeDeliveryFieldResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponse) SetStatusCode(v int32) *DescribeDcdnRealTimeDeliveryFieldResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnRealTimeDeliveryFieldResponse) SetBody(v *DescribeDcdnRealTimeDeliveryFieldResponseBody) *DescribeDcdnRealTimeDeliveryFieldResponse {
	s.Body = v
	return s
}

type DescribeDcdnRefreshQuotaRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnRefreshQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshQuotaRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshQuotaRequest) SetOwnerId(v int64) *DescribeDcdnRefreshQuotaRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaRequest) SetSecurityToken(v string) *DescribeDcdnRefreshQuotaRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnRefreshQuotaResponseBody struct {
	// The maximum number of URLs that can be blocked.
	BlockQuota *string `json:"BlockQuota,omitempty" xml:"BlockQuota,omitempty"`
	// The remaining number of URLs that can be blocked on the current day.
	BlockRemain *string `json:"BlockRemain,omitempty" xml:"BlockRemain,omitempty"`
	// The maximum number of directories that can be refreshed on the current day.
	DirQuota *string `json:"DirQuota,omitempty" xml:"DirQuota,omitempty"`
	// The remaining number of directories that can be refreshed on the current day.
	DirRemain *string `json:"DirRemain,omitempty" xml:"DirRemain,omitempty"`
	// The maximum number of URLs or directories with parameters ignored that can be refreshed on the current day.
	IgnoreParamsQuota *string `json:"IgnoreParamsQuota,omitempty" xml:"IgnoreParamsQuota,omitempty"`
	// The number of remaining URLs or directories that can be refreshed with parameters ignored on the current day.
	IgnoreParamsRemain *string `json:"IgnoreParamsRemain,omitempty" xml:"IgnoreParamsRemain,omitempty"`
	// The maximum number of URLs that can be prefetched on the current day.
	PreloadQuota *string `json:"PreloadQuota,omitempty" xml:"PreloadQuota,omitempty"`
	// The remaining number of URLs that can be prefetched on the current day.
	PreloadRemain *string `json:"PreloadRemain,omitempty" xml:"PreloadRemain,omitempty"`
	// The maximum number of URLs or directories that can be refreshed by using regular expressions on the current day.
	RegexQuota *string `json:"RegexQuota,omitempty" xml:"RegexQuota,omitempty"`
	// The remaining number of URLs or directories that can be refreshed by using regular expressions on the current day.
	RegexRemain *string `json:"RegexRemain,omitempty" xml:"RegexRemain,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The maximum number of URLs that can be refreshed on the current day.
	UrlQuota *string `json:"UrlQuota,omitempty" xml:"UrlQuota,omitempty"`
	// The remaining number of URLs that can be refreshed on the current day.
	UrlRemain *string `json:"UrlRemain,omitempty" xml:"UrlRemain,omitempty"`
}

func (s DescribeDcdnRefreshQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetBlockQuota(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.BlockQuota = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetBlockRemain(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.BlockRemain = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetDirQuota(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.DirQuota = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetDirRemain(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.DirRemain = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetIgnoreParamsQuota(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.IgnoreParamsQuota = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetIgnoreParamsRemain(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.IgnoreParamsRemain = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetPreloadQuota(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.PreloadQuota = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetPreloadRemain(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.PreloadRemain = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetRegexQuota(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.RegexQuota = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetRegexRemain(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.RegexRemain = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetRequestId(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetUrlQuota(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.UrlQuota = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponseBody) SetUrlRemain(v string) *DescribeDcdnRefreshQuotaResponseBody {
	s.UrlRemain = &v
	return s
}

type DescribeDcdnRefreshQuotaResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnRefreshQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnRefreshQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshQuotaResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshQuotaResponse) SetHeaders(v map[string]*string) *DescribeDcdnRefreshQuotaResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponse) SetStatusCode(v int32) *DescribeDcdnRefreshQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnRefreshQuotaResponse) SetBody(v *DescribeDcdnRefreshQuotaResponseBody) *DescribeDcdnRefreshQuotaResponse {
	s.Body = v
	return s
}

type DescribeDcdnRefreshTaskByIdRequest struct {
	// The ID of the task that you want to query. The following signature algorithms require different message digest algorithms:
	//
	// *   Perform the [RefreshDcdnObjectCaches](~~130620~~) operation to query refresh task IDs.
	// *   Perform the [PreloadDcdnObjectCaches](~~130636~~) operation to query prefetch task IDs.
	//
	// > You can specify at most 10 task IDs in each call. Separate IDs with commas (,).
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeDcdnRefreshTaskByIdRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTaskByIdRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTaskByIdRequest) SetTaskId(v string) *DescribeDcdnRefreshTaskByIdRequest {
	s.TaskId = &v
	return s
}

type DescribeDcdnRefreshTaskByIdResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// A list of prefetch or refresh tasks.
	Tasks []*DescribeDcdnRefreshTaskByIdResponseBodyTasks `json:"Tasks,omitempty" xml:"Tasks,omitempty" type:"Repeated"`
	// The total number of tasks.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnRefreshTaskByIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTaskByIdResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTaskByIdResponseBody) SetRequestId(v string) *DescribeDcdnRefreshTaskByIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBody) SetTasks(v []*DescribeDcdnRefreshTaskByIdResponseBodyTasks) *DescribeDcdnRefreshTaskByIdResponseBody {
	s.Tasks = v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBody) SetTotalCount(v int64) *DescribeDcdnRefreshTaskByIdResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnRefreshTaskByIdResponseBodyTasks struct {
	// The time when the task was created. The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The error returned when the refresh or prefetch task failed. Valid values:
	//
	// *   **Internal Error**: An internal error occurred.
	// *   **Origin Timeout**: The response from the origin server timed out.
	// *   **Origin Return StatusCode 5XX**: The origin server returned a 5XX error.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The path of the refresh or prefetch object.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the refresh or prefetch task. Valid values:
	//
	// *   **file**: refreshes an individual file.
	// *   **directory**: refreshes files under the specified directory.
	// *   **preload**: prefetches an individual file.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The progress of the task, in percentage.
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The task status. Valid values:
	//
	// *   **Complete**: The task is complete.
	// *   **Pending**: The task is pending.
	// *   **Refreshing**: The task is running.
	// *   **Failed**: The task failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeDcdnRefreshTaskByIdResponseBodyTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTaskByIdResponseBodyTasks) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTaskByIdResponseBodyTasks) SetCreationTime(v string) *DescribeDcdnRefreshTaskByIdResponseBodyTasks {
	s.CreationTime = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBodyTasks) SetDescription(v string) *DescribeDcdnRefreshTaskByIdResponseBodyTasks {
	s.Description = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBodyTasks) SetObjectPath(v string) *DescribeDcdnRefreshTaskByIdResponseBodyTasks {
	s.ObjectPath = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBodyTasks) SetObjectType(v string) *DescribeDcdnRefreshTaskByIdResponseBodyTasks {
	s.ObjectType = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBodyTasks) SetProcess(v string) *DescribeDcdnRefreshTaskByIdResponseBodyTasks {
	s.Process = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBodyTasks) SetStatus(v string) *DescribeDcdnRefreshTaskByIdResponseBodyTasks {
	s.Status = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponseBodyTasks) SetTaskId(v string) *DescribeDcdnRefreshTaskByIdResponseBodyTasks {
	s.TaskId = &v
	return s
}

type DescribeDcdnRefreshTaskByIdResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnRefreshTaskByIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnRefreshTaskByIdResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTaskByIdResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTaskByIdResponse) SetHeaders(v map[string]*string) *DescribeDcdnRefreshTaskByIdResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponse) SetStatusCode(v int32) *DescribeDcdnRefreshTaskByIdResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnRefreshTaskByIdResponse) SetBody(v *DescribeDcdnRefreshTaskByIdResponseBody) *DescribeDcdnRefreshTaskByIdResponse {
	s.Body = v
	return s
}

type DescribeDcdnRefreshTasksRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The path of the object. The path is used as a condition for exact matching.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **file**: URL-based refresh
	// *   **directory**: directory-based refresh
	// *   **regex**: regular expression-based refresh
	// *   **preload**: URL-based prefetch
	//
	// If you set **DomainName** or **Status**, you must also set this parameter.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Valid values: **1** to **100000**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **50**. Valid values: **1** to **50**.
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **Complete**: The task is complete.
	// *   **Refreshing**: The task is in progress.
	// *   **Failed**: The task failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task. A task ID is assigned when you create a refresh or prefetch task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeDcdnRefreshTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTasksRequest) SetDomainName(v string) *DescribeDcdnRefreshTasksRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetEndTime(v string) *DescribeDcdnRefreshTasksRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetObjectPath(v string) *DescribeDcdnRefreshTasksRequest {
	s.ObjectPath = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetObjectType(v string) *DescribeDcdnRefreshTasksRequest {
	s.ObjectType = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetOwnerId(v int64) *DescribeDcdnRefreshTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetPageNumber(v int32) *DescribeDcdnRefreshTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetPageSize(v int32) *DescribeDcdnRefreshTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetSecurityToken(v string) *DescribeDcdnRefreshTasksRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetStartTime(v string) *DescribeDcdnRefreshTasksRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetStatus(v string) *DescribeDcdnRefreshTasksRequest {
	s.Status = &v
	return s
}

func (s *DescribeDcdnRefreshTasksRequest) SetTaskId(v string) *DescribeDcdnRefreshTasksRequest {
	s.TaskId = &v
	return s
}

type DescribeDcdnRefreshTasksResponseBody struct {
	// The number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tasks.
	Tasks *DescribeDcdnRefreshTasksResponseBodyTasks `json:"Tasks,omitempty" xml:"Tasks,omitempty" type:"Struct"`
	// The number of tasks.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnRefreshTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTasksResponseBody) SetPageNumber(v int64) *DescribeDcdnRefreshTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBody) SetPageSize(v int64) *DescribeDcdnRefreshTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBody) SetRequestId(v string) *DescribeDcdnRefreshTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBody) SetTasks(v *DescribeDcdnRefreshTasksResponseBodyTasks) *DescribeDcdnRefreshTasksResponseBody {
	s.Tasks = v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBody) SetTotalCount(v int64) *DescribeDcdnRefreshTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnRefreshTasksResponseBodyTasks struct {
	Task []*DescribeDcdnRefreshTasksResponseBodyTasksTask `json:"Task,omitempty" xml:"Task,omitempty" type:"Repeated"`
}

func (s DescribeDcdnRefreshTasksResponseBodyTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTasksResponseBodyTasks) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasks) SetTask(v []*DescribeDcdnRefreshTasksResponseBodyTasksTask) *DescribeDcdnRefreshTasksResponseBodyTasks {
	s.Task = v
	return s
}

type DescribeDcdnRefreshTasksResponseBodyTasksTask struct {
	// The time when the task was created. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of error returned when the refresh or prefetch task has failed.
	//
	// *   **InternalError**: An internal error occurred.
	// *   **OriginTimeout**: The response from the origin server timed out.
	// *   **OriginReturn StatusCode 5XX**: The origin server returned a 5XX error.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the object refreshed.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **file**: URL-based refresh
	// *   **path**: directory-based refresh
	// *   **regex**: regular expression-based refresh
	// *   **preload**: URL-based prefetch
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The progress of the task in percentage.
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The status of the auxiliary media asset.
	//
	// *   **Complete**: The task is complete.
	// *   **Refreshing**: The task is in progress.
	// *   **Failed**: The task failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeDcdnRefreshTasksResponseBodyTasksTask) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTasksResponseBodyTasksTask) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasksTask) SetCreationTime(v string) *DescribeDcdnRefreshTasksResponseBodyTasksTask {
	s.CreationTime = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasksTask) SetDescription(v string) *DescribeDcdnRefreshTasksResponseBodyTasksTask {
	s.Description = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasksTask) SetObjectPath(v string) *DescribeDcdnRefreshTasksResponseBodyTasksTask {
	s.ObjectPath = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasksTask) SetObjectType(v string) *DescribeDcdnRefreshTasksResponseBodyTasksTask {
	s.ObjectType = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasksTask) SetProcess(v string) *DescribeDcdnRefreshTasksResponseBodyTasksTask {
	s.Process = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasksTask) SetStatus(v string) *DescribeDcdnRefreshTasksResponseBodyTasksTask {
	s.Status = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponseBodyTasksTask) SetTaskId(v string) *DescribeDcdnRefreshTasksResponseBodyTasksTask {
	s.TaskId = &v
	return s
}

type DescribeDcdnRefreshTasksResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnRefreshTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnRefreshTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRefreshTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRefreshTasksResponse) SetHeaders(v map[string]*string) *DescribeDcdnRefreshTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnRefreshTasksResponse) SetStatusCode(v int32) *DescribeDcdnRefreshTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnRefreshTasksResponse) SetBody(v *DescribeDcdnRefreshTasksResponseBody) *DescribeDcdnRefreshTasksResponse {
	s.Body = v
	return s
}

type DescribeDcdnRegionAndIspRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnRegionAndIspRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRegionAndIspRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRegionAndIspRequest) SetOwnerId(v int64) *DescribeDcdnRegionAndIspRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnRegionAndIspRequest) SetSecurityToken(v string) *DescribeDcdnRegionAndIspRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnRegionAndIspResponseBody struct {
	// The list of ISPs.
	Isps *DescribeDcdnRegionAndIspResponseBodyIsps `json:"Isps,omitempty" xml:"Isps,omitempty" type:"Struct"`
	// The list of regions.
	Regions *DescribeDcdnRegionAndIspResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnRegionAndIspResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRegionAndIspResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRegionAndIspResponseBody) SetIsps(v *DescribeDcdnRegionAndIspResponseBodyIsps) *DescribeDcdnRegionAndIspResponseBody {
	s.Isps = v
	return s
}

func (s *DescribeDcdnRegionAndIspResponseBody) SetRegions(v *DescribeDcdnRegionAndIspResponseBodyRegions) *DescribeDcdnRegionAndIspResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeDcdnRegionAndIspResponseBody) SetRequestId(v string) *DescribeDcdnRegionAndIspResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnRegionAndIspResponseBodyIsps struct {
	Isp []*DescribeDcdnRegionAndIspResponseBodyIspsIsp `json:"Isp,omitempty" xml:"Isp,omitempty" type:"Repeated"`
}

func (s DescribeDcdnRegionAndIspResponseBodyIsps) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRegionAndIspResponseBodyIsps) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRegionAndIspResponseBodyIsps) SetIsp(v []*DescribeDcdnRegionAndIspResponseBodyIspsIsp) *DescribeDcdnRegionAndIspResponseBodyIsps {
	s.Isp = v
	return s
}

type DescribeDcdnRegionAndIspResponseBodyIspsIsp struct {
	// The English name of the region.
	NameEn *string `json:"NameEn,omitempty" xml:"NameEn,omitempty"`
	// The Chinese name of the ISP.
	NameZh *string `json:"NameZh,omitempty" xml:"NameZh,omitempty"`
}

func (s DescribeDcdnRegionAndIspResponseBodyIspsIsp) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRegionAndIspResponseBodyIspsIsp) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRegionAndIspResponseBodyIspsIsp) SetNameEn(v string) *DescribeDcdnRegionAndIspResponseBodyIspsIsp {
	s.NameEn = &v
	return s
}

func (s *DescribeDcdnRegionAndIspResponseBodyIspsIsp) SetNameZh(v string) *DescribeDcdnRegionAndIspResponseBodyIspsIsp {
	s.NameZh = &v
	return s
}

type DescribeDcdnRegionAndIspResponseBodyRegions struct {
	Region []*DescribeDcdnRegionAndIspResponseBodyRegionsRegion `json:"Region,omitempty" xml:"Region,omitempty" type:"Repeated"`
}

func (s DescribeDcdnRegionAndIspResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRegionAndIspResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRegionAndIspResponseBodyRegions) SetRegion(v []*DescribeDcdnRegionAndIspResponseBodyRegionsRegion) *DescribeDcdnRegionAndIspResponseBodyRegions {
	s.Region = v
	return s
}

type DescribeDcdnRegionAndIspResponseBodyRegionsRegion struct {
	// The English name of the region.
	NameEn *string `json:"NameEn,omitempty" xml:"NameEn,omitempty"`
	// The Chinese name of the region.
	NameZh *string `json:"NameZh,omitempty" xml:"NameZh,omitempty"`
}

func (s DescribeDcdnRegionAndIspResponseBodyRegionsRegion) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRegionAndIspResponseBodyRegionsRegion) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRegionAndIspResponseBodyRegionsRegion) SetNameEn(v string) *DescribeDcdnRegionAndIspResponseBodyRegionsRegion {
	s.NameEn = &v
	return s
}

func (s *DescribeDcdnRegionAndIspResponseBodyRegionsRegion) SetNameZh(v string) *DescribeDcdnRegionAndIspResponseBodyRegionsRegion {
	s.NameZh = &v
	return s
}

type DescribeDcdnRegionAndIspResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnRegionAndIspResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnRegionAndIspResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnRegionAndIspResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnRegionAndIspResponse) SetHeaders(v map[string]*string) *DescribeDcdnRegionAndIspResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnRegionAndIspResponse) SetStatusCode(v int32) *DescribeDcdnRegionAndIspResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnRegionAndIspResponse) SetBody(v *DescribeDcdnRegionAndIspResponseBody) *DescribeDcdnRegionAndIspResponse {
	s.Body = v
	return s
}

type DescribeDcdnReportRequest struct {
	// The region. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.
	//
	// *   If you do not specify a region, data in all regions is queried.
	// *   If you specify a region, data in the specified region is returned. You can specify one or more regions. Separate regions with commas (,).
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The domain names that you want to query. Separate domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The HTTP status code. Valid values:
	//
	// *   **2xx**: HTTP 2xx status codes
	// *   **3xx**: HTTP 3xx status codes
	// *   **4xx**: HTTP 4xx status codes
	// *   **5xx**: HTTP 5xx status codes
	//
	// If you do not specify an HTTP status code, data for all preceding HTTP status codes is queried.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// Specify whether the region is outside the Chinese mainland. Valid values:
	//
	// *   **1**: outside the Chinese mainland
	// *   **0**: inside the Chinese mainland
	IsOverseas *string `json:"IsOverseas,omitempty" xml:"IsOverseas,omitempty"`
	// The ID of the operations report that you want to query. You can enter only one ID in each call. You can call the [DescribeDcdnSubList](~~270075~~) operation to query report IDs.
	ReportId *int64 `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnReportRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnReportRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnReportRequest) SetArea(v string) *DescribeDcdnReportRequest {
	s.Area = &v
	return s
}

func (s *DescribeDcdnReportRequest) SetDomainName(v string) *DescribeDcdnReportRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnReportRequest) SetEndTime(v string) *DescribeDcdnReportRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnReportRequest) SetHttpCode(v string) *DescribeDcdnReportRequest {
	s.HttpCode = &v
	return s
}

func (s *DescribeDcdnReportRequest) SetIsOverseas(v string) *DescribeDcdnReportRequest {
	s.IsOverseas = &v
	return s
}

func (s *DescribeDcdnReportRequest) SetReportId(v int64) *DescribeDcdnReportRequest {
	s.ReportId = &v
	return s
}

func (s *DescribeDcdnReportRequest) SetStartTime(v string) *DescribeDcdnReportRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnReportResponseBody struct {
	// The content of the operations report.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnReportResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnReportResponseBody) SetContent(v map[string]interface{}) *DescribeDcdnReportResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnReportResponseBody) SetRequestId(v string) *DescribeDcdnReportResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnReportResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnReportResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnReportResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnReportResponse) SetHeaders(v map[string]*string) *DescribeDcdnReportResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnReportResponse) SetStatusCode(v int32) *DescribeDcdnReportResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnReportResponse) SetBody(v *DescribeDcdnReportResponseBody) *DescribeDcdnReportResponse {
	s.Body = v
	return s
}

type DescribeDcdnReportListRequest struct {
	// The ID of the operations report that you want to query. If you do not specify an ID, all operations reports are queried.
	ReportId *int64 `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
}

func (s DescribeDcdnReportListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnReportListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnReportListRequest) SetReportId(v int64) *DescribeDcdnReportListRequest {
	s.ReportId = &v
	return s
}

type DescribeDcdnReportListResponseBody struct {
	// The information about the operations report.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnReportListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnReportListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnReportListResponseBody) SetContent(v string) *DescribeDcdnReportListResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeDcdnReportListResponseBody) SetRequestId(v string) *DescribeDcdnReportListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnReportListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnReportListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnReportListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnReportListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnReportListResponse) SetHeaders(v map[string]*string) *DescribeDcdnReportListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnReportListResponse) SetStatusCode(v int32) *DescribeDcdnReportListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnReportListResponse) SetBody(v *DescribeDcdnReportListResponseBody) *DescribeDcdnReportListResponse {
	s.Body = v
	return s
}

type DescribeDcdnSLSRealTimeLogTypeResponseBody struct {
	Content   *DescribeDcdnSLSRealTimeLogTypeResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	RequestId *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnSLSRealTimeLogTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealTimeLogTypeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponseBody) SetContent(v *DescribeDcdnSLSRealTimeLogTypeResponseBodyContent) *DescribeDcdnSLSRealTimeLogTypeResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponseBody) SetRequestId(v string) *DescribeDcdnSLSRealTimeLogTypeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnSLSRealTimeLogTypeResponseBodyContent struct {
	Business []*DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness `json:"Business,omitempty" xml:"Business,omitempty" type:"Repeated"`
}

func (s DescribeDcdnSLSRealTimeLogTypeResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealTimeLogTypeResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponseBodyContent) SetBusiness(v []*DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness) *DescribeDcdnSLSRealTimeLogTypeResponseBodyContent {
	s.Business = v
	return s
}

type DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness struct {
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	Desc         *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
}

func (s DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness) SetBusinessType(v string) *DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness {
	s.BusinessType = &v
	return s
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness) SetDesc(v string) *DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness {
	s.Desc = &v
	return s
}

type DescribeDcdnSLSRealTimeLogTypeResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnSLSRealTimeLogTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnSLSRealTimeLogTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealTimeLogTypeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponse) SetHeaders(v map[string]*string) *DescribeDcdnSLSRealTimeLogTypeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponse) SetStatusCode(v int32) *DescribeDcdnSLSRealTimeLogTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnSLSRealTimeLogTypeResponse) SetBody(v *DescribeDcdnSLSRealTimeLogTypeResponseBody) *DescribeDcdnSLSRealTimeLogTypeResponse {
	s.Body = v
	return s
}

type DescribeDcdnSLSRealtimeLogDeliveryRequest struct {
	// The name of a real-time log delivery project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s DescribeDcdnSLSRealtimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealtimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryRequest) SetProjectName(v string) *DescribeDcdnSLSRealtimeLogDeliveryRequest {
	s.ProjectName = &v
	return s
}

type DescribeDcdnSLSRealtimeLogDeliveryResponseBody struct {
	// The configuration results of the domain name.
	Content *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnSLSRealtimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealtimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBody) SetContent(v *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) *DescribeDcdnSLSRealtimeLogDeliveryResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBody) SetRequestId(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The region from which logs were collected.
	DataCenter *string `json:"DataCenter,omitempty" xml:"DataCenter,omitempty"`
	// The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](~~324199~~).
	FieldName *string `json:"FieldName,omitempty" xml:"FieldName,omitempty"`
	// The name of the project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the Logstore.
	SLSLogStore *string `json:"SLSLogStore,omitempty" xml:"SLSLogStore,omitempty"`
	// The name of the log file.
	SLSProject *string `json:"SLSProject,omitempty" xml:"SLSProject,omitempty"`
	// The region to which logs were delivered.
	SLSRegion *string `json:"SLSRegion,omitempty" xml:"SLSRegion,omitempty"`
	// The sampling rate.
	SamplingRate *string `json:"SamplingRate,omitempty" xml:"SamplingRate,omitempty"`
	// The status of real-time logs.
	//
	// *   **success**
	// *   **fail**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of log delivery. Only **SLS_POST** is supported.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetBusinessType(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.BusinessType = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetDataCenter(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.DataCenter = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetDomainName(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetFieldName(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.FieldName = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetProjectName(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.ProjectName = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetSLSLogStore(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.SLSLogStore = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetSLSProject(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.SLSProject = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetSLSRegion(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.SLSRegion = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetSamplingRate(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.SamplingRate = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetStatus(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.Status = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetType(v string) *DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.Type = &v
	return s
}

type DescribeDcdnSLSRealtimeLogDeliveryResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnSLSRealtimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnSLSRealtimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSLSRealtimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponse) SetHeaders(v map[string]*string) *DescribeDcdnSLSRealtimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponse) SetStatusCode(v int32) *DescribeDcdnSLSRealtimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnSLSRealtimeLogDeliveryResponse) SetBody(v *DescribeDcdnSLSRealtimeLogDeliveryResponseBody) *DescribeDcdnSLSRealtimeLogDeliveryResponse {
	s.Body = v
	return s
}

type DescribeDcdnSMCertificateDetailRequest struct {
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken  *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnSMCertificateDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateDetailRequest) SetCertIdentifier(v string) *DescribeDcdnSMCertificateDetailRequest {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailRequest) SetOwnerId(v int64) *DescribeDcdnSMCertificateDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailRequest) SetSecurityToken(v string) *DescribeDcdnSMCertificateDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnSMCertificateDetailResponseBody struct {
	// The time when the certificate expires. The time is displayed in UTC.
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	CertOrg *string `json:"CertOrg,omitempty" xml:"CertOrg,omitempty"`
	// The top-level domain name.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The content of the encryption certificate.
	EncryptCertificate *string `json:"EncryptCertificate,omitempty" xml:"EncryptCertificate,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The domain name on the additional certificate.
	Sans *string `json:"Sans,omitempty" xml:"Sans,omitempty"`
	// The content of the signature certificate.
	SignCertificate *string `json:"SignCertificate,omitempty" xml:"SignCertificate,omitempty"`
}

func (s DescribeDcdnSMCertificateDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetCertExpireTime(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetCertIdentifier(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetCertName(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetCertOrg(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.CertOrg = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetCommonName(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.CommonName = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetEncryptCertificate(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.EncryptCertificate = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetRequestId(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetSans(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.Sans = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponseBody) SetSignCertificate(v string) *DescribeDcdnSMCertificateDetailResponseBody {
	s.SignCertificate = &v
	return s
}

type DescribeDcdnSMCertificateDetailResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnSMCertificateDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnSMCertificateDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateDetailResponse) SetHeaders(v map[string]*string) *DescribeDcdnSMCertificateDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponse) SetStatusCode(v int32) *DescribeDcdnSMCertificateDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnSMCertificateDetailResponse) SetBody(v *DescribeDcdnSMCertificateDetailResponseBody) *DescribeDcdnSMCertificateDetailResponse {
	s.Body = v
	return s
}

type DescribeDcdnSMCertificateListRequest struct {
	// The accelerated domain name whose SM certificates you want to query.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnSMCertificateListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateListRequest) SetDomainName(v string) *DescribeDcdnSMCertificateListRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnSMCertificateListRequest) SetOwnerId(v int64) *DescribeDcdnSMCertificateListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnSMCertificateListRequest) SetSecurityToken(v string) *DescribeDcdnSMCertificateListRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnSMCertificateListResponseBody struct {
	// The type of the certificate information.
	CertificateListModel *DescribeDcdnSMCertificateListResponseBodyCertificateListModel `json:"CertificateListModel,omitempty" xml:"CertificateListModel,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnSMCertificateListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateListResponseBody) SetCertificateListModel(v *DescribeDcdnSMCertificateListResponseBodyCertificateListModel) *DescribeDcdnSMCertificateListResponseBody {
	s.CertificateListModel = v
	return s
}

func (s *DescribeDcdnSMCertificateListResponseBody) SetRequestId(v string) *DescribeDcdnSMCertificateListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnSMCertificateListResponseBodyCertificateListModel struct {
	// A list of certificates.
	CertList []*DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList `json:"CertList,omitempty" xml:"CertList,omitempty" type:"Repeated"`
	// The number of certificates that are returned.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s DescribeDcdnSMCertificateListResponseBodyCertificateListModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateListResponseBodyCertificateListModel) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateListResponseBodyCertificateListModel) SetCertList(v []*DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList) *DescribeDcdnSMCertificateListResponseBodyCertificateListModel {
	s.CertList = v
	return s
}

func (s *DescribeDcdnSMCertificateListResponseBodyCertificateListModel) SetCount(v int32) *DescribeDcdnSMCertificateListResponseBodyCertificateListModel {
	s.Count = &v
	return s
}

type DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList struct {
	// The ID of the certificate.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The common name of the certificate.
	Common *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
}

func (s DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList) SetCertIdentifier(v string) *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList) SetCertName(v string) *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList {
	s.CertName = &v
	return s
}

func (s *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList) SetCommon(v string) *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList {
	s.Common = &v
	return s
}

func (s *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList) SetIssuer(v string) *DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList {
	s.Issuer = &v
	return s
}

type DescribeDcdnSMCertificateListResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnSMCertificateListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnSMCertificateListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSMCertificateListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSMCertificateListResponse) SetHeaders(v map[string]*string) *DescribeDcdnSMCertificateListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnSMCertificateListResponse) SetStatusCode(v int32) *DescribeDcdnSMCertificateListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnSMCertificateListResponse) SetBody(v *DescribeDcdnSMCertificateListResponseBody) *DescribeDcdnSMCertificateListResponse {
	s.Body = v
	return s
}

type DescribeDcdnSecFuncInfoRequest struct {
	// The language. Valid values: en and zh. Default value: en.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The type of the drop-down list. Valid values: RobotRuleName and RobotObject.
	SecFuncType *string `json:"SecFuncType,omitempty" xml:"SecFuncType,omitempty"`
}

func (s DescribeDcdnSecFuncInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecFuncInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecFuncInfoRequest) SetLang(v string) *DescribeDcdnSecFuncInfoRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDcdnSecFuncInfoRequest) SetSecFuncType(v string) *DescribeDcdnSecFuncInfoRequest {
	s.SecFuncType = &v
	return s
}

type DescribeDcdnSecFuncInfoResponseBody struct {
	// The parameters required by the code.
	Content []*DescribeDcdnSecFuncInfoResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	// The description of HTTP responses.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The HTTP status code.
	HttpStatus *string `json:"HttpStatus,omitempty" xml:"HttpStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return value for HTTP requests. Valid values:
	//
	// *   0: OK.
	// *   Values other than 0: an error.
	RetCode *string `json:"RetCode,omitempty" xml:"RetCode,omitempty"`
}

func (s DescribeDcdnSecFuncInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecFuncInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecFuncInfoResponseBody) SetContent(v []*DescribeDcdnSecFuncInfoResponseBodyContent) *DescribeDcdnSecFuncInfoResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnSecFuncInfoResponseBody) SetDescription(v string) *DescribeDcdnSecFuncInfoResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeDcdnSecFuncInfoResponseBody) SetHttpStatus(v string) *DescribeDcdnSecFuncInfoResponseBody {
	s.HttpStatus = &v
	return s
}

func (s *DescribeDcdnSecFuncInfoResponseBody) SetRequestId(v string) *DescribeDcdnSecFuncInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnSecFuncInfoResponseBody) SetRetCode(v string) *DescribeDcdnSecFuncInfoResponseBody {
	s.RetCode = &v
	return s
}

type DescribeDcdnSecFuncInfoResponseBodyContent struct {
	// The language (Chinese or English).
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The options in the drop-down list.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnSecFuncInfoResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecFuncInfoResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecFuncInfoResponseBodyContent) SetLabel(v string) *DescribeDcdnSecFuncInfoResponseBodyContent {
	s.Label = &v
	return s
}

func (s *DescribeDcdnSecFuncInfoResponseBodyContent) SetValue(v string) *DescribeDcdnSecFuncInfoResponseBodyContent {
	s.Value = &v
	return s
}

type DescribeDcdnSecFuncInfoResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnSecFuncInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnSecFuncInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecFuncInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecFuncInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnSecFuncInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnSecFuncInfoResponse) SetStatusCode(v int32) *DescribeDcdnSecFuncInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnSecFuncInfoResponse) SetBody(v *DescribeDcdnSecFuncInfoResponseBody) *DescribeDcdnSecFuncInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnSecSpecInfoResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The code and configurations of the security rules.
	SpecInfos []*DescribeDcdnSecSpecInfoResponseBodySpecInfos `json:"SpecInfos,omitempty" xml:"SpecInfos,omitempty" type:"Repeated"`
	// The version of secure DCDN.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s DescribeDcdnSecSpecInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecSpecInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecSpecInfoResponseBody) SetRequestId(v string) *DescribeDcdnSecSpecInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnSecSpecInfoResponseBody) SetSpecInfos(v []*DescribeDcdnSecSpecInfoResponseBodySpecInfos) *DescribeDcdnSecSpecInfoResponseBody {
	s.SpecInfos = v
	return s
}

func (s *DescribeDcdnSecSpecInfoResponseBody) SetVersion(v string) *DescribeDcdnSecSpecInfoResponseBody {
	s.Version = &v
	return s
}

type DescribeDcdnSecSpecInfoResponseBodySpecInfos struct {
	// The code of the security rule.
	RuleCode *string `json:"RuleCode,omitempty" xml:"RuleCode,omitempty"`
	// The configurations of the security rule.
	RuleConfigs []*DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs `json:"RuleConfigs,omitempty" xml:"RuleConfigs,omitempty" type:"Repeated"`
}

func (s DescribeDcdnSecSpecInfoResponseBodySpecInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecSpecInfoResponseBodySpecInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecSpecInfoResponseBodySpecInfos) SetRuleCode(v string) *DescribeDcdnSecSpecInfoResponseBodySpecInfos {
	s.RuleCode = &v
	return s
}

func (s *DescribeDcdnSecSpecInfoResponseBodySpecInfos) SetRuleConfigs(v []*DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs) *DescribeDcdnSecSpecInfoResponseBodySpecInfos {
	s.RuleConfigs = v
	return s
}

type DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs struct {
	// The configuration code of the security rule.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The configuration expression of the security rule.
	Expr *string `json:"Expr,omitempty" xml:"Expr,omitempty"`
	// The value of the configuration expression of the security rule.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs) SetCode(v string) *DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs {
	s.Code = &v
	return s
}

func (s *DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs) SetExpr(v string) *DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs {
	s.Expr = &v
	return s
}

func (s *DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs) SetValue(v string) *DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs {
	s.Value = &v
	return s
}

type DescribeDcdnSecSpecInfoResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnSecSpecInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnSecSpecInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSecSpecInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSecSpecInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnSecSpecInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnSecSpecInfoResponse) SetStatusCode(v int32) *DescribeDcdnSecSpecInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnSecSpecInfoResponse) SetBody(v *DescribeDcdnSecSpecInfoResponseBody) *DescribeDcdnSecSpecInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnServiceRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnServiceRequest) SetOwnerId(v int64) *DescribeDcdnServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnServiceRequest) SetSecurityToken(v string) *DescribeDcdnServiceRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnServiceResponseBody struct {
	// The time when the renewed secure DCDN takes effect. The time is displayed in UTC.
	ChangingAffectTime *string `json:"ChangingAffectTime,omitempty" xml:"ChangingAffectTime,omitempty"`
	// The new metering method for the renewed secure DCDN. Valid values:
	//
	// *   **PayByTraffic**: pay by data transfer
	// *   **PayByBandwidth**: pay by bandwidth
	// *   **PayByBandwidth95**: pay by 95th percentile bandwidth
	// *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
	// *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
	// *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
	// *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
	ChangingChargeType *string `json:"ChangingChargeType,omitempty" xml:"ChangingChargeType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The current metering method. Valid values:
	//
	// *   **PayByTraffic**: pay by data transfer
	// *   **PayByBandwidth**: pay by bandwidth
	// *   **PayByBandwidth95**: pay by 95th percentile bandwidth
	// *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
	// *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
	// *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
	// *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The time when the DCDN service was activated. The time follows the ISO 8601 standard.
	OpeningTime *string `json:"OpeningTime,omitempty" xml:"OpeningTime,omitempty"`
	// The lock status of DCDN.
	OperationLocks *DescribeDcdnServiceResponseBodyOperationLocks `json:"OperationLocks,omitempty" xml:"OperationLocks,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The time when the changes of the WebSocket configuration take effect. The value is the same as that of the ChangingAffectTime parameter. This parameter can be displayed in the console only if the specified time is later than the current time.
	WebsocketChangingTime *string `json:"WebsocketChangingTime,omitempty" xml:"WebsocketChangingTime,omitempty"`
	// The next effective billing method of WebSocket. Valid values: **websockettraffic** and **websocketbps**. A value of websockettraffic indicates that you are billed based on the traffic volume. A value of websocketbps indicates that you are billed based on the bandwidth.
	WebsocketChangingType *string `json:"WebsocketChangingType,omitempty" xml:"WebsocketChangingType,omitempty"`
	// The current billing method of WebSocket. Valid values: **websockettraffic** and **websocketbps**. A value of websockettraffic indicates that you are billed based on the traffic volume. A value of websocketbps indicates that you are billed based on the bandwidth.
	WebsocketType *string `json:"WebsocketType,omitempty" xml:"WebsocketType,omitempty"`
}

func (s DescribeDcdnServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnServiceResponseBody) SetChangingAffectTime(v string) *DescribeDcdnServiceResponseBody {
	s.ChangingAffectTime = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetChangingChargeType(v string) *DescribeDcdnServiceResponseBody {
	s.ChangingChargeType = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetInstanceId(v string) *DescribeDcdnServiceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetInternetChargeType(v string) *DescribeDcdnServiceResponseBody {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetOpeningTime(v string) *DescribeDcdnServiceResponseBody {
	s.OpeningTime = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetOperationLocks(v *DescribeDcdnServiceResponseBodyOperationLocks) *DescribeDcdnServiceResponseBody {
	s.OperationLocks = v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetRequestId(v string) *DescribeDcdnServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetWebsocketChangingTime(v string) *DescribeDcdnServiceResponseBody {
	s.WebsocketChangingTime = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetWebsocketChangingType(v string) *DescribeDcdnServiceResponseBody {
	s.WebsocketChangingType = &v
	return s
}

func (s *DescribeDcdnServiceResponseBody) SetWebsocketType(v string) *DescribeDcdnServiceResponseBody {
	s.WebsocketType = &v
	return s
}

type DescribeDcdnServiceResponseBodyOperationLocks struct {
	LockReason []*DescribeDcdnServiceResponseBodyOperationLocksLockReason `json:"LockReason,omitempty" xml:"LockReason,omitempty" type:"Repeated"`
}

func (s DescribeDcdnServiceResponseBodyOperationLocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnServiceResponseBodyOperationLocks) GoString() string {
	return s.String()
}

func (s *DescribeDcdnServiceResponseBodyOperationLocks) SetLockReason(v []*DescribeDcdnServiceResponseBodyOperationLocksLockReason) *DescribeDcdnServiceResponseBodyOperationLocks {
	s.LockReason = v
	return s
}

type DescribeDcdnServiceResponseBodyOperationLocksLockReason struct {
	// The reason why secure DCDN was locked. For example, a value of financial indicates that an overdue payment exists.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
}

func (s DescribeDcdnServiceResponseBodyOperationLocksLockReason) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnServiceResponseBodyOperationLocksLockReason) GoString() string {
	return s.String()
}

func (s *DescribeDcdnServiceResponseBodyOperationLocksLockReason) SetLockReason(v string) *DescribeDcdnServiceResponseBodyOperationLocksLockReason {
	s.LockReason = &v
	return s
}

type DescribeDcdnServiceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnServiceResponse) SetHeaders(v map[string]*string) *DescribeDcdnServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnServiceResponse) SetStatusCode(v int32) *DescribeDcdnServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnServiceResponse) SetBody(v *DescribeDcdnServiceResponseBody) *DescribeDcdnServiceResponse {
	s.Body = v
	return s
}

type DescribeDcdnStagingIpResponseBody struct {
	IPV4s *DescribeDcdnStagingIpResponseBodyIPV4s `json:"IPV4s,omitempty" xml:"IPV4s,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnStagingIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnStagingIpResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnStagingIpResponseBody) SetIPV4s(v *DescribeDcdnStagingIpResponseBodyIPV4s) *DescribeDcdnStagingIpResponseBody {
	s.IPV4s = v
	return s
}

func (s *DescribeDcdnStagingIpResponseBody) SetRequestId(v string) *DescribeDcdnStagingIpResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnStagingIpResponseBodyIPV4s struct {
	IPV4 []*string `json:"IPV4,omitempty" xml:"IPV4,omitempty" type:"Repeated"`
}

func (s DescribeDcdnStagingIpResponseBodyIPV4s) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnStagingIpResponseBodyIPV4s) GoString() string {
	return s.String()
}

func (s *DescribeDcdnStagingIpResponseBodyIPV4s) SetIPV4(v []*string) *DescribeDcdnStagingIpResponseBodyIPV4s {
	s.IPV4 = v
	return s
}

type DescribeDcdnStagingIpResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnStagingIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnStagingIpResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnStagingIpResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnStagingIpResponse) SetHeaders(v map[string]*string) *DescribeDcdnStagingIpResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnStagingIpResponse) SetStatusCode(v int32) *DescribeDcdnStagingIpResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnStagingIpResponse) SetBody(v *DescribeDcdnStagingIpResponseBody) *DescribeDcdnStagingIpResponse {
	s.Body = v
	return s
}

type DescribeDcdnSubListResponseBody struct {
	// The information about the custom report.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnSubListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSubListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSubListResponseBody) SetContent(v string) *DescribeDcdnSubListResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeDcdnSubListResponseBody) SetRequestId(v string) *DescribeDcdnSubListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnSubListResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnSubListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnSubListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnSubListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnSubListResponse) SetHeaders(v map[string]*string) *DescribeDcdnSubListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnSubListResponse) SetStatusCode(v int32) *DescribeDcdnSubListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnSubListResponse) SetBody(v *DescribeDcdnSubListResponseBody) *DescribeDcdnSubListResponse {
	s.Body = v
	return s
}

type DescribeDcdnTagResourcesRequest struct {
	// The list of resource IDs. You can specify a maximum of 50 resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource. Set the value to **DOMAIN**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags. You can specify a maximum of 20 tag values.
	Tag []*DescribeDcdnTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeDcdnTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTagResourcesRequest) SetResourceId(v []*string) *DescribeDcdnTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *DescribeDcdnTagResourcesRequest) SetResourceType(v string) *DescribeDcdnTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribeDcdnTagResourcesRequest) SetTag(v []*DescribeDcdnTagResourcesRequestTag) *DescribeDcdnTagResourcesRequest {
	s.Tag = v
	return s
}

type DescribeDcdnTagResourcesRequestTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTagResourcesRequestTag) SetKey(v string) *DescribeDcdnTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeDcdnTagResourcesRequestTag) SetValue(v string) *DescribeDcdnTagResourcesRequestTag {
	s.Value = &v
	return s
}

type DescribeDcdnTagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tag of the instance.
	TagResources []*DescribeDcdnTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Repeated"`
}

func (s DescribeDcdnTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTagResourcesResponseBody) SetRequestId(v string) *DescribeDcdnTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnTagResourcesResponseBody) SetTagResources(v []*DescribeDcdnTagResourcesResponseBodyTagResources) *DescribeDcdnTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type DescribeDcdnTagResourcesResponseBodyTagResources struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The tags of the snapshot.
	Tag []*DescribeDcdnTagResourcesResponseBodyTagResourcesTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeDcdnTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTagResourcesResponseBodyTagResources) SetResourceId(v string) *DescribeDcdnTagResourcesResponseBodyTagResources {
	s.ResourceId = &v
	return s
}

func (s *DescribeDcdnTagResourcesResponseBodyTagResources) SetTag(v []*DescribeDcdnTagResourcesResponseBodyTagResourcesTag) *DescribeDcdnTagResourcesResponseBodyTagResources {
	s.Tag = v
	return s
}

type DescribeDcdnTagResourcesResponseBodyTagResourcesTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnTagResourcesResponseBodyTagResourcesTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTagResourcesResponseBodyTagResourcesTag) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTagResourcesResponseBodyTagResourcesTag) SetKey(v string) *DescribeDcdnTagResourcesResponseBodyTagResourcesTag {
	s.Key = &v
	return s
}

func (s *DescribeDcdnTagResourcesResponseBodyTagResourcesTag) SetValue(v string) *DescribeDcdnTagResourcesResponseBodyTagResourcesTag {
	s.Value = &v
	return s
}

type DescribeDcdnTagResourcesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTagResourcesResponse) SetHeaders(v map[string]*string) *DescribeDcdnTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnTagResourcesResponse) SetStatusCode(v int32) *DescribeDcdnTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnTagResourcesResponse) SetBody(v *DescribeDcdnTagResourcesResponseBody) *DescribeDcdnTagResourcesResponse {
	s.Body = v
	return s
}

type DescribeDcdnTopDomainsByFlowRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of domain names to return. Valid values: **1** to **100**. Default value: **20**.
	Limit *int64 `json:"Limit,omitempty" xml:"Limit,omitempty"`
	// The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnTopDomainsByFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTopDomainsByFlowRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTopDomainsByFlowRequest) SetEndTime(v string) *DescribeDcdnTopDomainsByFlowRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowRequest) SetLimit(v int64) *DescribeDcdnTopDomainsByFlowRequest {
	s.Limit = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowRequest) SetStartTime(v string) *DescribeDcdnTopDomainsByFlowRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnTopDomainsByFlowResponseBody struct {
	// The total number of accelerated domains under your account.
	DomainCount *int64 `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	// The total number of accelerated domains that are in the **Enabled** state under your account.
	DomainOnlineCount *int64 `json:"DomainOnlineCount,omitempty" xml:"DomainOnlineCount,omitempty"`
	// The end of the reporting period.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the reporting period.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The top N domain names ranked by network traffic.
	TopDomains *DescribeDcdnTopDomainsByFlowResponseBodyTopDomains `json:"TopDomains,omitempty" xml:"TopDomains,omitempty" type:"Struct"`
}

func (s DescribeDcdnTopDomainsByFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTopDomainsByFlowResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTopDomainsByFlowResponseBody) SetDomainCount(v int64) *DescribeDcdnTopDomainsByFlowResponseBody {
	s.DomainCount = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBody) SetDomainOnlineCount(v int64) *DescribeDcdnTopDomainsByFlowResponseBody {
	s.DomainOnlineCount = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBody) SetEndTime(v string) *DescribeDcdnTopDomainsByFlowResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBody) SetRequestId(v string) *DescribeDcdnTopDomainsByFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBody) SetStartTime(v string) *DescribeDcdnTopDomainsByFlowResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBody) SetTopDomains(v *DescribeDcdnTopDomainsByFlowResponseBodyTopDomains) *DescribeDcdnTopDomainsByFlowResponseBody {
	s.TopDomains = v
	return s
}

type DescribeDcdnTopDomainsByFlowResponseBodyTopDomains struct {
	TopDomain []*DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain `json:"TopDomain,omitempty" xml:"TopDomain,omitempty" type:"Repeated"`
}

func (s DescribeDcdnTopDomainsByFlowResponseBodyTopDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTopDomainsByFlowResponseBodyTopDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomains) SetTopDomain(v []*DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomains {
	s.TopDomain = v
	return s
}

type DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The peak bandwidth value.
	MaxBps *int64 `json:"MaxBps,omitempty" xml:"MaxBps,omitempty"`
	// The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	MaxBpsTime *string `json:"MaxBpsTime,omitempty" xml:"MaxBpsTime,omitempty"`
	// The ranking of the accelerated domain name.
	Rank *int64 `json:"Rank,omitempty" xml:"Rank,omitempty"`
	// The number of visits.
	TotalAccess *int64 `json:"TotalAccess,omitempty" xml:"TotalAccess,omitempty"`
	// The total amount of network traffic.
	TotalTraffic *string `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
	// The proportion of network traffic consumed to access the URL.
	TrafficPercent *string `json:"TrafficPercent,omitempty" xml:"TrafficPercent,omitempty"`
}

func (s DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetDomainName(v string) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetMaxBps(v int64) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.MaxBps = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetMaxBpsTime(v string) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.MaxBpsTime = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetRank(v int64) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.Rank = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetTotalAccess(v int64) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.TotalAccess = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetTotalTraffic(v string) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.TotalTraffic = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain) SetTrafficPercent(v string) *DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain {
	s.TrafficPercent = &v
	return s
}

type DescribeDcdnTopDomainsByFlowResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnTopDomainsByFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnTopDomainsByFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnTopDomainsByFlowResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnTopDomainsByFlowResponse) SetHeaders(v map[string]*string) *DescribeDcdnTopDomainsByFlowResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponse) SetStatusCode(v int32) *DescribeDcdnTopDomainsByFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnTopDomainsByFlowResponse) SetBody(v *DescribeDcdnTopDomainsByFlowResponseBody) *DescribeDcdnTopDomainsByFlowResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserBillHistoryRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// The minimum data granularity is 5 minutes.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnUserBillHistoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillHistoryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillHistoryRequest) SetEndTime(v string) *DescribeDcdnUserBillHistoryRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryRequest) SetStartTime(v string) *DescribeDcdnUserBillHistoryRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnUserBillHistoryResponseBody struct {
	// The billing history returned.
	BillHistoryData *DescribeDcdnUserBillHistoryResponseBodyBillHistoryData `json:"BillHistoryData,omitempty" xml:"BillHistoryData,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnUserBillHistoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillHistoryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillHistoryResponseBody) SetBillHistoryData(v *DescribeDcdnUserBillHistoryResponseBodyBillHistoryData) *DescribeDcdnUserBillHistoryResponseBody {
	s.BillHistoryData = v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBody) SetRequestId(v string) *DescribeDcdnUserBillHistoryResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnUserBillHistoryResponseBodyBillHistoryData struct {
	BillHistoryDataItem []*DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem `json:"BillHistoryDataItem,omitempty" xml:"BillHistoryDataItem,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryData) SetBillHistoryDataItem(v []*DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryData {
	s.BillHistoryDataItem = v
	return s
}

type DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem struct {
	// The beginning of the time range that was queried.
	BillTime *string `json:"BillTime,omitempty" xml:"BillTime,omitempty"`
	// The metering method.
	BillType *string `json:"BillType,omitempty" xml:"BillType,omitempty"`
	// The billable items.
	BillingData *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData `json:"BillingData,omitempty" xml:"BillingData,omitempty" type:"Struct"`
	// The dimension.
	Dimension *string `json:"Dimension,omitempty" xml:"Dimension,omitempty"`
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetBillTime(v string) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.BillTime = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetBillType(v string) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.BillType = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetBillingData(v *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.BillingData = v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem) SetDimension(v string) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem {
	s.Dimension = &v
	return s
}

type DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData struct {
	BillingDataItem []*DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem `json:"BillingDataItem,omitempty" xml:"BillingDataItem,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData) SetBillingDataItem(v []*DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData {
	s.BillingDataItem = v
	return s
}

type DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem struct {
	// The bandwidth. Unit: bit/s.
	Bandwidth *float32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The region for which the billing records are generated. Valid values: **CN**, **OverSeas**, **AP1**, **AP2**, **AP3**, **NA**, **SA**, **EU**, and **MEAA**.
	CdnRegion *string `json:"CdnRegion,omitempty" xml:"CdnRegion,omitempty"`
	// The billing method of the disk. Valid values: Valid values: **StaticHttp**, **DynamicHttp**, and **DynamicHttps**.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The number of billing entries.
	Count *float32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The amount of network traffic. Unit: bytes.
	Flow *float32 `json:"Flow,omitempty" xml:"Flow,omitempty"`
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetBandwidth(v float32) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.Bandwidth = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetCdnRegion(v string) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.CdnRegion = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetChargeType(v string) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.ChargeType = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetCount(v float32) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.Count = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem) SetFlow(v float32) *DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem {
	s.Flow = &v
	return s
}

type DescribeDcdnUserBillHistoryResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserBillHistoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserBillHistoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillHistoryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillHistoryResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserBillHistoryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponse) SetStatusCode(v int32) *DescribeDcdnUserBillHistoryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserBillHistoryResponse) SetBody(v *DescribeDcdnUserBillHistoryResponseBody) *DescribeDcdnUserBillHistoryResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserBillTypeRequest struct {
	// The end of the time range to query.
	//
	// The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnUserBillTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillTypeRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillTypeRequest) SetEndTime(v string) *DescribeDcdnUserBillTypeRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnUserBillTypeRequest) SetStartTime(v string) *DescribeDcdnUserBillTypeRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnUserBillTypeResponseBody struct {
	// The information about the metering method.
	BillTypeData *DescribeDcdnUserBillTypeResponseBodyBillTypeData `json:"BillTypeData,omitempty" xml:"BillTypeData,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnUserBillTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillTypeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillTypeResponseBody) SetBillTypeData(v *DescribeDcdnUserBillTypeResponseBodyBillTypeData) *DescribeDcdnUserBillTypeResponseBody {
	s.BillTypeData = v
	return s
}

func (s *DescribeDcdnUserBillTypeResponseBody) SetRequestId(v string) *DescribeDcdnUserBillTypeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnUserBillTypeResponseBodyBillTypeData struct {
	BillTypeDataItem []*DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem `json:"BillTypeDataItem,omitempty" xml:"BillTypeDataItem,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserBillTypeResponseBodyBillTypeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillTypeResponseBodyBillTypeData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillTypeResponseBodyBillTypeData) SetBillTypeDataItem(v []*DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) *DescribeDcdnUserBillTypeResponseBodyBillTypeData {
	s.BillTypeDataItem = v
	return s
}

type DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem struct {
	// The metering method. Valid values:
	//
	// *   **hour_flow**: pay by hourly traffic
	// *   **day_bandwidth**: pay by daily bandwidth
	// *   **month\_95**: pay by monthly 95th percentile
	// *   **month_avg_day_bandwidth**: pay by average daily peak bandwidth per month
	// *   **month\_4th_day_bandwidth**: pay by 4th peak bandwidth per month
	// *   **month_avg_day\_95**: pay by average daily 95th percentile per month
	// *   **month\_95\_night_half**: pay by 95th percentile (50% off during nighttime)
	// *   **hour_vas**: pay by value-added service per month
	// *   **quic_hour_count**: pay by QUIC request per hour
	// *   **hour_count**: pay by request per hour
	// *   **rtlog_count_day**: pay by the number of real-time logs per day
	BillType *string `json:"BillType,omitempty" xml:"BillType,omitempty"`
	// The metering cycle.
	BillingCycle *string `json:"BillingCycle,omitempty" xml:"BillingCycle,omitempty"`
	// The dimension. Valid values:
	//
	// *   **flow**: network traffic and bandwidth
	// *   **vas**: value-added services (HTTPS and requests for dynamic content)
	// *   **websocket**: WebSocket
	// *   **quic**: QUIC requests
	// *   **rtlog2sls**: log entries delivered to Log Service in real time
	Dimension *string `json:"Dimension,omitempty" xml:"Dimension,omitempty"`
	// The time when the metering method ends.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the service.
	Product *string `json:"Product,omitempty" xml:"Product,omitempty"`
	// The time when the metering method takes effect.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetBillType(v string) *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.BillType = &v
	return s
}

func (s *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetBillingCycle(v string) *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.BillingCycle = &v
	return s
}

func (s *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetDimension(v string) *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.Dimension = &v
	return s
}

func (s *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetEndTime(v string) *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetProduct(v string) *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.Product = &v
	return s
}

func (s *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem) SetStartTime(v string) *DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem {
	s.StartTime = &v
	return s
}

type DescribeDcdnUserBillTypeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserBillTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserBillTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserBillTypeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserBillTypeResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserBillTypeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserBillTypeResponse) SetStatusCode(v int32) *DescribeDcdnUserBillTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserBillTypeResponse) SetBody(v *DescribeDcdnUserBillTypeResponseBody) *DescribeDcdnUserBillTypeResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserCertificateExpireCountResponseBody struct {
	// The number of domain names whose SSL certificates are about to expires within 30 days.
	ExpireWithin30DaysCount *int32 `json:"ExpireWithin30DaysCount,omitempty" xml:"ExpireWithin30DaysCount,omitempty"`
	// The number of domain names whose SSL certificates have already expired.
	ExpiredCount *int32 `json:"ExpiredCount,omitempty" xml:"ExpiredCount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnUserCertificateExpireCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserCertificateExpireCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserCertificateExpireCountResponseBody) SetExpireWithin30DaysCount(v int32) *DescribeDcdnUserCertificateExpireCountResponseBody {
	s.ExpireWithin30DaysCount = &v
	return s
}

func (s *DescribeDcdnUserCertificateExpireCountResponseBody) SetExpiredCount(v int32) *DescribeDcdnUserCertificateExpireCountResponseBody {
	s.ExpiredCount = &v
	return s
}

func (s *DescribeDcdnUserCertificateExpireCountResponseBody) SetRequestId(v string) *DescribeDcdnUserCertificateExpireCountResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnUserCertificateExpireCountResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserCertificateExpireCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserCertificateExpireCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserCertificateExpireCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserCertificateExpireCountResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserCertificateExpireCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserCertificateExpireCountResponse) SetStatusCode(v int32) *DescribeDcdnUserCertificateExpireCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserCertificateExpireCountResponse) SetBody(v *DescribeDcdnUserCertificateExpireCountResponseBody) *DescribeDcdnUserCertificateExpireCountResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserConfigsRequest struct {
	// The configuration that you want to query. Valid values:
	//
	// *   domain_business_control: user configurations
	// *   bot_basic: the basic edition of bot traffic management, which supports authorized crawlers and provides threat intelligence
	// *   bot_Advance: the advanced edition of bot traffic management, which supports authorized crawlers and AI intelligent protection and provides threat intelligence
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s DescribeDcdnUserConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserConfigsRequest) SetFunctionName(v string) *DescribeDcdnUserConfigsRequest {
	s.FunctionName = &v
	return s
}

type DescribeDcdnUserConfigsResponseBody struct {
	// The user configurations.
	Configs []*DescribeDcdnUserConfigsResponseBodyConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnUserConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserConfigsResponseBody) SetConfigs(v []*DescribeDcdnUserConfigsResponseBodyConfigs) *DescribeDcdnUserConfigsResponseBody {
	s.Configs = v
	return s
}

func (s *DescribeDcdnUserConfigsResponseBody) SetRequestId(v string) *DescribeDcdnUserConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnUserConfigsResponseBodyConfigs struct {
	// The name of the configuration.
	//
	// The configuration is specified by enterprise users and public service sectors.
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The value of the configuration. Valid values:
	//
	// *   cc_rule: HTTP flood protection
	// *   ddos_dispatch: DDoS mitigation
	// *   edge_safe: application security on points of presence (POPs)
	// *   blocked_regions: region blacklist
	// *   http_acl_policy: precise access control
	// *   bot_manager: bot traffic management
	// *   ip_reputation: IP reputation library
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s DescribeDcdnUserConfigsResponseBodyConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserConfigsResponseBodyConfigs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserConfigsResponseBodyConfigs) SetArgName(v string) *DescribeDcdnUserConfigsResponseBodyConfigs {
	s.ArgName = &v
	return s
}

func (s *DescribeDcdnUserConfigsResponseBodyConfigs) SetArgValue(v string) *DescribeDcdnUserConfigsResponseBodyConfigs {
	s.ArgValue = &v
	return s
}

func (s *DescribeDcdnUserConfigsResponseBodyConfigs) SetFunctionName(v string) *DescribeDcdnUserConfigsResponseBodyConfigs {
	s.FunctionName = &v
	return s
}

type DescribeDcdnUserConfigsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserConfigsResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserConfigsResponse) SetStatusCode(v int32) *DescribeDcdnUserConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserConfigsResponse) SetBody(v *DescribeDcdnUserConfigsResponseBody) *DescribeDcdnUserConfigsResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserDomainsRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.
	//
	// > The end time must be later than the start time.
	ChangeEndTime *string `json:"ChangeEndTime,omitempty" xml:"ChangeEndTime,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.
	ChangeStartTime *string `json:"ChangeStartTime,omitempty" xml:"ChangeStartTime,omitempty"`
	// Specifies whether to display domain names that are under review, failed the review, or failed to be configured. Valid values:
	//
	// *   true: displays domain names.
	// *   false: does not display detailed information.
	CheckDomainShow *bool `json:"CheckDomainShow,omitempty" xml:"CheckDomainShow,omitempty"`
	// The acceleration region. By default, all acceleration regions are queried.
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: outside the Chinese mainland
	// *   **global**: global
	Coverage *string `json:"Coverage,omitempty" xml:"Coverage,omitempty"`
	// The accelerated domain names. If you do not set this parameter, configurations of all domain names that match the conditions are returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The search method. Default value: full_match. Valid values:
	//
	// *   **fuzzy_match**: fuzzy match
	// *   **pre_match**: prefix match
	// *   **suf_match**: suffix match
	// *   **full_match** (default): exact match
	//
	// > If you specify the domain names to query but do not set the DomainSearchType parameter, the exact match mode is used.
	DomainSearchType *string `json:"DomainSearchType,omitempty" xml:"DomainSearchType,omitempty"`
	// The status of the domain name. Valid values:
	//
	// *   **online**: enabled
	// *   **offline**: disabled
	// *   **configuring**: configuring
	// *   **configure_failed**: configuration failed
	// *   **checking**: reviewing
	// *   **check_failed:** review failed
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of returned pages. Valid values: **1** to **100000**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Valid values: **1** to **500**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The list of tags.
	Tag         []*DescribeDcdnUserDomainsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	WebSiteType *string                              `json:"WebSiteType,omitempty" xml:"WebSiteType,omitempty"`
}

func (s DescribeDcdnUserDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsRequest) SetChangeEndTime(v string) *DescribeDcdnUserDomainsRequest {
	s.ChangeEndTime = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetChangeStartTime(v string) *DescribeDcdnUserDomainsRequest {
	s.ChangeStartTime = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetCheckDomainShow(v bool) *DescribeDcdnUserDomainsRequest {
	s.CheckDomainShow = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetCoverage(v string) *DescribeDcdnUserDomainsRequest {
	s.Coverage = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetDomainName(v string) *DescribeDcdnUserDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetDomainSearchType(v string) *DescribeDcdnUserDomainsRequest {
	s.DomainSearchType = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetDomainStatus(v string) *DescribeDcdnUserDomainsRequest {
	s.DomainStatus = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetOwnerId(v int64) *DescribeDcdnUserDomainsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetPageNumber(v int32) *DescribeDcdnUserDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetPageSize(v int32) *DescribeDcdnUserDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetResourceGroupId(v string) *DescribeDcdnUserDomainsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetSecurityToken(v string) *DescribeDcdnUserDomainsRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetTag(v []*DescribeDcdnUserDomainsRequestTag) *DescribeDcdnUserDomainsRequest {
	s.Tag = v
	return s
}

func (s *DescribeDcdnUserDomainsRequest) SetWebSiteType(v string) *DescribeDcdnUserDomainsRequest {
	s.WebSiteType = &v
	return s
}

type DescribeDcdnUserDomainsRequestTag struct {
	// The tag key. Valid values of N: **1** to **20**. You can call the TagDcdnResources operation to set a tag for a domain name.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. Valid values of N: **1** to **20**.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnUserDomainsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsRequestTag) SetKey(v string) *DescribeDcdnUserDomainsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeDcdnUserDomainsRequestTag) SetValue(v string) *DescribeDcdnUserDomainsRequestTag {
	s.Value = &v
	return s
}

type DescribeDcdnUserDomainsResponseBody struct {
	// The array that consists of multiple PageData parameters. The details about each accelerated domain name are included in a separate PageData parameter.
	Domains *DescribeDcdnUserDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnUserDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsResponseBody) SetDomains(v *DescribeDcdnUserDomainsResponseBodyDomains) *DescribeDcdnUserDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBody) SetPageNumber(v int64) *DescribeDcdnUserDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBody) SetPageSize(v int64) *DescribeDcdnUserDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBody) SetRequestId(v string) *DescribeDcdnUserDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBody) SetTotalCount(v int64) *DescribeDcdnUserDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnUserDomainsResponseBodyDomains struct {
	PageData []*DescribeDcdnUserDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsResponseBodyDomains) SetPageData(v []*DescribeDcdnUserDomainsResponseBodyDomainsPageData) *DescribeDcdnUserDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeDcdnUserDomainsResponseBodyDomainsPageData struct {
	// The CNAME assigned to the accelerated domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The reason why the accelerated domain name failed the review.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the accelerated domain name.
	DomainId *int64 `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The information about the accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name.
	//
	// *   **online**: enabled
	// *   **offline**: disabled
	// *   **configuring**: configuring
	// *   **configure_failed**: configuration failed
	// *   **checking**: reviewing
	// *   **check_failed:** review failed
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// The time when the accelerated domain name was added to Dynamic Content Delivery Network (DCDN).
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the accelerated domain name was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of HTTPS.
	//
	// *   **on**
	// *   **off**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// Indicates whether the accelerated domain name was in a sandbox.
	Sandbox *string `json:"Sandbox,omitempty" xml:"Sandbox,omitempty"`
	// 
	// - **apiscene**API
	// - **webservicescene**
	// - **staticscene**
	// - ****
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The information about the origin server.
	Sources *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
}

func (s DescribeDcdnUserDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetCname(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetDescription(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetDomainId(v int64) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.DomainId = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetFunctionType(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.FunctionType = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetResourceGroupId(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetSSLProtocol(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.SSLProtocol = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetSandbox(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.Sandbox = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetScene(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.Scene = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageData) SetSources(v *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources) *DescribeDcdnUserDomainsResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

type DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources struct {
	Source []*DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources) SetSource(v []*DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The port of the origin server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource) SetWeight(v string) *DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Weight = &v
	return s
}

type DescribeDcdnUserDomainsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserDomainsResponse) SetStatusCode(v int32) *DescribeDcdnUserDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserDomainsResponse) SetBody(v *DescribeDcdnUserDomainsResponseBody) *DescribeDcdnUserDomainsResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserDomainsByFuncRequest struct {
	// The accelerated domain name whose ICP filing status you want to update.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// Specifies whether the feature that is specified by the FuncId parameter is enabled.
	//
	// *   **config**: enabled
	// *   **unconfig**: not enabled
	FuncFilter *string `json:"FuncFilter,omitempty" xml:"FuncFilter,omitempty"`
	// The ID of the feature. For more information about how to query feature IDs, see [Parameters for configuring features for domain names](~~410622~~). For example, the ID of the origin host feature (set_req_host_header) is 18.
	FuncId *int32 `json:"FuncId,omitempty" xml:"FuncId,omitempty"`
	// The number of the page to return. Default value: **1**. Valid values: **1 to 100000**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Valid values: **1 to 500**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeDcdnUserDomainsByFuncRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsByFuncRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsByFuncRequest) SetDomainName(v string) *DescribeDcdnUserDomainsByFuncRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncRequest) SetFuncFilter(v string) *DescribeDcdnUserDomainsByFuncRequest {
	s.FuncFilter = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncRequest) SetFuncId(v int32) *DescribeDcdnUserDomainsByFuncRequest {
	s.FuncId = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncRequest) SetPageNumber(v int32) *DescribeDcdnUserDomainsByFuncRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncRequest) SetPageSize(v int32) *DescribeDcdnUserDomainsByFuncRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncRequest) SetResourceGroupId(v string) *DescribeDcdnUserDomainsByFuncRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeDcdnUserDomainsByFuncResponseBody struct {
	// The array that consists of multiple PageData parameters. The details about each accelerated domain name are included in a separate PageData parameter.
	Domains *DescribeDcdnUserDomainsByFuncResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the page returned.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnUserDomainsByFuncResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsByFuncResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsByFuncResponseBody) SetDomains(v *DescribeDcdnUserDomainsByFuncResponseBodyDomains) *DescribeDcdnUserDomainsByFuncResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBody) SetPageNumber(v int64) *DescribeDcdnUserDomainsByFuncResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBody) SetPageSize(v int64) *DescribeDcdnUserDomainsByFuncResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBody) SetRequestId(v string) *DescribeDcdnUserDomainsByFuncResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBody) SetTotalCount(v int64) *DescribeDcdnUserDomainsByFuncResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnUserDomainsByFuncResponseBodyDomains struct {
	PageData []*DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomains) SetPageData(v []*DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) *DescribeDcdnUserDomainsByFuncResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData struct {
	// The CNAME assigned to the accelerated domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The reason why the accelerated domain name failed the review.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   **online**
	// *   **offline**
	// *   **configuring**
	// *   **configure_failed**
	// *   **checking**
	// *   **check_failed**
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the accelerated domain name was added to Dynamic Content Delivery Network (DCDN).
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the accelerated domain name was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the accelerated domain name was in a sandbox.
	Sandbox *string `json:"Sandbox,omitempty" xml:"Sandbox,omitempty"`
	// The information about the origin servers.
	Sources *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// Indicates whether HTTPS is enabled. Valid values:
	//
	// *   **on**: HTTPS is enabled.
	// *   **off**: HTTPS is disabled.
	SslProtocol *string `json:"SslProtocol,omitempty" xml:"SslProtocol,omitempty"`
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetCname(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetDescription(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetDomainName(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetResourceGroupId(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetSandbox(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.Sandbox = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetSources(v *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData) SetSslProtocol(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData {
	s.SslProtocol = &v
	return s
}

type DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources struct {
	Source []*DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources) SetSource(v []*DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource struct {
	// The origin server address.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The port of the origin server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource) SetWeight(v string) *DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource {
	s.Weight = &v
	return s
}

type DescribeDcdnUserDomainsByFuncResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserDomainsByFuncResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserDomainsByFuncResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserDomainsByFuncResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserDomainsByFuncResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserDomainsByFuncResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponse) SetStatusCode(v int32) *DescribeDcdnUserDomainsByFuncResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserDomainsByFuncResponse) SetBody(v *DescribeDcdnUserDomainsByFuncResponseBody) *DescribeDcdnUserDomainsByFuncResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserQuotaRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnUserQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserQuotaRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserQuotaRequest) SetOwnerId(v int64) *DescribeDcdnUserQuotaRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnUserQuotaRequest) SetSecurityToken(v string) *DescribeDcdnUserQuotaRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnUserQuotaResponseBody struct {
	// The maximum number of URLs that can be blocked.
	BlockQuota *int32 `json:"BlockQuota,omitempty" xml:"BlockQuota,omitempty"`
	// The remaining number of URLs that can be blocked.
	BlockRemain *int32 `json:"BlockRemain,omitempty" xml:"BlockRemain,omitempty"`
	// The maximum number of accelerated domains.
	DomainQuota *int32 `json:"DomainQuota,omitempty" xml:"DomainQuota,omitempty"`
	// The maximum number of URLs or directories with parameters ignored that can be refreshed.
	IgnoreParamsQuota *int32 `json:"IgnoreParamsQuota,omitempty" xml:"IgnoreParamsQuota,omitempty"`
	// The number of remaining URLs or directories with parameters ignored that can be refreshed.
	IgnoreParamsRemain *int32 `json:"IgnoreParamsRemain,omitempty" xml:"IgnoreParamsRemain,omitempty"`
	// The maximum number of URLs that can be prefetched.
	PreloadQuota *int32 `json:"PreloadQuota,omitempty" xml:"PreloadQuota,omitempty"`
	// The remaining number of URLs that can be prefetched.
	PreloadRemain *int32 `json:"PreloadRemain,omitempty" xml:"PreloadRemain,omitempty"`
	// The maximum number of directories that can be refreshed.
	RefreshDirQuota *int32 `json:"RefreshDirQuota,omitempty" xml:"RefreshDirQuota,omitempty"`
	// The remaining number of directories that can be refreshed.
	RefreshDirRemain *int32 `json:"RefreshDirRemain,omitempty" xml:"RefreshDirRemain,omitempty"`
	// The maximum number of URLs that can be refreshed.
	RefreshUrlQuota *int32 `json:"RefreshUrlQuota,omitempty" xml:"RefreshUrlQuota,omitempty"`
	// The remaining number of URLs that can be refreshed.
	RefreshUrlRemain *int32 `json:"RefreshUrlRemain,omitempty" xml:"RefreshUrlRemain,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnUserQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserQuotaResponseBody) SetBlockQuota(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.BlockQuota = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetBlockRemain(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.BlockRemain = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetDomainQuota(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.DomainQuota = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetIgnoreParamsQuota(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.IgnoreParamsQuota = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetIgnoreParamsRemain(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.IgnoreParamsRemain = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetPreloadQuota(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.PreloadQuota = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetPreloadRemain(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.PreloadRemain = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetRefreshDirQuota(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.RefreshDirQuota = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetRefreshDirRemain(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.RefreshDirRemain = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetRefreshUrlQuota(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.RefreshUrlQuota = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetRefreshUrlRemain(v int32) *DescribeDcdnUserQuotaResponseBody {
	s.RefreshUrlRemain = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponseBody) SetRequestId(v string) *DescribeDcdnUserQuotaResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnUserQuotaResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserQuotaResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserQuotaResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserQuotaResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserQuotaResponse) SetStatusCode(v int32) *DescribeDcdnUserQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserQuotaResponse) SetBody(v *DescribeDcdnUserQuotaResponseBody) *DescribeDcdnUserQuotaResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserRealTimeDeliveryFieldRequest struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of L1 Dynamic Content Delivery Network (DCDN) points of presence (POPs)
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
}

func (s DescribeDcdnUserRealTimeDeliveryFieldRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserRealTimeDeliveryFieldRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldRequest) SetBusinessType(v string) *DescribeDcdnUserRealTimeDeliveryFieldRequest {
	s.BusinessType = &v
	return s
}

type DescribeDcdnUserRealTimeDeliveryFieldResponseBody struct {
	// The data returned.
	Content *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponseBody) SetContent(v *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent) *DescribeDcdnUserRealTimeDeliveryFieldResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponseBody) SetRequestId(v string) *DescribeDcdnUserRealTimeDeliveryFieldResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent struct {
	Fields []*DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields `json:"Fields,omitempty" xml:"Fields,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent) SetFields(v []*DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields) *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent {
	s.Fields = v
	return s
}

type DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields struct {
	// The description of the field.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the field.
	FieldName *string `json:"FieldName,omitempty" xml:"FieldName,omitempty"`
	// Indicates whether the field was selected.
	//
	// *   **true**
	// *   **false**
	Selected *bool `json:"Selected,omitempty" xml:"Selected,omitempty"`
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields) SetDescription(v string) *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields {
	s.Description = &v
	return s
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields) SetFieldName(v string) *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields {
	s.FieldName = &v
	return s
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields) SetSelected(v bool) *DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields {
	s.Selected = &v
	return s
}

type DescribeDcdnUserRealTimeDeliveryFieldResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserRealTimeDeliveryFieldResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserRealTimeDeliveryFieldResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserRealTimeDeliveryFieldResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponse) SetStatusCode(v int32) *DescribeDcdnUserRealTimeDeliveryFieldResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserRealTimeDeliveryFieldResponse) SetBody(v *DescribeDcdnUserRealTimeDeliveryFieldResponseBody) *DescribeDcdnUserRealTimeDeliveryFieldResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserResourcePackageRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The status of the resource plan. Valid values:
	//
	// *   **valid**: valid
	// *   **closed**: expired
	// *   If you leave this parameter empty, all resource plans are queried.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnUserResourcePackageRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserResourcePackageRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserResourcePackageRequest) SetOwnerId(v int64) *DescribeDcdnUserResourcePackageRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageRequest) SetSecurityToken(v string) *DescribeDcdnUserResourcePackageRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageRequest) SetStatus(v string) *DescribeDcdnUserResourcePackageRequest {
	s.Status = &v
	return s
}

type DescribeDcdnUserResourcePackageResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The detailed information about resource plans. The returned information is displayed in the format that is specified by the ResourcePackageInfo parameter.
	ResourcePackageInfos *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos `json:"ResourcePackageInfos,omitempty" xml:"ResourcePackageInfos,omitempty" type:"Struct"`
}

func (s DescribeDcdnUserResourcePackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserResourcePackageResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserResourcePackageResponseBody) SetRequestId(v string) *DescribeDcdnUserResourcePackageResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBody) SetResourcePackageInfos(v *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos) *DescribeDcdnUserResourcePackageResponseBody {
	s.ResourcePackageInfos = v
	return s
}

type DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos struct {
	ResourcePackageInfo []*DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo `json:"ResourcePackageInfo,omitempty" xml:"ResourcePackageInfo,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos) SetResourcePackageInfo(v []*DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos {
	s.ResourcePackageInfo = v
	return s
}

type DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo struct {
	// The commodity code of the resource plan.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The remaining quota of the resource plan.
	//
	// *   The unit for traffic: bytes.
	// *   The unit for requests: count.
	CurrCapacity *string `json:"CurrCapacity,omitempty" xml:"CurrCapacity,omitempty"`
	// The name of the resource plan.
	DisplayName *string `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	// The expiration time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The total quota of the resource plan.
	//
	// *   The unit for traffic: bytes.
	// *   The unit for requests: count.
	InitCapacity *string `json:"InitCapacity,omitempty" xml:"InitCapacity,omitempty"`
	// The ID of the resource plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The validation time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the resource plan. Valid values:
	//
	// *   **valid**: valid
	// *   **closed**: expired
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The name of the template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetCommodityCode(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.CommodityCode = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetCurrCapacity(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.CurrCapacity = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetDisplayName(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.DisplayName = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetEndTime(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetInitCapacity(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.InitCapacity = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetInstanceId(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.InstanceId = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetStartTime(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetStatus(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.Status = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo) SetTemplateName(v string) *DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo {
	s.TemplateName = &v
	return s
}

type DescribeDcdnUserResourcePackageResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserResourcePackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserResourcePackageResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserResourcePackageResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserResourcePackageResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserResourcePackageResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponse) SetStatusCode(v int32) *DescribeDcdnUserResourcePackageResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserResourcePackageResponse) SetBody(v *DescribeDcdnUserResourcePackageResponseBody) *DescribeDcdnUserResourcePackageResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserSecDropRequest struct {
	// The date or month that you want to query.
	//
	// *   If data is collected every day, set Data in the format of yyyymmdd, such as 20201203.
	// *   If data is collected every month, set Data in the format of yyyymm, such as 202012.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The time interval at which data is collected.
	//
	// *   If data is collected every day, the number of blocked packets on the specified day is calculated.
	// *   If data is collected every month, the number of blocked packets in the specified month is calculated.
	Metric *string `json:"Metric,omitempty" xml:"Metric,omitempty"`
	// The security feature. Valid values:
	//
	// *   waf: WAF
	// *   tmd: rate limiting
	// *   robot: bot traffic recognition
	// *   l4\_dm_drop: domain name blocking at Layer 4
	SecFunc *string `json:"SecFunc,omitempty" xml:"SecFunc,omitempty"`
}

func (s DescribeDcdnUserSecDropRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserSecDropRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserSecDropRequest) SetData(v string) *DescribeDcdnUserSecDropRequest {
	s.Data = &v
	return s
}

func (s *DescribeDcdnUserSecDropRequest) SetMetric(v string) *DescribeDcdnUserSecDropRequest {
	s.Metric = &v
	return s
}

func (s *DescribeDcdnUserSecDropRequest) SetSecFunc(v string) *DescribeDcdnUserSecDropRequest {
	s.SecFunc = &v
	return s
}

type DescribeDcdnUserSecDropResponseBody struct {
	// The number of packets that are blocked.
	Drops *int32 `json:"Drops,omitempty" xml:"Drops,omitempty"`
	// Indicates whether the information is found.
	//
	// *   Found
	// *   Not Found
	Msg *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The character string that is concatenated based on the request parameters and is used to locate causes when data is not found.
	UuidStr *string `json:"UuidStr,omitempty" xml:"UuidStr,omitempty"`
}

func (s DescribeDcdnUserSecDropResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserSecDropResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserSecDropResponseBody) SetDrops(v int32) *DescribeDcdnUserSecDropResponseBody {
	s.Drops = &v
	return s
}

func (s *DescribeDcdnUserSecDropResponseBody) SetMsg(v string) *DescribeDcdnUserSecDropResponseBody {
	s.Msg = &v
	return s
}

func (s *DescribeDcdnUserSecDropResponseBody) SetRequestId(v string) *DescribeDcdnUserSecDropResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnUserSecDropResponseBody) SetUuidStr(v string) *DescribeDcdnUserSecDropResponseBody {
	s.UuidStr = &v
	return s
}

type DescribeDcdnUserSecDropResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserSecDropResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserSecDropResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserSecDropResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserSecDropResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserSecDropResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserSecDropResponse) SetStatusCode(v int32) *DescribeDcdnUserSecDropResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserSecDropResponse) SetBody(v *DescribeDcdnUserSecDropResponseBody) *DescribeDcdnUserSecDropResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserSecDropByMinuteRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2006-01-02T15:05:04Z.
	//
	// > The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The language. Valid values: en and zh. Default value: en
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The object that triggered rate limiting.
	Object *string `json:"Object,omitempty" xml:"Object,omitempty"`
	// The number of the page to return. Pages start from page 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The rule that was triggered.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The name of the security feature.
	SecFunc *string `json:"SecFunc,omitempty" xml:"SecFunc,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2006-01-02T15:04:04Z.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnUserSecDropByMinuteRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserSecDropByMinuteRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetDomainName(v string) *DescribeDcdnUserSecDropByMinuteRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetEndTime(v string) *DescribeDcdnUserSecDropByMinuteRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetLang(v string) *DescribeDcdnUserSecDropByMinuteRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetObject(v string) *DescribeDcdnUserSecDropByMinuteRequest {
	s.Object = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetPageNumber(v int64) *DescribeDcdnUserSecDropByMinuteRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetPageSize(v int64) *DescribeDcdnUserSecDropByMinuteRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetRuleName(v string) *DescribeDcdnUserSecDropByMinuteRequest {
	s.RuleName = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetSecFunc(v string) *DescribeDcdnUserSecDropByMinuteRequest {
	s.SecFunc = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteRequest) SetStartTime(v string) *DescribeDcdnUserSecDropByMinuteRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnUserSecDropByMinuteResponseBody struct {
	// The description of HTTP responses.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The total number of entries returned.
	Len *int32 `json:"Len,omitempty" xml:"Len,omitempty"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array.
	Rows []*DescribeDcdnUserSecDropByMinuteResponseBodyRows `json:"Rows,omitempty" xml:"Rows,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnUserSecDropByMinuteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserSecDropByMinuteResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBody) SetDescription(v string) *DescribeDcdnUserSecDropByMinuteResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBody) SetLen(v int32) *DescribeDcdnUserSecDropByMinuteResponseBody {
	s.Len = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBody) SetPageNumber(v int32) *DescribeDcdnUserSecDropByMinuteResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBody) SetPageSize(v int32) *DescribeDcdnUserSecDropByMinuteResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBody) SetRequestId(v string) *DescribeDcdnUserSecDropByMinuteResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBody) SetRows(v []*DescribeDcdnUserSecDropByMinuteResponseBodyRows) *DescribeDcdnUserSecDropByMinuteResponseBody {
	s.Rows = v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBody) SetTotalCount(v int32) *DescribeDcdnUserSecDropByMinuteResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnUserSecDropByMinuteResponseBodyRows struct {
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The number of packets blocked within 5 minutes.
	Drops *int32 `json:"Drops,omitempty" xml:"Drops,omitempty"`
	// The object that triggered rate limiting.
	Object *string `json:"Object,omitempty" xml:"Object,omitempty"`
	// The rule that was triggered.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The security feature that blocked the packets.
	SecFunc *string `json:"SecFunc,omitempty" xml:"SecFunc,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	TmStr *string `json:"TmStr,omitempty" xml:"TmStr,omitempty"`
}

func (s DescribeDcdnUserSecDropByMinuteResponseBodyRows) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserSecDropByMinuteResponseBodyRows) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBodyRows) SetDomain(v string) *DescribeDcdnUserSecDropByMinuteResponseBodyRows {
	s.Domain = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBodyRows) SetDrops(v int32) *DescribeDcdnUserSecDropByMinuteResponseBodyRows {
	s.Drops = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBodyRows) SetObject(v string) *DescribeDcdnUserSecDropByMinuteResponseBodyRows {
	s.Object = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBodyRows) SetRuleName(v string) *DescribeDcdnUserSecDropByMinuteResponseBodyRows {
	s.RuleName = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBodyRows) SetSecFunc(v string) *DescribeDcdnUserSecDropByMinuteResponseBodyRows {
	s.SecFunc = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponseBodyRows) SetTmStr(v string) *DescribeDcdnUserSecDropByMinuteResponseBodyRows {
	s.TmStr = &v
	return s
}

type DescribeDcdnUserSecDropByMinuteResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserSecDropByMinuteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserSecDropByMinuteResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserSecDropByMinuteResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserSecDropByMinuteResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserSecDropByMinuteResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponse) SetStatusCode(v int32) *DescribeDcdnUserSecDropByMinuteResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserSecDropByMinuteResponse) SetBody(v *DescribeDcdnUserSecDropByMinuteResponseBody) *DescribeDcdnUserSecDropByMinuteResponse {
	s.Body = v
	return s
}

type DescribeDcdnUserTagsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tag.
	Tags []*DescribeDcdnUserTagsResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserTagsResponseBody) SetRequestId(v string) *DescribeDcdnUserTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnUserTagsResponseBody) SetTags(v []*DescribeDcdnUserTagsResponseBodyTags) *DescribeDcdnUserTagsResponseBody {
	s.Tags = v
	return s
}

type DescribeDcdnUserTagsResponseBodyTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that you want to query.
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeDcdnUserTagsResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserTagsResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserTagsResponseBodyTags) SetKey(v string) *DescribeDcdnUserTagsResponseBodyTags {
	s.Key = &v
	return s
}

func (s *DescribeDcdnUserTagsResponseBodyTags) SetValue(v []*string) *DescribeDcdnUserTagsResponseBodyTags {
	s.Value = v
	return s
}

type DescribeDcdnUserTagsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnUserTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnUserTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnUserTagsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnUserTagsResponse) SetHeaders(v map[string]*string) *DescribeDcdnUserTagsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnUserTagsResponse) SetStatusCode(v int32) *DescribeDcdnUserTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnUserTagsResponse) SetBody(v *DescribeDcdnUserTagsResponseBody) *DescribeDcdnUserTagsResponse {
	s.Body = v
	return s
}

type DescribeDcdnVerifyContentRequest struct {
	// The domain name for which you want to query the ownership verification content. You can specify only one domain name in one request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnVerifyContentRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnVerifyContentRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnVerifyContentRequest) SetDomainName(v string) *DescribeDcdnVerifyContentRequest {
	s.DomainName = &v
	return s
}

type DescribeDcdnVerifyContentResponseBody struct {
	// The verification result.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnVerifyContentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnVerifyContentResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnVerifyContentResponseBody) SetContent(v string) *DescribeDcdnVerifyContentResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeDcdnVerifyContentResponseBody) SetRequestId(v string) *DescribeDcdnVerifyContentResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnVerifyContentResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnVerifyContentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnVerifyContentResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnVerifyContentResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnVerifyContentResponse) SetHeaders(v map[string]*string) *DescribeDcdnVerifyContentResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnVerifyContentResponse) SetStatusCode(v int32) *DescribeDcdnVerifyContentResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnVerifyContentResponse) SetBody(v *DescribeDcdnVerifyContentResponseBody) *DescribeDcdnVerifyContentResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafBotAppKeyResponseBody struct {
	AppKey    *string `json:"AppKey,omitempty" xml:"AppKey,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafBotAppKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafBotAppKeyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafBotAppKeyResponseBody) SetAppKey(v string) *DescribeDcdnWafBotAppKeyResponseBody {
	s.AppKey = &v
	return s
}

func (s *DescribeDcdnWafBotAppKeyResponseBody) SetRequestId(v string) *DescribeDcdnWafBotAppKeyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafBotAppKeyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafBotAppKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafBotAppKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafBotAppKeyResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafBotAppKeyResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafBotAppKeyResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafBotAppKeyResponse) SetStatusCode(v int32) *DescribeDcdnWafBotAppKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafBotAppKeyResponse) SetBody(v *DescribeDcdnWafBotAppKeyResponseBody) *DescribeDcdnWafBotAppKeyResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafDefaultRulesRequest struct {
	QueryArgs *string `json:"QueryArgs,omitempty" xml:"QueryArgs,omitempty"`
}

func (s DescribeDcdnWafDefaultRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDefaultRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDefaultRulesRequest) SetQueryArgs(v string) *DescribeDcdnWafDefaultRulesRequest {
	s.QueryArgs = &v
	return s
}

type DescribeDcdnWafDefaultRulesResponseBody struct {
	Content   []*DescribeDcdnWafDefaultRulesResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	RequestId *string                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafDefaultRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDefaultRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDefaultRulesResponseBody) SetContent(v []*DescribeDcdnWafDefaultRulesResponseBodyContent) *DescribeDcdnWafDefaultRulesResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponseBody) SetRequestId(v string) *DescribeDcdnWafDefaultRulesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafDefaultRulesResponseBodyContent struct {
	DefenseScene *string                                                `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	Rules        []*DescribeDcdnWafDefaultRulesResponseBodyContentRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
}

func (s DescribeDcdnWafDefaultRulesResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDefaultRulesResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDefaultRulesResponseBodyContent) SetDefenseScene(v string) *DescribeDcdnWafDefaultRulesResponseBodyContent {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponseBodyContent) SetRules(v []*DescribeDcdnWafDefaultRulesResponseBodyContentRules) *DescribeDcdnWafDefaultRulesResponseBodyContent {
	s.Rules = v
	return s
}

type DescribeDcdnWafDefaultRulesResponseBodyContentRules struct {
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	Name   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	Type   *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnWafDefaultRulesResponseBodyContentRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDefaultRulesResponseBodyContentRules) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDefaultRulesResponseBodyContentRules) SetAction(v string) *DescribeDcdnWafDefaultRulesResponseBodyContentRules {
	s.Action = &v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponseBodyContentRules) SetConfig(v string) *DescribeDcdnWafDefaultRulesResponseBodyContentRules {
	s.Config = &v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponseBodyContentRules) SetName(v string) *DescribeDcdnWafDefaultRulesResponseBodyContentRules {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponseBodyContentRules) SetStatus(v string) *DescribeDcdnWafDefaultRulesResponseBodyContentRules {
	s.Status = &v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponseBodyContentRules) SetType(v string) *DescribeDcdnWafDefaultRulesResponseBodyContentRules {
	s.Type = &v
	return s
}

type DescribeDcdnWafDefaultRulesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafDefaultRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafDefaultRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDefaultRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDefaultRulesResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafDefaultRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponse) SetStatusCode(v int32) *DescribeDcdnWafDefaultRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafDefaultRulesResponse) SetBody(v *DescribeDcdnWafDefaultRulesResponseBody) *DescribeDcdnWafDefaultRulesResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafDomainRequest struct {
	// The accelerated domain name. If you do not specify an accelerated domain name, all accelerated domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The region where WAF is enabled.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. If you leave this parameter empty, the default resource group is used.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeDcdnWafDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainRequest) SetDomainName(v string) *DescribeDcdnWafDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnWafDomainRequest) SetRegionId(v string) *DescribeDcdnWafDomainRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDcdnWafDomainRequest) SetResourceGroupId(v string) *DescribeDcdnWafDomainRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeDcdnWafDomainResponseBody struct {
	// The accelerated domain name.
	OutPutDomains []*DescribeDcdnWafDomainResponseBodyOutPutDomains `json:"OutPutDomains,omitempty" xml:"OutPutDomains,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of accelerated domain names returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnWafDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainResponseBody) SetOutPutDomains(v []*DescribeDcdnWafDomainResponseBodyOutPutDomains) *DescribeDcdnWafDomainResponseBody {
	s.OutPutDomains = v
	return s
}

func (s *DescribeDcdnWafDomainResponseBody) SetRequestId(v string) *DescribeDcdnWafDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafDomainResponseBody) SetTotalCount(v int32) *DescribeDcdnWafDomainResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnWafDomainResponseBodyOutPutDomains struct {
	// The status of the ACL. Valid values:
	//
	// *   0: disabled
	// *   1: enabled
	AclStatus *int32 `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The status of protection against HTTP flood attacks. Valid values:
	//
	// *   0: disabled
	// *   1: enabled
	CcStatus *int32 `json:"CcStatus,omitempty" xml:"CcStatus,omitempty"`
	// The domain name that has WAF enabled.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The status of the domain name. Valid values:
	//
	// *   1: The domain name is added to WAF, or the domain name is valid.
	// *   10: The domain name is being added to WAF.
	// *   11: The domain name failed to be added to WAF.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The status of WAF. Valid values:
	//
	// *   0: disabled
	// *   1: enabled
	WafStatus *int32 `json:"WafStatus,omitempty" xml:"WafStatus,omitempty"`
}

func (s DescribeDcdnWafDomainResponseBodyOutPutDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainResponseBodyOutPutDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainResponseBodyOutPutDomains) SetAclStatus(v int32) *DescribeDcdnWafDomainResponseBodyOutPutDomains {
	s.AclStatus = &v
	return s
}

func (s *DescribeDcdnWafDomainResponseBodyOutPutDomains) SetCcStatus(v int32) *DescribeDcdnWafDomainResponseBodyOutPutDomains {
	s.CcStatus = &v
	return s
}

func (s *DescribeDcdnWafDomainResponseBodyOutPutDomains) SetDomain(v string) *DescribeDcdnWafDomainResponseBodyOutPutDomains {
	s.Domain = &v
	return s
}

func (s *DescribeDcdnWafDomainResponseBodyOutPutDomains) SetStatus(v int32) *DescribeDcdnWafDomainResponseBodyOutPutDomains {
	s.Status = &v
	return s
}

func (s *DescribeDcdnWafDomainResponseBodyOutPutDomains) SetWafStatus(v int32) *DescribeDcdnWafDomainResponseBodyOutPutDomains {
	s.WafStatus = &v
	return s
}

type DescribeDcdnWafDomainResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafDomainResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafDomainResponse) SetStatusCode(v int32) *DescribeDcdnWafDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafDomainResponse) SetBody(v *DescribeDcdnWafDomainResponseBody) *DescribeDcdnWafDomainResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafDomainDetailRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request. Exact match is supported.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnWafDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainDetailRequest) SetDomainName(v string) *DescribeDcdnWafDomainDetailRequest {
	s.DomainName = &v
	return s
}

type DescribeDcdnWafDomainDetailResponseBody struct {
	// The information about the accelerated domain name.
	Domain *DescribeDcdnWafDomainDetailResponseBodyDomain `json:"Domain,omitempty" xml:"Domain,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainDetailResponseBody) SetDomain(v *DescribeDcdnWafDomainDetailResponseBodyDomain) *DescribeDcdnWafDomainDetailResponseBody {
	s.Domain = v
	return s
}

func (s *DescribeDcdnWafDomainDetailResponseBody) SetRequestId(v string) *DescribeDcdnWafDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafDomainDetailResponseBodyDomain struct {
	// The types of the protection policies.
	DefenseScenes []*DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes `json:"DefenseScenes,omitempty" xml:"DefenseScenes,omitempty" type:"Repeated"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnWafDomainDetailResponseBodyDomain) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainDetailResponseBodyDomain) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainDetailResponseBodyDomain) SetDefenseScenes(v []*DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes) *DescribeDcdnWafDomainDetailResponseBodyDomain {
	s.DefenseScenes = v
	return s
}

func (s *DescribeDcdnWafDomainDetailResponseBodyDomain) SetDomainName(v string) *DescribeDcdnWafDomainDetailResponseBodyDomain {
	s.DomainName = &v
	return s
}

type DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes struct {
	// The type of the protection policy. Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom protection
	// *   whitelist: whitelist
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The ID of the protection policy.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The IDs of the protection policy.
	PolicyIds *string `json:"PolicyIds,omitempty" xml:"PolicyIds,omitempty"`
}

func (s DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes) SetDefenseScene(v string) *DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes) SetPolicyId(v int64) *DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes {
	s.PolicyId = &v
	return s
}

func (s *DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes) SetPolicyIds(v string) *DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes {
	s.PolicyIds = &v
	return s
}

type DescribeDcdnWafDomainDetailResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainDetailResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafDomainDetailResponse) SetStatusCode(v int32) *DescribeDcdnWafDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafDomainDetailResponse) SetBody(v *DescribeDcdnWafDomainDetailResponseBody) *DescribeDcdnWafDomainDetailResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafDomainsRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**.
	//
	// Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The query conditions. You can filter domain names by name. Fuzzy match is supported `QueryArgs={"DomainName":"Accelerated domain name"}`
	QueryArgs *string `json:"QueryArgs,omitempty" xml:"QueryArgs,omitempty"`
}

func (s DescribeDcdnWafDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainsRequest) SetPageNumber(v int32) *DescribeDcdnWafDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafDomainsRequest) SetPageSize(v int32) *DescribeDcdnWafDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafDomainsRequest) SetQueryArgs(v string) *DescribeDcdnWafDomainsRequest {
	s.QueryArgs = &v
	return s
}

type DescribeDcdnWafDomainsResponseBody struct {
	// The protected domain name.
	Domains []*DescribeDcdnWafDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The page number of the returned page, which is the same as the PageNumber parameter in request parameters.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of protected domain names.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnWafDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainsResponseBody) SetDomains(v []*DescribeDcdnWafDomainsResponseBodyDomains) *DescribeDcdnWafDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDcdnWafDomainsResponseBody) SetPageNumber(v int32) *DescribeDcdnWafDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafDomainsResponseBody) SetPageSize(v int32) *DescribeDcdnWafDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafDomainsResponseBody) SetRequestId(v string) *DescribeDcdnWafDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafDomainsResponseBody) SetTotalCount(v int32) *DescribeDcdnWafDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnWafDomainsResponseBodyDomains struct {
	// The header of IP address of the client that is connected to the point of presence (POP).
	ClientIpTag *string `json:"ClientIpTag,omitempty" xml:"ClientIpTag,omitempty"`
	// The protected domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The number of protection policies that were configured for the protected domain name.
	PolicyCount *int32 `json:"PolicyCount,omitempty" xml:"PolicyCount,omitempty"`
}

func (s DescribeDcdnWafDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainsResponseBodyDomains) SetClientIpTag(v string) *DescribeDcdnWafDomainsResponseBodyDomains {
	s.ClientIpTag = &v
	return s
}

func (s *DescribeDcdnWafDomainsResponseBodyDomains) SetDomainName(v string) *DescribeDcdnWafDomainsResponseBodyDomains {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnWafDomainsResponseBodyDomains) SetPolicyCount(v int32) *DescribeDcdnWafDomainsResponseBodyDomains {
	s.PolicyCount = &v
	return s
}

type DescribeDcdnWafDomainsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafDomainsResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafDomainsResponse) SetStatusCode(v int32) *DescribeDcdnWafDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafDomainsResponse) SetBody(v *DescribeDcdnWafDomainsResponseBody) *DescribeDcdnWafDomainsResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafFilterInfoRequest struct {
	// The type of the protection policy. Separate multiple types with commas (,). Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom protection
	// *   whitelist: IP address whitelist
	//
	// **
	//
	// **If you do not specify this parameter, all types are returned.
	DefenseScenes *string `json:"DefenseScenes,omitempty" xml:"DefenseScenes,omitempty"`
	// The language of the returned information. Valid values:
	//
	// *   en: English
	// *   cn: Simplified Chinese
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
}

func (s DescribeDcdnWafFilterInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafFilterInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafFilterInfoRequest) SetDefenseScenes(v string) *DescribeDcdnWafFilterInfoRequest {
	s.DefenseScenes = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoRequest) SetLanguage(v string) *DescribeDcdnWafFilterInfoRequest {
	s.Language = &v
	return s
}

type DescribeDcdnWafFilterInfoResponseBody struct {
	// The returned information.
	Content []*DescribeDcdnWafFilterInfoResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafFilterInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafFilterInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafFilterInfoResponseBody) SetContent(v []*DescribeDcdnWafFilterInfoResponseBodyContent) *DescribeDcdnWafFilterInfoResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBody) SetRequestId(v string) *DescribeDcdnWafFilterInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafFilterInfoResponseBodyContent struct {
	// The type of the protection policy. The value of this parameter is the same as that of the DefenseScenes parameter in the request.
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The information about the match condition.
	Fields []*DescribeDcdnWafFilterInfoResponseBodyContentFields `json:"Fields,omitempty" xml:"Fields,omitempty" type:"Repeated"`
}

func (s DescribeDcdnWafFilterInfoResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafFilterInfoResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContent) SetDefenseScene(v string) *DescribeDcdnWafFilterInfoResponseBodyContent {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContent) SetFields(v []*DescribeDcdnWafFilterInfoResponseBodyContentFields) *DescribeDcdnWafFilterInfoResponseBodyContent {
	s.Fields = v
	return s
}

type DescribeDcdnWafFilterInfoResponseBodyContentFields struct {
	// The description of the match field. This parameter is not returned or is empty if no match fields are found.
	ExtendField *string `json:"ExtendField,omitempty" xml:"ExtendField,omitempty"`
	// The logical operator.
	LogicalSymbol []*DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol `json:"LogicalSymbol,omitempty" xml:"LogicalSymbol,omitempty" type:"Repeated"`
	// The match field.
	MatchField *string `json:"MatchField,omitempty" xml:"MatchField,omitempty"`
}

func (s DescribeDcdnWafFilterInfoResponseBodyContentFields) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafFilterInfoResponseBodyContentFields) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFields) SetExtendField(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFields {
	s.ExtendField = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFields) SetLogicalSymbol(v []*DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) *DescribeDcdnWafFilterInfoResponseBodyContentFields {
	s.LogicalSymbol = v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFields) SetMatchField(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFields {
	s.MatchField = &v
	return s
}

type DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol struct {
	// The logical symbol that is displayed in the Dynamic Content Delivery Network (DCDN) console.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The maximum number of match contents that can be returned. The value of this parameter varies based on the value of the Type parameter. Valid values:
	//
	// *   If **multi** is returned for the Type parameter, the value of this parameter indicates the maximum number of match contents.
	// *   If **single** is returned for the Type parameter, the value of this parameter is 1.
	// *   If **none** is returned for the Type parameter, the value of this parameter is 0.
	MaxLength *int32 `json:"MaxLength,omitempty" xml:"MaxLength,omitempty"`
	// The regular expression.
	Regexp *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp `json:"Regexp,omitempty" xml:"Regexp,omitempty" type:"Struct"`
	// The logical symbol that is passed to the backend.
	Symbol *string `json:"Symbol,omitempty" xml:"Symbol,omitempty"`
	// The tips that are displayed in the match content.
	Tip *string `json:"Tip,omitempty" xml:"Tip,omitempty"`
	// The number of match contents. Valid values:
	//
	// *   multi: multiple match contents
	// *   single: one match content
	// *   none: no match contents
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) SetDescription(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol {
	s.Description = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) SetMaxLength(v int32) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol {
	s.MaxLength = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) SetRegexp(v *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol {
	s.Regexp = v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) SetSymbol(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol {
	s.Symbol = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) SetTip(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol {
	s.Tip = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol) SetType(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol {
	s.Type = &v
	return s
}

type DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp struct {
	// The error message returned because no items match the regular expression.
	ErrMsg *string `json:"ErrMsg,omitempty" xml:"ErrMsg,omitempty"`
	// The regular expression.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
}

func (s DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp) SetErrMsg(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp {
	s.ErrMsg = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp) SetPattern(v string) *DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp {
	s.Pattern = &v
	return s
}

type DescribeDcdnWafFilterInfoResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafFilterInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafFilterInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafFilterInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafFilterInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafFilterInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponse) SetStatusCode(v int32) *DescribeDcdnWafFilterInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafFilterInfoResponse) SetBody(v *DescribeDcdnWafFilterInfoResponseBody) *DescribeDcdnWafFilterInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafGeoInfoRequest struct {
	// The language of the information to return. Valid values:
	//
	// *   cn: Chinese
	// *   en: English
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
}

func (s DescribeDcdnWafGeoInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGeoInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGeoInfoRequest) SetLanguage(v string) *DescribeDcdnWafGeoInfoRequest {
	s.Language = &v
	return s
}

type DescribeDcdnWafGeoInfoResponseBody struct {
	// The type of information about the country or region.
	Content []*DescribeDcdnWafGeoInfoResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafGeoInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGeoInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGeoInfoResponseBody) SetContent(v []*DescribeDcdnWafGeoInfoResponseBodyContent) *DescribeDcdnWafGeoInfoResponseBody {
	s.Content = v
	return s
}

func (s *DescribeDcdnWafGeoInfoResponseBody) SetRequestId(v string) *DescribeDcdnWafGeoInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafGeoInfoResponseBodyContent struct {
	// The information about the country or region.
	Continents []*DescribeDcdnWafGeoInfoResponseBodyContentContinents `json:"Continents,omitempty" xml:"Continents,omitempty" type:"Repeated"`
	// The type of the region.
	//
	// *   CN: China
	// *   Other: outside China
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnWafGeoInfoResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGeoInfoResponseBodyContent) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGeoInfoResponseBodyContent) SetContinents(v []*DescribeDcdnWafGeoInfoResponseBodyContentContinents) *DescribeDcdnWafGeoInfoResponseBodyContent {
	s.Continents = v
	return s
}

func (s *DescribeDcdnWafGeoInfoResponseBodyContent) SetType(v string) *DescribeDcdnWafGeoInfoResponseBodyContent {
	s.Type = &v
	return s
}

type DescribeDcdnWafGeoInfoResponseBodyContentContinents struct {
	// The district to which the country or region belongs.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region information.
	Regions []*DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
}

func (s DescribeDcdnWafGeoInfoResponseBodyContentContinents) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGeoInfoResponseBodyContentContinents) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGeoInfoResponseBodyContentContinents) SetName(v string) *DescribeDcdnWafGeoInfoResponseBodyContentContinents {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafGeoInfoResponseBodyContentContinents) SetRegions(v []*DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions) *DescribeDcdnWafGeoInfoResponseBodyContentContinents {
	s.Regions = v
	return s
}

type DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions struct {
	// The name of the country or region.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The code of the country or region.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions) SetName(v string) *DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions) SetValue(v string) *DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions {
	s.Value = &v
	return s
}

type DescribeDcdnWafGeoInfoResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafGeoInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafGeoInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGeoInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGeoInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafGeoInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafGeoInfoResponse) SetStatusCode(v int32) *DescribeDcdnWafGeoInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafGeoInfoResponse) SetBody(v *DescribeDcdnWafGeoInfoResponseBody) *DescribeDcdnWafGeoInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafGroupRequest struct {
	Id         *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	Language   *string `json:"Language,omitempty" xml:"Language,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	QueryArgs  *string `json:"QueryArgs,omitempty" xml:"QueryArgs,omitempty"`
	Scope      *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
}

func (s DescribeDcdnWafGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupRequest) SetId(v int64) *DescribeDcdnWafGroupRequest {
	s.Id = &v
	return s
}

func (s *DescribeDcdnWafGroupRequest) SetLanguage(v string) *DescribeDcdnWafGroupRequest {
	s.Language = &v
	return s
}

func (s *DescribeDcdnWafGroupRequest) SetPageNumber(v int32) *DescribeDcdnWafGroupRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafGroupRequest) SetPageSize(v int32) *DescribeDcdnWafGroupRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafGroupRequest) SetQueryArgs(v string) *DescribeDcdnWafGroupRequest {
	s.QueryArgs = &v
	return s
}

func (s *DescribeDcdnWafGroupRequest) SetScope(v string) *DescribeDcdnWafGroupRequest {
	s.Scope = &v
	return s
}

type DescribeDcdnWafGroupResponseBody struct {
	Id         *int64                                   `json:"Id,omitempty" xml:"Id,omitempty"`
	Name       *string                                  `json:"Name,omitempty" xml:"Name,omitempty"`
	PageNumber *int32                                   `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32                                   `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Rules      []*DescribeDcdnWafGroupResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
	Subscribe  *string                                  `json:"Subscribe,omitempty" xml:"Subscribe,omitempty"`
	TemplateId *int64                                   `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TotalCount *int32                                   `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnWafGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupResponseBody) SetId(v int64) *DescribeDcdnWafGroupResponseBody {
	s.Id = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetName(v string) *DescribeDcdnWafGroupResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetPageNumber(v int32) *DescribeDcdnWafGroupResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetPageSize(v int32) *DescribeDcdnWafGroupResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetRequestId(v string) *DescribeDcdnWafGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetRules(v []*DescribeDcdnWafGroupResponseBodyRules) *DescribeDcdnWafGroupResponseBody {
	s.Rules = v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetSubscribe(v string) *DescribeDcdnWafGroupResponseBody {
	s.Subscribe = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetTemplateId(v int64) *DescribeDcdnWafGroupResponseBody {
	s.TemplateId = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBody) SetTotalCount(v int32) *DescribeDcdnWafGroupResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnWafGroupResponseBodyRules struct {
	ApplicationType *int32 `json:"ApplicationType,omitempty" xml:"ApplicationType,omitempty"`
	// CVE ID
	CveId          *string `json:"CveId,omitempty" xml:"CveId,omitempty"`
	CveUrl         *string `json:"CveUrl,omitempty" xml:"CveUrl,omitempty"`
	Description    *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GmtModified    *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Id             *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ProtectionType *int32  `json:"ProtectionType,omitempty" xml:"ProtectionType,omitempty"`
	RiskLevel      *int32  `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s DescribeDcdnWafGroupResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupResponseBodyRules) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetApplicationType(v int32) *DescribeDcdnWafGroupResponseBodyRules {
	s.ApplicationType = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetCveId(v string) *DescribeDcdnWafGroupResponseBodyRules {
	s.CveId = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetCveUrl(v string) *DescribeDcdnWafGroupResponseBodyRules {
	s.CveUrl = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetDescription(v string) *DescribeDcdnWafGroupResponseBodyRules {
	s.Description = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetGmtModified(v string) *DescribeDcdnWafGroupResponseBodyRules {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetId(v int64) *DescribeDcdnWafGroupResponseBodyRules {
	s.Id = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetName(v string) *DescribeDcdnWafGroupResponseBodyRules {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetProtectionType(v int32) *DescribeDcdnWafGroupResponseBodyRules {
	s.ProtectionType = &v
	return s
}

func (s *DescribeDcdnWafGroupResponseBodyRules) SetRiskLevel(v int32) *DescribeDcdnWafGroupResponseBodyRules {
	s.RiskLevel = &v
	return s
}

type DescribeDcdnWafGroupResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafGroupResponse) SetStatusCode(v int32) *DescribeDcdnWafGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafGroupResponse) SetBody(v *DescribeDcdnWafGroupResponseBody) *DescribeDcdnWafGroupResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafGroupsRequest struct {
	Language   *string `json:"Language,omitempty" xml:"Language,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	QueryArgs  *string `json:"QueryArgs,omitempty" xml:"QueryArgs,omitempty"`
}

func (s DescribeDcdnWafGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupsRequest) SetLanguage(v string) *DescribeDcdnWafGroupsRequest {
	s.Language = &v
	return s
}

func (s *DescribeDcdnWafGroupsRequest) SetPageNumber(v int32) *DescribeDcdnWafGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafGroupsRequest) SetPageSize(v int32) *DescribeDcdnWafGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafGroupsRequest) SetQueryArgs(v string) *DescribeDcdnWafGroupsRequest {
	s.QueryArgs = &v
	return s
}

type DescribeDcdnWafGroupsResponseBody struct {
	PageNumber *int32                                        `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int32                                        `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	WafGroups  []*DescribeDcdnWafGroupsResponseBodyWafGroups `json:"WafGroups,omitempty" xml:"WafGroups,omitempty" type:"Repeated"`
}

func (s DescribeDcdnWafGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupsResponseBody) SetPageNumber(v int32) *DescribeDcdnWafGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBody) SetPageSize(v int32) *DescribeDcdnWafGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBody) SetRequestId(v string) *DescribeDcdnWafGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBody) SetTotalCount(v int32) *DescribeDcdnWafGroupsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBody) SetWafGroups(v []*DescribeDcdnWafGroupsResponseBodyWafGroups) *DescribeDcdnWafGroupsResponseBody {
	s.WafGroups = v
	return s
}

type DescribeDcdnWafGroupsResponseBodyWafGroups struct {
	GmtModified *string                                               `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Id          *int64                                                `json:"Id,omitempty" xml:"Id,omitempty"`
	Name        *string                                               `json:"Name,omitempty" xml:"Name,omitempty"`
	Policies    []*DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	RuleCount   *int32                                                `json:"RuleCount,omitempty" xml:"RuleCount,omitempty"`
	Subscribe   *string                                               `json:"Subscribe,omitempty" xml:"Subscribe,omitempty"`
	TemplateId  *int64                                                `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DescribeDcdnWafGroupsResponseBodyWafGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupsResponseBodyWafGroups) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroups) SetGmtModified(v string) *DescribeDcdnWafGroupsResponseBodyWafGroups {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroups) SetId(v int64) *DescribeDcdnWafGroupsResponseBodyWafGroups {
	s.Id = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroups) SetName(v string) *DescribeDcdnWafGroupsResponseBodyWafGroups {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroups) SetPolicies(v []*DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies) *DescribeDcdnWafGroupsResponseBodyWafGroups {
	s.Policies = v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroups) SetRuleCount(v int32) *DescribeDcdnWafGroupsResponseBodyWafGroups {
	s.RuleCount = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroups) SetSubscribe(v string) *DescribeDcdnWafGroupsResponseBodyWafGroups {
	s.Subscribe = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroups) SetTemplateId(v int64) *DescribeDcdnWafGroupsResponseBodyWafGroups {
	s.TemplateId = &v
	return s
}

type DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies struct {
	Id   *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies) SetId(v int64) *DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies {
	s.Id = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies) SetName(v string) *DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies) SetType(v string) *DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies {
	s.Type = &v
	return s
}

type DescribeDcdnWafGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafGroupsResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafGroupsResponse) SetStatusCode(v int32) *DescribeDcdnWafGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafGroupsResponse) SetBody(v *DescribeDcdnWafGroupsResponseBody) *DescribeDcdnWafGroupsResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafLogsRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Valid values: an integer greater than 0.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **300**. Valid values: **1 to 1000**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnWafLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafLogsRequest) SetDomainName(v string) *DescribeDcdnWafLogsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnWafLogsRequest) SetEndTime(v string) *DescribeDcdnWafLogsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnWafLogsRequest) SetPageNumber(v int64) *DescribeDcdnWafLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafLogsRequest) SetPageSize(v int64) *DescribeDcdnWafLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafLogsRequest) SetStartTime(v string) *DescribeDcdnWafLogsRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnWafLogsResponseBody struct {
	// Details about logs returned.
	DomainLogDetails []*DescribeDcdnWafLogsResponseBodyDomainLogDetails `json:"DomainLogDetails,omitempty" xml:"DomainLogDetails,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafLogsResponseBody) SetDomainLogDetails(v []*DescribeDcdnWafLogsResponseBodyDomainLogDetails) *DescribeDcdnWafLogsResponseBody {
	s.DomainLogDetails = v
	return s
}

func (s *DescribeDcdnWafLogsResponseBody) SetRequestId(v string) *DescribeDcdnWafLogsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafLogsResponseBodyDomainLogDetails struct {
	// The WAF domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The total number of entries returned on the current page.
	LogCount *int64 `json:"LogCount,omitempty" xml:"LogCount,omitempty"`
	// The log information.
	LogInfos []*DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos `json:"LogInfos,omitempty" xml:"LogInfos,omitempty" type:"Repeated"`
	// The page information.
	PageInfos *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos `json:"PageInfos,omitempty" xml:"PageInfos,omitempty" type:"Struct"`
}

func (s DescribeDcdnWafLogsResponseBodyDomainLogDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafLogsResponseBodyDomainLogDetails) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetails) SetDomainName(v string) *DescribeDcdnWafLogsResponseBodyDomainLogDetails {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetails) SetLogCount(v int64) *DescribeDcdnWafLogsResponseBodyDomainLogDetails {
	s.LogCount = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetails) SetLogInfos(v []*DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) *DescribeDcdnWafLogsResponseBodyDomainLogDetails {
	s.LogInfos = v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetails) SetPageInfos(v *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos) *DescribeDcdnWafLogsResponseBodyDomainLogDetails {
	s.PageInfos = v
	return s
}

type DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos struct {
	// The end of the time range during which data was queried.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the log file.
	LogName *string `json:"LogName,omitempty" xml:"LogName,omitempty"`
	// The path of the log file.
	LogPath *string `json:"LogPath,omitempty" xml:"LogPath,omitempty"`
	// The size of the log file. Unit: bytes.
	LogSize *int64 `json:"LogSize,omitempty" xml:"LogSize,omitempty"`
	// The beginning of the time range during which data was queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) SetEndTime(v string) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) SetLogName(v string) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos {
	s.LogName = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) SetLogPath(v string) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos {
	s.LogPath = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) SetLogSize(v int64) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos {
	s.LogSize = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos) SetStartTime(v string) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos {
	s.StartTime = &v
	return s
}

type DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos struct {
	// The page number of the returned page.
	PageIndex *int64 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos) SetPageIndex(v int64) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos {
	s.PageIndex = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos) SetPageSize(v int64) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos) SetTotal(v int64) *DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos {
	s.Total = &v
	return s
}

type DescribeDcdnWafLogsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafLogsResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafLogsResponse) SetStatusCode(v int32) *DescribeDcdnWafLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafLogsResponse) SetBody(v *DescribeDcdnWafLogsResponseBody) *DescribeDcdnWafLogsResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafPoliciesRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of protection policies to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The query conditions. The value is a JSON string. The format is `QueryArgs={"PolicyIds":"The IDs of protection policies","RuleIds":"The IDs of protection rules","PolicyNameLike":"The name of the protection policy","DomainNames":"The protected domain names","PolicyType":"default","DefenseScenes":"waf_group","PolicyStatus":"on","OrderBy":"GmtModified","Desc":"false"}`
	//
	// > If you do not set this parameter, all protection policies are queried.
	QueryArgs *string `json:"QueryArgs,omitempty" xml:"QueryArgs,omitempty"`
}

func (s DescribeDcdnWafPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPoliciesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPoliciesRequest) SetPageNumber(v int32) *DescribeDcdnWafPoliciesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafPoliciesRequest) SetPageSize(v int32) *DescribeDcdnWafPoliciesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafPoliciesRequest) SetQueryArgs(v string) *DescribeDcdnWafPoliciesRequest {
	s.QueryArgs = &v
	return s
}

type DescribeDcdnWafPoliciesResponseBody struct {
	// The page number of the returned page. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of protection policies returned per page. Valid values: an integer from **1** to **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The information about protection policies.
	Policies []*DescribeDcdnWafPoliciesResponseBodyPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of protection policies.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnWafPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPoliciesResponseBody) SetPageNumber(v int32) *DescribeDcdnWafPoliciesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBody) SetPageSize(v int32) *DescribeDcdnWafPoliciesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBody) SetPolicies(v []*DescribeDcdnWafPoliciesResponseBodyPolicies) *DescribeDcdnWafPoliciesResponseBody {
	s.Policies = v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBody) SetRequestId(v string) *DescribeDcdnWafPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBody) SetTotalCount(v int32) *DescribeDcdnWafPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnWafPoliciesResponseBodyPolicies struct {
	// The type of the protection policy, which is the same as the DefenseScenes field in the QueryArgs parameter.
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The number of domain names that use the protection policy.
	DomainCount *int32 `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	// The time when the protection policy was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the protection policy.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The name of the protection policy.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The status of the protection policy, which is the same as the PolicyStatus field in the QueryArgs parameter.
	PolicyStatus *string `json:"PolicyStatus,omitempty" xml:"PolicyStatus,omitempty"`
	// Indicates whether this protection policy is the default policy, which is the same as the PolicyType field in the QueryArgs parameter.
	PolicyType *string `json:"PolicyType,omitempty" xml:"PolicyType,omitempty"`
	// The number of protection rules in the protection policy.
	RuleCount *int64 `json:"RuleCount,omitempty" xml:"RuleCount,omitempty"`
}

func (s DescribeDcdnWafPoliciesResponseBodyPolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPoliciesResponseBodyPolicies) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetDefenseScene(v string) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetDomainCount(v int32) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.DomainCount = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetGmtModified(v string) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetPolicyId(v int64) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.PolicyId = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetPolicyName(v string) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.PolicyName = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetPolicyStatus(v string) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.PolicyStatus = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetPolicyType(v string) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.PolicyType = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponseBodyPolicies) SetRuleCount(v int64) *DescribeDcdnWafPoliciesResponseBodyPolicies {
	s.RuleCount = &v
	return s
}

type DescribeDcdnWafPoliciesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPoliciesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPoliciesResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafPoliciesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafPoliciesResponse) SetStatusCode(v int32) *DescribeDcdnWafPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafPoliciesResponse) SetBody(v *DescribeDcdnWafPoliciesResponseBody) *DescribeDcdnWafPoliciesResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafPolicyRequest struct {
	// The ID of the protection policy. You can specify only one ID in each request.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s DescribeDcdnWafPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyRequest) SetPolicyId(v int64) *DescribeDcdnWafPolicyRequest {
	s.PolicyId = &v
	return s
}

type DescribeDcdnWafPolicyResponseBody struct {
	// The information about the protection policy.
	Policy *DescribeDcdnWafPolicyResponseBodyPolicy `json:"Policy,omitempty" xml:"Policy,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyResponseBody) SetPolicy(v *DescribeDcdnWafPolicyResponseBodyPolicy) *DescribeDcdnWafPolicyResponseBody {
	s.Policy = v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBody) SetRequestId(v string) *DescribeDcdnWafPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafPolicyResponseBodyPolicy struct {
	// The type of the protection policy. Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom protection
	// *   whitelist: whitelist
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The number of domain names that use the protection policy.
	DomainCount *int32 `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	// The time when the protection policy was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the protection policy.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The name of the protection policy.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The status of the protection policy. Valid values:
	//
	// *   on
	// *   off
	PolicyStatus *string `json:"PolicyStatus,omitempty" xml:"PolicyStatus,omitempty"`
	// Indicates whether the current policy is the default policy. Valid values:
	//
	// *   default
	// *   custom
	PolicyType *string `json:"PolicyType,omitempty" xml:"PolicyType,omitempty"`
	// The protection rule configurations that are defined in the protection policy. The configurations only support bot management. For more information, see [Configure protection rules](~~423350~~).
	RuleConfigs *string `json:"RuleConfigs,omitempty" xml:"RuleConfigs,omitempty"`
	// The number of protection rules in the protection policy.
	RuleCount *int64 `json:"RuleCount,omitempty" xml:"RuleCount,omitempty"`
}

func (s DescribeDcdnWafPolicyResponseBodyPolicy) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyResponseBodyPolicy) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetDefenseScene(v string) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetDomainCount(v int32) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.DomainCount = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetGmtModified(v string) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetPolicyId(v int64) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.PolicyId = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetPolicyName(v string) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.PolicyName = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetPolicyStatus(v string) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.PolicyStatus = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetPolicyType(v string) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.PolicyType = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetRuleConfigs(v string) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.RuleConfigs = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponseBodyPolicy) SetRuleCount(v int64) *DescribeDcdnWafPolicyResponseBodyPolicy {
	s.RuleCount = &v
	return s
}

type DescribeDcdnWafPolicyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafPolicyResponse) SetStatusCode(v int32) *DescribeDcdnWafPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafPolicyResponse) SetBody(v *DescribeDcdnWafPolicyResponseBody) *DescribeDcdnWafPolicyResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafPolicyDomainsRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the protection policy. You can specify only one ID in each request.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s DescribeDcdnWafPolicyDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyDomainsRequest) SetPageNumber(v int32) *DescribeDcdnWafPolicyDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsRequest) SetPageSize(v int32) *DescribeDcdnWafPolicyDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsRequest) SetPolicyId(v int64) *DescribeDcdnWafPolicyDomainsRequest {
	s.PolicyId = &v
	return s
}

type DescribeDcdnWafPolicyDomainsResponseBody struct {
	// The accelerated domain names.
	Domains []*DescribeDcdnWafPolicyDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The page number of the returned page, which is the same as the PageNumber parameter in request parameters.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnWafPolicyDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyDomainsResponseBody) SetDomains(v []*DescribeDcdnWafPolicyDomainsResponseBodyDomains) *DescribeDcdnWafPolicyDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsResponseBody) SetPageNumber(v int32) *DescribeDcdnWafPolicyDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsResponseBody) SetPageSize(v int32) *DescribeDcdnWafPolicyDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsResponseBody) SetRequestId(v string) *DescribeDcdnWafPolicyDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsResponseBody) SetTotalCount(v int32) *DescribeDcdnWafPolicyDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnWafPolicyDomainsResponseBodyDomains struct {
	// The accelerated domain name that is protected by the specified protection policy.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeDcdnWafPolicyDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyDomainsResponseBodyDomains) SetDomainName(v string) *DescribeDcdnWafPolicyDomainsResponseBodyDomains {
	s.DomainName = &v
	return s
}

type DescribeDcdnWafPolicyDomainsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafPolicyDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafPolicyDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyDomainsResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafPolicyDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsResponse) SetStatusCode(v int32) *DescribeDcdnWafPolicyDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafPolicyDomainsResponse) SetBody(v *DescribeDcdnWafPolicyDomainsResponseBody) *DescribeDcdnWafPolicyDomainsResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafPolicyValidDomainsRequest struct {
	// The type of the Web Application Firewall (WAF) protection policy. Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom protection
	// *   whitelist: IP address whitelist
	// *   ip_blacklist: IP address blacklist
	// *   region_block: region blacklist
	// *   bot: bot management
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The protected domain name. Fuzzy search is supported.
	DomainNameLike *string `json:"DomainNameLike,omitempty" xml:"DomainNameLike,omitempty"`
	// The page number of the returned page. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeDcdnWafPolicyValidDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyValidDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyValidDomainsRequest) SetDefenseScene(v string) *DescribeDcdnWafPolicyValidDomainsRequest {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsRequest) SetDomainNameLike(v string) *DescribeDcdnWafPolicyValidDomainsRequest {
	s.DomainNameLike = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsRequest) SetPageNumber(v int32) *DescribeDcdnWafPolicyValidDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsRequest) SetPageSize(v int32) *DescribeDcdnWafPolicyValidDomainsRequest {
	s.PageSize = &v
	return s
}

type DescribeDcdnWafPolicyValidDomainsResponseBody struct {
	// The information about the protected domain names.
	Domains []*DescribeDcdnWafPolicyValidDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The page number of the returned page, which is the same as the PageNumber parameter in request parameters.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnWafPolicyValidDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyValidDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBody) SetDomains(v []*DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) *DescribeDcdnWafPolicyValidDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBody) SetPageNumber(v int32) *DescribeDcdnWafPolicyValidDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBody) SetPageSize(v int32) *DescribeDcdnWafPolicyValidDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBody) SetRequestId(v string) *DescribeDcdnWafPolicyValidDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBody) SetTotalCount(v int32) *DescribeDcdnWafPolicyValidDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnWafPolicyValidDomainsResponseBodyDomains struct {
	// The protected domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The policy that is bound to the domain name.
	Policies []*DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// The ID of the protection policy.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The name of the protection policy.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// Indicates whether the protection policy is the default policy. Valid values:
	//
	// *   default: The protection policy is the default policy.
	// *   custom: The protection policy is not the default policy.
	PolicyType *string `json:"PolicyType,omitempty" xml:"PolicyType,omitempty"`
}

func (s DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) SetDomainName(v string) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) SetPolicies(v []*DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains {
	s.Policies = v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) SetPolicyId(v int64) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains {
	s.PolicyId = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) SetPolicyName(v string) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains {
	s.PolicyName = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains) SetPolicyType(v string) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomains {
	s.PolicyType = &v
	return s
}

type DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies struct {
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the policy.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies) SetId(v int64) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies {
	s.Id = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies) SetName(v string) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies {
	s.Name = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies) SetType(v string) *DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies {
	s.Type = &v
	return s
}

type DescribeDcdnWafPolicyValidDomainsResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafPolicyValidDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafPolicyValidDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafPolicyValidDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafPolicyValidDomainsResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafPolicyValidDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponse) SetStatusCode(v int32) *DescribeDcdnWafPolicyValidDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafPolicyValidDomainsResponse) SetBody(v *DescribeDcdnWafPolicyValidDomainsResponseBody) *DescribeDcdnWafPolicyValidDomainsResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafRuleRequest struct {
	// The ID of the protection rule. You can specify only one ID in each request.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DescribeDcdnWafRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRuleRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRuleRequest) SetRuleId(v int64) *DescribeDcdnWafRuleRequest {
	s.RuleId = &v
	return s
}

type DescribeDcdnWafRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the protection rule.
	Rule *DescribeDcdnWafRuleResponseBodyRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Struct"`
}

func (s DescribeDcdnWafRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRuleResponseBody) SetRequestId(v string) *DescribeDcdnWafRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafRuleResponseBody) SetRule(v *DescribeDcdnWafRuleResponseBodyRule) *DescribeDcdnWafRuleResponseBody {
	s.Rule = v
	return s
}

type DescribeDcdnWafRuleResponseBodyRule struct {
	// The type of the protection policy. Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom protection
	// *   whitelist: IP address whitelist
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The time when the scaling group was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the protection policy.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The configurations of the protection rule.
	RuleConfig *string `json:"RuleConfig,omitempty" xml:"RuleConfig,omitempty"`
	// The ID of the protection rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the protection rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The status of the protection rule. Valid values:
	//
	// *   on
	// *   off
	RuleStatus *string `json:"RuleStatus,omitempty" xml:"RuleStatus,omitempty"`
}

func (s DescribeDcdnWafRuleResponseBodyRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRuleResponseBodyRule) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRuleResponseBodyRule) SetDefenseScene(v string) *DescribeDcdnWafRuleResponseBodyRule {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafRuleResponseBodyRule) SetGmtModified(v string) *DescribeDcdnWafRuleResponseBodyRule {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnWafRuleResponseBodyRule) SetPolicyId(v int64) *DescribeDcdnWafRuleResponseBodyRule {
	s.PolicyId = &v
	return s
}

func (s *DescribeDcdnWafRuleResponseBodyRule) SetRuleConfig(v string) *DescribeDcdnWafRuleResponseBodyRule {
	s.RuleConfig = &v
	return s
}

func (s *DescribeDcdnWafRuleResponseBodyRule) SetRuleId(v int64) *DescribeDcdnWafRuleResponseBodyRule {
	s.RuleId = &v
	return s
}

func (s *DescribeDcdnWafRuleResponseBodyRule) SetRuleName(v string) *DescribeDcdnWafRuleResponseBodyRule {
	s.RuleName = &v
	return s
}

func (s *DescribeDcdnWafRuleResponseBodyRule) SetRuleStatus(v string) *DescribeDcdnWafRuleResponseBodyRule {
	s.RuleStatus = &v
	return s
}

type DescribeDcdnWafRuleResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRuleResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRuleResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafRuleResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafRuleResponse) SetStatusCode(v int32) *DescribeDcdnWafRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafRuleResponse) SetBody(v *DescribeDcdnWafRuleResponseBody) *DescribeDcdnWafRuleResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafRulesRequest struct {
	// The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of protection rules to return per page. Valid values: integers from **1** to **500**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The query conditions. The value needs to be a JSON string in the following format: `QueryArgs={"PolicyIds":"The range of protection policy IDs","RuleIds":"The range of protection rule IDs","RuleNameLike":"The name of the protection rule","DomainNames":"The protected domain names","DefenseScenes":"waf_group","RuleStatus":"on","OrderBy":"GmtModified","Desc":"false"}`.
	//
	// > If you do not specify this parameter, all protection rules are queried.
	QueryArgs *string `json:"QueryArgs,omitempty" xml:"QueryArgs,omitempty"`
}

func (s DescribeDcdnWafRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRulesRequest) SetPageNumber(v int32) *DescribeDcdnWafRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafRulesRequest) SetPageSize(v int32) *DescribeDcdnWafRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafRulesRequest) SetQueryArgs(v string) *DescribeDcdnWafRulesRequest {
	s.QueryArgs = &v
	return s
}

type DescribeDcdnWafRulesResponseBody struct {
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of protection rules returned per page. The value of this parameter is the same as that of the PageSize parameter in the request.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the protection rule.
	Rules []*DescribeDcdnWafRulesResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
	// The total number of protection rules.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDcdnWafRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRulesResponseBody) SetPageNumber(v int32) *DescribeDcdnWafRulesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBody) SetPageSize(v int32) *DescribeDcdnWafRulesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBody) SetRequestId(v string) *DescribeDcdnWafRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBody) SetRules(v []*DescribeDcdnWafRulesResponseBodyRules) *DescribeDcdnWafRulesResponseBody {
	s.Rules = v
	return s
}

func (s *DescribeDcdnWafRulesResponseBody) SetTotalCount(v int32) *DescribeDcdnWafRulesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDcdnWafRulesResponseBodyRules struct {
	// The type of the protection policy. The value of this parameter is the same as that of the DefenseScene field in QueryArgst.
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The time when the protection policy was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the protection policy.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The configuration information about the protection rule.
	RuleConfig *string `json:"RuleConfig,omitempty" xml:"RuleConfig,omitempty"`
	// The ID of the protection rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the protection rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The status of the protection rule. The value of this parameter is the same as that of the RuleStatus field in QueryArgst.
	RuleStatus *string `json:"RuleStatus,omitempty" xml:"RuleStatus,omitempty"`
}

func (s DescribeDcdnWafRulesResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRulesResponseBodyRules) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRulesResponseBodyRules) SetDefenseScene(v string) *DescribeDcdnWafRulesResponseBodyRules {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBodyRules) SetGmtModified(v string) *DescribeDcdnWafRulesResponseBodyRules {
	s.GmtModified = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBodyRules) SetPolicyId(v int64) *DescribeDcdnWafRulesResponseBodyRules {
	s.PolicyId = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBodyRules) SetRuleConfig(v string) *DescribeDcdnWafRulesResponseBodyRules {
	s.RuleConfig = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBodyRules) SetRuleId(v int64) *DescribeDcdnWafRulesResponseBodyRules {
	s.RuleId = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBodyRules) SetRuleName(v string) *DescribeDcdnWafRulesResponseBodyRules {
	s.RuleName = &v
	return s
}

func (s *DescribeDcdnWafRulesResponseBodyRules) SetRuleStatus(v string) *DescribeDcdnWafRulesResponseBodyRules {
	s.RuleStatus = &v
	return s
}

type DescribeDcdnWafRulesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafRulesResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafRulesResponse) SetStatusCode(v int32) *DescribeDcdnWafRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafRulesResponse) SetBody(v *DescribeDcdnWafRulesResponseBody) *DescribeDcdnWafRulesResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafScenesRequest struct {
	// The types of the protection policies that you want to query. Separate multiple types with commas (,). Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom protection
	// *   whitelist: IP address whitelist
	// *   ip_blacklist: IP address blacklist
	// *   region_block: region blacklist
	// *   bot: bot management
	//
	// > If you do not set this parameter, all types of protection policies are queried.
	DefenseScenes *string `json:"DefenseScenes,omitempty" xml:"DefenseScenes,omitempty"`
}

func (s DescribeDcdnWafScenesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafScenesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafScenesRequest) SetDefenseScenes(v string) *DescribeDcdnWafScenesRequest {
	s.DefenseScenes = &v
	return s
}

type DescribeDcdnWafScenesResponseBody struct {
	// The types of the protection policies.
	DefenseScenes []*DescribeDcdnWafScenesResponseBodyDefenseScenes `json:"DefenseScenes,omitempty" xml:"DefenseScenes,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDcdnWafScenesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafScenesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafScenesResponseBody) SetDefenseScenes(v []*DescribeDcdnWafScenesResponseBodyDefenseScenes) *DescribeDcdnWafScenesResponseBody {
	s.DefenseScenes = v
	return s
}

func (s *DescribeDcdnWafScenesResponseBody) SetRequestId(v string) *DescribeDcdnWafScenesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDcdnWafScenesResponseBodyDefenseScenes struct {
	// The type of the protection policy, which is the same as the DefenseScenes parameter in request parameters.
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
	// The total number of policies of this type that were configured.
	PolicyCount *int32 `json:"PolicyCount,omitempty" xml:"PolicyCount,omitempty"`
	// The total number of protection rules that were configured in this type of the policy.
	RuleCount *int32 `json:"RuleCount,omitempty" xml:"RuleCount,omitempty"`
}

func (s DescribeDcdnWafScenesResponseBodyDefenseScenes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafScenesResponseBodyDefenseScenes) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafScenesResponseBodyDefenseScenes) SetDefenseScene(v string) *DescribeDcdnWafScenesResponseBodyDefenseScenes {
	s.DefenseScene = &v
	return s
}

func (s *DescribeDcdnWafScenesResponseBodyDefenseScenes) SetPolicyCount(v int32) *DescribeDcdnWafScenesResponseBodyDefenseScenes {
	s.PolicyCount = &v
	return s
}

func (s *DescribeDcdnWafScenesResponseBodyDefenseScenes) SetRuleCount(v int32) *DescribeDcdnWafScenesResponseBodyDefenseScenes {
	s.RuleCount = &v
	return s
}

type DescribeDcdnWafScenesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafScenesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafScenesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafScenesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafScenesResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafScenesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafScenesResponse) SetStatusCode(v int32) *DescribeDcdnWafScenesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafScenesResponse) SetBody(v *DescribeDcdnWafScenesResponseBody) *DescribeDcdnWafScenesResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafServiceRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnWafServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafServiceRequest) SetOwnerId(v int64) *DescribeDcdnWafServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnWafServiceRequest) SetSecurityToken(v string) *DescribeDcdnWafServiceRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnWafServiceResponseBody struct {
	// The edition of WAF.
	Edition *string `json:"Edition,omitempty" xml:"Edition,omitempty"`
	// The status of WAF. Valid values:
	//
	// *   on
	// *   off
	Enabled *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The time when WAF was enabled.
	OpeningTime *string `json:"OpeningTime,omitempty" xml:"OpeningTime,omitempty"`
	// The metering method for requests.
	RequestBillingType *string `json:"RequestBillingType,omitempty" xml:"RequestBillingType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The metering method for rules. You are charged for the number of SeCUs.
	RuleBillingType *string `json:"RuleBillingType,omitempty" xml:"RuleBillingType,omitempty"`
	// The status of WAF. Valid values:
	//
	// *   Normal
	// *   WaitForExpire
	// *   Expired
	// *   Released
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDcdnWafServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafServiceResponseBody) SetEdition(v string) *DescribeDcdnWafServiceResponseBody {
	s.Edition = &v
	return s
}

func (s *DescribeDcdnWafServiceResponseBody) SetEnabled(v string) *DescribeDcdnWafServiceResponseBody {
	s.Enabled = &v
	return s
}

func (s *DescribeDcdnWafServiceResponseBody) SetOpeningTime(v string) *DescribeDcdnWafServiceResponseBody {
	s.OpeningTime = &v
	return s
}

func (s *DescribeDcdnWafServiceResponseBody) SetRequestBillingType(v string) *DescribeDcdnWafServiceResponseBody {
	s.RequestBillingType = &v
	return s
}

func (s *DescribeDcdnWafServiceResponseBody) SetRequestId(v string) *DescribeDcdnWafServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafServiceResponseBody) SetRuleBillingType(v string) *DescribeDcdnWafServiceResponseBody {
	s.RuleBillingType = &v
	return s
}

func (s *DescribeDcdnWafServiceResponseBody) SetStatus(v string) *DescribeDcdnWafServiceResponseBody {
	s.Status = &v
	return s
}

type DescribeDcdnWafServiceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafServiceResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafServiceResponse) SetStatusCode(v int32) *DescribeDcdnWafServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafServiceResponse) SetBody(v *DescribeDcdnWafServiceResponseBody) *DescribeDcdnWafServiceResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafSpecInfoResponseBody struct {
	// The version of WAF.
	Edition *string `json:"Edition,omitempty" xml:"Edition,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The supported types of protection policies and the configuration information of protection rules.
	SpecInfos []*DescribeDcdnWafSpecInfoResponseBodySpecInfos `json:"SpecInfos,omitempty" xml:"SpecInfos,omitempty" type:"Repeated"`
}

func (s DescribeDcdnWafSpecInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafSpecInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafSpecInfoResponseBody) SetEdition(v string) *DescribeDcdnWafSpecInfoResponseBody {
	s.Edition = &v
	return s
}

func (s *DescribeDcdnWafSpecInfoResponseBody) SetRequestId(v string) *DescribeDcdnWafSpecInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafSpecInfoResponseBody) SetSpecInfos(v []*DescribeDcdnWafSpecInfoResponseBodySpecInfos) *DescribeDcdnWafSpecInfoResponseBody {
	s.SpecInfos = v
	return s
}

type DescribeDcdnWafSpecInfoResponseBodySpecInfos struct {
	// The configuration information of the protection rule.
	Configs []*DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Repeated"`
	// The type of the protection policy. Valid values:
	//
	// *   waf_group: basic web protection
	// *   custom_acl: custom
	// *   whitelist: whitelist
	// *   ip_blacklist: IP address blacklist
	// *   region_block: region blacklist
	// *   bot: bot management
	DefenseScene *string `json:"DefenseScene,omitempty" xml:"DefenseScene,omitempty"`
}

func (s DescribeDcdnWafSpecInfoResponseBodySpecInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafSpecInfoResponseBodySpecInfos) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafSpecInfoResponseBodySpecInfos) SetConfigs(v []*DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs) *DescribeDcdnWafSpecInfoResponseBodySpecInfos {
	s.Configs = v
	return s
}

func (s *DescribeDcdnWafSpecInfoResponseBodySpecInfos) SetDefenseScene(v string) *DescribeDcdnWafSpecInfoResponseBodySpecInfos {
	s.DefenseScene = &v
	return s
}

type DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs struct {
	// The configuration code of the protection rule.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The configuration expression of the protection rule.
	Expr *string `json:"Expr,omitempty" xml:"Expr,omitempty"`
	// The value of the configuration expression of the protection rule.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs) SetConfig(v string) *DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs {
	s.Config = &v
	return s
}

func (s *DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs) SetExpr(v string) *DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs {
	s.Expr = &v
	return s
}

func (s *DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs) SetValue(v string) *DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs {
	s.Value = &v
	return s
}

type DescribeDcdnWafSpecInfoResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafSpecInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafSpecInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafSpecInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafSpecInfoResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafSpecInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafSpecInfoResponse) SetStatusCode(v int32) *DescribeDcdnWafSpecInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafSpecInfoResponse) SetBody(v *DescribeDcdnWafSpecInfoResponseBody) *DescribeDcdnWafSpecInfoResponse {
	s.Body = v
	return s
}

type DescribeDcdnWafUsageDataRequest struct {
	// The timestamp of the data returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of used SeCUs.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The WAF information about the accelerated domain name.
	SplitBy *string `json:"SplitBy,omitempty" xml:"SplitBy,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDcdnWafUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafUsageDataRequest) SetDomainName(v string) *DescribeDcdnWafUsageDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDcdnWafUsageDataRequest) SetEndTime(v string) *DescribeDcdnWafUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnWafUsageDataRequest) SetInterval(v string) *DescribeDcdnWafUsageDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDcdnWafUsageDataRequest) SetSplitBy(v string) *DescribeDcdnWafUsageDataRequest {
	s.SplitBy = &v
	return s
}

func (s *DescribeDcdnWafUsageDataRequest) SetStartTime(v string) *DescribeDcdnWafUsageDataRequest {
	s.StartTime = &v
	return s
}

type DescribeDcdnWafUsageDataResponseBody struct {
	// The operation that you want to perform. Set the value to **DescribeDcdnWafUsageData**.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Specifies how query results are grouped. By default, this parameter is empty. Valid values:
	//
	// *   domain: Query results are grouped by accelerated domain name.
	// *   An empty string: Query results are not grouped.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The accelerated domain name.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The number of monitored requests.
	WafUsageData *DescribeDcdnWafUsageDataResponseBodyWafUsageData `json:"WafUsageData,omitempty" xml:"WafUsageData,omitempty" type:"Struct"`
}

func (s DescribeDcdnWafUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafUsageDataResponseBody) SetEndTime(v string) *DescribeDcdnWafUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBody) SetRequestId(v string) *DescribeDcdnWafUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBody) SetStartTime(v string) *DescribeDcdnWafUsageDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBody) SetWafUsageData(v *DescribeDcdnWafUsageDataResponseBodyWafUsageData) *DescribeDcdnWafUsageDataResponseBody {
	s.WafUsageData = v
	return s
}

type DescribeDcdnWafUsageDataResponseBodyWafUsageData struct {
	WafUsageDataItem []*DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem `json:"WafUsageDataItem,omitempty" xml:"WafUsageDataItem,omitempty" type:"Repeated"`
}

func (s DescribeDcdnWafUsageDataResponseBodyWafUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafUsageDataResponseBodyWafUsageData) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafUsageDataResponseBodyWafUsageData) SetWafUsageDataItem(v []*DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) *DescribeDcdnWafUsageDataResponseBodyWafUsageData {
	s.WafUsageDataItem = v
	return s
}

type DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem struct {
	// The number of blocked requests.
	AccessCnt *int64 `json:"AccessCnt,omitempty" xml:"AccessCnt,omitempty"`
	// The number of allowed requests.
	BlockCnt *int64 `json:"BlockCnt,omitempty" xml:"BlockCnt,omitempty"`
	// The domain name that you want to query. If you do not specify an accelerated domain name, all accelerated domain names are queried by default.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range during which data was queried.
	ObserveCnt *int64 `json:"ObserveCnt,omitempty" xml:"ObserveCnt,omitempty"`
	// The time granularity for a query. Unit: seconds.
	//
	// The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day).
	SecCu *int64 `json:"SecCu,omitempty" xml:"SecCu,omitempty"`
	// The beginning of the time range during which data was queried.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) SetAccessCnt(v int64) *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem {
	s.AccessCnt = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) SetBlockCnt(v int64) *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem {
	s.BlockCnt = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) SetDomain(v string) *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem {
	s.Domain = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) SetObserveCnt(v int64) *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem {
	s.ObserveCnt = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) SetSecCu(v int64) *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem {
	s.SecCu = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem) SetTimeStamp(v string) *DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem {
	s.TimeStamp = &v
	return s
}

type DescribeDcdnWafUsageDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnWafUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnWafUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnWafUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnWafUsageDataResponse) SetHeaders(v map[string]*string) *DescribeDcdnWafUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnWafUsageDataResponse) SetStatusCode(v int32) *DescribeDcdnWafUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnWafUsageDataResponse) SetBody(v *DescribeDcdnWafUsageDataResponseBody) *DescribeDcdnWafUsageDataResponse {
	s.Body = v
	return s
}

type DescribeDcdnsecServiceRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeDcdnsecServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnsecServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDcdnsecServiceRequest) SetOwnerId(v int64) *DescribeDcdnsecServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDcdnsecServiceRequest) SetSecurityToken(v string) *DescribeDcdnsecServiceRequest {
	s.SecurityToken = &v
	return s
}

type DescribeDcdnsecServiceResponseBody struct {
	// The time when the renewed service takes effect. The time is displayed in UTC.
	ChangingAffectTime *string `json:"ChangingAffectTime,omitempty" xml:"ChangingAffectTime,omitempty"`
	// The new metering method for the renewed DCDN. Valid values:
	//
	// *   **PayByTraffic**: pay by data transfer
	// *   **PayByBandwidth**: pay by bandwidth
	// *   **PayByBandwidth95**: pay by 95th percentile bandwidth
	// *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
	// *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
	// *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
	// *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
	ChangingChargeType *string `json:"ChangingChargeType,omitempty" xml:"ChangingChargeType,omitempty"`
	// The number of accelerated domain names that use DCDN.
	DomainNum *string `json:"DomainNum,omitempty" xml:"DomainNum,omitempty"`
	// The service expiration time.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The metering method for traffic.
	FlowType *string `json:"FlowType,omitempty" xml:"FlowType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The current metering method. Valid values:
	//
	// *   **PayByTraffic**: pay by data transfer
	// *   **PayByBandwidth**: pay by bandwidth
	// *   **PayByBandwidth95**: pay by 95th percentile bandwidth
	// *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
	// *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
	// *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
	// *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The lock status of DCDN.
	OperationLocks *DescribeDcdnsecServiceResponseBodyOperationLocks `json:"OperationLocks,omitempty" xml:"OperationLocks,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The metering method for requests.
	RequestType *string `json:"RequestType,omitempty" xml:"RequestType,omitempty"`
	// The service activation time.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The version number.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s DescribeDcdnsecServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnsecServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDcdnsecServiceResponseBody) SetChangingAffectTime(v string) *DescribeDcdnsecServiceResponseBody {
	s.ChangingAffectTime = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetChangingChargeType(v string) *DescribeDcdnsecServiceResponseBody {
	s.ChangingChargeType = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetDomainNum(v string) *DescribeDcdnsecServiceResponseBody {
	s.DomainNum = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetEndTime(v string) *DescribeDcdnsecServiceResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetFlowType(v string) *DescribeDcdnsecServiceResponseBody {
	s.FlowType = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetInstanceId(v string) *DescribeDcdnsecServiceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetInternetChargeType(v string) *DescribeDcdnsecServiceResponseBody {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetOperationLocks(v *DescribeDcdnsecServiceResponseBodyOperationLocks) *DescribeDcdnsecServiceResponseBody {
	s.OperationLocks = v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetRequestId(v string) *DescribeDcdnsecServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetRequestType(v string) *DescribeDcdnsecServiceResponseBody {
	s.RequestType = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetStartTime(v string) *DescribeDcdnsecServiceResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDcdnsecServiceResponseBody) SetVersion(v string) *DescribeDcdnsecServiceResponseBody {
	s.Version = &v
	return s
}

type DescribeDcdnsecServiceResponseBodyOperationLocks struct {
	LockReason []*DescribeDcdnsecServiceResponseBodyOperationLocksLockReason `json:"LockReason,omitempty" xml:"LockReason,omitempty" type:"Repeated"`
}

func (s DescribeDcdnsecServiceResponseBodyOperationLocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnsecServiceResponseBodyOperationLocks) GoString() string {
	return s.String()
}

func (s *DescribeDcdnsecServiceResponseBodyOperationLocks) SetLockReason(v []*DescribeDcdnsecServiceResponseBodyOperationLocksLockReason) *DescribeDcdnsecServiceResponseBodyOperationLocks {
	s.LockReason = v
	return s
}

type DescribeDcdnsecServiceResponseBodyOperationLocksLockReason struct {
	// The reason why the instance was locked.
	LockReason *string `json:"LockReason,omitempty" xml:"LockReason,omitempty"`
}

func (s DescribeDcdnsecServiceResponseBodyOperationLocksLockReason) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnsecServiceResponseBodyOperationLocksLockReason) GoString() string {
	return s.String()
}

func (s *DescribeDcdnsecServiceResponseBodyOperationLocksLockReason) SetLockReason(v string) *DescribeDcdnsecServiceResponseBodyOperationLocksLockReason {
	s.LockReason = &v
	return s
}

type DescribeDcdnsecServiceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDcdnsecServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDcdnsecServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDcdnsecServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDcdnsecServiceResponse) SetHeaders(v map[string]*string) *DescribeDcdnsecServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDcdnsecServiceResponse) SetStatusCode(v int32) *DescribeDcdnsecServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDcdnsecServiceResponse) SetBody(v *DescribeDcdnsecServiceResponseBody) *DescribeDcdnsecServiceResponse {
	s.Body = v
	return s
}

type DescribeDdosAllEventListRequest struct {
	EndTime    *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	EventType  *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	StartTime  *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDdosAllEventListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDdosAllEventListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDdosAllEventListRequest) SetEndTime(v string) *DescribeDdosAllEventListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDdosAllEventListRequest) SetEventType(v string) *DescribeDdosAllEventListRequest {
	s.EventType = &v
	return s
}

func (s *DescribeDdosAllEventListRequest) SetPageNumber(v int32) *DescribeDdosAllEventListRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDdosAllEventListRequest) SetPageSize(v int32) *DescribeDdosAllEventListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDdosAllEventListRequest) SetStartTime(v string) *DescribeDdosAllEventListRequest {
	s.StartTime = &v
	return s
}

type DescribeDdosAllEventListResponseBody struct {
	DataList   []*DescribeDdosAllEventListResponseBodyDataList `json:"DataList,omitempty" xml:"DataList,omitempty" type:"Repeated"`
	PageNumber *int32                                          `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32                                          `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Total      *int64                                          `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeDdosAllEventListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDdosAllEventListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDdosAllEventListResponseBody) SetDataList(v []*DescribeDdosAllEventListResponseBodyDataList) *DescribeDdosAllEventListResponseBody {
	s.DataList = v
	return s
}

func (s *DescribeDdosAllEventListResponseBody) SetPageNumber(v int32) *DescribeDdosAllEventListResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBody) SetPageSize(v int32) *DescribeDdosAllEventListResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBody) SetRequestId(v string) *DescribeDdosAllEventListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBody) SetTotal(v int64) *DescribeDdosAllEventListResponseBody {
	s.Total = &v
	return s
}

type DescribeDdosAllEventListResponseBodyDataList struct {
	Bps       *int64  `json:"Bps,omitempty" xml:"Bps,omitempty"`
	Cps       *int64  `json:"Cps,omitempty" xml:"Cps,omitempty"`
	EndTime   *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	EventId   *string `json:"EventId,omitempty" xml:"EventId,omitempty"`
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	Pps       *int64  `json:"Pps,omitempty" xml:"Pps,omitempty"`
	Qps       *int64  `json:"Qps,omitempty" xml:"Qps,omitempty"`
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	Target    *string `json:"Target,omitempty" xml:"Target,omitempty"`
}

func (s DescribeDdosAllEventListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDdosAllEventListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetBps(v int64) *DescribeDdosAllEventListResponseBodyDataList {
	s.Bps = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetCps(v int64) *DescribeDdosAllEventListResponseBodyDataList {
	s.Cps = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetEndTime(v string) *DescribeDdosAllEventListResponseBodyDataList {
	s.EndTime = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetEventId(v string) *DescribeDdosAllEventListResponseBodyDataList {
	s.EventId = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetEventType(v string) *DescribeDdosAllEventListResponseBodyDataList {
	s.EventType = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetPps(v int64) *DescribeDdosAllEventListResponseBodyDataList {
	s.Pps = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetQps(v int64) *DescribeDdosAllEventListResponseBodyDataList {
	s.Qps = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetStartTime(v string) *DescribeDdosAllEventListResponseBodyDataList {
	s.StartTime = &v
	return s
}

func (s *DescribeDdosAllEventListResponseBodyDataList) SetTarget(v string) *DescribeDdosAllEventListResponseBodyDataList {
	s.Target = &v
	return s
}

type DescribeDdosAllEventListResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDdosAllEventListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDdosAllEventListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDdosAllEventListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDdosAllEventListResponse) SetHeaders(v map[string]*string) *DescribeDdosAllEventListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDdosAllEventListResponse) SetStatusCode(v int32) *DescribeDdosAllEventListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDdosAllEventListResponse) SetBody(v *DescribeDdosAllEventListResponseBody) *DescribeDdosAllEventListResponse {
	s.Body = v
	return s
}

type DescribeEncryptRoutineUidResponseBody struct {
	Content   *string `json:"Content,omitempty" xml:"Content,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEncryptRoutineUidResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEncryptRoutineUidResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEncryptRoutineUidResponseBody) SetContent(v string) *DescribeEncryptRoutineUidResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeEncryptRoutineUidResponseBody) SetRequestId(v string) *DescribeEncryptRoutineUidResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEncryptRoutineUidResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEncryptRoutineUidResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEncryptRoutineUidResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEncryptRoutineUidResponse) GoString() string {
	return s.String()
}

func (s *DescribeEncryptRoutineUidResponse) SetHeaders(v map[string]*string) *DescribeEncryptRoutineUidResponse {
	s.Headers = v
	return s
}

func (s *DescribeEncryptRoutineUidResponse) SetStatusCode(v int32) *DescribeEncryptRoutineUidResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEncryptRoutineUidResponse) SetBody(v *DescribeEncryptRoutineUidResponseBody) *DescribeEncryptRoutineUidResponse {
	s.Body = v
	return s
}

type DescribeHighlightInfoRequest struct {
	EndTime   *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Lang      *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TraceId   *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s DescribeHighlightInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighlightInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeHighlightInfoRequest) SetEndTime(v string) *DescribeHighlightInfoRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeHighlightInfoRequest) SetLang(v string) *DescribeHighlightInfoRequest {
	s.Lang = &v
	return s
}

func (s *DescribeHighlightInfoRequest) SetStartTime(v string) *DescribeHighlightInfoRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeHighlightInfoRequest) SetTraceId(v string) *DescribeHighlightInfoRequest {
	s.TraceId = &v
	return s
}

type DescribeHighlightInfoResponseBody struct {
	DataModule []*DescribeHighlightInfoResponseBodyDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
	RequestId  *string                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHighlightInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighlightInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHighlightInfoResponseBody) SetDataModule(v []*DescribeHighlightInfoResponseBodyDataModule) *DescribeHighlightInfoResponseBody {
	s.DataModule = v
	return s
}

func (s *DescribeHighlightInfoResponseBody) SetRequestId(v string) *DescribeHighlightInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHighlightInfoResponseBodyDataModule struct {
	Hit *string `json:"Hit,omitempty" xml:"Hit,omitempty"`
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Raw *string `json:"Raw,omitempty" xml:"Raw,omitempty"`
}

func (s DescribeHighlightInfoResponseBodyDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighlightInfoResponseBodyDataModule) GoString() string {
	return s.String()
}

func (s *DescribeHighlightInfoResponseBodyDataModule) SetHit(v string) *DescribeHighlightInfoResponseBodyDataModule {
	s.Hit = &v
	return s
}

func (s *DescribeHighlightInfoResponseBodyDataModule) SetKey(v string) *DescribeHighlightInfoResponseBodyDataModule {
	s.Key = &v
	return s
}

func (s *DescribeHighlightInfoResponseBodyDataModule) SetRaw(v string) *DescribeHighlightInfoResponseBodyDataModule {
	s.Raw = &v
	return s
}

type DescribeHighlightInfoResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHighlightInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHighlightInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighlightInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeHighlightInfoResponse) SetHeaders(v map[string]*string) *DescribeHighlightInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeHighlightInfoResponse) SetStatusCode(v int32) *DescribeHighlightInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHighlightInfoResponse) SetBody(v *DescribeHighlightInfoResponseBody) *DescribeHighlightInfoResponse {
	s.Body = v
	return s
}

type DescribeRDDomainConfigRequest struct {
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the feature. Default value: source_group.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s DescribeRDDomainConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainConfigRequest) SetDomainName(v string) *DescribeRDDomainConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeRDDomainConfigRequest) SetFunctionName(v string) *DescribeRDDomainConfigRequest {
	s.FunctionName = &v
	return s
}

type DescribeRDDomainConfigResponseBody struct {
	// The configuration of the domain name.
	DomainConfigs []*DescribeRDDomainConfigResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRDDomainConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainConfigResponseBody) SetDomainConfigs(v []*DescribeRDDomainConfigResponseBodyDomainConfigs) *DescribeRDDomainConfigResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeRDDomainConfigResponseBody) SetRequestId(v string) *DescribeRDDomainConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRDDomainConfigResponseBodyDomainConfigs struct {
	// The ID of the configuration.
	ConfigId *int64 `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The configurations of the features.
	FunctionArgs []*DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Repeated"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The ID of the advanced condition configuration.
	ParentId *string `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The status. Valid values:
	//
	// *   **success**
	// *   **testing**
	// *   **failed**
	// *   **configuring**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeRDDomainConfigResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainConfigResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainConfigResponseBodyDomainConfigs) SetConfigId(v int64) *DescribeRDDomainConfigResponseBodyDomainConfigs {
	s.ConfigId = &v
	return s
}

func (s *DescribeRDDomainConfigResponseBodyDomainConfigs) SetFunctionArgs(v []*DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs) *DescribeRDDomainConfigResponseBodyDomainConfigs {
	s.FunctionArgs = v
	return s
}

func (s *DescribeRDDomainConfigResponseBodyDomainConfigs) SetFunctionName(v string) *DescribeRDDomainConfigResponseBodyDomainConfigs {
	s.FunctionName = &v
	return s
}

func (s *DescribeRDDomainConfigResponseBodyDomainConfigs) SetParentId(v string) *DescribeRDDomainConfigResponseBodyDomainConfigs {
	s.ParentId = &v
	return s
}

func (s *DescribeRDDomainConfigResponseBodyDomainConfigs) SetStatus(v string) *DescribeRDDomainConfigResponseBodyDomainConfigs {
	s.Status = &v
	return s
}

type DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs struct {
	// The name of the configuration.
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The value of the configuration.
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs) SetArgName(v string) *DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs {
	s.ArgName = &v
	return s
}

func (s *DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs) SetArgValue(v string) *DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs {
	s.ArgValue = &v
	return s
}

type DescribeRDDomainConfigResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRDDomainConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRDDomainConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainConfigResponse) SetHeaders(v map[string]*string) *DescribeRDDomainConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeRDDomainConfigResponse) SetStatusCode(v int32) *DescribeRDDomainConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRDDomainConfigResponse) SetBody(v *DescribeRDDomainConfigResponseBody) *DescribeRDDomainConfigResponse {
	s.Body = v
	return s
}

type DescribeRDDomainsRequest struct {
	// The number of the page to return. Valid values: 1 to 100000.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. The default value is 20. Valid values: an integer between 1 and 500. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeRDDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainsRequest) SetPageNumber(v int32) *DescribeRDDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRDDomainsRequest) SetPageSize(v int32) *DescribeRDDomainsRequest {
	s.PageSize = &v
	return s
}

type DescribeRDDomainsResponseBody struct {
	// The status information about the accelerated domain name.
	Domains *DescribeRDDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRDDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainsResponseBody) SetDomains(v *DescribeRDDomainsResponseBodyDomains) *DescribeRDDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeRDDomainsResponseBody) SetPageNumber(v int64) *DescribeRDDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRDDomainsResponseBody) SetPageSize(v int64) *DescribeRDDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRDDomainsResponseBody) SetRequestId(v string) *DescribeRDDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRDDomainsResponseBody) SetTotalCount(v int64) *DescribeRDDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRDDomainsResponseBodyDomains struct {
	PageData []*DescribeRDDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeRDDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainsResponseBodyDomains) SetPageData(v []*DescribeRDDomainsResponseBodyDomainsPageData) *DescribeRDDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeRDDomainsResponseBodyDomainsPageData struct {
	BizName *string `json:"BizName,omitempty" xml:"BizName,omitempty"`
	// The CNAME assigned to the accelerated domain name.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The reason why the accelerated domain name failed the review.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the accelerated domain name. Valid values:
	//
	// *   online: The domain name is enabled.
	// *   offline: The domain name is disabled.
	// *   configuring: The domain name is being configured.
	// *   configure_failed: The domain name failed to be configured.
	// *   checking: The domain name is being reviewed.
	// *   check_failed: The domain name failed the review.
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the accelerated domain name was added to DCDN.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The time when the accelerated domain name was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the accelerated domain name was in a sandbox.
	Sandbox     *string `json:"Sandbox,omitempty" xml:"Sandbox,omitempty"`
	ServiceCode *string `json:"ServiceCode,omitempty" xml:"ServiceCode,omitempty"`
	// The information about the origin server.
	Sources *DescribeRDDomainsResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// Indicates whether HTTPS is enabled.
	//
	// *   on
	// *   off
	SslProtocol *string `json:"SslProtocol,omitempty" xml:"SslProtocol,omitempty"`
}

func (s DescribeRDDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetBizName(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.BizName = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetCname(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetDescription(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetResourceGroupId(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetSandbox(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.Sandbox = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetServiceCode(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.ServiceCode = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetSources(v *DescribeRDDomainsResponseBodyDomainsPageDataSources) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageData) SetSslProtocol(v string) *DescribeRDDomainsResponseBodyDomainsPageData {
	s.SslProtocol = &v
	return s
}

type DescribeRDDomainsResponseBodyDomainsPageDataSources struct {
	Source []*DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeRDDomainsResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainsResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainsResponseBodyDomainsPageDataSources) SetSource(v []*DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) *DescribeRDDomainsResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource struct {
	// The address of the origin server.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The port of the origin server.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The origin server weight if multiple origin servers have been specified.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource) SetWeight(v string) *DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Weight = &v
	return s
}

type DescribeRDDomainsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRDDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRDDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRDDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRDDomainsResponse) SetHeaders(v map[string]*string) *DescribeRDDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRDDomainsResponse) SetStatusCode(v int32) *DescribeRDDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRDDomainsResponse) SetBody(v *DescribeRDDomainsResponseBody) *DescribeRDDomainsResponse {
	s.Body = v
	return s
}

type DescribeRoutineRequest struct {
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeRoutineRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineRequest) GoString() string {
	return s.String()
}

func (s *DescribeRoutineRequest) SetName(v string) *DescribeRoutineRequest {
	s.Name = &v
	return s
}

type DescribeRoutineResponseBody struct {
	// The metadata of the routine. The following table describes the fields.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRoutineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRoutineResponseBody) SetContent(v map[string]interface{}) *DescribeRoutineResponseBody {
	s.Content = v
	return s
}

func (s *DescribeRoutineResponseBody) SetRequestId(v string) *DescribeRoutineResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRoutineResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRoutineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRoutineResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineResponse) GoString() string {
	return s.String()
}

func (s *DescribeRoutineResponse) SetHeaders(v map[string]*string) *DescribeRoutineResponse {
	s.Headers = v
	return s
}

func (s *DescribeRoutineResponse) SetStatusCode(v int32) *DescribeRoutineResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRoutineResponse) SetBody(v *DescribeRoutineResponseBody) *DescribeRoutineResponse {
	s.Body = v
	return s
}

type DescribeRoutineCanaryEnvsResponseBody struct {
	// The canary release environments that are supported.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRoutineCanaryEnvsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineCanaryEnvsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRoutineCanaryEnvsResponseBody) SetContent(v map[string]interface{}) *DescribeRoutineCanaryEnvsResponseBody {
	s.Content = v
	return s
}

func (s *DescribeRoutineCanaryEnvsResponseBody) SetRequestId(v string) *DescribeRoutineCanaryEnvsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRoutineCanaryEnvsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRoutineCanaryEnvsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRoutineCanaryEnvsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineCanaryEnvsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRoutineCanaryEnvsResponse) SetHeaders(v map[string]*string) *DescribeRoutineCanaryEnvsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRoutineCanaryEnvsResponse) SetStatusCode(v int32) *DescribeRoutineCanaryEnvsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRoutineCanaryEnvsResponse) SetBody(v *DescribeRoutineCanaryEnvsResponseBody) *DescribeRoutineCanaryEnvsResponse {
	s.Body = v
	return s
}

type DescribeRoutineCodeRevisionRequest struct {
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The version of the JavaScript code that you want to query.
	SelectCodeRevision *string `json:"SelectCodeRevision,omitempty" xml:"SelectCodeRevision,omitempty"`
}

func (s DescribeRoutineCodeRevisionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineCodeRevisionRequest) GoString() string {
	return s.String()
}

func (s *DescribeRoutineCodeRevisionRequest) SetName(v string) *DescribeRoutineCodeRevisionRequest {
	s.Name = &v
	return s
}

func (s *DescribeRoutineCodeRevisionRequest) SetSelectCodeRevision(v string) *DescribeRoutineCodeRevisionRequest {
	s.SelectCodeRevision = &v
	return s
}

type DescribeRoutineCodeRevisionResponseBody struct {
	// The information about the JavaScript code version.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRoutineCodeRevisionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineCodeRevisionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRoutineCodeRevisionResponseBody) SetContent(v map[string]interface{}) *DescribeRoutineCodeRevisionResponseBody {
	s.Content = v
	return s
}

func (s *DescribeRoutineCodeRevisionResponseBody) SetRequestId(v string) *DescribeRoutineCodeRevisionResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRoutineCodeRevisionResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRoutineCodeRevisionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRoutineCodeRevisionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineCodeRevisionResponse) GoString() string {
	return s.String()
}

func (s *DescribeRoutineCodeRevisionResponse) SetHeaders(v map[string]*string) *DescribeRoutineCodeRevisionResponse {
	s.Headers = v
	return s
}

func (s *DescribeRoutineCodeRevisionResponse) SetStatusCode(v int32) *DescribeRoutineCodeRevisionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRoutineCodeRevisionResponse) SetBody(v *DescribeRoutineCodeRevisionResponseBody) *DescribeRoutineCodeRevisionResponse {
	s.Body = v
	return s
}

type DescribeRoutineRelatedDomainsRequest struct {
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeRoutineRelatedDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineRelatedDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRoutineRelatedDomainsRequest) SetName(v string) *DescribeRoutineRelatedDomainsRequest {
	s.Name = &v
	return s
}

type DescribeRoutineRelatedDomainsResponseBody struct {
	Content   map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	RequestId *string                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRoutineRelatedDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineRelatedDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRoutineRelatedDomainsResponseBody) SetContent(v map[string]interface{}) *DescribeRoutineRelatedDomainsResponseBody {
	s.Content = v
	return s
}

func (s *DescribeRoutineRelatedDomainsResponseBody) SetRequestId(v string) *DescribeRoutineRelatedDomainsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRoutineRelatedDomainsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRoutineRelatedDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRoutineRelatedDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineRelatedDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRoutineRelatedDomainsResponse) SetHeaders(v map[string]*string) *DescribeRoutineRelatedDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRoutineRelatedDomainsResponse) SetStatusCode(v int32) *DescribeRoutineRelatedDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRoutineRelatedDomainsResponse) SetBody(v *DescribeRoutineRelatedDomainsResponseBody) *DescribeRoutineRelatedDomainsResponse {
	s.Body = v
	return s
}

type DescribeRoutineSpecResponseBody struct {
	// The specification of the CPU time slice. Valid values: 5 ms, 50 ms, and 100 ms.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRoutineSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineSpecResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRoutineSpecResponseBody) SetContent(v map[string]interface{}) *DescribeRoutineSpecResponseBody {
	s.Content = v
	return s
}

func (s *DescribeRoutineSpecResponseBody) SetRequestId(v string) *DescribeRoutineSpecResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRoutineSpecResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRoutineSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRoutineSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineSpecResponse) GoString() string {
	return s.String()
}

func (s *DescribeRoutineSpecResponse) SetHeaders(v map[string]*string) *DescribeRoutineSpecResponse {
	s.Headers = v
	return s
}

func (s *DescribeRoutineSpecResponse) SetStatusCode(v int32) *DescribeRoutineSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRoutineSpecResponse) SetBody(v *DescribeRoutineSpecResponseBody) *DescribeRoutineSpecResponse {
	s.Body = v
	return s
}

type DescribeRoutineUserInfoResponseBody struct {
	// The ID of the request.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeRoutineUserInfo**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRoutineUserInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineUserInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRoutineUserInfoResponseBody) SetContent(v map[string]interface{}) *DescribeRoutineUserInfoResponseBody {
	s.Content = v
	return s
}

func (s *DescribeRoutineUserInfoResponseBody) SetRequestId(v string) *DescribeRoutineUserInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRoutineUserInfoResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRoutineUserInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRoutineUserInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRoutineUserInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeRoutineUserInfoResponse) SetHeaders(v map[string]*string) *DescribeRoutineUserInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeRoutineUserInfoResponse) SetStatusCode(v int32) *DescribeRoutineUserInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRoutineUserInfoResponse) SetBody(v *DescribeRoutineUserInfoResponseBody) *DescribeRoutineUserInfoResponse {
	s.Body = v
	return s
}

type DescribeUserDcdnIpaStatusRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeUserDcdnIpaStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDcdnIpaStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserDcdnIpaStatusRequest) SetOwnerId(v int64) *DescribeUserDcdnIpaStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeUserDcdnIpaStatusRequest) SetSecurityToken(v string) *DescribeUserDcdnIpaStatusRequest {
	s.SecurityToken = &v
	return s
}

type DescribeUserDcdnIpaStatusResponseBody struct {
	// Indicates whether the IPA service is activated.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether you have overdue payments.
	InDebt *bool `json:"InDebt,omitempty" xml:"InDebt,omitempty"`
	// Indicates whether the grace period for your overdue payments expired.
	InDebtOverdue *bool `json:"InDebtOverdue,omitempty" xml:"InDebtOverdue,omitempty"`
	// Indicates whether the IPA service is available. The IPA service is available when no payment is overdue.
	OnService *bool `json:"OnService,omitempty" xml:"OnService,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserDcdnIpaStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDcdnIpaStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserDcdnIpaStatusResponseBody) SetEnabled(v bool) *DescribeUserDcdnIpaStatusResponseBody {
	s.Enabled = &v
	return s
}

func (s *DescribeUserDcdnIpaStatusResponseBody) SetInDebt(v bool) *DescribeUserDcdnIpaStatusResponseBody {
	s.InDebt = &v
	return s
}

func (s *DescribeUserDcdnIpaStatusResponseBody) SetInDebtOverdue(v bool) *DescribeUserDcdnIpaStatusResponseBody {
	s.InDebtOverdue = &v
	return s
}

func (s *DescribeUserDcdnIpaStatusResponseBody) SetOnService(v bool) *DescribeUserDcdnIpaStatusResponseBody {
	s.OnService = &v
	return s
}

func (s *DescribeUserDcdnIpaStatusResponseBody) SetRequestId(v string) *DescribeUserDcdnIpaStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserDcdnIpaStatusResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserDcdnIpaStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserDcdnIpaStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDcdnIpaStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserDcdnIpaStatusResponse) SetHeaders(v map[string]*string) *DescribeUserDcdnIpaStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserDcdnIpaStatusResponse) SetStatusCode(v int32) *DescribeUserDcdnIpaStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserDcdnIpaStatusResponse) SetBody(v *DescribeUserDcdnIpaStatusResponseBody) *DescribeUserDcdnIpaStatusResponse {
	s.Body = v
	return s
}

type DescribeUserDcdnStatusRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s DescribeUserDcdnStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDcdnStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserDcdnStatusRequest) SetOwnerId(v int64) *DescribeUserDcdnStatusRequest {
	s.OwnerId = &v
	return s
}

type DescribeUserDcdnStatusResponseBody struct {
	// Indicates whether the DCDN service is activated.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether your account has overdue payments.
	InDebt *bool `json:"InDebt,omitempty" xml:"InDebt,omitempty"`
	// Indicates whether the grace period for your overdue payments expired.
	InDebtOverdue *bool `json:"InDebtOverdue,omitempty" xml:"InDebtOverdue,omitempty"`
	// Indicates whether the service is available.
	OnService *bool `json:"OnService,omitempty" xml:"OnService,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserDcdnStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDcdnStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserDcdnStatusResponseBody) SetEnabled(v bool) *DescribeUserDcdnStatusResponseBody {
	s.Enabled = &v
	return s
}

func (s *DescribeUserDcdnStatusResponseBody) SetInDebt(v bool) *DescribeUserDcdnStatusResponseBody {
	s.InDebt = &v
	return s
}

func (s *DescribeUserDcdnStatusResponseBody) SetInDebtOverdue(v bool) *DescribeUserDcdnStatusResponseBody {
	s.InDebtOverdue = &v
	return s
}

func (s *DescribeUserDcdnStatusResponseBody) SetOnService(v bool) *DescribeUserDcdnStatusResponseBody {
	s.OnService = &v
	return s
}

func (s *DescribeUserDcdnStatusResponseBody) SetRequestId(v string) *DescribeUserDcdnStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserDcdnStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserDcdnStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserDcdnStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserDcdnStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserDcdnStatusResponse) SetHeaders(v map[string]*string) *DescribeUserDcdnStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserDcdnStatusResponse) SetStatusCode(v int32) *DescribeUserDcdnStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserDcdnStatusResponse) SetBody(v *DescribeUserDcdnStatusResponseBody) *DescribeUserDcdnStatusResponse {
	s.Body = v
	return s
}

type DescribeUserErStatusRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s DescribeUserErStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserErStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserErStatusRequest) SetOwnerId(v int64) *DescribeUserErStatusRequest {
	s.OwnerId = &v
	return s
}

type DescribeUserErStatusResponseBody struct {
	// Indicates whether ER is activated.
	//
	// *   true
	// *   false
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether ER has an overdue payment.
	//
	// *   true
	// *   false
	InDebt *bool `json:"InDebt,omitempty" xml:"InDebt,omitempty"`
	// Indicates whether an overdue payment of ER has passed the grace period.
	//
	// *   true
	// *   false
	InDebtOverdue *bool `json:"InDebtOverdue,omitempty" xml:"InDebtOverdue,omitempty"`
	// Indicates whether ER is available.
	//
	// *   true
	// *   false
	OnService *bool `json:"OnService,omitempty" xml:"OnService,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserErStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserErStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserErStatusResponseBody) SetEnabled(v bool) *DescribeUserErStatusResponseBody {
	s.Enabled = &v
	return s
}

func (s *DescribeUserErStatusResponseBody) SetInDebt(v bool) *DescribeUserErStatusResponseBody {
	s.InDebt = &v
	return s
}

func (s *DescribeUserErStatusResponseBody) SetInDebtOverdue(v bool) *DescribeUserErStatusResponseBody {
	s.InDebtOverdue = &v
	return s
}

func (s *DescribeUserErStatusResponseBody) SetOnService(v bool) *DescribeUserErStatusResponseBody {
	s.OnService = &v
	return s
}

func (s *DescribeUserErStatusResponseBody) SetRequestId(v string) *DescribeUserErStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserErStatusResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserErStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserErStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserErStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserErStatusResponse) SetHeaders(v map[string]*string) *DescribeUserErStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserErStatusResponse) SetStatusCode(v int32) *DescribeUserErStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserErStatusResponse) SetBody(v *DescribeUserErStatusResponseBody) *DescribeUserErStatusResponse {
	s.Body = v
	return s
}

type DescribeUserLogserviceStatusRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeUserLogserviceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserLogserviceStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserLogserviceStatusRequest) SetOwnerId(v int64) *DescribeUserLogserviceStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeUserLogserviceStatusRequest) SetSecurityToken(v string) *DescribeUserLogserviceStatusRequest {
	s.SecurityToken = &v
	return s
}

type DescribeUserLogserviceStatusResponseBody struct {
	// Indicates whether Log Service is activated.
	//
	// *   true
	// *   false
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether your Log Service has overdue payments.
	//
	// *   true
	// *   false
	InDebt *bool `json:"InDebt,omitempty" xml:"InDebt,omitempty"`
	// Indicates whether an overdue payment of your Log Service has passed the grace period.
	//
	// *   true
	// *   false
	InDebtOverdue *bool `json:"InDebtOverdue,omitempty" xml:"InDebtOverdue,omitempty"`
	// Indicates whether Log Service is available.
	//
	// *   true
	// *   false
	OnService *bool `json:"OnService,omitempty" xml:"OnService,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserLogserviceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserLogserviceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserLogserviceStatusResponseBody) SetEnabled(v bool) *DescribeUserLogserviceStatusResponseBody {
	s.Enabled = &v
	return s
}

func (s *DescribeUserLogserviceStatusResponseBody) SetInDebt(v bool) *DescribeUserLogserviceStatusResponseBody {
	s.InDebt = &v
	return s
}

func (s *DescribeUserLogserviceStatusResponseBody) SetInDebtOverdue(v bool) *DescribeUserLogserviceStatusResponseBody {
	s.InDebtOverdue = &v
	return s
}

func (s *DescribeUserLogserviceStatusResponseBody) SetOnService(v bool) *DescribeUserLogserviceStatusResponseBody {
	s.OnService = &v
	return s
}

func (s *DescribeUserLogserviceStatusResponseBody) SetRequestId(v string) *DescribeUserLogserviceStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserLogserviceStatusResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserLogserviceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserLogserviceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserLogserviceStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserLogserviceStatusResponse) SetHeaders(v map[string]*string) *DescribeUserLogserviceStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserLogserviceStatusResponse) SetStatusCode(v int32) *DescribeUserLogserviceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserLogserviceStatusResponse) SetBody(v *DescribeUserLogserviceStatusResponseBody) *DescribeUserLogserviceStatusResponse {
	s.Body = v
	return s
}

type EditRoutineConfRequest struct {
	// The description of the routine.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configurations of the specified environment.
	EnvConf map[string]interface{} `json:"EnvConf,omitempty" xml:"EnvConf,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s EditRoutineConfRequest) String() string {
	return tea.Prettify(s)
}

func (s EditRoutineConfRequest) GoString() string {
	return s.String()
}

func (s *EditRoutineConfRequest) SetDescription(v string) *EditRoutineConfRequest {
	s.Description = &v
	return s
}

func (s *EditRoutineConfRequest) SetEnvConf(v map[string]interface{}) *EditRoutineConfRequest {
	s.EnvConf = v
	return s
}

func (s *EditRoutineConfRequest) SetName(v string) *EditRoutineConfRequest {
	s.Name = &v
	return s
}

type EditRoutineConfShrinkRequest struct {
	// The description of the routine.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configurations of the specified environment.
	EnvConfShrink *string `json:"EnvConf,omitempty" xml:"EnvConf,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s EditRoutineConfShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s EditRoutineConfShrinkRequest) GoString() string {
	return s.String()
}

func (s *EditRoutineConfShrinkRequest) SetDescription(v string) *EditRoutineConfShrinkRequest {
	s.Description = &v
	return s
}

func (s *EditRoutineConfShrinkRequest) SetEnvConfShrink(v string) *EditRoutineConfShrinkRequest {
	s.EnvConfShrink = &v
	return s
}

func (s *EditRoutineConfShrinkRequest) SetName(v string) *EditRoutineConfShrinkRequest {
	s.Name = &v
	return s
}

type EditRoutineConfResponseBody struct {
	// The description of the execution errors and the version number of the latest environment configurations.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EditRoutineConfResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EditRoutineConfResponseBody) GoString() string {
	return s.String()
}

func (s *EditRoutineConfResponseBody) SetContent(v map[string]interface{}) *EditRoutineConfResponseBody {
	s.Content = v
	return s
}

func (s *EditRoutineConfResponseBody) SetRequestId(v string) *EditRoutineConfResponseBody {
	s.RequestId = &v
	return s
}

type EditRoutineConfResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EditRoutineConfResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EditRoutineConfResponse) String() string {
	return tea.Prettify(s)
}

func (s EditRoutineConfResponse) GoString() string {
	return s.String()
}

func (s *EditRoutineConfResponse) SetHeaders(v map[string]*string) *EditRoutineConfResponse {
	s.Headers = v
	return s
}

func (s *EditRoutineConfResponse) SetStatusCode(v int32) *EditRoutineConfResponse {
	s.StatusCode = &v
	return s
}

func (s *EditRoutineConfResponse) SetBody(v *EditRoutineConfResponseBody) *EditRoutineConfResponse {
	s.Body = v
	return s
}

type GetDcdnKvRequest struct {
	// The name of the key that you want to query.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s GetDcdnKvRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDcdnKvRequest) GoString() string {
	return s.String()
}

func (s *GetDcdnKvRequest) SetKey(v string) *GetDcdnKvRequest {
	s.Key = &v
	return s
}

func (s *GetDcdnKvRequest) SetNamespace(v string) *GetDcdnKvRequest {
	s.Namespace = &v
	return s
}

type GetDcdnKvResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The value of the key.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetDcdnKvResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDcdnKvResponseBody) GoString() string {
	return s.String()
}

func (s *GetDcdnKvResponseBody) SetRequestId(v string) *GetDcdnKvResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDcdnKvResponseBody) SetValue(v string) *GetDcdnKvResponseBody {
	s.Value = &v
	return s
}

type GetDcdnKvResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDcdnKvResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDcdnKvResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDcdnKvResponse) GoString() string {
	return s.String()
}

func (s *GetDcdnKvResponse) SetHeaders(v map[string]*string) *GetDcdnKvResponse {
	s.Headers = v
	return s
}

func (s *GetDcdnKvResponse) SetStatusCode(v int32) *GetDcdnKvResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDcdnKvResponse) SetBody(v *GetDcdnKvResponseBody) *GetDcdnKvResponse {
	s.Body = v
	return s
}

type ListDcdnKvRequest struct {
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The number of the page to return. The product of PageNumber and PageSize cannot exceed 50,000.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 50. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The prefix to query.
	Prefix *string `json:"Prefix,omitempty" xml:"Prefix,omitempty"`
}

func (s ListDcdnKvRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnKvRequest) GoString() string {
	return s.String()
}

func (s *ListDcdnKvRequest) SetNamespace(v string) *ListDcdnKvRequest {
	s.Namespace = &v
	return s
}

func (s *ListDcdnKvRequest) SetPageNumber(v int32) *ListDcdnKvRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDcdnKvRequest) SetPageSize(v int32) *ListDcdnKvRequest {
	s.PageSize = &v
	return s
}

func (s *ListDcdnKvRequest) SetPrefix(v string) *ListDcdnKvRequest {
	s.Prefix = &v
	return s
}

type ListDcdnKvResponseBody struct {
	// The keys obtained in this traversal.
	Keys []*ListDcdnKvResponseBodyKeys `json:"Keys,omitempty" xml:"Keys,omitempty" type:"Repeated"`
	// The total number of pages returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDcdnKvResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnKvResponseBody) GoString() string {
	return s.String()
}

func (s *ListDcdnKvResponseBody) SetKeys(v []*ListDcdnKvResponseBodyKeys) *ListDcdnKvResponseBody {
	s.Keys = v
	return s
}

func (s *ListDcdnKvResponseBody) SetPageNumber(v int32) *ListDcdnKvResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListDcdnKvResponseBody) SetPageSize(v int32) *ListDcdnKvResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListDcdnKvResponseBody) SetRequestId(v string) *ListDcdnKvResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDcdnKvResponseBody) SetTotalCount(v int32) *ListDcdnKvResponseBody {
	s.TotalCount = &v
	return s
}

type ListDcdnKvResponseBodyKeys struct {
	// The value of the key obtained in this traversal.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The time when the key was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ListDcdnKvResponseBodyKeys) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnKvResponseBodyKeys) GoString() string {
	return s.String()
}

func (s *ListDcdnKvResponseBodyKeys) SetName(v string) *ListDcdnKvResponseBodyKeys {
	s.Name = &v
	return s
}

func (s *ListDcdnKvResponseBodyKeys) SetUpdateTime(v string) *ListDcdnKvResponseBodyKeys {
	s.UpdateTime = &v
	return s
}

type ListDcdnKvResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDcdnKvResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDcdnKvResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnKvResponse) GoString() string {
	return s.String()
}

func (s *ListDcdnKvResponse) SetHeaders(v map[string]*string) *ListDcdnKvResponse {
	s.Headers = v
	return s
}

func (s *ListDcdnKvResponse) SetStatusCode(v int32) *ListDcdnKvResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDcdnKvResponse) SetBody(v *ListDcdnKvResponseBody) *ListDcdnKvResponse {
	s.Body = v
	return s
}

type ListDcdnRealTimeDeliveryProjectRequest struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	// *   By default, this parameter is left empty, and all logs are returned.
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The domain name. You can specify only one domain name in each request. If this parameter is not specified, all domain names are queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The number of the page to return. Valid values: **1** to **100000**. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. The default value is 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListDcdnRealTimeDeliveryProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnRealTimeDeliveryProjectRequest) GoString() string {
	return s.String()
}

func (s *ListDcdnRealTimeDeliveryProjectRequest) SetBusinessType(v string) *ListDcdnRealTimeDeliveryProjectRequest {
	s.BusinessType = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectRequest) SetDomainName(v string) *ListDcdnRealTimeDeliveryProjectRequest {
	s.DomainName = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectRequest) SetPageNumber(v int32) *ListDcdnRealTimeDeliveryProjectRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectRequest) SetPageSize(v int32) *ListDcdnRealTimeDeliveryProjectRequest {
	s.PageSize = &v
	return s
}

type ListDcdnRealTimeDeliveryProjectResponseBody struct {
	// The configuration results of the domain name.
	Content *ListDcdnRealTimeDeliveryProjectResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDcdnRealTimeDeliveryProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnRealTimeDeliveryProjectResponseBody) GoString() string {
	return s.String()
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBody) SetContent(v *ListDcdnRealTimeDeliveryProjectResponseBodyContent) *ListDcdnRealTimeDeliveryProjectResponseBody {
	s.Content = v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBody) SetRequestId(v string) *ListDcdnRealTimeDeliveryProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBody) SetTotalCount(v int32) *ListDcdnRealTimeDeliveryProjectResponseBody {
	s.TotalCount = &v
	return s
}

type ListDcdnRealTimeDeliveryProjectResponseBodyContent struct {
	Projects []*ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects `json:"Projects,omitempty" xml:"Projects,omitempty" type:"Repeated"`
}

func (s ListDcdnRealTimeDeliveryProjectResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnRealTimeDeliveryProjectResponseBodyContent) GoString() string {
	return s.String()
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContent) SetProjects(v []*ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) *ListDcdnRealTimeDeliveryProjectResponseBodyContent {
	s.Projects = v
	return s
}

type ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of DCDN POPs
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The region from which logs were collected.
	DataCenter *string `json:"DataCenter,omitempty" xml:"DataCenter,omitempty"`
	// The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](~~324199~~).
	FieldName *string `json:"FieldName,omitempty" xml:"FieldName,omitempty"`
	// The name of the project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the Logstore.
	SLSLogStore *string `json:"SLSLogStore,omitempty" xml:"SLSLogStore,omitempty"`
	// The name of the log file.
	SLSProject *string `json:"SLSProject,omitempty" xml:"SLSProject,omitempty"`
	// The region to which logs were delivered.
	SLSRegion *string `json:"SLSRegion,omitempty" xml:"SLSRegion,omitempty"`
	// The sampling rate.
	SamplingRate *float32 `json:"SamplingRate,omitempty" xml:"SamplingRate,omitempty"`
	// The type of log delivery. Only **SLS_POST** is supported.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) GoString() string {
	return s.String()
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetBusinessType(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.BusinessType = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetDataCenter(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.DataCenter = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetDomainName(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.DomainName = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetFieldName(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.FieldName = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetProjectName(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.ProjectName = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetSLSLogStore(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.SLSLogStore = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetSLSProject(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.SLSProject = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetSLSRegion(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.SLSRegion = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetSamplingRate(v float32) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.SamplingRate = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects) SetType(v string) *ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects {
	s.Type = &v
	return s
}

type ListDcdnRealTimeDeliveryProjectResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDcdnRealTimeDeliveryProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDcdnRealTimeDeliveryProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDcdnRealTimeDeliveryProjectResponse) GoString() string {
	return s.String()
}

func (s *ListDcdnRealTimeDeliveryProjectResponse) SetHeaders(v map[string]*string) *ListDcdnRealTimeDeliveryProjectResponse {
	s.Headers = v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponse) SetStatusCode(v int32) *ListDcdnRealTimeDeliveryProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDcdnRealTimeDeliveryProjectResponse) SetBody(v *ListDcdnRealTimeDeliveryProjectResponseBody) *ListDcdnRealTimeDeliveryProjectResponse {
	s.Body = v
	return s
}

type ModifyDCdnDomainSchdmByPropertyRequest struct {
	// The name of the accelerated domain for which you want to change the acceleration region. You can specify only one domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The region where the acceleration service is deployed. Valid values:
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: global (excluding mainland China)
	// *   **global**: global
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
}

func (s ModifyDCdnDomainSchdmByPropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDCdnDomainSchdmByPropertyRequest) GoString() string {
	return s.String()
}

func (s *ModifyDCdnDomainSchdmByPropertyRequest) SetDomainName(v string) *ModifyDCdnDomainSchdmByPropertyRequest {
	s.DomainName = &v
	return s
}

func (s *ModifyDCdnDomainSchdmByPropertyRequest) SetProperty(v string) *ModifyDCdnDomainSchdmByPropertyRequest {
	s.Property = &v
	return s
}

type ModifyDCdnDomainSchdmByPropertyResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDCdnDomainSchdmByPropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDCdnDomainSchdmByPropertyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDCdnDomainSchdmByPropertyResponseBody) SetRequestId(v string) *ModifyDCdnDomainSchdmByPropertyResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDCdnDomainSchdmByPropertyResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDCdnDomainSchdmByPropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDCdnDomainSchdmByPropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDCdnDomainSchdmByPropertyResponse) GoString() string {
	return s.String()
}

func (s *ModifyDCdnDomainSchdmByPropertyResponse) SetHeaders(v map[string]*string) *ModifyDCdnDomainSchdmByPropertyResponse {
	s.Headers = v
	return s
}

func (s *ModifyDCdnDomainSchdmByPropertyResponse) SetStatusCode(v int32) *ModifyDCdnDomainSchdmByPropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDCdnDomainSchdmByPropertyResponse) SetBody(v *ModifyDCdnDomainSchdmByPropertyResponseBody) *ModifyDCdnDomainSchdmByPropertyResponse {
	s.Body = v
	return s
}

type ModifyDcdnWafGroupRequest struct {
	// The ID of the custom WAF rule group.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the custom WAF rule group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The incremental modification of the rules in the custom WAF rule group. The value is a string in the JSON format.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s ModifyDcdnWafGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafGroupRequest) SetId(v int64) *ModifyDcdnWafGroupRequest {
	s.Id = &v
	return s
}

func (s *ModifyDcdnWafGroupRequest) SetName(v string) *ModifyDcdnWafGroupRequest {
	s.Name = &v
	return s
}

func (s *ModifyDcdnWafGroupRequest) SetRules(v string) *ModifyDcdnWafGroupRequest {
	s.Rules = &v
	return s
}

type ModifyDcdnWafGroupResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDcdnWafGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafGroupResponseBody) SetRequestId(v string) *ModifyDcdnWafGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDcdnWafGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDcdnWafGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDcdnWafGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafGroupResponse) SetHeaders(v map[string]*string) *ModifyDcdnWafGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyDcdnWafGroupResponse) SetStatusCode(v int32) *ModifyDcdnWafGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDcdnWafGroupResponse) SetBody(v *ModifyDcdnWafGroupResponseBody) *ModifyDcdnWafGroupResponse {
	s.Body = v
	return s
}

type ModifyDcdnWafPolicyRequest struct {
	// The ID of the protection policy that you want to modify. You can specify only one ID in each request.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The new name of the protection policy.
	//
	// > You must specify PolicyName or PolicyStatus.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The new status of the protection policy. Valid values:
	//
	// *   **on**
	// *   **off**
	//
	// > You must specify PolicyName or PolicyStatus.
	PolicyStatus *string `json:"PolicyStatus,omitempty" xml:"PolicyStatus,omitempty"`
}

func (s ModifyDcdnWafPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafPolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafPolicyRequest) SetPolicyId(v int64) *ModifyDcdnWafPolicyRequest {
	s.PolicyId = &v
	return s
}

func (s *ModifyDcdnWafPolicyRequest) SetPolicyName(v string) *ModifyDcdnWafPolicyRequest {
	s.PolicyName = &v
	return s
}

func (s *ModifyDcdnWafPolicyRequest) SetPolicyStatus(v string) *ModifyDcdnWafPolicyRequest {
	s.PolicyStatus = &v
	return s
}

type ModifyDcdnWafPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDcdnWafPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafPolicyResponseBody) SetRequestId(v string) *ModifyDcdnWafPolicyResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDcdnWafPolicyResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDcdnWafPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDcdnWafPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafPolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafPolicyResponse) SetHeaders(v map[string]*string) *ModifyDcdnWafPolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifyDcdnWafPolicyResponse) SetStatusCode(v int32) *ModifyDcdnWafPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDcdnWafPolicyResponse) SetBody(v *ModifyDcdnWafPolicyResponseBody) *ModifyDcdnWafPolicyResponse {
	s.Body = v
	return s
}

type ModifyDcdnWafPolicyDomainsRequest struct {
	// The domain names that you want to bind to the protection policy. You can specify up to 50 domain names. Separate multiple domain names with commas (,).
	//
	// > You can configure either **BindDomains** or **UnbindDomains**.
	BindDomains *string `json:"BindDomains,omitempty" xml:"BindDomains,omitempty"`
	// The association method. Valid values:
	//
	// *   0: replace.
	// *   1: add.
	// *   Default value: 0.
	//
	// >
	//
	// *   This parameter takes effect only when you specify **BindDomains**. If you have associated a domain name indicated by **BindDomains** with the default protection policy, the `Policy.DefaultAndCustom.BindToSameDomain` error is returned.
	//
	// *   You can only replace accelerated domain names that are bound to the default protection policy.
	Method *int32 `json:"Method,omitempty" xml:"Method,omitempty"`
	// The ID of the protection policy. You can specify only one ID in each request.
	PolicyId *int64 `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The domain names that you want to unbind from the protection policy. You can specify up to 50 domain names. Separate multiple domain names with commas (,).
	//
	// > You can configure either **BindDomains** or **UnbindDomains**.
	UnbindDomains *string `json:"UnbindDomains,omitempty" xml:"UnbindDomains,omitempty"`
}

func (s ModifyDcdnWafPolicyDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafPolicyDomainsRequest) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafPolicyDomainsRequest) SetBindDomains(v string) *ModifyDcdnWafPolicyDomainsRequest {
	s.BindDomains = &v
	return s
}

func (s *ModifyDcdnWafPolicyDomainsRequest) SetMethod(v int32) *ModifyDcdnWafPolicyDomainsRequest {
	s.Method = &v
	return s
}

func (s *ModifyDcdnWafPolicyDomainsRequest) SetPolicyId(v int64) *ModifyDcdnWafPolicyDomainsRequest {
	s.PolicyId = &v
	return s
}

func (s *ModifyDcdnWafPolicyDomainsRequest) SetUnbindDomains(v string) *ModifyDcdnWafPolicyDomainsRequest {
	s.UnbindDomains = &v
	return s
}

type ModifyDcdnWafPolicyDomainsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDcdnWafPolicyDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafPolicyDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafPolicyDomainsResponseBody) SetRequestId(v string) *ModifyDcdnWafPolicyDomainsResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDcdnWafPolicyDomainsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDcdnWafPolicyDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDcdnWafPolicyDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafPolicyDomainsResponse) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafPolicyDomainsResponse) SetHeaders(v map[string]*string) *ModifyDcdnWafPolicyDomainsResponse {
	s.Headers = v
	return s
}

func (s *ModifyDcdnWafPolicyDomainsResponse) SetStatusCode(v int32) *ModifyDcdnWafPolicyDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDcdnWafPolicyDomainsResponse) SetBody(v *ModifyDcdnWafPolicyDomainsResponseBody) *ModifyDcdnWafPolicyDomainsResponse {
	s.Body = v
	return s
}

type ModifyDcdnWafRuleRequest struct {
	// The new configurations of the protection rule.
	//
	// > After you modify the configurations of the protection rule, the previous configurations are overwritten.
	RuleConfig *string `json:"RuleConfig,omitempty" xml:"RuleConfig,omitempty"`
	// The ID of the protection rule. You can specify only one ID in each request.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The new name of the protection rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The new status of the protection rule. Valid values:
	//
	// *   **on**
	// *   **off**
	RuleStatus *string `json:"RuleStatus,omitempty" xml:"RuleStatus,omitempty"`
}

func (s ModifyDcdnWafRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafRuleRequest) SetRuleConfig(v string) *ModifyDcdnWafRuleRequest {
	s.RuleConfig = &v
	return s
}

func (s *ModifyDcdnWafRuleRequest) SetRuleId(v int64) *ModifyDcdnWafRuleRequest {
	s.RuleId = &v
	return s
}

func (s *ModifyDcdnWafRuleRequest) SetRuleName(v string) *ModifyDcdnWafRuleRequest {
	s.RuleName = &v
	return s
}

func (s *ModifyDcdnWafRuleRequest) SetRuleStatus(v string) *ModifyDcdnWafRuleRequest {
	s.RuleStatus = &v
	return s
}

type ModifyDcdnWafRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDcdnWafRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafRuleResponseBody) SetRequestId(v string) *ModifyDcdnWafRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDcdnWafRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDcdnWafRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDcdnWafRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDcdnWafRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyDcdnWafRuleResponse) SetHeaders(v map[string]*string) *ModifyDcdnWafRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyDcdnWafRuleResponse) SetStatusCode(v int32) *ModifyDcdnWafRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDcdnWafRuleResponse) SetBody(v *ModifyDcdnWafRuleResponseBody) *ModifyDcdnWafRuleResponse {
	s.Body = v
	return s
}

type OpenDcdnServiceRequest struct {
	// The metering method of DCDN. Valid values:
	//
	// *   **PayByTraffic**: pay-by-traffic
	// *   **PayByBandwidth**: pay-by-bandwidth
	BillType      *string `json:"BillType,omitempty" xml:"BillType,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The metering method of WebSocket. Valid values:
	//
	// *   **websockettraffic**: pay-by-data-transfer
	// *   **websocketbps**: pay-by-bandwidth
	WebsocketBillType *string `json:"WebsocketBillType,omitempty" xml:"WebsocketBillType,omitempty"`
}

func (s OpenDcdnServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenDcdnServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenDcdnServiceRequest) SetBillType(v string) *OpenDcdnServiceRequest {
	s.BillType = &v
	return s
}

func (s *OpenDcdnServiceRequest) SetOwnerId(v int64) *OpenDcdnServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *OpenDcdnServiceRequest) SetSecurityToken(v string) *OpenDcdnServiceRequest {
	s.SecurityToken = &v
	return s
}

func (s *OpenDcdnServiceRequest) SetWebsocketBillType(v string) *OpenDcdnServiceRequest {
	s.WebsocketBillType = &v
	return s
}

type OpenDcdnServiceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenDcdnServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenDcdnServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenDcdnServiceResponseBody) SetRequestId(v string) *OpenDcdnServiceResponseBody {
	s.RequestId = &v
	return s
}

type OpenDcdnServiceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenDcdnServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenDcdnServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenDcdnServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenDcdnServiceResponse) SetHeaders(v map[string]*string) *OpenDcdnServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenDcdnServiceResponse) SetStatusCode(v int32) *OpenDcdnServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenDcdnServiceResponse) SetBody(v *OpenDcdnServiceResponseBody) *OpenDcdnServiceResponse {
	s.Body = v
	return s
}

type PreloadDcdnObjectCachesRequest struct {
	// The acceleration region in which you want to prefetch content. If you do not specify a region, the value overseas is used.
	//
	// *   **domestic**: Chinese mainland
	// *   **overseas**: outside the Chinese mainland
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// Specifies whether to prefetch content to POPs. Valid values:
	//
	// *   **true**: prefetches content to nodes that include L2 DCDN nodes.
	// *   **false**: prefetches content to L2 POPs or L3 POPs.
	L2Preload *bool `json:"L2Preload,omitempty" xml:"L2Preload,omitempty"`
	// The path of the content that you want to prefetch. Separate multiple URLs with line feed characters (\n) or a pair of carriage return and line feed characters (\r\n).
	ObjectPath    *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The custom header for prefetch in the JSON format.
	WithHeader *string `json:"WithHeader,omitempty" xml:"WithHeader,omitempty"`
}

func (s PreloadDcdnObjectCachesRequest) String() string {
	return tea.Prettify(s)
}

func (s PreloadDcdnObjectCachesRequest) GoString() string {
	return s.String()
}

func (s *PreloadDcdnObjectCachesRequest) SetArea(v string) *PreloadDcdnObjectCachesRequest {
	s.Area = &v
	return s
}

func (s *PreloadDcdnObjectCachesRequest) SetL2Preload(v bool) *PreloadDcdnObjectCachesRequest {
	s.L2Preload = &v
	return s
}

func (s *PreloadDcdnObjectCachesRequest) SetObjectPath(v string) *PreloadDcdnObjectCachesRequest {
	s.ObjectPath = &v
	return s
}

func (s *PreloadDcdnObjectCachesRequest) SetOwnerId(v int64) *PreloadDcdnObjectCachesRequest {
	s.OwnerId = &v
	return s
}

func (s *PreloadDcdnObjectCachesRequest) SetSecurityToken(v string) *PreloadDcdnObjectCachesRequest {
	s.SecurityToken = &v
	return s
}

func (s *PreloadDcdnObjectCachesRequest) SetWithHeader(v string) *PreloadDcdnObjectCachesRequest {
	s.WithHeader = &v
	return s
}

type PreloadDcdnObjectCachesResponseBody struct {
	// The ID of the prefetch task. Multiple IDs are separated by commas (,).
	PreloadTaskId *string `json:"PreloadTaskId,omitempty" xml:"PreloadTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PreloadDcdnObjectCachesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PreloadDcdnObjectCachesResponseBody) GoString() string {
	return s.String()
}

func (s *PreloadDcdnObjectCachesResponseBody) SetPreloadTaskId(v string) *PreloadDcdnObjectCachesResponseBody {
	s.PreloadTaskId = &v
	return s
}

func (s *PreloadDcdnObjectCachesResponseBody) SetRequestId(v string) *PreloadDcdnObjectCachesResponseBody {
	s.RequestId = &v
	return s
}

type PreloadDcdnObjectCachesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PreloadDcdnObjectCachesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PreloadDcdnObjectCachesResponse) String() string {
	return tea.Prettify(s)
}

func (s PreloadDcdnObjectCachesResponse) GoString() string {
	return s.String()
}

func (s *PreloadDcdnObjectCachesResponse) SetHeaders(v map[string]*string) *PreloadDcdnObjectCachesResponse {
	s.Headers = v
	return s
}

func (s *PreloadDcdnObjectCachesResponse) SetStatusCode(v int32) *PreloadDcdnObjectCachesResponse {
	s.StatusCode = &v
	return s
}

func (s *PreloadDcdnObjectCachesResponse) SetBody(v *PreloadDcdnObjectCachesResponseBody) *PreloadDcdnObjectCachesResponse {
	s.Body = v
	return s
}

type PublishDcdnStagingConfigToProductionRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the feature.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
}

func (s PublishDcdnStagingConfigToProductionRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishDcdnStagingConfigToProductionRequest) GoString() string {
	return s.String()
}

func (s *PublishDcdnStagingConfigToProductionRequest) SetDomainName(v string) *PublishDcdnStagingConfigToProductionRequest {
	s.DomainName = &v
	return s
}

func (s *PublishDcdnStagingConfigToProductionRequest) SetFunctionName(v string) *PublishDcdnStagingConfigToProductionRequest {
	s.FunctionName = &v
	return s
}

type PublishDcdnStagingConfigToProductionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PublishDcdnStagingConfigToProductionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishDcdnStagingConfigToProductionResponseBody) GoString() string {
	return s.String()
}

func (s *PublishDcdnStagingConfigToProductionResponseBody) SetRequestId(v string) *PublishDcdnStagingConfigToProductionResponseBody {
	s.RequestId = &v
	return s
}

type PublishDcdnStagingConfigToProductionResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishDcdnStagingConfigToProductionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishDcdnStagingConfigToProductionResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishDcdnStagingConfigToProductionResponse) GoString() string {
	return s.String()
}

func (s *PublishDcdnStagingConfigToProductionResponse) SetHeaders(v map[string]*string) *PublishDcdnStagingConfigToProductionResponse {
	s.Headers = v
	return s
}

func (s *PublishDcdnStagingConfigToProductionResponse) SetStatusCode(v int32) *PublishDcdnStagingConfigToProductionResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishDcdnStagingConfigToProductionResponse) SetBody(v *PublishDcdnStagingConfigToProductionResponseBody) *PublishDcdnStagingConfigToProductionResponse {
	s.Body = v
	return s
}

type PublishRoutineCodeRevisionRequest struct {
	// The environment to which you want to publish the code.
	//
	// >
	//
	// *   production: the name of the environment, including the environment name (SpecName) and the domain name whitelist (AllowedHosts).
	//
	// *   presetCanary: You can add canary release environments based on your business requirements. This parameter is optional.
	Envs map[string]interface{} `json:"Envs,omitempty" xml:"Envs,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The version of the routine code that you want to publish.
	SelectCodeRevision *string `json:"SelectCodeRevision,omitempty" xml:"SelectCodeRevision,omitempty"`
}

func (s PublishRoutineCodeRevisionRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishRoutineCodeRevisionRequest) GoString() string {
	return s.String()
}

func (s *PublishRoutineCodeRevisionRequest) SetEnvs(v map[string]interface{}) *PublishRoutineCodeRevisionRequest {
	s.Envs = v
	return s
}

func (s *PublishRoutineCodeRevisionRequest) SetName(v string) *PublishRoutineCodeRevisionRequest {
	s.Name = &v
	return s
}

func (s *PublishRoutineCodeRevisionRequest) SetSelectCodeRevision(v string) *PublishRoutineCodeRevisionRequest {
	s.SelectCodeRevision = &v
	return s
}

type PublishRoutineCodeRevisionShrinkRequest struct {
	// The environment to which you want to publish the code.
	//
	// >
	//
	// *   production: the name of the environment, including the environment name (SpecName) and the domain name whitelist (AllowedHosts).
	//
	// *   presetCanary: You can add canary release environments based on your business requirements. This parameter is optional.
	EnvsShrink *string `json:"Envs,omitempty" xml:"Envs,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The version of the routine code that you want to publish.
	SelectCodeRevision *string `json:"SelectCodeRevision,omitempty" xml:"SelectCodeRevision,omitempty"`
}

func (s PublishRoutineCodeRevisionShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishRoutineCodeRevisionShrinkRequest) GoString() string {
	return s.String()
}

func (s *PublishRoutineCodeRevisionShrinkRequest) SetEnvsShrink(v string) *PublishRoutineCodeRevisionShrinkRequest {
	s.EnvsShrink = &v
	return s
}

func (s *PublishRoutineCodeRevisionShrinkRequest) SetName(v string) *PublishRoutineCodeRevisionShrinkRequest {
	s.Name = &v
	return s
}

func (s *PublishRoutineCodeRevisionShrinkRequest) SetSelectCodeRevision(v string) *PublishRoutineCodeRevisionShrinkRequest {
	s.SelectCodeRevision = &v
	return s
}

type PublishRoutineCodeRevisionResponseBody struct {
	// The version of the routine code that is published to the specified environment.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PublishRoutineCodeRevisionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishRoutineCodeRevisionResponseBody) GoString() string {
	return s.String()
}

func (s *PublishRoutineCodeRevisionResponseBody) SetContent(v map[string]interface{}) *PublishRoutineCodeRevisionResponseBody {
	s.Content = v
	return s
}

func (s *PublishRoutineCodeRevisionResponseBody) SetRequestId(v string) *PublishRoutineCodeRevisionResponseBody {
	s.RequestId = &v
	return s
}

type PublishRoutineCodeRevisionResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishRoutineCodeRevisionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishRoutineCodeRevisionResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishRoutineCodeRevisionResponse) GoString() string {
	return s.String()
}

func (s *PublishRoutineCodeRevisionResponse) SetHeaders(v map[string]*string) *PublishRoutineCodeRevisionResponse {
	s.Headers = v
	return s
}

func (s *PublishRoutineCodeRevisionResponse) SetStatusCode(v int32) *PublishRoutineCodeRevisionResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishRoutineCodeRevisionResponse) SetBody(v *PublishRoutineCodeRevisionResponseBody) *PublishRoutineCodeRevisionResponse {
	s.Body = v
	return s
}

type PutDcdnKvRequest struct {
	// The time when the key expires.Example: "1690081381".
	Expiration *int64 `json:"Expiration,omitempty" xml:"Expiration,omitempty"`
	// The time when the key expires.Example: "3600".
	ExpirationTtl *int64 `json:"ExpirationTtl,omitempty" xml:"ExpirationTtl,omitempty"`
	// The key. The key can be up to 512 characters in length, and cannot contain spaces.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The value of the key. The maximum size is 2 MB (2 x 1000 x 1000 bytes).
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s PutDcdnKvRequest) String() string {
	return tea.Prettify(s)
}

func (s PutDcdnKvRequest) GoString() string {
	return s.String()
}

func (s *PutDcdnKvRequest) SetExpiration(v int64) *PutDcdnKvRequest {
	s.Expiration = &v
	return s
}

func (s *PutDcdnKvRequest) SetExpirationTtl(v int64) *PutDcdnKvRequest {
	s.ExpirationTtl = &v
	return s
}

func (s *PutDcdnKvRequest) SetKey(v string) *PutDcdnKvRequest {
	s.Key = &v
	return s
}

func (s *PutDcdnKvRequest) SetNamespace(v string) *PutDcdnKvRequest {
	s.Namespace = &v
	return s
}

func (s *PutDcdnKvRequest) SetValue(v string) *PutDcdnKvRequest {
	s.Value = &v
	return s
}

type PutDcdnKvResponseBody struct {
	// The length of the key.
	Length *int32 `json:"Length,omitempty" xml:"Length,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The value of the key. If the value exceeds 256 characters in length, the first 100 characters and the last 100 characters are retained and other characters are not displayed.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s PutDcdnKvResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PutDcdnKvResponseBody) GoString() string {
	return s.String()
}

func (s *PutDcdnKvResponseBody) SetLength(v int32) *PutDcdnKvResponseBody {
	s.Length = &v
	return s
}

func (s *PutDcdnKvResponseBody) SetRequestId(v string) *PutDcdnKvResponseBody {
	s.RequestId = &v
	return s
}

func (s *PutDcdnKvResponseBody) SetValue(v string) *PutDcdnKvResponseBody {
	s.Value = &v
	return s
}

type PutDcdnKvResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PutDcdnKvResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PutDcdnKvResponse) String() string {
	return tea.Prettify(s)
}

func (s PutDcdnKvResponse) GoString() string {
	return s.String()
}

func (s *PutDcdnKvResponse) SetHeaders(v map[string]*string) *PutDcdnKvResponse {
	s.Headers = v
	return s
}

func (s *PutDcdnKvResponse) SetStatusCode(v int32) *PutDcdnKvResponse {
	s.StatusCode = &v
	return s
}

func (s *PutDcdnKvResponse) SetBody(v *PutDcdnKvResponseBody) *PutDcdnKvResponse {
	s.Body = v
	return s
}

type PutDcdnKvNamespaceRequest struct {
	// The description of the namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the namespace. The name can contain letters, digits, hyphens (-), and underscores (\_).
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s PutDcdnKvNamespaceRequest) String() string {
	return tea.Prettify(s)
}

func (s PutDcdnKvNamespaceRequest) GoString() string {
	return s.String()
}

func (s *PutDcdnKvNamespaceRequest) SetDescription(v string) *PutDcdnKvNamespaceRequest {
	s.Description = &v
	return s
}

func (s *PutDcdnKvNamespaceRequest) SetNamespace(v string) *PutDcdnKvNamespaceRequest {
	s.Namespace = &v
	return s
}

type PutDcdnKvNamespaceResponseBody struct {
	// The description of the namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the namespace. Valid values:
	//
	// *   **online**: normal
	// *   **delete**: pending delete
	// *   **deleting**: being deleted
	// *   **deleted**: deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s PutDcdnKvNamespaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PutDcdnKvNamespaceResponseBody) GoString() string {
	return s.String()
}

func (s *PutDcdnKvNamespaceResponseBody) SetDescription(v string) *PutDcdnKvNamespaceResponseBody {
	s.Description = &v
	return s
}

func (s *PutDcdnKvNamespaceResponseBody) SetNamespace(v string) *PutDcdnKvNamespaceResponseBody {
	s.Namespace = &v
	return s
}

func (s *PutDcdnKvNamespaceResponseBody) SetNamespaceId(v string) *PutDcdnKvNamespaceResponseBody {
	s.NamespaceId = &v
	return s
}

func (s *PutDcdnKvNamespaceResponseBody) SetRequestId(v string) *PutDcdnKvNamespaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *PutDcdnKvNamespaceResponseBody) SetStatus(v string) *PutDcdnKvNamespaceResponseBody {
	s.Status = &v
	return s
}

type PutDcdnKvNamespaceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PutDcdnKvNamespaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PutDcdnKvNamespaceResponse) String() string {
	return tea.Prettify(s)
}

func (s PutDcdnKvNamespaceResponse) GoString() string {
	return s.String()
}

func (s *PutDcdnKvNamespaceResponse) SetHeaders(v map[string]*string) *PutDcdnKvNamespaceResponse {
	s.Headers = v
	return s
}

func (s *PutDcdnKvNamespaceResponse) SetStatusCode(v int32) *PutDcdnKvNamespaceResponse {
	s.StatusCode = &v
	return s
}

func (s *PutDcdnKvNamespaceResponse) SetBody(v *PutDcdnKvNamespaceResponseBody) *PutDcdnKvNamespaceResponse {
	s.Body = v
	return s
}

type RefreshDcdnObjectCachesRequest struct {
	// The path of the objects that you want to refresh. Separate multiple URLs with line feed characters (\n) or a pair of carriage return and line feed characters (\r\n).
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The refresh type. Valid values:
	//
	// *   **File**: URL
	// *   **Directory**: directory
	ObjectType    *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s RefreshDcdnObjectCachesRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshDcdnObjectCachesRequest) GoString() string {
	return s.String()
}

func (s *RefreshDcdnObjectCachesRequest) SetObjectPath(v string) *RefreshDcdnObjectCachesRequest {
	s.ObjectPath = &v
	return s
}

func (s *RefreshDcdnObjectCachesRequest) SetObjectType(v string) *RefreshDcdnObjectCachesRequest {
	s.ObjectType = &v
	return s
}

func (s *RefreshDcdnObjectCachesRequest) SetOwnerId(v int64) *RefreshDcdnObjectCachesRequest {
	s.OwnerId = &v
	return s
}

func (s *RefreshDcdnObjectCachesRequest) SetSecurityToken(v string) *RefreshDcdnObjectCachesRequest {
	s.SecurityToken = &v
	return s
}

type RefreshDcdnObjectCachesResponseBody struct {
	// The ID of the refresh task. Multiple IDs are separated by commas (,).
	RefreshTaskId *string `json:"RefreshTaskId,omitempty" xml:"RefreshTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RefreshDcdnObjectCachesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshDcdnObjectCachesResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshDcdnObjectCachesResponseBody) SetRefreshTaskId(v string) *RefreshDcdnObjectCachesResponseBody {
	s.RefreshTaskId = &v
	return s
}

func (s *RefreshDcdnObjectCachesResponseBody) SetRequestId(v string) *RefreshDcdnObjectCachesResponseBody {
	s.RequestId = &v
	return s
}

type RefreshDcdnObjectCachesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshDcdnObjectCachesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshDcdnObjectCachesResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshDcdnObjectCachesResponse) GoString() string {
	return s.String()
}

func (s *RefreshDcdnObjectCachesResponse) SetHeaders(v map[string]*string) *RefreshDcdnObjectCachesResponse {
	s.Headers = v
	return s
}

func (s *RefreshDcdnObjectCachesResponse) SetStatusCode(v int32) *RefreshDcdnObjectCachesResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshDcdnObjectCachesResponse) SetBody(v *RefreshDcdnObjectCachesResponseBody) *RefreshDcdnObjectCachesResponse {
	s.Body = v
	return s
}

type RollbackDcdnStagingConfigRequest struct {
	// The accelerated domain name. You can specify only one domain name in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s RollbackDcdnStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s RollbackDcdnStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *RollbackDcdnStagingConfigRequest) SetDomainName(v string) *RollbackDcdnStagingConfigRequest {
	s.DomainName = &v
	return s
}

type RollbackDcdnStagingConfigResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RollbackDcdnStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RollbackDcdnStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *RollbackDcdnStagingConfigResponseBody) SetRequestId(v string) *RollbackDcdnStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type RollbackDcdnStagingConfigResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RollbackDcdnStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RollbackDcdnStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s RollbackDcdnStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *RollbackDcdnStagingConfigResponse) SetHeaders(v map[string]*string) *RollbackDcdnStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *RollbackDcdnStagingConfigResponse) SetStatusCode(v int32) *RollbackDcdnStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *RollbackDcdnStagingConfigResponse) SetBody(v *RollbackDcdnStagingConfigResponseBody) *RollbackDcdnStagingConfigResponse {
	s.Body = v
	return s
}

type SetDcdnDomainCertificateRequest struct {
	// The certificate name.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The certificate type.
	//
	// *   **upload**: a user-uploaded SSL certificate.
	// *   **cas**: a certificate that is acquired through Certificate Management Service.
	//
	// > If the value of the CertType parameter is **cas**, the **SSLPri** parameter is not required.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The accelerated domain name. You can specify only one domain name.
	//
	// HTTPS acceleration must be enabled for the accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// Specifies whether to check the certificate name for duplicates. If you set the value to 1, the system does not perform the check and overwrites the information about the existing certificate that uses the same name.
	ForceSet *string `json:"ForceSet,omitempty" xml:"ForceSet,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region. Default value: ch-hangzhou.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The private key. This parameter is required only if you enable the SSL certificate.
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the SSL certificate.
	//
	// *   **on**
	// *   **off**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The certificate content. This parameter is required only if you enable the SSL certificate.
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetDcdnDomainCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainCertificateRequest) SetCertName(v string) *SetDcdnDomainCertificateRequest {
	s.CertName = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetCertType(v string) *SetDcdnDomainCertificateRequest {
	s.CertType = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetDomainName(v string) *SetDcdnDomainCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetForceSet(v string) *SetDcdnDomainCertificateRequest {
	s.ForceSet = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetOwnerId(v int64) *SetDcdnDomainCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetRegion(v string) *SetDcdnDomainCertificateRequest {
	s.Region = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetSSLPri(v string) *SetDcdnDomainCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetSSLProtocol(v string) *SetDcdnDomainCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetSSLPub(v string) *SetDcdnDomainCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *SetDcdnDomainCertificateRequest) SetSecurityToken(v string) *SetDcdnDomainCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetDcdnDomainCertificateResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDcdnDomainCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainCertificateResponseBody) SetRequestId(v string) *SetDcdnDomainCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetDcdnDomainCertificateResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDcdnDomainCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDcdnDomainCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainCertificateResponse) SetHeaders(v map[string]*string) *SetDcdnDomainCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetDcdnDomainCertificateResponse) SetStatusCode(v int32) *SetDcdnDomainCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDcdnDomainCertificateResponse) SetBody(v *SetDcdnDomainCertificateResponseBody) *SetDcdnDomainCertificateResponse {
	s.Body = v
	return s
}

type SetDcdnDomainSMCertificateRequest struct {
	// The identifier of the certificate. The value is Certificate ID-cn-hangzhou. If the ID of the certificate is 123, CertIdentifier is set to 123-cn-hangzhou.
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The accelerated domain name for which the SM certificate is configured.
	//
	// > The domain name must have HTTPS secure acceleration enabled.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to enable the SSL certificate. Valid values:
	//
	// *   **on**
	// *   **off**
	SSLProtocol   *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetDcdnDomainSMCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainSMCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainSMCertificateRequest) SetCertIdentifier(v string) *SetDcdnDomainSMCertificateRequest {
	s.CertIdentifier = &v
	return s
}

func (s *SetDcdnDomainSMCertificateRequest) SetDomainName(v string) *SetDcdnDomainSMCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetDcdnDomainSMCertificateRequest) SetOwnerId(v int64) *SetDcdnDomainSMCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetDcdnDomainSMCertificateRequest) SetSSLProtocol(v string) *SetDcdnDomainSMCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetDcdnDomainSMCertificateRequest) SetSecurityToken(v string) *SetDcdnDomainSMCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetDcdnDomainSMCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDcdnDomainSMCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainSMCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainSMCertificateResponseBody) SetRequestId(v string) *SetDcdnDomainSMCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetDcdnDomainSMCertificateResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDcdnDomainSMCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDcdnDomainSMCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainSMCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainSMCertificateResponse) SetHeaders(v map[string]*string) *SetDcdnDomainSMCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetDcdnDomainSMCertificateResponse) SetStatusCode(v int32) *SetDcdnDomainSMCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDcdnDomainSMCertificateResponse) SetBody(v *SetDcdnDomainSMCertificateResponseBody) *SetDcdnDomainSMCertificateResponse {
	s.Body = v
	return s
}

type SetDcdnDomainSSLCertificateRequest struct {
	// The ID of the certificate. This parameter takes effect only when **CertType** is set to **cas**.
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the SSL certificate. You can specify only one certificate name.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The region of the SSL certificate. This parameter takes effect only when **CertType** is set to **cas**. Default value: **cn-hangzhou**. Valid values: **cn-hangzhou** and **ap-southeast-1**.
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The type of the certificate. Valid values:
	//
	// *   **upload**: a user-uploaded SSL certificate.
	// *   **cas**: a certificate that is acquired through Certificate Management Service.
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The domain name that is secured by the SSL certificate.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The private key. Specify the private key only if you want to enable the SSL certificate.
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the SSL certificate. Valid values:
	//
	// *   **on**
	// *   **off**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The content of the SSL certificate. Specify the content of the SSL certificate only if you want to enable the SSL certificate.
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetDcdnDomainSSLCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainSSLCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainSSLCertificateRequest) SetCertId(v int64) *SetDcdnDomainSSLCertificateRequest {
	s.CertId = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetCertName(v string) *SetDcdnDomainSSLCertificateRequest {
	s.CertName = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetCertRegion(v string) *SetDcdnDomainSSLCertificateRequest {
	s.CertRegion = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetCertType(v string) *SetDcdnDomainSSLCertificateRequest {
	s.CertType = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetDomainName(v string) *SetDcdnDomainSSLCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetOwnerId(v int64) *SetDcdnDomainSSLCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetSSLPri(v string) *SetDcdnDomainSSLCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetSSLProtocol(v string) *SetDcdnDomainSSLCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetSSLPub(v string) *SetDcdnDomainSSLCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateRequest) SetSecurityToken(v string) *SetDcdnDomainSSLCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetDcdnDomainSSLCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDcdnDomainSSLCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainSSLCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainSSLCertificateResponseBody) SetRequestId(v string) *SetDcdnDomainSSLCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetDcdnDomainSSLCertificateResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDcdnDomainSSLCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDcdnDomainSSLCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainSSLCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainSSLCertificateResponse) SetHeaders(v map[string]*string) *SetDcdnDomainSSLCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetDcdnDomainSSLCertificateResponse) SetStatusCode(v int32) *SetDcdnDomainSSLCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDcdnDomainSSLCertificateResponse) SetBody(v *SetDcdnDomainSSLCertificateResponseBody) *SetDcdnDomainSSLCertificateResponse {
	s.Body = v
	return s
}

type SetDcdnDomainStagingConfigRequest struct {
	// The accelerated domain name. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The list of features. Format: `[{"functionArgs":[{"argName":"parameter key","argValue":"parameter value"},{"argName":"xx","argValue":"xx"}],"functionName": feature name"}]`
	//
	// > Separate multiple parameters with commas (,).
	Functions *string `json:"Functions,omitempty" xml:"Functions,omitempty"`
}

func (s SetDcdnDomainStagingConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainStagingConfigRequest) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainStagingConfigRequest) SetDomainName(v string) *SetDcdnDomainStagingConfigRequest {
	s.DomainName = &v
	return s
}

func (s *SetDcdnDomainStagingConfigRequest) SetFunctions(v string) *SetDcdnDomainStagingConfigRequest {
	s.Functions = &v
	return s
}

type SetDcdnDomainStagingConfigResponseBody struct {
	// The ID of the region.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDcdnDomainStagingConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainStagingConfigResponseBody) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainStagingConfigResponseBody) SetRequestId(v string) *SetDcdnDomainStagingConfigResponseBody {
	s.RequestId = &v
	return s
}

type SetDcdnDomainStagingConfigResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDcdnDomainStagingConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDcdnDomainStagingConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnDomainStagingConfigResponse) GoString() string {
	return s.String()
}

func (s *SetDcdnDomainStagingConfigResponse) SetHeaders(v map[string]*string) *SetDcdnDomainStagingConfigResponse {
	s.Headers = v
	return s
}

func (s *SetDcdnDomainStagingConfigResponse) SetStatusCode(v int32) *SetDcdnDomainStagingConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDcdnDomainStagingConfigResponse) SetBody(v *SetDcdnDomainStagingConfigResponseBody) *SetDcdnDomainStagingConfigResponse {
	s.Body = v
	return s
}

type SetDcdnFullDomainsBlockIPRequest struct {
	// The blocking period. Unit: seconds.
	//
	// > If you set the **OperationType** parameter to **unblock**, you do not need to set this parameter.
	BlockInterval *int32 `json:"BlockInterval,omitempty" xml:"BlockInterval,omitempty"`
	// The IP addresses that are blocked or unblocked. Separate multiple IP addresses with commas (,). You can specify up to 1,000 IP addresses.
	IPList *string `json:"IPList,omitempty" xml:"IPList,omitempty"`
	// The action. Valid values:
	//
	// *   **block**
	// *   **unblock**
	OperationType *string `json:"OperationType,omitempty" xml:"OperationType,omitempty"`
	UpdateType    *string `json:"UpdateType,omitempty" xml:"UpdateType,omitempty"`
}

func (s SetDcdnFullDomainsBlockIPRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnFullDomainsBlockIPRequest) GoString() string {
	return s.String()
}

func (s *SetDcdnFullDomainsBlockIPRequest) SetBlockInterval(v int32) *SetDcdnFullDomainsBlockIPRequest {
	s.BlockInterval = &v
	return s
}

func (s *SetDcdnFullDomainsBlockIPRequest) SetIPList(v string) *SetDcdnFullDomainsBlockIPRequest {
	s.IPList = &v
	return s
}

func (s *SetDcdnFullDomainsBlockIPRequest) SetOperationType(v string) *SetDcdnFullDomainsBlockIPRequest {
	s.OperationType = &v
	return s
}

func (s *SetDcdnFullDomainsBlockIPRequest) SetUpdateType(v string) *SetDcdnFullDomainsBlockIPRequest {
	s.UpdateType = &v
	return s
}

type SetDcdnFullDomainsBlockIPResponseBody struct {
	// The response code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The status code that indicates the result.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDcdnFullDomainsBlockIPResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnFullDomainsBlockIPResponseBody) GoString() string {
	return s.String()
}

func (s *SetDcdnFullDomainsBlockIPResponseBody) SetCode(v int32) *SetDcdnFullDomainsBlockIPResponseBody {
	s.Code = &v
	return s
}

func (s *SetDcdnFullDomainsBlockIPResponseBody) SetMessage(v string) *SetDcdnFullDomainsBlockIPResponseBody {
	s.Message = &v
	return s
}

func (s *SetDcdnFullDomainsBlockIPResponseBody) SetRequestId(v string) *SetDcdnFullDomainsBlockIPResponseBody {
	s.RequestId = &v
	return s
}

type SetDcdnFullDomainsBlockIPResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDcdnFullDomainsBlockIPResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDcdnFullDomainsBlockIPResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnFullDomainsBlockIPResponse) GoString() string {
	return s.String()
}

func (s *SetDcdnFullDomainsBlockIPResponse) SetHeaders(v map[string]*string) *SetDcdnFullDomainsBlockIPResponse {
	s.Headers = v
	return s
}

func (s *SetDcdnFullDomainsBlockIPResponse) SetStatusCode(v int32) *SetDcdnFullDomainsBlockIPResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDcdnFullDomainsBlockIPResponse) SetBody(v *SetDcdnFullDomainsBlockIPResponseBody) *SetDcdnFullDomainsBlockIPResponse {
	s.Body = v
	return s
}

type SetDcdnUserConfigRequest struct {
	// The configuration parameters of the feature.
	Configs *string `json:"Configs,omitempty" xml:"Configs,omitempty"`
	// The ID of the feature.
	FunctionId    *int32  `json:"FunctionId,omitempty" xml:"FunctionId,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetDcdnUserConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnUserConfigRequest) GoString() string {
	return s.String()
}

func (s *SetDcdnUserConfigRequest) SetConfigs(v string) *SetDcdnUserConfigRequest {
	s.Configs = &v
	return s
}

func (s *SetDcdnUserConfigRequest) SetFunctionId(v int32) *SetDcdnUserConfigRequest {
	s.FunctionId = &v
	return s
}

func (s *SetDcdnUserConfigRequest) SetOwnerAccount(v string) *SetDcdnUserConfigRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetDcdnUserConfigRequest) SetOwnerId(v int64) *SetDcdnUserConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *SetDcdnUserConfigRequest) SetSecurityToken(v string) *SetDcdnUserConfigRequest {
	s.SecurityToken = &v
	return s
}

type SetDcdnUserConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDcdnUserConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnUserConfigResponseBody) GoString() string {
	return s.String()
}

func (s *SetDcdnUserConfigResponseBody) SetRequestId(v string) *SetDcdnUserConfigResponseBody {
	s.RequestId = &v
	return s
}

type SetDcdnUserConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDcdnUserConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDcdnUserConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDcdnUserConfigResponse) GoString() string {
	return s.String()
}

func (s *SetDcdnUserConfigResponse) SetHeaders(v map[string]*string) *SetDcdnUserConfigResponse {
	s.Headers = v
	return s
}

func (s *SetDcdnUserConfigResponse) SetStatusCode(v int32) *SetDcdnUserConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDcdnUserConfigResponse) SetBody(v *SetDcdnUserConfigResponseBody) *SetDcdnUserConfigResponse {
	s.Body = v
	return s
}

type SetRoutineSubdomainRequest struct {
	// The parameters of the subdomain.
	//
	// The parameters are in the following format:
	//
	//     Subdomains: [
	//         "subdomain-test"
	//     ]
	Subdomains map[string]interface{} `json:"Subdomains,omitempty" xml:"Subdomains,omitempty"`
}

func (s SetRoutineSubdomainRequest) String() string {
	return tea.Prettify(s)
}

func (s SetRoutineSubdomainRequest) GoString() string {
	return s.String()
}

func (s *SetRoutineSubdomainRequest) SetSubdomains(v map[string]interface{}) *SetRoutineSubdomainRequest {
	s.Subdomains = v
	return s
}

type SetRoutineSubdomainShrinkRequest struct {
	// The parameters of the subdomain.
	//
	// The parameters are in the following format:
	//
	//     Subdomains: [
	//         "subdomain-test"
	//     ]
	SubdomainsShrink *string `json:"Subdomains,omitempty" xml:"Subdomains,omitempty"`
}

func (s SetRoutineSubdomainShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s SetRoutineSubdomainShrinkRequest) GoString() string {
	return s.String()
}

func (s *SetRoutineSubdomainShrinkRequest) SetSubdomainsShrink(v string) *SetRoutineSubdomainShrinkRequest {
	s.SubdomainsShrink = &v
	return s
}

type SetRoutineSubdomainResponseBody struct {
	// The message returned, such as ""Status": "OK"".
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetRoutineSubdomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetRoutineSubdomainResponseBody) GoString() string {
	return s.String()
}

func (s *SetRoutineSubdomainResponseBody) SetContent(v map[string]interface{}) *SetRoutineSubdomainResponseBody {
	s.Content = v
	return s
}

func (s *SetRoutineSubdomainResponseBody) SetRequestId(v string) *SetRoutineSubdomainResponseBody {
	s.RequestId = &v
	return s
}

type SetRoutineSubdomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetRoutineSubdomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetRoutineSubdomainResponse) String() string {
	return tea.Prettify(s)
}

func (s SetRoutineSubdomainResponse) GoString() string {
	return s.String()
}

func (s *SetRoutineSubdomainResponse) SetHeaders(v map[string]*string) *SetRoutineSubdomainResponse {
	s.Headers = v
	return s
}

func (s *SetRoutineSubdomainResponse) SetStatusCode(v int32) *SetRoutineSubdomainResponse {
	s.StatusCode = &v
	return s
}

func (s *SetRoutineSubdomainResponse) SetBody(v *SetRoutineSubdomainResponseBody) *SetRoutineSubdomainResponse {
	s.Body = v
	return s
}

type StartDcdnDomainRequest struct {
	// The accelerated domain name. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s StartDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s StartDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *StartDcdnDomainRequest) SetDomainName(v string) *StartDcdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *StartDcdnDomainRequest) SetOwnerId(v int64) *StartDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *StartDcdnDomainRequest) SetSecurityToken(v string) *StartDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type StartDcdnDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *StartDcdnDomainResponseBody) SetRequestId(v string) *StartDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type StartDcdnDomainResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s StartDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *StartDcdnDomainResponse) SetHeaders(v map[string]*string) *StartDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *StartDcdnDomainResponse) SetStatusCode(v int32) *StartDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *StartDcdnDomainResponse) SetBody(v *StartDcdnDomainResponseBody) *StartDcdnDomainResponse {
	s.Body = v
	return s
}

type StartDcdnIpaDomainRequest struct {
	// The name of the accelerated domain to be enabled. You can specify only one accelerated domain name at a time.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s StartDcdnIpaDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s StartDcdnIpaDomainRequest) GoString() string {
	return s.String()
}

func (s *StartDcdnIpaDomainRequest) SetDomainName(v string) *StartDcdnIpaDomainRequest {
	s.DomainName = &v
	return s
}

func (s *StartDcdnIpaDomainRequest) SetOwnerId(v int64) *StartDcdnIpaDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *StartDcdnIpaDomainRequest) SetSecurityToken(v string) *StartDcdnIpaDomainRequest {
	s.SecurityToken = &v
	return s
}

type StartDcdnIpaDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartDcdnIpaDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartDcdnIpaDomainResponseBody) GoString() string {
	return s.String()
}

func (s *StartDcdnIpaDomainResponseBody) SetRequestId(v string) *StartDcdnIpaDomainResponseBody {
	s.RequestId = &v
	return s
}

type StartDcdnIpaDomainResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartDcdnIpaDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartDcdnIpaDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s StartDcdnIpaDomainResponse) GoString() string {
	return s.String()
}

func (s *StartDcdnIpaDomainResponse) SetHeaders(v map[string]*string) *StartDcdnIpaDomainResponse {
	s.Headers = v
	return s
}

func (s *StartDcdnIpaDomainResponse) SetStatusCode(v int32) *StartDcdnIpaDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *StartDcdnIpaDomainResponse) SetBody(v *StartDcdnIpaDomainResponseBody) *StartDcdnIpaDomainResponse {
	s.Body = v
	return s
}

type StopDcdnDomainRequest struct {
	// The accelerated domain name that you want to disable. You can specify only one domain name in each request.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s StopDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s StopDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *StopDcdnDomainRequest) SetDomainName(v string) *StopDcdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *StopDcdnDomainRequest) SetOwnerId(v int64) *StopDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *StopDcdnDomainRequest) SetSecurityToken(v string) *StopDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

type StopDcdnDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *StopDcdnDomainResponseBody) SetRequestId(v string) *StopDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type StopDcdnDomainResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s StopDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *StopDcdnDomainResponse) SetHeaders(v map[string]*string) *StopDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *StopDcdnDomainResponse) SetStatusCode(v int32) *StopDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *StopDcdnDomainResponse) SetBody(v *StopDcdnDomainResponseBody) *StopDcdnDomainResponse {
	s.Body = v
	return s
}

type StopDcdnIpaDomainRequest struct {
	// The name of the accelerated domain that you want to disable. You can specify only one domain name at a time.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s StopDcdnIpaDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s StopDcdnIpaDomainRequest) GoString() string {
	return s.String()
}

func (s *StopDcdnIpaDomainRequest) SetDomainName(v string) *StopDcdnIpaDomainRequest {
	s.DomainName = &v
	return s
}

func (s *StopDcdnIpaDomainRequest) SetOwnerId(v int64) *StopDcdnIpaDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *StopDcdnIpaDomainRequest) SetSecurityToken(v string) *StopDcdnIpaDomainRequest {
	s.SecurityToken = &v
	return s
}

type StopDcdnIpaDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopDcdnIpaDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopDcdnIpaDomainResponseBody) GoString() string {
	return s.String()
}

func (s *StopDcdnIpaDomainResponseBody) SetRequestId(v string) *StopDcdnIpaDomainResponseBody {
	s.RequestId = &v
	return s
}

type StopDcdnIpaDomainResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopDcdnIpaDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopDcdnIpaDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s StopDcdnIpaDomainResponse) GoString() string {
	return s.String()
}

func (s *StopDcdnIpaDomainResponse) SetHeaders(v map[string]*string) *StopDcdnIpaDomainResponse {
	s.Headers = v
	return s
}

func (s *StopDcdnIpaDomainResponse) SetStatusCode(v int32) *StopDcdnIpaDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *StopDcdnIpaDomainResponse) SetBody(v *StopDcdnIpaDomainResponseBody) *StopDcdnIpaDomainResponse {
	s.Body = v
	return s
}

type TagDcdnResourcesRequest struct {
	// The ID of the resource. Valid values of N: **1** to **50**.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource. Set the value to **DOMAIN**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags.
	Tag []*TagDcdnResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagDcdnResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagDcdnResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagDcdnResourcesRequest) SetResourceId(v []*string) *TagDcdnResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagDcdnResourcesRequest) SetResourceType(v string) *TagDcdnResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagDcdnResourcesRequest) SetTag(v []*TagDcdnResourcesRequestTag) *TagDcdnResourcesRequest {
	s.Tag = v
	return s
}

type TagDcdnResourcesRequestTag struct {
	// The key of the tag. Valid values of N: **1** to **20**.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of a tag. Valid values of N: **1** to **20**.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagDcdnResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagDcdnResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagDcdnResourcesRequestTag) SetKey(v string) *TagDcdnResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagDcdnResourcesRequestTag) SetValue(v string) *TagDcdnResourcesRequestTag {
	s.Value = &v
	return s
}

type TagDcdnResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagDcdnResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagDcdnResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagDcdnResourcesResponseBody) SetRequestId(v string) *TagDcdnResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagDcdnResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagDcdnResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagDcdnResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagDcdnResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagDcdnResourcesResponse) SetHeaders(v map[string]*string) *TagDcdnResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagDcdnResourcesResponse) SetStatusCode(v int32) *TagDcdnResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagDcdnResourcesResponse) SetBody(v *TagDcdnResourcesResponseBody) *TagDcdnResourcesResponse {
	s.Body = v
	return s
}

type UntagDcdnResourcesRequest struct {
	// Specifies whether to delete all tags. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// Default value: **false**
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The ID of the resource. Valid values of N: **1** to **50**.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource. Set the value to **DOMAIN**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag. Valid values of N: **1** to **20**.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagDcdnResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagDcdnResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagDcdnResourcesRequest) SetAll(v bool) *UntagDcdnResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagDcdnResourcesRequest) SetResourceId(v []*string) *UntagDcdnResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagDcdnResourcesRequest) SetResourceType(v string) *UntagDcdnResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagDcdnResourcesRequest) SetTagKey(v []*string) *UntagDcdnResourcesRequest {
	s.TagKey = v
	return s
}

type UntagDcdnResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagDcdnResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagDcdnResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagDcdnResourcesResponseBody) SetRequestId(v string) *UntagDcdnResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagDcdnResourcesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagDcdnResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagDcdnResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagDcdnResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagDcdnResourcesResponse) SetHeaders(v map[string]*string) *UntagDcdnResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagDcdnResourcesResponse) SetStatusCode(v int32) *UntagDcdnResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagDcdnResourcesResponse) SetBody(v *UntagDcdnResourcesResponseBody) *UntagDcdnResourcesResponse {
	s.Body = v
	return s
}

type UpdateDcdnDeliverTaskRequest struct {
	// The ID of the request.
	Deliver *string `json:"Deliver,omitempty" xml:"Deliver,omitempty"`
	// Domain Subscription
	DeliverId *int64 `json:"DeliverId,omitempty" xml:"DeliverId,omitempty"`
	// {"schedName":"subscription task name","description":"description","crontab":"000**?","frequency":"d","status":"enable","effectiveFrom": "2020-09-17T00:00:00Z","effectiveEnd":"2020-11-17T00:00:00Z"}
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the tracking task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The operations reports that are tracked by the task. The data must be escaped in JSON.
	Reports *string `json:"Reports,omitempty" xml:"Reports,omitempty"`
	// The method that is used to send operations reports. Operations reports are sent to you only by email. The settings must be escaped in JSON.
	Schedule *string `json:"Schedule,omitempty" xml:"Schedule,omitempty"`
}

func (s UpdateDcdnDeliverTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnDeliverTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateDcdnDeliverTaskRequest) SetDeliver(v string) *UpdateDcdnDeliverTaskRequest {
	s.Deliver = &v
	return s
}

func (s *UpdateDcdnDeliverTaskRequest) SetDeliverId(v int64) *UpdateDcdnDeliverTaskRequest {
	s.DeliverId = &v
	return s
}

func (s *UpdateDcdnDeliverTaskRequest) SetDomainName(v string) *UpdateDcdnDeliverTaskRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDcdnDeliverTaskRequest) SetName(v string) *UpdateDcdnDeliverTaskRequest {
	s.Name = &v
	return s
}

func (s *UpdateDcdnDeliverTaskRequest) SetReports(v string) *UpdateDcdnDeliverTaskRequest {
	s.Reports = &v
	return s
}

func (s *UpdateDcdnDeliverTaskRequest) SetSchedule(v string) *UpdateDcdnDeliverTaskRequest {
	s.Schedule = &v
	return s
}

type UpdateDcdnDeliverTaskResponseBody struct {
	// Updates a tracking task by task ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDcdnDeliverTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnDeliverTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDcdnDeliverTaskResponseBody) SetRequestId(v string) *UpdateDcdnDeliverTaskResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDcdnDeliverTaskResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDcdnDeliverTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDcdnDeliverTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnDeliverTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateDcdnDeliverTaskResponse) SetHeaders(v map[string]*string) *UpdateDcdnDeliverTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateDcdnDeliverTaskResponse) SetStatusCode(v int32) *UpdateDcdnDeliverTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDcdnDeliverTaskResponse) SetBody(v *UpdateDcdnDeliverTaskResponseBody) *UpdateDcdnDeliverTaskResponse {
	s.Body = v
	return s
}

type UpdateDcdnDomainRequest struct {
	// The top-level domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The accelerated domain name. You can specify only one domain name in each call.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The operation that you want to perform. Set the value to **UpdateDcdnDomain**.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s UpdateDcdnDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateDcdnDomainRequest) SetDomainName(v string) *UpdateDcdnDomainRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDcdnDomainRequest) SetOwnerId(v int64) *UpdateDcdnDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateDcdnDomainRequest) SetResourceGroupId(v string) *UpdateDcdnDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdateDcdnDomainRequest) SetSecurityToken(v string) *UpdateDcdnDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *UpdateDcdnDomainRequest) SetSources(v string) *UpdateDcdnDomainRequest {
	s.Sources = &v
	return s
}

func (s *UpdateDcdnDomainRequest) SetTopLevelDomain(v string) *UpdateDcdnDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type UpdateDcdnDomainResponseBody struct {
	// The information about the addresses of origin servers.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDcdnDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDcdnDomainResponseBody) SetRequestId(v string) *UpdateDcdnDomainResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDcdnDomainResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDcdnDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDcdnDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateDcdnDomainResponse) SetHeaders(v map[string]*string) *UpdateDcdnDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateDcdnDomainResponse) SetStatusCode(v int32) *UpdateDcdnDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDcdnDomainResponse) SetBody(v *UpdateDcdnDomainResponseBody) *UpdateDcdnDomainResponse {
	s.Body = v
	return s
}

type UpdateDcdnIpaDomainRequest struct {
	// The accelerated domain name that you want to modify. You can specify only one domain name in each request.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of the origin server.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The top-level domain name.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s UpdateDcdnIpaDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnIpaDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateDcdnIpaDomainRequest) SetDomainName(v string) *UpdateDcdnIpaDomainRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDcdnIpaDomainRequest) SetOwnerId(v int64) *UpdateDcdnIpaDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateDcdnIpaDomainRequest) SetResourceGroupId(v string) *UpdateDcdnIpaDomainRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdateDcdnIpaDomainRequest) SetSecurityToken(v string) *UpdateDcdnIpaDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *UpdateDcdnIpaDomainRequest) SetSources(v string) *UpdateDcdnIpaDomainRequest {
	s.Sources = &v
	return s
}

func (s *UpdateDcdnIpaDomainRequest) SetTopLevelDomain(v string) *UpdateDcdnIpaDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type UpdateDcdnIpaDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDcdnIpaDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnIpaDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDcdnIpaDomainResponseBody) SetRequestId(v string) *UpdateDcdnIpaDomainResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDcdnIpaDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDcdnIpaDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDcdnIpaDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnIpaDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateDcdnIpaDomainResponse) SetHeaders(v map[string]*string) *UpdateDcdnIpaDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateDcdnIpaDomainResponse) SetStatusCode(v int32) *UpdateDcdnIpaDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDcdnIpaDomainResponse) SetBody(v *UpdateDcdnIpaDomainResponseBody) *UpdateDcdnIpaDomainResponse {
	s.Body = v
	return s
}

type UpdateDcdnSLSRealtimeLogDeliveryRequest struct {
	// The region from which logs are collected.
	//
	// *   **cn**: Chinese mainland
	// *   **sg**: Singapore
	// *   **in**: India
	// *   **eu**: Europe
	// *   **us**: United States
	DataCenter *string `json:"DataCenter,omitempty" xml:"DataCenter,omitempty"`
	// The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the Logstore.
	SLSLogStore *string `json:"SLSLogStore,omitempty" xml:"SLSLogStore,omitempty"`
	// The name of the log file.
	SLSProject *string `json:"SLSProject,omitempty" xml:"SLSProject,omitempty"`
	// The region to which logs were delivered.
	SLSRegion *string `json:"SLSRegion,omitempty" xml:"SLSRegion,omitempty"`
	// The sampling rate.
	SamplingRate *string `json:"SamplingRate,omitempty" xml:"SamplingRate,omitempty"`
}

func (s UpdateDcdnSLSRealtimeLogDeliveryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSLSRealtimeLogDeliveryRequest) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryRequest) SetDataCenter(v string) *UpdateDcdnSLSRealtimeLogDeliveryRequest {
	s.DataCenter = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryRequest) SetDomainName(v string) *UpdateDcdnSLSRealtimeLogDeliveryRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryRequest) SetProjectName(v string) *UpdateDcdnSLSRealtimeLogDeliveryRequest {
	s.ProjectName = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryRequest) SetSLSLogStore(v string) *UpdateDcdnSLSRealtimeLogDeliveryRequest {
	s.SLSLogStore = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryRequest) SetSLSProject(v string) *UpdateDcdnSLSRealtimeLogDeliveryRequest {
	s.SLSProject = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryRequest) SetSLSRegion(v string) *UpdateDcdnSLSRealtimeLogDeliveryRequest {
	s.SLSRegion = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryRequest) SetSamplingRate(v string) *UpdateDcdnSLSRealtimeLogDeliveryRequest {
	s.SamplingRate = &v
	return s
}

type UpdateDcdnSLSRealtimeLogDeliveryResponseBody struct {
	// The configuration results of the domain name.
	Content *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponseBody) SetContent(v *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent) *UpdateDcdnSLSRealtimeLogDeliveryResponseBody {
	s.Content = v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponseBody) SetRequestId(v string) *UpdateDcdnSLSRealtimeLogDeliveryResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent struct {
	Domains []*UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent) SetDomains(v []*UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains) *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent {
	s.Domains = v
	return s
}

type UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains struct {
	// The description of the returned result.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// Indicates whether the real-time log delivery project was successfully updated. Valid values:
	//
	// *   **success**
	// *   **fail**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains) SetDesc(v string) *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains {
	s.Desc = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains) SetDomainName(v string) *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains {
	s.DomainName = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains) SetRegion(v string) *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains {
	s.Region = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains) SetStatus(v string) *UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains {
	s.Status = &v
	return s
}

type UpdateDcdnSLSRealtimeLogDeliveryResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDcdnSLSRealtimeLogDeliveryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSLSRealtimeLogDeliveryResponse) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponse) SetHeaders(v map[string]*string) *UpdateDcdnSLSRealtimeLogDeliveryResponse {
	s.Headers = v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponse) SetStatusCode(v int32) *UpdateDcdnSLSRealtimeLogDeliveryResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDcdnSLSRealtimeLogDeliveryResponse) SetBody(v *UpdateDcdnSLSRealtimeLogDeliveryResponseBody) *UpdateDcdnSLSRealtimeLogDeliveryResponse {
	s.Body = v
	return s
}

type UpdateDcdnSubTaskRequest struct {
	// The domain names that you want to include in the operations report. If you do not specify a domain name, all domain names that belong to your Alibaba Cloud account are included.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IDs of the metrics that you want to update. Separate IDs with commas (,). You can call the [DescribeDcdnSubList](~~270075~~) operation to query the IDs.
	ReportIds *string `json:"ReportIds,omitempty" xml:"ReportIds,omitempty"`
	// The start time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s UpdateDcdnSubTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSubTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSubTaskRequest) SetDomainName(v string) *UpdateDcdnSubTaskRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDcdnSubTaskRequest) SetEndTime(v string) *UpdateDcdnSubTaskRequest {
	s.EndTime = &v
	return s
}

func (s *UpdateDcdnSubTaskRequest) SetReportIds(v string) *UpdateDcdnSubTaskRequest {
	s.ReportIds = &v
	return s
}

func (s *UpdateDcdnSubTaskRequest) SetStartTime(v string) *UpdateDcdnSubTaskRequest {
	s.StartTime = &v
	return s
}

type UpdateDcdnSubTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDcdnSubTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSubTaskResponseBody) SetRequestId(v string) *UpdateDcdnSubTaskResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDcdnSubTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDcdnSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDcdnSubTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnSubTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateDcdnSubTaskResponse) SetHeaders(v map[string]*string) *UpdateDcdnSubTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateDcdnSubTaskResponse) SetStatusCode(v int32) *UpdateDcdnSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDcdnSubTaskResponse) SetBody(v *UpdateDcdnSubTaskResponseBody) *UpdateDcdnSubTaskResponse {
	s.Body = v
	return s
}

type UpdateDcdnUserRealTimeDeliveryFieldRequest struct {
	// The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
	//
	// *   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) points of presence (POPs)
	// *   **cdn_log_origin**: back-to-origin logs
	// *   **cdn_log_er**: EdgeRoutine logs
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The list of fields. Separate multiple fields with commas (,). For more information, see [Fields in a real-time log](~~324199~~).
	Fields *string `json:"Fields,omitempty" xml:"Fields,omitempty"`
}

func (s UpdateDcdnUserRealTimeDeliveryFieldRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnUserRealTimeDeliveryFieldRequest) GoString() string {
	return s.String()
}

func (s *UpdateDcdnUserRealTimeDeliveryFieldRequest) SetBusinessType(v string) *UpdateDcdnUserRealTimeDeliveryFieldRequest {
	s.BusinessType = &v
	return s
}

func (s *UpdateDcdnUserRealTimeDeliveryFieldRequest) SetFields(v string) *UpdateDcdnUserRealTimeDeliveryFieldRequest {
	s.Fields = &v
	return s
}

type UpdateDcdnUserRealTimeDeliveryFieldResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDcdnUserRealTimeDeliveryFieldResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnUserRealTimeDeliveryFieldResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDcdnUserRealTimeDeliveryFieldResponseBody) SetRequestId(v string) *UpdateDcdnUserRealTimeDeliveryFieldResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDcdnUserRealTimeDeliveryFieldResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDcdnUserRealTimeDeliveryFieldResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDcdnUserRealTimeDeliveryFieldResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDcdnUserRealTimeDeliveryFieldResponse) GoString() string {
	return s.String()
}

func (s *UpdateDcdnUserRealTimeDeliveryFieldResponse) SetHeaders(v map[string]*string) *UpdateDcdnUserRealTimeDeliveryFieldResponse {
	s.Headers = v
	return s
}

func (s *UpdateDcdnUserRealTimeDeliveryFieldResponse) SetStatusCode(v int32) *UpdateDcdnUserRealTimeDeliveryFieldResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDcdnUserRealTimeDeliveryFieldResponse) SetBody(v *UpdateDcdnUserRealTimeDeliveryFieldResponseBody) *UpdateDcdnUserRealTimeDeliveryFieldResponse {
	s.Body = v
	return s
}

type UploadRoutineCodeRequest struct {
	// The description of the code version.
	CodeDescription *string `json:"CodeDescription,omitempty" xml:"CodeDescription,omitempty"`
	// The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UploadRoutineCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadRoutineCodeRequest) GoString() string {
	return s.String()
}

func (s *UploadRoutineCodeRequest) SetCodeDescription(v string) *UploadRoutineCodeRequest {
	s.CodeDescription = &v
	return s
}

func (s *UploadRoutineCodeRequest) SetName(v string) *UploadRoutineCodeRequest {
	s.Name = &v
	return s
}

type UploadRoutineCodeResponseBody struct {
	// The content returned, such as the code version number and information about the code upload.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UploadRoutineCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadRoutineCodeResponseBody) GoString() string {
	return s.String()
}

func (s *UploadRoutineCodeResponseBody) SetContent(v map[string]interface{}) *UploadRoutineCodeResponseBody {
	s.Content = v
	return s
}

func (s *UploadRoutineCodeResponseBody) SetRequestId(v string) *UploadRoutineCodeResponseBody {
	s.RequestId = &v
	return s
}

type UploadRoutineCodeResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadRoutineCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadRoutineCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadRoutineCodeResponse) GoString() string {
	return s.String()
}

func (s *UploadRoutineCodeResponse) SetHeaders(v map[string]*string) *UploadRoutineCodeResponse {
	s.Headers = v
	return s
}

func (s *UploadRoutineCodeResponse) SetStatusCode(v int32) *UploadRoutineCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadRoutineCodeResponse) SetBody(v *UploadRoutineCodeResponseBody) *UploadRoutineCodeResponse {
	s.Body = v
	return s
}

type UploadStagingRoutineCodeRequest struct {
	// The description of the version.
	CodeDescription *string `json:"CodeDescription,omitempty" xml:"CodeDescription,omitempty"`
	// The name of the routine. The name needs to be unique among the routines that belong to the same Alibaba Cloud account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UploadStagingRoutineCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadStagingRoutineCodeRequest) GoString() string {
	return s.String()
}

func (s *UploadStagingRoutineCodeRequest) SetCodeDescription(v string) *UploadStagingRoutineCodeRequest {
	s.CodeDescription = &v
	return s
}

func (s *UploadStagingRoutineCodeRequest) SetName(v string) *UploadStagingRoutineCodeRequest {
	s.Name = &v
	return s
}

type UploadStagingRoutineCodeResponseBody struct {
	// The parameters required by the code.
	Content map[string]interface{} `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UploadStagingRoutineCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadStagingRoutineCodeResponseBody) GoString() string {
	return s.String()
}

func (s *UploadStagingRoutineCodeResponseBody) SetContent(v map[string]interface{}) *UploadStagingRoutineCodeResponseBody {
	s.Content = v
	return s
}

func (s *UploadStagingRoutineCodeResponseBody) SetRequestId(v string) *UploadStagingRoutineCodeResponseBody {
	s.RequestId = &v
	return s
}

type UploadStagingRoutineCodeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadStagingRoutineCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadStagingRoutineCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadStagingRoutineCodeResponse) GoString() string {
	return s.String()
}

func (s *UploadStagingRoutineCodeResponse) SetHeaders(v map[string]*string) *UploadStagingRoutineCodeResponse {
	s.Headers = v
	return s
}

func (s *UploadStagingRoutineCodeResponse) SetStatusCode(v int32) *UploadStagingRoutineCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadStagingRoutineCodeResponse) SetBody(v *UploadStagingRoutineCodeResponseBody) *UploadStagingRoutineCodeResponse {
	s.Body = v
	return s
}

type VerifyDcdnDomainOwnerRequest struct {
	// The domain name of which you want to verify the ownership. You can specify only one domain name in each call.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The verification method. Valid values:
	//
	// *   **dnsCheck**: by DNS record
	// *   **fileCheck**: by verification file
	VerifyType *string `json:"VerifyType,omitempty" xml:"VerifyType,omitempty"`
}

func (s VerifyDcdnDomainOwnerRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyDcdnDomainOwnerRequest) GoString() string {
	return s.String()
}

func (s *VerifyDcdnDomainOwnerRequest) SetDomainName(v string) *VerifyDcdnDomainOwnerRequest {
	s.DomainName = &v
	return s
}

func (s *VerifyDcdnDomainOwnerRequest) SetVerifyType(v string) *VerifyDcdnDomainOwnerRequest {
	s.VerifyType = &v
	return s
}

type VerifyDcdnDomainOwnerResponseBody struct {
	// The verification result.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyDcdnDomainOwnerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyDcdnDomainOwnerResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyDcdnDomainOwnerResponseBody) SetContent(v string) *VerifyDcdnDomainOwnerResponseBody {
	s.Content = &v
	return s
}

func (s *VerifyDcdnDomainOwnerResponseBody) SetRequestId(v string) *VerifyDcdnDomainOwnerResponseBody {
	s.RequestId = &v
	return s
}

type VerifyDcdnDomainOwnerResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyDcdnDomainOwnerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyDcdnDomainOwnerResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyDcdnDomainOwnerResponse) GoString() string {
	return s.String()
}

func (s *VerifyDcdnDomainOwnerResponse) SetHeaders(v map[string]*string) *VerifyDcdnDomainOwnerResponse {
	s.Headers = v
	return s
}

func (s *VerifyDcdnDomainOwnerResponse) SetStatusCode(v int32) *VerifyDcdnDomainOwnerResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyDcdnDomainOwnerResponse) SetBody(v *VerifyDcdnDomainOwnerResponseBody) *VerifyDcdnDomainOwnerResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"ap-northeast-1":              tea.String("dcdn.aliyuncs.com"),
		"ap-northeast-2-pop":          tea.String("dcdn.aliyuncs.com"),
		"ap-south-1":                  tea.String("dcdn.aliyuncs.com"),
		"ap-southeast-1":              tea.String("dcdn.aliyuncs.com"),
		"ap-southeast-2":              tea.String("dcdn.aliyuncs.com"),
		"ap-southeast-3":              tea.String("dcdn.aliyuncs.com"),
		"ap-southeast-5":              tea.String("dcdn.aliyuncs.com"),
		"cn-beijing":                  tea.String("dcdn.aliyuncs.com"),
		"cn-beijing-finance-1":        tea.String("dcdn.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("dcdn.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("dcdn.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("dcdn.aliyuncs.com"),
		"cn-chengdu":                  tea.String("dcdn.aliyuncs.com"),
		"cn-edge-1":                   tea.String("dcdn.aliyuncs.com"),
		"cn-fujian":                   tea.String("dcdn.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou":                 tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("dcdn.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("dcdn.aliyuncs.com"),
		"cn-hongkong":                 tea.String("dcdn.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("dcdn.aliyuncs.com"),
		"cn-huhehaote":                tea.String("dcdn.aliyuncs.com"),
		"cn-north-2-gov-1":            tea.String("dcdn.aliyuncs.com"),
		"cn-qingdao":                  tea.String("dcdn.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("dcdn.aliyuncs.com"),
		"cn-shanghai":                 tea.String("dcdn.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("dcdn.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("dcdn.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("dcdn.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("dcdn.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("dcdn.aliyuncs.com"),
		"cn-shenzhen":                 tea.String("dcdn.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("dcdn.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("dcdn.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("dcdn.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("dcdn.aliyuncs.com"),
		"cn-wuhan":                    tea.String("dcdn.aliyuncs.com"),
		"cn-yushanfang":               tea.String("dcdn.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("dcdn.aliyuncs.com"),
		"cn-zhangjiakou":              tea.String("dcdn.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("dcdn.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("dcdn.aliyuncs.com"),
		"eu-central-1":                tea.String("dcdn.aliyuncs.com"),
		"eu-west-1":                   tea.String("dcdn.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("dcdn.aliyuncs.com"),
		"me-east-1":                   tea.String("dcdn.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("dcdn.aliyuncs.com"),
		"us-east-1":                   tea.String("dcdn.aliyuncs.com"),
		"us-west-1":                   tea.String("dcdn.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("dcdn"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   Dynamic Content Delivery Network (DCDN) is activated.
 * *   Internet content provider (ICP) filing is complete for the accelerated domain name.
 * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request AddDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDcdnDomainResponse
 */
func (client *Client) AddDcdnDomainWithOptions(request *AddDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *AddDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckUrl)) {
		query["CheckUrl"] = request.CheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionType)) {
		query["FunctionType"] = request.FunctionType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Scene)) {
		query["Scene"] = request.Scene
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   Dynamic Content Delivery Network (DCDN) is activated.
 * *   Internet content provider (ICP) filing is complete for the accelerated domain name.
 * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request AddDcdnDomainRequest
 * @return AddDcdnDomainResponse
 */
func (client *Client) AddDcdnDomain(request *AddDcdnDomainRequest) (_result *AddDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDcdnDomainResponse{}
	_body, _err := client.AddDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   Make sure that the IPA service is activated before you add a domain name to accelerate.
 * *   Make sure that the Internet content provider (ICP) filling is complete for the domain name to accelerate.
 * *   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review is complete by the end of the next business day after you submit the request.
 * *   You can call this operation up to 10 times per second per user.
 *
 * @param request AddDcdnIpaDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDcdnIpaDomainResponse
 */
func (client *Client) AddDcdnIpaDomainWithOptions(request *AddDcdnIpaDomainRequest, runtime *util.RuntimeOptions) (_result *AddDcdnIpaDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckUrl)) {
		query["CheckUrl"] = request.CheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDcdnIpaDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDcdnIpaDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   Make sure that the IPA service is activated before you add a domain name to accelerate.
 * *   Make sure that the Internet content provider (ICP) filling is complete for the domain name to accelerate.
 * *   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review is complete by the end of the next business day after you submit the request.
 * *   You can call this operation up to 10 times per second per user.
 *
 * @param request AddDcdnIpaDomainRequest
 * @return AddDcdnIpaDomainResponse
 */
func (client *Client) AddDcdnIpaDomain(request *AddDcdnIpaDomainRequest) (_result *AddDcdnIpaDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDcdnIpaDomainResponse{}
	_body, _err := client.AddDcdnIpaDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **Prerequisites**:
 * *   The [DCDN service is activated](~~64926~~).
 * *   Internet content provider (ICP) filing is complete for the accelerated domain names.
 * > *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
 * >*   You can specify up to 50 domain names in each request.
 * >*   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchAddDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddDcdnDomainResponse
 */
func (client *Client) BatchAddDcdnDomainWithOptions(request *BatchAddDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *BatchAddDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckUrl)) {
		query["CheckUrl"] = request.CheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchAddDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchAddDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **Prerequisites**:
 * *   The [DCDN service is activated](~~64926~~).
 * *   Internet content provider (ICP) filing is complete for the accelerated domain names.
 * > *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
 * >*   You can specify up to 50 domain names in each request.
 * >*   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchAddDcdnDomainRequest
 * @return BatchAddDcdnDomainResponse
 */
func (client *Client) BatchAddDcdnDomain(request *BatchAddDcdnDomainRequest) (_result *BatchAddDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchAddDcdnDomainResponse{}
	_body, _err := client.BatchAddDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request BatchCreateDcdnWafRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreateDcdnWafRulesResponse
 */
func (client *Client) BatchCreateDcdnWafRulesWithOptions(request *BatchCreateDcdnWafRulesRequest, runtime *util.RuntimeOptions) (_result *BatchCreateDcdnWafRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		body["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleConfigs)) {
		body["RuleConfigs"] = request.RuleConfigs
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchCreateDcdnWafRules"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchCreateDcdnWafRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request BatchCreateDcdnWafRulesRequest
 * @return BatchCreateDcdnWafRulesResponse
 */
func (client *Client) BatchCreateDcdnWafRules(request *BatchCreateDcdnWafRulesRequest) (_result *BatchCreateDcdnWafRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchCreateDcdnWafRulesResponse{}
	_body, _err := client.BatchCreateDcdnWafRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > - You can specify up to 50 domain names in each request.
 * > - You can call this operation up to 30 times per second per account.
 *
 * @param request BatchDeleteDcdnDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteDcdnDomainConfigsResponse
 */
func (client *Client) BatchDeleteDcdnDomainConfigsWithOptions(request *BatchDeleteDcdnDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *BatchDeleteDcdnDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchDeleteDcdnDomainConfigs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchDeleteDcdnDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > - You can specify up to 50 domain names in each request.
 * > - You can call this operation up to 30 times per second per account.
 *
 * @param request BatchDeleteDcdnDomainConfigsRequest
 * @return BatchDeleteDcdnDomainConfigsResponse
 */
func (client *Client) BatchDeleteDcdnDomainConfigs(request *BatchDeleteDcdnDomainConfigsRequest) (_result *BatchDeleteDcdnDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchDeleteDcdnDomainConfigsResponse{}
	_body, _err := client.BatchDeleteDcdnDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * # Usage notes
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request BatchDeleteDcdnWafRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteDcdnWafRulesResponse
 */
func (client *Client) BatchDeleteDcdnWafRulesWithOptions(request *BatchDeleteDcdnWafRulesRequest, runtime *util.RuntimeOptions) (_result *BatchDeleteDcdnWafRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RuleIds)) {
		body["RuleIds"] = request.RuleIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchDeleteDcdnWafRules"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchDeleteDcdnWafRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * # Usage notes
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request BatchDeleteDcdnWafRulesRequest
 * @return BatchDeleteDcdnWafRulesResponse
 */
func (client *Client) BatchDeleteDcdnWafRules(request *BatchDeleteDcdnWafRulesRequest) (_result *BatchDeleteDcdnWafRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchDeleteDcdnWafRulesResponse{}
	_body, _err := client.BatchDeleteDcdnWafRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request BatchModifyDcdnWafRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchModifyDcdnWafRulesResponse
 */
func (client *Client) BatchModifyDcdnWafRulesWithOptions(request *BatchModifyDcdnWafRulesRequest, runtime *util.RuntimeOptions) (_result *BatchModifyDcdnWafRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		body["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleConfigs)) {
		body["RuleConfigs"] = request.RuleConfigs
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchModifyDcdnWafRules"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchModifyDcdnWafRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request BatchModifyDcdnWafRulesRequest
 * @return BatchModifyDcdnWafRulesResponse
 */
func (client *Client) BatchModifyDcdnWafRules(request *BatchModifyDcdnWafRulesRequest) (_result *BatchModifyDcdnWafRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchModifyDcdnWafRulesResponse{}
	_body, _err := client.BatchModifyDcdnWafRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchPutDcdnKvWithOptions(tmpReq *BatchPutDcdnKvRequest, runtime *util.RuntimeOptions) (_result *BatchPutDcdnKvResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &BatchPutDcdnKvShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.KvList)) {
		request.KvListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.KvList, tea.String("KvList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.KvListShrink)) {
		query["KvList"] = request.KvListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchPutDcdnKv"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchPutDcdnKvResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchPutDcdnKv(request *BatchPutDcdnKvRequest) (_result *BatchPutDcdnKvResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchPutDcdnKvResponse{}
	_body, _err := client.BatchPutDcdnKvWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request BatchSetDcdnDomainCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetDcdnDomainCertificateResponse
 */
func (client *Client) BatchSetDcdnDomainCertificateWithOptions(request *BatchSetDcdnDomainCertificateRequest, runtime *util.RuntimeOptions) (_result *BatchSetDcdnDomainCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertType)) {
		query["CertType"] = request.CertType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetDcdnDomainCertificate"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetDcdnDomainCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request BatchSetDcdnDomainCertificateRequest
 * @return BatchSetDcdnDomainCertificateResponse
 */
func (client *Client) BatchSetDcdnDomainCertificate(request *BatchSetDcdnDomainCertificateRequest) (_result *BatchSetDcdnDomainCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetDcdnDomainCertificateResponse{}
	_body, _err := client.BatchSetDcdnDomainCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   You can specify up to 50 domain names in each request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchSetDcdnDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetDcdnDomainConfigsResponse
 */
func (client *Client) BatchSetDcdnDomainConfigsWithOptions(request *BatchSetDcdnDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *BatchSetDcdnDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.Functions)) {
		query["Functions"] = request.Functions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetDcdnDomainConfigs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetDcdnDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   You can specify up to 50 domain names in each request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchSetDcdnDomainConfigsRequest
 * @return BatchSetDcdnDomainConfigsResponse
 */
func (client *Client) BatchSetDcdnDomainConfigs(request *BatchSetDcdnDomainConfigsRequest) (_result *BatchSetDcdnDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetDcdnDomainConfigsResponse{}
	_body, _err := client.BatchSetDcdnDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request BatchSetDcdnIpaDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetDcdnIpaDomainConfigsResponse
 */
func (client *Client) BatchSetDcdnIpaDomainConfigsWithOptions(request *BatchSetDcdnIpaDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *BatchSetDcdnIpaDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.Functions)) {
		query["Functions"] = request.Functions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetDcdnIpaDomainConfigs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetDcdnIpaDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request BatchSetDcdnIpaDomainConfigsRequest
 * @return BatchSetDcdnIpaDomainConfigsResponse
 */
func (client *Client) BatchSetDcdnIpaDomainConfigs(request *BatchSetDcdnIpaDomainConfigsRequest) (_result *BatchSetDcdnIpaDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetDcdnIpaDomainConfigsResponse{}
	_body, _err := client.BatchSetDcdnIpaDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * #
 * *   You can call this operation up to 20 times per second.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request BatchSetDcdnWafDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetDcdnWafDomainConfigsResponse
 */
func (client *Client) BatchSetDcdnWafDomainConfigsWithOptions(request *BatchSetDcdnWafDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *BatchSetDcdnWafDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientIpTag)) {
		body["ClientIpTag"] = request.ClientIpTag
	}

	if !tea.BoolValue(util.IsUnset(request.DefenseStatus)) {
		body["DefenseStatus"] = request.DefenseStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		body["DomainNames"] = request.DomainNames
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetDcdnWafDomainConfigs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetDcdnWafDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * #
 * *   You can call this operation up to 20 times per second.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request BatchSetDcdnWafDomainConfigsRequest
 * @return BatchSetDcdnWafDomainConfigsResponse
 */
func (client *Client) BatchSetDcdnWafDomainConfigs(request *BatchSetDcdnWafDomainConfigsRequest) (_result *BatchSetDcdnWafDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetDcdnWafDomainConfigsResponse{}
	_body, _err := client.BatchSetDcdnWafDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If an accelerated domain name is in an invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
 * *   You can specify up to 50 domain names in each request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchStartDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchStartDcdnDomainResponse
 */
func (client *Client) BatchStartDcdnDomainWithOptions(request *BatchStartDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStartDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStartDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchStartDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If an accelerated domain name is in an invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
 * *   You can specify up to 50 domain names in each request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchStartDcdnDomainRequest
 * @return BatchStartDcdnDomainResponse
 */
func (client *Client) BatchStartDcdnDomain(request *BatchStartDcdnDomainRequest) (_result *BatchStartDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStartDcdnDomainResponse{}
	_body, _err := client.BatchStartDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > *   After an accelerated domain name is disabled, Dynamic Content Delivery Network (DCDN) retains the domain name information. The system automatically reroutes all requests that are destined for the accelerated domain name to the origin.
 * >*   You can specify up to 50 domain names in each request.
 * >*   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchStopDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchStopDcdnDomainResponse
 */
func (client *Client) BatchStopDcdnDomainWithOptions(request *BatchStopDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStopDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStopDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchStopDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > *   After an accelerated domain name is disabled, Dynamic Content Delivery Network (DCDN) retains the domain name information. The system automatically reroutes all requests that are destined for the accelerated domain name to the origin.
 * >*   You can specify up to 50 domain names in each request.
 * >*   You can call this operation up to 30 times per second per account.
 *
 * @param request BatchStopDcdnDomainRequest
 * @return BatchStopDcdnDomainResponse
 */
func (client *Client) BatchStopDcdnDomain(request *BatchStopDcdnDomainRequest) (_result *BatchStopDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStopDcdnDomainResponse{}
	_body, _err := client.BatchStopDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request CheckDcdnProjectExistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckDcdnProjectExistResponse
 */
func (client *Client) CheckDcdnProjectExistWithOptions(request *CheckDcdnProjectExistRequest, runtime *util.RuntimeOptions) (_result *CheckDcdnProjectExistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckDcdnProjectExist"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckDcdnProjectExistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request CheckDcdnProjectExistRequest
 * @return CheckDcdnProjectExistResponse
 */
func (client *Client) CheckDcdnProjectExist(request *CheckDcdnProjectExistRequest) (_result *CheckDcdnProjectExistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckDcdnProjectExistResponse{}
	_body, _err := client.CheckDcdnProjectExistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The call frequency of the API is no more than 100 queries per second.
 *
 * @param request CommitStagingRoutineCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CommitStagingRoutineCodeResponse
 */
func (client *Client) CommitStagingRoutineCodeWithOptions(request *CommitStagingRoutineCodeRequest, runtime *util.RuntimeOptions) (_result *CommitStagingRoutineCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CodeDescription)) {
		body["CodeDescription"] = request.CodeDescription
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CommitStagingRoutineCode"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CommitStagingRoutineCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The call frequency of the API is no more than 100 queries per second.
 *
 * @param request CommitStagingRoutineCodeRequest
 * @return CommitStagingRoutineCodeResponse
 */
func (client *Client) CommitStagingRoutineCode(request *CommitStagingRoutineCodeRequest) (_result *CommitStagingRoutineCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CommitStagingRoutineCodeResponse{}
	_body, _err := client.CommitStagingRoutineCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request CreateDcdnDeliverTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDcdnDeliverTaskResponse
 */
func (client *Client) CreateDcdnDeliverTaskWithOptions(request *CreateDcdnDeliverTaskRequest, runtime *util.RuntimeOptions) (_result *CreateDcdnDeliverTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Deliver)) {
		body["Deliver"] = request.Deliver
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Reports)) {
		body["Reports"] = request.Reports
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["Schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDcdnDeliverTask"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDcdnDeliverTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request CreateDcdnDeliverTaskRequest
 * @return CreateDcdnDeliverTaskResponse
 */
func (client *Client) CreateDcdnDeliverTask(request *CreateDcdnDeliverTaskRequest) (_result *CreateDcdnDeliverTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDcdnDeliverTaskResponse{}
	_body, _err := client.CreateDcdnDeliverTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request CreateDcdnSLSRealTimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDcdnSLSRealTimeLogDeliveryResponse
 */
func (client *Client) CreateDcdnSLSRealTimeLogDeliveryWithOptions(request *CreateDcdnSLSRealTimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *CreateDcdnSLSRealTimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessType)) {
		body["BusinessType"] = request.BusinessType
	}

	if !tea.BoolValue(util.IsUnset(request.DataCenter)) {
		body["DataCenter"] = request.DataCenter
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.SLSLogStore)) {
		body["SLSLogStore"] = request.SLSLogStore
	}

	if !tea.BoolValue(util.IsUnset(request.SLSProject)) {
		body["SLSProject"] = request.SLSProject
	}

	if !tea.BoolValue(util.IsUnset(request.SLSRegion)) {
		body["SLSRegion"] = request.SLSRegion
	}

	if !tea.BoolValue(util.IsUnset(request.SamplingRate)) {
		body["SamplingRate"] = request.SamplingRate
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDcdnSLSRealTimeLogDelivery"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDcdnSLSRealTimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request CreateDcdnSLSRealTimeLogDeliveryRequest
 * @return CreateDcdnSLSRealTimeLogDeliveryResponse
 */
func (client *Client) CreateDcdnSLSRealTimeLogDelivery(request *CreateDcdnSLSRealTimeLogDeliveryRequest) (_result *CreateDcdnSLSRealTimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDcdnSLSRealTimeLogDeliveryResponse{}
	_body, _err := client.CreateDcdnSLSRealTimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   This operation allows you to customize an operations report for a specific domain name. You can view the statistics about the domain name in the report.
 * *   You can call this operation up to three times per second per account.
 *
 * @param request CreateDcdnSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDcdnSubTaskResponse
 */
func (client *Client) CreateDcdnSubTaskWithOptions(request *CreateDcdnSubTaskRequest, runtime *util.RuntimeOptions) (_result *CreateDcdnSubTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ReportIds)) {
		body["ReportIds"] = request.ReportIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDcdnSubTask"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDcdnSubTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   This operation allows you to customize an operations report for a specific domain name. You can view the statistics about the domain name in the report.
 * *   You can call this operation up to three times per second per account.
 *
 * @param request CreateDcdnSubTaskRequest
 * @return CreateDcdnSubTaskResponse
 */
func (client *Client) CreateDcdnSubTask(request *CreateDcdnSubTaskRequest) (_result *CreateDcdnSubTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDcdnSubTaskResponse{}
	_body, _err := client.CreateDcdnSubTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDcdnWafGroupWithOptions(request *CreateDcdnWafGroupRequest, runtime *util.RuntimeOptions) (_result *CreateDcdnWafGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Subscribe)) {
		body["Subscribe"] = request.Subscribe
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDcdnWafGroup"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDcdnWafGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDcdnWafGroup(request *CreateDcdnWafGroupRequest) (_result *CreateDcdnWafGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDcdnWafGroupResponse{}
	_body, _err := client.CreateDcdnWafGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per user.
 * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
 *
 * @param request CreateDcdnWafPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDcdnWafPolicyResponse
 */
func (client *Client) CreateDcdnWafPolicyWithOptions(request *CreateDcdnWafPolicyRequest, runtime *util.RuntimeOptions) (_result *CreateDcdnWafPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefenseScene)) {
		body["DefenseScene"] = request.DefenseScene
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		body["PolicyName"] = request.PolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyStatus)) {
		body["PolicyStatus"] = request.PolicyStatus
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyType)) {
		body["PolicyType"] = request.PolicyType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDcdnWafPolicy"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDcdnWafPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per user.
 * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
 *
 * @param request CreateDcdnWafPolicyRequest
 * @return CreateDcdnWafPolicyResponse
 */
func (client *Client) CreateDcdnWafPolicy(request *CreateDcdnWafPolicyRequest) (_result *CreateDcdnWafPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDcdnWafPolicyResponse{}
	_body, _err := client.CreateDcdnWafPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   The parameters must comply with the rules of EnvConf. The description of a routine cannot exceed 50 characters in length.
 * *   You can only specify the production and staging environments when you call this operation.
 * *   You can call this operation up to 100 times per second.
 *
 * @param tmpReq CreateRoutineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRoutineResponse
 */
func (client *Client) CreateRoutineWithOptions(tmpReq *CreateRoutineRequest, runtime *util.RuntimeOptions) (_result *CreateRoutineResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateRoutineShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.EnvConf)) {
		request.EnvConfShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.EnvConf, tea.String("EnvConf"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnvConfShrink)) {
		body["EnvConf"] = request.EnvConfShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRoutine"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRoutineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   The parameters must comply with the rules of EnvConf. The description of a routine cannot exceed 50 characters in length.
 * *   You can only specify the production and staging environments when you call this operation.
 * *   You can call this operation up to 100 times per second.
 *
 * @param request CreateRoutineRequest
 * @return CreateRoutineResponse
 */
func (client *Client) CreateRoutine(request *CreateRoutineRequest) (_result *CreateRoutineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRoutineResponse{}
	_body, _err := client.CreateRoutineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 100 times per second per account.
 *
 * @param request CreateSlrAndSlsProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSlrAndSlsProjectResponse
 */
func (client *Client) CreateSlrAndSlsProjectWithOptions(request *CreateSlrAndSlsProjectRequest, runtime *util.RuntimeOptions) (_result *CreateSlrAndSlsProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessType)) {
		body["BusinessType"] = request.BusinessType
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		body["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSlrAndSlsProject"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSlrAndSlsProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 100 times per second per account.
 *
 * @param request CreateSlrAndSlsProjectRequest
 * @return CreateSlrAndSlsProjectResponse
 */
func (client *Client) CreateSlrAndSlsProject(request *CreateSlrAndSlsProjectRequest) (_result *CreateSlrAndSlsProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSlrAndSlsProjectResponse{}
	_body, _err := client.CreateSlrAndSlsProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 3.
 *
 * @param request DeleteDcdnDeliverTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnDeliverTaskResponse
 */
func (client *Client) DeleteDcdnDeliverTaskWithOptions(request *DeleteDcdnDeliverTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnDeliverTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeliverId)) {
		query["DeliverId"] = request.DeliverId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnDeliverTask"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnDeliverTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 3.
 *
 * @param request DeleteDcdnDeliverTaskRequest
 * @return DeleteDcdnDeliverTaskResponse
 */
func (client *Client) DeleteDcdnDeliverTask(request *DeleteDcdnDeliverTaskRequest) (_result *DeleteDcdnDeliverTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnDeliverTaskResponse{}
	_body, _err := client.DeleteDcdnDeliverTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > *   Before you delete your domain name, you need to request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
 * > *   If you call the **DeleteDcdnDomain** operation, all the information about the accelerated domain name is deleted. If you want to disable an accelerated domain name, call the [StopDcdnDomain](~~130622~~) operation.
 * > *   You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnDomainResponse
 */
func (client *Client) DeleteDcdnDomainWithOptions(request *DeleteDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > *   Before you delete your domain name, you need to request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
 * > *   If you call the **DeleteDcdnDomain** operation, all the information about the accelerated domain name is deleted. If you want to disable an accelerated domain name, call the [StopDcdnDomain](~~130622~~) operation.
 * > *   You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteDcdnDomainRequest
 * @return DeleteDcdnDomainResponse
 */
func (client *Client) DeleteDcdnDomain(request *DeleteDcdnDomainRequest) (_result *DeleteDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnDomainResponse{}
	_body, _err := client.DeleteDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   Before you delete your domain name, we recommend that you request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
 * *   This operation deletes all records of the specified accelerated domain name. If you want to temporarily disable an accelerated domain name, call the **StopDcdnIpaDomain** operation.****
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteDcdnIpaDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnIpaDomainResponse
 */
func (client *Client) DeleteDcdnIpaDomainWithOptions(request *DeleteDcdnIpaDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnIpaDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnIpaDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnIpaDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   Before you delete your domain name, we recommend that you request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
 * *   This operation deletes all records of the specified accelerated domain name. If you want to temporarily disable an accelerated domain name, call the **StopDcdnIpaDomain** operation.****
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteDcdnIpaDomainRequest
 * @return DeleteDcdnIpaDomainResponse
 */
func (client *Client) DeleteDcdnIpaDomain(request *DeleteDcdnIpaDomainRequest) (_result *DeleteDcdnIpaDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnIpaDomainResponse{}
	_body, _err := client.DeleteDcdnIpaDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteDcdnIpaSpecificConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnIpaSpecificConfigResponse
 */
func (client *Client) DeleteDcdnIpaSpecificConfigWithOptions(request *DeleteDcdnIpaSpecificConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnIpaSpecificConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnIpaSpecificConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnIpaSpecificConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DeleteDcdnIpaSpecificConfigRequest
 * @return DeleteDcdnIpaSpecificConfigResponse
 */
func (client *Client) DeleteDcdnIpaSpecificConfig(request *DeleteDcdnIpaSpecificConfigRequest) (_result *DeleteDcdnIpaSpecificConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnIpaSpecificConfigResponse{}
	_body, _err := client.DeleteDcdnIpaSpecificConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDcdnKvWithOptions(request *DeleteDcdnKvRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnKvResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnKv"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnKvResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDcdnKv(request *DeleteDcdnKvRequest) (_result *DeleteDcdnKvResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnKvResponse{}
	_body, _err := client.DeleteDcdnKvWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDcdnKvNamespaceWithOptions(request *DeleteDcdnKvNamespaceRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnKvNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnKvNamespace"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnKvNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDcdnKvNamespace(request *DeleteDcdnKvNamespaceRequest) (_result *DeleteDcdnKvNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnKvNamespaceResponse{}
	_body, _err := client.DeleteDcdnKvNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteDcdnRealTimeLogProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnRealTimeLogProjectResponse
 */
func (client *Client) DeleteDcdnRealTimeLogProjectWithOptions(request *DeleteDcdnRealTimeLogProjectRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnRealTimeLogProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnRealTimeLogProject"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnRealTimeLogProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteDcdnRealTimeLogProjectRequest
 * @return DeleteDcdnRealTimeLogProjectResponse
 */
func (client *Client) DeleteDcdnRealTimeLogProject(request *DeleteDcdnRealTimeLogProjectRequest) (_result *DeleteDcdnRealTimeLogProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnRealTimeLogProjectResponse{}
	_body, _err := client.DeleteDcdnRealTimeLogProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DeleteDcdnSpecificConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnSpecificConfigResponse
 */
func (client *Client) DeleteDcdnSpecificConfigWithOptions(request *DeleteDcdnSpecificConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnSpecificConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnSpecificConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnSpecificConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DeleteDcdnSpecificConfigRequest
 * @return DeleteDcdnSpecificConfigResponse
 */
func (client *Client) DeleteDcdnSpecificConfig(request *DeleteDcdnSpecificConfigRequest) (_result *DeleteDcdnSpecificConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnSpecificConfigResponse{}
	_body, _err := client.DeleteDcdnSpecificConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DeleteDcdnSpecificStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnSpecificStagingConfigResponse
 */
func (client *Client) DeleteDcdnSpecificStagingConfigWithOptions(request *DeleteDcdnSpecificStagingConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnSpecificStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnSpecificStagingConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnSpecificStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DeleteDcdnSpecificStagingConfigRequest
 * @return DeleteDcdnSpecificStagingConfigResponse
 */
func (client *Client) DeleteDcdnSpecificStagingConfig(request *DeleteDcdnSpecificStagingConfigRequest) (_result *DeleteDcdnSpecificStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnSpecificStagingConfigResponse{}
	_body, _err := client.DeleteDcdnSpecificStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 3 times per second per account.
 *
 * @param request DeleteDcdnSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnSubTaskResponse
 */
func (client *Client) DeleteDcdnSubTaskWithOptions(runtime *util.RuntimeOptions) (_result *DeleteDcdnSubTaskResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnSubTask"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnSubTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 3 times per second per account.
 *
 * @return DeleteDcdnSubTaskResponse
 */
func (client *Client) DeleteDcdnSubTask() (_result *DeleteDcdnSubTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnSubTaskResponse{}
	_body, _err := client.DeleteDcdnSubTaskWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDcdnWafGroupWithOptions(request *DeleteDcdnWafGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnWafGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnWafGroup"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnWafGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDcdnWafGroup(request *DeleteDcdnWafGroupRequest) (_result *DeleteDcdnWafGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnWafGroupResponse{}
	_body, _err := client.DeleteDcdnWafGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request DeleteDcdnWafPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDcdnWafPolicyResponse
 */
func (client *Client) DeleteDcdnWafPolicyWithOptions(request *DeleteDcdnWafPolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteDcdnWafPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		body["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDcdnWafPolicy"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDcdnWafPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request DeleteDcdnWafPolicyRequest
 * @return DeleteDcdnWafPolicyResponse
 */
func (client *Client) DeleteDcdnWafPolicy(request *DeleteDcdnWafPolicyRequest) (_result *DeleteDcdnWafPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDcdnWafPolicyResponse{}
	_body, _err := client.DeleteDcdnWafPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRoutineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRoutineResponse
 */
func (client *Client) DeleteRoutineWithOptions(request *DeleteRoutineRequest, runtime *util.RuntimeOptions) (_result *DeleteRoutineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRoutine"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRoutineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRoutineRequest
 * @return DeleteRoutineResponse
 */
func (client *Client) DeleteRoutine(request *DeleteRoutineRequest) (_result *DeleteRoutineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRoutineResponse{}
	_body, _err := client.DeleteRoutineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRoutineCodeRevisionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRoutineCodeRevisionResponse
 */
func (client *Client) DeleteRoutineCodeRevisionWithOptions(request *DeleteRoutineCodeRevisionRequest, runtime *util.RuntimeOptions) (_result *DeleteRoutineCodeRevisionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.SelectCodeRevision)) {
		body["SelectCodeRevision"] = request.SelectCodeRevision
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRoutineCodeRevision"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRoutineCodeRevisionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRoutineCodeRevisionRequest
 * @return DeleteRoutineCodeRevisionResponse
 */
func (client *Client) DeleteRoutineCodeRevision(request *DeleteRoutineCodeRevisionRequest) (_result *DeleteRoutineCodeRevisionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRoutineCodeRevisionResponse{}
	_body, _err := client.DeleteRoutineCodeRevisionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   This operation deletes only custom preset canary release environments. You cannot delete production or staging environments.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param tmpReq DeleteRoutineConfEnvsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRoutineConfEnvsResponse
 */
func (client *Client) DeleteRoutineConfEnvsWithOptions(tmpReq *DeleteRoutineConfEnvsRequest, runtime *util.RuntimeOptions) (_result *DeleteRoutineConfEnvsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DeleteRoutineConfEnvsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Envs)) {
		request.EnvsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Envs, tea.String("Envs"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvsShrink)) {
		body["Envs"] = request.EnvsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRoutineConfEnvs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRoutineConfEnvsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   This operation deletes only custom preset canary release environments. You cannot delete production or staging environments.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DeleteRoutineConfEnvsRequest
 * @return DeleteRoutineConfEnvsResponse
 */
func (client *Client) DeleteRoutineConfEnvs(request *DeleteRoutineConfEnvsRequest) (_result *DeleteRoutineConfEnvsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRoutineConfEnvsResponse{}
	_body, _err := client.DeleteRoutineConfEnvsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DescribeDcdnAclFieldsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnAclFieldsResponse
 */
func (client *Client) DescribeDcdnAclFieldsWithOptions(request *DescribeDcdnAclFieldsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnAclFieldsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnAclFields"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnAclFieldsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DescribeDcdnAclFieldsRequest
 * @return DescribeDcdnAclFieldsResponse
 */
func (client *Client) DescribeDcdnAclFields(request *DescribeDcdnAclFieldsRequest) (_result *DescribeDcdnAclFieldsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnAclFieldsResponse{}
	_body, _err := client.DescribeDcdnAclFieldsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
 * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
 * *   You can query data in the last 90 days.
 * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
 * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
 * *   You can call this operation up to five times per second per account.
 *
 * @param request DescribeDcdnBgpBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnBgpBpsDataResponse
 */
func (client *Client) DescribeDcdnBgpBpsDataWithOptions(request *DescribeDcdnBgpBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnBgpBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.DevicePort)) {
		query["DevicePort"] = request.DevicePort
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnBgpBpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnBgpBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
 * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
 * *   You can query data in the last 90 days.
 * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
 * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
 * *   You can call this operation up to five times per second per account.
 *
 * @param request DescribeDcdnBgpBpsDataRequest
 * @return DescribeDcdnBgpBpsDataResponse
 */
func (client *Client) DescribeDcdnBgpBpsData(request *DescribeDcdnBgpBpsDataRequest) (_result *DescribeDcdnBgpBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnBgpBpsDataResponse{}
	_body, _err := client.DescribeDcdnBgpBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both parameters empty.
 * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
 * *   You can query data in the last 90 days.
 * *   The maximum time range that you can specify is 31 days. StartTime specifies the start time and EndTime specifies the end time of the time range.
 * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
 * *   You can call this operation up to five times per second per account.
 *
 * @param request DescribeDcdnBgpTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnBgpTrafficDataResponse
 */
func (client *Client) DescribeDcdnBgpTrafficDataWithOptions(request *DescribeDcdnBgpTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnBgpTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnBgpTrafficData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnBgpTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both parameters empty.
 * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
 * *   You can query data in the last 90 days.
 * *   The maximum time range that you can specify is 31 days. StartTime specifies the start time and EndTime specifies the end time of the time range.
 * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
 * *   You can call this operation up to five times per second per account.
 *
 * @param request DescribeDcdnBgpTrafficDataRequest
 * @return DescribeDcdnBgpTrafficDataResponse
 */
func (client *Client) DescribeDcdnBgpTrafficData(request *DescribeDcdnBgpTrafficDataRequest) (_result *DescribeDcdnBgpTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnBgpTrafficDataResponse{}
	_body, _err := client.DescribeDcdnBgpTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnBlockedRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnBlockedRegionsResponse
 */
func (client *Client) DescribeDcdnBlockedRegionsWithOptions(request *DescribeDcdnBlockedRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnBlockedRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnBlockedRegions"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnBlockedRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnBlockedRegionsRequest
 * @return DescribeDcdnBlockedRegionsResponse
 */
func (client *Client) DescribeDcdnBlockedRegions(request *DescribeDcdnBlockedRegionsRequest) (_result *DescribeDcdnBlockedRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnBlockedRegionsResponse{}
	_body, _err := client.DescribeDcdnBlockedRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnCertificateDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnCertificateDetailResponse
 */
func (client *Client) DescribeDcdnCertificateDetailWithOptions(request *DescribeDcdnCertificateDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnCertificateDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnCertificateDetail"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnCertificateDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnCertificateDetailRequest
 * @return DescribeDcdnCertificateDetailResponse
 */
func (client *Client) DescribeDcdnCertificateDetail(request *DescribeDcdnCertificateDetailRequest) (_result *DescribeDcdnCertificateDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnCertificateDetailResponse{}
	_body, _err := client.DescribeDcdnCertificateDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnCertificateListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnCertificateListResponse
 */
func (client *Client) DescribeDcdnCertificateListWithOptions(request *DescribeDcdnCertificateListRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnCertificateListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnCertificateList"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnCertificateListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnCertificateListRequest
 * @return DescribeDcdnCertificateListResponse
 */
func (client *Client) DescribeDcdnCertificateList(request *DescribeDcdnCertificateListRequest) (_result *DescribeDcdnCertificateListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnCertificateListResponse{}
	_body, _err := client.DescribeDcdnCertificateListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnDdosServiceWithOptions(request *DescribeDcdnDdosServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDdosServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDdosService"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDdosServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnDdosService(request *DescribeDcdnDdosServiceRequest) (_result *DescribeDcdnDdosServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDdosServiceResponse{}
	_body, _err := client.DescribeDcdnDdosServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnDdosSpecInfoWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnDdosSpecInfoResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDdosSpecInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDdosSpecInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnDdosSpecInfo() (_result *DescribeDcdnDdosSpecInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDdosSpecInfoResponse{}
	_body, _err := client.DescribeDcdnDdosSpecInfoWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnDeletedDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDeletedDomainsResponse
 */
func (client *Client) DescribeDcdnDeletedDomainsWithOptions(request *DescribeDcdnDeletedDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDeletedDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDeletedDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDeletedDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnDeletedDomainsRequest
 * @return DescribeDcdnDeletedDomainsResponse
 */
func (client *Client) DescribeDcdnDeletedDomains(request *DescribeDcdnDeletedDomainsRequest) (_result *DescribeDcdnDeletedDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDeletedDomainsResponse{}
	_body, _err := client.DescribeDcdnDeletedDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **
 * **You can call this operation up to three times per second.
 *
 * @param request DescribeDcdnDeliverListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDeliverListResponse
 */
func (client *Client) DescribeDcdnDeliverListWithOptions(request *DescribeDcdnDeliverListRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDeliverListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeliverId)) {
		query["DeliverId"] = request.DeliverId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDeliverList"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDeliverListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **
 * **You can call this operation up to three times per second.
 *
 * @param request DescribeDcdnDeliverListRequest
 * @return DescribeDcdnDeliverListResponse
 */
func (client *Client) DescribeDcdnDeliverList(request *DescribeDcdnDeliverListRequest) (_result *DescribeDcdnDeliverListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDeliverListResponse{}
	_body, _err := client.DescribeDcdnDeliverListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainBpsDataWithOptions(request *DescribeDcdnDomainBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainBpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainBpsDataRequest
 * @return DescribeDcdnDomainBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainBpsData(request *DescribeDcdnDomainBpsDataRequest) (_result *DescribeDcdnDomainBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainBpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set **StartTime** or **EndTime**, the request returns the data collected in the last 24 hours. If you set both **StartTime** and **EndTime**, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainBpsDataByLayerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainBpsDataByLayerResponse
 */
func (client *Client) DescribeDcdnDomainBpsDataByLayerWithOptions(request *DescribeDcdnDomainBpsDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainBpsDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.Layer)) {
		query["Layer"] = request.Layer
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainBpsDataByLayer"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainBpsDataByLayerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set **StartTime** or **EndTime**, the request returns the data collected in the last 24 hours. If you set both **StartTime** and **EndTime**, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainBpsDataByLayerRequest
 * @return DescribeDcdnDomainBpsDataByLayerResponse
 */
func (client *Client) DescribeDcdnDomainBpsDataByLayer(request *DescribeDcdnDomainBpsDataByLayerRequest) (_result *DescribeDcdnDomainBpsDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainBpsDataByLayerResponse{}
	_body, _err := client.DescribeDcdnDomainBpsDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainByCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainByCertificateResponse
 */
func (client *Client) DescribeDcdnDomainByCertificateWithOptions(request *DescribeDcdnDomainByCertificateRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainByCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Exact)) {
		query["Exact"] = request.Exact
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SSLStatus)) {
		query["SSLStatus"] = request.SSLStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainByCertificate"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainByCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainByCertificateRequest
 * @return DescribeDcdnDomainByCertificateResponse
 */
func (client *Client) DescribeDcdnDomainByCertificate(request *DescribeDcdnDomainByCertificateRequest) (_result *DescribeDcdnDomainByCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainByCertificateResponse{}
	_body, _err := client.DescribeDcdnDomainByCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If you do not configure the StartTime or EndTime parameter, data collected over the last 24 hours is queried. If you configure both the StartTime and EndTime parameters, data collected within the specified time range is queried.
 * *   You can query data collected over the last 30 days.
 * *   You can call the RefreshObjectCaches operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnDomainCcActivityLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainCcActivityLogResponse
 */
func (client *Client) DescribeDcdnDomainCcActivityLogWithOptions(request *DescribeDcdnDomainCcActivityLogRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainCcActivityLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TriggerObject)) {
		query["TriggerObject"] = request.TriggerObject
	}

	if !tea.BoolValue(util.IsUnset(request.Value)) {
		query["Value"] = request.Value
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainCcActivityLog"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainCcActivityLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If you do not configure the StartTime or EndTime parameter, data collected over the last 24 hours is queried. If you configure both the StartTime and EndTime parameters, data collected within the specified time range is queried.
 * *   You can query data collected over the last 30 days.
 * *   You can call the RefreshObjectCaches operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnDomainCcActivityLogRequest
 * @return DescribeDcdnDomainCcActivityLogResponse
 */
func (client *Client) DescribeDcdnDomainCcActivityLog(request *DescribeDcdnDomainCcActivityLogRequest) (_result *DescribeDcdnDomainCcActivityLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainCcActivityLogResponse{}
	_body, _err := client.DescribeDcdnDomainCcActivityLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainCertificateInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainCertificateInfoResponse
 */
func (client *Client) DescribeDcdnDomainCertificateInfoWithOptions(request *DescribeDcdnDomainCertificateInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainCertificateInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainCertificateInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainCertificateInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainCertificateInfoRequest
 * @return DescribeDcdnDomainCertificateInfoResponse
 */
func (client *Client) DescribeDcdnDomainCertificateInfo(request *DescribeDcdnDomainCertificateInfoRequest) (_result *DescribeDcdnDomainCertificateInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainCertificateInfoResponse{}
	_body, _err := client.DescribeDcdnDomainCertificateInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 80 times per second per account.
 *
 * @param request DescribeDcdnDomainCnameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainCnameResponse
 */
func (client *Client) DescribeDcdnDomainCnameWithOptions(request *DescribeDcdnDomainCnameRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainCnameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainCname"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainCnameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 80 times per second per account.
 *
 * @param request DescribeDcdnDomainCnameRequest
 * @return DescribeDcdnDomainCnameResponse
 */
func (client *Client) DescribeDcdnDomainCname(request *DescribeDcdnDomainCnameRequest) (_result *DescribeDcdnDomainCnameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainCnameResponse{}
	_body, _err := client.DescribeDcdnDomainCnameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   You can query the configurations of one or more features in a request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainConfigsResponse
 */
func (client *Client) DescribeDcdnDomainConfigsWithOptions(request *DescribeDcdnDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainConfigs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   You can query the configurations of one or more features in a request.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnDomainConfigsRequest
 * @return DescribeDcdnDomainConfigsResponse
 */
func (client *Client) DescribeDcdnDomainConfigs(request *DescribeDcdnDomainConfigsRequest) (_result *DescribeDcdnDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainConfigsResponse{}
	_body, _err := client.DescribeDcdnDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnDomainDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainDetailResponse
 */
func (client *Client) DescribeDcdnDomainDetailWithOptions(request *DescribeDcdnDomainDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainDetail"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnDomainDetailRequest
 * @return DescribeDcdnDomainDetailResponse
 */
func (client *Client) DescribeDcdnDomainDetail(request *DescribeDcdnDomainDetailRequest) (_result *DescribeDcdnDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainDetailResponse{}
	_body, _err := client.DescribeDcdnDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * #
 * *   You can call this operation up to 100 times per second per account.
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity** The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table. |Time granularity |Maximum time range per query |Historical data available |Data delay | -------------- | -------------- | ------ |5 minutes |3 days |93 days |15 minutes |1 hour |31 days |186 days |4 hours |1 day |366 days |366 days |04:00 on the next day
 *
 * @param request DescribeDcdnDomainHitRateDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainHitRateDataResponse
 */
func (client *Client) DescribeDcdnDomainHitRateDataWithOptions(request *DescribeDcdnDomainHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainHitRateData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainHitRateDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * #
 * *   You can call this operation up to 100 times per second per account.
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity** The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table. |Time granularity |Maximum time range per query |Historical data available |Data delay | -------------- | -------------- | ------ |5 minutes |3 days |93 days |15 minutes |1 hour |31 days |186 days |4 hours |1 day |366 days |366 days |04:00 on the next day
 *
 * @param request DescribeDcdnDomainHitRateDataRequest
 * @return DescribeDcdnDomainHitRateDataResponse
 */
func (client *Client) DescribeDcdnDomainHitRateData(request *DescribeDcdnDomainHitRateDataRequest) (_result *DescribeDcdnDomainHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainHitRateDataResponse{}
	_body, _err := client.DescribeDcdnDomainHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * * You can call this operation up to 100 times per second per account.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainHttpCodeDataWithOptions(request *DescribeDcdnDomainHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainHttpCodeData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * * You can call this operation up to 100 times per second per account.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainHttpCodeDataRequest
 * @return DescribeDcdnDomainHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainHttpCodeData(request *DescribeDcdnDomainHttpCodeDataRequest) (_result *DescribeDcdnDomainHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainHttpCodeDataResponse{}
	_body, _err := client.DescribeDcdnDomainHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * You cannot query the distribution of HTTP status codes by IP protocol.
 * * If you do not specify the **StartTime** or **EndTime** parameter, the data that is collected within the last 24 hours is collected. If you specify both the **StartTime** and **EndTime** parameters, the data that is collected within the time range that you specify is collected.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainHttpCodeDataByLayerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainHttpCodeDataByLayerResponse
 */
func (client *Client) DescribeDcdnDomainHttpCodeDataByLayerWithOptions(request *DescribeDcdnDomainHttpCodeDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainHttpCodeDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.Layer)) {
		query["Layer"] = request.Layer
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainHttpCodeDataByLayer"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainHttpCodeDataByLayerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * You cannot query the distribution of HTTP status codes by IP protocol.
 * * If you do not specify the **StartTime** or **EndTime** parameter, the data that is collected within the last 24 hours is collected. If you specify both the **StartTime** and **EndTime** parameters, the data that is collected within the time range that you specify is collected.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainHttpCodeDataByLayerRequest
 * @return DescribeDcdnDomainHttpCodeDataByLayerResponse
 */
func (client *Client) DescribeDcdnDomainHttpCodeDataByLayer(request *DescribeDcdnDomainHttpCodeDataByLayerRequest) (_result *DescribeDcdnDomainHttpCodeDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainHttpCodeDataByLayerResponse{}
	_body, _err := client.DescribeDcdnDomainHttpCodeDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   The bandwidth is measured in bit/s.
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainIpaBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainIpaBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainIpaBpsDataWithOptions(request *DescribeDcdnDomainIpaBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainIpaBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.FixTimeGap)) {
		query["FixTimeGap"] = request.FixTimeGap
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TimeMerge)) {
		query["TimeMerge"] = request.TimeMerge
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainIpaBpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainIpaBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   The bandwidth is measured in bit/s.
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainIpaBpsDataRequest
 * @return DescribeDcdnDomainIpaBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainIpaBpsData(request *DescribeDcdnDomainIpaBpsDataRequest) (_result *DescribeDcdnDomainIpaBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainIpaBpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainIpaBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per user.
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * *   The minimum time granularity at which the data is queried is 5 minutes. The maximum time range for a single query is 31 days. The period within which historical data is available is 366 days. The data latency is no more than 10 minutes.
 *
 * @param request DescribeDcdnDomainIpaConnDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainIpaConnDataResponse
 */
func (client *Client) DescribeDcdnDomainIpaConnDataWithOptions(request *DescribeDcdnDomainIpaConnDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainIpaConnDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.SplitBy)) {
		query["SplitBy"] = request.SplitBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainIpaConnData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainIpaConnDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per user.
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * *   The minimum time granularity at which the data is queried is 5 minutes. The maximum time range for a single query is 31 days. The period within which historical data is available is 366 days. The data latency is no more than 10 minutes.
 *
 * @param request DescribeDcdnDomainIpaConnDataRequest
 * @return DescribeDcdnDomainIpaConnDataResponse
 */
func (client *Client) DescribeDcdnDomainIpaConnData(request *DescribeDcdnDomainIpaConnDataRequest) (_result *DescribeDcdnDomainIpaConnDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainIpaConnDataResponse{}
	_body, _err := client.DescribeDcdnDomainIpaConnDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * *   Unit: bytes.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainIpaTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainIpaTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainIpaTrafficDataWithOptions(request *DescribeDcdnDomainIpaTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainIpaTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.FixTimeGap)) {
		query["FixTimeGap"] = request.FixTimeGap
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TimeMerge)) {
		query["TimeMerge"] = request.TimeMerge
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainIpaTrafficData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainIpaTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * *   Unit: bytes.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainIpaTrafficDataRequest
 * @return DescribeDcdnDomainIpaTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainIpaTrafficData(request *DescribeDcdnDomainIpaTrafficDataRequest) (_result *DescribeDcdnDomainIpaTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainIpaTrafficDataResponse{}
	_body, _err := client.DescribeDcdnDomainIpaTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   You can call this operation up to 100 times per second per account.
 * *   If **StartTime** is set but **EndTime** is not set, the data within the hour that starts from **StartTime** is queried.
 * *   If **EndTime** is set but **StartTime** is not set, the data within the last hour that precedes **EndTime** is queried.
 * *   You can query data of a domain name or all domain names that belong to your account.
 * *   You can view data that is collected over the last seven days. The interval at which data is queried is based on the time range specified by **StartTime** and **EndTime**.
 *     *   **If the time range is shorter than or equal to one hour**, data is queried every minute.
 *     *   **If the time range is longer than 1 hour but shorter than or equal to three days**, data is queried every five minutes.
 *     *   **If the time range is longer than three days but shorter than or equal to seven days**, data is queried every hour.
 *
 * @param request DescribeDcdnDomainIspDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainIspDataResponse
 */
func (client *Client) DescribeDcdnDomainIspDataWithOptions(request *DescribeDcdnDomainIspDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainIspDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainIspData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainIspDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   You can call this operation up to 100 times per second per account.
 * *   If **StartTime** is set but **EndTime** is not set, the data within the hour that starts from **StartTime** is queried.
 * *   If **EndTime** is set but **StartTime** is not set, the data within the last hour that precedes **EndTime** is queried.
 * *   You can query data of a domain name or all domain names that belong to your account.
 * *   You can view data that is collected over the last seven days. The interval at which data is queried is based on the time range specified by **StartTime** and **EndTime**.
 *     *   **If the time range is shorter than or equal to one hour**, data is queried every minute.
 *     *   **If the time range is longer than 1 hour but shorter than or equal to three days**, data is queried every five minutes.
 *     *   **If the time range is longer than three days but shorter than or equal to seven days**, data is queried every hour.
 *
 * @param request DescribeDcdnDomainIspDataRequest
 * @return DescribeDcdnDomainIspDataResponse
 */
func (client *Client) DescribeDcdnDomainIspData(request *DescribeDcdnDomainIspDataRequest) (_result *DescribeDcdnDomainIspDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainIspDataResponse{}
	_body, _err := client.DescribeDcdnDomainIspDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.********
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainLogResponse
 */
func (client *Client) DescribeDcdnDomainLogWithOptions(request *DescribeDcdnDomainLogRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainLog"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.********
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainLogRequest
 * @return DescribeDcdnDomainLogResponse
 */
func (client *Client) DescribeDcdnDomainLog(request *DescribeDcdnDomainLogRequest) (_result *DescribeDcdnDomainLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainLogResponse{}
	_body, _err := client.DescribeDcdnDomainLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, data within the last 10 minutes is queried. You can set both the StartTime and EndTime parameters to specify a time range.
 * *   You can specify one or more accelerated domain names. Separate domain names with commas (,).
 * *   You can query data within the last 90 days.
 * *   The time range cannot exceed 1 hour.
 *
 * @param request DescribeDcdnDomainMultiUsageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainMultiUsageDataResponse
 */
func (client *Client) DescribeDcdnDomainMultiUsageDataWithOptions(request *DescribeDcdnDomainMultiUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainMultiUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainMultiUsageData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainMultiUsageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, data within the last 10 minutes is queried. You can set both the StartTime and EndTime parameters to specify a time range.
 * *   You can specify one or more accelerated domain names. Separate domain names with commas (,).
 * *   You can query data within the last 90 days.
 * *   The time range cannot exceed 1 hour.
 *
 * @param request DescribeDcdnDomainMultiUsageDataRequest
 * @return DescribeDcdnDomainMultiUsageDataResponse
 */
func (client *Client) DescribeDcdnDomainMultiUsageData(request *DescribeDcdnDomainMultiUsageDataRequest) (_result *DescribeDcdnDomainMultiUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainMultiUsageDataResponse{}
	_body, _err := client.DescribeDcdnDomainMultiUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainOriginBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainOriginBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainOriginBpsDataWithOptions(request *DescribeDcdnDomainOriginBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainOriginBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainOriginBpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainOriginBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainOriginBpsDataRequest
 * @return DescribeDcdnDomainOriginBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainOriginBpsData(request *DescribeDcdnDomainOriginBpsDataRequest) (_result *DescribeDcdnDomainOriginBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainOriginBpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainOriginBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * - You can call this operation up to 100 times per second per account.
 * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
 * | Time granularity | Maximum time range per query | Historical data available | Data delay |
 * | ---------------- | ---------------------------- | ------------------------- | ---------- |
 * | 5 minutes | 3 days | 93 days | 15 minutes |
 * | 1 hour | 31 days | 186 days | 4 hours |
 * | 1 day | 366 days | 366 days | 04:00 on the next day |
 *
 * @param request DescribeDcdnDomainOriginTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainOriginTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainOriginTrafficDataWithOptions(request *DescribeDcdnDomainOriginTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainOriginTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainOriginTrafficData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainOriginTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * - You can call this operation up to 100 times per second per account.
 * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
 * | Time granularity | Maximum time range per query | Historical data available | Data delay |
 * | ---------------- | ---------------------------- | ------------------------- | ---------- |
 * | 5 minutes | 3 days | 93 days | 15 minutes |
 * | 1 hour | 31 days | 186 days | 4 hours |
 * | 1 day | 366 days | 366 days | 04:00 on the next day |
 *
 * @param request DescribeDcdnDomainOriginTrafficDataRequest
 * @return DescribeDcdnDomainOriginTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainOriginTrafficData(request *DescribeDcdnDomainOriginTrafficDataRequest) (_result *DescribeDcdnDomainOriginTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainOriginTrafficDataResponse{}
	_body, _err := client.DescribeDcdnDomainOriginTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnDomainPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainPropertyResponse
 */
func (client *Client) DescribeDcdnDomainPropertyWithOptions(request *DescribeDcdnDomainPropertyRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainPropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainProperty"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainPropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnDomainPropertyRequest
 * @return DescribeDcdnDomainPropertyResponse
 */
func (client *Client) DescribeDcdnDomainProperty(request *DescribeDcdnDomainPropertyRequest) (_result *DescribeDcdnDomainPropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainPropertyResponse{}
	_body, _err := client.DescribeDcdnDomainPropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnDomainPvDataWithOptions(request *DescribeDcdnDomainPvDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainPvDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainPvData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainPvDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnDomainPvData(request *DescribeDcdnDomainPvDataRequest) (_result *DescribeDcdnDomainPvDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainPvDataResponse{}
	_body, _err := client.DescribeDcdnDomainPvDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainQpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainQpsDataResponse
 */
func (client *Client) DescribeDcdnDomainQpsDataWithOptions(request *DescribeDcdnDomainQpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainQpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainQpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainQpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainQpsDataRequest
 * @return DescribeDcdnDomainQpsDataResponse
 */
func (client *Client) DescribeDcdnDomainQpsData(request *DescribeDcdnDomainQpsDataRequest) (_result *DescribeDcdnDomainQpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainQpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainQpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainQpsDataByLayerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainQpsDataByLayerResponse
 */
func (client *Client) DescribeDcdnDomainQpsDataByLayerWithOptions(request *DescribeDcdnDomainQpsDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainQpsDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.Layer)) {
		query["Layer"] = request.Layer
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainQpsDataByLayer"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainQpsDataByLayerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 20 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainQpsDataByLayerRequest
 * @return DescribeDcdnDomainQpsDataByLayerResponse
 */
func (client *Client) DescribeDcdnDomainQpsDataByLayer(request *DescribeDcdnDomainQpsDataByLayerRequest) (_result *DescribeDcdnDomainQpsDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainQpsDataByLayerResponse{}
	_body, _err := client.DescribeDcdnDomainQpsDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnDomainRealTimeBpsDataWithOptions(request *DescribeDcdnDomainRealTimeBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeBpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnDomainRealTimeBpsData(request *DescribeDcdnDomainRealTimeBpsDataRequest) (_result *DescribeDcdnDomainRealTimeBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeBpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * | Time granularity | Maximum time range per query | Historical data available | Data delay |
 * |----|------|-----|--------|
 * | 1 minute | 1 hour | 7 days | 5 minutes |
 * | 5 minutes | 3 days | 93 days | 15 minutes |
 * | 1 hour | 31 days | 186 days | 4 hours |
 *
 * @param request DescribeDcdnDomainRealTimeByteHitRateDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeByteHitRateDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeByteHitRateDataWithOptions(request *DescribeDcdnDomainRealTimeByteHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeByteHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeByteHitRateData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeByteHitRateDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * | Time granularity | Maximum time range per query | Historical data available | Data delay |
 * |----|------|-----|--------|
 * | 1 minute | 1 hour | 7 days | 5 minutes |
 * | 5 minutes | 3 days | 93 days | 15 minutes |
 * | 1 hour | 31 days | 186 days | 4 hours |
 *
 * @param request DescribeDcdnDomainRealTimeByteHitRateDataRequest
 * @return DescribeDcdnDomainRealTimeByteHitRateDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeByteHitRateData(request *DescribeDcdnDomainRealTimeByteHitRateDataRequest) (_result *DescribeDcdnDomainRealTimeByteHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeByteHitRateDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeByteHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnDomainRealTimeDetailDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeDetailDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeDetailDataWithOptions(request *DescribeDcdnDomainRealTimeDetailDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeDetailDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeDetailData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeDetailDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnDomainRealTimeDetailDataRequest
 * @return DescribeDcdnDomainRealTimeDetailDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeDetailData(request *DescribeDcdnDomainRealTimeDetailDataRequest) (_result *DescribeDcdnDomainRealTimeDetailDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeDetailDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeDetailDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeHttpCodeDataWithOptions(request *DescribeDcdnDomainRealTimeHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeHttpCodeData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeHttpCodeDataRequest
 * @return DescribeDcdnDomainRealTimeHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeHttpCodeData(request *DescribeDcdnDomainRealTimeHttpCodeDataRequest) (_result *DescribeDcdnDomainRealTimeHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeHttpCodeDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeQpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeQpsDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeQpsDataWithOptions(request *DescribeDcdnDomainRealTimeQpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeQpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeQpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeQpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeQpsDataRequest
 * @return DescribeDcdnDomainRealTimeQpsDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeQpsData(request *DescribeDcdnDomainRealTimeQpsDataRequest) (_result *DescribeDcdnDomainRealTimeQpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeQpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeQpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per user.
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity** The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeReqHitRateDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeReqHitRateDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeReqHitRateDataWithOptions(request *DescribeDcdnDomainRealTimeReqHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeReqHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeReqHitRateData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeReqHitRateDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per user.
 * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity** The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeReqHitRateDataRequest
 * @return DescribeDcdnDomainRealTimeReqHitRateDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeReqHitRateData(request *DescribeDcdnDomainRealTimeReqHitRateDataRequest) (_result *DescribeDcdnDomainRealTimeReqHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeReqHitRateDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeReqHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * | Time granularity | Maximum time range per query | Historical data available | Data delay |
 * |-----|-----|-----|--------|
 * | 1 minute | 1 hour | 7 days | 5 minutes |
 * | 5 minutes | 3 days | 93 days | 15 minutes | | 1 hour | 31 days | 186 days | 4 hours |
 *
 * @param request DescribeDcdnDomainRealTimeSrcBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeSrcBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeSrcBpsDataWithOptions(request *DescribeDcdnDomainRealTimeSrcBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeSrcBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeSrcBpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeSrcBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * | Time granularity | Maximum time range per query | Historical data available | Data delay |
 * |-----|-----|-----|--------|
 * | 1 minute | 1 hour | 7 days | 5 minutes |
 * | 5 minutes | 3 days | 93 days | 15 minutes | | 1 hour | 31 days | 186 days | 4 hours |
 *
 * @param request DescribeDcdnDomainRealTimeSrcBpsDataRequest
 * @return DescribeDcdnDomainRealTimeSrcBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeSrcBpsData(request *DescribeDcdnDomainRealTimeSrcBpsDataRequest) (_result *DescribeDcdnDomainRealTimeSrcBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeSrcBpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeSrcBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(request *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeSrcHttpCodeData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest
 * @return DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeSrcHttpCodeData(request *DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest) (_result *DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeSrcTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeSrcTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeSrcTrafficDataWithOptions(request *DescribeDcdnDomainRealTimeSrcTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeSrcTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeSrcTrafficData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeSrcTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeSrcTrafficDataRequest
 * @return DescribeDcdnDomainRealTimeSrcTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeSrcTrafficData(request *DescribeDcdnDomainRealTimeSrcTrafficDataRequest) (_result *DescribeDcdnDomainRealTimeSrcTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeSrcTrafficDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeSrcTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 50 times per second per user.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRealTimeTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeTrafficDataWithOptions(request *DescribeDcdnDomainRealTimeTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRealTimeTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRealTimeTrafficData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRealTimeTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 50 times per second per user.
 * **Time granularity**
 * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |1 minute|1 hour|7 days|5 minutes|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 *
 * @param request DescribeDcdnDomainRealTimeTrafficDataRequest
 * @return DescribeDcdnDomainRealTimeTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainRealTimeTrafficData(request *DescribeDcdnDomainRealTimeTrafficDataRequest) (_result *DescribeDcdnDomainRealTimeTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRealTimeTrafficDataResponse{}
	_body, _err := client.DescribeDcdnDomainRealTimeTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If you do not specify the StartTime and EndTime parameters, the data within the last 24 hours is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainRegionDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainRegionDataResponse
 */
func (client *Client) DescribeDcdnDomainRegionDataWithOptions(request *DescribeDcdnDomainRegionDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainRegionDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainRegionData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainRegionDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If you do not specify the StartTime and EndTime parameters, the data within the last 24 hours is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnDomainRegionDataRequest
 * @return DescribeDcdnDomainRegionDataResponse
 */
func (client *Client) DescribeDcdnDomainRegionData(request *DescribeDcdnDomainRegionDataRequest) (_result *DescribeDcdnDomainRegionDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainRegionDataResponse{}
	_body, _err := client.DescribeDcdnDomainRegionDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the accelerated domain.
 *
 * @param request DescribeDcdnDomainStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainStagingConfigResponse
 */
func (client *Client) DescribeDcdnDomainStagingConfigWithOptions(request *DescribeDcdnDomainStagingConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainStagingConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the accelerated domain.
 *
 * @param request DescribeDcdnDomainStagingConfigRequest
 * @return DescribeDcdnDomainStagingConfigResponse
 */
func (client *Client) DescribeDcdnDomainStagingConfig(request *DescribeDcdnDomainStagingConfigRequest) (_result *DescribeDcdnDomainStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainStagingConfigResponse{}
	_body, _err := client.DescribeDcdnDomainStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set the StartTime parameter, the data on the previous day is queried.
 * *   You can specify only one domain name.
 *
 * @param request DescribeDcdnDomainTopReferVisitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainTopReferVisitResponse
 */
func (client *Client) DescribeDcdnDomainTopReferVisitWithOptions(request *DescribeDcdnDomainTopReferVisitRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainTopReferVisitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainTopReferVisit"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainTopReferVisitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set the StartTime parameter, the data on the previous day is queried.
 * *   You can specify only one domain name.
 *
 * @param request DescribeDcdnDomainTopReferVisitRequest
 * @return DescribeDcdnDomainTopReferVisitResponse
 */
func (client *Client) DescribeDcdnDomainTopReferVisit(request *DescribeDcdnDomainTopReferVisitRequest) (_result *DescribeDcdnDomainTopReferVisitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainTopReferVisitResponse{}
	_body, _err := client.DescribeDcdnDomainTopReferVisitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can query data in the last seven days.
 *
 * @param request DescribeDcdnDomainTopUrlVisitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainTopUrlVisitResponse
 */
func (client *Client) DescribeDcdnDomainTopUrlVisitWithOptions(request *DescribeDcdnDomainTopUrlVisitRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainTopUrlVisitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainTopUrlVisit"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainTopUrlVisitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can query data in the last seven days.
 *
 * @param request DescribeDcdnDomainTopUrlVisitRequest
 * @return DescribeDcdnDomainTopUrlVisitResponse
 */
func (client *Client) DescribeDcdnDomainTopUrlVisit(request *DescribeDcdnDomainTopUrlVisitRequest) (_result *DescribeDcdnDomainTopUrlVisitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainTopUrlVisitResponse{}
	_body, _err := client.DescribeDcdnDomainTopUrlVisitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * * You can call this operation up to 100 times per second per account.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainTrafficDataWithOptions(request *DescribeDcdnDomainTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainTrafficData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * * You can call this operation up to 100 times per second per account.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainTrafficDataRequest
 * @return DescribeDcdnDomainTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainTrafficData(request *DescribeDcdnDomainTrafficDataRequest) (_result *DescribeDcdnDomainTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainTrafficDataResponse{}
	_body, _err := client.DescribeDcdnDomainTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * Usage data includes traffic (measured in bytes), bandwidth values (measured in bit/s), and the number of requests.
 * **Time granularity**:
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainUsageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainUsageDataResponse
 */
func (client *Client) DescribeDcdnDomainUsageDataWithOptions(request *DescribeDcdnDomainUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.DataProtocol)) {
		query["DataProtocol"] = request.DataProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Field)) {
		query["Field"] = request.Field
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainUsageData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainUsageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 10 times per second per account.
 * * Usage data includes traffic (measured in bytes), bandwidth values (measured in bit/s), and the number of requests.
 * **Time granularity**:
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainUsageDataRequest
 * @return DescribeDcdnDomainUsageDataResponse
 */
func (client *Client) DescribeDcdnDomainUsageData(request *DescribeDcdnDomainUsageDataRequest) (_result *DescribeDcdnDomainUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainUsageDataResponse{}
	_body, _err := client.DescribeDcdnDomainUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   You can specify only one accelerated domain name or all the accelerated domain names that belong to your Alibaba Cloud account.
 *
 * @param request DescribeDcdnDomainUvDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainUvDataResponse
 */
func (client *Client) DescribeDcdnDomainUvDataWithOptions(request *DescribeDcdnDomainUvDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainUvDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainUvData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainUvDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   You can specify only one accelerated domain name or all the accelerated domain names that belong to your Alibaba Cloud account.
 *
 * @param request DescribeDcdnDomainUvDataRequest
 * @return DescribeDcdnDomainUvDataResponse
 */
func (client *Client) DescribeDcdnDomainUvData(request *DescribeDcdnDomainUvDataRequest) (_result *DescribeDcdnDomainUvDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainUvDataResponse{}
	_body, _err := client.DescribeDcdnDomainUvDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainWebsocketBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainWebsocketBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainWebsocketBpsDataWithOptions(request *DescribeDcdnDomainWebsocketBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainWebsocketBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainWebsocketBpsData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainWebsocketBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainWebsocketBpsDataRequest
 * @return DescribeDcdnDomainWebsocketBpsDataResponse
 */
func (client *Client) DescribeDcdnDomainWebsocketBpsData(request *DescribeDcdnDomainWebsocketBpsDataRequest) (_result *DescribeDcdnDomainWebsocketBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainWebsocketBpsDataResponse{}
	_body, _err := client.DescribeDcdnDomainWebsocketBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 100 times per second per account.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainWebsocketHttpCodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainWebsocketHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainWebsocketHttpCodeDataWithOptions(request *DescribeDcdnDomainWebsocketHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainWebsocketHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainWebsocketHttpCodeData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainWebsocketHttpCodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 100 times per second per account.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainWebsocketHttpCodeDataRequest
 * @return DescribeDcdnDomainWebsocketHttpCodeDataResponse
 */
func (client *Client) DescribeDcdnDomainWebsocketHttpCodeData(request *DescribeDcdnDomainWebsocketHttpCodeDataRequest) (_result *DescribeDcdnDomainWebsocketHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainWebsocketHttpCodeDataResponse{}
	_body, _err := client.DescribeDcdnDomainWebsocketHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainWebsocketTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnDomainWebsocketTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainWebsocketTrafficDataWithOptions(request *DescribeDcdnDomainWebsocketTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnDomainWebsocketTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnDomainWebsocketTrafficData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnDomainWebsocketTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * * You can call this operation up to 100 times per second per account.
 * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
 * **Time granularity**
 * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
 * |Time granularity|Maximum time range per query|Historical data available|Data delay|
 * |---|---|---|---|
 * |5 minutes|3 days|93 days|15 minutes|
 * |1 hour|31 days|186 days|4 hours|
 * |1 day|366 days|366 days|04:00 on the next day|
 *
 * @param request DescribeDcdnDomainWebsocketTrafficDataRequest
 * @return DescribeDcdnDomainWebsocketTrafficDataResponse
 */
func (client *Client) DescribeDcdnDomainWebsocketTrafficData(request *DescribeDcdnDomainWebsocketTrafficDataRequest) (_result *DescribeDcdnDomainWebsocketTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnDomainWebsocketTrafficDataResponse{}
	_body, _err := client.DescribeDcdnDomainWebsocketTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   The minimum time granularity for a query is 1 hour. The maximum time span for a query is 24 hours. The time period within which historical data is available for a query is 366 days.
 *
 * @param request DescribeDcdnErUsageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnErUsageDataResponse
 */
func (client *Client) DescribeDcdnErUsageDataWithOptions(request *DescribeDcdnErUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnErUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RoutineID)) {
		query["RoutineID"] = request.RoutineID
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.SplitBy)) {
		query["SplitBy"] = request.SplitBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnErUsageData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnErUsageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   The minimum time granularity for a query is 1 hour. The maximum time span for a query is 24 hours. The time period within which historical data is available for a query is 366 days.
 *
 * @param request DescribeDcdnErUsageDataRequest
 * @return DescribeDcdnErUsageDataResponse
 */
func (client *Client) DescribeDcdnErUsageData(request *DescribeDcdnErUsageDataRequest) (_result *DescribeDcdnErUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnErUsageDataResponse{}
	_body, _err := client.DescribeDcdnErUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you specify IP addresses or CIDR blocks, IP addresses that are effective and corresponding expiration time are returned. If you do not specify IP addresses or CIDR blocks, all effective IP addresses and the corresponding expiration time are returned.
 * *   The results are written to OSS and returned as OSS URLs. The OSS objects are in the format of `IP address-Corresponding expiration time`. The expiration time is in the yyyy-MM-dd HH:mm:ss format.
 * *   You can share URLs of OSS objects with others. The shared URLs are valid for three days.
 *
 * @param request DescribeDcdnFullDomainsBlockIPConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnFullDomainsBlockIPConfigResponse
 */
func (client *Client) DescribeDcdnFullDomainsBlockIPConfigWithOptions(request *DescribeDcdnFullDomainsBlockIPConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnFullDomainsBlockIPConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnFullDomainsBlockIPConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnFullDomainsBlockIPConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you specify IP addresses or CIDR blocks, IP addresses that are effective and corresponding expiration time are returned. If you do not specify IP addresses or CIDR blocks, all effective IP addresses and the corresponding expiration time are returned.
 * *   The results are written to OSS and returned as OSS URLs. The OSS objects are in the format of `IP address-Corresponding expiration time`. The expiration time is in the yyyy-MM-dd HH:mm:ss format.
 * *   You can share URLs of OSS objects with others. The shared URLs are valid for three days.
 *
 * @param request DescribeDcdnFullDomainsBlockIPConfigRequest
 * @return DescribeDcdnFullDomainsBlockIPConfigResponse
 */
func (client *Client) DescribeDcdnFullDomainsBlockIPConfig(request *DescribeDcdnFullDomainsBlockIPConfigRequest) (_result *DescribeDcdnFullDomainsBlockIPConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnFullDomainsBlockIPConfigResponse{}
	_body, _err := client.DescribeDcdnFullDomainsBlockIPConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   For a specified IP addresses and time range, the time when the IP address was delivered to the edge and the corresponding result are returned.
 * *   If a specified IP address or CIDR block has multiple blocking records in a specified time range, the records are sorted by delivery time in descending order.
 * *   The maximum time range to query is 90 days.
 * *   If no blocking record exists or delivery fails for the given IP address and time range, the delivery time is empty.
 *
 * @param request DescribeDcdnFullDomainsBlockIPHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnFullDomainsBlockIPHistoryResponse
 */
func (client *Client) DescribeDcdnFullDomainsBlockIPHistoryWithOptions(request *DescribeDcdnFullDomainsBlockIPHistoryRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnFullDomainsBlockIPHistoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IPList)) {
		body["IPList"] = request.IPList
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		body["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnFullDomainsBlockIPHistory"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnFullDomainsBlockIPHistoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   For a specified IP addresses and time range, the time when the IP address was delivered to the edge and the corresponding result are returned.
 * *   If a specified IP address or CIDR block has multiple blocking records in a specified time range, the records are sorted by delivery time in descending order.
 * *   The maximum time range to query is 90 days.
 * *   If no blocking record exists or delivery fails for the given IP address and time range, the delivery time is empty.
 *
 * @param request DescribeDcdnFullDomainsBlockIPHistoryRequest
 * @return DescribeDcdnFullDomainsBlockIPHistoryResponse
 */
func (client *Client) DescribeDcdnFullDomainsBlockIPHistory(request *DescribeDcdnFullDomainsBlockIPHistoryRequest) (_result *DescribeDcdnFullDomainsBlockIPHistoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnFullDomainsBlockIPHistoryResponse{}
	_body, _err := client.DescribeDcdnFullDomainsBlockIPHistoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request DescribeDcdnHttpsDomainListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnHttpsDomainListResponse
 */
func (client *Client) DescribeDcdnHttpsDomainListWithOptions(request *DescribeDcdnHttpsDomainListRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnHttpsDomainListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnHttpsDomainList"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnHttpsDomainListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 100.
 *
 * @param request DescribeDcdnHttpsDomainListRequest
 * @return DescribeDcdnHttpsDomainListResponse
 */
func (client *Client) DescribeDcdnHttpsDomainList(request *DescribeDcdnHttpsDomainListRequest) (_result *DescribeDcdnHttpsDomainListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnHttpsDomainListResponse{}
	_body, _err := client.DescribeDcdnHttpsDomainListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnIpInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnIpInfoResponse
 */
func (client *Client) DescribeDcdnIpInfoWithOptions(request *DescribeDcdnIpInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnIpInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IP)) {
		query["IP"] = request.IP
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnIpInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnIpInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnIpInfoRequest
 * @return DescribeDcdnIpInfoResponse
 */
func (client *Client) DescribeDcdnIpInfo(request *DescribeDcdnIpInfoRequest) (_result *DescribeDcdnIpInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnIpInfoResponse{}
	_body, _err := client.DescribeDcdnIpInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnIpaDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnIpaDomainConfigsResponse
 */
func (client *Client) DescribeDcdnIpaDomainConfigsWithOptions(request *DescribeDcdnIpaDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnIpaDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnIpaDomainConfigs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnIpaDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnIpaDomainConfigsRequest
 * @return DescribeDcdnIpaDomainConfigsResponse
 */
func (client *Client) DescribeDcdnIpaDomainConfigs(request *DescribeDcdnIpaDomainConfigsRequest) (_result *DescribeDcdnIpaDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnIpaDomainConfigsResponse{}
	_body, _err := client.DescribeDcdnIpaDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnIpaDomainDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnIpaDomainDetailResponse
 */
func (client *Client) DescribeDcdnIpaDomainDetailWithOptions(request *DescribeDcdnIpaDomainDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnIpaDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnIpaDomainDetail"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnIpaDomainDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnIpaDomainDetailRequest
 * @return DescribeDcdnIpaDomainDetailResponse
 */
func (client *Client) DescribeDcdnIpaDomainDetail(request *DescribeDcdnIpaDomainDetailRequest) (_result *DescribeDcdnIpaDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnIpaDomainDetailResponse{}
	_body, _err := client.DescribeDcdnIpaDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **
 * **The maximum number of times that each user can call this operation per second is 20.
 *
 * @param request DescribeDcdnIpaServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnIpaServiceResponse
 */
func (client *Client) DescribeDcdnIpaServiceWithOptions(request *DescribeDcdnIpaServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnIpaServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnIpaService"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnIpaServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **
 * **The maximum number of times that each user can call this operation per second is 20.
 *
 * @param request DescribeDcdnIpaServiceRequest
 * @return DescribeDcdnIpaServiceResponse
 */
func (client *Client) DescribeDcdnIpaService(request *DescribeDcdnIpaServiceRequest) (_result *DescribeDcdnIpaServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnIpaServiceResponse{}
	_body, _err := client.DescribeDcdnIpaServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnIpaUserDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnIpaUserDomainsResponse
 */
func (client *Client) DescribeDcdnIpaUserDomainsWithOptions(request *DescribeDcdnIpaUserDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnIpaUserDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckDomainShow)) {
		query["CheckDomainShow"] = request.CheckDomainShow
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainSearchType)) {
		query["DomainSearchType"] = request.DomainSearchType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainStatus)) {
		query["DomainStatus"] = request.DomainStatus
	}

	if !tea.BoolValue(util.IsUnset(request.FuncFilter)) {
		query["FuncFilter"] = request.FuncFilter
	}

	if !tea.BoolValue(util.IsUnset(request.FuncId)) {
		query["FuncId"] = request.FuncId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnIpaUserDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnIpaUserDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnIpaUserDomainsRequest
 * @return DescribeDcdnIpaUserDomainsResponse
 */
func (client *Client) DescribeDcdnIpaUserDomains(request *DescribeDcdnIpaUserDomainsRequest) (_result *DescribeDcdnIpaUserDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnIpaUserDomainsResponse{}
	_body, _err := client.DescribeDcdnIpaUserDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnKvAccountWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnKvAccountResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnKvAccount"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnKvAccountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnKvAccount() (_result *DescribeDcdnKvAccountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnKvAccountResponse{}
	_body, _err := client.DescribeDcdnKvAccountWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnKvAccountStatusWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnKvAccountStatusResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnKvAccountStatus"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnKvAccountStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnKvAccountStatus() (_result *DescribeDcdnKvAccountStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnKvAccountStatusResponse{}
	_body, _err := client.DescribeDcdnKvAccountStatusWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnKvNamespaceWithOptions(request *DescribeDcdnKvNamespaceRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnKvNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnKvNamespace"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnKvNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnKvNamespace(request *DescribeDcdnKvNamespaceRequest) (_result *DescribeDcdnKvNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnKvNamespaceResponse{}
	_body, _err := client.DescribeDcdnKvNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnL2IpsWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnL2IpsResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnL2Ips"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnL2IpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnL2Ips() (_result *DescribeDcdnL2IpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnL2IpsResponse{}
	_body, _err := client.DescribeDcdnL2IpsWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnL2VipsWithOptions(request *DescribeDcdnL2VipsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnL2VipsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnL2Vips"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnL2VipsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnL2Vips(request *DescribeDcdnL2VipsRequest) (_result *DescribeDcdnL2VipsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnL2VipsResponse{}
	_body, _err := client.DescribeDcdnL2VipsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this API operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnRealTimeDeliveryFieldRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnRealTimeDeliveryFieldResponse
 */
func (client *Client) DescribeDcdnRealTimeDeliveryFieldWithOptions(request *DescribeDcdnRealTimeDeliveryFieldRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnRealTimeDeliveryFieldResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessType)) {
		query["BusinessType"] = request.BusinessType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnRealTimeDeliveryField"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnRealTimeDeliveryFieldResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this API operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnRealTimeDeliveryFieldRequest
 * @return DescribeDcdnRealTimeDeliveryFieldResponse
 */
func (client *Client) DescribeDcdnRealTimeDeliveryField(request *DescribeDcdnRealTimeDeliveryFieldRequest) (_result *DescribeDcdnRealTimeDeliveryFieldResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnRealTimeDeliveryFieldResponse{}
	_body, _err := client.DescribeDcdnRealTimeDeliveryFieldWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   You can call the **RefreshDcdnObjectCaches** operation to refresh content and call the **PreloadDcdnObjectCaches** operation to prefetch content.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnRefreshQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnRefreshQuotaResponse
 */
func (client *Client) DescribeDcdnRefreshQuotaWithOptions(request *DescribeDcdnRefreshQuotaRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnRefreshQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnRefreshQuota"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnRefreshQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   You can call the **RefreshDcdnObjectCaches** operation to refresh content and call the **PreloadDcdnObjectCaches** operation to prefetch content.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnRefreshQuotaRequest
 * @return DescribeDcdnRefreshQuotaResponse
 */
func (client *Client) DescribeDcdnRefreshQuota(request *DescribeDcdnRefreshQuotaRequest) (_result *DescribeDcdnRefreshQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnRefreshQuotaResponse{}
	_body, _err := client.DescribeDcdnRefreshQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   You can query data within the last three days.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnRefreshTaskByIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnRefreshTaskByIdResponse
 */
func (client *Client) DescribeDcdnRefreshTaskByIdWithOptions(request *DescribeDcdnRefreshTaskByIdRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnRefreshTaskByIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnRefreshTaskById"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnRefreshTaskByIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   You can query data within the last three days.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnRefreshTaskByIdRequest
 * @return DescribeDcdnRefreshTaskByIdResponse
 */
func (client *Client) DescribeDcdnRefreshTaskById(request *DescribeDcdnRefreshTaskByIdRequest) (_result *DescribeDcdnRefreshTaskByIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnRefreshTaskByIdResponse{}
	_body, _err := client.DescribeDcdnRefreshTaskByIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   You can query the refresh or prefetch tasks by ID or URL.
 * *   You can set both **TaskId** and **ObjectPath** in a request. If you do not set **TaskId** or **ObjectPath**, the data in the last 3 days on the first page is returned. By default, a maximum of 20 entries can be displayed on each page.
 * *   If you specify **DomainName** or **Status**, you must also specify **ObjectType**.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnRefreshTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnRefreshTasksResponse
 */
func (client *Client) DescribeDcdnRefreshTasksWithOptions(request *DescribeDcdnRefreshTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnRefreshTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnRefreshTasks"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnRefreshTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   You can query the refresh or prefetch tasks by ID or URL.
 * *   You can set both **TaskId** and **ObjectPath** in a request. If you do not set **TaskId** or **ObjectPath**, the data in the last 3 days on the first page is returned. By default, a maximum of 20 entries can be displayed on each page.
 * *   If you specify **DomainName** or **Status**, you must also specify **ObjectType**.
 * *   You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnRefreshTasksRequest
 * @return DescribeDcdnRefreshTasksResponse
 */
func (client *Client) DescribeDcdnRefreshTasks(request *DescribeDcdnRefreshTasksRequest) (_result *DescribeDcdnRefreshTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnRefreshTasksResponse{}
	_body, _err := client.DescribeDcdnRefreshTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnRegionAndIspRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnRegionAndIspResponse
 */
func (client *Client) DescribeDcdnRegionAndIspWithOptions(request *DescribeDcdnRegionAndIspRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnRegionAndIspResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnRegionAndIsp"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnRegionAndIspResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnRegionAndIspRequest
 * @return DescribeDcdnRegionAndIspResponse
 */
func (client *Client) DescribeDcdnRegionAndIsp(request *DescribeDcdnRegionAndIspRequest) (_result *DescribeDcdnRegionAndIspResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnRegionAndIspResponse{}
	_body, _err := client.DescribeDcdnRegionAndIspWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DescribeDcdnReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnReportResponse
 */
func (client *Client) DescribeDcdnReportWithOptions(request *DescribeDcdnReportRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.HttpCode)) {
		query["HttpCode"] = request.HttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.IsOverseas)) {
		query["IsOverseas"] = request.IsOverseas
	}

	if !tea.BoolValue(util.IsUnset(request.ReportId)) {
		query["ReportId"] = request.ReportId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnReport"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request DescribeDcdnReportRequest
 * @return DescribeDcdnReportResponse
 */
func (client *Client) DescribeDcdnReport(request *DescribeDcdnReportRequest) (_result *DescribeDcdnReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnReportResponse{}
	_body, _err := client.DescribeDcdnReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > * This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
 * > * You can call this operation up to three times per second per account.
 *
 * @param request DescribeDcdnReportListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnReportListResponse
 */
func (client *Client) DescribeDcdnReportListWithOptions(request *DescribeDcdnReportListRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnReportListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ReportId)) {
		query["ReportId"] = request.ReportId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnReportList"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnReportListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > * This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
 * > * You can call this operation up to three times per second per account.
 *
 * @param request DescribeDcdnReportListRequest
 * @return DescribeDcdnReportListResponse
 */
func (client *Client) DescribeDcdnReportList(request *DescribeDcdnReportListRequest) (_result *DescribeDcdnReportListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnReportListResponse{}
	_body, _err := client.DescribeDcdnReportListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnSLSRealTimeLogTypeWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnSLSRealTimeLogTypeResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnSLSRealTimeLogType"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnSLSRealTimeLogTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnSLSRealTimeLogType() (_result *DescribeDcdnSLSRealTimeLogTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnSLSRealTimeLogTypeResponse{}
	_body, _err := client.DescribeDcdnSLSRealTimeLogTypeWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnSLSRealtimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnSLSRealtimeLogDeliveryResponse
 */
func (client *Client) DescribeDcdnSLSRealtimeLogDeliveryWithOptions(request *DescribeDcdnSLSRealtimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnSLSRealtimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnSLSRealtimeLogDelivery"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnSLSRealtimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnSLSRealtimeLogDeliveryRequest
 * @return DescribeDcdnSLSRealtimeLogDeliveryResponse
 */
func (client *Client) DescribeDcdnSLSRealtimeLogDelivery(request *DescribeDcdnSLSRealtimeLogDeliveryRequest) (_result *DescribeDcdnSLSRealtimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnSLSRealtimeLogDeliveryResponse{}
	_body, _err := client.DescribeDcdnSLSRealtimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnSMCertificateDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnSMCertificateDetailResponse
 */
func (client *Client) DescribeDcdnSMCertificateDetailWithOptions(request *DescribeDcdnSMCertificateDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnSMCertificateDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnSMCertificateDetail"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnSMCertificateDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnSMCertificateDetailRequest
 * @return DescribeDcdnSMCertificateDetailResponse
 */
func (client *Client) DescribeDcdnSMCertificateDetail(request *DescribeDcdnSMCertificateDetailRequest) (_result *DescribeDcdnSMCertificateDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnSMCertificateDetailResponse{}
	_body, _err := client.DescribeDcdnSMCertificateDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnSMCertificateListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnSMCertificateListResponse
 */
func (client *Client) DescribeDcdnSMCertificateListWithOptions(request *DescribeDcdnSMCertificateListRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnSMCertificateListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnSMCertificateList"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnSMCertificateListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnSMCertificateListRequest
 * @return DescribeDcdnSMCertificateListResponse
 */
func (client *Client) DescribeDcdnSMCertificateList(request *DescribeDcdnSMCertificateListRequest) (_result *DescribeDcdnSMCertificateListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnSMCertificateListResponse{}
	_body, _err := client.DescribeDcdnSMCertificateListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnSecFuncInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnSecFuncInfoResponse
 */
func (client *Client) DescribeDcdnSecFuncInfoWithOptions(request *DescribeDcdnSecFuncInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnSecFuncInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.SecFuncType)) {
		query["SecFuncType"] = request.SecFuncType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnSecFuncInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnSecFuncInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnSecFuncInfoRequest
 * @return DescribeDcdnSecFuncInfoResponse
 */
func (client *Client) DescribeDcdnSecFuncInfo(request *DescribeDcdnSecFuncInfoRequest) (_result *DescribeDcdnSecFuncInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnSecFuncInfoResponse{}
	_body, _err := client.DescribeDcdnSecFuncInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnSecSpecInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnSecSpecInfoResponse
 */
func (client *Client) DescribeDcdnSecSpecInfoWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnSecSpecInfoResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnSecSpecInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnSecSpecInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @return DescribeDcdnSecSpecInfoResponse
 */
func (client *Client) DescribeDcdnSecSpecInfo() (_result *DescribeDcdnSecSpecInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnSecSpecInfoResponse{}
	_body, _err := client.DescribeDcdnSecSpecInfoWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnServiceResponse
 */
func (client *Client) DescribeDcdnServiceWithOptions(request *DescribeDcdnServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnService"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnServiceRequest
 * @return DescribeDcdnServiceResponse
 */
func (client *Client) DescribeDcdnService(request *DescribeDcdnServiceRequest) (_result *DescribeDcdnServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnServiceResponse{}
	_body, _err := client.DescribeDcdnServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnStagingIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnStagingIpResponse
 */
func (client *Client) DescribeDcdnStagingIpWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnStagingIpResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnStagingIp"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnStagingIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @return DescribeDcdnStagingIpResponse
 */
func (client *Client) DescribeDcdnStagingIp() (_result *DescribeDcdnStagingIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnStagingIpResponse{}
	_body, _err := client.DescribeDcdnStagingIpWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   By default, this operation queries all custom operations reports. However, only one operations report can be displayed. Therefore, only one operations report is returned.
 * *   You can call this API operation up to three times per second per account.
 *
 * @param request DescribeDcdnSubListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnSubListResponse
 */
func (client *Client) DescribeDcdnSubListWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnSubListResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnSubList"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnSubListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   By default, this operation queries all custom operations reports. However, only one operations report can be displayed. Therefore, only one operations report is returned.
 * *   You can call this API operation up to three times per second per account.
 *
 * @return DescribeDcdnSubListResponse
 */
func (client *Client) DescribeDcdnSubList() (_result *DescribeDcdnSubListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnSubListResponse{}
	_body, _err := client.DescribeDcdnSubListWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnTagResourcesResponse
 */
func (client *Client) DescribeDcdnTagResourcesWithOptions(request *DescribeDcdnTagResourcesRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnTagResources"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request DescribeDcdnTagResourcesRequest
 * @return DescribeDcdnTagResourcesResponse
 */
func (client *Client) DescribeDcdnTagResources(request *DescribeDcdnTagResourcesRequest) (_result *DescribeDcdnTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnTagResourcesResponse{}
	_body, _err := client.DescribeDcdnTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you do not specify the StartTime and EndTime parameters, the data within the current month is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
 *
 * @param request DescribeDcdnTopDomainsByFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnTopDomainsByFlowResponse
 */
func (client *Client) DescribeDcdnTopDomainsByFlowWithOptions(request *DescribeDcdnTopDomainsByFlowRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnTopDomainsByFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Limit)) {
		query["Limit"] = request.Limit
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnTopDomainsByFlow"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnTopDomainsByFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you do not specify the StartTime and EndTime parameters, the data within the current month is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
 *
 * @param request DescribeDcdnTopDomainsByFlowRequest
 * @return DescribeDcdnTopDomainsByFlowResponse
 */
func (client *Client) DescribeDcdnTopDomainsByFlow(request *DescribeDcdnTopDomainsByFlowRequest) (_result *DescribeDcdnTopDomainsByFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnTopDomainsByFlowResponse{}
	_body, _err := client.DescribeDcdnTopDomainsByFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserBillHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserBillHistoryResponse
 */
func (client *Client) DescribeDcdnUserBillHistoryWithOptions(request *DescribeDcdnUserBillHistoryRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserBillHistoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserBillHistory"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserBillHistoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserBillHistoryRequest
 * @return DescribeDcdnUserBillHistoryResponse
 */
func (client *Client) DescribeDcdnUserBillHistory(request *DescribeDcdnUserBillHistoryRequest) (_result *DescribeDcdnUserBillHistoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserBillHistoryResponse{}
	_body, _err := client.DescribeDcdnUserBillHistoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnUserBillTypeWithOptions(request *DescribeDcdnUserBillTypeRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserBillTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserBillType"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserBillTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnUserBillType(request *DescribeDcdnUserBillTypeRequest) (_result *DescribeDcdnUserBillTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserBillTypeResponse{}
	_body, _err := client.DescribeDcdnUserBillTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserCertificateExpireCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserCertificateExpireCountResponse
 */
func (client *Client) DescribeDcdnUserCertificateExpireCountWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnUserCertificateExpireCountResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserCertificateExpireCount"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserCertificateExpireCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return DescribeDcdnUserCertificateExpireCountResponse
 */
func (client *Client) DescribeDcdnUserCertificateExpireCount() (_result *DescribeDcdnUserCertificateExpireCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserCertificateExpireCountResponse{}
	_body, _err := client.DescribeDcdnUserCertificateExpireCountWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnUserConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserConfigsResponse
 */
func (client *Client) DescribeDcdnUserConfigsWithOptions(request *DescribeDcdnUserConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionName)) {
		query["FunctionName"] = request.FunctionName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserConfigs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeDcdnUserConfigsRequest
 * @return DescribeDcdnUserConfigsResponse
 */
func (client *Client) DescribeDcdnUserConfigs(request *DescribeDcdnUserConfigsRequest) (_result *DescribeDcdnUserConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserConfigsResponse{}
	_body, _err := client.DescribeDcdnUserConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 80 times per second per account.
 *
 * @param request DescribeDcdnUserDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserDomainsResponse
 */
func (client *Client) DescribeDcdnUserDomainsWithOptions(request *DescribeDcdnUserDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChangeEndTime)) {
		query["ChangeEndTime"] = request.ChangeEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ChangeStartTime)) {
		query["ChangeStartTime"] = request.ChangeStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.CheckDomainShow)) {
		query["CheckDomainShow"] = request.CheckDomainShow
	}

	if !tea.BoolValue(util.IsUnset(request.Coverage)) {
		query["Coverage"] = request.Coverage
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainSearchType)) {
		query["DomainSearchType"] = request.DomainSearchType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainStatus)) {
		query["DomainStatus"] = request.DomainStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.WebSiteType)) {
		query["WebSiteType"] = request.WebSiteType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 80 times per second per account.
 *
 * @param request DescribeDcdnUserDomainsRequest
 * @return DescribeDcdnUserDomainsResponse
 */
func (client *Client) DescribeDcdnUserDomains(request *DescribeDcdnUserDomainsRequest) (_result *DescribeDcdnUserDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserDomainsResponse{}
	_body, _err := client.DescribeDcdnUserDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserDomainsByFuncRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserDomainsByFuncResponse
 */
func (client *Client) DescribeDcdnUserDomainsByFuncWithOptions(request *DescribeDcdnUserDomainsByFuncRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserDomainsByFuncResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FuncFilter)) {
		query["FuncFilter"] = request.FuncFilter
	}

	if !tea.BoolValue(util.IsUnset(request.FuncId)) {
		query["FuncId"] = request.FuncId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserDomainsByFunc"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserDomainsByFuncResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserDomainsByFuncRequest
 * @return DescribeDcdnUserDomainsByFuncResponse
 */
func (client *Client) DescribeDcdnUserDomainsByFunc(request *DescribeDcdnUserDomainsByFuncRequest) (_result *DescribeDcdnUserDomainsByFuncResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserDomainsByFuncResponse{}
	_body, _err := client.DescribeDcdnUserDomainsByFuncWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 30.
 *
 * @param request DescribeDcdnUserQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserQuotaResponse
 */
func (client *Client) DescribeDcdnUserQuotaWithOptions(request *DescribeDcdnUserQuotaRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserQuota"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  The maximum number of times that each user can call this operation per second is 30.
 *
 * @param request DescribeDcdnUserQuotaRequest
 * @return DescribeDcdnUserQuotaResponse
 */
func (client *Client) DescribeDcdnUserQuota(request *DescribeDcdnUserQuotaRequest) (_result *DescribeDcdnUserQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserQuotaResponse{}
	_body, _err := client.DescribeDcdnUserQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserRealTimeDeliveryFieldRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserRealTimeDeliveryFieldResponse
 */
func (client *Client) DescribeDcdnUserRealTimeDeliveryFieldWithOptions(request *DescribeDcdnUserRealTimeDeliveryFieldRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserRealTimeDeliveryFieldResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserRealTimeDeliveryField"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserRealTimeDeliveryFieldResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserRealTimeDeliveryFieldRequest
 * @return DescribeDcdnUserRealTimeDeliveryFieldResponse
 */
func (client *Client) DescribeDcdnUserRealTimeDeliveryField(request *DescribeDcdnUserRealTimeDeliveryFieldRequest) (_result *DescribeDcdnUserRealTimeDeliveryFieldResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserRealTimeDeliveryFieldResponse{}
	_body, _err := client.DescribeDcdnUserRealTimeDeliveryFieldWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **
 * **The maximum number of times that each user can call this operation per second is 30.
 *
 * @param request DescribeDcdnUserResourcePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserResourcePackageResponse
 */
func (client *Client) DescribeDcdnUserResourcePackageWithOptions(request *DescribeDcdnUserResourcePackageRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserResourcePackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserResourcePackage"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserResourcePackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **
 * **The maximum number of times that each user can call this operation per second is 30.
 *
 * @param request DescribeDcdnUserResourcePackageRequest
 * @return DescribeDcdnUserResourcePackageResponse
 */
func (client *Client) DescribeDcdnUserResourcePackage(request *DescribeDcdnUserResourcePackageRequest) (_result *DescribeDcdnUserResourcePackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserResourcePackageResponse{}
	_body, _err := client.DescribeDcdnUserResourcePackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnUserSecDropRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserSecDropResponse
 */
func (client *Client) DescribeDcdnUserSecDropWithOptions(request *DescribeDcdnUserSecDropRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserSecDropResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Data)) {
		query["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Metric)) {
		query["Metric"] = request.Metric
	}

	if !tea.BoolValue(util.IsUnset(request.SecFunc)) {
		query["SecFunc"] = request.SecFunc
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserSecDrop"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserSecDropResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnUserSecDropRequest
 * @return DescribeDcdnUserSecDropResponse
 */
func (client *Client) DescribeDcdnUserSecDrop(request *DescribeDcdnUserSecDropRequest) (_result *DescribeDcdnUserSecDropResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserSecDropResponse{}
	_body, _err := client.DescribeDcdnUserSecDropWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnUserSecDropByMinuteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserSecDropByMinuteResponse
 */
func (client *Client) DescribeDcdnUserSecDropByMinuteWithOptions(request *DescribeDcdnUserSecDropByMinuteRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnUserSecDropByMinuteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Object)) {
		query["Object"] = request.Object
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.SecFunc)) {
		query["SecFunc"] = request.SecFunc
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserSecDropByMinute"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserSecDropByMinuteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnUserSecDropByMinuteRequest
 * @return DescribeDcdnUserSecDropByMinuteResponse
 */
func (client *Client) DescribeDcdnUserSecDropByMinute(request *DescribeDcdnUserSecDropByMinuteRequest) (_result *DescribeDcdnUserSecDropByMinuteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserSecDropByMinuteResponse{}
	_body, _err := client.DescribeDcdnUserSecDropByMinuteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnUserTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnUserTagsResponse
 */
func (client *Client) DescribeDcdnUserTagsWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnUserTagsResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnUserTags"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnUserTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return DescribeDcdnUserTagsResponse
 */
func (client *Client) DescribeDcdnUserTags() (_result *DescribeDcdnUserTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnUserTagsResponse{}
	_body, _err := client.DescribeDcdnUserTagsWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnVerifyContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnVerifyContentResponse
 */
func (client *Client) DescribeDcdnVerifyContentWithOptions(request *DescribeDcdnVerifyContentRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnVerifyContentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnVerifyContent"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnVerifyContentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnVerifyContentRequest
 * @return DescribeDcdnVerifyContentResponse
 */
func (client *Client) DescribeDcdnVerifyContent(request *DescribeDcdnVerifyContentRequest) (_result *DescribeDcdnVerifyContentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnVerifyContentResponse{}
	_body, _err := client.DescribeDcdnVerifyContentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnWafBotAppKeyWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnWafBotAppKeyResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafBotAppKey"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafBotAppKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnWafBotAppKey() (_result *DescribeDcdnWafBotAppKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafBotAppKeyResponse{}
	_body, _err := client.DescribeDcdnWafBotAppKeyWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnWafDefaultRulesWithOptions(request *DescribeDcdnWafDefaultRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafDefaultRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.QueryArgs)) {
		query["QueryArgs"] = request.QueryArgs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafDefaultRules"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafDefaultRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnWafDefaultRules(request *DescribeDcdnWafDefaultRulesRequest) (_result *DescribeDcdnWafDefaultRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafDefaultRulesResponse{}
	_body, _err := client.DescribeDcdnWafDefaultRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnWafDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafDomainResponse
 */
func (client *Client) DescribeDcdnWafDomainWithOptions(request *DescribeDcdnWafDomainRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 50 times per second per account.
 *
 * @param request DescribeDcdnWafDomainRequest
 * @return DescribeDcdnWafDomainResponse
 */
func (client *Client) DescribeDcdnWafDomain(request *DescribeDcdnWafDomainRequest) (_result *DescribeDcdnWafDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafDomainResponse{}
	_body, _err := client.DescribeDcdnWafDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafDomainDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafDomainDetailResponse
 */
func (client *Client) DescribeDcdnWafDomainDetailWithOptions(request *DescribeDcdnWafDomainDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafDomainDetail"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafDomainDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafDomainDetailRequest
 * @return DescribeDcdnWafDomainDetailResponse
 */
func (client *Client) DescribeDcdnWafDomainDetail(request *DescribeDcdnWafDomainDetailRequest) (_result *DescribeDcdnWafDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafDomainDetailResponse{}
	_body, _err := client.DescribeDcdnWafDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafDomainsResponse
 */
func (client *Client) DescribeDcdnWafDomainsWithOptions(request *DescribeDcdnWafDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryArgs)) {
		query["QueryArgs"] = request.QueryArgs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafDomainsRequest
 * @return DescribeDcdnWafDomainsResponse
 */
func (client *Client) DescribeDcdnWafDomains(request *DescribeDcdnWafDomainsRequest) (_result *DescribeDcdnWafDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafDomainsResponse{}
	_body, _err := client.DescribeDcdnWafDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafFilterInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafFilterInfoResponse
 */
func (client *Client) DescribeDcdnWafFilterInfoWithOptions(request *DescribeDcdnWafFilterInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafFilterInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefenseScenes)) {
		query["DefenseScenes"] = request.DefenseScenes
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafFilterInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafFilterInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafFilterInfoRequest
 * @return DescribeDcdnWafFilterInfoResponse
 */
func (client *Client) DescribeDcdnWafFilterInfo(request *DescribeDcdnWafFilterInfoRequest) (_result *DescribeDcdnWafFilterInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafFilterInfoResponse{}
	_body, _err := client.DescribeDcdnWafFilterInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafGeoInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafGeoInfoResponse
 */
func (client *Client) DescribeDcdnWafGeoInfoWithOptions(request *DescribeDcdnWafGeoInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafGeoInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafGeoInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafGeoInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafGeoInfoRequest
 * @return DescribeDcdnWafGeoInfoResponse
 */
func (client *Client) DescribeDcdnWafGeoInfo(request *DescribeDcdnWafGeoInfoRequest) (_result *DescribeDcdnWafGeoInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafGeoInfoResponse{}
	_body, _err := client.DescribeDcdnWafGeoInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnWafGroupWithOptions(request *DescribeDcdnWafGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryArgs)) {
		query["QueryArgs"] = request.QueryArgs
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafGroup"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnWafGroup(request *DescribeDcdnWafGroupRequest) (_result *DescribeDcdnWafGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafGroupResponse{}
	_body, _err := client.DescribeDcdnWafGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDcdnWafGroupsWithOptions(request *DescribeDcdnWafGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryArgs)) {
		query["QueryArgs"] = request.QueryArgs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafGroups"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDcdnWafGroups(request *DescribeDcdnWafGroupsRequest) (_result *DescribeDcdnWafGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafGroupsResponse{}
	_body, _err := client.DescribeDcdnWafGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   The log data is collected every hour.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnWafLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafLogsResponse
 */
func (client *Client) DescribeDcdnWafLogsWithOptions(request *DescribeDcdnWafLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafLogs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
 * *   The log data is collected every hour.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeDcdnWafLogsRequest
 * @return DescribeDcdnWafLogsResponse
 */
func (client *Client) DescribeDcdnWafLogs(request *DescribeDcdnWafLogsRequest) (_result *DescribeDcdnWafLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafLogsResponse{}
	_body, _err := client.DescribeDcdnWafLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafPoliciesResponse
 */
func (client *Client) DescribeDcdnWafPoliciesWithOptions(request *DescribeDcdnWafPoliciesRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryArgs)) {
		query["QueryArgs"] = request.QueryArgs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafPolicies"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafPoliciesRequest
 * @return DescribeDcdnWafPoliciesResponse
 */
func (client *Client) DescribeDcdnWafPolicies(request *DescribeDcdnWafPoliciesRequest) (_result *DescribeDcdnWafPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafPoliciesResponse{}
	_body, _err := client.DescribeDcdnWafPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafPolicyResponse
 */
func (client *Client) DescribeDcdnWafPolicyWithOptions(request *DescribeDcdnWafPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafPolicy"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafPolicyRequest
 * @return DescribeDcdnWafPolicyResponse
 */
func (client *Client) DescribeDcdnWafPolicy(request *DescribeDcdnWafPolicyRequest) (_result *DescribeDcdnWafPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafPolicyResponse{}
	_body, _err := client.DescribeDcdnWafPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per user.
 *
 * @param request DescribeDcdnWafPolicyDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafPolicyDomainsResponse
 */
func (client *Client) DescribeDcdnWafPolicyDomainsWithOptions(request *DescribeDcdnWafPolicyDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafPolicyDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafPolicyDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafPolicyDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per user.
 *
 * @param request DescribeDcdnWafPolicyDomainsRequest
 * @return DescribeDcdnWafPolicyDomainsResponse
 */
func (client *Client) DescribeDcdnWafPolicyDomains(request *DescribeDcdnWafPolicyDomainsRequest) (_result *DescribeDcdnWafPolicyDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafPolicyDomainsResponse{}
	_body, _err := client.DescribeDcdnWafPolicyDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafPolicyValidDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafPolicyValidDomainsResponse
 */
func (client *Client) DescribeDcdnWafPolicyValidDomainsWithOptions(request *DescribeDcdnWafPolicyValidDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafPolicyValidDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefenseScene)) {
		query["DefenseScene"] = request.DefenseScene
	}

	if !tea.BoolValue(util.IsUnset(request.DomainNameLike)) {
		query["DomainNameLike"] = request.DomainNameLike
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafPolicyValidDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafPolicyValidDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafPolicyValidDomainsRequest
 * @return DescribeDcdnWafPolicyValidDomainsResponse
 */
func (client *Client) DescribeDcdnWafPolicyValidDomains(request *DescribeDcdnWafPolicyValidDomainsRequest) (_result *DescribeDcdnWafPolicyValidDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafPolicyValidDomainsResponse{}
	_body, _err := client.DescribeDcdnWafPolicyValidDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * #
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafRuleResponse
 */
func (client *Client) DescribeDcdnWafRuleWithOptions(request *DescribeDcdnWafRuleRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafRule"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * #
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafRuleRequest
 * @return DescribeDcdnWafRuleResponse
 */
func (client *Client) DescribeDcdnWafRule(request *DescribeDcdnWafRuleRequest) (_result *DescribeDcdnWafRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafRuleResponse{}
	_body, _err := client.DescribeDcdnWafRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafRulesResponse
 */
func (client *Client) DescribeDcdnWafRulesWithOptions(request *DescribeDcdnWafRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryArgs)) {
		query["QueryArgs"] = request.QueryArgs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafRules"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafRulesRequest
 * @return DescribeDcdnWafRulesResponse
 */
func (client *Client) DescribeDcdnWafRules(request *DescribeDcdnWafRulesRequest) (_result *DescribeDcdnWafRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafRulesResponse{}
	_body, _err := client.DescribeDcdnWafRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per user.
 *
 * @param request DescribeDcdnWafScenesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafScenesResponse
 */
func (client *Client) DescribeDcdnWafScenesWithOptions(request *DescribeDcdnWafScenesRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafScenesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefenseScenes)) {
		query["DefenseScenes"] = request.DefenseScenes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafScenes"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafScenesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per user.
 *
 * @param request DescribeDcdnWafScenesRequest
 * @return DescribeDcdnWafScenesResponse
 */
func (client *Client) DescribeDcdnWafScenes(request *DescribeDcdnWafScenesRequest) (_result *DescribeDcdnWafScenesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafScenesResponse{}
	_body, _err := client.DescribeDcdnWafScenesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * # Usage notes
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafServiceResponse
 */
func (client *Client) DescribeDcdnWafServiceWithOptions(request *DescribeDcdnWafServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafService"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * # Usage notes
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafServiceRequest
 * @return DescribeDcdnWafServiceResponse
 */
func (client *Client) DescribeDcdnWafService(request *DescribeDcdnWafServiceRequest) (_result *DescribeDcdnWafServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafServiceResponse{}
	_body, _err := client.DescribeDcdnWafServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnWafSpecInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafSpecInfoResponse
 */
func (client *Client) DescribeDcdnWafSpecInfoWithOptions(runtime *util.RuntimeOptions) (_result *DescribeDcdnWafSpecInfoResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafSpecInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafSpecInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation up to 20 times per second per account.
 *
 * @return DescribeDcdnWafSpecInfoResponse
 */
func (client *Client) DescribeDcdnWafSpecInfo() (_result *DescribeDcdnWafSpecInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafSpecInfoResponse{}
	_body, _err := client.DescribeDcdnWafSpecInfoWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   The minimum time granularity for a query is 5 minutes. The maximum time span for a query is 31 days. The time period within which historical data is available for a query is 90 days.
 *
 * @param request DescribeDcdnWafUsageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnWafUsageDataResponse
 */
func (client *Client) DescribeDcdnWafUsageDataWithOptions(request *DescribeDcdnWafUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnWafUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.SplitBy)) {
		query["SplitBy"] = request.SplitBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnWafUsageData"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnWafUsageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 10 times per second per account.
 * *   The minimum time granularity for a query is 5 minutes. The maximum time span for a query is 31 days. The time period within which historical data is available for a query is 90 days.
 *
 * @param request DescribeDcdnWafUsageDataRequest
 * @return DescribeDcdnWafUsageDataResponse
 */
func (client *Client) DescribeDcdnWafUsageData(request *DescribeDcdnWafUsageDataRequest) (_result *DescribeDcdnWafUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnWafUsageDataResponse{}
	_body, _err := client.DescribeDcdnWafUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnsecServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDcdnsecServiceResponse
 */
func (client *Client) DescribeDcdnsecServiceWithOptions(request *DescribeDcdnsecServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeDcdnsecServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDcdnsecService"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDcdnsecServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeDcdnsecServiceRequest
 * @return DescribeDcdnsecServiceResponse
 */
func (client *Client) DescribeDcdnsecService(request *DescribeDcdnsecServiceRequest) (_result *DescribeDcdnsecServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDcdnsecServiceResponse{}
	_body, _err := client.DescribeDcdnsecServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDdosAllEventListWithOptions(request *DescribeDdosAllEventListRequest, runtime *util.RuntimeOptions) (_result *DescribeDdosAllEventListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDdosAllEventList"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDdosAllEventListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDdosAllEventList(request *DescribeDdosAllEventListRequest) (_result *DescribeDdosAllEventListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDdosAllEventListResponse{}
	_body, _err := client.DescribeDdosAllEventListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEncryptRoutineUidWithOptions(runtime *util.RuntimeOptions) (_result *DescribeEncryptRoutineUidResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeEncryptRoutineUid"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEncryptRoutineUidResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEncryptRoutineUid() (_result *DescribeEncryptRoutineUidResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEncryptRoutineUidResponse{}
	_body, _err := client.DescribeEncryptRoutineUidWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHighlightInfoWithOptions(request *DescribeHighlightInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeHighlightInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TraceId)) {
		query["TraceId"] = request.TraceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHighlightInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHighlightInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHighlightInfo(request *DescribeHighlightInfoRequest) (_result *DescribeHighlightInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHighlightInfoResponse{}
	_body, _err := client.DescribeHighlightInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRDDomainConfigWithOptions(request *DescribeRDDomainConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeRDDomainConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionName)) {
		query["FunctionName"] = request.FunctionName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRDDomainConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRDDomainConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRDDomainConfig(request *DescribeRDDomainConfigRequest) (_result *DescribeRDDomainConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRDDomainConfigResponse{}
	_body, _err := client.DescribeRDDomainConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A domain name can be in one of the following states:
 * *   online
 * *   offline
 * *   configuring
 * *   configure_failed
 * *   checking
 * *   check_failed
 *
 * @param request DescribeRDDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRDDomainsResponse
 */
func (client *Client) DescribeRDDomainsWithOptions(request *DescribeRDDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeRDDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRDDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRDDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A domain name can be in one of the following states:
 * *   online
 * *   offline
 * *   configuring
 * *   configure_failed
 * *   checking
 * *   check_failed
 *
 * @param request DescribeRDDomainsRequest
 * @return DescribeRDDomainsResponse
 */
func (client *Client) DescribeRDDomains(request *DescribeRDDomainsRequest) (_result *DescribeRDDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRDDomainsResponse{}
	_body, _err := client.DescribeRDDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRoutineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRoutineResponse
 */
func (client *Client) DescribeRoutineWithOptions(request *DescribeRoutineRequest, runtime *util.RuntimeOptions) (_result *DescribeRoutineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRoutine"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRoutineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRoutineRequest
 * @return DescribeRoutineResponse
 */
func (client *Client) DescribeRoutine(request *DescribeRoutineRequest) (_result *DescribeRoutineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRoutineResponse{}
	_body, _err := client.DescribeRoutineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRoutineCanaryEnvsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRoutineCanaryEnvsResponse
 */
func (client *Client) DescribeRoutineCanaryEnvsWithOptions(runtime *util.RuntimeOptions) (_result *DescribeRoutineCanaryEnvsResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeRoutineCanaryEnvs"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRoutineCanaryEnvsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return DescribeRoutineCanaryEnvsResponse
 */
func (client *Client) DescribeRoutineCanaryEnvs() (_result *DescribeRoutineCanaryEnvsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRoutineCanaryEnvsResponse{}
	_body, _err := client.DescribeRoutineCanaryEnvsWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRoutineCodeRevisionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRoutineCodeRevisionResponse
 */
func (client *Client) DescribeRoutineCodeRevisionWithOptions(request *DescribeRoutineCodeRevisionRequest, runtime *util.RuntimeOptions) (_result *DescribeRoutineCodeRevisionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.SelectCodeRevision)) {
		body["SelectCodeRevision"] = request.SelectCodeRevision
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRoutineCodeRevision"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRoutineCodeRevisionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRoutineCodeRevisionRequest
 * @return DescribeRoutineCodeRevisionResponse
 */
func (client *Client) DescribeRoutineCodeRevision(request *DescribeRoutineCodeRevisionRequest) (_result *DescribeRoutineCodeRevisionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRoutineCodeRevisionResponse{}
	_body, _err := client.DescribeRoutineCodeRevisionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRoutineRelatedDomainsWithOptions(request *DescribeRoutineRelatedDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeRoutineRelatedDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRoutineRelatedDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRoutineRelatedDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRoutineRelatedDomains(request *DescribeRoutineRelatedDomainsRequest) (_result *DescribeRoutineRelatedDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRoutineRelatedDomainsResponse{}
	_body, _err := client.DescribeRoutineRelatedDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRoutineSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRoutineSpecResponse
 */
func (client *Client) DescribeRoutineSpecWithOptions(runtime *util.RuntimeOptions) (_result *DescribeRoutineSpecResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeRoutineSpec"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRoutineSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @return DescribeRoutineSpecResponse
 */
func (client *Client) DescribeRoutineSpec() (_result *DescribeRoutineSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRoutineSpecResponse{}
	_body, _err := client.DescribeRoutineSpecWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 100 times per second per account.
 *
 * @param request DescribeRoutineUserInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRoutineUserInfoResponse
 */
func (client *Client) DescribeRoutineUserInfoWithOptions(runtime *util.RuntimeOptions) (_result *DescribeRoutineUserInfoResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("DescribeRoutineUserInfo"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRoutineUserInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 100 times per second per account.
 *
 * @return DescribeRoutineUserInfoResponse
 */
func (client *Client) DescribeRoutineUserInfo() (_result *DescribeRoutineUserInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRoutineUserInfoResponse{}
	_body, _err := client.DescribeRoutineUserInfoWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **
 * **The maximum number of times that each user can call this operation per second is 20.
 *
 * @param request DescribeUserDcdnIpaStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserDcdnIpaStatusResponse
 */
func (client *Client) DescribeUserDcdnIpaStatusWithOptions(request *DescribeUserDcdnIpaStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeUserDcdnIpaStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserDcdnIpaStatus"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserDcdnIpaStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **
 * **The maximum number of times that each user can call this operation per second is 20.
 *
 * @param request DescribeUserDcdnIpaStatusRequest
 * @return DescribeUserDcdnIpaStatusResponse
 */
func (client *Client) DescribeUserDcdnIpaStatus(request *DescribeUserDcdnIpaStatusRequest) (_result *DescribeUserDcdnIpaStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserDcdnIpaStatusResponse{}
	_body, _err := client.DescribeUserDcdnIpaStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeUserDcdnStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserDcdnStatusResponse
 */
func (client *Client) DescribeUserDcdnStatusWithOptions(request *DescribeUserDcdnStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeUserDcdnStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserDcdnStatus"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserDcdnStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeUserDcdnStatusRequest
 * @return DescribeUserDcdnStatusResponse
 */
func (client *Client) DescribeUserDcdnStatus(request *DescribeUserDcdnStatusRequest) (_result *DescribeUserDcdnStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserDcdnStatusResponse{}
	_body, _err := client.DescribeUserDcdnStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeUserErStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserErStatusResponse
 */
func (client *Client) DescribeUserErStatusWithOptions(request *DescribeUserErStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeUserErStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserErStatus"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserErStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request DescribeUserErStatusRequest
 * @return DescribeUserErStatusResponse
 */
func (client *Client) DescribeUserErStatus(request *DescribeUserErStatusRequest) (_result *DescribeUserErStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserErStatusResponse{}
	_body, _err := client.DescribeUserErStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeUserLogserviceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUserLogserviceStatusResponse
 */
func (client *Client) DescribeUserLogserviceStatusWithOptions(request *DescribeUserLogserviceStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeUserLogserviceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserLogserviceStatus"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserLogserviceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 20 times per second per account.
 *
 * @param request DescribeUserLogserviceStatusRequest
 * @return DescribeUserLogserviceStatusResponse
 */
func (client *Client) DescribeUserLogserviceStatus(request *DescribeUserLogserviceStatusRequest) (_result *DescribeUserLogserviceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserLogserviceStatusResponse{}
	_body, _err := client.DescribeUserLogserviceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   This operation modifies only the specified configurations. Other configurations remain unchanged.
 * *   If you want to delete a setting, delete the parameter value.
 * *   This operation can add canary release environments. Make sure that the environment names comply with the naming rules. Otherwise, you will fail to add the environments.
 * *   Dynamic Route for CDN (DCDN) provides 35 canary release environments. Among these environments, 34 are deployed in China and 1 is deployed outside China. The canary release environments are:
 *     *   Outside China: presetCanaryOverseas.
 *     *   In China: The 34 canary release environments are named in the format of presetCanaryXX. For example, presetCanaryBeijing represents the canary release environment in Beijing. A canary release environment is in each of the following regions: Anhui, Beijing, Chongqing, Fujian, Gansu, Guangdong, Guangxi, Guizhou, Hainan, Hebei, Heilongjiang, Henan, Hong Kong, Hubei, Hunan, Jiangsu, Jiangxi, Jilin, Liaoning, Macao, Neimenggu, Ningxia, Qinghai, Shaanxi, Shandong, Shanghai, Shanxi, Sichuan, Taiwan, Tianjin, Xinjiang, Xizang, Yunan, and Zhejiang.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param tmpReq EditRoutineConfRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EditRoutineConfResponse
 */
func (client *Client) EditRoutineConfWithOptions(tmpReq *EditRoutineConfRequest, runtime *util.RuntimeOptions) (_result *EditRoutineConfResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &EditRoutineConfShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.EnvConf)) {
		request.EnvConfShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.EnvConf, tea.String("EnvConf"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnvConfShrink)) {
		body["EnvConf"] = request.EnvConfShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("EditRoutineConf"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EditRoutineConfResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   This operation modifies only the specified configurations. Other configurations remain unchanged.
 * *   If you want to delete a setting, delete the parameter value.
 * *   This operation can add canary release environments. Make sure that the environment names comply with the naming rules. Otherwise, you will fail to add the environments.
 * *   Dynamic Route for CDN (DCDN) provides 35 canary release environments. Among these environments, 34 are deployed in China and 1 is deployed outside China. The canary release environments are:
 *     *   Outside China: presetCanaryOverseas.
 *     *   In China: The 34 canary release environments are named in the format of presetCanaryXX. For example, presetCanaryBeijing represents the canary release environment in Beijing. A canary release environment is in each of the following regions: Anhui, Beijing, Chongqing, Fujian, Gansu, Guangdong, Guangxi, Guizhou, Hainan, Hebei, Heilongjiang, Henan, Hong Kong, Hubei, Hunan, Jiangsu, Jiangxi, Jilin, Liaoning, Macao, Neimenggu, Ningxia, Qinghai, Shaanxi, Shandong, Shanghai, Shanxi, Sichuan, Taiwan, Tianjin, Xinjiang, Xizang, Yunan, and Zhejiang.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request EditRoutineConfRequest
 * @return EditRoutineConfResponse
 */
func (client *Client) EditRoutineConf(request *EditRoutineConfRequest) (_result *EditRoutineConfResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EditRoutineConfResponse{}
	_body, _err := client.EditRoutineConfWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDcdnKvWithOptions(request *GetDcdnKvRequest, runtime *util.RuntimeOptions) (_result *GetDcdnKvResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDcdnKv"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDcdnKvResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDcdnKv(request *GetDcdnKvRequest) (_result *GetDcdnKvResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDcdnKvResponse{}
	_body, _err := client.GetDcdnKvWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDcdnKvWithOptions(request *ListDcdnKvRequest, runtime *util.RuntimeOptions) (_result *ListDcdnKvResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDcdnKv"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDcdnKvResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDcdnKv(request *ListDcdnKvRequest) (_result *ListDcdnKvResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDcdnKvResponse{}
	_body, _err := client.ListDcdnKvWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListDcdnRealTimeDeliveryProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDcdnRealTimeDeliveryProjectResponse
 */
func (client *Client) ListDcdnRealTimeDeliveryProjectWithOptions(request *ListDcdnRealTimeDeliveryProjectRequest, runtime *util.RuntimeOptions) (_result *ListDcdnRealTimeDeliveryProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessType)) {
		query["BusinessType"] = request.BusinessType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDcdnRealTimeDeliveryProject"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDcdnRealTimeDeliveryProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ListDcdnRealTimeDeliveryProjectRequest
 * @return ListDcdnRealTimeDeliveryProjectResponse
 */
func (client *Client) ListDcdnRealTimeDeliveryProject(request *ListDcdnRealTimeDeliveryProjectRequest) (_result *ListDcdnRealTimeDeliveryProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDcdnRealTimeDeliveryProjectResponse{}
	_body, _err := client.ListDcdnRealTimeDeliveryProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ModifyDCdnDomainSchdmByPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDCdnDomainSchdmByPropertyResponse
 */
func (client *Client) ModifyDCdnDomainSchdmByPropertyWithOptions(request *ModifyDCdnDomainSchdmByPropertyRequest, runtime *util.RuntimeOptions) (_result *ModifyDCdnDomainSchdmByPropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Property)) {
		query["Property"] = request.Property
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDCdnDomainSchdmByProperty"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDCdnDomainSchdmByPropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request ModifyDCdnDomainSchdmByPropertyRequest
 * @return ModifyDCdnDomainSchdmByPropertyResponse
 */
func (client *Client) ModifyDCdnDomainSchdmByProperty(request *ModifyDCdnDomainSchdmByPropertyRequest) (_result *ModifyDCdnDomainSchdmByPropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDCdnDomainSchdmByPropertyResponse{}
	_body, _err := client.ModifyDCdnDomainSchdmByPropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDcdnWafGroupWithOptions(request *ModifyDcdnWafGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyDcdnWafGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Rules)) {
		body["Rules"] = request.Rules
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDcdnWafGroup"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDcdnWafGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDcdnWafGroup(request *ModifyDcdnWafGroupRequest) (_result *ModifyDcdnWafGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDcdnWafGroupResponse{}
	_body, _err := client.ModifyDcdnWafGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request ModifyDcdnWafPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDcdnWafPolicyResponse
 */
func (client *Client) ModifyDcdnWafPolicyWithOptions(request *ModifyDcdnWafPolicyRequest, runtime *util.RuntimeOptions) (_result *ModifyDcdnWafPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		body["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		body["PolicyName"] = request.PolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyStatus)) {
		body["PolicyStatus"] = request.PolicyStatus
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDcdnWafPolicy"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDcdnWafPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 *
 * @param request ModifyDcdnWafPolicyRequest
 * @return ModifyDcdnWafPolicyResponse
 */
func (client *Client) ModifyDcdnWafPolicy(request *ModifyDcdnWafPolicyRequest) (_result *ModifyDcdnWafPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDcdnWafPolicyResponse{}
	_body, _err := client.ModifyDcdnWafPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * # Usage notes
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
 *
 * @param request ModifyDcdnWafPolicyDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDcdnWafPolicyDomainsResponse
 */
func (client *Client) ModifyDcdnWafPolicyDomainsWithOptions(request *ModifyDcdnWafPolicyDomainsRequest, runtime *util.RuntimeOptions) (_result *ModifyDcdnWafPolicyDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BindDomains)) {
		body["BindDomains"] = request.BindDomains
	}

	if !tea.BoolValue(util.IsUnset(request.Method)) {
		body["Method"] = request.Method
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		body["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.UnbindDomains)) {
		body["UnbindDomains"] = request.UnbindDomains
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDcdnWafPolicyDomains"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDcdnWafPolicyDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * # Usage notes
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
 *
 * @param request ModifyDcdnWafPolicyDomainsRequest
 * @return ModifyDcdnWafPolicyDomainsResponse
 */
func (client *Client) ModifyDcdnWafPolicyDomains(request *ModifyDcdnWafPolicyDomainsRequest) (_result *ModifyDcdnWafPolicyDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDcdnWafPolicyDomainsResponse{}
	_body, _err := client.ModifyDcdnWafPolicyDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 * *   You must configure at least one of the **RuleStatus**, **RuleName** and **RuleConfig** parameters.
 *
 * @param request ModifyDcdnWafRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDcdnWafRuleResponse
 */
func (client *Client) ModifyDcdnWafRuleWithOptions(request *ModifyDcdnWafRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyDcdnWafRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RuleConfig)) {
		body["RuleConfig"] = request.RuleConfig
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		body["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		body["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleStatus)) {
		body["RuleStatus"] = request.RuleStatus
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDcdnWafRule"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDcdnWafRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation up to 20 times per second per account.
 * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
 * *   You must configure at least one of the **RuleStatus**, **RuleName** and **RuleConfig** parameters.
 *
 * @param request ModifyDcdnWafRuleRequest
 * @return ModifyDcdnWafRuleResponse
 */
func (client *Client) ModifyDcdnWafRule(request *ModifyDcdnWafRuleRequest) (_result *ModifyDcdnWafRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDcdnWafRuleResponse{}
	_body, _err := client.ModifyDcdnWafRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   DCDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must pass real-name verification.
 * *   You can call this operation up to five times per second per user.
 *
 * @param request OpenDcdnServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenDcdnServiceResponse
 */
func (client *Client) OpenDcdnServiceWithOptions(request *OpenDcdnServiceRequest, runtime *util.RuntimeOptions) (_result *OpenDcdnServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BillType)) {
		query["BillType"] = request.BillType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.WebsocketBillType)) {
		query["WebsocketBillType"] = request.WebsocketBillType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenDcdnService"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenDcdnServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   DCDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must pass real-name verification.
 * *   You can call this operation up to five times per second per user.
 *
 * @param request OpenDcdnServiceRequest
 * @return OpenDcdnServiceResponse
 */
func (client *Client) OpenDcdnService(request *OpenDcdnServiceRequest) (_result *OpenDcdnServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenDcdnServiceResponse{}
	_body, _err := client.OpenDcdnServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
 * *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
 * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
 * *   You can specify up to 100 URLs to prefetch.
 * *   The prefetch queue of each Alibaba Cloud account can contain up to 100,000 URLs. DCDN executes prefetch tasks based on the time at which you submit the URLs.
 * *   You can call this operation up to 15 times per second per account.
 * ## Description
 * *   After a refresh task is submitted and completed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
 * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks require 5 to 30 minutes to complete. A task with a smaller average file size requires less time.
 * *   To allow RAM users to perform this operation, you need to first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~445051~~).
 *
 * @param request PreloadDcdnObjectCachesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PreloadDcdnObjectCachesResponse
 */
func (client *Client) PreloadDcdnObjectCachesWithOptions(request *PreloadDcdnObjectCachesRequest, runtime *util.RuntimeOptions) (_result *PreloadDcdnObjectCachesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.L2Preload)) {
		query["L2Preload"] = request.L2Preload
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.WithHeader)) {
		query["WithHeader"] = request.WithHeader
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PreloadDcdnObjectCaches"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PreloadDcdnObjectCachesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
 * *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
 * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
 * *   You can specify up to 100 URLs to prefetch.
 * *   The prefetch queue of each Alibaba Cloud account can contain up to 100,000 URLs. DCDN executes prefetch tasks based on the time at which you submit the URLs.
 * *   You can call this operation up to 15 times per second per account.
 * ## Description
 * *   After a refresh task is submitted and completed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
 * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks require 5 to 30 minutes to complete. A task with a smaller average file size requires less time.
 * *   To allow RAM users to perform this operation, you need to first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~445051~~).
 *
 * @param request PreloadDcdnObjectCachesRequest
 * @return PreloadDcdnObjectCachesResponse
 */
func (client *Client) PreloadDcdnObjectCaches(request *PreloadDcdnObjectCachesRequest) (_result *PreloadDcdnObjectCachesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PreloadDcdnObjectCachesResponse{}
	_body, _err := client.PreloadDcdnObjectCachesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request PublishDcdnStagingConfigToProductionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishDcdnStagingConfigToProductionResponse
 */
func (client *Client) PublishDcdnStagingConfigToProductionWithOptions(request *PublishDcdnStagingConfigToProductionRequest, runtime *util.RuntimeOptions) (_result *PublishDcdnStagingConfigToProductionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionName)) {
		query["FunctionName"] = request.FunctionName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishDcdnStagingConfigToProduction"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishDcdnStagingConfigToProductionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request PublishDcdnStagingConfigToProductionRequest
 * @return PublishDcdnStagingConfigToProductionResponse
 */
func (client *Client) PublishDcdnStagingConfigToProduction(request *PublishDcdnStagingConfigToProductionRequest) (_result *PublishDcdnStagingConfigToProductionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishDcdnStagingConfigToProductionResponse{}
	_body, _err := client.PublishDcdnStagingConfigToProductionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param tmpReq PublishRoutineCodeRevisionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishRoutineCodeRevisionResponse
 */
func (client *Client) PublishRoutineCodeRevisionWithOptions(tmpReq *PublishRoutineCodeRevisionRequest, runtime *util.RuntimeOptions) (_result *PublishRoutineCodeRevisionResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &PublishRoutineCodeRevisionShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Envs)) {
		request.EnvsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Envs, tea.String("Envs"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvsShrink)) {
		body["Envs"] = request.EnvsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.SelectCodeRevision)) {
		body["SelectCodeRevision"] = request.SelectCodeRevision
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishRoutineCodeRevision"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishRoutineCodeRevisionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request PublishRoutineCodeRevisionRequest
 * @return PublishRoutineCodeRevisionResponse
 */
func (client *Client) PublishRoutineCodeRevision(request *PublishRoutineCodeRevisionRequest) (_result *PublishRoutineCodeRevisionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishRoutineCodeRevisionResponse{}
	_body, _err := client.PublishRoutineCodeRevisionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PutDcdnKvWithOptions(request *PutDcdnKvRequest, runtime *util.RuntimeOptions) (_result *PutDcdnKvResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Expiration)) {
		query["Expiration"] = request.Expiration
	}

	if !tea.BoolValue(util.IsUnset(request.ExpirationTtl)) {
		query["ExpirationTtl"] = request.ExpirationTtl
	}

	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Value)) {
		body["Value"] = request.Value
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutDcdnKv"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PutDcdnKvResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PutDcdnKv(request *PutDcdnKvRequest) (_result *PutDcdnKvResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PutDcdnKvResponse{}
	_body, _err := client.PutDcdnKvWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PutDcdnKvNamespaceWithOptions(request *PutDcdnKvNamespaceRequest, runtime *util.RuntimeOptions) (_result *PutDcdnKvNamespaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		body["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutDcdnKvNamespace"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PutDcdnKvNamespaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PutDcdnKvNamespace(request *PutDcdnKvNamespaceRequest) (_result *PutDcdnKvNamespaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PutDcdnKvNamespaceResponse{}
	_body, _err := client.PutDcdnKvNamespaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * #
 * *   DCDN supports POST requests in which parameters are sent as a form.
 * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
 * *   By default, each Alibaba Cloud account can refresh content from a maximum of 10,000 URLs and 100 directories per day, including subdirectories. If the daily peak bandwidth value exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to request a quota increase. DCDN evaluates your application based on your workloads.
 * *   You can specify up to 1,000 URLs or 100 directories that you want to refresh in each request.
 * *   You can refresh up to 1,000 URLs per minute for each domain name.
 * *   You can call this operation up to 30 times per second per account.
 * # Precautions
 * *   After a refresh task is submitted and completed, your resources that are stored on DCDN POPs are removed. When a POP receives a request to your resources, the request is redirected to the origin server to retrieve the resources. Then, the resources are returned to the client and cached on the POP. If you frequently run refresh tasks, more requests will be redirected back to the origin server for resources, which result in high bandwidth costs and undue pressure on the origin server.
 * *   A refresh task takes effect 5 to 6 minutes after being submitted. This means that if the resource you want to refresh has a TTL of less than five minutes, you wait for it to expire instead of manually running a refresh task.
 * *   If you want to use RAM users to refresh or prefetch resources, you need to obtain the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~445051~~).
 *
 * @param request RefreshDcdnObjectCachesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshDcdnObjectCachesResponse
 */
func (client *Client) RefreshDcdnObjectCachesWithOptions(request *RefreshDcdnObjectCachesRequest, runtime *util.RuntimeOptions) (_result *RefreshDcdnObjectCachesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshDcdnObjectCaches"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshDcdnObjectCachesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * #
 * *   DCDN supports POST requests in which parameters are sent as a form.
 * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
 * *   By default, each Alibaba Cloud account can refresh content from a maximum of 10,000 URLs and 100 directories per day, including subdirectories. If the daily peak bandwidth value exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to request a quota increase. DCDN evaluates your application based on your workloads.
 * *   You can specify up to 1,000 URLs or 100 directories that you want to refresh in each request.
 * *   You can refresh up to 1,000 URLs per minute for each domain name.
 * *   You can call this operation up to 30 times per second per account.
 * # Precautions
 * *   After a refresh task is submitted and completed, your resources that are stored on DCDN POPs are removed. When a POP receives a request to your resources, the request is redirected to the origin server to retrieve the resources. Then, the resources are returned to the client and cached on the POP. If you frequently run refresh tasks, more requests will be redirected back to the origin server for resources, which result in high bandwidth costs and undue pressure on the origin server.
 * *   A refresh task takes effect 5 to 6 minutes after being submitted. This means that if the resource you want to refresh has a TTL of less than five minutes, you wait for it to expire instead of manually running a refresh task.
 * *   If you want to use RAM users to refresh or prefetch resources, you need to obtain the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~445051~~).
 *
 * @param request RefreshDcdnObjectCachesRequest
 * @return RefreshDcdnObjectCachesResponse
 */
func (client *Client) RefreshDcdnObjectCaches(request *RefreshDcdnObjectCachesRequest) (_result *RefreshDcdnObjectCachesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshDcdnObjectCachesResponse{}
	_body, _err := client.RefreshDcdnObjectCachesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request RollbackDcdnStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RollbackDcdnStagingConfigResponse
 */
func (client *Client) RollbackDcdnStagingConfigWithOptions(request *RollbackDcdnStagingConfigRequest, runtime *util.RuntimeOptions) (_result *RollbackDcdnStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RollbackDcdnStagingConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RollbackDcdnStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request RollbackDcdnStagingConfigRequest
 * @return RollbackDcdnStagingConfigResponse
 */
func (client *Client) RollbackDcdnStagingConfig(request *RollbackDcdnStagingConfigRequest) (_result *RollbackDcdnStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RollbackDcdnStagingConfigResponse{}
	_body, _err := client.RollbackDcdnStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : SetDcdnDomainCertificate is deprecated, please use dcdn::2018-01-15::SetDcdnDomainSSLCertificate instead.
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnDomainCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDcdnDomainCertificateResponse
 */
// Deprecated
func (client *Client) SetDcdnDomainCertificateWithOptions(request *SetDcdnDomainCertificateRequest, runtime *util.RuntimeOptions) (_result *SetDcdnDomainCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertType)) {
		query["CertType"] = request.CertType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ForceSet)) {
		query["ForceSet"] = request.ForceSet
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDcdnDomainCertificate"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDcdnDomainCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : SetDcdnDomainCertificate is deprecated, please use dcdn::2018-01-15::SetDcdnDomainSSLCertificate instead.
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnDomainCertificateRequest
 * @return SetDcdnDomainCertificateResponse
 */
// Deprecated
func (client *Client) SetDcdnDomainCertificate(request *SetDcdnDomainCertificateRequest) (_result *SetDcdnDomainCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDcdnDomainCertificateResponse{}
	_body, _err := client.SetDcdnDomainCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnDomainSMCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDcdnDomainSMCertificateResponse
 */
func (client *Client) SetDcdnDomainSMCertificateWithOptions(request *SetDcdnDomainSMCertificateRequest, runtime *util.RuntimeOptions) (_result *SetDcdnDomainSMCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDcdnDomainSMCertificate"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDcdnDomainSMCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnDomainSMCertificateRequest
 * @return SetDcdnDomainSMCertificateResponse
 */
func (client *Client) SetDcdnDomainSMCertificate(request *SetDcdnDomainSMCertificateRequest) (_result *SetDcdnDomainSMCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDcdnDomainSMCertificateResponse{}
	_body, _err := client.SetDcdnDomainSMCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDcdnDomainSSLCertificateWithOptions(request *SetDcdnDomainSSLCertificateRequest, runtime *util.RuntimeOptions) (_result *SetDcdnDomainSSLCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertId)) {
		query["CertId"] = request.CertId
	}

	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertRegion)) {
		query["CertRegion"] = request.CertRegion
	}

	if !tea.BoolValue(util.IsUnset(request.CertType)) {
		query["CertType"] = request.CertType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDcdnDomainSSLCertificate"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDcdnDomainSSLCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDcdnDomainSSLCertificate(request *SetDcdnDomainSSLCertificateRequest) (_result *SetDcdnDomainSSLCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDcdnDomainSSLCertificateResponse{}
	_body, _err := client.SetDcdnDomainSSLCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnDomainStagingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDcdnDomainStagingConfigResponse
 */
func (client *Client) SetDcdnDomainStagingConfigWithOptions(request *SetDcdnDomainStagingConfigRequest, runtime *util.RuntimeOptions) (_result *SetDcdnDomainStagingConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Functions)) {
		query["Functions"] = request.Functions
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDcdnDomainStagingConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDcdnDomainStagingConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnDomainStagingConfigRequest
 * @return SetDcdnDomainStagingConfigResponse
 */
func (client *Client) SetDcdnDomainStagingConfig(request *SetDcdnDomainStagingConfigRequest) (_result *SetDcdnDomainStagingConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDcdnDomainStagingConfigResponse{}
	_body, _err := client.SetDcdnDomainStagingConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request SetDcdnFullDomainsBlockIPRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDcdnFullDomainsBlockIPResponse
 */
func (client *Client) SetDcdnFullDomainsBlockIPWithOptions(request *SetDcdnFullDomainsBlockIPRequest, runtime *util.RuntimeOptions) (_result *SetDcdnFullDomainsBlockIPResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BlockInterval)) {
		body["BlockInterval"] = request.BlockInterval
	}

	if !tea.BoolValue(util.IsUnset(request.IPList)) {
		body["IPList"] = request.IPList
	}

	if !tea.BoolValue(util.IsUnset(request.OperationType)) {
		body["OperationType"] = request.OperationType
	}

	if !tea.BoolValue(util.IsUnset(request.UpdateType)) {
		body["UpdateType"] = request.UpdateType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDcdnFullDomainsBlockIP"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDcdnFullDomainsBlockIPResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 10 times per second per account.
 *
 * @param request SetDcdnFullDomainsBlockIPRequest
 * @return SetDcdnFullDomainsBlockIPResponse
 */
func (client *Client) SetDcdnFullDomainsBlockIP(request *SetDcdnFullDomainsBlockIPRequest) (_result *SetDcdnFullDomainsBlockIPResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDcdnFullDomainsBlockIPResponse{}
	_body, _err := client.SetDcdnFullDomainsBlockIPWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnUserConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDcdnUserConfigResponse
 */
func (client *Client) SetDcdnUserConfigWithOptions(request *SetDcdnUserConfigRequest, runtime *util.RuntimeOptions) (_result *SetDcdnUserConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configs)) {
		query["Configs"] = request.Configs
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionId)) {
		query["FunctionId"] = request.FunctionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDcdnUserConfig"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDcdnUserConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 30 times per second per account.
 *
 * @param request SetDcdnUserConfigRequest
 * @return SetDcdnUserConfigResponse
 */
func (client *Client) SetDcdnUserConfig(request *SetDcdnUserConfigRequest) (_result *SetDcdnUserConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDcdnUserConfigResponse{}
	_body, _err := client.SetDcdnUserConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   Each subdomain is globally unique. Resource Access Management (RAM) users cannot create duplicate subdomains.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param tmpReq SetRoutineSubdomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetRoutineSubdomainResponse
 */
func (client *Client) SetRoutineSubdomainWithOptions(tmpReq *SetRoutineSubdomainRequest, runtime *util.RuntimeOptions) (_result *SetRoutineSubdomainResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &SetRoutineSubdomainShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Subdomains)) {
		request.SubdomainsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Subdomains, tea.String("Subdomains"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SubdomainsShrink)) {
		body["Subdomains"] = request.SubdomainsShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SetRoutineSubdomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetRoutineSubdomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   Each subdomain is globally unique. Resource Access Management (RAM) users cannot create duplicate subdomains.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request SetRoutineSubdomainRequest
 * @return SetRoutineSubdomainResponse
 */
func (client *Client) SetRoutineSubdomain(request *SetRoutineSubdomainRequest) (_result *SetRoutineSubdomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetRoutineSubdomainResponse{}
	_body, _err := client.SetRoutineSubdomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request StartDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDcdnDomainResponse
 */
func (client *Client) StartDcdnDomainWithOptions(request *StartDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *StartDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request StartDcdnDomainRequest
 * @return StartDcdnDomainResponse
 */
func (client *Client) StartDcdnDomain(request *StartDcdnDomainRequest) (_result *StartDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartDcdnDomainResponse{}
	_body, _err := client.StartDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request StartDcdnIpaDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDcdnIpaDomainResponse
 */
func (client *Client) StartDcdnIpaDomainWithOptions(request *StartDcdnIpaDomainRequest, runtime *util.RuntimeOptions) (_result *StartDcdnIpaDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartDcdnIpaDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartDcdnIpaDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request StartDcdnIpaDomainRequest
 * @return StartDcdnIpaDomainResponse
 */
func (client *Client) StartDcdnIpaDomain(request *StartDcdnIpaDomainRequest) (_result *StartDcdnIpaDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartDcdnIpaDomainResponse{}
	_body, _err := client.StartDcdnIpaDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   After an accelerated domain is disabled, Dynamic Content Delivery Network (DCDN) retains its information and routes all the requests that are destined for the accelerated domain to the origin server.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request StopDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopDcdnDomainResponse
 */
func (client *Client) StopDcdnDomainWithOptions(request *StopDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *StopDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   After an accelerated domain is disabled, Dynamic Content Delivery Network (DCDN) retains its information and routes all the requests that are destined for the accelerated domain to the origin server.
 * *   You can call this operation up to 30 times per second per account.
 *
 * @param request StopDcdnDomainRequest
 * @return StopDcdnDomainResponse
 */
func (client *Client) StopDcdnDomain(request *StopDcdnDomainRequest) (_result *StopDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopDcdnDomainResponse{}
	_body, _err := client.StopDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   If you disable an accelerated domain, the configurations of the accelerated domain are still retained. The system automatically forwards all the requests that are destined for this domain to the origin.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request StopDcdnIpaDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopDcdnIpaDomainResponse
 */
func (client *Client) StopDcdnIpaDomainWithOptions(request *StopDcdnIpaDomainRequest, runtime *util.RuntimeOptions) (_result *StopDcdnIpaDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopDcdnIpaDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopDcdnIpaDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   If you disable an accelerated domain, the configurations of the accelerated domain are still retained. The system automatically forwards all the requests that are destined for this domain to the origin.
 * *   You can call this operation up to 20 times per second per account.
 *
 * @param request StopDcdnIpaDomainRequest
 * @return StopDcdnIpaDomainResponse
 */
func (client *Client) StopDcdnIpaDomain(request *StopDcdnIpaDomainRequest) (_result *StopDcdnIpaDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopDcdnIpaDomainResponse{}
	_body, _err := client.StopDcdnIpaDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request TagDcdnResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagDcdnResourcesResponse
 */
func (client *Client) TagDcdnResourcesWithOptions(request *TagDcdnResourcesRequest, runtime *util.RuntimeOptions) (_result *TagDcdnResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagDcdnResources"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagDcdnResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request TagDcdnResourcesRequest
 * @return TagDcdnResourcesResponse
 */
func (client *Client) TagDcdnResources(request *TagDcdnResourcesRequest) (_result *TagDcdnResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagDcdnResourcesResponse{}
	_body, _err := client.TagDcdnResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UntagDcdnResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagDcdnResourcesResponse
 */
func (client *Client) UntagDcdnResourcesWithOptions(request *UntagDcdnResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagDcdnResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagDcdnResources"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagDcdnResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UntagDcdnResourcesRequest
 * @return UntagDcdnResourcesResponse
 */
func (client *Client) UntagDcdnResources(request *UntagDcdnResourcesRequest) (_result *UntagDcdnResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagDcdnResourcesResponse{}
	_body, _err := client.UntagDcdnResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The parameters that specify the time interval at which the tracking task sends operations reports. The settings must be escaped in JSON.
 *
 * @param request UpdateDcdnDeliverTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDcdnDeliverTaskResponse
 */
func (client *Client) UpdateDcdnDeliverTaskWithOptions(request *UpdateDcdnDeliverTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateDcdnDeliverTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Deliver)) {
		body["Deliver"] = request.Deliver
	}

	if !tea.BoolValue(util.IsUnset(request.DeliverId)) {
		body["DeliverId"] = request.DeliverId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Reports)) {
		body["Reports"] = request.Reports
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["Schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDcdnDeliverTask"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDcdnDeliverTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The parameters that specify the time interval at which the tracking task sends operations reports. The settings must be escaped in JSON.
 *
 * @param request UpdateDcdnDeliverTaskRequest
 * @return UpdateDcdnDeliverTaskResponse
 */
func (client *Client) UpdateDcdnDeliverTask(request *UpdateDcdnDeliverTaskRequest) (_result *UpdateDcdnDeliverTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDcdnDeliverTaskResponse{}
	_body, _err := client.UpdateDcdnDeliverTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request UpdateDcdnDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDcdnDomainResponse
 */
func (client *Client) UpdateDcdnDomainWithOptions(request *UpdateDcdnDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateDcdnDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDcdnDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDcdnDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 30 times per second per account.
 *
 * @param request UpdateDcdnDomainRequest
 * @return UpdateDcdnDomainResponse
 */
func (client *Client) UpdateDcdnDomain(request *UpdateDcdnDomainRequest) (_result *UpdateDcdnDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDcdnDomainResponse{}
	_body, _err := client.UpdateDcdnDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation up to 20 times per second per account.
 *
 * @param request UpdateDcdnIpaDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDcdnIpaDomainResponse
 */
func (client *Client) UpdateDcdnIpaDomainWithOptions(request *UpdateDcdnIpaDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateDcdnIpaDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDcdnIpaDomain"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDcdnIpaDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation up to 20 times per second per account.
 *
 * @param request UpdateDcdnIpaDomainRequest
 * @return UpdateDcdnIpaDomainResponse
 */
func (client *Client) UpdateDcdnIpaDomain(request *UpdateDcdnIpaDomainRequest) (_result *UpdateDcdnIpaDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDcdnIpaDomainResponse{}
	_body, _err := client.UpdateDcdnIpaDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UpdateDcdnSLSRealtimeLogDeliveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDcdnSLSRealtimeLogDeliveryResponse
 */
func (client *Client) UpdateDcdnSLSRealtimeLogDeliveryWithOptions(request *UpdateDcdnSLSRealtimeLogDeliveryRequest, runtime *util.RuntimeOptions) (_result *UpdateDcdnSLSRealtimeLogDeliveryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataCenter)) {
		body["DataCenter"] = request.DataCenter
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.SLSLogStore)) {
		body["SLSLogStore"] = request.SLSLogStore
	}

	if !tea.BoolValue(util.IsUnset(request.SLSProject)) {
		body["SLSProject"] = request.SLSProject
	}

	if !tea.BoolValue(util.IsUnset(request.SLSRegion)) {
		body["SLSRegion"] = request.SLSRegion
	}

	if !tea.BoolValue(util.IsUnset(request.SamplingRate)) {
		body["SamplingRate"] = request.SamplingRate
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDcdnSLSRealtimeLogDelivery"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDcdnSLSRealtimeLogDeliveryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UpdateDcdnSLSRealtimeLogDeliveryRequest
 * @return UpdateDcdnSLSRealtimeLogDeliveryResponse
 */
func (client *Client) UpdateDcdnSLSRealtimeLogDelivery(request *UpdateDcdnSLSRealtimeLogDeliveryRequest) (_result *UpdateDcdnSLSRealtimeLogDeliveryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDcdnSLSRealtimeLogDeliveryResponse{}
	_body, _err := client.UpdateDcdnSLSRealtimeLogDeliveryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request UpdateDcdnSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDcdnSubTaskResponse
 */
func (client *Client) UpdateDcdnSubTaskWithOptions(request *UpdateDcdnSubTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateDcdnSubTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ReportIds)) {
		body["ReportIds"] = request.ReportIds
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		body["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDcdnSubTask"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDcdnSubTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to three times per second per account.
 *
 * @param request UpdateDcdnSubTaskRequest
 * @return UpdateDcdnSubTaskResponse
 */
func (client *Client) UpdateDcdnSubTask(request *UpdateDcdnSubTaskRequest) (_result *UpdateDcdnSubTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDcdnSubTaskResponse{}
	_body, _err := client.UpdateDcdnSubTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UpdateDcdnUserRealTimeDeliveryFieldRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDcdnUserRealTimeDeliveryFieldResponse
 */
func (client *Client) UpdateDcdnUserRealTimeDeliveryFieldWithOptions(request *UpdateDcdnUserRealTimeDeliveryFieldRequest, runtime *util.RuntimeOptions) (_result *UpdateDcdnUserRealTimeDeliveryFieldResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDcdnUserRealTimeDeliveryField"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDcdnUserRealTimeDeliveryFieldResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request UpdateDcdnUserRealTimeDeliveryFieldRequest
 * @return UpdateDcdnUserRealTimeDeliveryFieldResponse
 */
func (client *Client) UpdateDcdnUserRealTimeDeliveryField(request *UpdateDcdnUserRealTimeDeliveryFieldRequest) (_result *UpdateDcdnUserRealTimeDeliveryFieldResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDcdnUserRealTimeDeliveryFieldResponse{}
	_body, _err := client.UpdateDcdnUserRealTimeDeliveryFieldWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   Each time you submit code, a version of the code is generated. You can manage and publish code by version.
 * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request UploadRoutineCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadRoutineCodeResponse
 */
func (client *Client) UploadRoutineCodeWithOptions(request *UploadRoutineCodeRequest, runtime *util.RuntimeOptions) (_result *UploadRoutineCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CodeDescription)) {
		body["CodeDescription"] = request.CodeDescription
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadRoutineCode"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadRoutineCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   Each time you submit code, a version of the code is generated. You can manage and publish code by version.
 * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request UploadRoutineCodeRequest
 * @return UploadRoutineCodeResponse
 */
func (client *Client) UploadRoutineCode(request *UploadRoutineCodeRequest) (_result *UploadRoutineCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadRoutineCodeResponse{}
	_body, _err := client.UploadRoutineCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   Each time you upload code to a routine, a version is generated. The number of versions is counted by CodeRev. The uploaded code is used only for testing.
 * *   The code is automatically published to a staging environment.
 * *   Each routine can retain at most 10 versions. If the upper limit is reached, you need to call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request UploadStagingRoutineCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadStagingRoutineCodeResponse
 */
func (client *Client) UploadStagingRoutineCodeWithOptions(request *UploadStagingRoutineCodeRequest, runtime *util.RuntimeOptions) (_result *UploadStagingRoutineCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CodeDescription)) {
		body["CodeDescription"] = request.CodeDescription
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadStagingRoutineCode"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadStagingRoutineCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   Each time you upload code to a routine, a version is generated. The number of versions is counted by CodeRev. The uploaded code is used only for testing.
 * *   The code is automatically published to a staging environment.
 * *   Each routine can retain at most 10 versions. If the upper limit is reached, you need to call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
 * *   You can call this operation up to 100 times per second per account.
 *
 * @param request UploadStagingRoutineCodeRequest
 * @return UploadStagingRoutineCodeResponse
 */
func (client *Client) UploadStagingRoutineCode(request *UploadStagingRoutineCodeRequest) (_result *UploadStagingRoutineCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadStagingRoutineCodeResponse{}
	_body, _err := client.UploadStagingRoutineCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request VerifyDcdnDomainOwnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return VerifyDcdnDomainOwnerResponse
 */
func (client *Client) VerifyDcdnDomainOwnerWithOptions(request *VerifyDcdnDomainOwnerRequest, runtime *util.RuntimeOptions) (_result *VerifyDcdnDomainOwnerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyType)) {
		query["VerifyType"] = request.VerifyType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyDcdnDomainOwner"),
		Version:     tea.String("2018-01-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyDcdnDomainOwnerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation up to 100 times per second per account.
 *
 * @param request VerifyDcdnDomainOwnerRequest
 * @return VerifyDcdnDomainOwnerResponse
 */
func (client *Client) VerifyDcdnDomainOwner(request *VerifyDcdnDomainOwnerRequest) (_result *VerifyDcdnDomainOwnerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyDcdnDomainOwnerResponse{}
	_body, _err := client.VerifyDcdnDomainOwnerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
