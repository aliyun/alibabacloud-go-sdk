// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddEntriesToAclRequest struct {
	// The IP addresses or CIDR blocks that you want to add to the ACL. You can add at most 20 entries in each request.
	AclEntries []*AddEntriesToAclRequestAclEntries `json:"AclEntries,omitempty" xml:"AclEntries,omitempty" type:"Repeated"`
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**(default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddEntriesToAclRequest) String() string {
	return tea.Prettify(s)
}

func (s AddEntriesToAclRequest) GoString() string {
	return s.String()
}

func (s *AddEntriesToAclRequest) SetAclEntries(v []*AddEntriesToAclRequestAclEntries) *AddEntriesToAclRequest {
	s.AclEntries = v
	return s
}

func (s *AddEntriesToAclRequest) SetAclId(v string) *AddEntriesToAclRequest {
	s.AclId = &v
	return s
}

func (s *AddEntriesToAclRequest) SetClientToken(v string) *AddEntriesToAclRequest {
	s.ClientToken = &v
	return s
}

func (s *AddEntriesToAclRequest) SetDryRun(v bool) *AddEntriesToAclRequest {
	s.DryRun = &v
	return s
}

func (s *AddEntriesToAclRequest) SetRegionId(v string) *AddEntriesToAclRequest {
	s.RegionId = &v
	return s
}

type AddEntriesToAclRequestAclEntries struct {
	// The IP address (192.168.XX.XX) or CIDR block (10.0.XX.XX/24) that you want to add to the ACL. You can add at most 20 entries in each request.
	//
	// > This parameter is required.
	Entry *string `json:"Entry,omitempty" xml:"Entry,omitempty"`
	// The description of the entry.
	//
	// You can add the descriptions of up to 20 entries in each request.
	//
	// The description must be 1 to 256 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	EntryDescription *string `json:"EntryDescription,omitempty" xml:"EntryDescription,omitempty"`
}

func (s AddEntriesToAclRequestAclEntries) String() string {
	return tea.Prettify(s)
}

func (s AddEntriesToAclRequestAclEntries) GoString() string {
	return s.String()
}

func (s *AddEntriesToAclRequestAclEntries) SetEntry(v string) *AddEntriesToAclRequestAclEntries {
	s.Entry = &v
	return s
}

func (s *AddEntriesToAclRequestAclEntries) SetEntryDescription(v string) *AddEntriesToAclRequestAclEntries {
	s.EntryDescription = &v
	return s
}

type AddEntriesToAclResponseBody struct {
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddEntriesToAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddEntriesToAclResponseBody) GoString() string {
	return s.String()
}

func (s *AddEntriesToAclResponseBody) SetAclId(v string) *AddEntriesToAclResponseBody {
	s.AclId = &v
	return s
}

func (s *AddEntriesToAclResponseBody) SetRequestId(v string) *AddEntriesToAclResponseBody {
	s.RequestId = &v
	return s
}

type AddEntriesToAclResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddEntriesToAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddEntriesToAclResponse) String() string {
	return tea.Prettify(s)
}

func (s AddEntriesToAclResponse) GoString() string {
	return s.String()
}

func (s *AddEntriesToAclResponse) SetHeaders(v map[string]*string) *AddEntriesToAclResponse {
	s.Headers = v
	return s
}

func (s *AddEntriesToAclResponse) SetStatusCode(v int32) *AddEntriesToAclResponse {
	s.StatusCode = &v
	return s
}

func (s *AddEntriesToAclResponse) SetBody(v *AddEntriesToAclResponseBody) *AddEntriesToAclResponse {
	s.Body = v
	return s
}

type AssociateAclsWithListenerRequest struct {
	// The ID of the ACL. You can associate up to two ACL IDs.
	AclIds []*string `json:"AclIds,omitempty" xml:"AclIds,omitempty" type:"Repeated"`
	// The type of ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios in which you want to allow only specific IP addresses to access an application. Your service may be adversely affected if the whitelist is not properly configured. After you configure a whitelist for a listener, only requests from the IP addresses that are added to the whitelist are forwarded by the listener. If the whitelist is enabled but no IP addresses are added to it, the listener does not forward requests.
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are denied. Blacklists apply to scenarios in which you want to deny access from specific IP addresses to an application. If the blacklist is enabled but no IP addresses are added to it, the listener forwards all requests.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Default value: false. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AssociateAclsWithListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateAclsWithListenerRequest) GoString() string {
	return s.String()
}

func (s *AssociateAclsWithListenerRequest) SetAclIds(v []*string) *AssociateAclsWithListenerRequest {
	s.AclIds = v
	return s
}

func (s *AssociateAclsWithListenerRequest) SetAclType(v string) *AssociateAclsWithListenerRequest {
	s.AclType = &v
	return s
}

func (s *AssociateAclsWithListenerRequest) SetClientToken(v string) *AssociateAclsWithListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateAclsWithListenerRequest) SetDryRun(v bool) *AssociateAclsWithListenerRequest {
	s.DryRun = &v
	return s
}

func (s *AssociateAclsWithListenerRequest) SetListenerId(v string) *AssociateAclsWithListenerRequest {
	s.ListenerId = &v
	return s
}

func (s *AssociateAclsWithListenerRequest) SetRegionId(v string) *AssociateAclsWithListenerRequest {
	s.RegionId = &v
	return s
}

type AssociateAclsWithListenerResponseBody struct {
	// The ID of the ACL.
	AclIds []*string `json:"AclIds,omitempty" xml:"AclIds,omitempty" type:"Repeated"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateAclsWithListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateAclsWithListenerResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateAclsWithListenerResponseBody) SetAclIds(v []*string) *AssociateAclsWithListenerResponseBody {
	s.AclIds = v
	return s
}

func (s *AssociateAclsWithListenerResponseBody) SetListenerId(v string) *AssociateAclsWithListenerResponseBody {
	s.ListenerId = &v
	return s
}

func (s *AssociateAclsWithListenerResponseBody) SetRequestId(v string) *AssociateAclsWithListenerResponseBody {
	s.RequestId = &v
	return s
}

type AssociateAclsWithListenerResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateAclsWithListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateAclsWithListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateAclsWithListenerResponse) GoString() string {
	return s.String()
}

func (s *AssociateAclsWithListenerResponse) SetHeaders(v map[string]*string) *AssociateAclsWithListenerResponse {
	s.Headers = v
	return s
}

func (s *AssociateAclsWithListenerResponse) SetStatusCode(v int32) *AssociateAclsWithListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateAclsWithListenerResponse) SetBody(v *AssociateAclsWithListenerResponseBody) *AssociateAclsWithListenerResponse {
	s.Body = v
	return s
}

type AssociateAdditionalCertificatesWithListenerRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The additional certificates.
	//
	// You can specify up to 10 certificate IDs in each request.
	Certificates []*AssociateAdditionalCertificatesWithListenerRequestCertificates `json:"Certificates,omitempty" xml:"Certificates,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The listener ID. Only HTTPS listeners are supported.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AssociateAdditionalCertificatesWithListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateAdditionalCertificatesWithListenerRequest) GoString() string {
	return s.String()
}

func (s *AssociateAdditionalCertificatesWithListenerRequest) SetAcceleratorId(v string) *AssociateAdditionalCertificatesWithListenerRequest {
	s.AcceleratorId = &v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerRequest) SetCertificates(v []*AssociateAdditionalCertificatesWithListenerRequestCertificates) *AssociateAdditionalCertificatesWithListenerRequest {
	s.Certificates = v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerRequest) SetClientToken(v string) *AssociateAdditionalCertificatesWithListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerRequest) SetListenerId(v string) *AssociateAdditionalCertificatesWithListenerRequest {
	s.ListenerId = &v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerRequest) SetRegionId(v string) *AssociateAdditionalCertificatesWithListenerRequest {
	s.RegionId = &v
	return s
}

type AssociateAdditionalCertificatesWithListenerRequestCertificates struct {
	// The domain name specified by the certificate. You can associate each domain name with only one additional certificate.
	//
	// You can specify up to 10 domain names in each request.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The certificate ID. Only server certificates are supported.
	//
	// You can specify up to 10 certificate IDs in each request.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s AssociateAdditionalCertificatesWithListenerRequestCertificates) String() string {
	return tea.Prettify(s)
}

func (s AssociateAdditionalCertificatesWithListenerRequestCertificates) GoString() string {
	return s.String()
}

func (s *AssociateAdditionalCertificatesWithListenerRequestCertificates) SetDomain(v string) *AssociateAdditionalCertificatesWithListenerRequestCertificates {
	s.Domain = &v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerRequestCertificates) SetId(v string) *AssociateAdditionalCertificatesWithListenerRequestCertificates {
	s.Id = &v
	return s
}

type AssociateAdditionalCertificatesWithListenerResponseBody struct {
	// The listener ID.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateAdditionalCertificatesWithListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateAdditionalCertificatesWithListenerResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateAdditionalCertificatesWithListenerResponseBody) SetListenerId(v string) *AssociateAdditionalCertificatesWithListenerResponseBody {
	s.ListenerId = &v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerResponseBody) SetRequestId(v string) *AssociateAdditionalCertificatesWithListenerResponseBody {
	s.RequestId = &v
	return s
}

type AssociateAdditionalCertificatesWithListenerResponse struct {
	Headers    map[string]*string                                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateAdditionalCertificatesWithListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateAdditionalCertificatesWithListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateAdditionalCertificatesWithListenerResponse) GoString() string {
	return s.String()
}

func (s *AssociateAdditionalCertificatesWithListenerResponse) SetHeaders(v map[string]*string) *AssociateAdditionalCertificatesWithListenerResponse {
	s.Headers = v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerResponse) SetStatusCode(v int32) *AssociateAdditionalCertificatesWithListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateAdditionalCertificatesWithListenerResponse) SetBody(v *AssociateAdditionalCertificatesWithListenerResponseBody) *AssociateAdditionalCertificatesWithListenerResponse {
	s.Body = v
	return s
}

type AttachDdosToAcceleratorRequest struct {
	// The ID of the GA instance with which the Anti-DDoS Pro/Premium instance is associated.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the Anti-DDoS Pro/Premium instance to be associated with the GA instance.
	DdosId *string `json:"DdosId,omitempty" xml:"DdosId,omitempty"`
	// The region where the Anti-DDoS Pro/Premium instance is deployed. Valid values:
	//
	// *   **cn-hangzhou**: regions in the Chinese mainland
	// *   **ap-southeast-1**: regions outside the Chinese mainland
	DdosRegionId *string `json:"DdosRegionId,omitempty" xml:"DdosRegionId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AttachDdosToAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachDdosToAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *AttachDdosToAcceleratorRequest) SetAcceleratorId(v string) *AttachDdosToAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *AttachDdosToAcceleratorRequest) SetDdosId(v string) *AttachDdosToAcceleratorRequest {
	s.DdosId = &v
	return s
}

func (s *AttachDdosToAcceleratorRequest) SetDdosRegionId(v string) *AttachDdosToAcceleratorRequest {
	s.DdosRegionId = &v
	return s
}

func (s *AttachDdosToAcceleratorRequest) SetRegionId(v string) *AttachDdosToAcceleratorRequest {
	s.RegionId = &v
	return s
}

type AttachDdosToAcceleratorResponseBody struct {
	// The ID of the Anti-DDoS Pro/Premium instance that is associated with the GA instance.
	DdosId *string `json:"DdosId,omitempty" xml:"DdosId,omitempty"`
	// The ID of the GA instance that is associated with the Anti-DDoS Pro/Premium instance.
	GaId *string `json:"GaId,omitempty" xml:"GaId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachDdosToAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachDdosToAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *AttachDdosToAcceleratorResponseBody) SetDdosId(v string) *AttachDdosToAcceleratorResponseBody {
	s.DdosId = &v
	return s
}

func (s *AttachDdosToAcceleratorResponseBody) SetGaId(v string) *AttachDdosToAcceleratorResponseBody {
	s.GaId = &v
	return s
}

func (s *AttachDdosToAcceleratorResponseBody) SetRequestId(v string) *AttachDdosToAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type AttachDdosToAcceleratorResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachDdosToAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachDdosToAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachDdosToAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *AttachDdosToAcceleratorResponse) SetHeaders(v map[string]*string) *AttachDdosToAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *AttachDdosToAcceleratorResponse) SetStatusCode(v int32) *AttachDdosToAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachDdosToAcceleratorResponse) SetBody(v *AttachDdosToAcceleratorResponseBody) *AttachDdosToAcceleratorResponse {
	s.Body = v
	return s
}

type AttachLogStoreToEndpointGroupRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of the endpoint groups.
	EndpointGroupIds []*string `json:"EndpointGroupIds,omitempty" xml:"EndpointGroupIds,omitempty" type:"Repeated"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the Logstore.
	SlsLogStoreName *string `json:"SlsLogStoreName,omitempty" xml:"SlsLogStoreName,omitempty"`
	// The name of the Log Service project.
	SlsProjectName *string `json:"SlsProjectName,omitempty" xml:"SlsProjectName,omitempty"`
	// The region ID of the Log Service project.
	SlsRegionId *string `json:"SlsRegionId,omitempty" xml:"SlsRegionId,omitempty"`
}

func (s AttachLogStoreToEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachLogStoreToEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *AttachLogStoreToEndpointGroupRequest) SetAcceleratorId(v string) *AttachLogStoreToEndpointGroupRequest {
	s.AcceleratorId = &v
	return s
}

func (s *AttachLogStoreToEndpointGroupRequest) SetClientToken(v string) *AttachLogStoreToEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachLogStoreToEndpointGroupRequest) SetEndpointGroupIds(v []*string) *AttachLogStoreToEndpointGroupRequest {
	s.EndpointGroupIds = v
	return s
}

func (s *AttachLogStoreToEndpointGroupRequest) SetListenerId(v string) *AttachLogStoreToEndpointGroupRequest {
	s.ListenerId = &v
	return s
}

func (s *AttachLogStoreToEndpointGroupRequest) SetRegionId(v string) *AttachLogStoreToEndpointGroupRequest {
	s.RegionId = &v
	return s
}

func (s *AttachLogStoreToEndpointGroupRequest) SetSlsLogStoreName(v string) *AttachLogStoreToEndpointGroupRequest {
	s.SlsLogStoreName = &v
	return s
}

func (s *AttachLogStoreToEndpointGroupRequest) SetSlsProjectName(v string) *AttachLogStoreToEndpointGroupRequest {
	s.SlsProjectName = &v
	return s
}

func (s *AttachLogStoreToEndpointGroupRequest) SetSlsRegionId(v string) *AttachLogStoreToEndpointGroupRequest {
	s.SlsRegionId = &v
	return s
}

type AttachLogStoreToEndpointGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachLogStoreToEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachLogStoreToEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AttachLogStoreToEndpointGroupResponseBody) SetRequestId(v string) *AttachLogStoreToEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type AttachLogStoreToEndpointGroupResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachLogStoreToEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachLogStoreToEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachLogStoreToEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *AttachLogStoreToEndpointGroupResponse) SetHeaders(v map[string]*string) *AttachLogStoreToEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *AttachLogStoreToEndpointGroupResponse) SetStatusCode(v int32) *AttachLogStoreToEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachLogStoreToEndpointGroupResponse) SetBody(v *AttachLogStoreToEndpointGroupResponseBody) *AttachLogStoreToEndpointGroupResponse {
	s.Body = v
	return s
}

type BandwidthPackageAddAcceleratorRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth plan ID.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s BandwidthPackageAddAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s BandwidthPackageAddAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *BandwidthPackageAddAcceleratorRequest) SetAcceleratorId(v string) *BandwidthPackageAddAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *BandwidthPackageAddAcceleratorRequest) SetBandwidthPackageId(v string) *BandwidthPackageAddAcceleratorRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *BandwidthPackageAddAcceleratorRequest) SetRegionId(v string) *BandwidthPackageAddAcceleratorRequest {
	s.RegionId = &v
	return s
}

type BandwidthPackageAddAcceleratorResponseBody struct {
	// The GA instance IDs.
	Accelerators []*string `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The bandwidth plan ID.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BandwidthPackageAddAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BandwidthPackageAddAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *BandwidthPackageAddAcceleratorResponseBody) SetAccelerators(v []*string) *BandwidthPackageAddAcceleratorResponseBody {
	s.Accelerators = v
	return s
}

func (s *BandwidthPackageAddAcceleratorResponseBody) SetBandwidthPackageId(v string) *BandwidthPackageAddAcceleratorResponseBody {
	s.BandwidthPackageId = &v
	return s
}

func (s *BandwidthPackageAddAcceleratorResponseBody) SetRequestId(v string) *BandwidthPackageAddAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type BandwidthPackageAddAcceleratorResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BandwidthPackageAddAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BandwidthPackageAddAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s BandwidthPackageAddAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *BandwidthPackageAddAcceleratorResponse) SetHeaders(v map[string]*string) *BandwidthPackageAddAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *BandwidthPackageAddAcceleratorResponse) SetStatusCode(v int32) *BandwidthPackageAddAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *BandwidthPackageAddAcceleratorResponse) SetBody(v *BandwidthPackageAddAcceleratorResponseBody) *BandwidthPackageAddAcceleratorResponse {
	s.Body = v
	return s
}

type BandwidthPackageRemoveAcceleratorRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s BandwidthPackageRemoveAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s BandwidthPackageRemoveAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *BandwidthPackageRemoveAcceleratorRequest) SetAcceleratorId(v string) *BandwidthPackageRemoveAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *BandwidthPackageRemoveAcceleratorRequest) SetBandwidthPackageId(v string) *BandwidthPackageRemoveAcceleratorRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *BandwidthPackageRemoveAcceleratorRequest) SetRegionId(v string) *BandwidthPackageRemoveAcceleratorRequest {
	s.RegionId = &v
	return s
}

type BandwidthPackageRemoveAcceleratorResponseBody struct {
	// The ID of the GA instance.
	Accelerators []*string `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BandwidthPackageRemoveAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BandwidthPackageRemoveAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *BandwidthPackageRemoveAcceleratorResponseBody) SetAccelerators(v []*string) *BandwidthPackageRemoveAcceleratorResponseBody {
	s.Accelerators = v
	return s
}

func (s *BandwidthPackageRemoveAcceleratorResponseBody) SetBandwidthPackageId(v string) *BandwidthPackageRemoveAcceleratorResponseBody {
	s.BandwidthPackageId = &v
	return s
}

func (s *BandwidthPackageRemoveAcceleratorResponseBody) SetRequestId(v string) *BandwidthPackageRemoveAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type BandwidthPackageRemoveAcceleratorResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BandwidthPackageRemoveAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BandwidthPackageRemoveAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s BandwidthPackageRemoveAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *BandwidthPackageRemoveAcceleratorResponse) SetHeaders(v map[string]*string) *BandwidthPackageRemoveAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *BandwidthPackageRemoveAcceleratorResponse) SetStatusCode(v int32) *BandwidthPackageRemoveAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *BandwidthPackageRemoveAcceleratorResponse) SetBody(v *BandwidthPackageRemoveAcceleratorResponseBody) *BandwidthPackageRemoveAcceleratorResponse {
	s.Body = v
	return s
}

type ChangeResourceGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. **The client token can contain only ASCII characters.**
	//
	// >  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the resource group that you want to use to replace the previous resource group.
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the GA resource.
	//
	// *   If you set the **ResourceType** parameter to **accelerator**, set the value of ResourceId to the ID of a standard GA instance.
	// *   If you set the **ResourceType** parameter to **basicaccelerator**, set the value of ResourceId to the ID of a basic GA instance.
	// *   If you set the **ResourceType** parameter to **bandwidthpackage**, set the value of ResourceId to the ID of a bandwidth plan.
	// *   If you set the **ResourceType** parameter to **acl**, set the value of ResourceId to the ID of an access control list (ACL).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the GA resource. Valid values:
	//
	// *   **accelerator:** a standard GA instance.
	// *   **basicaccelerator:** a basic GA instance.
	// *   **bandwidthpackage:** a bandwidth plan.
	// *   **acl:** an ACL.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) SetClientToken(v string) *ChangeResourceGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetNewResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetRegionId(v string) *ChangeResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceGroupResponse) SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse {
	s.Body = v
	return s
}

type ConfigEndpointProbeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable latency monitoring. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The endpoint.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The endpoint group ID.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Ip:** a custom IP address.
	// *   **Domain:** a custom domain name.
	// *   **EIP:** an Alibaba Cloud elastic IP address (EIP).
	// *   **PublicIp:** an Alibaba Cloud public IP address.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The port that is used to monitor latency. Valid values: **0** to **65535**.
	ProbePort *string `json:"ProbePort,omitempty" xml:"ProbePort,omitempty"`
	// The protocol that is used to monitor latency. Valid values:
	//
	// *   **tcp:** TCP.
	// *   **icmp:** ICMP.
	ProbeProtocol *string `json:"ProbeProtocol,omitempty" xml:"ProbeProtocol,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ConfigEndpointProbeRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigEndpointProbeRequest) GoString() string {
	return s.String()
}

func (s *ConfigEndpointProbeRequest) SetClientToken(v string) *ConfigEndpointProbeRequest {
	s.ClientToken = &v
	return s
}

func (s *ConfigEndpointProbeRequest) SetEnable(v string) *ConfigEndpointProbeRequest {
	s.Enable = &v
	return s
}

func (s *ConfigEndpointProbeRequest) SetEndpoint(v string) *ConfigEndpointProbeRequest {
	s.Endpoint = &v
	return s
}

func (s *ConfigEndpointProbeRequest) SetEndpointGroupId(v string) *ConfigEndpointProbeRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ConfigEndpointProbeRequest) SetEndpointType(v string) *ConfigEndpointProbeRequest {
	s.EndpointType = &v
	return s
}

func (s *ConfigEndpointProbeRequest) SetProbePort(v string) *ConfigEndpointProbeRequest {
	s.ProbePort = &v
	return s
}

func (s *ConfigEndpointProbeRequest) SetProbeProtocol(v string) *ConfigEndpointProbeRequest {
	s.ProbeProtocol = &v
	return s
}

func (s *ConfigEndpointProbeRequest) SetRegionId(v string) *ConfigEndpointProbeRequest {
	s.RegionId = &v
	return s
}

type ConfigEndpointProbeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigEndpointProbeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigEndpointProbeResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigEndpointProbeResponseBody) SetRequestId(v string) *ConfigEndpointProbeResponseBody {
	s.RequestId = &v
	return s
}

type ConfigEndpointProbeResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConfigEndpointProbeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfigEndpointProbeResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigEndpointProbeResponse) GoString() string {
	return s.String()
}

func (s *ConfigEndpointProbeResponse) SetHeaders(v map[string]*string) *ConfigEndpointProbeResponse {
	s.Headers = v
	return s
}

func (s *ConfigEndpointProbeResponse) SetStatusCode(v int32) *ConfigEndpointProbeResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigEndpointProbeResponse) SetBody(v *ConfigEndpointProbeResponseBody) *ConfigEndpointProbeResponse {
	s.Body = v
	return s
}

type CreateAcceleratorRequest struct {
	// Specifies whether to enable automatic payment. Default value: false. Valid values:
	//
	// *   **false:** disables automatic payment. If you select this option, you must go to the Order Center to complete the payment after an order is generated.
	// *   **true:** enables automatic payment. Payments are automatically completed.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal for the GA instance. Default value: false. Valid values:
	//
	// *   **true:** enables auto-renewal.
	// *   **false:** disables auto-renewal.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal duration. Unit: months.
	//
	// Valid values: **1** to **12**. Default value: **1**.
	//
	// >  This parameter takes effect only when **AutoRenew** is set to **true**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// Specifies whether to automatically use coupons when making payments. Default value: false. Valid values:
	//
	// *   **true:** automatically pays bill by using coupons.
	// *   **false:** does not automatically pay bills by using coupons.
	//
	// >  This parameter takes effect only when **AutoPay** is set to **true**.
	AutoUseCoupon *string `json:"AutoUseCoupon,omitempty" xml:"AutoUseCoupon,omitempty"`
	// The bandwidth billing method.
	//
	// *   **BandwidthPackage:** billed based on bandwidth plans.
	// *   **CDT:** billed based on data transfer.
	// *   **CDT95:** billed based on the 95th percentile bandwidth. The billing is managed by Cloud Data Transfer (CDT). This bandwidth billing method is not available by default. Contact your Alibaba Cloud account manager for more information.
	BandwidthBillingType *string `json:"BandwidthBillingType,omitempty" xml:"BandwidthBillingType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck the request. Default value: false. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The subscription duration of the GA instance.
	//
	// *   If the **PricingCycle** parameter is set to **Month**, the valid values for the **Duration** parameter are **1** to **9**.
	// *   If the **PricingCycle** parameter is set to **Year**, the valid values for the **Duration** parameter are **1** to **3**.
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The billing method of the GA. Default value is PREPAY (subscription).
	//
	// *   PREPAY : subscription.
	// *   POSTPAY : pay-as-you-go
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The configurations of the acceleration area.
	IpSetConfig *CreateAcceleratorRequestIpSetConfig `json:"IpSetConfig,omitempty" xml:"IpSetConfig,omitempty" type:"Struct"`
	// The name of the GA instance.
	//
	// The name must be 2 to 128 characters in length and can contain digits, underscores (\_), and hyphens (-). It must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The billing cycle of the GA instance. Valid values:
	//
	// *   **Month:** billed on a monthly basis.
	// *   **Year:** billed on an annual basis.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The coupon code.
	//
	// >
	PromotionOptionNo *string `json:"PromotionOptionNo,omitempty" xml:"PromotionOptionNo,omitempty"`
	// The ID of the region in which to create the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the standard GA instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of GA instance. Valid values:
	//
	// *   **1:** Small Ⅰ
	// *   **2:** Small Ⅱ
	// *   **3:** Small Ⅲ
	// *   **5:** Medium Ⅰ
	// *   **8:** Medium Ⅱ
	// *   **10:** Medium Ⅲ
	// *   **20:** Large Ⅰ
	// *   **30:** Large Ⅱ
	// *   **40:** Large Ⅲ
	// *   **50:** Large Ⅳ
	// *   **60:** Large Ⅴ
	// *   **70:** Large Ⅵ
	// *   **80:** Large VⅡ
	// *   **90:** Large VⅢ
	// *   **100:** Super Large Ⅰ
	// *   **200:** Super Large Ⅱ
	//
	// >  GA instances Large III and above are not available by default. To use these instances , contact your Alibaba Cloud account manager.
	//
	// Each instance type provides different capabilities. For more information, see [Instance specifications](~~153127~~).
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The tags of the GA instance.
	Tag []*CreateAcceleratorRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *CreateAcceleratorRequest) SetAutoPay(v bool) *CreateAcceleratorRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateAcceleratorRequest) SetAutoRenew(v bool) *CreateAcceleratorRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateAcceleratorRequest) SetAutoRenewDuration(v int32) *CreateAcceleratorRequest {
	s.AutoRenewDuration = &v
	return s
}

func (s *CreateAcceleratorRequest) SetAutoUseCoupon(v string) *CreateAcceleratorRequest {
	s.AutoUseCoupon = &v
	return s
}

func (s *CreateAcceleratorRequest) SetBandwidthBillingType(v string) *CreateAcceleratorRequest {
	s.BandwidthBillingType = &v
	return s
}

func (s *CreateAcceleratorRequest) SetClientToken(v string) *CreateAcceleratorRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAcceleratorRequest) SetDryRun(v bool) *CreateAcceleratorRequest {
	s.DryRun = &v
	return s
}

func (s *CreateAcceleratorRequest) SetDuration(v int32) *CreateAcceleratorRequest {
	s.Duration = &v
	return s
}

func (s *CreateAcceleratorRequest) SetInstanceChargeType(v string) *CreateAcceleratorRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *CreateAcceleratorRequest) SetIpSetConfig(v *CreateAcceleratorRequestIpSetConfig) *CreateAcceleratorRequest {
	s.IpSetConfig = v
	return s
}

func (s *CreateAcceleratorRequest) SetName(v string) *CreateAcceleratorRequest {
	s.Name = &v
	return s
}

func (s *CreateAcceleratorRequest) SetPricingCycle(v string) *CreateAcceleratorRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateAcceleratorRequest) SetPromotionOptionNo(v string) *CreateAcceleratorRequest {
	s.PromotionOptionNo = &v
	return s
}

func (s *CreateAcceleratorRequest) SetRegionId(v string) *CreateAcceleratorRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAcceleratorRequest) SetResourceGroupId(v string) *CreateAcceleratorRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateAcceleratorRequest) SetSpec(v string) *CreateAcceleratorRequest {
	s.Spec = &v
	return s
}

func (s *CreateAcceleratorRequest) SetTag(v []*CreateAcceleratorRequestTag) *CreateAcceleratorRequest {
	s.Tag = v
	return s
}

type CreateAcceleratorRequestIpSetConfig struct {
	// The access mode of the acceleration area. Valid values:
	//
	// *   **UserDefine:** custom nearby access mode. You can select acceleration areas and regions based on your business requirements. GA allocates a separate EIP to each acceleration region.
	// *   **Anycast:** automatic nearby access mode. You do not need to specify an acceleration area. GA allocates an Anycast EIP to multiple regions across the globe. Users can connect to the nearest access point of the Alibaba Cloud global transmission network by sending requests to the Anycast EIP.
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
}

func (s CreateAcceleratorRequestIpSetConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateAcceleratorRequestIpSetConfig) GoString() string {
	return s.String()
}

func (s *CreateAcceleratorRequestIpSetConfig) SetAccessMode(v string) *CreateAcceleratorRequestIpSetConfig {
	s.AccessMode = &v
	return s
}

type CreateAcceleratorRequestTag struct {
	// The tag key of the GA instance. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the GA instance. The tag value cannot be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateAcceleratorRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateAcceleratorRequestTag) GoString() string {
	return s.String()
}

func (s *CreateAcceleratorRequestTag) SetKey(v string) *CreateAcceleratorRequestTag {
	s.Key = &v
	return s
}

func (s *CreateAcceleratorRequestTag) SetValue(v string) *CreateAcceleratorRequestTag {
	s.Value = &v
	return s
}

type CreateAcceleratorResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the order.
	//
	// If you did not configure automatic payment, you must go to the [Order Center](https://usercenter2-intl.aliyun.com/order/list) to complete the payments.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAcceleratorResponseBody) SetAcceleratorId(v string) *CreateAcceleratorResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *CreateAcceleratorResponseBody) SetOrderId(v string) *CreateAcceleratorResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateAcceleratorResponseBody) SetRequestId(v string) *CreateAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type CreateAcceleratorResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *CreateAcceleratorResponse) SetHeaders(v map[string]*string) *CreateAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *CreateAcceleratorResponse) SetStatusCode(v int32) *CreateAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAcceleratorResponse) SetBody(v *CreateAcceleratorResponseBody) *CreateAcceleratorResponse {
	s.Body = v
	return s
}

type CreateAclRequest struct {
	// The entries of IP addresses or CIDR blocks to add to the ACL.
	//
	// You can add up to 20 entries in each request.
	AclEntries []*CreateAclRequestAclEntries `json:"AclEntries,omitempty" xml:"AclEntries,omitempty" type:"Repeated"`
	// The name of the ACL. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The IP version of the ACL. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Default value: false. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags of the ACL.
	Tag []*CreateAclRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateAclRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAclRequest) GoString() string {
	return s.String()
}

func (s *CreateAclRequest) SetAclEntries(v []*CreateAclRequestAclEntries) *CreateAclRequest {
	s.AclEntries = v
	return s
}

func (s *CreateAclRequest) SetAclName(v string) *CreateAclRequest {
	s.AclName = &v
	return s
}

func (s *CreateAclRequest) SetAddressIPVersion(v string) *CreateAclRequest {
	s.AddressIPVersion = &v
	return s
}

func (s *CreateAclRequest) SetClientToken(v string) *CreateAclRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAclRequest) SetDryRun(v bool) *CreateAclRequest {
	s.DryRun = &v
	return s
}

func (s *CreateAclRequest) SetRegionId(v string) *CreateAclRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAclRequest) SetResourceGroupId(v string) *CreateAclRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateAclRequest) SetTag(v []*CreateAclRequestTag) *CreateAclRequest {
	s.Tag = v
	return s
}

type CreateAclRequestAclEntries struct {
	// The IP addresses (192.168.XX.XX) or CIDR blocks (10.0.XX.XX/24) that you want to add to the ACL.
	//
	// You can add up to 20 entries in each request.
	Entry *string `json:"Entry,omitempty" xml:"Entry,omitempty"`
	// The description of the entry that you want to add to the ACL.
	//
	// You can add the descriptions of up to 20 entries in each request.
	//
	// The description must be 1 to 256 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	EntryDescription *string `json:"EntryDescription,omitempty" xml:"EntryDescription,omitempty"`
}

func (s CreateAclRequestAclEntries) String() string {
	return tea.Prettify(s)
}

func (s CreateAclRequestAclEntries) GoString() string {
	return s.String()
}

func (s *CreateAclRequestAclEntries) SetEntry(v string) *CreateAclRequestAclEntries {
	s.Entry = &v
	return s
}

func (s *CreateAclRequestAclEntries) SetEntryDescription(v string) *CreateAclRequestAclEntries {
	s.EntryDescription = &v
	return s
}

type CreateAclRequestTag struct {
	// The tag key of the ACL. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the ACL. The tag value cannot be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateAclRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateAclRequestTag) GoString() string {
	return s.String()
}

func (s *CreateAclRequestTag) SetKey(v string) *CreateAclRequestTag {
	s.Key = &v
	return s
}

func (s *CreateAclRequestTag) SetValue(v string) *CreateAclRequestTag {
	s.Value = &v
	return s
}

type CreateAclResponseBody struct {
	// The ID of the ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAclResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAclResponseBody) SetAclId(v string) *CreateAclResponseBody {
	s.AclId = &v
	return s
}

func (s *CreateAclResponseBody) SetRequestId(v string) *CreateAclResponseBody {
	s.RequestId = &v
	return s
}

type CreateAclResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAclResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAclResponse) GoString() string {
	return s.String()
}

func (s *CreateAclResponse) SetHeaders(v map[string]*string) *CreateAclResponse {
	s.Headers = v
	return s
}

func (s *CreateAclResponse) SetStatusCode(v int32) *CreateAclResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAclResponse) SetBody(v *CreateAclResponseBody) *CreateAclResponse {
	s.Body = v
	return s
}

type CreateApplicationMonitorRequest struct {
	// The ID of the GA instance on which to execute the origin probing task.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The URL or IP address that you want to probe.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable the automatic diagnostics feature. Default value: false. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	DetectEnable *bool `json:"DetectEnable,omitempty" xml:"DetectEnable,omitempty"`
	// The threshold that is used to trigger the automatic diagnostics feature. Unit: %.
	//
	// Valid values: **0** to **100**.
	//
	// The default value is **0**, which indicates that the automatic diagnostics feature is not triggered.
	DetectThreshold *int32 `json:"DetectThreshold,omitempty" xml:"DetectThreshold,omitempty"`
	// The number of times that are required to reach the threshold before the automatic diagnostics feature can be triggered.
	//
	// Valid values: **1** to **20**. Default value: **1**.
	DetectTimes *int32 `json:"DetectTimes,omitempty" xml:"DetectTimes,omitempty"`
	// The ID of the listener on which to execute the origin probing task.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The extended options of the listener protocol that is used by the origin probing task. The options vary based on the listener protocol.
	OptionsJson *string `json:"OptionsJson,omitempty" xml:"OptionsJson,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The silence period of the automatic diagnostics feature. This parameter specifies the interval at which the automatic diagnostics feature is triggered. If the availability rate does not return to normal after GA triggers an automatic diagnostic, GA must wait until the silence period ends before GA can trigger another automatic diagnostic.
	//
	// If the number of consecutive times that the availability rate drops below the threshold of automatic diagnostics reaches the value of the **DetectTimes** parameter, the automatic diagnostics feature is triggered. The automatic diagnostics feature is not triggered again within the silence period even if the availability rate stays below the threshold. If the availability rate does not return to normal after the silence period ends, the automatic diagnostics feature is triggered again.
	//
	// Unit: seconds. Valid values: **300** to **86400**. Default value: **300**.
	SilenceTime *int32 `json:"SilenceTime,omitempty" xml:"SilenceTime,omitempty"`
	// The name of the origin probing task.
	//
	// The name must be 4 to 100 characters in length, and can contain digits, underscores (\_), and hyphens (-). It must start with a letter.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s CreateApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *CreateApplicationMonitorRequest) SetAcceleratorId(v string) *CreateApplicationMonitorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetAddress(v string) *CreateApplicationMonitorRequest {
	s.Address = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetClientToken(v string) *CreateApplicationMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetDetectEnable(v bool) *CreateApplicationMonitorRequest {
	s.DetectEnable = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetDetectThreshold(v int32) *CreateApplicationMonitorRequest {
	s.DetectThreshold = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetDetectTimes(v int32) *CreateApplicationMonitorRequest {
	s.DetectTimes = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetListenerId(v string) *CreateApplicationMonitorRequest {
	s.ListenerId = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetOptionsJson(v string) *CreateApplicationMonitorRequest {
	s.OptionsJson = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetRegionId(v string) *CreateApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetSilenceTime(v int32) *CreateApplicationMonitorRequest {
	s.SilenceTime = &v
	return s
}

func (s *CreateApplicationMonitorRequest) SetTaskName(v string) *CreateApplicationMonitorRequest {
	s.TaskName = &v
	return s
}

type CreateApplicationMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the origin probing task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateApplicationMonitorResponseBody) SetRequestId(v string) *CreateApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateApplicationMonitorResponseBody) SetTaskId(v string) *CreateApplicationMonitorResponseBody {
	s.TaskId = &v
	return s
}

type CreateApplicationMonitorResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *CreateApplicationMonitorResponse) SetHeaders(v map[string]*string) *CreateApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *CreateApplicationMonitorResponse) SetStatusCode(v int32) *CreateApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateApplicationMonitorResponse) SetBody(v *CreateApplicationMonitorResponseBody) *CreateApplicationMonitorResponse {
	s.Body = v
	return s
}

type CreateBandwidthPackageRequest struct {
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **false** (default): disables automatic payment. If you select this option, you must go to the Order Center to complete the payment after an order is generated.
	// *   **true**: enables automatic payment. Payments are automatically completed.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal for the bandwidth plan. Valid values:
	//
	// *   **true**: enables auto-renewal.
	// *   **false** (default): does not enable auto-renewal.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal duration. Unit: months.
	//
	// Valid values: **1** to **12**. Default value: **1**.
	//
	// >  This parameter is required only if **AutoRenew** is set to **true**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// Specifies whether to automatically pay bills by using coupons. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// >  This parameter is required only if **AutoPay** is set to **true**.
	AutoUseCoupon *string `json:"AutoUseCoupon,omitempty" xml:"AutoUseCoupon,omitempty"`
	// The bandwidth of the bandwidth plan. Unit: Mbit/s.
	//
	// Valid values: **2** to **2000**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The type of the bandwidth. Valid values:
	//
	// *   **Basic**: standard bandwidth
	// *   **Enhanced**: enhanced bandwidth
	// *   **Advanced**: premium bandwidth
	//
	// If **Type** is set to **Basic**, this parameter is required.
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The metering method that is used when you use the pay-as-you-go billing method. Valid values:
	//
	// *   **PayByTraffic** (default): pay-by-data-transfer
	// *   **PayBY95**: pay-by-95th-percentile By default, the pay-by-95th-percentile metering method is unavailable. If you want to use the metering method, contact your account manager.
	BillingType *string `json:"BillingType,omitempty" xml:"BillingType,omitempty"`
	// Area A to be connected. Set the value to **China-mainland**.
	//
	// You can set this parameter only if you call this operation on the international site (alibabacloud.com).
	CbnGeographicRegionIdA *string `json:"CbnGeographicRegionIdA,omitempty" xml:"CbnGeographicRegionIdA,omitempty"`
	// Area B to be connected. Set the value to **Global**.
	//
	// You can set this parameter only if you call this operation on the international site (alibabacloud.com).
	CbnGeographicRegionIdB *string `json:"CbnGeographicRegionIdB,omitempty" xml:"CbnGeographicRegionIdB,omitempty"`
	// The billing method of the bandwidth plan. Valid values:
	//
	// *   **PREPAY** (default): subscription.
	// *   **POSTPAY**: pay-as-you-go. By default, the pay-as-you-go billing method is unavailable. If you want to use the billing method, contact your account manager.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The ClientToken value contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The subscription duration.
	//
	// *   If the **PricingCycle** parameter is set to **Month**, the valid values for the **Duration** parameter are **1** to **9**.
	// *   If the **PricingCycle** parameter is set to **Year**, the valid values for the **Duration** parameter are **1** to **3**.
	//
	// If **ChargeType** is set to **PREPAY**, this parameter is required.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The billing cycle. Valid values:
	//
	// *   **Month**: billed on a monthly basis.
	// *   **Year**: billed on an annual basis.
	//
	// If **ChargeType** is set to **PREPAY**, this parameter is required.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The coupon code.
	//
	// >  This parameter is only available on the international site (alibabacloud.com).
	PromotionOptionNo *string `json:"PromotionOptionNo,omitempty" xml:"PromotionOptionNo,omitempty"`
	// The percentage of the minimum bandwidth guaranteed if the pay-by-95th-percentile-bandwidth metering method is used. Valid values: **30** to **100**.
	//
	// >  This parameter is required only if **BillingType** is set to **PayBY95**.
	Ratio *int32 `json:"Ratio,omitempty" xml:"Ratio,omitempty"`
	// The ID of the region where the GA instance is deployed. **cn-hangzhou** is returned.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags to add to the bandwidth plan.
	Tag []*CreateBandwidthPackageRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The type of the bandwidth plan. Valid values:
	//
	// *   **Basic**: a basic bandwidth plan
	// *   **CrossDomain**: a cross-region acceleration bandwidth plan
	//
	// If you call this operation on the Alibaba Cloud China site, only **Basic** is supported.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *CreateBandwidthPackageRequest) SetAutoPay(v bool) *CreateBandwidthPackageRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetAutoRenew(v bool) *CreateBandwidthPackageRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetAutoRenewDuration(v int32) *CreateBandwidthPackageRequest {
	s.AutoRenewDuration = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetAutoUseCoupon(v string) *CreateBandwidthPackageRequest {
	s.AutoUseCoupon = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetBandwidth(v int32) *CreateBandwidthPackageRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetBandwidthType(v string) *CreateBandwidthPackageRequest {
	s.BandwidthType = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetBillingType(v string) *CreateBandwidthPackageRequest {
	s.BillingType = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetCbnGeographicRegionIdA(v string) *CreateBandwidthPackageRequest {
	s.CbnGeographicRegionIdA = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetCbnGeographicRegionIdB(v string) *CreateBandwidthPackageRequest {
	s.CbnGeographicRegionIdB = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetChargeType(v string) *CreateBandwidthPackageRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetClientToken(v string) *CreateBandwidthPackageRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetDuration(v string) *CreateBandwidthPackageRequest {
	s.Duration = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetPricingCycle(v string) *CreateBandwidthPackageRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetPromotionOptionNo(v string) *CreateBandwidthPackageRequest {
	s.PromotionOptionNo = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetRatio(v int32) *CreateBandwidthPackageRequest {
	s.Ratio = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetRegionId(v string) *CreateBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetResourceGroupId(v string) *CreateBandwidthPackageRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateBandwidthPackageRequest) SetTag(v []*CreateBandwidthPackageRequestTag) *CreateBandwidthPackageRequest {
	s.Tag = v
	return s
}

func (s *CreateBandwidthPackageRequest) SetType(v string) *CreateBandwidthPackageRequest {
	s.Type = &v
	return s
}

type CreateBandwidthPackageRequestTag struct {
	// The tag key.
	//
	// The tag keys cannot be an empty string. The tag key can be up to 64 characters in length, and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// Each tag key corresponds to a tag value. Valid values of **N**: **1** to **20**.
	//
	// The value cannot exceed 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateBandwidthPackageRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateBandwidthPackageRequestTag) GoString() string {
	return s.String()
}

func (s *CreateBandwidthPackageRequestTag) SetKey(v string) *CreateBandwidthPackageRequestTag {
	s.Key = &v
	return s
}

func (s *CreateBandwidthPackageRequestTag) SetValue(v string) *CreateBandwidthPackageRequestTag {
	s.Value = &v
	return s
}

type CreateBandwidthPackageResponseBody struct {
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The ID of the order.
	//
	// If bills are not automatically paid, you must go to the Order Center to complete the payments.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBandwidthPackageResponseBody) SetBandwidthPackageId(v string) *CreateBandwidthPackageResponseBody {
	s.BandwidthPackageId = &v
	return s
}

func (s *CreateBandwidthPackageResponseBody) SetOrderId(v string) *CreateBandwidthPackageResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateBandwidthPackageResponseBody) SetRequestId(v string) *CreateBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type CreateBandwidthPackageResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *CreateBandwidthPackageResponse) SetHeaders(v map[string]*string) *CreateBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *CreateBandwidthPackageResponse) SetStatusCode(v int32) *CreateBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBandwidthPackageResponse) SetBody(v *CreateBandwidthPackageResponseBody) *CreateBandwidthPackageResponse {
	s.Body = v
	return s
}

type CreateBasicAccelerateIpRequest struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateBasicAccelerateIpRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpRequest) SetAcceleratorId(v string) *CreateBasicAccelerateIpRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicAccelerateIpRequest) SetClientToken(v string) *CreateBasicAccelerateIpRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicAccelerateIpRequest) SetIpSetId(v string) *CreateBasicAccelerateIpRequest {
	s.IpSetId = &v
	return s
}

func (s *CreateBasicAccelerateIpRequest) SetRegionId(v string) *CreateBasicAccelerateIpRequest {
	s.RegionId = &v
	return s
}

type CreateBasicAccelerateIpResponseBody struct {
	// The accelerated IP address.
	AccelerateIpAddress *string `json:"AccelerateIpAddress,omitempty" xml:"AccelerateIpAddress,omitempty"`
	// The ID of the accelerated IP address.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the acceleration region.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the accelerated IP address.
	//
	// >  This parameter returns an empty string because the parameter is not in use.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s CreateBasicAccelerateIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpResponseBody) SetAccelerateIpAddress(v string) *CreateBasicAccelerateIpResponseBody {
	s.AccelerateIpAddress = &v
	return s
}

func (s *CreateBasicAccelerateIpResponseBody) SetAccelerateIpId(v string) *CreateBasicAccelerateIpResponseBody {
	s.AccelerateIpId = &v
	return s
}

func (s *CreateBasicAccelerateIpResponseBody) SetAcceleratorId(v string) *CreateBasicAccelerateIpResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicAccelerateIpResponseBody) SetIpSetId(v string) *CreateBasicAccelerateIpResponseBody {
	s.IpSetId = &v
	return s
}

func (s *CreateBasicAccelerateIpResponseBody) SetRequestId(v string) *CreateBasicAccelerateIpResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateBasicAccelerateIpResponseBody) SetState(v string) *CreateBasicAccelerateIpResponseBody {
	s.State = &v
	return s
}

type CreateBasicAccelerateIpResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicAccelerateIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicAccelerateIpResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpResponse) SetHeaders(v map[string]*string) *CreateBasicAccelerateIpResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicAccelerateIpResponse) SetStatusCode(v int32) *CreateBasicAccelerateIpResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicAccelerateIpResponse) SetBody(v *CreateBasicAccelerateIpResponseBody) *CreateBasicAccelerateIpResponse {
	s.Body = v
	return s
}

type CreateBasicAccelerateIpEndpointRelationRequest struct {
	// The ID of the accelerated IP address of the basic GA instance.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint that is associated with the basic GA instance.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateBasicAccelerateIpEndpointRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpEndpointRelationRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpEndpointRelationRequest) SetAccelerateIpId(v string) *CreateBasicAccelerateIpEndpointRelationRequest {
	s.AccelerateIpId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationRequest) SetAcceleratorId(v string) *CreateBasicAccelerateIpEndpointRelationRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationRequest) SetClientToken(v string) *CreateBasicAccelerateIpEndpointRelationRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationRequest) SetEndpointId(v string) *CreateBasicAccelerateIpEndpointRelationRequest {
	s.EndpointId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationRequest) SetRegionId(v string) *CreateBasicAccelerateIpEndpointRelationRequest {
	s.RegionId = &v
	return s
}

type CreateBasicAccelerateIpEndpointRelationResponseBody struct {
	// The ID of the accelerated IP address of the basic GA instance.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint that is associated with the basic GA instance.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The association status between the accelerated IP address and endpoint.
	//
	// >  This parameter is not in use and empty.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s CreateBasicAccelerateIpEndpointRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpEndpointRelationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpEndpointRelationResponseBody) SetAccelerateIpId(v string) *CreateBasicAccelerateIpEndpointRelationResponseBody {
	s.AccelerateIpId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationResponseBody) SetAcceleratorId(v string) *CreateBasicAccelerateIpEndpointRelationResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationResponseBody) SetEndpointId(v string) *CreateBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationResponseBody) SetRequestId(v string) *CreateBasicAccelerateIpEndpointRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationResponseBody) SetState(v string) *CreateBasicAccelerateIpEndpointRelationResponseBody {
	s.State = &v
	return s
}

type CreateBasicAccelerateIpEndpointRelationResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicAccelerateIpEndpointRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicAccelerateIpEndpointRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpEndpointRelationResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpEndpointRelationResponse) SetHeaders(v map[string]*string) *CreateBasicAccelerateIpEndpointRelationResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationResponse) SetStatusCode(v int32) *CreateBasicAccelerateIpEndpointRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationResponse) SetBody(v *CreateBasicAccelerateIpEndpointRelationResponseBody) *CreateBasicAccelerateIpEndpointRelationResponse {
	s.Body = v
	return s
}

type CreateBasicAccelerateIpEndpointRelationsRequest struct {
	// A list of accelerated IP addresses and the endpoints with which the accelerated IP addresses are associated.
	AccelerateIpEndpointRelations []*CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations `json:"AccelerateIpEndpointRelations,omitempty" xml:"AccelerateIpEndpointRelations,omitempty" type:"Repeated"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateBasicAccelerateIpEndpointRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpEndpointRelationsRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpEndpointRelationsRequest) SetAccelerateIpEndpointRelations(v []*CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations) *CreateBasicAccelerateIpEndpointRelationsRequest {
	s.AccelerateIpEndpointRelations = v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationsRequest) SetAcceleratorId(v string) *CreateBasicAccelerateIpEndpointRelationsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationsRequest) SetClientToken(v string) *CreateBasicAccelerateIpEndpointRelationsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationsRequest) SetRegionId(v string) *CreateBasicAccelerateIpEndpointRelationsRequest {
	s.RegionId = &v
	return s
}

type CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations struct {
	// The IDs of the accelerated IP addresses.
	//
	// You can specify at most 20 IP address IDs.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The IDs of the endpoints.
	//
	// You can specify up to 20 endpoint IDs.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
}

func (s CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations) SetAccelerateIpId(v string) *CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations {
	s.AccelerateIpId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations) SetEndpointId(v string) *CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations {
	s.EndpointId = &v
	return s
}

type CreateBasicAccelerateIpEndpointRelationsResponseBody struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBasicAccelerateIpEndpointRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpEndpointRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpEndpointRelationsResponseBody) SetAcceleratorId(v string) *CreateBasicAccelerateIpEndpointRelationsResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationsResponseBody) SetRequestId(v string) *CreateBasicAccelerateIpEndpointRelationsResponseBody {
	s.RequestId = &v
	return s
}

type CreateBasicAccelerateIpEndpointRelationsResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicAccelerateIpEndpointRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicAccelerateIpEndpointRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAccelerateIpEndpointRelationsResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicAccelerateIpEndpointRelationsResponse) SetHeaders(v map[string]*string) *CreateBasicAccelerateIpEndpointRelationsResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationsResponse) SetStatusCode(v int32) *CreateBasicAccelerateIpEndpointRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicAccelerateIpEndpointRelationsResponse) SetBody(v *CreateBasicAccelerateIpEndpointRelationsResponseBody) *CreateBasicAccelerateIpEndpointRelationsResponse {
	s.Body = v
	return s
}

type CreateBasicAcceleratorRequest struct {
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **false:** disables automatic payment. If you select this option, you must go to the Order Center to complete the payment after an order is generated. This is the default value.
	// *   **true:** enables automatic payment. Payments are automatically completed.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal for the basic GA instance. Valid values:
	//
	// *   **true:** enables auto-renewal for the basic GA instance.
	// *   **false:** disables auto-renewal for the basic GA instance. This is the default value.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal duration. Unit: months.
	//
	// Valid values: **1** to **12**. Default value: **1**.
	//
	// >  This parameter takes effect only when the **AutoPay** parameter is set to **true**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// Specifies whether to automatically apply coupons to your bills. Valid values:
	//
	// *   **true:** automatically applies coupons to your bills.
	// *   **false:** does not automatically apply coupons to your bills. This is the default value.
	//
	// >  This parameter takes effect only when the **AutoPay** parameter is set to **true**.
	AutoUseCoupon *string `json:"AutoUseCoupon,omitempty" xml:"AutoUseCoupon,omitempty"`
	// The bandwidth billing method. Valid values:
	//
	// *   **BandwidthPackage:** billed based on bandwidth plans.
	// *   **CDT:** billed based on data transfer. The bills are managed by using Cloud Data Transfer (CDT).
	// *   **CDT95:** billed based on the 95th percentile bandwidth. The bills are managed by using Cloud Data Transfer (CDT). This bandwidth billing method is not available by default. Contact your Alibaba Cloud account manager for more information.
	BandwidthBillingType *string `json:"BandwidthBillingType,omitempty" xml:"BandwidthBillingType,omitempty"`
	// The billing method of the basic GA instance. Valid values:
	// - **PREPAY**: subscription. This is the default value.
	// - **POSTPAY**: pay-as-you-go.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true:** performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**: performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The subscription duration of the GA instance.
	//
	// *   If you set the **PricingCycle** parameter to **Month**, the valid values for the **Duration** parameter are **1** to **9**.
	// *   If you set the **PricingCycle** parameter to **Year**, the valid values for the **Duration** parameter are **1** to **3**.
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The billing cycle of the basic GA instance. Valid values:
	//
	// *   **Month:** billed on a monthly basis.
	// *   **Year:** billed on an annual basis.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The code of the coupon.
	//
	// >  This parameter takes effect only for accounts registered on the international site (alibabacloud.com).
	PromotionOptionNo *string `json:"PromotionOptionNo,omitempty" xml:"PromotionOptionNo,omitempty"`
	// The ID of the region where the basic GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the basic GA instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags of the basic GA instance.
	Tag []*CreateBasicAcceleratorRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateBasicAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicAcceleratorRequest) SetAutoPay(v bool) *CreateBasicAcceleratorRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetAutoRenew(v bool) *CreateBasicAcceleratorRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetAutoRenewDuration(v int32) *CreateBasicAcceleratorRequest {
	s.AutoRenewDuration = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetAutoUseCoupon(v string) *CreateBasicAcceleratorRequest {
	s.AutoUseCoupon = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetBandwidthBillingType(v string) *CreateBasicAcceleratorRequest {
	s.BandwidthBillingType = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetChargeType(v string) *CreateBasicAcceleratorRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetClientToken(v string) *CreateBasicAcceleratorRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetDryRun(v bool) *CreateBasicAcceleratorRequest {
	s.DryRun = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetDuration(v int32) *CreateBasicAcceleratorRequest {
	s.Duration = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetPricingCycle(v string) *CreateBasicAcceleratorRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetPromotionOptionNo(v string) *CreateBasicAcceleratorRequest {
	s.PromotionOptionNo = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetRegionId(v string) *CreateBasicAcceleratorRequest {
	s.RegionId = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetResourceGroupId(v string) *CreateBasicAcceleratorRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateBasicAcceleratorRequest) SetTag(v []*CreateBasicAcceleratorRequestTag) *CreateBasicAcceleratorRequest {
	s.Tag = v
	return s
}

type CreateBasicAcceleratorRequestTag struct {
	// The tag key of the basic GA instance. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the basic GA instance. The tag value cannot be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateBasicAcceleratorRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAcceleratorRequestTag) GoString() string {
	return s.String()
}

func (s *CreateBasicAcceleratorRequestTag) SetKey(v string) *CreateBasicAcceleratorRequestTag {
	s.Key = &v
	return s
}

func (s *CreateBasicAcceleratorRequestTag) SetValue(v string) *CreateBasicAcceleratorRequestTag {
	s.Value = &v
	return s
}

type CreateBasicAcceleratorResponseBody struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBasicAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicAcceleratorResponseBody) SetAcceleratorId(v string) *CreateBasicAcceleratorResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicAcceleratorResponseBody) SetOrderId(v string) *CreateBasicAcceleratorResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateBasicAcceleratorResponseBody) SetRequestId(v string) *CreateBasicAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type CreateBasicAcceleratorResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicAcceleratorResponse) SetHeaders(v map[string]*string) *CreateBasicAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicAcceleratorResponse) SetStatusCode(v int32) *CreateBasicAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicAcceleratorResponse) SetBody(v *CreateBasicAcceleratorResponseBody) *CreateBasicAcceleratorResponse {
	s.Body = v
	return s
}

type CreateBasicEndpointRequest struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is required if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, you can set **EndpointSubAddress** to the secondary private IP address of the primary ENI. If the parameter is left empty, the primary private IP address of the primary ENI is used.
	// *   If the endpoint type is **ENI**, you can set **EndpointSubAddress** to the secondary private IP address of the secondary ENI. If the parameter is left empty, the primary private IP address of the secondary ENI is used.
	// *   This parameter is required if the endpoint type is **NLB**. **EndpointSubAddress** is the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of the secondary address of the endpoint. Valid values:
	//
	// *   **primary**: a primary private IP address.
	// *   **secondary**: a secondary private IP address.
	//
	// This parameter is required if the endpoint type is **ECS**, **ENI**, or **NLB**. If the endpoint type is **NLB**, only **primary** is supported.
	EndpointSubAddressType *string `json:"EndpointSubAddressType,omitempty" xml:"EndpointSubAddressType,omitempty"`
	// The type of endpoint. Valid values:
	//
	// *   **ENI**: elastic network interface (ENI)
	// *   **SLB**: Classic Load Balancer (CLB)
	// *   **ECS**: Elastic Compute Service (ECS)
	// *   **NLB**: Network Load Balancer (NLB)
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The zone ID of the endpoint.
	//
	// This parameter is required only if the endpoint type is **NLB**.
	EndpointZoneId *string `json:"EndpointZoneId,omitempty" xml:"EndpointZoneId,omitempty"`
	// The name of the endpoint.
	//
	// The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateBasicEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointRequest) SetAcceleratorId(v string) *CreateBasicEndpointRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetClientToken(v string) *CreateBasicEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetEndpointAddress(v string) *CreateBasicEndpointRequest {
	s.EndpointAddress = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetEndpointGroupId(v string) *CreateBasicEndpointRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetEndpointSubAddress(v string) *CreateBasicEndpointRequest {
	s.EndpointSubAddress = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetEndpointSubAddressType(v string) *CreateBasicEndpointRequest {
	s.EndpointSubAddressType = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetEndpointType(v string) *CreateBasicEndpointRequest {
	s.EndpointType = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetEndpointZoneId(v string) *CreateBasicEndpointRequest {
	s.EndpointZoneId = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetName(v string) *CreateBasicEndpointRequest {
	s.Name = &v
	return s
}

func (s *CreateBasicEndpointRequest) SetRegionId(v string) *CreateBasicEndpointRequest {
	s.RegionId = &v
	return s
}

type CreateBasicEndpointResponseBody struct {
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBasicEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointResponseBody) SetEndpointGroupId(v string) *CreateBasicEndpointResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateBasicEndpointResponseBody) SetEndpointId(v string) *CreateBasicEndpointResponseBody {
	s.EndpointId = &v
	return s
}

func (s *CreateBasicEndpointResponseBody) SetRequestId(v string) *CreateBasicEndpointResponseBody {
	s.RequestId = &v
	return s
}

type CreateBasicEndpointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointResponse) SetHeaders(v map[string]*string) *CreateBasicEndpointResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicEndpointResponse) SetStatusCode(v int32) *CreateBasicEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicEndpointResponse) SetBody(v *CreateBasicEndpointResponseBody) *CreateBasicEndpointResponse {
	s.Body = v
	return s
}

type CreateBasicEndpointGroupRequest struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the endpoint group.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The endpoint address.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the region where you want to create the endpoint group.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The secondary address of the endpoint.
	//
	// You must specify this parameter when the accelerated IP address is associated with the secondary private IP address of an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
	//
	// *   When the endpoint type is **ECS**, you can set **EndpointSubAddress** to the secondary private IP address of the primary ENI. If the parameter is left empty, the primary private IP address of the primary ENI is used.
	// *   If the endpoint type is **ENI**, you can set **EndpointSubAddress** to the secondary private IP address of the secondary ENI. If the parameter is left empty, the primary private IP address of the secondary ENI is used.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **ENI**
	// *   **SLB**
	// *   **ECS**
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The name of the endpoint group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateBasicEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointGroupRequest) SetAcceleratorId(v string) *CreateBasicEndpointGroupRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetClientToken(v string) *CreateBasicEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetDescription(v string) *CreateBasicEndpointGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetEndpointAddress(v string) *CreateBasicEndpointGroupRequest {
	s.EndpointAddress = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetEndpointGroupRegion(v string) *CreateBasicEndpointGroupRequest {
	s.EndpointGroupRegion = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetEndpointSubAddress(v string) *CreateBasicEndpointGroupRequest {
	s.EndpointSubAddress = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetEndpointType(v string) *CreateBasicEndpointGroupRequest {
	s.EndpointType = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetName(v string) *CreateBasicEndpointGroupRequest {
	s.Name = &v
	return s
}

func (s *CreateBasicEndpointGroupRequest) SetRegionId(v string) *CreateBasicEndpointGroupRequest {
	s.RegionId = &v
	return s
}

type CreateBasicEndpointGroupResponseBody struct {
	// The endpoint group ID.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBasicEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointGroupResponseBody) SetEndpointGroupId(v string) *CreateBasicEndpointGroupResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateBasicEndpointGroupResponseBody) SetRequestId(v string) *CreateBasicEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateBasicEndpointGroupResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointGroupResponse) SetHeaders(v map[string]*string) *CreateBasicEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicEndpointGroupResponse) SetStatusCode(v int32) *CreateBasicEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicEndpointGroupResponse) SetBody(v *CreateBasicEndpointGroupResponseBody) *CreateBasicEndpointGroupResponse {
	s.Body = v
	return s
}

type CreateBasicEndpointsRequest struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The endpoints in the endpoint group.
	Endpoints []*CreateBasicEndpointsRequestEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateBasicEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointsRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointsRequest) SetAcceleratorId(v string) *CreateBasicEndpointsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicEndpointsRequest) SetClientToken(v string) *CreateBasicEndpointsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicEndpointsRequest) SetEndpointGroupId(v string) *CreateBasicEndpointsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateBasicEndpointsRequest) SetEndpoints(v []*CreateBasicEndpointsRequestEndpoints) *CreateBasicEndpointsRequest {
	s.Endpoints = v
	return s
}

func (s *CreateBasicEndpointsRequest) SetRegionId(v string) *CreateBasicEndpointsRequest {
	s.RegionId = &v
	return s
}

type CreateBasicEndpointsRequestEndpoints struct {
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is required if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, you can set the **EndpointSubAddress** parameter to the secondary private IP address of the primary ENI. If the parameter is left empty, the primary private IP address of the primary ENI is used.
	// *   If the endpoint type is **ENI**, you can set the **EndpointSubAddress** parameter to the secondary private IP address of the secondary ENI. If the parameter is left empty, the primary private IP address of the secondary ENI is used.
	// *   This parameter is required if the endpoint type is **NLB**. **EndpointSubAddress** is the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The secondary address type of the endpoint. Valid values:
	//
	// *   **primary:** a primary private IP address.
	// *   **secondary:** a secondary private IP address.
	//
	// This parameter is required if the endpoint type is **ECS**, **ENI**, or **NLB**. If the endpoint type is **NLB**, only **primary** is supported.
	EndpointSubAddressType *string `json:"EndpointSubAddressType,omitempty" xml:"EndpointSubAddressType,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **ENI:** elastic network interface (ENI).
	// *   **SLB:** Classic Load Balancer (CLB) instance.
	// *   **ECS:** Elastic Compute Service (ECS) instance.
	// *   **NLB:** Network Load Balancer (NLB) instance.
	//
	// >  This parameter is required.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The ID of the zone where the endpoint resides.
	//
	// This parameter is required only if the endpoint type is **NLB**.
	EndpointZoneId *string `json:"EndpointZoneId,omitempty" xml:"EndpointZoneId,omitempty"`
	// The name of the endpoint.
	//
	// The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateBasicEndpointsRequestEndpoints) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointsRequestEndpoints) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointsRequestEndpoints) SetEndpointAddress(v string) *CreateBasicEndpointsRequestEndpoints {
	s.EndpointAddress = &v
	return s
}

func (s *CreateBasicEndpointsRequestEndpoints) SetEndpointSubAddress(v string) *CreateBasicEndpointsRequestEndpoints {
	s.EndpointSubAddress = &v
	return s
}

func (s *CreateBasicEndpointsRequestEndpoints) SetEndpointSubAddressType(v string) *CreateBasicEndpointsRequestEndpoints {
	s.EndpointSubAddressType = &v
	return s
}

func (s *CreateBasicEndpointsRequestEndpoints) SetEndpointType(v string) *CreateBasicEndpointsRequestEndpoints {
	s.EndpointType = &v
	return s
}

func (s *CreateBasicEndpointsRequestEndpoints) SetEndpointZoneId(v string) *CreateBasicEndpointsRequestEndpoints {
	s.EndpointZoneId = &v
	return s
}

func (s *CreateBasicEndpointsRequestEndpoints) SetName(v string) *CreateBasicEndpointsRequestEndpoints {
	s.Name = &v
	return s
}

type CreateBasicEndpointsResponseBody struct {
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The endpoints in the endpoint group.
	Endpoints []*CreateBasicEndpointsResponseBodyEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBasicEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointsResponseBody) SetEndpointGroupId(v string) *CreateBasicEndpointsResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateBasicEndpointsResponseBody) SetEndpoints(v []*CreateBasicEndpointsResponseBodyEndpoints) *CreateBasicEndpointsResponseBody {
	s.Endpoints = v
	return s
}

func (s *CreateBasicEndpointsResponseBody) SetRequestId(v string) *CreateBasicEndpointsResponseBody {
	s.RequestId = &v
	return s
}

type CreateBasicEndpointsResponseBodyEndpoints struct {
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, **EndpointSubAddress** returns the primary or secondary private IP address of the primary ENI.
	// *   If the endpoint type is **ENI**, **EndpointSubAddress** returns the primary or secondary private IP address of the secondary ENI.
	// *   If the endpoint type is **NLB**, **EndpointSubAddress** returns the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **ENI:** ENI.
	// *   **SLB:** CLB instance.
	// *   **ECS:** ECS instance.
	// *   **NLB:** NLB instance.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
}

func (s CreateBasicEndpointsResponseBodyEndpoints) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointsResponseBodyEndpoints) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointsResponseBodyEndpoints) SetEndpointAddress(v string) *CreateBasicEndpointsResponseBodyEndpoints {
	s.EndpointAddress = &v
	return s
}

func (s *CreateBasicEndpointsResponseBodyEndpoints) SetEndpointId(v string) *CreateBasicEndpointsResponseBodyEndpoints {
	s.EndpointId = &v
	return s
}

func (s *CreateBasicEndpointsResponseBodyEndpoints) SetEndpointSubAddress(v string) *CreateBasicEndpointsResponseBodyEndpoints {
	s.EndpointSubAddress = &v
	return s
}

func (s *CreateBasicEndpointsResponseBodyEndpoints) SetEndpointType(v string) *CreateBasicEndpointsResponseBodyEndpoints {
	s.EndpointType = &v
	return s
}

type CreateBasicEndpointsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicEndpointsResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicEndpointsResponse) SetHeaders(v map[string]*string) *CreateBasicEndpointsResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicEndpointsResponse) SetStatusCode(v int32) *CreateBasicEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicEndpointsResponse) SetBody(v *CreateBasicEndpointsResponseBody) *CreateBasicEndpointsResponse {
	s.Body = v
	return s
}

type CreateBasicIpSetRequest struct {
	// The ID of the acceleration region.
	//
	// You can call the [ListAvailableBusiRegions](~~261190~~) operation to query the most recent acceleration region list.
	AccelerateRegionId *string `json:"AccelerateRegionId,omitempty" xml:"AccelerateRegionId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth to be allocated to the acceleration region. Unit: **Mbit/s**.
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The line type of the elastic IP address (EIP) in the acceleration region. Valid values:
	//
	// *   **BGP** (default)
	// *   **BGP_PRO** If the acceleration region is China (Hong Kong) and a basic bandwidth plan whose bandwidth type is Premium is associated with the GA instance, the default value of IspType is BGP_PRO.
	//
	// If you are allowed to use single-ISP bandwidth, you can also specify one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom (single ISP)
	// *   **ChinaUnicom**: China Unicom (single ISP)
	// *   **ChinaMobile**: China Mobile (single ISP)
	// *   **ChinaTelecom_L2**: China Telecom \_L2 (single ISP)
	// *   **ChinaUnicom_L2**: China Unicom \_L2 (single ISP)
	// *   **ChinaMobile_L2**: China Mobile \_L2 (single ISP)
	//
	// > Different acceleration regions support different single-ISP BGP lines.
	IspType *string `json:"IspType,omitempty" xml:"IspType,omitempty"`
	// The region ID of the basic GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateBasicIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicIpSetRequest) GoString() string {
	return s.String()
}

func (s *CreateBasicIpSetRequest) SetAccelerateRegionId(v string) *CreateBasicIpSetRequest {
	s.AccelerateRegionId = &v
	return s
}

func (s *CreateBasicIpSetRequest) SetAcceleratorId(v string) *CreateBasicIpSetRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateBasicIpSetRequest) SetBandwidth(v int64) *CreateBasicIpSetRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateBasicIpSetRequest) SetClientToken(v string) *CreateBasicIpSetRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateBasicIpSetRequest) SetIspType(v string) *CreateBasicIpSetRequest {
	s.IspType = &v
	return s
}

func (s *CreateBasicIpSetRequest) SetRegionId(v string) *CreateBasicIpSetRequest {
	s.RegionId = &v
	return s
}

type CreateBasicIpSetResponseBody struct {
	// The region ID of the GA instance.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBasicIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBasicIpSetResponseBody) SetIpSetId(v string) *CreateBasicIpSetResponseBody {
	s.IpSetId = &v
	return s
}

func (s *CreateBasicIpSetResponseBody) SetRequestId(v string) *CreateBasicIpSetResponseBody {
	s.RequestId = &v
	return s
}

type CreateBasicIpSetResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBasicIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBasicIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBasicIpSetResponse) GoString() string {
	return s.String()
}

func (s *CreateBasicIpSetResponse) SetHeaders(v map[string]*string) *CreateBasicIpSetResponse {
	s.Headers = v
	return s
}

func (s *CreateBasicIpSetResponse) SetStatusCode(v int32) *CreateBasicIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBasicIpSetResponse) SetBody(v *CreateBasicIpSetResponseBody) *CreateBasicIpSetResponse {
	s.Body = v
	return s
}

type CreateCustomRoutingEndpointGroupDestinationsRequest struct {
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**: performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The mapping configuration of the endpoint group.
	//
	// You need to specify the backend service ports and protocols for the endpoint group. The ports are mapped to listener ports.
	//
	// You can specify up to 20 mappings in each call.
	DestinationConfigurations []*CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations `json:"DestinationConfigurations,omitempty" xml:"DestinationConfigurations,omitempty" type:"Repeated"`
	// The endpoint group ID.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The mappings of the endpoint group.
	//
	// You need to specify the backend service ports and protocols for the endpoint group. The ports are mapped to listener ports.
	//
	// You can specify up to 20 mappings in each call.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupDestinationsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupDestinationsRequest) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequest) SetClientToken(v string) *CreateCustomRoutingEndpointGroupDestinationsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequest) SetDestinationConfigurations(v []*CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) *CreateCustomRoutingEndpointGroupDestinationsRequest {
	s.DestinationConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequest) SetDryRun(v bool) *CreateCustomRoutingEndpointGroupDestinationsRequest {
	s.DryRun = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequest) SetEndpointGroupId(v string) *CreateCustomRoutingEndpointGroupDestinationsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequest) SetRegionId(v string) *CreateCustomRoutingEndpointGroupDestinationsRequest {
	s.RegionId = &v
	return s
}

type CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations struct {
	// The last port of the backend service port range.
	//
	// Valid values: **1** to **65499**. The value of **FromPort** must be equal to or smaller than the value of **ToPort**.
	//
	// You can specify up to 20 last ports in each call.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The backend service protocol of the endpoint group. Valid values:
	//
	// *   **TCP**
	// *   **UDP**
	// *   **TCP+UDP: the TCP and UDP protocols.**
	//
	// You can specify up to four backend service protocols for each endpoint group mapping.
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The response parameters.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) SetFromPort(v int32) *CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations {
	s.FromPort = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) SetProtocols(v []*string) *CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations {
	s.Protocols = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) SetToPort(v int32) *CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations {
	s.ToPort = &v
	return s
}

type CreateCustomRoutingEndpointGroupDestinationsResponseBody struct {
	// The IDs of the endpoint group mappings.
	DestinationIds []*string `json:"DestinationIds,omitempty" xml:"DestinationIds,omitempty" type:"Repeated"`
	// The IDs of the endpoint group mappings.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupDestinationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupDestinationsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupDestinationsResponseBody) SetDestinationIds(v []*string) *CreateCustomRoutingEndpointGroupDestinationsResponseBody {
	s.DestinationIds = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsResponseBody) SetRequestId(v string) *CreateCustomRoutingEndpointGroupDestinationsResponseBody {
	s.RequestId = &v
	return s
}

type CreateCustomRoutingEndpointGroupDestinationsResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCustomRoutingEndpointGroupDestinationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCustomRoutingEndpointGroupDestinationsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupDestinationsResponse) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupDestinationsResponse) SetHeaders(v map[string]*string) *CreateCustomRoutingEndpointGroupDestinationsResponse {
	s.Headers = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsResponse) SetStatusCode(v int32) *CreateCustomRoutingEndpointGroupDestinationsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupDestinationsResponse) SetBody(v *CreateCustomRoutingEndpointGroupDestinationsResponseBody) *CreateCustomRoutingEndpointGroupDestinationsResponse {
	s.Body = v
	return s
}

type CreateCustomRoutingEndpointGroupsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request is different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The information about the endpoint groups.
	//
	// You can specify at most five endpoint groups.
	EndpointGroupConfigurations []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations `json:"EndpointGroupConfigurations,omitempty" xml:"EndpointGroupConfigurations,omitempty" type:"Repeated"`
	// The ID of the custom routing listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsRequest) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsRequest) SetAcceleratorId(v string) *CreateCustomRoutingEndpointGroupsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequest) SetClientToken(v string) *CreateCustomRoutingEndpointGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequest) SetDryRun(v bool) *CreateCustomRoutingEndpointGroupsRequest {
	s.DryRun = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequest) SetEndpointGroupConfigurations(v []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) *CreateCustomRoutingEndpointGroupsRequest {
	s.EndpointGroupConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequest) SetListenerId(v string) *CreateCustomRoutingEndpointGroupsRequest {
	s.ListenerId = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequest) SetRegionId(v string) *CreateCustomRoutingEndpointGroupsRequest {
	s.RegionId = &v
	return s
}

type CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations struct {
	// The description of the endpoint group.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	//
	// You can specify at most five endpoint group descriptions.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mapping configuration of the endpoint group.
	//
	// You need to specify the backend service ports and protocols for the endpoint group. The ports are mapped to listener ports.
	//
	// You can specify at most 20 mapping configurations for each endpoint group.
	DestinationConfigurations []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations `json:"DestinationConfigurations,omitempty" xml:"DestinationConfigurations,omitempty" type:"Repeated"`
	// The information about the endpoints.
	//
	// You can specify at most 10 endpoints for each endpoint group.
	EndpointConfigurations []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The ID of the region in which the endpoint group resides.
	//
	// You can specify at most five region IDs.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The name of the endpoint group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// You can specify at most five endpoint group names.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) SetDescription(v string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations {
	s.Description = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) SetDestinationConfigurations(v []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations {
	s.DestinationConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointConfigurations(v []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupRegion(v string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupRegion = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations) SetName(v string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations {
	s.Name = &v
	return s
}

type CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations struct {
	// The first backend service port for the endpoint group.
	//
	// Valid values: **1** to **65499**. The value of **FromPort** must be smaller than or equal to the value of **ToPort**.
	//
	// You can specify at most 20 first backend service ports for each endpoint group.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The backend service protocol.
	//
	// You can specify up to four backend service protocols in each mapping configuration.
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The last backend service port for the endpoint group.
	//
	// Valid values: **1** to **65499**. The value of **FromPort** must be smaller than or equal to the value of **ToPort**.
	//
	// You can specify at most 20 last backend service ports for each endpoint group.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations) SetFromPort(v int32) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations {
	s.FromPort = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations) SetProtocols(v []*string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations {
	s.Protocols = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations) SetToPort(v int32) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations {
	s.ToPort = &v
	return s
}

type CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations struct {
	// The name of the vSwitch that is specified as an endpoint.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The destination to which traffic is forwarded.
	//
	// You can specify at most 20 destinations for each endpoint.
	PolicyConfigurations []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations `json:"PolicyConfigurations,omitempty" xml:"PolicyConfigurations,omitempty" type:"Repeated"`
	// The traffic policy that is used to process traffic to the endpoint. Valid values:
	//
	// *   **AllowAll**: allows all traffic to the endpoint.
	// *   **DenyAll** (default): denies all traffic to the endpoint.
	// *   **AllowCustom**: allows traffic only to specified destinations in the endpoint.
	//
	// If you set this parameter to AllowCustom, you must specify IP addresses and port ranges as the destinations to which traffic is distributed. If you specify only IP addresses and do not specify port ranges, GA can forward traffic to the specified IP addresses over all destination ports.
	TrafficToEndpointPolicy *string `json:"TrafficToEndpointPolicy,omitempty" xml:"TrafficToEndpointPolicy,omitempty"`
	// The type of endpoint.
	//
	// Set the value to **PrivateSubNet**, which specifies a private CIDR block. This is the default value.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetEndpoint(v string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetPolicyConfigurations(v []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.PolicyConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetTrafficToEndpointPolicy(v string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.TrafficToEndpointPolicy = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetType(v string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Type = &v
	return s
}

type CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations struct {
	// The IP address of the destination to which traffic is forwarded.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify at most 20 destination IP addresses for each endpoint.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The port range of the destination to which traffic is forwarded. The value of this parameter must fall within the port range of the endpoint group.
	//
	// If you leave this parameter empty, traffic is forwarded to all destination ports.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for at most 20 destinations in each endpoint and specify at most five port ranges for each destination.
	PortRanges []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) SetAddress(v string) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations {
	s.Address = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) SetPortRanges(v []*CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations {
	s.PortRanges = v
	return s
}

type CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges struct {
	// The first port of the destination port range. The value of this parameter must fall within the port range of the endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for at most 20 destinations in each endpoint and specify at most five first ports for each destination.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port of the destination port range. The value of this parameter must fall within the port range of the endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for at most 20 destinations in each endpoint and specify at most five last ports for each destination.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) SetFromPort(v int32) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.FromPort = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) SetToPort(v int32) *CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.ToPort = &v
	return s
}

type CreateCustomRoutingEndpointGroupsResponseBody struct {
	// The IDs of the endpoint groups.
	EndpointGroupIds []*string `json:"EndpointGroupIds,omitempty" xml:"EndpointGroupIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCustomRoutingEndpointGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsResponseBody) SetEndpointGroupIds(v []*string) *CreateCustomRoutingEndpointGroupsResponseBody {
	s.EndpointGroupIds = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsResponseBody) SetRequestId(v string) *CreateCustomRoutingEndpointGroupsResponseBody {
	s.RequestId = &v
	return s
}

type CreateCustomRoutingEndpointGroupsResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCustomRoutingEndpointGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCustomRoutingEndpointGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointGroupsResponse) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointGroupsResponse) SetHeaders(v map[string]*string) *CreateCustomRoutingEndpointGroupsResponse {
	s.Headers = v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsResponse) SetStatusCode(v int32) *CreateCustomRoutingEndpointGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCustomRoutingEndpointGroupsResponse) SetBody(v *CreateCustomRoutingEndpointGroupsResponseBody) *CreateCustomRoutingEndpointGroupsResponse {
	s.Body = v
	return s
}

type CreateCustomRoutingEndpointTrafficPoliciesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request is different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint for which you want to create the traffic destinations.
	//
	// > This parameter is required.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The configurations of the traffic destinations.
	//
	// You can specify up to 500 traffic destinations for each endpoint.
	PolicyConfigurations []*CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations `json:"PolicyConfigurations,omitempty" xml:"PolicyConfigurations,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateCustomRoutingEndpointTrafficPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointTrafficPoliciesRequest) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequest) SetClientToken(v string) *CreateCustomRoutingEndpointTrafficPoliciesRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequest) SetEndpointId(v string) *CreateCustomRoutingEndpointTrafficPoliciesRequest {
	s.EndpointId = &v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequest) SetPolicyConfigurations(v []*CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) *CreateCustomRoutingEndpointTrafficPoliciesRequest {
	s.PolicyConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequest) SetRegionId(v string) *CreateCustomRoutingEndpointTrafficPoliciesRequest {
	s.RegionId = &v
	return s
}

type CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations struct {
	// The IP address of the destination to which traffic is forwarded.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify up to 500 destination IP addresses for each endpoint.
	//
	// > This parameter is required.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The port range of the destination to which traffic is forwarded. The value of this parameter must fall within the port range of the endpoint group.
	//
	// If you leave this parameter empty, traffic is forwarded to all destination ports.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 500 traffic destinations in each endpoint and specify up to 10 port ranges for each traffic destination.
	PortRanges []*CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
}

func (s CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) SetAddress(v string) *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations {
	s.Address = &v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) SetPortRanges(v []*CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations {
	s.PortRanges = v
	return s
}

type CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges struct {
	// The first port of the destination port range. The value of this parameter must fall within the port range of the endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// If the first port and the last port are not specified, traffic on all ports of the destination is allowed.
	//
	// You can specify port ranges for up to 500 destinations in each endpoint and specify up to 10 first ports for each destination.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port of the destination port range. The value of this parameter must fall within the port range of the endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// If the first port and the last port are not specified, traffic on all ports of the destination is allowed.
	//
	// You can specify port ranges for up to 500 destinations in each endpoint and specify up to 10 last ports for each destination.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) SetFromPort(v int32) *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges {
	s.FromPort = &v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) SetToPort(v int32) *CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges {
	s.ToPort = &v
	return s
}

type CreateCustomRoutingEndpointTrafficPoliciesResponseBody struct {
	// The IDs of the traffic destinations.
	PolicyIds []*string `json:"PolicyIds,omitempty" xml:"PolicyIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCustomRoutingEndpointTrafficPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointTrafficPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesResponseBody) SetPolicyIds(v []*string) *CreateCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.PolicyIds = v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesResponseBody) SetRequestId(v string) *CreateCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.RequestId = &v
	return s
}

type CreateCustomRoutingEndpointTrafficPoliciesResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCustomRoutingEndpointTrafficPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCustomRoutingEndpointTrafficPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointTrafficPoliciesResponse) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesResponse) SetHeaders(v map[string]*string) *CreateCustomRoutingEndpointTrafficPoliciesResponse {
	s.Headers = v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesResponse) SetStatusCode(v int32) *CreateCustomRoutingEndpointTrafficPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCustomRoutingEndpointTrafficPoliciesResponse) SetBody(v *CreateCustomRoutingEndpointTrafficPoliciesResponseBody) *CreateCustomRoutingEndpointTrafficPoliciesResponse {
	s.Body = v
	return s
}

type CreateCustomRoutingEndpointsRequest struct {
	// The ID of the endpoint group in which to create endpoints.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The information about the endpoints.
	//
	// You can specify information for up to 20 endpoints.
	EndpointConfigurations []*CreateCustomRoutingEndpointsRequestEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The information about the endpoints.
	//
	// You can specify information for up to 20 endpoints.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request is different.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateCustomRoutingEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointsRequest) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointsRequest) SetClientToken(v string) *CreateCustomRoutingEndpointsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCustomRoutingEndpointsRequest) SetEndpointConfigurations(v []*CreateCustomRoutingEndpointsRequestEndpointConfigurations) *CreateCustomRoutingEndpointsRequest {
	s.EndpointConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointsRequest) SetEndpointGroupId(v string) *CreateCustomRoutingEndpointsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateCustomRoutingEndpointsRequest) SetRegionId(v string) *CreateCustomRoutingEndpointsRequest {
	s.RegionId = &v
	return s
}

type CreateCustomRoutingEndpointsRequestEndpointConfigurations struct {
	// The traffic policy that is used to process traffic to the endpoint. Valid values:
	//
	// *   **DenyAll** (default): denies all traffic to the endpoint.
	// *   **AllowAll**: allows all traffic to the endpoint.
	// *   **AllowCustom**: allows traffic only to specified destinations in the endpoint.
	//
	// If you set this parameter to AllowCustom, you must specify IP addresses and port ranges as the destinations to which traffic is distributed. If you specify only IP addresses and do not specify port ranges, GA can forward traffic to the specified IP addresses over all destination ports.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The destination to which traffic is forwarded.
	//
	// You can specify up to 20 destinations for each endpoint.
	PolicyConfigurations []*CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations `json:"PolicyConfigurations,omitempty" xml:"PolicyConfigurations,omitempty" type:"Repeated"`
	// The destination to which traffic is forwarded.
	//
	// You can specify up to 20 destinations for each endpoint.
	TrafficToEndpointPolicy *string `json:"TrafficToEndpointPolicy,omitempty" xml:"TrafficToEndpointPolicy,omitempty"`
	// The ID of the vSwitch that is specified as an endpoint.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateCustomRoutingEndpointsRequestEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointsRequestEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurations) SetEndpoint(v string) *CreateCustomRoutingEndpointsRequestEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurations) SetPolicyConfigurations(v []*CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) *CreateCustomRoutingEndpointsRequestEndpointConfigurations {
	s.PolicyConfigurations = v
	return s
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurations) SetTrafficToEndpointPolicy(v string) *CreateCustomRoutingEndpointsRequestEndpointConfigurations {
	s.TrafficToEndpointPolicy = &v
	return s
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurations) SetType(v string) *CreateCustomRoutingEndpointsRequestEndpointConfigurations {
	s.Type = &v
	return s
}

type CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations struct {
	// The port range of the destination to which traffic is forwarded. The value of this parameter must fall within the port range of the endpoint group.
	//
	// If you leave this parameter empty, traffic is forwarded to all destination ports.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations for each endpoint and specify up to 20 port ranges for each destination.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The port range of the destination to which traffic is forwarded. The value of this parameter must fall within the port range of the endpoint group.
	//
	// If you leave this parameter empty, traffic is forwarded to all destination ports.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations for each endpoint and specify up to 20 port ranges for each destination.
	PortRanges []*CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
}

func (s CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) SetAddress(v string) *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations {
	s.Address = &v
	return s
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) SetPortRanges(v []*CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations {
	s.PortRanges = v
	return s
}

type CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges struct {
	// The last port of the destination port range. The value of this parameter must fall within the port range of the endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations for each endpoint and specify up to 20 last ports for each destination.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The returned information.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) SetFromPort(v int32) *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.FromPort = &v
	return s
}

func (s *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) SetToPort(v int32) *CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.ToPort = &v
	return s
}

type CreateCustomRoutingEndpointsResponseBody struct {
	// The IDs of the endpoints.
	EndpointIds []*string `json:"EndpointIds,omitempty" xml:"EndpointIds,omitempty" type:"Repeated"`
	// The IDs of the endpoints.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCustomRoutingEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointsResponseBody) SetEndpointIds(v []*string) *CreateCustomRoutingEndpointsResponseBody {
	s.EndpointIds = v
	return s
}

func (s *CreateCustomRoutingEndpointsResponseBody) SetRequestId(v string) *CreateCustomRoutingEndpointsResponseBody {
	s.RequestId = &v
	return s
}

type CreateCustomRoutingEndpointsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCustomRoutingEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCustomRoutingEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCustomRoutingEndpointsResponse) GoString() string {
	return s.String()
}

func (s *CreateCustomRoutingEndpointsResponse) SetHeaders(v map[string]*string) *CreateCustomRoutingEndpointsResponse {
	s.Headers = v
	return s
}

func (s *CreateCustomRoutingEndpointsResponse) SetStatusCode(v int32) *CreateCustomRoutingEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCustomRoutingEndpointsResponse) SetBody(v *CreateCustomRoutingEndpointsResponseBody) *CreateCustomRoutingEndpointsResponse {
	s.Body = v
	return s
}

type CreateDomainRequest struct {
	// The ID of the GA instance.
	//
	// You can enter up to 50 IDs.
	AcceleratorIds []*string `json:"AcceleratorIds,omitempty" xml:"AcceleratorIds,omitempty" type:"Repeated"`
	// The accelerated domain name to be added.
	//
	// Wildcard domain names are supported. A wildcard domain name must start with `*.`, such as `*.example.com`.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainRequest) GoString() string {
	return s.String()
}

func (s *CreateDomainRequest) SetAcceleratorIds(v []*string) *CreateDomainRequest {
	s.AcceleratorIds = v
	return s
}

func (s *CreateDomainRequest) SetDomain(v string) *CreateDomainRequest {
	s.Domain = &v
	return s
}

func (s *CreateDomainRequest) SetRegionId(v string) *CreateDomainRequest {
	s.RegionId = &v
	return s
}

type CreateDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDomainResponseBody) SetRequestId(v string) *CreateDomainResponseBody {
	s.RequestId = &v
	return s
}

type CreateDomainResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResponse) GoString() string {
	return s.String()
}

func (s *CreateDomainResponse) SetHeaders(v map[string]*string) *CreateDomainResponse {
	s.Headers = v
	return s
}

func (s *CreateDomainResponse) SetStatusCode(v int32) *CreateDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDomainResponse) SetBody(v *CreateDomainResponseBody) *CreateDomainResponse {
	s.Body = v
	return s
}

type CreateEndpointGroupRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the endpoint group.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configurations of endpoints in the endpoint group.
	EndpointConfigurations []*CreateEndpointGroupRequestEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The ID of the region in which to create the endpoint group.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The type of the endpoint group. Default value: default. Valid values:
	//
	// *   **default**: a default endpoint group.
	// *   **virtual**: a virtual endpoint group.
	//
	// >  Only HTTP and HTTPS listeners support virtual endpoint groups.
	EndpointGroupType *string `json:"EndpointGroupType,omitempty" xml:"EndpointGroupType,omitempty"`
	// The protocol that is used by the backend service. Default value: HTTP. Valid values:
	//
	// *   **HTTP**
	// *   **HTTPS**
	//
	// > *   You can set this parameter only when the listener that is associated with the endpoint group uses **HTTP** or **HTTPS**.
	// >*   For an **HTTP** listener, the backend service protocol must be **HTTP**.
	EndpointRequestProtocol *string `json:"EndpointRequestProtocol,omitempty" xml:"EndpointRequestProtocol,omitempty"`
	// Specifies whether to enable the health check feature. Default value: true. Valid values:
	//
	// *   **true**: enables the health check feature.
	// *   **false**: disables the health check feature.
	HealthCheckEnabled *bool `json:"HealthCheckEnabled,omitempty" xml:"HealthCheckEnabled,omitempty"`
	// The interval at which health checks are performed. Unit: seconds.
	HealthCheckIntervalSeconds *int32 `json:"HealthCheckIntervalSeconds,omitempty" xml:"HealthCheckIntervalSeconds,omitempty"`
	// The path to which to send health check requests.
	HealthCheckPath *string `json:"HealthCheckPath,omitempty" xml:"HealthCheckPath,omitempty"`
	// The port that is used for health checks.
	HealthCheckPort *int32 `json:"HealthCheckPort,omitempty" xml:"HealthCheckPort,omitempty"`
	// The protocol over which to send health check requests. Valid values:
	//
	// *   **tcp**: TCP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	HealthCheckProtocol *string `json:"HealthCheckProtocol,omitempty" xml:"HealthCheckProtocol,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the endpoint group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The mappings between ports.
	PortOverrides []*CreateEndpointGroupRequestPortOverrides `json:"PortOverrides,omitempty" xml:"PortOverrides,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Tags of GA instances.
	Tag []*CreateEndpointGroupRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The number of consecutive health check failures that must occur before a healthy endpoint group is considered unhealthy, or the number of consecutive health check successes that must occur before an unhealthy endpoint group is considered healthy.
	//
	// Valid values: **2** to **10**. Default value: **3**.
	ThresholdCount *int32 `json:"ThresholdCount,omitempty" xml:"ThresholdCount,omitempty"`
	// The traffic ratio for the endpoint group when the specified listener is associated with multiple endpoint groups.
	//
	// Valid values: **1** to **100**.
	TrafficPercentage *int32 `json:"TrafficPercentage,omitempty" xml:"TrafficPercentage,omitempty"`
}

func (s CreateEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupRequest) SetAcceleratorId(v string) *CreateEndpointGroupRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetClientToken(v string) *CreateEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetDescription(v string) *CreateEndpointGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetEndpointConfigurations(v []*CreateEndpointGroupRequestEndpointConfigurations) *CreateEndpointGroupRequest {
	s.EndpointConfigurations = v
	return s
}

func (s *CreateEndpointGroupRequest) SetEndpointGroupRegion(v string) *CreateEndpointGroupRequest {
	s.EndpointGroupRegion = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetEndpointGroupType(v string) *CreateEndpointGroupRequest {
	s.EndpointGroupType = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetEndpointRequestProtocol(v string) *CreateEndpointGroupRequest {
	s.EndpointRequestProtocol = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetHealthCheckEnabled(v bool) *CreateEndpointGroupRequest {
	s.HealthCheckEnabled = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetHealthCheckIntervalSeconds(v int32) *CreateEndpointGroupRequest {
	s.HealthCheckIntervalSeconds = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetHealthCheckPath(v string) *CreateEndpointGroupRequest {
	s.HealthCheckPath = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetHealthCheckPort(v int32) *CreateEndpointGroupRequest {
	s.HealthCheckPort = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetHealthCheckProtocol(v string) *CreateEndpointGroupRequest {
	s.HealthCheckProtocol = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetListenerId(v string) *CreateEndpointGroupRequest {
	s.ListenerId = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetName(v string) *CreateEndpointGroupRequest {
	s.Name = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetPortOverrides(v []*CreateEndpointGroupRequestPortOverrides) *CreateEndpointGroupRequest {
	s.PortOverrides = v
	return s
}

func (s *CreateEndpointGroupRequest) SetRegionId(v string) *CreateEndpointGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetTag(v []*CreateEndpointGroupRequestTag) *CreateEndpointGroupRequest {
	s.Tag = v
	return s
}

func (s *CreateEndpointGroupRequest) SetThresholdCount(v int32) *CreateEndpointGroupRequest {
	s.ThresholdCount = &v
	return s
}

func (s *CreateEndpointGroupRequest) SetTrafficPercentage(v int32) *CreateEndpointGroupRequest {
	s.TrafficPercentage = &v
	return s
}

type CreateEndpointGroupRequestEndpointConfigurations struct {
	// Specifies whether to use the TCP Option Address (TOA) module to preserve client IP addresses. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	EnableClientIPPreservation *bool `json:"EnableClientIPPreservation,omitempty" xml:"EnableClientIPPreservation,omitempty"`
	// Specifies whether to use the proxy protocol to preserve client IP addresses. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	EnableProxyProtocol *bool `json:"EnableProxyProtocol,omitempty" xml:"EnableProxyProtocol,omitempty"`
	// Enter the IP address, domain name, or instance ID based on the value of the Type parameter.
	Endpoint   *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	SubAddress *string `json:"SubAddress,omitempty" xml:"SubAddress,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Domain:** a custom domain name.
	// *   **Ip:** a custom IP address.
	// *   **PublicIp:** a public IP address provided by Alibaba Cloud.
	// *   **ECS:** an Elastic Compute Service (ECS) instance.
	// *   **SLB:** a Server Load Balancer (SLB) instance.
	// *   **ALB:** an Application Load Balancer (ALB) instance.
	// *   **OSS:** an Object Storage Service (OSS) bucket.
	//
	// > *   If you set this parameter to **ECS** or **SLB** and the service-linked role AliyunServiceRoleForGaVpcEndpoint does not exist, the system automatically creates the service-linked role.
	// >*   If you set this parameter to **ALB** and the service-linked role AliyunServiceRoleForGaAlb does not exist, the system automatically creates the service-linked role.
	// >*   If you set this parameter to **OSS** and the service-linked role AliyunServiceRoleForGaOss does not exist, the system automatically creates the service-linked role.
	//
	// For more information, see [Service linked roles](~~178360~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the endpoint.
	//
	// Valid values: **0** to **255**.
	//
	// >  If you set the weight of an endpoint to 0, the GA instance stops distributing traffic to the endpoint.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateEndpointGroupRequestEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupRequestEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupRequestEndpointConfigurations) SetEnableClientIPPreservation(v bool) *CreateEndpointGroupRequestEndpointConfigurations {
	s.EnableClientIPPreservation = &v
	return s
}

func (s *CreateEndpointGroupRequestEndpointConfigurations) SetEnableProxyProtocol(v bool) *CreateEndpointGroupRequestEndpointConfigurations {
	s.EnableProxyProtocol = &v
	return s
}

func (s *CreateEndpointGroupRequestEndpointConfigurations) SetEndpoint(v string) *CreateEndpointGroupRequestEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *CreateEndpointGroupRequestEndpointConfigurations) SetSubAddress(v string) *CreateEndpointGroupRequestEndpointConfigurations {
	s.SubAddress = &v
	return s
}

func (s *CreateEndpointGroupRequestEndpointConfigurations) SetType(v string) *CreateEndpointGroupRequestEndpointConfigurations {
	s.Type = &v
	return s
}

func (s *CreateEndpointGroupRequestEndpointConfigurations) SetWeight(v int32) *CreateEndpointGroupRequestEndpointConfigurations {
	s.Weight = &v
	return s
}

type CreateEndpointGroupRequestPortOverrides struct {
	// The endpoint port that is mapped to the listener port.
	EndpointPort *int32 `json:"EndpointPort,omitempty" xml:"EndpointPort,omitempty"`
	// The listener port that is mapped to the endpoint port.
	//
	// > *   Only HTTP and HTTPS listeners support port mappings.
	// >*   The listener port must be the one used by the current listener.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
}

func (s CreateEndpointGroupRequestPortOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupRequestPortOverrides) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupRequestPortOverrides) SetEndpointPort(v int32) *CreateEndpointGroupRequestPortOverrides {
	s.EndpointPort = &v
	return s
}

func (s *CreateEndpointGroupRequestPortOverrides) SetListenerPort(v int32) *CreateEndpointGroupRequestPortOverrides {
	s.ListenerPort = &v
	return s
}

type CreateEndpointGroupRequestTag struct {
	// The tag key of the GA instance. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the GA instance. The tag value cannot be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEndpointGroupRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupRequestTag) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupRequestTag) SetKey(v string) *CreateEndpointGroupRequestTag {
	s.Key = &v
	return s
}

func (s *CreateEndpointGroupRequestTag) SetValue(v string) *CreateEndpointGroupRequestTag {
	s.Value = &v
	return s
}

type CreateEndpointGroupResponseBody struct {
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupResponseBody) SetEndpointGroupId(v string) *CreateEndpointGroupResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *CreateEndpointGroupResponseBody) SetRequestId(v string) *CreateEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateEndpointGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupResponse) SetHeaders(v map[string]*string) *CreateEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateEndpointGroupResponse) SetStatusCode(v int32) *CreateEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEndpointGroupResponse) SetBody(v *CreateEndpointGroupResponseBody) *CreateEndpointGroupResponse {
	s.Body = v
	return s
}

type CreateEndpointGroupsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Default value: false. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Terminal node group configuration information.
	EndpointGroupConfigurations []*CreateEndpointGroupsRequestEndpointGroupConfigurations `json:"EndpointGroupConfigurations,omitempty" xml:"EndpointGroupConfigurations,omitempty" type:"Repeated"`
	// The ID of the listener.
	//
	// >  If the protocol of the listener is **HTTP** or **HTTPS**, only one endpoint group is created after you call the **CreateEndpointGroups** operation.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateEndpointGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupsRequest) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupsRequest) SetAcceleratorId(v string) *CreateEndpointGroupsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateEndpointGroupsRequest) SetClientToken(v string) *CreateEndpointGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateEndpointGroupsRequest) SetDryRun(v bool) *CreateEndpointGroupsRequest {
	s.DryRun = &v
	return s
}

func (s *CreateEndpointGroupsRequest) SetEndpointGroupConfigurations(v []*CreateEndpointGroupsRequestEndpointGroupConfigurations) *CreateEndpointGroupsRequest {
	s.EndpointGroupConfigurations = v
	return s
}

func (s *CreateEndpointGroupsRequest) SetListenerId(v string) *CreateEndpointGroupsRequest {
	s.ListenerId = &v
	return s
}

func (s *CreateEndpointGroupsRequest) SetRegionId(v string) *CreateEndpointGroupsRequest {
	s.RegionId = &v
	return s
}

type CreateEndpointGroupsRequestEndpointGroupConfigurations struct {
	// Specifies whether to use the proxy protocol to preserve client IP addresses. Default value: false. Valid values:
	//
	// *   **true**: uses the proxy protocol to preserve client IP addresses.
	// *   **false**: does not use the proxy protocol to preserve client IP addresses.
	//
	// You can specify this parameter for up to 10 endpoint groups.
	EnableClientIPPreservationProxyProtocol *bool `json:"EnableClientIPPreservationProxyProtocol,omitempty" xml:"EnableClientIPPreservationProxyProtocol,omitempty"`
	// Specifies whether to preserve client IP addresses by using the TCP Option Address (TOA) module. Default value: false. Valid values:
	//
	// *   **true**: preserves client IP addresses by using the TOA module.
	// *   **false**: does not preserve client IP addresses by using the TOA module.
	//
	// You can specify this parameter for up to 10 endpoint groups.
	EnableClientIPPreservationToa *bool `json:"EnableClientIPPreservationToa,omitempty" xml:"EnableClientIPPreservationToa,omitempty"`
	// Terminal node configuration information.
	EndpointConfigurations []*CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The description of the endpoint group.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	//
	// You can enter the descriptions of up to 10 endpoint groups.
	EndpointGroupDescription *string `json:"EndpointGroupDescription,omitempty" xml:"EndpointGroupDescription,omitempty"`
	// The name of the endpoint group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// You can enter the names of up to 10 endpoint groups.
	EndpointGroupName *string `json:"EndpointGroupName,omitempty" xml:"EndpointGroupName,omitempty"`
	// The ID of the region where you want to create the endpoint group.
	//
	// You can enter the IDs of up to 10 regions.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The type of the endpoint group. Default value: default. Valid values:
	//
	// *   **default**: a default endpoint group.
	// *   **virtual**: a virtual endpoint group.
	//
	// You can specify the types of up to 10 endpoint groups.
	//
	// >  Only HTTP and HTTPS listeners support virtual endpoint groups.
	EndpointGroupType *string `json:"EndpointGroupType,omitempty" xml:"EndpointGroupType,omitempty"`
	// The protocol that is used by the backend service. Default value: HTTP. Valid values:
	//
	// *   **HTTP**: HTTP
	// *   **HTTPS**: HTTPS
	//
	// You can specify up to 10 backend service protocols.
	//
	// >
	// *   You can set this parameter only if the listener that is associated with the endpoint group uses **HTTP** or **HTTPS**.
	// *   For an **HTTP** listener, the backend service protocol must be **HTTP**.
	EndpointRequestProtocol *string `json:"EndpointRequestProtocol,omitempty" xml:"EndpointRequestProtocol,omitempty"`
	// Specifies whether to enable the health check feature. Default value: false. Valid values:
	//
	// *   **true**: enables the health check feature.
	// *   **false**: disables the health check feature.
	//
	// You can enable the health check feature for up to 10 endpoint groups.
	HealthCheckEnabled *bool `json:"HealthCheckEnabled,omitempty" xml:"HealthCheckEnabled,omitempty"`
	// The interval at which health checks are performed. Unit: seconds.
	//
	// You can specify up to 10 health check intervals.
	HealthCheckIntervalSeconds *int64 `json:"HealthCheckIntervalSeconds,omitempty" xml:"HealthCheckIntervalSeconds,omitempty"`
	// The path to which health check requests are sent.
	//
	// You can specify up to 10 health check paths.
	HealthCheckPath *string `json:"HealthCheckPath,omitempty" xml:"HealthCheckPath,omitempty"`
	// The port that is used for health checks. Valid values: **1** to **65535**.
	//
	// You can specify up to 10 ports for health checks.
	HealthCheckPort *int64 `json:"HealthCheckPort,omitempty" xml:"HealthCheckPort,omitempty"`
	// The protocol over which health check requests are sent. Valid values:
	//
	// *   **tcp**: TCP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	//
	// You can specify up to 10 health check protocols.
	HealthCheckProtocol *string `json:"HealthCheckProtocol,omitempty" xml:"HealthCheckProtocol,omitempty"`
	// The mappings between ports.
	PortOverrides []*CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides `json:"PortOverrides,omitempty" xml:"PortOverrides,omitempty" type:"Repeated"`
	// The number of consecutive health check failures that must occur before a healthy endpoint group is considered unhealthy, or the number of consecutive health check successes that must occur before an unhealthy endpoint group is considered healthy.
	//
	// Valid values: **2** to **10**. Default value: **3**.
	//
	// You can specify the number of consecutive health check successes or failures for up to 10 endpoint groups.
	ThresholdCount *int64 `json:"ThresholdCount,omitempty" xml:"ThresholdCount,omitempty"`
	// The value of the traffic distribution ratio. If a listener is associated with multiple endpoint groups, you can set this parameter to distribute different percentages of traffic to the endpoint groups.
	//
	// Valid values: **1** to **100**. Default value: **100**.
	//
	// You can specify the traffic distribution ratios for up to 10 endpoint groups.
	TrafficPercentage *int64 `json:"TrafficPercentage,omitempty" xml:"TrafficPercentage,omitempty"`
}

func (s CreateEndpointGroupsRequestEndpointGroupConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupsRequestEndpointGroupConfigurations) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEnableClientIPPreservationProxyProtocol(v bool) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EnableClientIPPreservationProxyProtocol = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEnableClientIPPreservationToa(v bool) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EnableClientIPPreservationToa = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointConfigurations(v []*CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointConfigurations = v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupDescription(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupDescription = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupName(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupName = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupRegion(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupRegion = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupType(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupType = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointRequestProtocol(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointRequestProtocol = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckEnabled(v bool) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckEnabled = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckIntervalSeconds(v int64) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckIntervalSeconds = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckPath(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckPath = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckPort(v int64) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckPort = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckProtocol(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckProtocol = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetPortOverrides(v []*CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.PortOverrides = v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetThresholdCount(v int64) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.ThresholdCount = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurations) SetTrafficPercentage(v int64) *CreateEndpointGroupsRequestEndpointGroupConfigurations {
	s.TrafficPercentage = &v
	return s
}

type CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations struct {
	// The IP address, domain name or instance id according to the type of the endpoint.
	//
	// You can specify up to 100 endpoint IP addresses or domain names in an endpoint group.
	//
	// >  This parameter is required.
	Endpoint   *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	SubAddress *string `json:"SubAddress,omitempty" xml:"SubAddress,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Domain**: a custom domain name
	// *   **Ip**: a custom IP address
	// *   **PublicIp**: a public IP address provided by Alibaba Cloud
	// *   **ECS**: an Elastic Compute Service (ECS) instance
	// *   **SLB**: a Server Load Balancer (SLB) instance
	// *   **ALB**: an Application Load Balancer (ALB) instance
	// *   **OSS**: an Object Storage Service (OSS) bucket
	//
	// You can specify up to 100 endpoint types for an endpoint group.
	//
	// >
	//
	// *   This parameter is required.
	// *   If you set this parameter to **ECS** or **SLB** and the service-linked role AliyunServiceRoleForGaVpcEndpoint does not exist, the system creates the service-linked role.
	// *   If you set this parameter to **ALB** and the service-linked role AliyunServiceRoleForGaAlb does not exist, the system creates the service-linked role.
	// *   If you set this parameter to **OSS** and the service-linked role AliyunServiceRoleForGaOss does not exist, the system creates the service-linked role.
	//
	// For more information, see [Service-linked roles](~~178360~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the endpoint.
	//
	// Valid values: **0** to **255**.
	//
	// You can set the weights of up to 100 endpoints in an endpoint group.
	//
	// >
	// *   This parameter is required.
	// *   If the weight of an endpoint is set to 0, GA stops distributing network traffic to the endpoint. Proceed with caution.
	Weight *int64 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetEndpoint(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetSubAddress(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.SubAddress = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetType(v string) *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Type = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetWeight(v int64) *CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Weight = &v
	return s
}

type CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides struct {
	// The endpoint port that is mapped to the listener port.
	//
	// You can specify endpoint ports in up to five port mappings.
	EndpointPort *int64 `json:"EndpointPort,omitempty" xml:"EndpointPort,omitempty"`
	// The listener port that is mapped to the endpoint port.
	//
	// You can specify listener ports in up to five port mappings.
	//
	// >
	// *   Only HTTP and HTTPS listeners support port mappings.
	// *   The listener port in a port mapping must be the one used by the current listener.
	ListenerPort *int64 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
}

func (s CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) SetEndpointPort(v int64) *CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides {
	s.EndpointPort = &v
	return s
}

func (s *CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) SetListenerPort(v int64) *CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides {
	s.ListenerPort = &v
	return s
}

type CreateEndpointGroupsResponseBody struct {
	// The IDs of the endpoint groups.
	EndpointGroupIds []*string `json:"EndpointGroupIds,omitempty" xml:"EndpointGroupIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateEndpointGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupsResponseBody) SetEndpointGroupIds(v []*string) *CreateEndpointGroupsResponseBody {
	s.EndpointGroupIds = v
	return s
}

func (s *CreateEndpointGroupsResponseBody) SetRequestId(v string) *CreateEndpointGroupsResponseBody {
	s.RequestId = &v
	return s
}

type CreateEndpointGroupsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEndpointGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEndpointGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEndpointGroupsResponse) GoString() string {
	return s.String()
}

func (s *CreateEndpointGroupsResponse) SetHeaders(v map[string]*string) *CreateEndpointGroupsResponse {
	s.Headers = v
	return s
}

func (s *CreateEndpointGroupsResponse) SetStatusCode(v int32) *CreateEndpointGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEndpointGroupsResponse) SetBody(v *CreateEndpointGroupsResponseBody) *CreateEndpointGroupsResponse {
	s.Body = v
	return s
}

type CreateForwardingRulesRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Details about the forwarding rules.
	ForwardingRules []*CreateForwardingRulesRequestForwardingRules `json:"ForwardingRules,omitempty" xml:"ForwardingRules,omitempty" type:"Repeated"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateForwardingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequest) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequest) SetAcceleratorId(v string) *CreateForwardingRulesRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateForwardingRulesRequest) SetClientToken(v string) *CreateForwardingRulesRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateForwardingRulesRequest) SetForwardingRules(v []*CreateForwardingRulesRequestForwardingRules) *CreateForwardingRulesRequest {
	s.ForwardingRules = v
	return s
}

func (s *CreateForwardingRulesRequest) SetListenerId(v string) *CreateForwardingRulesRequest {
	s.ListenerId = &v
	return s
}

func (s *CreateForwardingRulesRequest) SetRegionId(v string) *CreateForwardingRulesRequest {
	s.RegionId = &v
	return s
}

type CreateForwardingRulesRequestForwardingRules struct {
	// The name of the forwarding rule.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	ForwardingRuleName *string `json:"ForwardingRuleName,omitempty" xml:"ForwardingRuleName,omitempty"`
	// The priority of the forwarding rule. Valid values: **1** to **10000**. A lower value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The forwarding action.
	RuleActions []*CreateForwardingRulesRequestForwardingRulesRuleActions `json:"RuleActions,omitempty" xml:"RuleActions,omitempty" type:"Repeated"`
	// The forwarding conditions.
	RuleConditions []*CreateForwardingRulesRequestForwardingRulesRuleConditions `json:"RuleConditions,omitempty" xml:"RuleConditions,omitempty" type:"Repeated"`
	// The direction in which the rule takes effect. You do not need to set this parameter.
	//
	// By default, this parameter is set to **request**, which indicates that the rule takes effect on requests.
	RuleDirection *string `json:"RuleDirection,omitempty" xml:"RuleDirection,omitempty"`
}

func (s CreateForwardingRulesRequestForwardingRules) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequestForwardingRules) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequestForwardingRules) SetForwardingRuleName(v string) *CreateForwardingRulesRequestForwardingRules {
	s.ForwardingRuleName = &v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRules) SetPriority(v int32) *CreateForwardingRulesRequestForwardingRules {
	s.Priority = &v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRules) SetRuleActions(v []*CreateForwardingRulesRequestForwardingRulesRuleActions) *CreateForwardingRulesRequestForwardingRules {
	s.RuleActions = v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRules) SetRuleConditions(v []*CreateForwardingRulesRequestForwardingRulesRuleConditions) *CreateForwardingRulesRequestForwardingRules {
	s.RuleConditions = v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRules) SetRuleDirection(v string) *CreateForwardingRulesRequestForwardingRules {
	s.RuleDirection = &v
	return s
}

type CreateForwardingRulesRequestForwardingRulesRuleActions struct {
	// The forwarding configurations.
	//
	// >  We recommend that you do not use this parameter. We recommend that you use the **RuleActionType** and **RuleActionValue** parameters to configure forwarding actions.
	ForwardGroupConfig *CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig `json:"ForwardGroupConfig,omitempty" xml:"ForwardGroupConfig,omitempty" type:"Struct"`
	// The forwarding priority.
	//
	// >  This parameter does not take effect. Ignore this parameter.
	Order *int32 `json:"Order,omitempty" xml:"Order,omitempty"`
	// The type of the forwarding action. Valid values:
	//
	// *   **ForwardGroup**: forwards a request.
	// *   **Redirect**: redirects a request.
	// *   **FixResponse**: returns a fixed response.
	// *   **Rewrite**: rewrites a request.
	// *   **AddHeader**: adds a header to a request.
	// *   **RemoveHeaderConfig**: deletes the header from a request.
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	// The value of the forwarding action type.
	//
	// You must specify different JSON strings based on the **RuleActionType** parameter.
	//
	// A forwarding rule can contain only one forwarding action whose type is **ForwardGroup**, **Redirect**, or **FixResponse**. You must specify a forwarding action whose type is **Rewrite**, **AddHeader**, or **RemoveHeader** before a forwarding action whose type is **ForwardGroup**.
	//
	// *   If **RuleActionType** is set to **ForwardGroup**, this parameter specifies the information of a virtual endpoint group. You can forward requests to only one virtual endpoint group. Example: `{"type":"endpointgroup", "value":"epg-bp1enpdcrqhl78g6r****"}`.
	//
	//     *   `type`: set this parameter to `endpointgroup`.
	//     *   `value`: set this parameter to the ID of a virtual endpoint group.
	//
	// *   If **RuleActionType** is set to **Redirect**, this parameter specifies redirecting configurations. You cannot leave all of the following parameters empty or configure all of these parameters to use the default values for a forwarding action whose type is **Redirect**: `protocol`, `domain`, `port`, `path`, and `query`. Example: `{"protocol":"HTTP", "domain":"www.example.com", "port":"80", "path":"/a","query":"value1", "code":"301" }`.
	//
	//     *   `protocol`: the protocol of requests after the requests are redirected. Valid values: `${protocol}` (default), `HTTP`, and `HTTPS`.
	//     *   `domain`: the domain name to which requests are redirected. Default value: `${host}`. You can also enter a domain name. The domain name must be 3 to 128 characters in length, and can contain only letters, digits, and the following special characters: `. - ? = ~ _ - + / ^ * ! $ & | ( ) [ ]`.
	//     *   `port`: the port to which requests are redirected. Default value: `${port}`. You can enter a port number that ranges from 1 to 63335.
	//     *   `path`: the path to which requests are redirected. Default value: `${path}`. The path must be 1 to 128 characters in length. To use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? ~ ^ * $ : ( ) [ ] + |`. The path must start with a tilde (~). If you do not want to use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? :`. The path must start with a forward slash (/).
	//     *   `query`: the query string of the requests to be redirected. Default value: `${query}`. You can also specify a query string. The query string must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The query string cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > # | &`.
	//     *   `code`: the redirecting code. Valid values: `301`, `302`, `303`, `307`, and `308`.
	//
	// *   If **RuleActionType** is set to **FixResponse**, this parameter specifies a fixed response. Example: `{"code":"200", "type":"text/plain", "content":"dssacav" }`.
	//
	//     *   `code`: the HTTP status code to return. The response status code must be one of the following numeric strings: `2xx`, `4xx`, and `5xx`. The letter `x` indicates a number from 0 to 9.
	//     *   `type`: the type of the response content. Valid values: **text/plain**, **text/css**, **text/html**, **application/javascript**, and **application/json**.
	//     *   `content`: the response content. The response content cannot exceed 1,000 characters in length and does not support Chinese characters.
	//
	// *   If **RuleActionType** is set to **AddHeader**, this parameter specifies an HTTP header to be added. If a forwarding rule contains a forwarding action whose type is **AddHeader**, you must specify another forwarding action whose type is **ForwardGroup**. Example: `[{"name":"header1","type":"userdefined", "value":"value"}]`.
	//
	//     *   `name`: the name of the HTTP header. The name must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). The name of the HTTP header specified by **AddHeader** must be unique and cannot be the same as the name of the HTTP header specified by **RemoveHeader**.
	//     *   `type`: the content type of the HTTP header. Valid values: `user-defined`, `ref`, and `system-defined`.
	//     *   `value`: the content of the HTTP header. You cannot leave this parameter empty. If you set `type` to `user-defined`, the content must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The content can contain letters, digits, hyphens (-), and underscores (\_). The content cannot start or end with a space character. If you set `type` to `ref`, the content must be 1 to 128 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). The content cannot start or end with a space character. If you set `type` to `system-defined`, only `ClientSrcIp` is supported.
	//
	// *   If **RuleActionType** is set to **RemoveHeader**, this parameter specifies an HTTP header to be removed. If a forwarding rule contains a forwarding action whose type is **RemoveHeader**, you must specify another forwarding action whose type is **ForwardGroup**. The header must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). Example: `["header1"]`.
	//
	// *   If **RuleActionType** is set to **Rewrite**, this parameter specifies the rewriting configuration. If a forwarding rule contains a forwarding action whose type is **Rewrite**, you must specify another forwarding action whose type is **ForwardGroup**. Example: `{"domain":"value1", "path":"value2", "query":"value3"}`.
	//
	//     *   `domain`: the domain name to which requests are redirected. Default value: `${host}`. You can also enter a domain name. The domain name must be 3 to 128 characters in length, and can contain only lowercase letters, digits, and the following special characters: `. - ? = ~ _ - + / ^ * ! $ & | ( ) [ ]`.
	//     *   `path`: the path to which requests are redirected. Default value: `${path}`. The path must be 1 to 128 characters in length. To use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? ~ ^ * $ : ( ) [ ] + |`. The path must start with a tilde (~). If you do not want to use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? :`. The path must start with a forward slash (/).
	//     *   `query`: the query string of the requests to be redirected. Default value: `${query}`. You can also specify a query string. The query string must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The query string cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > # | &`.
	RuleActionValue *string `json:"RuleActionValue,omitempty" xml:"RuleActionValue,omitempty"`
}

func (s CreateForwardingRulesRequestForwardingRulesRuleActions) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequestForwardingRulesRuleActions) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleActions) SetForwardGroupConfig(v *CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) *CreateForwardingRulesRequestForwardingRulesRuleActions {
	s.ForwardGroupConfig = v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleActions) SetOrder(v int32) *CreateForwardingRulesRequestForwardingRulesRuleActions {
	s.Order = &v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleActions) SetRuleActionType(v string) *CreateForwardingRulesRequestForwardingRulesRuleActions {
	s.RuleActionType = &v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleActions) SetRuleActionValue(v string) *CreateForwardingRulesRequestForwardingRulesRuleActions {
	s.RuleActionValue = &v
	return s
}

type CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig struct {
	// The information about the endpoint group.
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you call **RuleActionType** and **RuleActionValue** to query forwarding actions.
	ServerGroupTuples []*CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples `json:"ServerGroupTuples,omitempty" xml:"ServerGroupTuples,omitempty" type:"Repeated"`
}

func (s CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) SetServerGroupTuples(v []*CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) *CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig {
	s.ServerGroupTuples = v
	return s
}

type CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples struct {
	// The ID of the endpoint group.
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you call **RuleActionType** and **RuleActionValue** to query forwarding actions.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
}

func (s CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) SetEndpointGroupId(v string) *CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples {
	s.EndpointGroupId = &v
	return s
}

type CreateForwardingRulesRequestForwardingRulesRuleConditions struct {
	// The configuration of the domain name.
	//
	// >  We recommend that you do not use this parameter. We recommend that you use the **RuleConditionType** and **RuleConditionValue** parameters to configure forwarding conditions.
	HostConfig *CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig `json:"HostConfig,omitempty" xml:"HostConfig,omitempty" type:"Struct"`
	// The configuration of the path.
	//
	// >  We recommend that you do not use this parameter. We recommend that you use the **RuleConditionType** and **RuleConditionValue** parameters to configure forwarding conditions.
	PathConfig *CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig `json:"PathConfig,omitempty" xml:"PathConfig,omitempty" type:"Struct"`
	// The type of the forwarding conditions. Valid values:
	//
	// *   **Host**: domain name
	// *   **Path**: path
	// *   **RequestHeader**: HTTP header
	// *   **Query**: query string
	// *   **Method**: HTTP method
	// *   **Cookie**: cookie
	// *   **SourceIP**: source IP address
	RuleConditionType *string `json:"RuleConditionType,omitempty" xml:"RuleConditionType,omitempty"`
	// The value of the forwarding condition type.
	//
	// You must specify different JSON strings based on the **RuleConditionType** parameter.
	//
	// *   If **RuleConditionType** is set to **Host**, this parameter specifies a domain name condition. A forwarding rule can contain only one forwarding condition whose type is host. You can specify multiple domain names in a forwarding condition. The relationship between multiple domain names is OR. The domain name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), and periods (.). Supported wildcard characters are asterisks (\*) and question marks (?). Example: `["www.example.com", "www.aliyun.com"]`.
	//
	// *   If **RuleConditionType** is set to **Path**, this parameter specifies a path condition. A forwarding rule can contain multiple forwarding conditions whose types are path. The relationship between multiple path conditions is OR. You can specify multiple paths in a forwarding condition. The relationship between multiple paths is OR. The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - \_ . + / & ~ @ : \". Supported wildcard characters are asterisks (\*) and question marks (?). Example: `["/a", "/b/"]`.
	//
	// *   If **RuleConditionType** is set to **RequestHeader**, this parameter specifies an HTTP header condition that consists of key-value pairs. The header values in a forwarding condition must be unique. Example: `[{"header1":["value1","value2"]}]`.
	//
	//     *   Key: The key of an HTTP header must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_).
	//     *   Value: The value of an HTTP header must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The value cannot start or end with a space character.
	//
	// *   If **RuleConditionType** is set to **Query**, this parameter specifies a query string condition that consists of key-value pairs. Example: `[{"query1":["value1"]}, {"query2":["value2"]}]`.
	//
	//     *   Key: The key of an HTTP header must be 1 to 100 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The key cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > \ ; / ? : @ & = + , $ % | " ^ ~`.
	//     *   Value: The value of an HTTP header must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The value cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > \ ; / ? : @ & = + , $ % | " ^ ~`.
	//
	// *   If **RuleConditionType** is set to **Method**, this parameter specifies an HTTP method condition. Valid values: **HEAD**, **GET**, **POST**, **OPTIONS**, **PUT**, **PATCH**, and **DELETE**. Example: `["GET", "OPTIONS", "POST"]`.
	//
	// *   If **RuleConditionType** is set to **Cookie**, this parameter specifies a cookie condition that consists of key-value pairs. Example: `[{"cookie1":["value1"]}, {"cookie2":["value2"]}]`.
	//
	//     *   Key: The key of a cookie must be 1 to 100 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The key cannot contain uppercase letters, space characters, or the following special characters: `# [ ] { } \ | < > &`.
	//     *   Value: The value of a cookie must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. The value cannot contain uppercase letters, space characters, or the following special characters: `# [ ] { } \ | < > &`.
	//
	// *   If **RuleConditionType** is set to **SourceIP**, this parameter specifies a source IP address condition. You can specify IP addresses, such as 1.1.XX.XX/32. You can also specify CIDR blocks, such as 2.2.XX.XX/24. A forwarding rule can contain only one forwarding condition whose type is source IP address. You can specify multiple source IP addresses in a forwarding condition. The relationship between multiple source IP addresses is OR. Example: `["1.1.XX.XX/32", "2.2.XX.XX/24"]`.
	RuleConditionValue *string `json:"RuleConditionValue,omitempty" xml:"RuleConditionValue,omitempty"`
}

func (s CreateForwardingRulesRequestForwardingRulesRuleConditions) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequestForwardingRulesRuleConditions) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleConditions) SetHostConfig(v *CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) *CreateForwardingRulesRequestForwardingRulesRuleConditions {
	s.HostConfig = v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleConditions) SetPathConfig(v *CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) *CreateForwardingRulesRequestForwardingRulesRuleConditions {
	s.PathConfig = v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleConditions) SetRuleConditionType(v string) *CreateForwardingRulesRequestForwardingRulesRuleConditions {
	s.RuleConditionType = &v
	return s
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleConditions) SetRuleConditionValue(v string) *CreateForwardingRulesRequestForwardingRulesRuleConditions {
	s.RuleConditionValue = &v
	return s
}

type CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig struct {
	// The domain name.
	//
	// The domain name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), and periods (.). Supported wildcard characters are asterisks (\*) and question marks (?).
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you use **RuleConditionType** and **RuleConditionValue** to query forwarding conditions.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) SetValues(v []*string) *CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig {
	s.Values = v
	return s
}

type CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig struct {
	// The path.
	//
	// The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain only letters, digits, and the following special characters: $ - \_ . + / & ~ @ : \". Supported wildcard characters are asterisks (\*) and question marks (?).
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you use **RuleConditionType** and **RuleConditionValue** to query forwarding conditions.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) SetValues(v []*string) *CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig {
	s.Values = v
	return s
}

type CreateForwardingRulesResponseBody struct {
	// Details about the forwarding rules.
	ForwardingRules []*CreateForwardingRulesResponseBodyForwardingRules `json:"ForwardingRules,omitempty" xml:"ForwardingRules,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateForwardingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesResponseBody) SetForwardingRules(v []*CreateForwardingRulesResponseBodyForwardingRules) *CreateForwardingRulesResponseBody {
	s.ForwardingRules = v
	return s
}

func (s *CreateForwardingRulesResponseBody) SetRequestId(v string) *CreateForwardingRulesResponseBody {
	s.RequestId = &v
	return s
}

type CreateForwardingRulesResponseBodyForwardingRules struct {
	// The ID of the forwarding rule.
	ForwardingRuleId *string `json:"ForwardingRuleId,omitempty" xml:"ForwardingRuleId,omitempty"`
}

func (s CreateForwardingRulesResponseBodyForwardingRules) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesResponseBodyForwardingRules) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesResponseBodyForwardingRules) SetForwardingRuleId(v string) *CreateForwardingRulesResponseBodyForwardingRules {
	s.ForwardingRuleId = &v
	return s
}

type CreateForwardingRulesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateForwardingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateForwardingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateForwardingRulesResponse) GoString() string {
	return s.String()
}

func (s *CreateForwardingRulesResponse) SetHeaders(v map[string]*string) *CreateForwardingRulesResponse {
	s.Headers = v
	return s
}

func (s *CreateForwardingRulesResponse) SetStatusCode(v int32) *CreateForwardingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateForwardingRulesResponse) SetBody(v *CreateForwardingRulesResponseBody) *CreateForwardingRulesResponse {
	s.Body = v
	return s
}

type CreateIpSetsRequest struct {
	// The information about the acceleration regions.
	AccelerateRegion []*CreateIpSetsRequestAccelerateRegion `json:"AccelerateRegion,omitempty" xml:"AccelerateRegion,omitempty" type:"Repeated"`
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateIpSetsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIpSetsRequest) GoString() string {
	return s.String()
}

func (s *CreateIpSetsRequest) SetAccelerateRegion(v []*CreateIpSetsRequestAccelerateRegion) *CreateIpSetsRequest {
	s.AccelerateRegion = v
	return s
}

func (s *CreateIpSetsRequest) SetAcceleratorId(v string) *CreateIpSetsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateIpSetsRequest) SetClientToken(v string) *CreateIpSetsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateIpSetsRequest) SetRegionId(v string) *CreateIpSetsRequest {
	s.RegionId = &v
	return s
}

type CreateIpSetsRequestAccelerateRegion struct {
	// The acceleration region IDs.
	//
	// The number of regions that can be added varies based on the specification of the GA instance. For more information, see [Overview](~~153127~~).
	AccelerateRegionId *string `json:"AccelerateRegionId,omitempty" xml:"AccelerateRegionId,omitempty"`
	// The bandwidth to be allocated to the acceleration region. Unit: **Mbit/s**.
	//
	// >
	//
	// *   Each acceleration region must be allocated a minimum of 2 Mbit/s of bandwidth.
	//
	// *   The total bandwidth for all acceleration regions cannot exceed the maximum bandwidth of the basic bandwidth plan.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The IP version used to connect to the GA instance. Valid values:
	//
	// *   **IPv4** (default)
	// *   **IPv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The line type of the elastic IP address (EIP) in the acceleration region. Valid values:
	//
	// *   **BGP**
	// *   **BGP_PRO** If the acceleration region is China (Hong Kong) and a basic bandwidth plan whose bandwidth type is Premium is associated with the GA instance, the default value of IspType is BGP_PRO.
	//
	// If you are allowed to use single-ISP bandwidth, you can also specify one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom (single ISP)
	// *   **ChinaUnicom**: China Unicom (single ISP)
	// *   **ChinaMobile**: China Mobile (single ISP)
	// *   **ChinaTelecom_L2**: China Telecom \_L2 (single ISP)
	// *   **ChinaUnicom_L2**: China Unicom \_L2 (single ISP)
	// *   **ChinaMobile_L2**: China Mobile \_L2 (single ISP)
	//
	// > Different acceleration regions support different single-ISP BGP lines.
	IspType *string `json:"IspType,omitempty" xml:"IspType,omitempty"`
}

func (s CreateIpSetsRequestAccelerateRegion) String() string {
	return tea.Prettify(s)
}

func (s CreateIpSetsRequestAccelerateRegion) GoString() string {
	return s.String()
}

func (s *CreateIpSetsRequestAccelerateRegion) SetAccelerateRegionId(v string) *CreateIpSetsRequestAccelerateRegion {
	s.AccelerateRegionId = &v
	return s
}

func (s *CreateIpSetsRequestAccelerateRegion) SetBandwidth(v int32) *CreateIpSetsRequestAccelerateRegion {
	s.Bandwidth = &v
	return s
}

func (s *CreateIpSetsRequestAccelerateRegion) SetIpVersion(v string) *CreateIpSetsRequestAccelerateRegion {
	s.IpVersion = &v
	return s
}

func (s *CreateIpSetsRequestAccelerateRegion) SetIspType(v string) *CreateIpSetsRequestAccelerateRegion {
	s.IspType = &v
	return s
}

type CreateIpSetsResponseBody struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The details about the acceleration regions.
	IpSets []*CreateIpSetsResponseBodyIpSets `json:"IpSets,omitempty" xml:"IpSets,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateIpSetsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIpSetsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIpSetsResponseBody) SetAcceleratorId(v string) *CreateIpSetsResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *CreateIpSetsResponseBody) SetIpSets(v []*CreateIpSetsResponseBodyIpSets) *CreateIpSetsResponseBody {
	s.IpSets = v
	return s
}

func (s *CreateIpSetsResponseBody) SetRequestId(v string) *CreateIpSetsResponseBody {
	s.RequestId = &v
	return s
}

type CreateIpSetsResponseBodyIpSets struct {
	// The acceleration region ID.
	AccelerateRegionId *string `json:"AccelerateRegionId,omitempty" xml:"AccelerateRegionId,omitempty"`
	// The bandwidth allocated to the acceleration region. Unit: **Mbit/s**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The acceleration region ID.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The line type of the EIP in the acceleration region.
	IspType *string `json:"IspType,omitempty" xml:"IspType,omitempty"`
}

func (s CreateIpSetsResponseBodyIpSets) String() string {
	return tea.Prettify(s)
}

func (s CreateIpSetsResponseBodyIpSets) GoString() string {
	return s.String()
}

func (s *CreateIpSetsResponseBodyIpSets) SetAccelerateRegionId(v string) *CreateIpSetsResponseBodyIpSets {
	s.AccelerateRegionId = &v
	return s
}

func (s *CreateIpSetsResponseBodyIpSets) SetBandwidth(v int32) *CreateIpSetsResponseBodyIpSets {
	s.Bandwidth = &v
	return s
}

func (s *CreateIpSetsResponseBodyIpSets) SetIpSetId(v string) *CreateIpSetsResponseBodyIpSets {
	s.IpSetId = &v
	return s
}

func (s *CreateIpSetsResponseBodyIpSets) SetIspType(v string) *CreateIpSetsResponseBodyIpSets {
	s.IspType = &v
	return s
}

type CreateIpSetsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIpSetsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIpSetsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIpSetsResponse) GoString() string {
	return s.String()
}

func (s *CreateIpSetsResponse) SetHeaders(v map[string]*string) *CreateIpSetsResponse {
	s.Headers = v
	return s
}

func (s *CreateIpSetsResponse) SetStatusCode(v int32) *CreateIpSetsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIpSetsResponse) SetBody(v *CreateIpSetsResponseBody) *CreateIpSetsResponse {
	s.Body = v
	return s
}

type CreateListenerRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The SSL certificates.
	Certificates []*CreateListenerRequestCertificates `json:"Certificates,omitempty" xml:"Certificates,omitempty" type:"Repeated"`
	// Specifies whether to enable client affinity for the listener.
	//
	// *   If this parameter is left empty, client affinity is disabled. After client affinity is disabled, requests from a specific client IP address may be forwarded to different endpoints.
	// *   To enable client affinity, set this parameter to **SOURCE_IP**. In this case, when a client accesses stateful applications, requests from the same client are forwarded to the same endpoint regardless of the source port or protocol.
	ClientAffinity *string `json:"ClientAffinity,omitempty" xml:"ClientAffinity,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** is different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The endpoint group that is associated with the custom routing listener.
	//
	// You can configure at most five endpoint groups for a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	CustomRoutingEndpointGroupConfigurations []*CreateListenerRequestCustomRoutingEndpointGroupConfigurations `json:"CustomRoutingEndpointGroupConfigurations,omitempty" xml:"CustomRoutingEndpointGroupConfigurations,omitempty" type:"Repeated"`
	// The description of the listener. The description can be at most 200 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The endpoint group that is associated with the intelligent routing listener.
	//
	// You can configure at most 10 endpoint groups for an intelligent routing listener.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	EndpointGroupConfigurations []*CreateListenerRequestEndpointGroupConfigurations `json:"EndpointGroupConfigurations,omitempty" xml:"EndpointGroupConfigurations,omitempty" type:"Repeated"`
	// The name of the listener.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The listener ports. Valid values: **1** to **65499**. The maximum number of ports that can be configured depends on the routing type and protocol of the listener. For more information, see [Listener overview](~~153216~~).
	PortRanges []*CreateListenerRequestPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
	// The network transmission protocol that you want to use for the listener. Valid values:
	//
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// Specifies whether to preserve client IP addresses. Valid values:
	//
	// *   **true**: enables the feature. After client IP addresses are preserved, you can view client IP addresses on the endpoints.
	// *   **false** (default): disables the feature.
	//
	// > This parameter will be deprecated in the API operations that are used to configure listeners. We recommend that you set this parameter when you call API operations to configure endpoint groups. For more information about the **ProxyProtocol** parameter, see [CreateEndpointGroup](~~153259~~) and [UpdateEndpointGroup](~~153262~~).
	ProxyProtocol *bool `json:"ProxyProtocol,omitempty" xml:"ProxyProtocol,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the security policy. Valid values:
	//
	// *   **tls_cipher_policy\_1\_0**
	//
	//     *   Supported Transport Layer Security (TLS) versions: TLS 1.0, TLS 1.1, and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA.
	//
	// *   **tls_cipher_policy\_1\_1**
	//
	//     *   Supported TLS versions: TLS 1.1 and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA.
	//
	// *   **tls_cipher_policy\_1\_2**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA.
	//
	// *   **tls_cipher_policy\_1\_2\_strict**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict_with\_1\_3**
	//
	//     *   Supported TLS versions: TLS 1.2 and TLS 1.3
	//     *   Supported cipher suites: TLS_AES\_128\_GCM_SHA256, TLS_AES\_256\_GCM_SHA384, TLS_CHACHA20\_POLY1305\_SHA256, TLS_AES\_128\_CCM_SHA256, TLS_AES\_128\_CCM\_8\_SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES128-SHA256, ECDHE-ECDSA-AES256-SHA384, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-ECDSA-AES128-SHA, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// > This parameter is available only when you create an HTTPS listener.
	SecurityPolicyId *string `json:"SecurityPolicyId,omitempty" xml:"SecurityPolicyId,omitempty"`
	// The routing type of the listener. Valid values:
	//
	// *   **Standard** (default): intelligent routing
	// *   **CustomRouting**: custom routing
	//
	// >
	//
	// *   Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager.
	//
	// *   You can create only listeners of the same routing type for a standard GA instance. You cannot change the routing types of listeners. For more information, see [Listener overview](~~153216~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The `XForward` headers.
	XForwardedForConfig *CreateListenerRequestXForwardedForConfig `json:"XForwardedForConfig,omitempty" xml:"XForwardedForConfig,omitempty" type:"Struct"`
}

func (s CreateListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequest) GoString() string {
	return s.String()
}

func (s *CreateListenerRequest) SetAcceleratorId(v string) *CreateListenerRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateListenerRequest) SetCertificates(v []*CreateListenerRequestCertificates) *CreateListenerRequest {
	s.Certificates = v
	return s
}

func (s *CreateListenerRequest) SetClientAffinity(v string) *CreateListenerRequest {
	s.ClientAffinity = &v
	return s
}

func (s *CreateListenerRequest) SetClientToken(v string) *CreateListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateListenerRequest) SetCustomRoutingEndpointGroupConfigurations(v []*CreateListenerRequestCustomRoutingEndpointGroupConfigurations) *CreateListenerRequest {
	s.CustomRoutingEndpointGroupConfigurations = v
	return s
}

func (s *CreateListenerRequest) SetDescription(v string) *CreateListenerRequest {
	s.Description = &v
	return s
}

func (s *CreateListenerRequest) SetEndpointGroupConfigurations(v []*CreateListenerRequestEndpointGroupConfigurations) *CreateListenerRequest {
	s.EndpointGroupConfigurations = v
	return s
}

func (s *CreateListenerRequest) SetName(v string) *CreateListenerRequest {
	s.Name = &v
	return s
}

func (s *CreateListenerRequest) SetPortRanges(v []*CreateListenerRequestPortRanges) *CreateListenerRequest {
	s.PortRanges = v
	return s
}

func (s *CreateListenerRequest) SetProtocol(v string) *CreateListenerRequest {
	s.Protocol = &v
	return s
}

func (s *CreateListenerRequest) SetProxyProtocol(v bool) *CreateListenerRequest {
	s.ProxyProtocol = &v
	return s
}

func (s *CreateListenerRequest) SetRegionId(v string) *CreateListenerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateListenerRequest) SetSecurityPolicyId(v string) *CreateListenerRequest {
	s.SecurityPolicyId = &v
	return s
}

func (s *CreateListenerRequest) SetType(v string) *CreateListenerRequest {
	s.Type = &v
	return s
}

func (s *CreateListenerRequest) SetXForwardedForConfig(v *CreateListenerRequestXForwardedForConfig) *CreateListenerRequest {
	s.XForwardedForConfig = v
	return s
}

type CreateListenerRequestCertificates struct {
	// The ID of the SSL certificate.
	//
	// > This parameter is required only when you create an HTTPS listener.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s CreateListenerRequestCertificates) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestCertificates) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestCertificates) SetId(v string) *CreateListenerRequestCertificates {
	s.Id = &v
	return s
}

type CreateListenerRequestCustomRoutingEndpointGroupConfigurations struct {
	// The description of the endpoint group that is associated with the custom routing listener.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	//
	// You can specify at most five endpoint group descriptions.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mapping configurations of the endpoint group that is associated with the custom routing listener.
	//
	// You need to specify the port ranges and protocols used by the endpoint group. The ports are mapped to listener ports.
	//
	// You can specify at most 20 mapping configurations for an endpoint group of a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	DestinationConfigurations []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations `json:"DestinationConfigurations,omitempty" xml:"DestinationConfigurations,omitempty" type:"Repeated"`
	// The endpoint that is associated with the custom routing listener.
	//
	// You can configure at most 10 endpoints for an endpoint group of a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	EndpointConfigurations []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The region ID of the endpoint group that is associated with the custom routing listener.
	//
	// You can enter the region IDs of up to five endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The name of the endpoint group that is associated with the custom routing listener.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// You can specify at most five endpoint group names.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurations) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurations) SetDescription(v string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurations {
	s.Description = &v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurations) SetDestinationConfigurations(v []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations) *CreateListenerRequestCustomRoutingEndpointGroupConfigurations {
	s.DestinationConfigurations = v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurations) SetEndpointConfigurations(v []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations) *CreateListenerRequestCustomRoutingEndpointGroupConfigurations {
	s.EndpointConfigurations = v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurations) SetEndpointGroupRegion(v string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurations {
	s.EndpointGroupRegion = &v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurations) SetName(v string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurations {
	s.Name = &v
	return s
}

type CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations struct {
	// The first port used by the endpoint group that is associated with the custom routing listener.
	//
	// Valid values: **1** to **65499**. The value of **FromPort** must be equal to or smaller than the value of **ToPort**.
	//
	// You can specify up to 20 first ports for an endpoint group of a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The protocol used by the endpoint group that is associated with the custom routing listener.
	//
	// You can specify up to four protocols in each mapping configuration for an endpoint group of a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The last port used by the endpoint group that is associated with the custom routing listener.
	//
	// Valid values: **1** to **65499**. The value of **FromPort** must be equal to or smaller than the value of **ToPort**.
	//
	// You can specify up to 20 last ports for an endpoint group of a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations) SetFromPort(v int32) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations {
	s.FromPort = &v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations) SetProtocols(v []*string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations {
	s.Protocols = v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations) SetToPort(v int32) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations {
	s.ToPort = &v
	return s
}

type CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations struct {
	// The name of the vSwitch that is specified as an endpoint.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The destination in the endpoint that is associated with the custom routing listener.
	//
	// You can specify at most 20 destinations in each endpoint of a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	PolicyConfigurations []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations `json:"PolicyConfigurations,omitempty" xml:"PolicyConfigurations,omitempty" type:"Repeated"`
	// The traffic policy for the endpoint that is associated with the custom routing listener. Valid values:
	//
	// *   **DenyAll** (default): denies all traffic to the endpoint.
	// *   **AllowAll**: allows all traffic to the endpoint.
	// *   **AllowCustom**: allows traffic only to specified destinations in the endpoint.
	//
	// If you set this parameter to AllowCustom, you must specify IP addresses and port ranges as the destinations to which traffic is distributed. If you specify only IP addresses and do not specify port ranges, GA can forward traffic to the specified IP addresses over all destination ports.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	TrafficToEndpointPolicy *string `json:"TrafficToEndpointPolicy,omitempty" xml:"TrafficToEndpointPolicy,omitempty"`
	// The service type of the endpoint that is associated with the custom routing listener.
	//
	// Set the value to **PrivateSubNet**, which specifies a private CIDR block.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations) SetEndpoint(v string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations) SetPolicyConfigurations(v []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations {
	s.PolicyConfigurations = v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations) SetTrafficToEndpointPolicy(v string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations {
	s.TrafficToEndpointPolicy = &v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations) SetType(v string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations {
	s.Type = &v
	return s
}

type CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations struct {
	// The IP address of the destination to which traffic is forwarded.
	//
	// This parameter takes effect only if **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify up to 20 destination IP addresses for each endpoint of a custom routing listener.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The port range of the destination to which traffic is forwarded. The value of this parameter must fall within the port range of the endpoint group.
	//
	// If you leave this parameter empty, traffic is distributed to all destination ports.
	//
	// This parameter takes effect only if **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations in each endpoint of a custom routing listener. You can specify up to five port ranges for each destination.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	PortRanges []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) SetAddress(v string) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations {
	s.Address = &v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations) SetPortRanges(v []*CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations {
	s.PortRanges = v
	return s
}

type CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges struct {
	// The first port of the destination port range. The value of this parameter must be in the port range of the endpoint group.
	//
	// This parameter takes effect only if **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations in each endpoint of a custom routing listener. You can specify up to five first ports for each destination.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port of the destination port range. The value of this parameter must be in the port range of the endpoint group.
	//
	// This parameter takes effect only if **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations in each endpoint of a custom routing listener. You can specify up to five end ports for each destination.
	//
	// > You can configure endpoint groups and endpoints for a custom routing listener only if the **Type** parameter is set to **CustomRouting**.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) SetFromPort(v int32) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.FromPort = &v
	return s
}

func (s *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges) SetToPort(v int32) *CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.ToPort = &v
	return s
}

type CreateListenerRequestEndpointGroupConfigurations struct {
	// Specifies whether to use the proxy protocol to preserve client IP addresses. Valid values:
	//
	// *   **true**: uses the proxy protocol to preserve client IP addresses.
	// *   **false** (default): does not use the proxy protocol to preserve client IP addresses.
	//
	// You can set this parameter for up to 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	EnableClientIPPreservationProxyProtocol *bool `json:"EnableClientIPPreservationProxyProtocol,omitempty" xml:"EnableClientIPPreservationProxyProtocol,omitempty"`
	// Specifies whether to obtain and preserve the IP addresses of clients that access the endpoint by using the TCP Option Address (TOA) module. Valid values:
	//
	// *   **true**: preserves client IP addresses by using the TOA module.
	// *   **false** (default): does not preserve client IP addresses by using the TOA module.
	//
	// You can set this parameter for up to 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	EnableClientIPPreservationToa *bool `json:"EnableClientIPPreservationToa,omitempty" xml:"EnableClientIPPreservationToa,omitempty"`
	// The endpoint that is associated with the intelligent routing listener.
	EndpointConfigurations []*CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The description of the endpoint group that is associated with the intelligent routing listener.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	//
	// You can enter the descriptions of up to 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	EndpointGroupDescription *string `json:"EndpointGroupDescription,omitempty" xml:"EndpointGroupDescription,omitempty"`
	// The name of the endpoint group that is associated with the intelligent routing listener.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// You can enter the names of up to 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	EndpointGroupName *string `json:"EndpointGroupName,omitempty" xml:"EndpointGroupName,omitempty"`
	// The region ID of the endpoint group that is associated with the intelligent routing listener.
	//
	// You can enter the region IDs of up to 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The endpoint group type of the intelligent routing listener. Valid values:
	//
	// *   **default** (default): a default endpoint group.
	// *   **virtual**: a virtual endpoint group.
	//
	// You can specify the types of up to 10 endpoint groups.
	//
	// >
	//
	// *   You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	//
	// *   Only HTTP intelligent routing listeners and HTTPS intelligent routing listeners support virtual endpoint groups.
	EndpointGroupType *string `json:"EndpointGroupType,omitempty" xml:"EndpointGroupType,omitempty"`
	// The protocol used by the endpoint that is associated with the intelligent routing listener. Valid values:
	//
	// *   **HTTP** (default): HTTP
	// *   **HTTPS**: HTTPS
	//
	// You can specify at most 10 protocols.
	//
	// >
	//
	// *   You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	//
	// *   You can set this parameter only for HTTP intelligent routing listeners and HTTPS intelligent routing listeners.
	// *   For an HTTP listener, the protocol must be **HTTP**.
	EndpointRequestProtocol *string `json:"EndpointRequestProtocol,omitempty" xml:"EndpointRequestProtocol,omitempty"`
	// Specifies whether to enable health checks for the endpoint group that is associated with the intelligent routing listener. Valid values:
	//
	// *   **true**: enables the health check feature.
	// *   **false** (default): disables the health check feature.
	//
	// You can enable the health check feature for up to 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	HealthCheckEnabled *bool `json:"HealthCheckEnabled,omitempty" xml:"HealthCheckEnabled,omitempty"`
	// The interval at which you want to perform health checks. Unit: seconds.
	//
	// You can specify up to 10 health check intervals.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	HealthCheckIntervalSeconds *int64 `json:"HealthCheckIntervalSeconds,omitempty" xml:"HealthCheckIntervalSeconds,omitempty"`
	// The path to which health check requests are sent.
	//
	// You can specify up to 10 health check paths.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	HealthCheckPath *string `json:"HealthCheckPath,omitempty" xml:"HealthCheckPath,omitempty"`
	// The port that is used for health checks. Valid values: **1** to **65535**.
	//
	// You can specify up to 10 ports for health checks.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	HealthCheckPort *int64 `json:"HealthCheckPort,omitempty" xml:"HealthCheckPort,omitempty"`
	// The protocol over which health check requests are sent. Valid values:
	//
	// *   **tcp**: TCP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	//
	// You can specify up to 10 health check protocols.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	HealthCheckProtocol *string `json:"HealthCheckProtocol,omitempty" xml:"HealthCheckProtocol,omitempty"`
	// The mappings between ports.
	PortOverrides []*CreateListenerRequestEndpointGroupConfigurationsPortOverrides `json:"PortOverrides,omitempty" xml:"PortOverrides,omitempty" type:"Repeated"`
	// The number of consecutive health check failures that must occur before a healthy endpoint group is considered unhealthy, or the number of consecutive health check successes that must occur before an unhealthy endpoint group is considered healthy. Valid values: **2** to **10**. Default value: **3**.
	//
	// You can specify the number of consecutive health check successes or failures for at most 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	ThresholdCount *int64 `json:"ThresholdCount,omitempty" xml:"ThresholdCount,omitempty"`
	// The traffic distribution ratio. If an intelligent routing listener is associated with multiple endpoint groups, you can use this parameter to specify the ratio of traffic that you want to distribute to each endpoint group.
	//
	// Valid values: **1** to **100**. Default value: **100**.
	//
	// You can specify the traffic distribution ratios for up to 10 endpoint groups.
	//
	// > You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	TrafficPercentage *int64 `json:"TrafficPercentage,omitempty" xml:"TrafficPercentage,omitempty"`
}

func (s CreateListenerRequestEndpointGroupConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestEndpointGroupConfigurations) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEnableClientIPPreservationProxyProtocol(v bool) *CreateListenerRequestEndpointGroupConfigurations {
	s.EnableClientIPPreservationProxyProtocol = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEnableClientIPPreservationToa(v bool) *CreateListenerRequestEndpointGroupConfigurations {
	s.EnableClientIPPreservationToa = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEndpointConfigurations(v []*CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations) *CreateListenerRequestEndpointGroupConfigurations {
	s.EndpointConfigurations = v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEndpointGroupDescription(v string) *CreateListenerRequestEndpointGroupConfigurations {
	s.EndpointGroupDescription = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEndpointGroupName(v string) *CreateListenerRequestEndpointGroupConfigurations {
	s.EndpointGroupName = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEndpointGroupRegion(v string) *CreateListenerRequestEndpointGroupConfigurations {
	s.EndpointGroupRegion = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEndpointGroupType(v string) *CreateListenerRequestEndpointGroupConfigurations {
	s.EndpointGroupType = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetEndpointRequestProtocol(v string) *CreateListenerRequestEndpointGroupConfigurations {
	s.EndpointRequestProtocol = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetHealthCheckEnabled(v bool) *CreateListenerRequestEndpointGroupConfigurations {
	s.HealthCheckEnabled = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetHealthCheckIntervalSeconds(v int64) *CreateListenerRequestEndpointGroupConfigurations {
	s.HealthCheckIntervalSeconds = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetHealthCheckPath(v string) *CreateListenerRequestEndpointGroupConfigurations {
	s.HealthCheckPath = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetHealthCheckPort(v int64) *CreateListenerRequestEndpointGroupConfigurations {
	s.HealthCheckPort = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetHealthCheckProtocol(v string) *CreateListenerRequestEndpointGroupConfigurations {
	s.HealthCheckProtocol = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetPortOverrides(v []*CreateListenerRequestEndpointGroupConfigurationsPortOverrides) *CreateListenerRequestEndpointGroupConfigurations {
	s.PortOverrides = v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetThresholdCount(v int64) *CreateListenerRequestEndpointGroupConfigurations {
	s.ThresholdCount = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurations) SetTrafficPercentage(v int64) *CreateListenerRequestEndpointGroupConfigurations {
	s.TrafficPercentage = &v
	return s
}

type CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations struct {
	// The IP address or domain name of the endpoint that is associated with the intelligent routing listener.
	//
	// You can specify up to 100 endpoint IP addresses or domain names for an endpoint group of an intelligent routing listener.
	//
	// > If the **Type** parameter is set to **Standard**, you can configure endpoint groups and endpoints for an intelligent routing listener, and this parameter is required.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The endpoint type of the intelligent routing listener. Valid values:
	//
	// *   **Domain**: a custom domain name
	// *   **Ip**: a custom IP address
	// *   **PublicIp**: a public IP address provided by Alibaba Cloud
	// *   **ECS**: an Elastic Compute Service (ECS) instance
	// *   **SLB**: a Server Load Balancer (SLB) instance
	// *   **ALB**: an Application Load Balancer (ALB) instance
	// *   **OSS**: an Object Storage Service (OSS) bucket
	//
	// You can specify up to 100 endpoint types for an endpoint group of an intelligent routing listener.
	//
	// >
	//
	// *   If the **Type** parameter is set to **Standard**, you can configure endpoint groups and endpoints for an intelligent routing listener, and this parameter is required.
	//
	// *   If you set this parameter to **ECS** or **SLB** and the service-linked role AliyunServiceRoleForGaVpcEndpoint does not exist, the system creates the service-linked role.
	// *   If you set this parameter to **ALB** and the service-linked role AliyunServiceRoleForGaAlb does not exist, the system automatically creates the service-linked role.
	// *   If you set this parameter to **OSS** and the service-linked role AliyunServiceRoleForGaOss does not exist, the system automatically creates the service-linked role.
	//
	// For more information, see [Service-linked roles](~~178360~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the endpoint that is associated with the intelligent routing listener.
	//
	// Valid values: **0** to **255**.
	//
	// You can set the weights of up to 100 endpoints for an endpoint group of an intelligent routing listener.
	//
	// >
	//
	// *   If the **Type** parameter is set to **Standard**, you can configure endpoint groups and endpoints for an intelligent routing listener, and this parameter is required.
	//
	// *   If the weight of an endpoint is set to 0, GA stops distributing network traffic to the endpoint. Proceed with caution.
	Weight *int64 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations) SetEndpoint(v string) *CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations) SetType(v string) *CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Type = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations) SetWeight(v int64) *CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Weight = &v
	return s
}

type CreateListenerRequestEndpointGroupConfigurationsPortOverrides struct {
	// The endpoint port that is mapped to the listener port.
	//
	// You can specify up to five endpoint ports.
	//
	// >
	//
	// *   You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	//
	// *   Only HTTP intelligent routing listeners and HTTPS intelligent routing listeners support port mappings.
	EndpointPort *int64 `json:"EndpointPort,omitempty" xml:"EndpointPort,omitempty"`
	// The listener port that is mapped to the endpoint port.
	//
	// You can specify up to five listener ports.
	//
	// >
	//
	// *   You can configure endpoint groups and endpoints for an intelligent routing listener only if the **Type** parameter is set to **Standard**.
	//
	// *   Only HTTP intelligent routing listeners and HTTPS intelligent routing listeners support port mappings.
	// *   The listener port in a port mapping must be the port that is used by the current listener.
	ListenerPort *int64 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
}

func (s CreateListenerRequestEndpointGroupConfigurationsPortOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestEndpointGroupConfigurationsPortOverrides) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestEndpointGroupConfigurationsPortOverrides) SetEndpointPort(v int64) *CreateListenerRequestEndpointGroupConfigurationsPortOverrides {
	s.EndpointPort = &v
	return s
}

func (s *CreateListenerRequestEndpointGroupConfigurationsPortOverrides) SetListenerPort(v int64) *CreateListenerRequestEndpointGroupConfigurationsPortOverrides {
	s.ListenerPort = &v
	return s
}

type CreateListenerRequestPortRanges struct {
	// The first port of the listener port range that you want to use to receive and forward requests to endpoints.
	//
	// Valid values: **1** to **65499**. The value of **FromPort** must be smaller than or equal to the value of **ToPort**.
	//
	// The maximum number of ports that can be configured varies based on the routing type and protocol of the listener. For more information, see [Listener overview](~~153216~~).
	//
	// > You can configure only one listener port for an HTTP or HTTPS listener. In this case, the first port is the same as the last port.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port of the listener port range that you want to use to receive and forward requests to endpoints.
	//
	// Valid values: **1** to **65499**. The value of **FromPort** must be smaller than or equal to the value of **ToPort**.
	//
	// The maximum number of ports that can be configured varies based on the routing type and protocol of the listener. For more information, see [Listener overview](~~153216~~).
	//
	// > You can configure only one listener port for an HTTP or HTTPS listener. In this case, the first port is the same as the last port.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s CreateListenerRequestPortRanges) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestPortRanges) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestPortRanges) SetFromPort(v int32) *CreateListenerRequestPortRanges {
	s.FromPort = &v
	return s
}

func (s *CreateListenerRequestPortRanges) SetToPort(v int32) *CreateListenerRequestPortRanges {
	s.ToPort = &v
	return s
}

type CreateListenerRequestXForwardedForConfig struct {
	// Specifies whether to use the `GA-AP` header to retrieve the information about acceleration regions. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForGaApEnabled *bool `json:"XForwardedForGaApEnabled,omitempty" xml:"XForwardedForGaApEnabled,omitempty"`
	// Specifies whether to use the `GA-ID` header to retrieve the ID of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForGaIdEnabled *bool `json:"XForwardedForGaIdEnabled,omitempty" xml:"XForwardedForGaIdEnabled,omitempty"`
	// Specifies whether to use the `GA-X-Forward-Port` header to retrieve the listener ports of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForPortEnabled *bool `json:"XForwardedForPortEnabled,omitempty" xml:"XForwardedForPortEnabled,omitempty"`
	// Specifies whether to use the `GA-X-Forward-Proto` header to retrieve the listener protocol of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForProtoEnabled *bool `json:"XForwardedForProtoEnabled,omitempty" xml:"XForwardedForProtoEnabled,omitempty"`
	// Specifies whether to use the `X-Real-IP` header to retrieve client IP addresses. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XRealIpEnabled *bool `json:"XRealIpEnabled,omitempty" xml:"XRealIpEnabled,omitempty"`
}

func (s CreateListenerRequestXForwardedForConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerRequestXForwardedForConfig) GoString() string {
	return s.String()
}

func (s *CreateListenerRequestXForwardedForConfig) SetXForwardedForGaApEnabled(v bool) *CreateListenerRequestXForwardedForConfig {
	s.XForwardedForGaApEnabled = &v
	return s
}

func (s *CreateListenerRequestXForwardedForConfig) SetXForwardedForGaIdEnabled(v bool) *CreateListenerRequestXForwardedForConfig {
	s.XForwardedForGaIdEnabled = &v
	return s
}

func (s *CreateListenerRequestXForwardedForConfig) SetXForwardedForPortEnabled(v bool) *CreateListenerRequestXForwardedForConfig {
	s.XForwardedForPortEnabled = &v
	return s
}

func (s *CreateListenerRequestXForwardedForConfig) SetXForwardedForProtoEnabled(v bool) *CreateListenerRequestXForwardedForConfig {
	s.XForwardedForProtoEnabled = &v
	return s
}

func (s *CreateListenerRequestXForwardedForConfig) SetXRealIpEnabled(v bool) *CreateListenerRequestXForwardedForConfig {
	s.XRealIpEnabled = &v
	return s
}

type CreateListenerResponseBody struct {
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateListenerResponseBody) SetListenerId(v string) *CreateListenerResponseBody {
	s.ListenerId = &v
	return s
}

func (s *CreateListenerResponseBody) SetRequestId(v string) *CreateListenerResponseBody {
	s.RequestId = &v
	return s
}

type CreateListenerResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateListenerResponse) GoString() string {
	return s.String()
}

func (s *CreateListenerResponse) SetHeaders(v map[string]*string) *CreateListenerResponse {
	s.Headers = v
	return s
}

func (s *CreateListenerResponse) SetStatusCode(v int32) *CreateListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateListenerResponse) SetBody(v *CreateListenerResponseBody) *CreateListenerResponse {
	s.Body = v
	return s
}

type CreateSpareIpsRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true:** performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (defalut): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The secondary IP addresses to be created for the CNAME. If an acceleration area of the GA instance become unavailable, GA redirects the access traffic to the secondary IP addresses.
	//
	// You can specify up to 2 secondary IP addresses. Separate IP addresses with commas (,).
	SpareIps []*string `json:"SpareIps,omitempty" xml:"SpareIps,omitempty" type:"Repeated"`
}

func (s CreateSpareIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSpareIpsRequest) GoString() string {
	return s.String()
}

func (s *CreateSpareIpsRequest) SetAcceleratorId(v string) *CreateSpareIpsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *CreateSpareIpsRequest) SetClientToken(v string) *CreateSpareIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateSpareIpsRequest) SetDryRun(v bool) *CreateSpareIpsRequest {
	s.DryRun = &v
	return s
}

func (s *CreateSpareIpsRequest) SetRegionId(v string) *CreateSpareIpsRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSpareIpsRequest) SetSpareIps(v []*string) *CreateSpareIpsRequest {
	s.SpareIps = v
	return s
}

type CreateSpareIpsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateSpareIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSpareIpsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSpareIpsResponseBody) SetRequestId(v string) *CreateSpareIpsResponseBody {
	s.RequestId = &v
	return s
}

type CreateSpareIpsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSpareIpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSpareIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSpareIpsResponse) GoString() string {
	return s.String()
}

func (s *CreateSpareIpsResponse) SetHeaders(v map[string]*string) *CreateSpareIpsResponse {
	s.Headers = v
	return s
}

func (s *CreateSpareIpsResponse) SetStatusCode(v int32) *CreateSpareIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSpareIpsResponse) SetBody(v *CreateSpareIpsResponseBody) *CreateSpareIpsResponse {
	s.Body = v
	return s
}

type DeleteAcceleratorRequest struct {
	// The ID of the GA instance that you want to delete.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region where your GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *DeleteAcceleratorRequest) SetAcceleratorId(v string) *DeleteAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteAcceleratorRequest) SetRegionId(v string) *DeleteAcceleratorRequest {
	s.RegionId = &v
	return s
}

type DeleteAcceleratorResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAcceleratorResponseBody) SetAcceleratorId(v string) *DeleteAcceleratorResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteAcceleratorResponseBody) SetRequestId(v string) *DeleteAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAcceleratorResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *DeleteAcceleratorResponse) SetHeaders(v map[string]*string) *DeleteAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *DeleteAcceleratorResponse) SetStatusCode(v int32) *DeleteAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAcceleratorResponse) SetBody(v *DeleteAcceleratorResponseBody) *DeleteAcceleratorResponse {
	s.Body = v
	return s
}

type DeleteAclRequest struct {
	// The ID of the network ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck the request. Default value: false. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteAclRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAclRequest) GoString() string {
	return s.String()
}

func (s *DeleteAclRequest) SetAclId(v string) *DeleteAclRequest {
	s.AclId = &v
	return s
}

func (s *DeleteAclRequest) SetClientToken(v string) *DeleteAclRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteAclRequest) SetDryRun(v bool) *DeleteAclRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteAclRequest) SetRegionId(v string) *DeleteAclRequest {
	s.RegionId = &v
	return s
}

type DeleteAclResponseBody struct {
	// The ID of the network ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAclResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAclResponseBody) SetAclId(v string) *DeleteAclResponseBody {
	s.AclId = &v
	return s
}

func (s *DeleteAclResponseBody) SetRequestId(v string) *DeleteAclResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAclResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAclResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAclResponse) GoString() string {
	return s.String()
}

func (s *DeleteAclResponse) SetHeaders(v map[string]*string) *DeleteAclResponse {
	s.Headers = v
	return s
}

func (s *DeleteAclResponse) SetStatusCode(v int32) *DeleteAclResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAclResponse) SetBody(v *DeleteAclResponseBody) *DeleteAclResponse {
	s.Body = v
	return s
}

type DeleteApplicationMonitorRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the origin probing task that you want to delete.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DeleteApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *DeleteApplicationMonitorRequest) SetClientToken(v string) *DeleteApplicationMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteApplicationMonitorRequest) SetRegionId(v string) *DeleteApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteApplicationMonitorRequest) SetTaskId(v string) *DeleteApplicationMonitorRequest {
	s.TaskId = &v
	return s
}

type DeleteApplicationMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteApplicationMonitorResponseBody) SetRequestId(v string) *DeleteApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DeleteApplicationMonitorResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *DeleteApplicationMonitorResponse) SetHeaders(v map[string]*string) *DeleteApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *DeleteApplicationMonitorResponse) SetStatusCode(v int32) *DeleteApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteApplicationMonitorResponse) SetBody(v *DeleteApplicationMonitorResponseBody) *DeleteApplicationMonitorResponse {
	s.Body = v
	return s
}

type DeleteBandwidthPackageRequest struct {
	// The bandwidth plan ID.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *DeleteBandwidthPackageRequest) SetBandwidthPackageId(v string) *DeleteBandwidthPackageRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *DeleteBandwidthPackageRequest) SetClientToken(v string) *DeleteBandwidthPackageRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBandwidthPackageRequest) SetRegionId(v string) *DeleteBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

type DeleteBandwidthPackageResponseBody struct {
	// The bandwidth plan ID.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBandwidthPackageResponseBody) SetBandwidthPackageId(v string) *DeleteBandwidthPackageResponseBody {
	s.BandwidthPackageId = &v
	return s
}

func (s *DeleteBandwidthPackageResponseBody) SetRequestId(v string) *DeleteBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBandwidthPackageResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *DeleteBandwidthPackageResponse) SetHeaders(v map[string]*string) *DeleteBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *DeleteBandwidthPackageResponse) SetStatusCode(v int32) *DeleteBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBandwidthPackageResponse) SetBody(v *DeleteBandwidthPackageResponseBody) *DeleteBandwidthPackageResponse {
	s.Body = v
	return s
}

type DeleteBasicAccelerateIpRequest struct {
	// The ID of the accelerated IP address that you want to delete.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteBasicAccelerateIpRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAccelerateIpRequest) GoString() string {
	return s.String()
}

func (s *DeleteBasicAccelerateIpRequest) SetAccelerateIpId(v string) *DeleteBasicAccelerateIpRequest {
	s.AccelerateIpId = &v
	return s
}

func (s *DeleteBasicAccelerateIpRequest) SetClientToken(v string) *DeleteBasicAccelerateIpRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBasicAccelerateIpRequest) SetRegionId(v string) *DeleteBasicAccelerateIpRequest {
	s.RegionId = &v
	return s
}

type DeleteBasicAccelerateIpResponseBody struct {
	// The ID of the accelerated IP address that is deleted.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBasicAccelerateIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAccelerateIpResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBasicAccelerateIpResponseBody) SetAccelerateIpId(v string) *DeleteBasicAccelerateIpResponseBody {
	s.AccelerateIpId = &v
	return s
}

func (s *DeleteBasicAccelerateIpResponseBody) SetRequestId(v string) *DeleteBasicAccelerateIpResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBasicAccelerateIpResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBasicAccelerateIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBasicAccelerateIpResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAccelerateIpResponse) GoString() string {
	return s.String()
}

func (s *DeleteBasicAccelerateIpResponse) SetHeaders(v map[string]*string) *DeleteBasicAccelerateIpResponse {
	s.Headers = v
	return s
}

func (s *DeleteBasicAccelerateIpResponse) SetStatusCode(v int32) *DeleteBasicAccelerateIpResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBasicAccelerateIpResponse) SetBody(v *DeleteBasicAccelerateIpResponseBody) *DeleteBasicAccelerateIpResponse {
	s.Body = v
	return s
}

type DeleteBasicAccelerateIpEndpointRelationRequest struct {
	// The ID of the accelerated IP address of the basic GA instance.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint that is associated with the basic GA instance.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteBasicAccelerateIpEndpointRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAccelerateIpEndpointRelationRequest) GoString() string {
	return s.String()
}

func (s *DeleteBasicAccelerateIpEndpointRelationRequest) SetAccelerateIpId(v string) *DeleteBasicAccelerateIpEndpointRelationRequest {
	s.AccelerateIpId = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationRequest) SetAcceleratorId(v string) *DeleteBasicAccelerateIpEndpointRelationRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationRequest) SetClientToken(v string) *DeleteBasicAccelerateIpEndpointRelationRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationRequest) SetEndpointId(v string) *DeleteBasicAccelerateIpEndpointRelationRequest {
	s.EndpointId = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationRequest) SetRegionId(v string) *DeleteBasicAccelerateIpEndpointRelationRequest {
	s.RegionId = &v
	return s
}

type DeleteBasicAccelerateIpEndpointRelationResponseBody struct {
	// The ID of the accelerated IP address of the basic GA instance.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint that is associated with the basic GA instance.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the mapping between the accelerated IP address and endpoint.
	//
	// >  This parameter is not in use and empty.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DeleteBasicAccelerateIpEndpointRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAccelerateIpEndpointRelationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponseBody) SetAccelerateIpId(v string) *DeleteBasicAccelerateIpEndpointRelationResponseBody {
	s.AccelerateIpId = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponseBody) SetAcceleratorId(v string) *DeleteBasicAccelerateIpEndpointRelationResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponseBody) SetEndpointId(v string) *DeleteBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointId = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponseBody) SetRequestId(v string) *DeleteBasicAccelerateIpEndpointRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponseBody) SetState(v string) *DeleteBasicAccelerateIpEndpointRelationResponseBody {
	s.State = &v
	return s
}

type DeleteBasicAccelerateIpEndpointRelationResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBasicAccelerateIpEndpointRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBasicAccelerateIpEndpointRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAccelerateIpEndpointRelationResponse) GoString() string {
	return s.String()
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponse) SetHeaders(v map[string]*string) *DeleteBasicAccelerateIpEndpointRelationResponse {
	s.Headers = v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponse) SetStatusCode(v int32) *DeleteBasicAccelerateIpEndpointRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBasicAccelerateIpEndpointRelationResponse) SetBody(v *DeleteBasicAccelerateIpEndpointRelationResponseBody) *DeleteBasicAccelerateIpEndpointRelationResponse {
	s.Body = v
	return s
}

type DeleteBasicAcceleratorRequest struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region to which the basic GA instance belongs. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteBasicAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *DeleteBasicAcceleratorRequest) SetAcceleratorId(v string) *DeleteBasicAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteBasicAcceleratorRequest) SetRegionId(v string) *DeleteBasicAcceleratorRequest {
	s.RegionId = &v
	return s
}

type DeleteBasicAcceleratorResponseBody struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBasicAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBasicAcceleratorResponseBody) SetAcceleratorId(v string) *DeleteBasicAcceleratorResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteBasicAcceleratorResponseBody) SetRequestId(v string) *DeleteBasicAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBasicAcceleratorResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBasicAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBasicAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *DeleteBasicAcceleratorResponse) SetHeaders(v map[string]*string) *DeleteBasicAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *DeleteBasicAcceleratorResponse) SetStatusCode(v int32) *DeleteBasicAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBasicAcceleratorResponse) SetBody(v *DeleteBasicAcceleratorResponseBody) *DeleteBasicAcceleratorResponse {
	s.Body = v
	return s
}

type DeleteBasicEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group to which the endpoint to be deleted belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint that you want to delete.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteBasicEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicEndpointRequest) GoString() string {
	return s.String()
}

func (s *DeleteBasicEndpointRequest) SetClientToken(v string) *DeleteBasicEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBasicEndpointRequest) SetEndpointGroupId(v string) *DeleteBasicEndpointRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *DeleteBasicEndpointRequest) SetEndpointId(v string) *DeleteBasicEndpointRequest {
	s.EndpointId = &v
	return s
}

func (s *DeleteBasicEndpointRequest) SetRegionId(v string) *DeleteBasicEndpointRequest {
	s.RegionId = &v
	return s
}

type DeleteBasicEndpointResponseBody struct {
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBasicEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBasicEndpointResponseBody) SetEndpointId(v string) *DeleteBasicEndpointResponseBody {
	s.EndpointId = &v
	return s
}

func (s *DeleteBasicEndpointResponseBody) SetRequestId(v string) *DeleteBasicEndpointResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBasicEndpointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBasicEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBasicEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicEndpointResponse) GoString() string {
	return s.String()
}

func (s *DeleteBasicEndpointResponse) SetHeaders(v map[string]*string) *DeleteBasicEndpointResponse {
	s.Headers = v
	return s
}

func (s *DeleteBasicEndpointResponse) SetStatusCode(v int32) *DeleteBasicEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBasicEndpointResponse) SetBody(v *DeleteBasicEndpointResponseBody) *DeleteBasicEndpointResponse {
	s.Body = v
	return s
}

type DeleteBasicEndpointGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group that is associated with the basic GA instance.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
}

func (s DeleteBasicEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteBasicEndpointGroupRequest) SetClientToken(v string) *DeleteBasicEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBasicEndpointGroupRequest) SetEndpointGroupId(v string) *DeleteBasicEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

type DeleteBasicEndpointGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBasicEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBasicEndpointGroupResponseBody) SetRequestId(v string) *DeleteBasicEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBasicEndpointGroupResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBasicEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBasicEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteBasicEndpointGroupResponse) SetHeaders(v map[string]*string) *DeleteBasicEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteBasicEndpointGroupResponse) SetStatusCode(v int32) *DeleteBasicEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBasicEndpointGroupResponse) SetBody(v *DeleteBasicEndpointGroupResponseBody) *DeleteBasicEndpointGroupResponse {
	s.Body = v
	return s
}

type DeleteBasicIpSetRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region of the basic GA instance.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the region where the basic GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteBasicIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicIpSetRequest) GoString() string {
	return s.String()
}

func (s *DeleteBasicIpSetRequest) SetClientToken(v string) *DeleteBasicIpSetRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteBasicIpSetRequest) SetIpSetId(v string) *DeleteBasicIpSetRequest {
	s.IpSetId = &v
	return s
}

func (s *DeleteBasicIpSetRequest) SetRegionId(v string) *DeleteBasicIpSetRequest {
	s.RegionId = &v
	return s
}

type DeleteBasicIpSetResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBasicIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBasicIpSetResponseBody) SetRequestId(v string) *DeleteBasicIpSetResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBasicIpSetResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBasicIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBasicIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBasicIpSetResponse) GoString() string {
	return s.String()
}

func (s *DeleteBasicIpSetResponse) SetHeaders(v map[string]*string) *DeleteBasicIpSetResponse {
	s.Headers = v
	return s
}

func (s *DeleteBasicIpSetResponse) SetStatusCode(v int32) *DeleteBasicIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBasicIpSetResponse) SetBody(v *DeleteBasicIpSetResponseBody) *DeleteBasicIpSetResponse {
	s.Body = v
	return s
}

type DeleteCustomRoutingEndpointGroupDestinationsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of the endpoint group mappings.
	DestinationIds []*string `json:"DestinationIds,omitempty" xml:"DestinationIds,omitempty" type:"Repeated"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**: performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The endpoint group ID.
	//
	// **
	//
	// ****
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCustomRoutingEndpointGroupDestinationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointGroupDestinationsRequest) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsRequest) SetClientToken(v string) *DeleteCustomRoutingEndpointGroupDestinationsRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsRequest) SetDestinationIds(v []*string) *DeleteCustomRoutingEndpointGroupDestinationsRequest {
	s.DestinationIds = v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsRequest) SetDryRun(v bool) *DeleteCustomRoutingEndpointGroupDestinationsRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsRequest) SetEndpointGroupId(v string) *DeleteCustomRoutingEndpointGroupDestinationsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsRequest) SetRegionId(v string) *DeleteCustomRoutingEndpointGroupDestinationsRequest {
	s.RegionId = &v
	return s
}

type DeleteCustomRoutingEndpointGroupDestinationsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCustomRoutingEndpointGroupDestinationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointGroupDestinationsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsResponseBody) SetRequestId(v string) *DeleteCustomRoutingEndpointGroupDestinationsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCustomRoutingEndpointGroupDestinationsResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCustomRoutingEndpointGroupDestinationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCustomRoutingEndpointGroupDestinationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointGroupDestinationsResponse) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsResponse) SetHeaders(v map[string]*string) *DeleteCustomRoutingEndpointGroupDestinationsResponse {
	s.Headers = v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsResponse) SetStatusCode(v int32) *DeleteCustomRoutingEndpointGroupDestinationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupDestinationsResponse) SetBody(v *DeleteCustomRoutingEndpointGroupDestinationsResponseBody) *DeleteCustomRoutingEndpointGroupDestinationsResponse {
	s.Body = v
	return s
}

type DeleteCustomRoutingEndpointGroupsRequest struct {
	// The ID of the GA instance that you want to query.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true:** performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false:** performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The IDs of the endpoint groups that you want to delete.
	//
	// You can specify up to 10 endpoint group IDs.
	EndpointGroupIds []*string `json:"EndpointGroupIds,omitempty" xml:"EndpointGroupIds,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCustomRoutingEndpointGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointGroupsRequest) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointGroupsRequest) SetAcceleratorId(v string) *DeleteCustomRoutingEndpointGroupsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupsRequest) SetClientToken(v string) *DeleteCustomRoutingEndpointGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupsRequest) SetDryRun(v bool) *DeleteCustomRoutingEndpointGroupsRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupsRequest) SetEndpointGroupIds(v []*string) *DeleteCustomRoutingEndpointGroupsRequest {
	s.EndpointGroupIds = v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupsRequest) SetRegionId(v string) *DeleteCustomRoutingEndpointGroupsRequest {
	s.RegionId = &v
	return s
}

type DeleteCustomRoutingEndpointGroupsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCustomRoutingEndpointGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointGroupsResponseBody) SetRequestId(v string) *DeleteCustomRoutingEndpointGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCustomRoutingEndpointGroupsResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCustomRoutingEndpointGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCustomRoutingEndpointGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointGroupsResponse) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointGroupsResponse) SetHeaders(v map[string]*string) *DeleteCustomRoutingEndpointGroupsResponse {
	s.Headers = v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupsResponse) SetStatusCode(v int32) *DeleteCustomRoutingEndpointGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCustomRoutingEndpointGroupsResponse) SetBody(v *DeleteCustomRoutingEndpointGroupsResponseBody) *DeleteCustomRoutingEndpointGroupsResponse {
	s.Body = v
	return s
}

type DeleteCustomRoutingEndpointTrafficPoliciesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint for which you want to delete traffic destinations.
	//
	// >  This parameter is required.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The IDs of the traffic destinations.
	//
	// You can specify the IDs of up to 9,000 traffic destinations.
	PolicyIds []*string `json:"PolicyIds,omitempty" xml:"PolicyIds,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCustomRoutingEndpointTrafficPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointTrafficPoliciesRequest) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesRequest) SetClientToken(v string) *DeleteCustomRoutingEndpointTrafficPoliciesRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesRequest) SetEndpointId(v string) *DeleteCustomRoutingEndpointTrafficPoliciesRequest {
	s.EndpointId = &v
	return s
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesRequest) SetPolicyIds(v []*string) *DeleteCustomRoutingEndpointTrafficPoliciesRequest {
	s.PolicyIds = v
	return s
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesRequest) SetRegionId(v string) *DeleteCustomRoutingEndpointTrafficPoliciesRequest {
	s.RegionId = &v
	return s
}

type DeleteCustomRoutingEndpointTrafficPoliciesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCustomRoutingEndpointTrafficPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointTrafficPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesResponseBody) SetRequestId(v string) *DeleteCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCustomRoutingEndpointTrafficPoliciesResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCustomRoutingEndpointTrafficPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCustomRoutingEndpointTrafficPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointTrafficPoliciesResponse) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesResponse) SetHeaders(v map[string]*string) *DeleteCustomRoutingEndpointTrafficPoliciesResponse {
	s.Headers = v
	return s
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesResponse) SetStatusCode(v int32) *DeleteCustomRoutingEndpointTrafficPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCustomRoutingEndpointTrafficPoliciesResponse) SetBody(v *DeleteCustomRoutingEndpointTrafficPoliciesResponseBody) *DeleteCustomRoutingEndpointTrafficPoliciesResponse {
	s.Body = v
	return s
}

type DeleteCustomRoutingEndpointsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group to which the endpoint that you want to delete belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The IDs of endpoints to be deleted.
	//
	// If you do not set this parameter, all the endpoints in the specified endpoint group are deleted.
	//
	// You can specify at most 10 endpoint IDs.
	EndpointIds []*string `json:"EndpointIds,omitempty" xml:"EndpointIds,omitempty" type:"Repeated"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCustomRoutingEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointsRequest) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointsRequest) SetClientToken(v string) *DeleteCustomRoutingEndpointsRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCustomRoutingEndpointsRequest) SetEndpointGroupId(v string) *DeleteCustomRoutingEndpointsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *DeleteCustomRoutingEndpointsRequest) SetEndpointIds(v []*string) *DeleteCustomRoutingEndpointsRequest {
	s.EndpointIds = v
	return s
}

func (s *DeleteCustomRoutingEndpointsRequest) SetRegionId(v string) *DeleteCustomRoutingEndpointsRequest {
	s.RegionId = &v
	return s
}

type DeleteCustomRoutingEndpointsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCustomRoutingEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointsResponseBody) SetRequestId(v string) *DeleteCustomRoutingEndpointsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCustomRoutingEndpointsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCustomRoutingEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCustomRoutingEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomRoutingEndpointsResponse) GoString() string {
	return s.String()
}

func (s *DeleteCustomRoutingEndpointsResponse) SetHeaders(v map[string]*string) *DeleteCustomRoutingEndpointsResponse {
	s.Headers = v
	return s
}

func (s *DeleteCustomRoutingEndpointsResponse) SetStatusCode(v int32) *DeleteCustomRoutingEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCustomRoutingEndpointsResponse) SetBody(v *DeleteCustomRoutingEndpointsResponseBody) *DeleteCustomRoutingEndpointsResponse {
	s.Body = v
	return s
}

type DeleteDomainAcceleratorRelationRequest struct {
	// The ID of the GA instance to be disassociated. You can specify up to 50 IDs.
	//
	// If you leave this parameter empty, all GA instances associated with the specified domain name are disassociated.
	AcceleratorIds []*string `json:"AcceleratorIds,omitempty" xml:"AcceleratorIds,omitempty" type:"Repeated"`
	// The accelerated domain name to be disassociated.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteDomainAcceleratorRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainAcceleratorRelationRequest) GoString() string {
	return s.String()
}

func (s *DeleteDomainAcceleratorRelationRequest) SetAcceleratorIds(v []*string) *DeleteDomainAcceleratorRelationRequest {
	s.AcceleratorIds = v
	return s
}

func (s *DeleteDomainAcceleratorRelationRequest) SetDomain(v string) *DeleteDomainAcceleratorRelationRequest {
	s.Domain = &v
	return s
}

func (s *DeleteDomainAcceleratorRelationRequest) SetRegionId(v string) *DeleteDomainAcceleratorRelationRequest {
	s.RegionId = &v
	return s
}

type DeleteDomainAcceleratorRelationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDomainAcceleratorRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainAcceleratorRelationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDomainAcceleratorRelationResponseBody) SetRequestId(v string) *DeleteDomainAcceleratorRelationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDomainAcceleratorRelationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDomainAcceleratorRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDomainAcceleratorRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainAcceleratorRelationResponse) GoString() string {
	return s.String()
}

func (s *DeleteDomainAcceleratorRelationResponse) SetHeaders(v map[string]*string) *DeleteDomainAcceleratorRelationResponse {
	s.Headers = v
	return s
}

func (s *DeleteDomainAcceleratorRelationResponse) SetStatusCode(v int32) *DeleteDomainAcceleratorRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDomainAcceleratorRelationResponse) SetBody(v *DeleteDomainAcceleratorRelationResponseBody) *DeleteDomainAcceleratorRelationResponse {
	s.Body = v
	return s
}

type DeleteEndpointGroupRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group that you want to delete.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
}

func (s DeleteEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteEndpointGroupRequest) SetAcceleratorId(v string) *DeleteEndpointGroupRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteEndpointGroupRequest) SetClientToken(v string) *DeleteEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteEndpointGroupRequest) SetEndpointGroupId(v string) *DeleteEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

type DeleteEndpointGroupResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEndpointGroupResponseBody) SetRequestId(v string) *DeleteEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEndpointGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteEndpointGroupResponse) SetHeaders(v map[string]*string) *DeleteEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteEndpointGroupResponse) SetStatusCode(v int32) *DeleteEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEndpointGroupResponse) SetBody(v *DeleteEndpointGroupResponseBody) *DeleteEndpointGroupResponse {
	s.Body = v
	return s
}

type DeleteEndpointGroupsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The IDs of the endpoint groups.
	EndpointGroupIds []*string `json:"EndpointGroupIds,omitempty" xml:"EndpointGroupIds,omitempty" type:"Repeated"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteEndpointGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEndpointGroupsRequest) GoString() string {
	return s.String()
}

func (s *DeleteEndpointGroupsRequest) SetClientToken(v string) *DeleteEndpointGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteEndpointGroupsRequest) SetDryRun(v bool) *DeleteEndpointGroupsRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteEndpointGroupsRequest) SetEndpointGroupIds(v []*string) *DeleteEndpointGroupsRequest {
	s.EndpointGroupIds = v
	return s
}

func (s *DeleteEndpointGroupsRequest) SetRegionId(v string) *DeleteEndpointGroupsRequest {
	s.RegionId = &v
	return s
}

type DeleteEndpointGroupsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEndpointGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEndpointGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEndpointGroupsResponseBody) SetRequestId(v string) *DeleteEndpointGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEndpointGroupsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEndpointGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEndpointGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEndpointGroupsResponse) GoString() string {
	return s.String()
}

func (s *DeleteEndpointGroupsResponse) SetHeaders(v map[string]*string) *DeleteEndpointGroupsResponse {
	s.Headers = v
	return s
}

func (s *DeleteEndpointGroupsResponse) SetStatusCode(v int32) *DeleteEndpointGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEndpointGroupsResponse) SetBody(v *DeleteEndpointGroupsResponseBody) *DeleteEndpointGroupsResponse {
	s.Body = v
	return s
}

type DeleteForwardingRulesRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The forwarding rules.
	ForwardingRuleIds []*string `json:"ForwardingRuleIds,omitempty" xml:"ForwardingRuleIds,omitempty" type:"Repeated"`
	// The listener ID.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteForwardingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteForwardingRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteForwardingRulesRequest) SetAcceleratorId(v string) *DeleteForwardingRulesRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteForwardingRulesRequest) SetClientToken(v string) *DeleteForwardingRulesRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteForwardingRulesRequest) SetForwardingRuleIds(v []*string) *DeleteForwardingRulesRequest {
	s.ForwardingRuleIds = v
	return s
}

func (s *DeleteForwardingRulesRequest) SetListenerId(v string) *DeleteForwardingRulesRequest {
	s.ListenerId = &v
	return s
}

func (s *DeleteForwardingRulesRequest) SetRegionId(v string) *DeleteForwardingRulesRequest {
	s.RegionId = &v
	return s
}

type DeleteForwardingRulesResponseBody struct {
	// The forwarding rules.
	ForwardingRules []*DeleteForwardingRulesResponseBodyForwardingRules `json:"ForwardingRules,omitempty" xml:"ForwardingRules,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteForwardingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteForwardingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteForwardingRulesResponseBody) SetForwardingRules(v []*DeleteForwardingRulesResponseBodyForwardingRules) *DeleteForwardingRulesResponseBody {
	s.ForwardingRules = v
	return s
}

func (s *DeleteForwardingRulesResponseBody) SetRequestId(v string) *DeleteForwardingRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteForwardingRulesResponseBodyForwardingRules struct {
	// The forwarding rule ID.
	ForwardingRuleId *string `json:"ForwardingRuleId,omitempty" xml:"ForwardingRuleId,omitempty"`
}

func (s DeleteForwardingRulesResponseBodyForwardingRules) String() string {
	return tea.Prettify(s)
}

func (s DeleteForwardingRulesResponseBodyForwardingRules) GoString() string {
	return s.String()
}

func (s *DeleteForwardingRulesResponseBodyForwardingRules) SetForwardingRuleId(v string) *DeleteForwardingRulesResponseBodyForwardingRules {
	s.ForwardingRuleId = &v
	return s
}

type DeleteForwardingRulesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteForwardingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteForwardingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteForwardingRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteForwardingRulesResponse) SetHeaders(v map[string]*string) *DeleteForwardingRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteForwardingRulesResponse) SetStatusCode(v int32) *DeleteForwardingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteForwardingRulesResponse) SetBody(v *DeleteForwardingRulesResponseBody) *DeleteForwardingRulesResponse {
	s.Body = v
	return s
}

type DeleteIpSetRequest struct {
	// The ID of the GA instance for which you want to delete an acceleration region.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region that you want to delete.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpSetRequest) GoString() string {
	return s.String()
}

func (s *DeleteIpSetRequest) SetAcceleratorId(v string) *DeleteIpSetRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteIpSetRequest) SetClientToken(v string) *DeleteIpSetRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteIpSetRequest) SetIpSetId(v string) *DeleteIpSetRequest {
	s.IpSetId = &v
	return s
}

func (s *DeleteIpSetRequest) SetRegionId(v string) *DeleteIpSetRequest {
	s.RegionId = &v
	return s
}

type DeleteIpSetResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIpSetResponseBody) SetRequestId(v string) *DeleteIpSetResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIpSetResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpSetResponse) GoString() string {
	return s.String()
}

func (s *DeleteIpSetResponse) SetHeaders(v map[string]*string) *DeleteIpSetResponse {
	s.Headers = v
	return s
}

func (s *DeleteIpSetResponse) SetStatusCode(v int32) *DeleteIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIpSetResponse) SetBody(v *DeleteIpSetResponseBody) *DeleteIpSetResponse {
	s.Body = v
	return s
}

type DeleteIpSetsRequest struct {
	// The ID of the acceleration region that you want to delete.
	IpSetIds []*string `json:"IpSetIds,omitempty" xml:"IpSetIds,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteIpSetsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpSetsRequest) GoString() string {
	return s.String()
}

func (s *DeleteIpSetsRequest) SetIpSetIds(v []*string) *DeleteIpSetsRequest {
	s.IpSetIds = v
	return s
}

func (s *DeleteIpSetsRequest) SetRegionId(v string) *DeleteIpSetsRequest {
	s.RegionId = &v
	return s
}

type DeleteIpSetsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIpSetsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpSetsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIpSetsResponseBody) SetRequestId(v string) *DeleteIpSetsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIpSetsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIpSetsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIpSetsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIpSetsResponse) GoString() string {
	return s.String()
}

func (s *DeleteIpSetsResponse) SetHeaders(v map[string]*string) *DeleteIpSetsResponse {
	s.Headers = v
	return s
}

func (s *DeleteIpSetsResponse) SetStatusCode(v int32) *DeleteIpSetsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIpSetsResponse) SetBody(v *DeleteIpSetsResponseBody) *DeleteIpSetsResponse {
	s.Body = v
	return s
}

type DeleteListenerRequest struct {
	// The ID of the GA instance for which you want to delete a listener.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the listener that you want to delete.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
}

func (s DeleteListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteListenerRequest) GoString() string {
	return s.String()
}

func (s *DeleteListenerRequest) SetAcceleratorId(v string) *DeleteListenerRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteListenerRequest) SetClientToken(v string) *DeleteListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteListenerRequest) SetListenerId(v string) *DeleteListenerRequest {
	s.ListenerId = &v
	return s
}

type DeleteListenerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteListenerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteListenerResponseBody) SetRequestId(v string) *DeleteListenerResponseBody {
	s.RequestId = &v
	return s
}

type DeleteListenerResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteListenerResponse) GoString() string {
	return s.String()
}

func (s *DeleteListenerResponse) SetHeaders(v map[string]*string) *DeleteListenerResponse {
	s.Headers = v
	return s
}

func (s *DeleteListenerResponse) SetStatusCode(v int32) *DeleteListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteListenerResponse) SetBody(v *DeleteListenerResponseBody) *DeleteListenerResponse {
	s.Body = v
	return s
}

type DeleteSpareIpsRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true:** performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (defalut): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The secondary IP addresses to be deleted for the CNAME. If an acceleration area of the GA instance becomes unavailable, GA redirects the access traffic to the secondary IP addresses.
	//
	// Separate the IP addresses with commas (,). You can specify up to two secondary IP addresses.
	SpareIps []*string `json:"SpareIps,omitempty" xml:"SpareIps,omitempty" type:"Repeated"`
}

func (s DeleteSpareIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpareIpsRequest) GoString() string {
	return s.String()
}

func (s *DeleteSpareIpsRequest) SetAcceleratorId(v string) *DeleteSpareIpsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DeleteSpareIpsRequest) SetClientToken(v string) *DeleteSpareIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteSpareIpsRequest) SetDryRun(v bool) *DeleteSpareIpsRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteSpareIpsRequest) SetRegionId(v string) *DeleteSpareIpsRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteSpareIpsRequest) SetSpareIps(v []*string) *DeleteSpareIpsRequest {
	s.SpareIps = v
	return s
}

type DeleteSpareIpsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSpareIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpareIpsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSpareIpsResponseBody) SetRequestId(v string) *DeleteSpareIpsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSpareIpsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSpareIpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSpareIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpareIpsResponse) GoString() string {
	return s.String()
}

func (s *DeleteSpareIpsResponse) SetHeaders(v map[string]*string) *DeleteSpareIpsResponse {
	s.Headers = v
	return s
}

func (s *DeleteSpareIpsResponse) SetStatusCode(v int32) *DeleteSpareIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSpareIpsResponse) SetBody(v *DeleteSpareIpsResponseBody) *DeleteSpareIpsResponse {
	s.Body = v
	return s
}

type DescribeAcceleratorRequest struct {
	// The ID of the GA instance that you want to query.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorRequest) SetAcceleratorId(v string) *DescribeAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeAcceleratorRequest) SetRegionId(v string) *DescribeAcceleratorRequest {
	s.RegionId = &v
	return s
}

type DescribeAcceleratorResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth metering method. Valid values:
	//
	// *   **BandwidthPackage:** billed based on bandwidth plans.
	// *   **CDT**: billed based on data transfer.
	BandwidthBillingType *string `json:"BandwidthBillingType,omitempty" xml:"BandwidthBillingType,omitempty"`
	// The details about the basic bandwidth plan that is associated with the GA instance.
	BasicBandwidthPackage *DescribeAcceleratorResponseBodyBasicBandwidthPackage `json:"BasicBandwidthPackage,omitempty" xml:"BasicBandwidthPackage,omitempty" type:"Struct"`
	// The ID of the Cloud Enterprise Network (CEN) instance with which the GA instance is associated.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The timestamp that indicates when the GA instance is created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The type of cross-border acceleration. This parameter is returned for GA instances whose bandwidth metering method is pay-by-data-transfer (CDT).
	//
	// Only **bpgPro** may be returned, which indicates BGP (Multi-ISP) Pro lines.
	CrossBorderMode *string `json:"CrossBorderMode,omitempty" xml:"CrossBorderMode,omitempty"`
	// Indicates whether cross-border acceleration is enabled.
	// - **true**: yes
	// - **false**: no
	CrossBorderStatus *bool `json:"CrossBorderStatus,omitempty" xml:"CrossBorderStatus,omitempty"`
	// The details about the cross-border acceleration bandwidth plan that is associated with the GA instance.
	//
	// This array is returned only for GA instances that are created on the international site (alibabacloud.com).
	CrossDomainBandwidthPackage *DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage `json:"CrossDomainBandwidthPackage,omitempty" xml:"CrossDomainBandwidthPackage,omitempty" type:"Struct"`
	// Indicates whether cross-border acceleration is enabled.
	//
	// *   **true**: yes
	// *   **false**: no
	CrossPrivateState *string `json:"CrossPrivateState,omitempty" xml:"CrossPrivateState,omitempty"`
	// The ID of the Anti-DDoS Pro/Premium instance that is associated with the GA instance.
	DdosId *string `json:"DdosId,omitempty" xml:"DdosId,omitempty"`
	// The description of the GA instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The canonical name (CNAME) that is assigned to the GA instance.
	DnsName *string `json:"DnsName,omitempty" xml:"DnsName,omitempty"`
	// The timestamp that indicates when the GA instance expires.
	ExpiredTime *int64 `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The billing method of the GA instance.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The configurations of the acceleration area.
	IpSetConfig *DescribeAcceleratorResponseBodyIpSetConfig `json:"IpSetConfig,omitempty" xml:"IpSetConfig,omitempty" type:"Struct"`
	// The name of the GA instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID of the GA instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The CNAME that is used to integrate the GA instance with the Anti-DDoS service.
	SecondDnsName *string `json:"SecondDnsName,omitempty" xml:"SecondDnsName,omitempty"`
	// 托管实例所属的服务方ID。
	// > 仅在**ServiceManaged**参数为**True**时有效。
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// 是否为托管实例。取值：
	//
	// - **true**：是托管实例。
	//
	// - **false**：不是托管实例。
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// 用户在此托管实例下可执行的动作策略列表。
	// > 仅在**ServiceManaged**参数为**True**时有效。
	// > - 当实例处于托管状态时，用户对实例的操作会受到限制，某些操作行为会被禁止。
	ServiceManagedInfos []*DescribeAcceleratorResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The specification of the GA instance. Valid values:
	//
	// *   **1**: Small Ⅰ
	// *   **2**: Small Ⅱ
	// *   **3**: Small Ⅲ
	// *   **5**: Medium Ⅰ
	// *   **8**: Medium Ⅱ
	// *   **10**: Medium Ⅲ
	// *   **20**: Large Ⅰ
	// *   **30**: Large Ⅱ
	// *   **40**: Large Ⅲ
	// *   **50**: Large Ⅳ
	// *   **60**: Large Ⅴ
	// *   **70**: Large Ⅵ
	// *   **80**: Large VⅡ
	// *   **90**: Large VⅢ
	// *   **100**: Super Large Ⅰ
	// *   **200**: Super Large Ⅱ
	//
	// >  The Large Ⅲ specification and higher specifications are available only to users that are added to the whitelist. To use these specifications, contact your Alibaba Cloud account manager.
	//
	// Different specifications provide different capabilities. For more information, see [Instance specifications](~~153127~~).
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the GA instance. Valid values:
	//
	// *   **init**: The GA instance is being initialized.
	// *   **active**: The GA instance is available.
	// *   **configuring**: The GA instance is being configured.
	// *   **binding**: The GA instance is being associated.
	// *   **unbinding**: The GA instance is being disassociated.
	// *   **deleting**: The GA instance is being deleted.
	// *   **finacialLocked**: The GA instance is locked due to overdue payments.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags of the GA instance.
	Tags []*DescribeAcceleratorResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// Indicates whether the GA instance can be upgraded. Valid values:
	//
	// *   **notUpgradable:** The GA instance does not need to be upgraded.
	// *   **upgradable:** The GA instance can be upgraded to the latest version.
	// *   **upgradeFailed:** The GA instance failed to be upgraded.
	UpgradableStatus *string `json:"UpgradableStatus,omitempty" xml:"UpgradableStatus,omitempty"`
}

func (s DescribeAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorResponseBody) SetAcceleratorId(v string) *DescribeAcceleratorResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetBandwidthBillingType(v string) *DescribeAcceleratorResponseBody {
	s.BandwidthBillingType = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetBasicBandwidthPackage(v *DescribeAcceleratorResponseBodyBasicBandwidthPackage) *DescribeAcceleratorResponseBody {
	s.BasicBandwidthPackage = v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetCenId(v string) *DescribeAcceleratorResponseBody {
	s.CenId = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetCreateTime(v int64) *DescribeAcceleratorResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetCrossBorderMode(v string) *DescribeAcceleratorResponseBody {
	s.CrossBorderMode = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetCrossBorderStatus(v bool) *DescribeAcceleratorResponseBody {
	s.CrossBorderStatus = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetCrossDomainBandwidthPackage(v *DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage) *DescribeAcceleratorResponseBody {
	s.CrossDomainBandwidthPackage = v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetCrossPrivateState(v string) *DescribeAcceleratorResponseBody {
	s.CrossPrivateState = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetDdosId(v string) *DescribeAcceleratorResponseBody {
	s.DdosId = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetDescription(v string) *DescribeAcceleratorResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetDnsName(v string) *DescribeAcceleratorResponseBody {
	s.DnsName = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetExpiredTime(v int64) *DescribeAcceleratorResponseBody {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetInstanceChargeType(v string) *DescribeAcceleratorResponseBody {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetIpSetConfig(v *DescribeAcceleratorResponseBodyIpSetConfig) *DescribeAcceleratorResponseBody {
	s.IpSetConfig = v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetName(v string) *DescribeAcceleratorResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetRegionId(v string) *DescribeAcceleratorResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetRequestId(v string) *DescribeAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetResourceGroupId(v string) *DescribeAcceleratorResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetSecondDnsName(v string) *DescribeAcceleratorResponseBody {
	s.SecondDnsName = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetServiceId(v string) *DescribeAcceleratorResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetServiceManaged(v bool) *DescribeAcceleratorResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetServiceManagedInfos(v []*DescribeAcceleratorResponseBodyServiceManagedInfos) *DescribeAcceleratorResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetSpec(v string) *DescribeAcceleratorResponseBody {
	s.Spec = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetState(v string) *DescribeAcceleratorResponseBody {
	s.State = &v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetTags(v []*DescribeAcceleratorResponseBodyTags) *DescribeAcceleratorResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeAcceleratorResponseBody) SetUpgradableStatus(v string) *DescribeAcceleratorResponseBody {
	s.UpgradableStatus = &v
	return s
}

type DescribeAcceleratorResponseBodyBasicBandwidthPackage struct {
	// The bandwidth value of the basic bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The type of the bandwidth that is provided by the basic bandwidth plan. Valid values:
	//
	// *   **Basic**: basic
	// *   **Enhanced**: enhanced
	// *   **Advanced**: premium
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the basic bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DescribeAcceleratorResponseBodyBasicBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorResponseBodyBasicBandwidthPackage) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorResponseBodyBasicBandwidthPackage) SetBandwidth(v int32) *DescribeAcceleratorResponseBodyBasicBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *DescribeAcceleratorResponseBodyBasicBandwidthPackage) SetBandwidthType(v string) *DescribeAcceleratorResponseBodyBasicBandwidthPackage {
	s.BandwidthType = &v
	return s
}

func (s *DescribeAcceleratorResponseBodyBasicBandwidthPackage) SetInstanceId(v string) *DescribeAcceleratorResponseBodyBasicBandwidthPackage {
	s.InstanceId = &v
	return s
}

type DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage struct {
	// The bandwidth that is provided by the cross-border acceleration bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the cross-border acceleration bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage) SetBandwidth(v int32) *DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage) SetInstanceId(v string) *DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage {
	s.InstanceId = &v
	return s
}

type DescribeAcceleratorResponseBodyIpSetConfig struct {
	// The access mode of the acceleration area. Valid values:
	//
	// *   **UserDefine**: custom nearby access mode. You can select acceleration areas and regions based on your business requirements. GA allocates a separate elastic IP address (EIP) to each acceleration region.
	// *   **Anycast**: automatic nearby access mode. You do not need to specify an acceleration area. GA allocates an Anycast EIP to multiple regions across the globe. Users can connect to the nearest access point of the Alibaba Cloud global transmission network by sending requests to the Anycast EIP.
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
}

func (s DescribeAcceleratorResponseBodyIpSetConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorResponseBodyIpSetConfig) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorResponseBodyIpSetConfig) SetAccessMode(v string) *DescribeAcceleratorResponseBodyIpSetConfig {
	s.AccessMode = &v
	return s
}

type DescribeAcceleratorResponseBodyServiceManagedInfos struct {
	// 托管策略动作名称，取值：
	// - **Create**：创建实例。
	// - **Update**：更新当前实例。
	// - **Delete**：删除当前实例。
	// - **Associate**：引用/被引用当前实例。
	// - **UserUnmanaged**：用户解托管实例。
	// - **CreateChild**：在当前实例下创建子资源。
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// 子资源类型，取值：
	//
	// - **Listener**：监听资源。
	//
	// - **IpSet**：加速地域资源。
	//
	// - **EndpointGroup**：终端节点组资源。
	//
	// - **ForwardingRule**：转发策略资源。
	//
	// - **Endpoint**：终端节点资源。
	//
	// - **EndpointGroupDestination**：自定义路由监听下的终端节点组协议映射资源。
	//
	// - **EndpointPolicy**：自定义路由监听下的终端节点通行策略资源。
	//
	// > 仅在**Action**参数为**CreateChild**时有效。
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// 托管策略动作是否被托管，取值：
	//
	// - **true**：托管策略动作被托管，用户无权在托管实例下执行Action指定的操作。
	//
	// - **false**：托管策略动作未被托管，用户可在托管实例下执行Action指定的操作。
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeAcceleratorResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorResponseBodyServiceManagedInfos) SetAction(v string) *DescribeAcceleratorResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeAcceleratorResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeAcceleratorResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeAcceleratorResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeAcceleratorResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeAcceleratorResponseBodyTags struct {
	// The key of tag N that is added to the GA instance.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N that is added to the GA instance.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeAcceleratorResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorResponseBodyTags) SetKey(v string) *DescribeAcceleratorResponseBodyTags {
	s.Key = &v
	return s
}

func (s *DescribeAcceleratorResponseBodyTags) SetValue(v string) *DescribeAcceleratorResponseBodyTags {
	s.Value = &v
	return s
}

type DescribeAcceleratorResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorResponse) SetHeaders(v map[string]*string) *DescribeAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *DescribeAcceleratorResponse) SetStatusCode(v int32) *DescribeAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAcceleratorResponse) SetBody(v *DescribeAcceleratorResponseBody) *DescribeAcceleratorResponse {
	s.Body = v
	return s
}

type DescribeAcceleratorAutoRenewAttributeRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeAcceleratorAutoRenewAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorAutoRenewAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorAutoRenewAttributeRequest) SetAcceleratorId(v string) *DescribeAcceleratorAutoRenewAttributeRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeAcceleratorAutoRenewAttributeRequest) SetRegionId(v string) *DescribeAcceleratorAutoRenewAttributeRequest {
	s.RegionId = &v
	return s
}

type DescribeAcceleratorAutoRenewAttributeResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// Indicates whether auto-renewal is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false** (default): disabled
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal duration. Unit: months.
	//
	// This parameter is returned only if **AutoRenew** is set to **true**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// Indicates how the GA instance is renewed. Valid values:
	//
	// *   **AutoRenewal**: The GA instance is automatically renewed.
	// *   **Normal**: You must manually renew the GA instance.
	// *   **NotRenewal**: The GA instance is not renewed after it expires. The system sends only a non-renewal reminder three days before the expiration date. The system no longer sends notifications to remind you to renew the GA instance.
	RenewalStatus *string `json:"RenewalStatus,omitempty" xml:"RenewalStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAcceleratorAutoRenewAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorAutoRenewAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorAutoRenewAttributeResponseBody) SetAcceleratorId(v string) *DescribeAcceleratorAutoRenewAttributeResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeAcceleratorAutoRenewAttributeResponseBody) SetAutoRenew(v bool) *DescribeAcceleratorAutoRenewAttributeResponseBody {
	s.AutoRenew = &v
	return s
}

func (s *DescribeAcceleratorAutoRenewAttributeResponseBody) SetAutoRenewDuration(v int32) *DescribeAcceleratorAutoRenewAttributeResponseBody {
	s.AutoRenewDuration = &v
	return s
}

func (s *DescribeAcceleratorAutoRenewAttributeResponseBody) SetRenewalStatus(v string) *DescribeAcceleratorAutoRenewAttributeResponseBody {
	s.RenewalStatus = &v
	return s
}

func (s *DescribeAcceleratorAutoRenewAttributeResponseBody) SetRequestId(v string) *DescribeAcceleratorAutoRenewAttributeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAcceleratorAutoRenewAttributeResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAcceleratorAutoRenewAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAcceleratorAutoRenewAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorAutoRenewAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorAutoRenewAttributeResponse) SetHeaders(v map[string]*string) *DescribeAcceleratorAutoRenewAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeAcceleratorAutoRenewAttributeResponse) SetStatusCode(v int32) *DescribeAcceleratorAutoRenewAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAcceleratorAutoRenewAttributeResponse) SetBody(v *DescribeAcceleratorAutoRenewAttributeResponseBody) *DescribeAcceleratorAutoRenewAttributeResponse {
	s.Body = v
	return s
}

type DescribeAcceleratorServiceStatusRequest struct {
	// The region ID of the GA instance. Set the value to cn-hangzhou.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeAcceleratorServiceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorServiceStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorServiceStatusRequest) SetRegionId(v string) *DescribeAcceleratorServiceStatusRequest {
	s.RegionId = &v
	return s
}

type DescribeAcceleratorServiceStatusResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the GA instance.
	//
	// Valid values:
	//
	// *   Released
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The instance was released due to overdue payments
	//
	//     <!-- -->
	//
	//     .
	//
	// *   Expired
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The instance expired due to overdue payments
	//
	//     <!-- -->
	//
	//     .
	//
	// *   NotOpened
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The instance is not activated
	//
	//     <!-- -->
	//
	//     .
	//
	// *   Normal
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The instance is activated
	//
	//     <!-- -->
	//
	//     .
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether the request was successful. Valid values: true false
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeAcceleratorServiceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorServiceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorServiceStatusResponseBody) SetCode(v string) *DescribeAcceleratorServiceStatusResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeAcceleratorServiceStatusResponseBody) SetMessage(v string) *DescribeAcceleratorServiceStatusResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeAcceleratorServiceStatusResponseBody) SetRequestId(v string) *DescribeAcceleratorServiceStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAcceleratorServiceStatusResponseBody) SetStatus(v string) *DescribeAcceleratorServiceStatusResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeAcceleratorServiceStatusResponseBody) SetSuccess(v string) *DescribeAcceleratorServiceStatusResponseBody {
	s.Success = &v
	return s
}

type DescribeAcceleratorServiceStatusResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAcceleratorServiceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAcceleratorServiceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAcceleratorServiceStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeAcceleratorServiceStatusResponse) SetHeaders(v map[string]*string) *DescribeAcceleratorServiceStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeAcceleratorServiceStatusResponse) SetStatusCode(v int32) *DescribeAcceleratorServiceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAcceleratorServiceStatusResponse) SetBody(v *DescribeAcceleratorServiceStatusResponseBody) *DescribeAcceleratorServiceStatusResponse {
	s.Body = v
	return s
}

type DescribeApplicationMonitorRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the origin probing task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *DescribeApplicationMonitorRequest) SetClientToken(v string) *DescribeApplicationMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeApplicationMonitorRequest) SetRegionId(v string) *DescribeApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeApplicationMonitorRequest) SetTaskId(v string) *DescribeApplicationMonitorRequest {
	s.TaskId = &v
	return s
}

type DescribeApplicationMonitorResponseBody struct {
	// The ID of the GA instance on which the origin probing task ran.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The URL or IP address that was probed.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// Indicates whether the automatic diagnostics feature is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	DetectEnable *bool `json:"DetectEnable,omitempty" xml:"DetectEnable,omitempty"`
	// The threshold that is used to trigger automatic diagnostics.
	//
	// If the availability of the origin server drops below the specified threshold, the automatic diagnostics feature is triggered.
	DetectThreshold *int32 `json:"DetectThreshold,omitempty" xml:"DetectThreshold,omitempty"`
	// The number of times that are required to reach the threshold before the automatic diagnostics feature is triggered.
	DetectTimes *int32 `json:"DetectTimes,omitempty" xml:"DetectTimes,omitempty"`
	// The probe points of the Internet service provider (ISP).
	IspCityList []*DescribeApplicationMonitorResponseBodyIspCityList `json:"IspCityList,omitempty" xml:"IspCityList,omitempty" type:"Repeated"`
	// The ID of the listener on which the origin probing task ran.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The extended options of the listener protocol that is used by the origin probing task. The options vary based on the listener protocol.
	OptionsJson *string `json:"OptionsJson,omitempty" xml:"OptionsJson,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The silence period of the automatic diagnostics feature. This parameter indicates the interval at which the automatic diagnostics feature is triggered. If the availability rate does not return to normal after GA triggers automatic diagnostics, GA must wait until the silence period ends before GA can trigger another automatic diagnostic.
	//
	// If the number of consecutive times that the availability rate drops below the automatic diagnostics threshold reaches the value of **DetectTimes**, the automatic diagnostics feature is triggered. The automatic diagnostics feature is not triggered again within the silence period regardless of whether the availability rate remains below the threshold. If the availability rate does not return to normal after the silence period ends, the automatic diagnostics feature is triggered again.
	//
	// Unit: seconds.
	SilenceTime *int32 `json:"SilenceTime,omitempty" xml:"SilenceTime,omitempty"`
	// The ID of the origin probing task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the origin probing task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s DescribeApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeApplicationMonitorResponseBody) SetAcceleratorId(v string) *DescribeApplicationMonitorResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetAddress(v string) *DescribeApplicationMonitorResponseBody {
	s.Address = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetDetectEnable(v bool) *DescribeApplicationMonitorResponseBody {
	s.DetectEnable = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetDetectThreshold(v int32) *DescribeApplicationMonitorResponseBody {
	s.DetectThreshold = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetDetectTimes(v int32) *DescribeApplicationMonitorResponseBody {
	s.DetectTimes = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetIspCityList(v []*DescribeApplicationMonitorResponseBodyIspCityList) *DescribeApplicationMonitorResponseBody {
	s.IspCityList = v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetListenerId(v string) *DescribeApplicationMonitorResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetOptionsJson(v string) *DescribeApplicationMonitorResponseBody {
	s.OptionsJson = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetRegionId(v string) *DescribeApplicationMonitorResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetRequestId(v string) *DescribeApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetSilenceTime(v int32) *DescribeApplicationMonitorResponseBody {
	s.SilenceTime = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetTaskId(v string) *DescribeApplicationMonitorResponseBody {
	s.TaskId = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBody) SetTaskName(v string) *DescribeApplicationMonitorResponseBody {
	s.TaskName = &v
	return s
}

type DescribeApplicationMonitorResponseBodyIspCityList struct {
	// The ID of the city where the probe point of the ISP is deployed.
	City *string `json:"City,omitempty" xml:"City,omitempty"`
	// The name of the city where the probe point of the ISP is deployed.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// The probe point ID of the ISP.
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The probe point name of the ISP.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
}

func (s DescribeApplicationMonitorResponseBodyIspCityList) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationMonitorResponseBodyIspCityList) GoString() string {
	return s.String()
}

func (s *DescribeApplicationMonitorResponseBodyIspCityList) SetCity(v string) *DescribeApplicationMonitorResponseBodyIspCityList {
	s.City = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBodyIspCityList) SetCityName(v string) *DescribeApplicationMonitorResponseBodyIspCityList {
	s.CityName = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBodyIspCityList) SetIsp(v string) *DescribeApplicationMonitorResponseBodyIspCityList {
	s.Isp = &v
	return s
}

func (s *DescribeApplicationMonitorResponseBodyIspCityList) SetIspName(v string) *DescribeApplicationMonitorResponseBodyIspCityList {
	s.IspName = &v
	return s
}

type DescribeApplicationMonitorResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *DescribeApplicationMonitorResponse) SetHeaders(v map[string]*string) *DescribeApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *DescribeApplicationMonitorResponse) SetStatusCode(v int32) *DescribeApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeApplicationMonitorResponse) SetBody(v *DescribeApplicationMonitorResponseBody) *DescribeApplicationMonitorResponse {
	s.Body = v
	return s
}

type DescribeBandwidthPackageRequest struct {
	// The ID of the bandwidth plan that you want to query.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *DescribeBandwidthPackageRequest) SetBandwidthPackageId(v string) *DescribeBandwidthPackageRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *DescribeBandwidthPackageRequest) SetRegionId(v string) *DescribeBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

type DescribeBandwidthPackageResponseBody struct {
	// The ID of the GA instance that is associated with the bandwidth plan.
	Accelerators []*string `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The bandwidth value of the bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The type of the bandwidth. Valid values:
	//
	// *   **Basic**: basic bandwidth
	// *   **Enhanced**: enhanced bandwidth
	// *   **Advanced**: premium bandwidth
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The metering method that is used when you use the pay-as-you-go billing method. Valid values:
	//
	// *   **PayByTraffic**: pay-by-data-transfer
	// *   **PayBY95**: pay-by-95th-percentile
	BillingType *string `json:"BillingType,omitempty" xml:"BillingType,omitempty"`
	// Area A specified in the cross-region acceleration bandwidth plan. Only **China-mainland** (the Chinese mainland) is returned.
	//
	// This parameter is returned only if you call this operation on the International site (alibabacloud.com).
	CbnGeographicRegionIdA *string `json:"CbnGeographicRegionIdA,omitempty" xml:"CbnGeographicRegionIdA,omitempty"`
	// Area B specified in the cross-region acceleration bandwidth plan. Only **Global** (global) is returned.
	//
	// This parameter is returned only if you call this operation on the International site (alibabacloud.com).
	CbnGeographicRegionIdB *string `json:"CbnGeographicRegionIdB,omitempty" xml:"CbnGeographicRegionIdB,omitempty"`
	// The billing method of the bandwidth plan. Only **PREPAY** is returned, which indicates the subscription billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The timestamp that indicates when the bandwidth plan was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the bandwidth plan.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timestamp that indicates when the bandwidth plan expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The name of the bandwidth plan.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The percentage of the minimum bandwidth guaranteed if the pay-by-95th-percentile-bandwidth metering method is used. Valid values: **30** to **100**.
	Ratio *int32 `json:"Ratio,omitempty" xml:"Ratio,omitempty"`
	// The ID of the region where GA instance is deployed. **cn-hangzhou** is returned.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The state of the bandwidth plan. Valid values:
	//
	// *   **init**: The bandwidth plan is being initialized.
	// *   **active**: The bandwidth plan is available.
	// *   **binded**: The bandwidth plan is associated with a GA instance.
	// *   **binding**: The bandwidth plan is being associated.
	// *   **unbinding**: The bandwidth plan is being disassociated.
	// *   **updating**: The bandwidth plan is being updated.
	// *   **finacialLocked**: The bandwidth plan is locked due to overdue payments.
	// *   **Locked**: The bandwidth plan is locked.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// Tag objects.
	Tags []*DescribeBandwidthPackageResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of the bandwidth plan. Valid values:
	//
	// *   **Basic**: a basic bandwidth plan
	// *   **CrossDomain**: a cross-region acceleration bandwidth plan
	//
	// If you call this operation on the Alibaba Cloud China Site (aliyun.com), only **Basic** is returned.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBandwidthPackageResponseBody) SetAccelerators(v []*string) *DescribeBandwidthPackageResponseBody {
	s.Accelerators = v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetBandwidth(v int32) *DescribeBandwidthPackageResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetBandwidthPackageId(v string) *DescribeBandwidthPackageResponseBody {
	s.BandwidthPackageId = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetBandwidthType(v string) *DescribeBandwidthPackageResponseBody {
	s.BandwidthType = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetBillingType(v string) *DescribeBandwidthPackageResponseBody {
	s.BillingType = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetCbnGeographicRegionIdA(v string) *DescribeBandwidthPackageResponseBody {
	s.CbnGeographicRegionIdA = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetCbnGeographicRegionIdB(v string) *DescribeBandwidthPackageResponseBody {
	s.CbnGeographicRegionIdB = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetChargeType(v string) *DescribeBandwidthPackageResponseBody {
	s.ChargeType = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetCreateTime(v string) *DescribeBandwidthPackageResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetDescription(v string) *DescribeBandwidthPackageResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetExpiredTime(v string) *DescribeBandwidthPackageResponseBody {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetName(v string) *DescribeBandwidthPackageResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetRatio(v int32) *DescribeBandwidthPackageResponseBody {
	s.Ratio = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetRegionId(v string) *DescribeBandwidthPackageResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetRequestId(v string) *DescribeBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetResourceGroupId(v string) *DescribeBandwidthPackageResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetState(v string) *DescribeBandwidthPackageResponseBody {
	s.State = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetTags(v []*DescribeBandwidthPackageResponseBodyTags) *DescribeBandwidthPackageResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeBandwidthPackageResponseBody) SetType(v string) *DescribeBandwidthPackageResponseBody {
	s.Type = &v
	return s
}

type DescribeBandwidthPackageResponseBodyTags struct {
	// The tag key
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeBandwidthPackageResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeBandwidthPackageResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeBandwidthPackageResponseBodyTags) SetKey(v string) *DescribeBandwidthPackageResponseBodyTags {
	s.Key = &v
	return s
}

func (s *DescribeBandwidthPackageResponseBodyTags) SetValue(v string) *DescribeBandwidthPackageResponseBodyTags {
	s.Value = &v
	return s
}

type DescribeBandwidthPackageResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *DescribeBandwidthPackageResponse) SetHeaders(v map[string]*string) *DescribeBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *DescribeBandwidthPackageResponse) SetStatusCode(v int32) *DescribeBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBandwidthPackageResponse) SetBody(v *DescribeBandwidthPackageResponseBody) *DescribeBandwidthPackageResponse {
	s.Body = v
	return s
}

type DescribeBandwidthPackageAutoRenewAttributeRequest struct {
	// The ID of the bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to cn-hangzhou.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeBandwidthPackageAutoRenewAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBandwidthPackageAutoRenewAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeBandwidthPackageAutoRenewAttributeRequest) SetInstanceId(v string) *DescribeBandwidthPackageAutoRenewAttributeRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeBandwidthPackageAutoRenewAttributeRequest) SetRegionId(v string) *DescribeBandwidthPackageAutoRenewAttributeRequest {
	s.RegionId = &v
	return s
}

type DescribeBandwidthPackageAutoRenewAttributeResponseBody struct {
	// Indicates whether auto-renewal is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false** (default): disabled
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal period. Unit: months. Valid values: **1** to **12**.
	//
	// > : This parameter takes effect only if **AutoRenew** is set to **true**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// The ID of the bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The auto-renewal status of the bandwidth plan. Valid values:
	//
	// *   **AutoRenewal**: The bandwidth plan is automatically renewed.
	// *   **Normal**: You must manually renew the bandwidth plan.
	// *   **NotRenewal**: Choose this option if you do not want to renew the bandwidth plan after it expires. The system sends only a non-renewal reminder three days before the expiration date. The system no longer sends notifications to remind you to renew the bandwidth plan. You can change the value of this parameter from NotRenewal to Normal for a bandwidth plan, and then manually renew the bandwidth plan. You can also set the RenewalStatus parameter to **AutoRenewal**.
	//
	// > The **RenewalStatus** parameter takes precedence over the **AutoRenew** parameter. If you do not set **RenewalStatus**, the **AutoRenew** parameter is used by default.
	RenewalStatus *string `json:"RenewalStatus,omitempty" xml:"RenewalStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBandwidthPackageAutoRenewAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBandwidthPackageAutoRenewAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponseBody) SetAutoRenew(v bool) *DescribeBandwidthPackageAutoRenewAttributeResponseBody {
	s.AutoRenew = &v
	return s
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponseBody) SetAutoRenewDuration(v int32) *DescribeBandwidthPackageAutoRenewAttributeResponseBody {
	s.AutoRenewDuration = &v
	return s
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponseBody) SetInstanceId(v string) *DescribeBandwidthPackageAutoRenewAttributeResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponseBody) SetRenewalStatus(v string) *DescribeBandwidthPackageAutoRenewAttributeResponseBody {
	s.RenewalStatus = &v
	return s
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponseBody) SetRequestId(v string) *DescribeBandwidthPackageAutoRenewAttributeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeBandwidthPackageAutoRenewAttributeResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBandwidthPackageAutoRenewAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBandwidthPackageAutoRenewAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBandwidthPackageAutoRenewAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponse) SetHeaders(v map[string]*string) *DescribeBandwidthPackageAutoRenewAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponse) SetStatusCode(v int32) *DescribeBandwidthPackageAutoRenewAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBandwidthPackageAutoRenewAttributeResponse) SetBody(v *DescribeBandwidthPackageAutoRenewAttributeResponseBody) *DescribeBandwidthPackageAutoRenewAttributeResponse {
	s.Body = v
	return s
}

type DescribeCommodityRequest struct {
	// The commodity code.
	//
	// Examples for the China site (aliyun.com):
	//
	// *   **ga_gapluspre_public_cn**: GA instance.
	// *   **ga_plusbwppre_public_cn**: basic bandwidth plan.
	//
	// Examples for the international site (alibabacloud.com):
	//
	// *   **ga_pluspre_public_intl**: GA instance.
	// *   **ga_bwppreintl_public_intl**: basic bandwidth plan.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The type of the order. Valid values:
	//
	// *   **BUY**: purchase
	// *   **RENEW**: renewal
	// *   **UPGRADE**: upgrade
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCommodityRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityRequest) GoString() string {
	return s.String()
}

func (s *DescribeCommodityRequest) SetCommodityCode(v string) *DescribeCommodityRequest {
	s.CommodityCode = &v
	return s
}

func (s *DescribeCommodityRequest) SetOrderType(v string) *DescribeCommodityRequest {
	s.OrderType = &v
	return s
}

func (s *DescribeCommodityRequest) SetRegionId(v string) *DescribeCommodityRequest {
	s.RegionId = &v
	return s
}

type DescribeCommodityResponseBody struct {
	// The commodity code.
	//
	// Examples for the China site (aliyun.com):
	//
	// *   **ga_gapluspre_public_cn**: GA instance.
	// *   **ga_plusbwppre_public_cn**: basic bandwidth plan.
	//
	// Examples for the international site (alibabacloud.com):
	//
	// *   **ga_pluspre_public_intl**: GA instance.
	// *   **ga_bwppreintl_public_intl**: basic bandwidth plan.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The name of the commodity.
	CommodityName *string `json:"CommodityName,omitempty" xml:"CommodityName,omitempty"`
	// The information about the commodity modules.
	//
	// The returned information varies based on the commodity.
	Components []*DescribeCommodityResponseBodyComponents `json:"Components,omitempty" xml:"Components,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCommodityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCommodityResponseBody) SetCommodityCode(v string) *DescribeCommodityResponseBody {
	s.CommodityCode = &v
	return s
}

func (s *DescribeCommodityResponseBody) SetCommodityName(v string) *DescribeCommodityResponseBody {
	s.CommodityName = &v
	return s
}

func (s *DescribeCommodityResponseBody) SetComponents(v []*DescribeCommodityResponseBodyComponents) *DescribeCommodityResponseBody {
	s.Components = v
	return s
}

func (s *DescribeCommodityResponseBody) SetRequestId(v string) *DescribeCommodityResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCommodityResponseBodyComponents struct {
	// The code of the commodity module.
	//
	// The returned information varies based on the commodity module.
	ComponentCode *string `json:"ComponentCode,omitempty" xml:"ComponentCode,omitempty"`
	// The name of the commodity module.
	//
	// The returned information varies based on the commodity module.
	ComponentName *string `json:"ComponentName,omitempty" xml:"ComponentName,omitempty"`
	// The attributes of the commodity module.
	//
	// The returned information varies based on the commodity module.
	Properties []*DescribeCommodityResponseBodyComponentsProperties `json:"Properties,omitempty" xml:"Properties,omitempty" type:"Repeated"`
}

func (s DescribeCommodityResponseBodyComponents) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityResponseBodyComponents) GoString() string {
	return s.String()
}

func (s *DescribeCommodityResponseBodyComponents) SetComponentCode(v string) *DescribeCommodityResponseBodyComponents {
	s.ComponentCode = &v
	return s
}

func (s *DescribeCommodityResponseBodyComponents) SetComponentName(v string) *DescribeCommodityResponseBodyComponents {
	s.ComponentName = &v
	return s
}

func (s *DescribeCommodityResponseBodyComponents) SetProperties(v []*DescribeCommodityResponseBodyComponentsProperties) *DescribeCommodityResponseBodyComponents {
	s.Properties = v
	return s
}

type DescribeCommodityResponseBodyComponentsProperties struct {
	// The code of the attribute.
	//
	// The returned information varies based on the commodity module.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The name of the attribute.
	//
	// The returned information varies based on the commodity module.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The list of attribute values of the commodity module.
	//
	// The returned information varies based on the commodity module.
	PropertyValueList []*DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList `json:"PropertyValueList,omitempty" xml:"PropertyValueList,omitempty" type:"Repeated"`
}

func (s DescribeCommodityResponseBodyComponentsProperties) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityResponseBodyComponentsProperties) GoString() string {
	return s.String()
}

func (s *DescribeCommodityResponseBodyComponentsProperties) SetCode(v string) *DescribeCommodityResponseBodyComponentsProperties {
	s.Code = &v
	return s
}

func (s *DescribeCommodityResponseBodyComponentsProperties) SetName(v string) *DescribeCommodityResponseBodyComponentsProperties {
	s.Name = &v
	return s
}

func (s *DescribeCommodityResponseBodyComponentsProperties) SetPropertyValueList(v []*DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList) *DescribeCommodityResponseBodyComponentsProperties {
	s.PropertyValueList = v
	return s
}

type DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList struct {
	// The sequence number of the attribute.
	//
	// The returned information varies based on the commodity module.
	OrderIndex *int64 `json:"OrderIndex,omitempty" xml:"OrderIndex,omitempty"`
	// The content of the attribute.
	//
	// The returned information varies based on the commodity module.
	Text *string `json:"Text,omitempty" xml:"Text,omitempty"`
	// The message of the attribute.
	//
	// The returned information varies based on the commodity module.
	Tips *string `json:"Tips,omitempty" xml:"Tips,omitempty"`
	// The value of the attribute.
	//
	// The returned information varies based on the commodity module.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList) GoString() string {
	return s.String()
}

func (s *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList) SetOrderIndex(v int64) *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList {
	s.OrderIndex = &v
	return s
}

func (s *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList) SetText(v string) *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList {
	s.Text = &v
	return s
}

func (s *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList) SetTips(v string) *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList {
	s.Tips = &v
	return s
}

func (s *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList) SetValue(v string) *DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList {
	s.Value = &v
	return s
}

type DescribeCommodityResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCommodityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCommodityResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityResponse) GoString() string {
	return s.String()
}

func (s *DescribeCommodityResponse) SetHeaders(v map[string]*string) *DescribeCommodityResponse {
	s.Headers = v
	return s
}

func (s *DescribeCommodityResponse) SetStatusCode(v int32) *DescribeCommodityResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCommodityResponse) SetBody(v *DescribeCommodityResponseBody) *DescribeCommodityResponse {
	s.Body = v
	return s
}

type DescribeCommodityPriceRequest struct {
	// The commodity orders.
	Orders []*DescribeCommodityPriceRequestOrders `json:"Orders,omitempty" xml:"Orders,omitempty" type:"Repeated"`
	// The coupon code.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	PromotionOptionNo *string `json:"PromotionOptionNo,omitempty" xml:"PromotionOptionNo,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCommodityPriceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceRequest) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceRequest) SetOrders(v []*DescribeCommodityPriceRequestOrders) *DescribeCommodityPriceRequest {
	s.Orders = v
	return s
}

func (s *DescribeCommodityPriceRequest) SetPromotionOptionNo(v string) *DescribeCommodityPriceRequest {
	s.PromotionOptionNo = &v
	return s
}

func (s *DescribeCommodityPriceRequest) SetRegionId(v string) *DescribeCommodityPriceRequest {
	s.RegionId = &v
	return s
}

type DescribeCommodityPriceRequestOrders struct {
	// The billing method. Set the value to **PREPAY**, which specifies the subscription billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The commodity code.
	//
	// Examples for the China site (aliyun.com):
	//
	// *   **ga_gapluspre_public_cn**: GA instance.
	// *   **ga_plusbwppre_public_cn**: basic bandwidth plan.
	//
	// Examples for the international site (alibabacloud.com):
	//
	// *   **ga_pluspre_public_intl**: GA instance.
	// *   **ga_bwppreintl_public_intl**: basic bandwidth plan.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The information about the commodity module.
	//
	// The information varies based on the commodity module.
	Components []*DescribeCommodityPriceRequestOrdersComponents `json:"Components,omitempty" xml:"Components,omitempty" type:"Repeated"`
	// The subscription duration of the instance.
	//
	// *   If the **PricingCycle** parameter is set to **Month**, the valid values of the Duration parameter are **1** to **9**.
	// *   If the **PricingCycle** parameter is set to **Year**, the valid values of the Duration parameter are **1** to **3**.
	Duration *int64 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The type of order. Valid values:
	//
	// *   **BUY**: purchase order
	// *   **RENEW**: renewal order
	// *   **UPGRADE**: upgrade order
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The billing cycle of the GA instance. Valid values:
	//
	// *   **Month**: billed on a monthly basis.
	// *   **Year**: billed on an annual basis.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The number of instances that you want to purchase.
	Quantity *int64 `json:"Quantity,omitempty" xml:"Quantity,omitempty"`
}

func (s DescribeCommodityPriceRequestOrders) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceRequestOrders) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceRequestOrders) SetChargeType(v string) *DescribeCommodityPriceRequestOrders {
	s.ChargeType = &v
	return s
}

func (s *DescribeCommodityPriceRequestOrders) SetCommodityCode(v string) *DescribeCommodityPriceRequestOrders {
	s.CommodityCode = &v
	return s
}

func (s *DescribeCommodityPriceRequestOrders) SetComponents(v []*DescribeCommodityPriceRequestOrdersComponents) *DescribeCommodityPriceRequestOrders {
	s.Components = v
	return s
}

func (s *DescribeCommodityPriceRequestOrders) SetDuration(v int64) *DescribeCommodityPriceRequestOrders {
	s.Duration = &v
	return s
}

func (s *DescribeCommodityPriceRequestOrders) SetOrderType(v string) *DescribeCommodityPriceRequestOrders {
	s.OrderType = &v
	return s
}

func (s *DescribeCommodityPriceRequestOrders) SetPricingCycle(v string) *DescribeCommodityPriceRequestOrders {
	s.PricingCycle = &v
	return s
}

func (s *DescribeCommodityPriceRequestOrders) SetQuantity(v int64) *DescribeCommodityPriceRequestOrders {
	s.Quantity = &v
	return s
}

type DescribeCommodityPriceRequestOrdersComponents struct {
	// The code of the commodity module.
	//
	// The information varies based on the commodity module. Examples: **instance** (GA instance) and **ord_time** (subscription duration).
	ComponentCode *string `json:"ComponentCode,omitempty" xml:"ComponentCode,omitempty"`
	// The attributes of the commodity module.
	//
	// The information varies based on the commodity module.
	Properties []*DescribeCommodityPriceRequestOrdersComponentsProperties `json:"Properties,omitempty" xml:"Properties,omitempty" type:"Repeated"`
}

func (s DescribeCommodityPriceRequestOrdersComponents) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceRequestOrdersComponents) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceRequestOrdersComponents) SetComponentCode(v string) *DescribeCommodityPriceRequestOrdersComponents {
	s.ComponentCode = &v
	return s
}

func (s *DescribeCommodityPriceRequestOrdersComponents) SetProperties(v []*DescribeCommodityPriceRequestOrdersComponentsProperties) *DescribeCommodityPriceRequestOrdersComponents {
	s.Properties = v
	return s
}

type DescribeCommodityPriceRequestOrdersComponentsProperties struct {
	// The code of the attribute.
	//
	// The information varies based on the commodity module. Examples: **instance** (GA instance) and **ord_time** (subscription duration).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The value of the attribute.
	//
	// The information varies based on the commodity module. Examples: **1:Month** (one-month subscription) and **instance_fee** (GA instance fee).
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCommodityPriceRequestOrdersComponentsProperties) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceRequestOrdersComponentsProperties) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceRequestOrdersComponentsProperties) SetCode(v string) *DescribeCommodityPriceRequestOrdersComponentsProperties {
	s.Code = &v
	return s
}

func (s *DescribeCommodityPriceRequestOrdersComponentsProperties) SetValue(v string) *DescribeCommodityPriceRequestOrdersComponentsProperties {
	s.Value = &v
	return s
}

type DescribeCommodityPriceResponseBody struct {
	// The currency unit.
	//
	// *   China site: **CNY**.
	// *   International site: **USD**.
	Currency *string `json:"Currency,omitempty" xml:"Currency,omitempty"`
	// The discount.
	DiscountPrice *float64 `json:"DiscountPrice,omitempty" xml:"DiscountPrice,omitempty"`
	// The details of the commodity module.
	OrderDetails []*DescribeCommodityPriceResponseBodyOrderDetails `json:"OrderDetails,omitempty" xml:"OrderDetails,omitempty" type:"Repeated"`
	// The original price.
	OriginalPrice *float64 `json:"OriginalPrice,omitempty" xml:"OriginalPrice,omitempty"`
	// The list of coupons.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	Promotions []*DescribeCommodityPriceResponseBodyPromotions `json:"Promotions,omitempty" xml:"Promotions,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details about the discount rules.
	RuleDetails []*DescribeCommodityPriceResponseBodyRuleDetails `json:"RuleDetails,omitempty" xml:"RuleDetails,omitempty" type:"Repeated"`
	// The transaction price, which is equal to the original price minus the discount.
	TradePrice *float64 `json:"TradePrice,omitempty" xml:"TradePrice,omitempty"`
}

func (s DescribeCommodityPriceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceResponseBody) SetCurrency(v string) *DescribeCommodityPriceResponseBody {
	s.Currency = &v
	return s
}

func (s *DescribeCommodityPriceResponseBody) SetDiscountPrice(v float64) *DescribeCommodityPriceResponseBody {
	s.DiscountPrice = &v
	return s
}

func (s *DescribeCommodityPriceResponseBody) SetOrderDetails(v []*DescribeCommodityPriceResponseBodyOrderDetails) *DescribeCommodityPriceResponseBody {
	s.OrderDetails = v
	return s
}

func (s *DescribeCommodityPriceResponseBody) SetOriginalPrice(v float64) *DescribeCommodityPriceResponseBody {
	s.OriginalPrice = &v
	return s
}

func (s *DescribeCommodityPriceResponseBody) SetPromotions(v []*DescribeCommodityPriceResponseBodyPromotions) *DescribeCommodityPriceResponseBody {
	s.Promotions = v
	return s
}

func (s *DescribeCommodityPriceResponseBody) SetRequestId(v string) *DescribeCommodityPriceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCommodityPriceResponseBody) SetRuleDetails(v []*DescribeCommodityPriceResponseBodyRuleDetails) *DescribeCommodityPriceResponseBody {
	s.RuleDetails = v
	return s
}

func (s *DescribeCommodityPriceResponseBody) SetTradePrice(v float64) *DescribeCommodityPriceResponseBody {
	s.TradePrice = &v
	return s
}

type DescribeCommodityPriceResponseBodyOrderDetails struct {
	// The code of the commodity.
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The name of the commodity.
	CommodityName *string `json:"CommodityName,omitempty" xml:"CommodityName,omitempty"`
	// The discount.
	DiscountPrice *float64 `json:"DiscountPrice,omitempty" xml:"DiscountPrice,omitempty"`
	// The information about the commodity module.
	ModuleDetails []*DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails `json:"ModuleDetails,omitempty" xml:"ModuleDetails,omitempty" type:"Repeated"`
	// The original price.
	OriginalPrice *float64 `json:"OriginalPrice,omitempty" xml:"OriginalPrice,omitempty"`
	// The details about the discount.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	PromDetails []*DescribeCommodityPriceResponseBodyOrderDetailsPromDetails `json:"PromDetails,omitempty" xml:"PromDetails,omitempty" type:"Repeated"`
	// The number of instances that are purchased.
	Quantity *int64 `json:"Quantity,omitempty" xml:"Quantity,omitempty"`
	// The IDs of the discount rules.
	RuleIds []*int64 `json:"RuleIds,omitempty" xml:"RuleIds,omitempty" type:"Repeated"`
	// The transaction price, which is equal to the original price minus the discount.
	TradePrice *float64 `json:"TradePrice,omitempty" xml:"TradePrice,omitempty"`
}

func (s DescribeCommodityPriceResponseBodyOrderDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceResponseBodyOrderDetails) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetCommodityCode(v string) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.CommodityCode = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetCommodityName(v string) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.CommodityName = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetDiscountPrice(v float64) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.DiscountPrice = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetModuleDetails(v []*DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.ModuleDetails = v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetOriginalPrice(v float64) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.OriginalPrice = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetPromDetails(v []*DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.PromDetails = v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetQuantity(v int64) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.Quantity = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetRuleIds(v []*int64) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.RuleIds = v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetails) SetTradePrice(v float64) *DescribeCommodityPriceResponseBodyOrderDetails {
	s.TradePrice = &v
	return s
}

type DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails struct {
	// The discount.
	DiscountPrice *float64 `json:"DiscountPrice,omitempty" xml:"DiscountPrice,omitempty"`
	// The code of the commodity module.
	ModuleCode *string `json:"ModuleCode,omitempty" xml:"ModuleCode,omitempty"`
	// The name of the commodity module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The original price.
	OriginalPrice *float64 `json:"OriginalPrice,omitempty" xml:"OriginalPrice,omitempty"`
	// The discounted price.
	TradePrice *float64 `json:"TradePrice,omitempty" xml:"TradePrice,omitempty"`
}

func (s DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) SetDiscountPrice(v float64) *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails {
	s.DiscountPrice = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) SetModuleCode(v string) *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails {
	s.ModuleCode = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) SetModuleName(v string) *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails {
	s.ModuleName = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) SetOriginalPrice(v float64) *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails {
	s.OriginalPrice = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails) SetTradePrice(v float64) *DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails {
	s.TradePrice = &v
	return s
}

type DescribeCommodityPriceResponseBodyOrderDetailsPromDetails struct {
	// The discounted price.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	FinalPromFee *float64 `json:"FinalPromFee,omitempty" xml:"FinalPromFee,omitempty"`
	// The code of the discount option.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	OptionCode *string `json:"OptionCode,omitempty" xml:"OptionCode,omitempty"`
	// The sub-type of the discount.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	PromType *string `json:"PromType,omitempty" xml:"PromType,omitempty"`
	// The ID of the discount item.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The name of the discount item.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	PromotionName *string `json:"PromotionName,omitempty" xml:"PromotionName,omitempty"`
}

func (s DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) SetFinalPromFee(v float64) *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails {
	s.FinalPromFee = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) SetOptionCode(v string) *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails {
	s.OptionCode = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) SetPromType(v string) *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails {
	s.PromType = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) SetPromotionId(v string) *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails {
	s.PromotionId = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails) SetPromotionName(v string) *DescribeCommodityPriceResponseBodyOrderDetailsPromDetails {
	s.PromotionName = &v
	return s
}

type DescribeCommodityPriceResponseBodyPromotions struct {
	// The discounted amount.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	CanPromFee *float64 `json:"CanPromFee,omitempty" xml:"CanPromFee,omitempty"`
	// The code of the commodity to which the coupon applies.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	OptionCode *string `json:"OptionCode,omitempty" xml:"OptionCode,omitempty"`
	// The name of the coupon.
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	PromotionName *string `json:"PromotionName,omitempty" xml:"PromotionName,omitempty"`
	// The coupon code.
	//
	// >
	//
	// *   `youhuiquan_promotion_option_id_for_blank` indicates coupons that do not apply.
	//
	// *   This parameter is unavailable on the China site (aliyun.com).
	PromotionOptionNo *string `json:"PromotionOptionNo,omitempty" xml:"PromotionOptionNo,omitempty"`
	// Indicates whether an item is selected. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is unavailable on the China site (aliyun.com).
	Selected *bool `json:"Selected,omitempty" xml:"Selected,omitempty"`
}

func (s DescribeCommodityPriceResponseBodyPromotions) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceResponseBodyPromotions) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceResponseBodyPromotions) SetCanPromFee(v float64) *DescribeCommodityPriceResponseBodyPromotions {
	s.CanPromFee = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyPromotions) SetOptionCode(v string) *DescribeCommodityPriceResponseBodyPromotions {
	s.OptionCode = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyPromotions) SetPromotionName(v string) *DescribeCommodityPriceResponseBodyPromotions {
	s.PromotionName = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyPromotions) SetPromotionOptionNo(v string) *DescribeCommodityPriceResponseBodyPromotions {
	s.PromotionOptionNo = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyPromotions) SetSelected(v bool) *DescribeCommodityPriceResponseBodyPromotions {
	s.Selected = &v
	return s
}

type DescribeCommodityPriceResponseBodyRuleDetails struct {
	// The ID of the discount rule.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the discount rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s DescribeCommodityPriceResponseBodyRuleDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceResponseBodyRuleDetails) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceResponseBodyRuleDetails) SetRuleId(v string) *DescribeCommodityPriceResponseBodyRuleDetails {
	s.RuleId = &v
	return s
}

func (s *DescribeCommodityPriceResponseBodyRuleDetails) SetRuleName(v string) *DescribeCommodityPriceResponseBodyRuleDetails {
	s.RuleName = &v
	return s
}

type DescribeCommodityPriceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCommodityPriceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCommodityPriceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCommodityPriceResponse) GoString() string {
	return s.String()
}

func (s *DescribeCommodityPriceResponse) SetHeaders(v map[string]*string) *DescribeCommodityPriceResponse {
	s.Headers = v
	return s
}

func (s *DescribeCommodityPriceResponse) SetStatusCode(v int32) *DescribeCommodityPriceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCommodityPriceResponse) SetBody(v *DescribeCommodityPriceResponseBody) *DescribeCommodityPriceResponse {
	s.Body = v
	return s
}

type DescribeCustomRoutingEndPointTrafficPolicyRequest struct {
	// The ID of the traffic policy to be queried.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeCustomRoutingEndPointTrafficPolicy**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCustomRoutingEndPointTrafficPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndPointTrafficPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyRequest) SetEndpointId(v string) *DescribeCustomRoutingEndPointTrafficPolicyRequest {
	s.EndpointId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyRequest) SetPolicyId(v string) *DescribeCustomRoutingEndPointTrafficPolicyRequest {
	s.PolicyId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyRequest) SetRegionId(v string) *DescribeCustomRoutingEndPointTrafficPolicyRequest {
	s.RegionId = &v
	return s
}

type DescribeCustomRoutingEndPointTrafficPolicyResponseBody struct {
	// The ID of the request.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the traffic policy.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the endpoint to which the traffic policy belongs.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The ID of the listener to which the endpoint belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint group to which the endpoint belongs.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the GA instance to which the endpoint belongs.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the vSwitch to which the traffic policy belongs.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The IP address of the traffic policy.
	PortRanges []*DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
	// The ID of the endpoint to which the traffic destination belongs.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The status of the traffic destination.
	//
	// - init: being initialized.
	// - active: running as expected.
	// - updating: being updated.
	// - deleting: being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetAcceleratorId(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetAddress(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.Address = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetEndpoint(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.Endpoint = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetEndpointGroupId(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetEndpointId(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.EndpointId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetListenerId(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetPolicyId(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.PolicyId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetPortRanges(v []*DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.PortRanges = v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetRequestId(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetServiceId(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetServiceManaged(v bool) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetServiceManagedInfos(v []*DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) SetState(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBody {
	s.State = &v
	return s
}

type DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges struct {
	// The port range of the traffic destination.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The first port of the port range.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges) SetFromPort(v int32) *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges {
	s.FromPort = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges) SetToPort(v int32) *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges {
	s.ToPort = &v
	return s
}

type DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos) SetAction(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeCustomRoutingEndPointTrafficPolicyResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeCustomRoutingEndPointTrafficPolicyResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomRoutingEndPointTrafficPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndPointTrafficPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponse) SetHeaders(v map[string]*string) *DescribeCustomRoutingEndPointTrafficPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponse) SetStatusCode(v int32) *DescribeCustomRoutingEndPointTrafficPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomRoutingEndPointTrafficPolicyResponse) SetBody(v *DescribeCustomRoutingEndPointTrafficPolicyResponseBody) *DescribeCustomRoutingEndPointTrafficPolicyResponse {
	s.Body = v
	return s
}

type DescribeCustomRoutingEndpointRequest struct {
	// The ID of the endpoint group.
	EndpointGroup *string `json:"EndpointGroup,omitempty" xml:"EndpointGroup,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCustomRoutingEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointRequest) SetEndpointGroup(v string) *DescribeCustomRoutingEndpointRequest {
	s.EndpointGroup = &v
	return s
}

func (s *DescribeCustomRoutingEndpointRequest) SetEndpointId(v string) *DescribeCustomRoutingEndpointRequest {
	s.EndpointId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointRequest) SetRegionId(v string) *DescribeCustomRoutingEndpointRequest {
	s.RegionId = &v
	return s
}

type DescribeCustomRoutingEndpointResponseBody struct {
	// The ID of the GA instance with which the endpoint is associated.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The name of the endpoint (vSwitch).
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The ID of the endpoint group to which the endpoint belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the listener with which the endpoint is associated.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The status of the endpoint.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The access policy of traffic for the specified endpoint. Valid values:
	//
	// *   **AllowAll**: allows all traffic to the endpoint.
	// *   **DenyAll**: denies all traffic to the endpoint.
	// *   **AllowCustom**: allows traffic only to specified destinations.
	TrafficToEndpointPolicy *string `json:"TrafficToEndpointPolicy,omitempty" xml:"TrafficToEndpointPolicy,omitempty"`
	// The backend service type of the endpoint.
	//
	// Set the value to **PrivateSubNet**, which indicates private CIDR blocks.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeCustomRoutingEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetAcceleratorId(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetEndpoint(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.Endpoint = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetEndpointGroupId(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetEndpointId(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.EndpointId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetListenerId(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetRequestId(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetServiceId(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetServiceManaged(v bool) *DescribeCustomRoutingEndpointResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetServiceManagedInfos(v []*DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos) *DescribeCustomRoutingEndpointResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetState(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.State = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetTrafficToEndpointPolicy(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.TrafficToEndpointPolicy = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBody) SetType(v string) *DescribeCustomRoutingEndpointResponseBody {
	s.Type = &v
	return s
}

type DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	//
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos) SetAction(v string) *DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeCustomRoutingEndpointResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeCustomRoutingEndpointResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomRoutingEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomRoutingEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointResponse) SetHeaders(v map[string]*string) *DescribeCustomRoutingEndpointResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomRoutingEndpointResponse) SetStatusCode(v int32) *DescribeCustomRoutingEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomRoutingEndpointResponse) SetBody(v *DescribeCustomRoutingEndpointResponseBody) *DescribeCustomRoutingEndpointResponse {
	s.Body = v
	return s
}

type DescribeCustomRoutingEndpointGroupRequest struct {
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCustomRoutingEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupRequest) SetEndpointGroupId(v string) *DescribeCustomRoutingEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupRequest) SetRegionId(v string) *DescribeCustomRoutingEndpointGroupRequest {
	s.RegionId = &v
	return s
}

type DescribeCustomRoutingEndpointGroupResponseBody struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// Indicates the status of the binding between the Log Service project and the endpoint group. Valid values:
	//
	// *   **on:** The endpoint group is bound to the Log Service project.
	// *   **off:** The endpoint group is not bound to the Log Service project.
	// *   **binding:** The endpoint group is being bound to the Log Service project.
	// *   **unbinding:** The endpoint group is being unbound from the Log Service project.
	AccessLogSwitch *string `json:"AccessLogSwitch,omitempty" xml:"AccessLogSwitch,omitempty"`
	// The description of the endpoint group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the access log feature is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	EnableAccessLog *bool `json:"EnableAccessLog,omitempty" xml:"EnableAccessLog,omitempty"`
	// The endpoint group ID.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The endpoint group IP addresses.
	EndpointGroupIpList []*string `json:"EndpointGroupIpList,omitempty" xml:"EndpointGroupIpList,omitempty" type:"Repeated"`
	// The region ID of the endpoint group.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The endpoint group IP addresses that need to be confirmed after the GA instance is upgraded.
	EndpointGroupUnconfirmedIpList []*string `json:"EndpointGroupUnconfirmedIpList,omitempty" xml:"EndpointGroupUnconfirmedIpList,omitempty" type:"Repeated"`
	// The custom routing listener ID.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the endpoint group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// 托管实例所属的服务方ID。
	// > 仅在**ServiceManaged**参数为**True**时有效。
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// 是否为托管实例。取值：
	//
	// - **true**：是托管实例。
	//
	// - **false**：不是托管实例。
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// 用户在此托管实例下可执行的动作策略列表。
	//
	// > 仅在**ServiceManaged**参数为**True**时有效。
	// > - 当实例处于托管状态时，用户对实例的操作会受到限制，某些操作行为会被禁止。
	ServiceManagedInfos []*DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The name of the Logstore.
	SlsLogStoreName *string `json:"SlsLogStoreName,omitempty" xml:"SlsLogStoreName,omitempty"`
	// The name of the Log Service project.
	SlsProjectName *string `json:"SlsProjectName,omitempty" xml:"SlsProjectName,omitempty"`
	// The region of the logs that are created in Log Service.
	SlsRegion *string `json:"SlsRegion,omitempty" xml:"SlsRegion,omitempty"`
	// The status of the endpoint group. Valid values:
	//
	// *   **init:** The endpoint group is being initialized.
	// *   **active:** The endpoint group is running normally.
	// *   **updating:** The endpoint group is being updated.
	// *   **deleting:** The ACL is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribeCustomRoutingEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetAcceleratorId(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetAccessLogSwitch(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.AccessLogSwitch = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetDescription(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetEnableAccessLog(v bool) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.EnableAccessLog = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetEndpointGroupId(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetEndpointGroupIpList(v []*string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.EndpointGroupIpList = v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetEndpointGroupRegion(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.EndpointGroupRegion = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetEndpointGroupUnconfirmedIpList(v []*string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.EndpointGroupUnconfirmedIpList = v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetListenerId(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetName(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetRequestId(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetServiceId(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetServiceManaged(v bool) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetServiceManagedInfos(v []*DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetSlsLogStoreName(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.SlsLogStoreName = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetSlsProjectName(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.SlsProjectName = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetSlsRegion(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.SlsRegion = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBody) SetState(v string) *DescribeCustomRoutingEndpointGroupResponseBody {
	s.State = &v
	return s
}

type DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos struct {
	// 托管策略动作名称，取值：
	// - **Create**：创建实例。
	// - **Update**：更新当前实例。
	// - **Delete**：删除当前实例。
	// - **Associate**：引用/被引用当前实例。
	// - **UserUnmanaged**：用户解托管实例。
	// - **CreateChild**：在当前实例下创建子资源。
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// 子资源类型，取值：
	// - **Listener**：监听资源。
	// - **IpSet**：加速地域资源。
	// - **EndpointGroup**：终端节点组资源。
	// - **ForwardingRule**：转发策略资源。
	// - **Endpoint**：终端节点资源。
	// - **EndpointGroupDestination**：自定义路由监听下的终端节点组协议映射资源。
	// - **EndpointPolicy**：自定义路由监听下的终端节点通行策略资源。
	// > 仅在**Action**参数为**CreateChild**时有效
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// 托管策略动作是否被托管，取值：
	// - **true**：托管策略动作被托管，用户无权在托管实例下执行Action指定的操作。
	// - **false**：托管策略动作未被托管，用户可在托管实例下执行Action指定的操作。
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos) SetAction(v string) *DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeCustomRoutingEndpointGroupResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeCustomRoutingEndpointGroupResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomRoutingEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomRoutingEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupResponse) SetHeaders(v map[string]*string) *DescribeCustomRoutingEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponse) SetStatusCode(v int32) *DescribeCustomRoutingEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupResponse) SetBody(v *DescribeCustomRoutingEndpointGroupResponseBody) *DescribeCustomRoutingEndpointGroupResponse {
	s.Body = v
	return s
}

type DescribeCustomRoutingEndpointGroupDestinationsRequest struct {
	// The ID of the endpoint group mapping configuration.
	DestinationId *string `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCustomRoutingEndpointGroupDestinationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupDestinationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsRequest) SetDestinationId(v string) *DescribeCustomRoutingEndpointGroupDestinationsRequest {
	s.DestinationId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsRequest) SetEndpointGroupId(v string) *DescribeCustomRoutingEndpointGroupDestinationsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsRequest) SetRegionId(v string) *DescribeCustomRoutingEndpointGroupDestinationsRequest {
	s.RegionId = &v
	return s
}

type DescribeCustomRoutingEndpointGroupDestinationsResponseBody struct {
	// The ID of the Global Accelerator (GA) instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint group mapping configuration.
	DestinationId *string `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The start port of the backend service port range of the endpoint group.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The backend service protocol of the endpoint group.
	//
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	// *   **TCP,UDP**: TCP and UDP
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The status of the endpoint group mapping configuration.
	//
	// *   **init**: being initialized.
	// *   **active**: normal.
	// *   **updating**: being updated.
	// *   **deleting**: being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The end port of the backend service port range of the endpoint group.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s DescribeCustomRoutingEndpointGroupDestinationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupDestinationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetAcceleratorId(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetDestinationId(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.DestinationId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetEndpointGroupId(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetFromPort(v int32) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.FromPort = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetListenerId(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetProtocols(v []*string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.Protocols = v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetRequestId(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetServiceId(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetServiceManaged(v bool) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetServiceManagedInfos(v []*DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetState(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.State = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) SetToPort(v int32) *DescribeCustomRoutingEndpointGroupDestinationsResponseBody {
	s.ToPort = &v
	return s
}

type DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	//
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos) SetAction(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeCustomRoutingEndpointGroupDestinationsResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeCustomRoutingEndpointGroupDestinationsResponse struct {
	Headers    map[string]*string                                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomRoutingEndpointGroupDestinationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomRoutingEndpointGroupDestinationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomRoutingEndpointGroupDestinationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponse) SetHeaders(v map[string]*string) *DescribeCustomRoutingEndpointGroupDestinationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponse) SetStatusCode(v int32) *DescribeCustomRoutingEndpointGroupDestinationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomRoutingEndpointGroupDestinationsResponse) SetBody(v *DescribeCustomRoutingEndpointGroupDestinationsResponseBody) *DescribeCustomRoutingEndpointGroupDestinationsResponse {
	s.Body = v
	return s
}

type DescribeEndpointGroupRequest struct {
	// The ID of the endpoint group that you want to query.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region where your Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeEndpointGroupRequest) SetEndpointGroupId(v string) *DescribeEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeEndpointGroupRequest) SetRegionId(v string) *DescribeEndpointGroupRequest {
	s.RegionId = &v
	return s
}

type DescribeEndpointGroupResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// Indicates the status of the binding between the Log Service project and the endpoint group. Valid values:
	//
	// *   **on**: The Log Service project is bound to the endpoint group.
	// *   **off**: No Log Service projects are bound to the endpoint group.
	// *   **binding**: The Log Service project is being bound to the endpoint group.
	// *   **unbinding**: The Log Service project is being unbound from the endpoint group.
	AccessLogSwitch *string `json:"AccessLogSwitch,omitempty" xml:"AccessLogSwitch,omitempty"`
	// The description of the endpoint group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the access log feature is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	EnableAccessLog *bool `json:"EnableAccessLog,omitempty" xml:"EnableAccessLog,omitempty"`
	// The configurations of endpoints in the endpoint group.
	EndpointConfigurations []*DescribeEndpointGroupResponseBodyEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The active endpoint IP addresses of the endpoint group.
	EndpointGroupIpList []*string `json:"EndpointGroupIpList,omitempty" xml:"EndpointGroupIpList,omitempty" type:"Repeated"`
	// The ID of the region where the endpoint group is deployed.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The type of endpoint group. Valid values:
	//
	// *   **default**: a default endpoint group
	// *   **virtual**: a virtual endpoint group
	EndpointGroupType *string `json:"EndpointGroupType,omitempty" xml:"EndpointGroupType,omitempty"`
	// The endpoint group IP addresses to be confirmed. After the GA instance is upgraded, the IP addresses that are added to the endpoint group need to be confirmed.
	EndpointGroupUnconfirmedIpList []*string `json:"EndpointGroupUnconfirmedIpList,omitempty" xml:"EndpointGroupUnconfirmedIpList,omitempty" type:"Repeated"`
	// The protocol that is used by the backend service.
	//
	// *   **HTTP**
	// *   **HTTPS**
	EndpointRequestProtocol *string `json:"EndpointRequestProtocol,omitempty" xml:"EndpointRequestProtocol,omitempty"`
	// The ID of the forwarding rule that is associated with the endpoint group.
	ForwardingRuleIds []*string `json:"ForwardingRuleIds,omitempty" xml:"ForwardingRuleIds,omitempty" type:"Repeated"`
	// Indicates whether the health check feature is enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	HealthCheckEnabled *bool `json:"HealthCheckEnabled,omitempty" xml:"HealthCheckEnabled,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	HealthCheckIntervalSeconds *int32 `json:"HealthCheckIntervalSeconds,omitempty" xml:"HealthCheckIntervalSeconds,omitempty"`
	// The path to which health check probes are sent.
	HealthCheckPath *string `json:"HealthCheckPath,omitempty" xml:"HealthCheckPath,omitempty"`
	// The port that is used for health checks.
	HealthCheckPort *int32 `json:"HealthCheckPort,omitempty" xml:"HealthCheckPort,omitempty"`
	// The protocol over which health check requests are sent. Valid values:
	//
	// *   **tcp**: TCP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	HealthCheckProtocol *string `json:"HealthCheckProtocol,omitempty" xml:"HealthCheckProtocol,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the endpoint group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The mappings between ports.
	PortOverrides []*DescribeEndpointGroupResponseBodyPortOverrides `json:"PortOverrides,omitempty" xml:"PortOverrides,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Value:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	//
	// > Valid only when the ServiceManaged parameter is True.
	// >* When an instance is hosted, user operations on the instance are restricted and some operations are prohibited.
	ServiceManagedInfos []*DescribeEndpointGroupResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The name of the Logstore.
	SlsLogStoreName *string `json:"SlsLogStoreName,omitempty" xml:"SlsLogStoreName,omitempty"`
	// The name of the Log Service project.
	SlsProjectName *string `json:"SlsProjectName,omitempty" xml:"SlsProjectName,omitempty"`
	// The region of the Log Service project.
	SlsRegion *string `json:"SlsRegion,omitempty" xml:"SlsRegion,omitempty"`
	// The status of the endpoint group. Valid values:
	//
	// *   **init**: The endpoint group is being initialized.
	// *   **active**: The endpoint group is running as expected.
	// *   **updating**: The endpoint group is being updated.
	// *   **deleting**: The endpoint group is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// Tags.
	Tags []*DescribeEndpointGroupResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The number of consecutive failed health checks that must occur before an endpoint is considered unhealthy.
	ThresholdCount *int32 `json:"ThresholdCount,omitempty" xml:"ThresholdCount,omitempty"`
	// The weight of the endpoint group. If the listener is associated with multiple endpoint groups, this parameter indicates the weight of the current endpoint group.
	TrafficPercentage *int32 `json:"TrafficPercentage,omitempty" xml:"TrafficPercentage,omitempty"`
}

func (s DescribeEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEndpointGroupResponseBody) SetAcceleratorId(v string) *DescribeEndpointGroupResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetAccessLogSwitch(v string) *DescribeEndpointGroupResponseBody {
	s.AccessLogSwitch = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetDescription(v string) *DescribeEndpointGroupResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEnableAccessLog(v bool) *DescribeEndpointGroupResponseBody {
	s.EnableAccessLog = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEndpointConfigurations(v []*DescribeEndpointGroupResponseBodyEndpointConfigurations) *DescribeEndpointGroupResponseBody {
	s.EndpointConfigurations = v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEndpointGroupId(v string) *DescribeEndpointGroupResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEndpointGroupIpList(v []*string) *DescribeEndpointGroupResponseBody {
	s.EndpointGroupIpList = v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEndpointGroupRegion(v string) *DescribeEndpointGroupResponseBody {
	s.EndpointGroupRegion = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEndpointGroupType(v string) *DescribeEndpointGroupResponseBody {
	s.EndpointGroupType = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEndpointGroupUnconfirmedIpList(v []*string) *DescribeEndpointGroupResponseBody {
	s.EndpointGroupUnconfirmedIpList = v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetEndpointRequestProtocol(v string) *DescribeEndpointGroupResponseBody {
	s.EndpointRequestProtocol = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetForwardingRuleIds(v []*string) *DescribeEndpointGroupResponseBody {
	s.ForwardingRuleIds = v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetHealthCheckEnabled(v bool) *DescribeEndpointGroupResponseBody {
	s.HealthCheckEnabled = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetHealthCheckIntervalSeconds(v int32) *DescribeEndpointGroupResponseBody {
	s.HealthCheckIntervalSeconds = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetHealthCheckPath(v string) *DescribeEndpointGroupResponseBody {
	s.HealthCheckPath = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetHealthCheckPort(v int32) *DescribeEndpointGroupResponseBody {
	s.HealthCheckPort = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetHealthCheckProtocol(v string) *DescribeEndpointGroupResponseBody {
	s.HealthCheckProtocol = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetListenerId(v string) *DescribeEndpointGroupResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetName(v string) *DescribeEndpointGroupResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetPortOverrides(v []*DescribeEndpointGroupResponseBodyPortOverrides) *DescribeEndpointGroupResponseBody {
	s.PortOverrides = v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetRequestId(v string) *DescribeEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetServiceId(v string) *DescribeEndpointGroupResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetServiceManaged(v bool) *DescribeEndpointGroupResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetServiceManagedInfos(v []*DescribeEndpointGroupResponseBodyServiceManagedInfos) *DescribeEndpointGroupResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetSlsLogStoreName(v string) *DescribeEndpointGroupResponseBody {
	s.SlsLogStoreName = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetSlsProjectName(v string) *DescribeEndpointGroupResponseBody {
	s.SlsProjectName = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetSlsRegion(v string) *DescribeEndpointGroupResponseBody {
	s.SlsRegion = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetState(v string) *DescribeEndpointGroupResponseBody {
	s.State = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetTags(v []*DescribeEndpointGroupResponseBodyTags) *DescribeEndpointGroupResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetThresholdCount(v int32) *DescribeEndpointGroupResponseBody {
	s.ThresholdCount = &v
	return s
}

func (s *DescribeEndpointGroupResponseBody) SetTrafficPercentage(v int32) *DescribeEndpointGroupResponseBody {
	s.TrafficPercentage = &v
	return s
}

type DescribeEndpointGroupResponseBodyEndpointConfigurations struct {
	// Indicates whether the client IP address preservation feature is enabled. Valid values:
	//
	// *   **true:** The client IP address preservation feature is enabled.
	// *   **false:** The client IP address preservation feature is disabled.
	EnableClientIPPreservation *bool `json:"EnableClientIPPreservation,omitempty" xml:"EnableClientIPPreservation,omitempty"`
	// Indicates whether the proxy protocol is used to preserve client IP addresses.
	EnableProxyProtocol *bool `json:"EnableProxyProtocol,omitempty" xml:"EnableProxyProtocol,omitempty"`
	// The IP address or domain name of the endpoint.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The port that is used to monitor latency.
	ProbePort *int32 `json:"ProbePort,omitempty" xml:"ProbePort,omitempty"`
	// The protocol that is used to monitor latency. Valid values:
	//
	// *   **tcp:** TCP.
	// *   **icmp:** ICMP.
	ProbeProtocol *string `json:"ProbeProtocol,omitempty" xml:"ProbeProtocol,omitempty"`
	SubAddress    *string `json:"SubAddress,omitempty" xml:"SubAddress,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Domain:** a custom domain name.
	// *   **Ip:** a custom IP address.
	// *   **PublicIp:** a public IP address provided by Alibaba Cloud.
	// *   **ECS:** an Elastic Compute Service (ECS) instance.
	// *   **SLB:** a Server Load Balancer (SLB) instance.
	// *   **ALB:** an Application Load Balancer (ALB) instance.
	// *   **OSS:** an Object Storage Service (OSS) bucket.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the endpoint.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeEndpointGroupResponseBodyEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s DescribeEndpointGroupResponseBodyEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetEnableClientIPPreservation(v bool) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.EnableClientIPPreservation = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetEnableProxyProtocol(v bool) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.EnableProxyProtocol = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetEndpoint(v string) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetProbePort(v int32) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.ProbePort = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetProbeProtocol(v string) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.ProbeProtocol = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetSubAddress(v string) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.SubAddress = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetType(v string) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.Type = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyEndpointConfigurations) SetWeight(v int32) *DescribeEndpointGroupResponseBodyEndpointConfigurations {
	s.Weight = &v
	return s
}

type DescribeEndpointGroupResponseBodyPortOverrides struct {
	// The endpoint port.
	EndpointPort *int32 `json:"EndpointPort,omitempty" xml:"EndpointPort,omitempty"`
	// The listening port.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
}

func (s DescribeEndpointGroupResponseBodyPortOverrides) String() string {
	return tea.Prettify(s)
}

func (s DescribeEndpointGroupResponseBodyPortOverrides) GoString() string {
	return s.String()
}

func (s *DescribeEndpointGroupResponseBodyPortOverrides) SetEndpointPort(v int32) *DescribeEndpointGroupResponseBodyPortOverrides {
	s.EndpointPort = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyPortOverrides) SetListenerPort(v int32) *DescribeEndpointGroupResponseBodyPortOverrides {
	s.ListenerPort = &v
	return s
}

type DescribeEndpointGroupResponseBodyServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	//
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeEndpointGroupResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeEndpointGroupResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeEndpointGroupResponseBodyServiceManagedInfos) SetAction(v string) *DescribeEndpointGroupResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeEndpointGroupResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeEndpointGroupResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeEndpointGroupResponseBodyTags struct {
	// The key of tag N that is added to the endpoint group.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N that is added to the endpoint group.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEndpointGroupResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeEndpointGroupResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeEndpointGroupResponseBodyTags) SetKey(v string) *DescribeEndpointGroupResponseBodyTags {
	s.Key = &v
	return s
}

func (s *DescribeEndpointGroupResponseBodyTags) SetValue(v string) *DescribeEndpointGroupResponseBodyTags {
	s.Value = &v
	return s
}

type DescribeEndpointGroupResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeEndpointGroupResponse) SetHeaders(v map[string]*string) *DescribeEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeEndpointGroupResponse) SetStatusCode(v int32) *DescribeEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEndpointGroupResponse) SetBody(v *DescribeEndpointGroupResponseBody) *DescribeEndpointGroupResponse {
	s.Body = v
	return s
}

type DescribeIpSetRequest struct {
	// The ID of the acceleration region.
	//
	// You can call the [ListIpSets](~~153247~~) operation to query IDs of acceleration regions of a specified GA instance.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpSetRequest) GoString() string {
	return s.String()
}

func (s *DescribeIpSetRequest) SetIpSetId(v string) *DescribeIpSetRequest {
	s.IpSetId = &v
	return s
}

func (s *DescribeIpSetRequest) SetRegionId(v string) *DescribeIpSetRequest {
	s.RegionId = &v
	return s
}

type DescribeIpSetResponseBody struct {
	// The ID of the acceleration region.
	AccelerateRegionId *string `json:"AccelerateRegionId,omitempty" xml:"AccelerateRegionId,omitempty"`
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth that is allocated to the acceleration region. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The list of accelerated IP addresses in the acceleration region.
	IpAddressList []*string `json:"IpAddressList,omitempty" xml:"IpAddressList,omitempty" type:"Repeated"`
	// The ID of the acceleration region.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The version of the IP protocol. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The line type of the elastic IP address (EIP) in the acceleration region. Valid values:
	//
	// *   **BGP**: BGP (Multi-ISP) lines.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines.
	//
	// If you are allowed to use single-ISP bandwidth, one of the following values is returned:
	//
	// *   **ChinaTelecom**: China Telecom (single ISP).
	// *   **ChinaUnicom**: China Unicom (single ISP).
	// *   **ChinaMobile**: China Mobile (single ISP).
	// *   **ChinaTelecom_L2**: China Telecom (single ISP)\_L2.
	// *   **ChinaUnicom_L2**: China Unicom (single ISP)\_L2.
	// *   **ChinaMobile_L2**: China Mobile (single ISP)\_L2.
	//
	// >  The supported single-ISP type varies with the acceleration region.
	IspType *string `json:"IspType,omitempty" xml:"IspType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*DescribeIpSetResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The status of the acceleration region. Valid values:
	//
	// *   **init**: The acceleration region is being initialized.
	// *   **active**: The acceleration region is in the running state.
	// *   **updating**: The acceleration region is being configured.
	// *   **deleting**: The GA instance is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribeIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIpSetResponseBody) SetAccelerateRegionId(v string) *DescribeIpSetResponseBody {
	s.AccelerateRegionId = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetAcceleratorId(v string) *DescribeIpSetResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetBandwidth(v int32) *DescribeIpSetResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetIpAddressList(v []*string) *DescribeIpSetResponseBody {
	s.IpAddressList = v
	return s
}

func (s *DescribeIpSetResponseBody) SetIpSetId(v string) *DescribeIpSetResponseBody {
	s.IpSetId = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetIpVersion(v string) *DescribeIpSetResponseBody {
	s.IpVersion = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetIspType(v string) *DescribeIpSetResponseBody {
	s.IspType = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetRequestId(v string) *DescribeIpSetResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetServiceId(v string) *DescribeIpSetResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetServiceManaged(v bool) *DescribeIpSetResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeIpSetResponseBody) SetServiceManagedInfos(v []*DescribeIpSetResponseBodyServiceManagedInfos) *DescribeIpSetResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeIpSetResponseBody) SetState(v string) *DescribeIpSetResponseBody {
	s.State = &v
	return s
}

type DescribeIpSetResponseBodyServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	//
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeIpSetResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpSetResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeIpSetResponseBodyServiceManagedInfos) SetAction(v string) *DescribeIpSetResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeIpSetResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeIpSetResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeIpSetResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeIpSetResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeIpSetResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIpSetResponse) GoString() string {
	return s.String()
}

func (s *DescribeIpSetResponse) SetHeaders(v map[string]*string) *DescribeIpSetResponse {
	s.Headers = v
	return s
}

func (s *DescribeIpSetResponse) SetStatusCode(v int32) *DescribeIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIpSetResponse) SetBody(v *DescribeIpSetResponseBody) *DescribeIpSetResponse {
	s.Body = v
	return s
}

type DescribeListenerRequest struct {
	// The ID of the listener that you want to query.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerRequest) GoString() string {
	return s.String()
}

func (s *DescribeListenerRequest) SetListenerId(v string) *DescribeListenerRequest {
	s.ListenerId = &v
	return s
}

func (s *DescribeListenerRequest) SetRegionId(v string) *DescribeListenerRequest {
	s.RegionId = &v
	return s
}

type DescribeListenerResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The type of the ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios in which you want to allow only specified IP addresses to access an application. Your service may be adversely affected if the whitelist is not properly configured. After you configure a whitelist for a listener, only requests from the IP addresses that are added to the whitelist are forwarded by the listener. If the whitelist is enabled but no IP addresses are added to the ACL, the listener does not forward requests.
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are blocked. Blacklists apply to scenarios in which you want to deny access from specific IP addresses to an application. If the blacklist is enabled but no IP addresses are added to the ACL, the listener forwards all requests.
	//
	// If the value of **Status** is **on**, this parameter is returned.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// Details about the backend ports.
	BackendPorts []*DescribeListenerResponseBodyBackendPorts `json:"BackendPorts,omitempty" xml:"BackendPorts,omitempty" type:"Repeated"`
	// The SSL certificates.
	Certificates []*DescribeListenerResponseBodyCertificates `json:"Certificates,omitempty" xml:"Certificates,omitempty" type:"Repeated"`
	// Indicates whether client affinity is enabled for the listener.
	//
	// *   If **NONE** is returned, client affinity is disabled. In this case, requests from the same client may be forwarded to different endpoints.
	// *   If **SOURCE_IP** is returned, client affinity is enabled. In this case, when a client accesses stateful applications, requests from the same client are always forwarded to the same endpoint regardless of the source port or protocol.
	ClientAffinity *string `json:"ClientAffinity,omitempty" xml:"ClientAffinity,omitempty"`
	// The timestamp when the listener was created. Unit: milliseconds.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the listener.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the listener.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Details about the listener ports.
	PortRanges []*DescribeListenerResponseBodyPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
	// The network transmission protocol that is used by the listener. Valid values:
	//
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// Indicates whether the client IP address preservation feature is enabled. Valid values:
	//
	// *   **true**: The client IP address preservation feature is enabled. After client IP addresses are reserved, you can view the source IP addresses of clients over the backend service.
	// *   **false**: The client IP address preservation feature is disabled.
	ProxyProtocol *bool `json:"ProxyProtocol,omitempty" xml:"ProxyProtocol,omitempty"`
	// The information about the access control list (ACL) that is associated with the listener.
	RelatedAcls []*DescribeListenerResponseBodyRelatedAcls `json:"RelatedAcls,omitempty" xml:"RelatedAcls,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the security policy.
	//
	// *   **tls_cipher_policy\_1\_0**
	//
	//     *   Supported Transport Layer Security (TLS) versions: TLS 1.0, TLS 1.1, and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_1**
	//
	//     *   Supported TLS versions: TLS 1.1 and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict_with\_1\_3**
	//
	//     *   Supported TLS versions: TLS 1.2 and TLS 1.3
	//     *   Supported cipher suites: TLS_AES\_128\_GCM_SHA256, TLS_AES\_256\_GCM_SHA384, TLS_CHACHA20\_POLY1305\_SHA256, TLS_AES\_128\_CCM_SHA256, TLS_AES\_128\_CCM\_8\_SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES128-SHA256, ECDHE-ECDSA-AES256-SHA384, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-ECDSA-AES128-SHA, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// >  This parameter is returned only for HTTPS listeners.
	SecurityPolicyId *string `json:"SecurityPolicyId,omitempty" xml:"SecurityPolicyId,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*DescribeListenerResponseBodyServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The state of the listener. Valid values:
	//
	// *   **configuring**: The listener is being configured.
	// *   **init**: The listener is being initialized.
	// *   **updating**: The listener is being updated.
	// *   **deleting**: The listener is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The routing type of the listener. Valid values:
	//
	// *   **Standard**: intelligent routing
	// *   **CustomRouting**: custom routing
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The configurations of the `XForward` headers.
	XForwardedForConfig *DescribeListenerResponseBodyXForwardedForConfig `json:"XForwardedForConfig,omitempty" xml:"XForwardedForConfig,omitempty" type:"Struct"`
}

func (s DescribeListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponseBody) SetAcceleratorId(v string) *DescribeListenerResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeListenerResponseBody) SetAclType(v string) *DescribeListenerResponseBody {
	s.AclType = &v
	return s
}

func (s *DescribeListenerResponseBody) SetBackendPorts(v []*DescribeListenerResponseBodyBackendPorts) *DescribeListenerResponseBody {
	s.BackendPorts = v
	return s
}

func (s *DescribeListenerResponseBody) SetCertificates(v []*DescribeListenerResponseBodyCertificates) *DescribeListenerResponseBody {
	s.Certificates = v
	return s
}

func (s *DescribeListenerResponseBody) SetClientAffinity(v string) *DescribeListenerResponseBody {
	s.ClientAffinity = &v
	return s
}

func (s *DescribeListenerResponseBody) SetCreateTime(v string) *DescribeListenerResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeListenerResponseBody) SetDescription(v string) *DescribeListenerResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeListenerResponseBody) SetListenerId(v string) *DescribeListenerResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeListenerResponseBody) SetName(v string) *DescribeListenerResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeListenerResponseBody) SetPortRanges(v []*DescribeListenerResponseBodyPortRanges) *DescribeListenerResponseBody {
	s.PortRanges = v
	return s
}

func (s *DescribeListenerResponseBody) SetProtocol(v string) *DescribeListenerResponseBody {
	s.Protocol = &v
	return s
}

func (s *DescribeListenerResponseBody) SetProxyProtocol(v bool) *DescribeListenerResponseBody {
	s.ProxyProtocol = &v
	return s
}

func (s *DescribeListenerResponseBody) SetRelatedAcls(v []*DescribeListenerResponseBodyRelatedAcls) *DescribeListenerResponseBody {
	s.RelatedAcls = v
	return s
}

func (s *DescribeListenerResponseBody) SetRequestId(v string) *DescribeListenerResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeListenerResponseBody) SetSecurityPolicyId(v string) *DescribeListenerResponseBody {
	s.SecurityPolicyId = &v
	return s
}

func (s *DescribeListenerResponseBody) SetServiceId(v string) *DescribeListenerResponseBody {
	s.ServiceId = &v
	return s
}

func (s *DescribeListenerResponseBody) SetServiceManaged(v bool) *DescribeListenerResponseBody {
	s.ServiceManaged = &v
	return s
}

func (s *DescribeListenerResponseBody) SetServiceManagedInfos(v []*DescribeListenerResponseBodyServiceManagedInfos) *DescribeListenerResponseBody {
	s.ServiceManagedInfos = v
	return s
}

func (s *DescribeListenerResponseBody) SetState(v string) *DescribeListenerResponseBody {
	s.State = &v
	return s
}

func (s *DescribeListenerResponseBody) SetType(v string) *DescribeListenerResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeListenerResponseBody) SetXForwardedForConfig(v *DescribeListenerResponseBodyXForwardedForConfig) *DescribeListenerResponseBody {
	s.XForwardedForConfig = v
	return s
}

type DescribeListenerResponseBodyBackendPorts struct {
	// The start port in the range of ports used by the backend server to receive requests.
	//
	// This parameter is returned only when you configure an HTTPS listener and the listening port is the same port used by the backend server to provide services.
	FromPort *string `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The end port in the range of ports used by the backend server to receive requests.
	ToPort *string `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s DescribeListenerResponseBodyBackendPorts) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponseBodyBackendPorts) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponseBodyBackendPorts) SetFromPort(v string) *DescribeListenerResponseBodyBackendPorts {
	s.FromPort = &v
	return s
}

func (s *DescribeListenerResponseBodyBackendPorts) SetToPort(v string) *DescribeListenerResponseBodyBackendPorts {
	s.ToPort = &v
	return s
}

type DescribeListenerResponseBodyCertificates struct {
	// The ID of the SSL certificate.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the certificate.
	//
	// Only **Server** can be returned. This value Server indicates a server certificate.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeListenerResponseBodyCertificates) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponseBodyCertificates) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponseBodyCertificates) SetId(v string) *DescribeListenerResponseBodyCertificates {
	s.Id = &v
	return s
}

func (s *DescribeListenerResponseBodyCertificates) SetType(v string) *DescribeListenerResponseBodyCertificates {
	s.Type = &v
	return s
}

type DescribeListenerResponseBodyPortRanges struct {
	// The start port in the range of listening ports used to receive and forward requests to endpoints.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The end port in the range of listening ports used to receive and forward requests to endpoints.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s DescribeListenerResponseBodyPortRanges) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponseBodyPortRanges) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponseBodyPortRanges) SetFromPort(v int32) *DescribeListenerResponseBodyPortRanges {
	s.FromPort = &v
	return s
}

func (s *DescribeListenerResponseBodyPortRanges) SetToPort(v int32) *DescribeListenerResponseBodyPortRanges {
	s.ToPort = &v
	return s
}

type DescribeListenerResponseBodyRelatedAcls struct {
	// The ID of the ACL that is associated with the listener.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// Indicates whether the access control feature is enabled. Valid values:
	//
	// *   **on**: enabled
	// *   **off**: disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeListenerResponseBodyRelatedAcls) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponseBodyRelatedAcls) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponseBodyRelatedAcls) SetAclId(v string) *DescribeListenerResponseBodyRelatedAcls {
	s.AclId = &v
	return s
}

func (s *DescribeListenerResponseBodyRelatedAcls) SetStatus(v string) *DescribeListenerResponseBodyRelatedAcls {
	s.Status = &v
	return s
}

type DescribeListenerResponseBodyServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	//
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	// - **true**: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	// - **false**: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s DescribeListenerResponseBodyServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponseBodyServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponseBodyServiceManagedInfos) SetAction(v string) *DescribeListenerResponseBodyServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *DescribeListenerResponseBodyServiceManagedInfos) SetChildType(v string) *DescribeListenerResponseBodyServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *DescribeListenerResponseBodyServiceManagedInfos) SetIsManaged(v bool) *DescribeListenerResponseBodyServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type DescribeListenerResponseBodyXForwardedForConfig struct {
	// Indicates whether the `GA-AP` header is used to retrieve the information about acceleration regions. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForGaApEnabled *bool `json:"XForwardedForGaApEnabled,omitempty" xml:"XForwardedForGaApEnabled,omitempty"`
	// Indicates whether the `GA-ID` header is used to retrieve the ID of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForGaIdEnabled *bool `json:"XForwardedForGaIdEnabled,omitempty" xml:"XForwardedForGaIdEnabled,omitempty"`
	// Indicates whether the `GA-X-Forward-Port` header is used to retrieve the listener ports of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForPortEnabled *bool `json:"XForwardedForPortEnabled,omitempty" xml:"XForwardedForPortEnabled,omitempty"`
	// Indicates whether the `GA-X-Forward-Proto` header is used to retrieve the listener protocol of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForProtoEnabled *bool `json:"XForwardedForProtoEnabled,omitempty" xml:"XForwardedForProtoEnabled,omitempty"`
	// Indicates whether the `X-Real-IP` header is used to retrieve client IP addresses. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XRealIpEnabled *bool `json:"XRealIpEnabled,omitempty" xml:"XRealIpEnabled,omitempty"`
}

func (s DescribeListenerResponseBodyXForwardedForConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponseBodyXForwardedForConfig) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponseBodyXForwardedForConfig) SetXForwardedForGaApEnabled(v bool) *DescribeListenerResponseBodyXForwardedForConfig {
	s.XForwardedForGaApEnabled = &v
	return s
}

func (s *DescribeListenerResponseBodyXForwardedForConfig) SetXForwardedForGaIdEnabled(v bool) *DescribeListenerResponseBodyXForwardedForConfig {
	s.XForwardedForGaIdEnabled = &v
	return s
}

func (s *DescribeListenerResponseBodyXForwardedForConfig) SetXForwardedForPortEnabled(v bool) *DescribeListenerResponseBodyXForwardedForConfig {
	s.XForwardedForPortEnabled = &v
	return s
}

func (s *DescribeListenerResponseBodyXForwardedForConfig) SetXForwardedForProtoEnabled(v bool) *DescribeListenerResponseBodyXForwardedForConfig {
	s.XForwardedForProtoEnabled = &v
	return s
}

func (s *DescribeListenerResponseBodyXForwardedForConfig) SetXRealIpEnabled(v bool) *DescribeListenerResponseBodyXForwardedForConfig {
	s.XRealIpEnabled = &v
	return s
}

type DescribeListenerResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerResponse) GoString() string {
	return s.String()
}

func (s *DescribeListenerResponse) SetHeaders(v map[string]*string) *DescribeListenerResponse {
	s.Headers = v
	return s
}

func (s *DescribeListenerResponse) SetStatusCode(v int32) *DescribeListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeListenerResponse) SetBody(v *DescribeListenerResponseBody) *DescribeListenerResponse {
	s.Body = v
	return s
}

type DescribeLogStoreOfEndpointGroupRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeLogStoreOfEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogStoreOfEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeLogStoreOfEndpointGroupRequest) SetAcceleratorId(v string) *DescribeLogStoreOfEndpointGroupRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupRequest) SetEndpointGroupId(v string) *DescribeLogStoreOfEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupRequest) SetListenerId(v string) *DescribeLogStoreOfEndpointGroupRequest {
	s.ListenerId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupRequest) SetRegionId(v string) *DescribeLogStoreOfEndpointGroupRequest {
	s.RegionId = &v
	return s
}

type DescribeLogStoreOfEndpointGroupResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the Logstore.
	SlsLogStoreName *string `json:"SlsLogStoreName,omitempty" xml:"SlsLogStoreName,omitempty"`
	// The name of the Log Service project.
	SlsProjectName *string `json:"SlsProjectName,omitempty" xml:"SlsProjectName,omitempty"`
	// The region ID of the Log Service project.
	SlsRegionId *string `json:"SlsRegionId,omitempty" xml:"SlsRegionId,omitempty"`
	// The status of the log.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeLogStoreOfEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogStoreOfEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetAcceleratorId(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetEndpointGroupId(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetListenerId(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetRequestId(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetSlsLogStoreName(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.SlsLogStoreName = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetSlsProjectName(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.SlsProjectName = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetSlsRegionId(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.SlsRegionId = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponseBody) SetStatus(v string) *DescribeLogStoreOfEndpointGroupResponseBody {
	s.Status = &v
	return s
}

type DescribeLogStoreOfEndpointGroupResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLogStoreOfEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLogStoreOfEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogStoreOfEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeLogStoreOfEndpointGroupResponse) SetHeaders(v map[string]*string) *DescribeLogStoreOfEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponse) SetStatusCode(v int32) *DescribeLogStoreOfEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLogStoreOfEndpointGroupResponse) SetBody(v *DescribeLogStoreOfEndpointGroupResponseBody) *DescribeLogStoreOfEndpointGroupResponse {
	s.Body = v
	return s
}

type DescribeRegionsRequest struct {
	// The ID of the region to query.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetRegionId(v string) *DescribeRegionsRequest {
	s.RegionId = &v
	return s
}

type DescribeRegionsResponseBody struct {
	// The available regions.
	Regions []*DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v []*DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	// The region name.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetLocalName(v string) *DescribeRegionsResponseBodyRegions {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegionId(v string) *DescribeRegionsResponseBodyRegions {
	s.RegionId = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DetachDdosFromAcceleratorRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DetachDdosFromAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachDdosFromAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *DetachDdosFromAcceleratorRequest) SetAcceleratorId(v string) *DetachDdosFromAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DetachDdosFromAcceleratorRequest) SetRegionId(v string) *DetachDdosFromAcceleratorRequest {
	s.RegionId = &v
	return s
}

type DetachDdosFromAcceleratorResponseBody struct {
	// The ID of the Anti-DDoS Pro/Premium instance that was disassociated from the GA instance.
	DdosId *string `json:"DdosId,omitempty" xml:"DdosId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachDdosFromAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachDdosFromAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *DetachDdosFromAcceleratorResponseBody) SetDdosId(v string) *DetachDdosFromAcceleratorResponseBody {
	s.DdosId = &v
	return s
}

func (s *DetachDdosFromAcceleratorResponseBody) SetRequestId(v string) *DetachDdosFromAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type DetachDdosFromAcceleratorResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachDdosFromAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachDdosFromAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachDdosFromAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *DetachDdosFromAcceleratorResponse) SetHeaders(v map[string]*string) *DetachDdosFromAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *DetachDdosFromAcceleratorResponse) SetStatusCode(v int32) *DetachDdosFromAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachDdosFromAcceleratorResponse) SetBody(v *DetachDdosFromAcceleratorResponseBody) *DetachDdosFromAcceleratorResponse {
	s.Body = v
	return s
}

type DetachLogStoreFromEndpointGroupRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of endpoint groups.
	EndpointGroupIds []*string `json:"EndpointGroupIds,omitempty" xml:"EndpointGroupIds,omitempty" type:"Repeated"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DetachLogStoreFromEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachLogStoreFromEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *DetachLogStoreFromEndpointGroupRequest) SetAcceleratorId(v string) *DetachLogStoreFromEndpointGroupRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DetachLogStoreFromEndpointGroupRequest) SetClientToken(v string) *DetachLogStoreFromEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachLogStoreFromEndpointGroupRequest) SetEndpointGroupIds(v []*string) *DetachLogStoreFromEndpointGroupRequest {
	s.EndpointGroupIds = v
	return s
}

func (s *DetachLogStoreFromEndpointGroupRequest) SetListenerId(v string) *DetachLogStoreFromEndpointGroupRequest {
	s.ListenerId = &v
	return s
}

func (s *DetachLogStoreFromEndpointGroupRequest) SetRegionId(v string) *DetachLogStoreFromEndpointGroupRequest {
	s.RegionId = &v
	return s
}

type DetachLogStoreFromEndpointGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachLogStoreFromEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachLogStoreFromEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DetachLogStoreFromEndpointGroupResponseBody) SetRequestId(v string) *DetachLogStoreFromEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type DetachLogStoreFromEndpointGroupResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachLogStoreFromEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachLogStoreFromEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachLogStoreFromEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *DetachLogStoreFromEndpointGroupResponse) SetHeaders(v map[string]*string) *DetachLogStoreFromEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *DetachLogStoreFromEndpointGroupResponse) SetStatusCode(v int32) *DetachLogStoreFromEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachLogStoreFromEndpointGroupResponse) SetBody(v *DetachLogStoreFromEndpointGroupResponseBody) *DetachLogStoreFromEndpointGroupResponse {
	s.Body = v
	return s
}

type DetectApplicationMonitorRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the origin probing task for which you want to enable the diagnostic feature.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DetectApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DetectApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *DetectApplicationMonitorRequest) SetClientToken(v string) *DetectApplicationMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *DetectApplicationMonitorRequest) SetRegionId(v string) *DetectApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *DetectApplicationMonitorRequest) SetTaskId(v string) *DetectApplicationMonitorRequest {
	s.TaskId = &v
	return s
}

type DetectApplicationMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetectApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetectApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DetectApplicationMonitorResponseBody) SetRequestId(v string) *DetectApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DetectApplicationMonitorResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetectApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetectApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DetectApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *DetectApplicationMonitorResponse) SetHeaders(v map[string]*string) *DetectApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *DetectApplicationMonitorResponse) SetStatusCode(v int32) *DetectApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DetectApplicationMonitorResponse) SetBody(v *DetectApplicationMonitorResponseBody) *DetectApplicationMonitorResponse {
	s.Body = v
	return s
}

type DisableApplicationMonitorRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the origin probing task that you want to disable.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DisableApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *DisableApplicationMonitorRequest) SetClientToken(v string) *DisableApplicationMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *DisableApplicationMonitorRequest) SetRegionId(v string) *DisableApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *DisableApplicationMonitorRequest) SetTaskId(v string) *DisableApplicationMonitorRequest {
	s.TaskId = &v
	return s
}

type DisableApplicationMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DisableApplicationMonitorResponseBody) SetRequestId(v string) *DisableApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DisableApplicationMonitorResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *DisableApplicationMonitorResponse) SetHeaders(v map[string]*string) *DisableApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *DisableApplicationMonitorResponse) SetStatusCode(v int32) *DisableApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableApplicationMonitorResponse) SetBody(v *DisableApplicationMonitorResponseBody) *DisableApplicationMonitorResponse {
	s.Body = v
	return s
}

type DissociateAclsFromListenerRequest struct {
	// The ID of the ACL. You can disassociate up to two ACLs from a listener.
	AclIds []*string `json:"AclIds,omitempty" xml:"AclIds,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to only precheck the request. Default value: false. Valid values:
	//
	// *   **true**: prechecks the request without performing the operation. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DissociateAclsFromListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s DissociateAclsFromListenerRequest) GoString() string {
	return s.String()
}

func (s *DissociateAclsFromListenerRequest) SetAclIds(v []*string) *DissociateAclsFromListenerRequest {
	s.AclIds = v
	return s
}

func (s *DissociateAclsFromListenerRequest) SetClientToken(v string) *DissociateAclsFromListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *DissociateAclsFromListenerRequest) SetDryRun(v bool) *DissociateAclsFromListenerRequest {
	s.DryRun = &v
	return s
}

func (s *DissociateAclsFromListenerRequest) SetListenerId(v string) *DissociateAclsFromListenerRequest {
	s.ListenerId = &v
	return s
}

func (s *DissociateAclsFromListenerRequest) SetRegionId(v string) *DissociateAclsFromListenerRequest {
	s.RegionId = &v
	return s
}

type DissociateAclsFromListenerResponseBody struct {
	// The IDs of the ACL.
	AclIds []*string `json:"AclIds,omitempty" xml:"AclIds,omitempty" type:"Repeated"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DissociateAclsFromListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DissociateAclsFromListenerResponseBody) GoString() string {
	return s.String()
}

func (s *DissociateAclsFromListenerResponseBody) SetAclIds(v []*string) *DissociateAclsFromListenerResponseBody {
	s.AclIds = v
	return s
}

func (s *DissociateAclsFromListenerResponseBody) SetListenerId(v string) *DissociateAclsFromListenerResponseBody {
	s.ListenerId = &v
	return s
}

func (s *DissociateAclsFromListenerResponseBody) SetRequestId(v string) *DissociateAclsFromListenerResponseBody {
	s.RequestId = &v
	return s
}

type DissociateAclsFromListenerResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DissociateAclsFromListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DissociateAclsFromListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s DissociateAclsFromListenerResponse) GoString() string {
	return s.String()
}

func (s *DissociateAclsFromListenerResponse) SetHeaders(v map[string]*string) *DissociateAclsFromListenerResponse {
	s.Headers = v
	return s
}

func (s *DissociateAclsFromListenerResponse) SetStatusCode(v int32) *DissociateAclsFromListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *DissociateAclsFromListenerResponse) SetBody(v *DissociateAclsFromListenerResponseBody) *DissociateAclsFromListenerResponse {
	s.Body = v
	return s
}

type DissociateAdditionalCertificatesFromListenerRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The domain name associated with the additional certificate.
	//
	// You can specify up to 10 domain names in each request.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DissociateAdditionalCertificatesFromListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s DissociateAdditionalCertificatesFromListenerRequest) GoString() string {
	return s.String()
}

func (s *DissociateAdditionalCertificatesFromListenerRequest) SetAcceleratorId(v string) *DissociateAdditionalCertificatesFromListenerRequest {
	s.AcceleratorId = &v
	return s
}

func (s *DissociateAdditionalCertificatesFromListenerRequest) SetClientToken(v string) *DissociateAdditionalCertificatesFromListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *DissociateAdditionalCertificatesFromListenerRequest) SetDomains(v []*string) *DissociateAdditionalCertificatesFromListenerRequest {
	s.Domains = v
	return s
}

func (s *DissociateAdditionalCertificatesFromListenerRequest) SetListenerId(v string) *DissociateAdditionalCertificatesFromListenerRequest {
	s.ListenerId = &v
	return s
}

func (s *DissociateAdditionalCertificatesFromListenerRequest) SetRegionId(v string) *DissociateAdditionalCertificatesFromListenerRequest {
	s.RegionId = &v
	return s
}

type DissociateAdditionalCertificatesFromListenerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DissociateAdditionalCertificatesFromListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DissociateAdditionalCertificatesFromListenerResponseBody) GoString() string {
	return s.String()
}

func (s *DissociateAdditionalCertificatesFromListenerResponseBody) SetRequestId(v string) *DissociateAdditionalCertificatesFromListenerResponseBody {
	s.RequestId = &v
	return s
}

type DissociateAdditionalCertificatesFromListenerResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DissociateAdditionalCertificatesFromListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DissociateAdditionalCertificatesFromListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s DissociateAdditionalCertificatesFromListenerResponse) GoString() string {
	return s.String()
}

func (s *DissociateAdditionalCertificatesFromListenerResponse) SetHeaders(v map[string]*string) *DissociateAdditionalCertificatesFromListenerResponse {
	s.Headers = v
	return s
}

func (s *DissociateAdditionalCertificatesFromListenerResponse) SetStatusCode(v int32) *DissociateAdditionalCertificatesFromListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *DissociateAdditionalCertificatesFromListenerResponse) SetBody(v *DissociateAdditionalCertificatesFromListenerResponseBody) *DissociateAdditionalCertificatesFromListenerResponse {
	s.Body = v
	return s
}

type EnableApplicationMonitorRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the origin probing task that you want to enable.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s EnableApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *EnableApplicationMonitorRequest) SetClientToken(v string) *EnableApplicationMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *EnableApplicationMonitorRequest) SetRegionId(v string) *EnableApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *EnableApplicationMonitorRequest) SetTaskId(v string) *EnableApplicationMonitorRequest {
	s.TaskId = &v
	return s
}

type EnableApplicationMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *EnableApplicationMonitorResponseBody) SetRequestId(v string) *EnableApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

type EnableApplicationMonitorResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *EnableApplicationMonitorResponse) SetHeaders(v map[string]*string) *EnableApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *EnableApplicationMonitorResponse) SetStatusCode(v int32) *EnableApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableApplicationMonitorResponse) SetBody(v *EnableApplicationMonitorResponseBody) *EnableApplicationMonitorResponse {
	s.Body = v
	return s
}

type GetAclRequest struct {
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The operation that you want to perform. Set the value to **GetAcl**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetAclRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAclRequest) GoString() string {
	return s.String()
}

func (s *GetAclRequest) SetAclId(v string) *GetAclRequest {
	s.AclId = &v
	return s
}

func (s *GetAclRequest) SetRegionId(v string) *GetAclRequest {
	s.RegionId = &v
	return s
}

type GetAclResponseBody struct {
	// The state of the network ACL. Valid values:
	//
	// *   **init**: The network ACL is being initialized.
	// *   **active**: The network ACL is available.
	// *   **configuring**: The network ACL is being configured.
	// *   **updating**: The network ACL is being updated.
	// *   **deleting**: The network ACL is being deleted.
	AclEntries []*GetAclResponseBodyAclEntries `json:"AclEntries,omitempty" xml:"AclEntries,omitempty" type:"Repeated"`
	// The ID of the request.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the GA instance.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The IP version of the network ACL. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The ID of the network ACL.
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	// The description of the network ACL entry.
	RelatedListeners []*GetAclResponseBodyRelatedListeners `json:"RelatedListeners,omitempty" xml:"RelatedListeners,omitempty" type:"Repeated"`
	// The ID of the network ACL.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the network ACL.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the resource group.
	Tags []*GetAclResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAclResponseBody) GoString() string {
	return s.String()
}

func (s *GetAclResponseBody) SetAclEntries(v []*GetAclResponseBodyAclEntries) *GetAclResponseBody {
	s.AclEntries = v
	return s
}

func (s *GetAclResponseBody) SetAclId(v string) *GetAclResponseBody {
	s.AclId = &v
	return s
}

func (s *GetAclResponseBody) SetAclName(v string) *GetAclResponseBody {
	s.AclName = &v
	return s
}

func (s *GetAclResponseBody) SetAclStatus(v string) *GetAclResponseBody {
	s.AclStatus = &v
	return s
}

func (s *GetAclResponseBody) SetAddressIPVersion(v string) *GetAclResponseBody {
	s.AddressIPVersion = &v
	return s
}

func (s *GetAclResponseBody) SetRelatedListeners(v []*GetAclResponseBodyRelatedListeners) *GetAclResponseBody {
	s.RelatedListeners = v
	return s
}

func (s *GetAclResponseBody) SetRequestId(v string) *GetAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAclResponseBody) SetResourceGroupId(v string) *GetAclResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *GetAclResponseBody) SetTags(v []*GetAclResponseBodyTags) *GetAclResponseBody {
	s.Tags = v
	return s
}

type GetAclResponseBodyAclEntries struct {
	// The list of network ACL entries that are returned. A maximum of 20 network ACL entries can be returned.
	Entry *string `json:"Entry,omitempty" xml:"Entry,omitempty"`
	// The network ACL entry.
	EntryDescription *string `json:"EntryDescription,omitempty" xml:"EntryDescription,omitempty"`
}

func (s GetAclResponseBodyAclEntries) String() string {
	return tea.Prettify(s)
}

func (s GetAclResponseBodyAclEntries) GoString() string {
	return s.String()
}

func (s *GetAclResponseBodyAclEntries) SetEntry(v string) *GetAclResponseBodyAclEntries {
	s.Entry = &v
	return s
}

func (s *GetAclResponseBodyAclEntries) SetEntryDescription(v string) *GetAclResponseBodyAclEntries {
	s.EntryDescription = &v
	return s
}

type GetAclResponseBodyRelatedListeners struct {
	// The type of the network ACL.
	//
	// *   **White**: a whitelist. Only requests from the IP addresses or CIDR blocks in the ACL are forwarded. Whitelists apply to scenarios in which you want to allow only specified IP addresses to access an application. Your service may be adversely affected if the whitelist is not properly configured. After you configure a whitelist for a listener, only requests from the IP addresses that are added to the whitelist are forwarded by the listener. If the whitelist is enabled but no IP addresses are added to the network ACL, the listener does not forward requests.
	// *   **Black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are blocked. Blacklists apply to scenarios in which you want to deny access from specific IP addresses to an application. If the blacklist is enabled but no IP addresses are added to the network ACL, the listener forwards all requests.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the listener.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The listeners that are associated with the network ACL.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
}

func (s GetAclResponseBodyRelatedListeners) String() string {
	return tea.Prettify(s)
}

func (s GetAclResponseBodyRelatedListeners) GoString() string {
	return s.String()
}

func (s *GetAclResponseBodyRelatedListeners) SetAcceleratorId(v string) *GetAclResponseBodyRelatedListeners {
	s.AcceleratorId = &v
	return s
}

func (s *GetAclResponseBodyRelatedListeners) SetAclType(v string) *GetAclResponseBodyRelatedListeners {
	s.AclType = &v
	return s
}

func (s *GetAclResponseBodyRelatedListeners) SetListenerId(v string) *GetAclResponseBodyRelatedListeners {
	s.ListenerId = &v
	return s
}

type GetAclResponseBodyTags struct {
	// The tags of the ACL.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag key
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetAclResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s GetAclResponseBodyTags) GoString() string {
	return s.String()
}

func (s *GetAclResponseBodyTags) SetKey(v string) *GetAclResponseBodyTags {
	s.Key = &v
	return s
}

func (s *GetAclResponseBodyTags) SetValue(v string) *GetAclResponseBodyTags {
	s.Value = &v
	return s
}

type GetAclResponse struct {
	Headers    map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAclResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAclResponse) GoString() string {
	return s.String()
}

func (s *GetAclResponse) SetHeaders(v map[string]*string) *GetAclResponse {
	s.Headers = v
	return s
}

func (s *GetAclResponse) SetStatusCode(v int32) *GetAclResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAclResponse) SetBody(v *GetAclResponseBody) *GetAclResponse {
	s.Body = v
	return s
}

type GetBasicAccelerateIpRequest struct {
	// The ID of the accelerated IP address that you want to query.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetBasicAccelerateIpRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpRequest) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpRequest) SetAccelerateIpId(v string) *GetBasicAccelerateIpRequest {
	s.AccelerateIpId = &v
	return s
}

func (s *GetBasicAccelerateIpRequest) SetClientToken(v string) *GetBasicAccelerateIpRequest {
	s.ClientToken = &v
	return s
}

func (s *GetBasicAccelerateIpRequest) SetRegionId(v string) *GetBasicAccelerateIpRequest {
	s.RegionId = &v
	return s
}

type GetBasicAccelerateIpResponseBody struct {
	// The accelerated IP address.
	AccelerateIpAddress *string `json:"AccelerateIpAddress,omitempty" xml:"AccelerateIpAddress,omitempty"`
	// The ID of the accelerated IP address.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance to which the queried accelerated IP address belongs.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the acceleration region of the basic GA instance.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the accelerated IP address. Valid values:
	//
	// *   **active**: The accelerated IP address is available.
	// *   **binding**: The accelerated IP address is being associated.
	// *   **bound**: The accelerated IP address is associated.
	// *   **unbinding**: The basic GA instance is being disassociated.
	// *   **deleting**: The accelerated IP address is being deleted.
	//
	// >  This parameter is not returned when the queried accelerated IP address is being created.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetBasicAccelerateIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpResponseBody) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpResponseBody) SetAccelerateIpAddress(v string) *GetBasicAccelerateIpResponseBody {
	s.AccelerateIpAddress = &v
	return s
}

func (s *GetBasicAccelerateIpResponseBody) SetAccelerateIpId(v string) *GetBasicAccelerateIpResponseBody {
	s.AccelerateIpId = &v
	return s
}

func (s *GetBasicAccelerateIpResponseBody) SetAcceleratorId(v string) *GetBasicAccelerateIpResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicAccelerateIpResponseBody) SetIpSetId(v string) *GetBasicAccelerateIpResponseBody {
	s.IpSetId = &v
	return s
}

func (s *GetBasicAccelerateIpResponseBody) SetRequestId(v string) *GetBasicAccelerateIpResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBasicAccelerateIpResponseBody) SetState(v string) *GetBasicAccelerateIpResponseBody {
	s.State = &v
	return s
}

type GetBasicAccelerateIpResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBasicAccelerateIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBasicAccelerateIpResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpResponse) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpResponse) SetHeaders(v map[string]*string) *GetBasicAccelerateIpResponse {
	s.Headers = v
	return s
}

func (s *GetBasicAccelerateIpResponse) SetStatusCode(v int32) *GetBasicAccelerateIpResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBasicAccelerateIpResponse) SetBody(v *GetBasicAccelerateIpResponseBody) *GetBasicAccelerateIpResponse {
	s.Body = v
	return s
}

type GetBasicAccelerateIpEndpointRelationRequest struct {
	// The ID of the accelerated IP address.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetBasicAccelerateIpEndpointRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpEndpointRelationRequest) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpEndpointRelationRequest) SetAccelerateIpId(v string) *GetBasicAccelerateIpEndpointRelationRequest {
	s.AccelerateIpId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationRequest) SetAcceleratorId(v string) *GetBasicAccelerateIpEndpointRelationRequest {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationRequest) SetClientToken(v string) *GetBasicAccelerateIpEndpointRelationRequest {
	s.ClientToken = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationRequest) SetEndpointId(v string) *GetBasicAccelerateIpEndpointRelationRequest {
	s.EndpointId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationRequest) SetRegionId(v string) *GetBasicAccelerateIpEndpointRelationRequest {
	s.RegionId = &v
	return s
}

type GetBasicAccelerateIpEndpointRelationResponseBody struct {
	// The ID of the accelerated IP address.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the endpoint.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, **EndpointSubAddress** returns the primary or secondary private IP address of the primary ENI.
	// *   If the endpoint type is **ENI**, **EndpointSubAddress** returns the primary or secondary private IP address of the secondary ENI.
	// *   If the endpoint type is **NLB**, **EndpointSubAddress** returns the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of the secondary address of the endpoint.
	//
	// *   **primary**: a primary private IP address.
	// *   **secondary**: a secondary private IP address.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**. If the endpoint type is set to **NLB**, **primary** is returned.
	EndpointSubAddressType *string `json:"EndpointSubAddressType,omitempty" xml:"EndpointSubAddressType,omitempty"`
	// The type of endpoint. Valid values:
	//
	// *   **ENI**: elastic network interface (ENI).
	// *   **SLB**: Classic Load Balancer (CLB) instance.
	// *   **ECS**: Elastic Compute Service (ECS) instance.
	// *   **NLB**: Network Load Balancer (NLB) instance.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The ID of the zone where the endpoint is created.
	//
	// This parameter is returned only when the endpoint type is **NLB**.
	EndpointZoneId *string `json:"EndpointZoneId,omitempty" xml:"EndpointZoneId,omitempty"`
	// The accelerated IP address of the basic GA instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The association status between the accelerated IP address and endpoint.
	//
	// A value of **active** indicates that the accelerated IP address is associated with the endpoint.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetBasicAccelerateIpEndpointRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpEndpointRelationResponseBody) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetAccelerateIpId(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.AccelerateIpId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetAcceleratorId(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetEndpointAddress(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointAddress = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetEndpointId(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetEndpointName(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointName = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetEndpointSubAddress(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointSubAddress = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetEndpointSubAddressType(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointSubAddressType = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetEndpointType(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointType = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetEndpointZoneId(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.EndpointZoneId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetIpAddress(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.IpAddress = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetRequestId(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponseBody) SetState(v string) *GetBasicAccelerateIpEndpointRelationResponseBody {
	s.State = &v
	return s
}

type GetBasicAccelerateIpEndpointRelationResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBasicAccelerateIpEndpointRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBasicAccelerateIpEndpointRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpEndpointRelationResponse) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpEndpointRelationResponse) SetHeaders(v map[string]*string) *GetBasicAccelerateIpEndpointRelationResponse {
	s.Headers = v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponse) SetStatusCode(v int32) *GetBasicAccelerateIpEndpointRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBasicAccelerateIpEndpointRelationResponse) SetBody(v *GetBasicAccelerateIpEndpointRelationResponseBody) *GetBasicAccelerateIpEndpointRelationResponse {
	s.Body = v
	return s
}

type GetBasicAccelerateIpIdleCountRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetBasicAccelerateIpIdleCountRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpIdleCountRequest) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpIdleCountRequest) SetClientToken(v string) *GetBasicAccelerateIpIdleCountRequest {
	s.ClientToken = &v
	return s
}

func (s *GetBasicAccelerateIpIdleCountRequest) SetIpSetId(v string) *GetBasicAccelerateIpIdleCountRequest {
	s.IpSetId = &v
	return s
}

func (s *GetBasicAccelerateIpIdleCountRequest) SetRegionId(v string) *GetBasicAccelerateIpIdleCountRequest {
	s.RegionId = &v
	return s
}

type GetBasicAccelerateIpIdleCountResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned, which indicates the number of idle accelerated IP addresses.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetBasicAccelerateIpIdleCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpIdleCountResponseBody) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpIdleCountResponseBody) SetRequestId(v string) *GetBasicAccelerateIpIdleCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBasicAccelerateIpIdleCountResponseBody) SetTotalCount(v int64) *GetBasicAccelerateIpIdleCountResponseBody {
	s.TotalCount = &v
	return s
}

type GetBasicAccelerateIpIdleCountResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBasicAccelerateIpIdleCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBasicAccelerateIpIdleCountResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAccelerateIpIdleCountResponse) GoString() string {
	return s.String()
}

func (s *GetBasicAccelerateIpIdleCountResponse) SetHeaders(v map[string]*string) *GetBasicAccelerateIpIdleCountResponse {
	s.Headers = v
	return s
}

func (s *GetBasicAccelerateIpIdleCountResponse) SetStatusCode(v int32) *GetBasicAccelerateIpIdleCountResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBasicAccelerateIpIdleCountResponse) SetBody(v *GetBasicAccelerateIpIdleCountResponseBody) *GetBasicAccelerateIpIdleCountResponse {
	s.Body = v
	return s
}

type GetBasicAcceleratorRequest struct {
	// The ID of the basic GA instance that you want to query.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region to which the basic GA instance belongs. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetBasicAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *GetBasicAcceleratorRequest) SetAcceleratorId(v string) *GetBasicAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicAcceleratorRequest) SetRegionId(v string) *GetBasicAcceleratorRequest {
	s.RegionId = &v
	return s
}

type GetBasicAcceleratorResponseBody struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth metering method.
	//
	// *   **BandwidthPackage**: billed based on bandwidth plans.
	// *   **CDT**: billed by Cloud Data Transfer (CDT) and based on data transfer.
	// *   **CDT95**: billed by CDT and based on the 95th percentile bandwidth. This bandwidth metering method is available only to users that are included in the whitelist.
	BandwidthBillingType *string `json:"BandwidthBillingType,omitempty" xml:"BandwidthBillingType,omitempty"`
	// The details about the basic bandwidth plan that is associated with the basic GA instance.
	BasicBandwidthPackage *GetBasicAcceleratorResponseBodyBasicBandwidthPackage `json:"BasicBandwidthPackage,omitempty" xml:"BasicBandwidthPackage,omitempty" type:"Struct"`
	// The ID of the endpoint group.
	BasicEndpointGroupId *string `json:"BasicEndpointGroupId,omitempty" xml:"BasicEndpointGroupId,omitempty"`
	// The ID of the acceleration region.
	BasicIpSetId *string `json:"BasicIpSetId,omitempty" xml:"BasicIpSetId,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance to which the basic GA instance is attached.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The timestamp that indicates when the basic GA instance is created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// 基础型全球加速实例是否开启跨境线路功能。取值：
	//
	// - **true**：开启跨境线路功能，可以加速跨境线路。
	//
	// - **false**：关闭跨境线路功能，不可以加速跨境线路。
	CrossBorderStatus *bool `json:"CrossBorderStatus,omitempty" xml:"CrossBorderStatus,omitempty"`
	// The details about the cross-border acceleration bandwidth plan that is associated with the GA instance.
	//
	// This array is returned only for GA instances that are created on the international site (alibabacloud.com).
	CrossDomainBandwidthPackage *GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage `json:"CrossDomainBandwidthPackage,omitempty" xml:"CrossDomainBandwidthPackage,omitempty" type:"Struct"`
	// Indicates whether cross-border acceleration is enabled.
	//
	// *   **true**: yes
	// *   **false**: no
	CrossPrivateState *string `json:"CrossPrivateState,omitempty" xml:"CrossPrivateState,omitempty"`
	// The description of the basic GA instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timestamp that indicates when the basic GA instance expires.
	//
	// The time follows the UNIX time format. It is the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	ExpiredTime *int64 `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The billing method of the basic GA instance. Only **PREPAY** is returned, which indicates the subscription billing method.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The name of the basic GA instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the basic GA instance is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the basic GA instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the basic GA instance.
	//
	// *   **init**: The GA instance is being initialized.
	// *   **active**: The GA instance is available.
	// *   **configuring**: The GA instance is being configured.
	// *   **binding**: The GA instance is being associated.
	// *   **unbinding**: The GA instance is being disassociated.
	// *   **deleting**: The GA instance is being deleted.
	// *   **finacialLocked**: The GA instance is locked due to overdue payments.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags of the basic GA instance.
	Tags []*GetBasicAcceleratorResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetBasicAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *GetBasicAcceleratorResponseBody) SetAcceleratorId(v string) *GetBasicAcceleratorResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetBandwidthBillingType(v string) *GetBasicAcceleratorResponseBody {
	s.BandwidthBillingType = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetBasicBandwidthPackage(v *GetBasicAcceleratorResponseBodyBasicBandwidthPackage) *GetBasicAcceleratorResponseBody {
	s.BasicBandwidthPackage = v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetBasicEndpointGroupId(v string) *GetBasicAcceleratorResponseBody {
	s.BasicEndpointGroupId = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetBasicIpSetId(v string) *GetBasicAcceleratorResponseBody {
	s.BasicIpSetId = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetCenId(v string) *GetBasicAcceleratorResponseBody {
	s.CenId = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetCreateTime(v int64) *GetBasicAcceleratorResponseBody {
	s.CreateTime = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetCrossBorderStatus(v bool) *GetBasicAcceleratorResponseBody {
	s.CrossBorderStatus = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetCrossDomainBandwidthPackage(v *GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage) *GetBasicAcceleratorResponseBody {
	s.CrossDomainBandwidthPackage = v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetCrossPrivateState(v string) *GetBasicAcceleratorResponseBody {
	s.CrossPrivateState = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetDescription(v string) *GetBasicAcceleratorResponseBody {
	s.Description = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetExpiredTime(v int64) *GetBasicAcceleratorResponseBody {
	s.ExpiredTime = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetInstanceChargeType(v string) *GetBasicAcceleratorResponseBody {
	s.InstanceChargeType = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetName(v string) *GetBasicAcceleratorResponseBody {
	s.Name = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetRegionId(v string) *GetBasicAcceleratorResponseBody {
	s.RegionId = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetRequestId(v string) *GetBasicAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetResourceGroupId(v string) *GetBasicAcceleratorResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetState(v string) *GetBasicAcceleratorResponseBody {
	s.State = &v
	return s
}

func (s *GetBasicAcceleratorResponseBody) SetTags(v []*GetBasicAcceleratorResponseBodyTags) *GetBasicAcceleratorResponseBody {
	s.Tags = v
	return s
}

type GetBasicAcceleratorResponseBodyBasicBandwidthPackage struct {
	// The bandwidth value of the basic bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The type of the bandwidth that is provided by the basic bandwidth plan.
	//
	// *   **Basic**: basic
	// *   **Enhanced**: enhanced
	// *   **Advanced**: premium
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the basic bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s GetBasicAcceleratorResponseBodyBasicBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAcceleratorResponseBodyBasicBandwidthPackage) GoString() string {
	return s.String()
}

func (s *GetBasicAcceleratorResponseBodyBasicBandwidthPackage) SetBandwidth(v int32) *GetBasicAcceleratorResponseBodyBasicBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *GetBasicAcceleratorResponseBodyBasicBandwidthPackage) SetBandwidthType(v string) *GetBasicAcceleratorResponseBodyBasicBandwidthPackage {
	s.BandwidthType = &v
	return s
}

func (s *GetBasicAcceleratorResponseBodyBasicBandwidthPackage) SetInstanceId(v string) *GetBasicAcceleratorResponseBodyBasicBandwidthPackage {
	s.InstanceId = &v
	return s
}

type GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage struct {
	// The bandwidth value of the cross-border acceleration bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the cross-border acceleration bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage) GoString() string {
	return s.String()
}

func (s *GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage) SetBandwidth(v int32) *GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage) SetInstanceId(v string) *GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage {
	s.InstanceId = &v
	return s
}

type GetBasicAcceleratorResponseBodyTags struct {
	// The tag key of the basic GA instance.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the basic GA instance.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetBasicAcceleratorResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAcceleratorResponseBodyTags) GoString() string {
	return s.String()
}

func (s *GetBasicAcceleratorResponseBodyTags) SetKey(v string) *GetBasicAcceleratorResponseBodyTags {
	s.Key = &v
	return s
}

func (s *GetBasicAcceleratorResponseBodyTags) SetValue(v string) *GetBasicAcceleratorResponseBodyTags {
	s.Value = &v
	return s
}

type GetBasicAcceleratorResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBasicAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBasicAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBasicAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *GetBasicAcceleratorResponse) SetHeaders(v map[string]*string) *GetBasicAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *GetBasicAcceleratorResponse) SetStatusCode(v int32) *GetBasicAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBasicAcceleratorResponse) SetBody(v *GetBasicAcceleratorResponseBody) *GetBasicAcceleratorResponse {
	s.Body = v
	return s
}

type GetBasicEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint that you want to query.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetBasicEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBasicEndpointRequest) GoString() string {
	return s.String()
}

func (s *GetBasicEndpointRequest) SetClientToken(v string) *GetBasicEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *GetBasicEndpointRequest) SetEndpointId(v string) *GetBasicEndpointRequest {
	s.EndpointId = &v
	return s
}

func (s *GetBasicEndpointRequest) SetRegionId(v string) *GetBasicEndpointRequest {
	s.RegionId = &v
	return s
}

type GetBasicEndpointResponseBody struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint that is associated with the basic GA instance.
	EndPointId *string `json:"EndPointId,omitempty" xml:"EndPointId,omitempty"`
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint group to which the endpoint belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, **EndpointSubAddress** returns the primary or secondary private IP address of the primary ENI.
	// *   If the endpoint type is **ENI**, **EndpointSubAddress** returns the primary or secondary private IP address of the secondary ENI.
	// *   If the endpoint type is **NLB**, **EndpointSubAddress** returns the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of the secondary address of the endpoint.
	//
	// *   **primary**: a primary private IP address.
	// *   **secondary**: a secondary private IP address.
	//
	// This parameter is returned if the type of the endpoint is set to **ECS**, **ENI**, or **NLB**. If the endpoint type is set to **NLB**, **primary** is returned.
	EndpointSubAddressType *string `json:"EndpointSubAddressType,omitempty" xml:"EndpointSubAddressType,omitempty"`
	// The type of endpoint. Valid values:
	//
	// *   **ENI**: elastic network interface (ENI).
	// *   **SLB**: Classic Load Balancer (CLB) instance.
	// *   **ECS**: Elastic Compute Service (ECS) instance.
	// *   **NLB**: Network Load Balancer (NLB) instance.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The ID of the zone where the endpoint is deployed.
	//
	// This parameter is returned only when the endpoint type is set to **NLB**.
	EndpointZoneId *string `json:"EndpointZoneId,omitempty" xml:"EndpointZoneId,omitempty"`
	// The name of the endpoint.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the endpoint. Valid values:
	//
	// *   **init**: The endpoint is being initialized.
	// *   **active**: The endpoint is available.
	// *   **updating**: The endpoint is being configured.
	// *   **binding**: The endpoint is being associated.
	// *   **unbinding**: The endpoint is being disassociated.
	// *   **deleting**: The endpoint is being deleted.
	// *   **bound**: The endpoint is associated.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetBasicEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBasicEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *GetBasicEndpointResponseBody) SetAcceleratorId(v string) *GetBasicEndpointResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetEndPointId(v string) *GetBasicEndpointResponseBody {
	s.EndPointId = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetEndpointAddress(v string) *GetBasicEndpointResponseBody {
	s.EndpointAddress = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetEndpointGroupId(v string) *GetBasicEndpointResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetEndpointSubAddress(v string) *GetBasicEndpointResponseBody {
	s.EndpointSubAddress = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetEndpointSubAddressType(v string) *GetBasicEndpointResponseBody {
	s.EndpointSubAddressType = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetEndpointType(v string) *GetBasicEndpointResponseBody {
	s.EndpointType = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetEndpointZoneId(v string) *GetBasicEndpointResponseBody {
	s.EndpointZoneId = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetName(v string) *GetBasicEndpointResponseBody {
	s.Name = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetRequestId(v string) *GetBasicEndpointResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBasicEndpointResponseBody) SetState(v string) *GetBasicEndpointResponseBody {
	s.State = &v
	return s
}

type GetBasicEndpointResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBasicEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBasicEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBasicEndpointResponse) GoString() string {
	return s.String()
}

func (s *GetBasicEndpointResponse) SetHeaders(v map[string]*string) *GetBasicEndpointResponse {
	s.Headers = v
	return s
}

func (s *GetBasicEndpointResponse) SetStatusCode(v int32) *GetBasicEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBasicEndpointResponse) SetBody(v *GetBasicEndpointResponseBody) *GetBasicEndpointResponse {
	s.Body = v
	return s
}

type GetBasicEndpointGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region where the basic GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetBasicEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBasicEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *GetBasicEndpointGroupRequest) SetClientToken(v string) *GetBasicEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *GetBasicEndpointGroupRequest) SetEndpointGroupId(v string) *GetBasicEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *GetBasicEndpointGroupRequest) SetRegionId(v string) *GetBasicEndpointGroupRequest {
	s.RegionId = &v
	return s
}

type GetBasicEndpointGroupResponseBody struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The description of the endpoint group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region where the endpoint group resides.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, **EndpointSubAddress** returns the primary or secondary private IP address of the primary ENI.
	// *   If the endpoint type is **ENI**, **EndpointSubAddress** returns the primary or secondary private IP address of the secondary ENI.
	// *   If the endpoint type is **NLB**, **EndpointSubAddress** returns the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of endpoint. Valid values:
	//
	// *   **ENI**: elastic network interface (ENI).
	// *   **SLB**: Classic Load Balancer (CLB) instance.
	// *   **ECS**: Elastic Compute Service (ECS) instance.
	// *   **NLB**: Network Load Balancer (NLB) instance
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The name of the endpoint group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the endpoint group. Valid values:
	//
	// *   **init**: being initialized.
	// *   **active**: running as expected.
	// *   **updating**: being updated.
	// *   **deleting**: being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetBasicEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBasicEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *GetBasicEndpointGroupResponseBody) SetAcceleratorId(v string) *GetBasicEndpointGroupResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetDescription(v string) *GetBasicEndpointGroupResponseBody {
	s.Description = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetEndpointAddress(v string) *GetBasicEndpointGroupResponseBody {
	s.EndpointAddress = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetEndpointGroupId(v string) *GetBasicEndpointGroupResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetEndpointGroupRegion(v string) *GetBasicEndpointGroupResponseBody {
	s.EndpointGroupRegion = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetEndpointSubAddress(v string) *GetBasicEndpointGroupResponseBody {
	s.EndpointSubAddress = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetEndpointType(v string) *GetBasicEndpointGroupResponseBody {
	s.EndpointType = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetName(v string) *GetBasicEndpointGroupResponseBody {
	s.Name = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetRequestId(v string) *GetBasicEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBasicEndpointGroupResponseBody) SetState(v string) *GetBasicEndpointGroupResponseBody {
	s.State = &v
	return s
}

type GetBasicEndpointGroupResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBasicEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBasicEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBasicEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *GetBasicEndpointGroupResponse) SetHeaders(v map[string]*string) *GetBasicEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *GetBasicEndpointGroupResponse) SetStatusCode(v int32) *GetBasicEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBasicEndpointGroupResponse) SetBody(v *GetBasicEndpointGroupResponseBody) *GetBasicEndpointGroupResponse {
	s.Body = v
	return s
}

type GetBasicIpSetRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region of the basic GA instance.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the region where the basic GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetBasicIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBasicIpSetRequest) GoString() string {
	return s.String()
}

func (s *GetBasicIpSetRequest) SetClientToken(v string) *GetBasicIpSetRequest {
	s.ClientToken = &v
	return s
}

func (s *GetBasicIpSetRequest) SetIpSetId(v string) *GetBasicIpSetRequest {
	s.IpSetId = &v
	return s
}

func (s *GetBasicIpSetRequest) SetRegionId(v string) *GetBasicIpSetRequest {
	s.RegionId = &v
	return s
}

type GetBasicIpSetResponseBody struct {
	// The ID of the region where the basic GA instance is deployed.
	AccelerateRegionId *string `json:"AccelerateRegionId,omitempty" xml:"AccelerateRegionId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth of the acceleration region of the basic GA instance. Unit: Mbit/s.
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The accelerated IP address.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The ID of the acceleration region of the basic GA instance.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The version of the accelerated IP address. Only **IPv4** is returned. This indicates that an IPv4 address is used.
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The line type of the elastic IP address (EIP) in the acceleration region. Valid values:
	//
	// *   **BGP** (default)
	// *   **BGP_PRO** If the acceleration region is China (Hong Kong) and a basic bandwidth plan whose bandwidth type is Premium is associated with the GA instance, the default value of IspType is BGP_PRO.
	//
	// If you are allowed to use single-ISP bandwidth, you can also specify one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom (single ISP)
	// *   **ChinaUnicom**: China Unicom (single ISP)
	// *   **ChinaMobile**: China Mobile (single ISP)
	// *   **ChinaTelecom_L2**: China Telecom \_L2 (single ISP)
	// *   **ChinaUnicom_L2**: China Unicom \_L2 (single ISP)
	// *   **ChinaMobile_L2**: China Mobile \_L2 (single ISP)
	//
	// > Different acceleration regions support different single-ISP BGP lines.
	IspType *string `json:"IspType,omitempty" xml:"IspType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the acceleration region of the basic GA instance. Valid values:
	//
	// *   **init**: The acceleration region is being initialized.
	// *   **active**: The acceleration region is in the running state.
	// *   **updating**: The acceleration region is being configured.
	// *   **Deleting**: The acceleration region is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetBasicIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBasicIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *GetBasicIpSetResponseBody) SetAccelerateRegionId(v string) *GetBasicIpSetResponseBody {
	s.AccelerateRegionId = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetAcceleratorId(v string) *GetBasicIpSetResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetBandwidth(v int64) *GetBasicIpSetResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetIpAddress(v string) *GetBasicIpSetResponseBody {
	s.IpAddress = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetIpSetId(v string) *GetBasicIpSetResponseBody {
	s.IpSetId = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetIpVersion(v string) *GetBasicIpSetResponseBody {
	s.IpVersion = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetIspType(v string) *GetBasicIpSetResponseBody {
	s.IspType = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetRequestId(v string) *GetBasicIpSetResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBasicIpSetResponseBody) SetState(v string) *GetBasicIpSetResponseBody {
	s.State = &v
	return s
}

type GetBasicIpSetResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetBasicIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetBasicIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBasicIpSetResponse) GoString() string {
	return s.String()
}

func (s *GetBasicIpSetResponse) SetHeaders(v map[string]*string) *GetBasicIpSetResponse {
	s.Headers = v
	return s
}

func (s *GetBasicIpSetResponse) SetStatusCode(v int32) *GetBasicIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBasicIpSetResponse) SetBody(v *GetBasicIpSetResponseBody) *GetBasicIpSetResponse {
	s.Body = v
	return s
}

type GetHealthStatusRequest struct {
	// The ID of the GA instance that you want to query.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** of each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck the request. Valid values:
	//
	// *   **true**: prechecks the request only. The health status of the listener is not queried. The system prechecks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends a normal request. If the request passes the precheck, a 2xx HTTP status code is returned and the health status of the listener is obtained.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetHealthStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetHealthStatusRequest) GoString() string {
	return s.String()
}

func (s *GetHealthStatusRequest) SetAcceleratorId(v string) *GetHealthStatusRequest {
	s.AcceleratorId = &v
	return s
}

func (s *GetHealthStatusRequest) SetClientToken(v string) *GetHealthStatusRequest {
	s.ClientToken = &v
	return s
}

func (s *GetHealthStatusRequest) SetDryRun(v bool) *GetHealthStatusRequest {
	s.DryRun = &v
	return s
}

func (s *GetHealthStatusRequest) SetListenerId(v string) *GetHealthStatusRequest {
	s.ListenerId = &v
	return s
}

func (s *GetHealthStatusRequest) SetRegionId(v string) *GetHealthStatusRequest {
	s.RegionId = &v
	return s
}

type GetHealthStatusResponseBody struct {
	// The information about the endpoint group.
	EndpointGroups []*GetHealthStatusResponseBodyEndpointGroups `json:"EndpointGroups,omitempty" xml:"EndpointGroups,omitempty" type:"Repeated"`
	// The health status of the listener. Valid values:
	//
	// *   **normal**: The listener is normal.
	// *   **Abnormal**: The listener is abnormal.
	// *   **partiallyAbnormal**: Some exceptions occur to the listener.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetHealthStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetHealthStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetHealthStatusResponseBody) SetEndpointGroups(v []*GetHealthStatusResponseBodyEndpointGroups) *GetHealthStatusResponseBody {
	s.EndpointGroups = v
	return s
}

func (s *GetHealthStatusResponseBody) SetHealthStatus(v string) *GetHealthStatusResponseBody {
	s.HealthStatus = &v
	return s
}

func (s *GetHealthStatusResponseBody) SetListenerId(v string) *GetHealthStatusResponseBody {
	s.ListenerId = &v
	return s
}

func (s *GetHealthStatusResponseBody) SetRequestId(v string) *GetHealthStatusResponseBody {
	s.RequestId = &v
	return s
}

type GetHealthStatusResponseBodyEndpointGroups struct {
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The type of the endpoint group. Valid values:
	//
	// *   **default**: a default endpoint group
	// *   **virtual**: a virtual endpoint group
	EndpointGroupType *string `json:"EndpointGroupType,omitempty" xml:"EndpointGroupType,omitempty"`
	// The information about the endpoints.
	Endpoints []*GetHealthStatusResponseBodyEndpointGroupsEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The IDs of the forwarding rules.
	ForwardingRuleIds []*string `json:"ForwardingRuleIds,omitempty" xml:"ForwardingRuleIds,omitempty" type:"Repeated"`
	// The health status of the endpoint group. Valid values:
	//
	// *   **init**: The endpoint group is being initialized.
	// *   **normal**: The endpoint group is normal.
	// *   **Abnormal**: The endpoint group is abnormal.
	// *   **partiallyAbnormal**: Some endpoint groups that are associated with the listener are abnormal.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
}

func (s GetHealthStatusResponseBodyEndpointGroups) String() string {
	return tea.Prettify(s)
}

func (s GetHealthStatusResponseBodyEndpointGroups) GoString() string {
	return s.String()
}

func (s *GetHealthStatusResponseBodyEndpointGroups) SetEndpointGroupId(v string) *GetHealthStatusResponseBodyEndpointGroups {
	s.EndpointGroupId = &v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroups) SetEndpointGroupType(v string) *GetHealthStatusResponseBodyEndpointGroups {
	s.EndpointGroupType = &v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroups) SetEndpoints(v []*GetHealthStatusResponseBodyEndpointGroupsEndpoints) *GetHealthStatusResponseBodyEndpointGroups {
	s.Endpoints = v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroups) SetForwardingRuleIds(v []*string) *GetHealthStatusResponseBodyEndpointGroups {
	s.ForwardingRuleIds = v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroups) SetHealthStatus(v string) *GetHealthStatusResponseBodyEndpointGroups {
	s.HealthStatus = &v
	return s
}

type GetHealthStatusResponseBodyEndpointGroupsEndpoints struct {
	// The IP address of the endpoint.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The health check details of the endpoint.
	//
	// >  This parameter is unavailable.
	HealthDetail *string `json:"HealthDetail,omitempty" xml:"HealthDetail,omitempty"`
	// The health status of the endpoint. Valid values:
	//
	// *   **init**: The endpoint is being initialized.
	// *   **normal**: The endpoint is normal.
	// *   **Abnormal**: The endpoint is abnormal.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The port that is used to connect to the endpoint.
	Port *int64 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Domain**: a custom domain name
	// *   **Ip**: a custom IP address
	// *   **PublicIp**: a public IP address provided by Alibaba Cloud
	// *   **ECS**: an Elastic Compute Service (ECS) instance
	// *   **SLB**: a Server Load Balancer (SLB) instance
	// *   **ALB**: an Application Load Balancer (ALB) instance
	// *   **OSS**: an Object Storage Service (OSS) bucket
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetHealthStatusResponseBodyEndpointGroupsEndpoints) String() string {
	return tea.Prettify(s)
}

func (s GetHealthStatusResponseBodyEndpointGroupsEndpoints) GoString() string {
	return s.String()
}

func (s *GetHealthStatusResponseBodyEndpointGroupsEndpoints) SetAddress(v string) *GetHealthStatusResponseBodyEndpointGroupsEndpoints {
	s.Address = &v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroupsEndpoints) SetEndpointId(v string) *GetHealthStatusResponseBodyEndpointGroupsEndpoints {
	s.EndpointId = &v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroupsEndpoints) SetHealthDetail(v string) *GetHealthStatusResponseBodyEndpointGroupsEndpoints {
	s.HealthDetail = &v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroupsEndpoints) SetHealthStatus(v string) *GetHealthStatusResponseBodyEndpointGroupsEndpoints {
	s.HealthStatus = &v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroupsEndpoints) SetPort(v int64) *GetHealthStatusResponseBodyEndpointGroupsEndpoints {
	s.Port = &v
	return s
}

func (s *GetHealthStatusResponseBodyEndpointGroupsEndpoints) SetType(v string) *GetHealthStatusResponseBodyEndpointGroupsEndpoints {
	s.Type = &v
	return s
}

type GetHealthStatusResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetHealthStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetHealthStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetHealthStatusResponse) GoString() string {
	return s.String()
}

func (s *GetHealthStatusResponse) SetHeaders(v map[string]*string) *GetHealthStatusResponse {
	s.Headers = v
	return s
}

func (s *GetHealthStatusResponse) SetStatusCode(v int32) *GetHealthStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetHealthStatusResponse) SetBody(v *GetHealthStatusResponseBody) *GetHealthStatusResponse {
	s.Body = v
	return s
}

type GetInvalidDomainCountRequest struct {
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetInvalidDomainCountRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInvalidDomainCountRequest) GoString() string {
	return s.String()
}

func (s *GetInvalidDomainCountRequest) SetRegionId(v string) *GetInvalidDomainCountRequest {
	s.RegionId = &v
	return s
}

type GetInvalidDomainCountResponseBody struct {
	// The number of invalid domain names.
	InvalidDomainCount *string `json:"InvalidDomainCount,omitempty" xml:"InvalidDomainCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetInvalidDomainCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInvalidDomainCountResponseBody) GoString() string {
	return s.String()
}

func (s *GetInvalidDomainCountResponseBody) SetInvalidDomainCount(v string) *GetInvalidDomainCountResponseBody {
	s.InvalidDomainCount = &v
	return s
}

func (s *GetInvalidDomainCountResponseBody) SetRequestId(v string) *GetInvalidDomainCountResponseBody {
	s.RequestId = &v
	return s
}

type GetInvalidDomainCountResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetInvalidDomainCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetInvalidDomainCountResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInvalidDomainCountResponse) GoString() string {
	return s.String()
}

func (s *GetInvalidDomainCountResponse) SetHeaders(v map[string]*string) *GetInvalidDomainCountResponse {
	s.Headers = v
	return s
}

func (s *GetInvalidDomainCountResponse) SetStatusCode(v int32) *GetInvalidDomainCountResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInvalidDomainCountResponse) SetBody(v *GetInvalidDomainCountResponseBody) *GetInvalidDomainCountResponse {
	s.Body = v
	return s
}

type GetIpsetsBandwidthLimitRequest struct {
	// The ID of the GA instance to be queried.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetIpsetsBandwidthLimitRequest) String() string {
	return tea.Prettify(s)
}

func (s GetIpsetsBandwidthLimitRequest) GoString() string {
	return s.String()
}

func (s *GetIpsetsBandwidthLimitRequest) SetAcceleratorId(v string) *GetIpsetsBandwidthLimitRequest {
	s.AcceleratorId = &v
	return s
}

func (s *GetIpsetsBandwidthLimitRequest) SetRegionId(v string) *GetIpsetsBandwidthLimitRequest {
	s.RegionId = &v
	return s
}

type GetIpsetsBandwidthLimitResponseBody struct {
	// The type of the bandwidth that is allocated.
	//
	// *   **ShareBandwidth:** shared bandwidth.
	// *   **ExclusiveBandwidth:** dedicated bandwidth.
	BandwidthAllocationType *string `json:"BandwidthAllocationType,omitempty" xml:"BandwidthAllocationType,omitempty"`
	// The maximum bandwidth of the acceleration area. Unit: Mbit/s.
	BandwidthLimit *int64 `json:"BandwidthLimit,omitempty" xml:"BandwidthLimit,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetIpsetsBandwidthLimitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetIpsetsBandwidthLimitResponseBody) GoString() string {
	return s.String()
}

func (s *GetIpsetsBandwidthLimitResponseBody) SetBandwidthAllocationType(v string) *GetIpsetsBandwidthLimitResponseBody {
	s.BandwidthAllocationType = &v
	return s
}

func (s *GetIpsetsBandwidthLimitResponseBody) SetBandwidthLimit(v int64) *GetIpsetsBandwidthLimitResponseBody {
	s.BandwidthLimit = &v
	return s
}

func (s *GetIpsetsBandwidthLimitResponseBody) SetRequestId(v string) *GetIpsetsBandwidthLimitResponseBody {
	s.RequestId = &v
	return s
}

type GetIpsetsBandwidthLimitResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetIpsetsBandwidthLimitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetIpsetsBandwidthLimitResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIpsetsBandwidthLimitResponse) GoString() string {
	return s.String()
}

func (s *GetIpsetsBandwidthLimitResponse) SetHeaders(v map[string]*string) *GetIpsetsBandwidthLimitResponse {
	s.Headers = v
	return s
}

func (s *GetIpsetsBandwidthLimitResponse) SetStatusCode(v int32) *GetIpsetsBandwidthLimitResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIpsetsBandwidthLimitResponse) SetBody(v *GetIpsetsBandwidthLimitResponseBody) *GetIpsetsBandwidthLimitResponse {
	s.Body = v
	return s
}

type GetSpareIpRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The secondary IP address that is associated with the CNAME. If the acceleration area becomes unavailable, GA redirects traffic to the secondary IP address.
	SpareIp *string `json:"SpareIp,omitempty" xml:"SpareIp,omitempty"`
}

func (s GetSpareIpRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSpareIpRequest) GoString() string {
	return s.String()
}

func (s *GetSpareIpRequest) SetAcceleratorId(v string) *GetSpareIpRequest {
	s.AcceleratorId = &v
	return s
}

func (s *GetSpareIpRequest) SetClientToken(v string) *GetSpareIpRequest {
	s.ClientToken = &v
	return s
}

func (s *GetSpareIpRequest) SetDryRun(v bool) *GetSpareIpRequest {
	s.DryRun = &v
	return s
}

func (s *GetSpareIpRequest) SetRegionId(v string) *GetSpareIpRequest {
	s.RegionId = &v
	return s
}

func (s *GetSpareIpRequest) SetSpareIp(v string) *GetSpareIpRequest {
	s.SpareIp = &v
	return s
}

type GetSpareIpResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the secondary IP address. Valid values:
	//
	// *   **active:** The secondary IP address is available.
	// *   **inuse:** The secondary IP address is in use.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetSpareIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSpareIpResponseBody) GoString() string {
	return s.String()
}

func (s *GetSpareIpResponseBody) SetRequestId(v string) *GetSpareIpResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSpareIpResponseBody) SetState(v string) *GetSpareIpResponseBody {
	s.State = &v
	return s
}

type GetSpareIpResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSpareIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSpareIpResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSpareIpResponse) GoString() string {
	return s.String()
}

func (s *GetSpareIpResponse) SetHeaders(v map[string]*string) *GetSpareIpResponse {
	s.Headers = v
	return s
}

func (s *GetSpareIpResponse) SetStatusCode(v int32) *GetSpareIpResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSpareIpResponse) SetBody(v *GetSpareIpResponseBody) *GetSpareIpResponse {
	s.Body = v
	return s
}

type ListAccelerateAreasRequest struct {
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListAccelerateAreasRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAccelerateAreasRequest) GoString() string {
	return s.String()
}

func (s *ListAccelerateAreasRequest) SetRegionId(v string) *ListAccelerateAreasRequest {
	s.RegionId = &v
	return s
}

type ListAccelerateAreasResponseBody struct {
	// The information about the areas.
	Areas []*ListAccelerateAreasResponseBodyAreas `json:"Areas,omitempty" xml:"Areas,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAccelerateAreasResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAccelerateAreasResponseBody) GoString() string {
	return s.String()
}

func (s *ListAccelerateAreasResponseBody) SetAreas(v []*ListAccelerateAreasResponseBodyAreas) *ListAccelerateAreasResponseBody {
	s.Areas = v
	return s
}

func (s *ListAccelerateAreasResponseBody) SetRequestId(v string) *ListAccelerateAreasResponseBody {
	s.RequestId = &v
	return s
}

type ListAccelerateAreasResponseBodyAreas struct {
	// The area ID.
	AreaId *string `json:"AreaId,omitempty" xml:"AreaId,omitempty"`
	// The area name.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The regions in the acceleration area.
	RegionList []*ListAccelerateAreasResponseBodyAreasRegionList `json:"RegionList,omitempty" xml:"RegionList,omitempty" type:"Repeated"`
}

func (s ListAccelerateAreasResponseBodyAreas) String() string {
	return tea.Prettify(s)
}

func (s ListAccelerateAreasResponseBodyAreas) GoString() string {
	return s.String()
}

func (s *ListAccelerateAreasResponseBodyAreas) SetAreaId(v string) *ListAccelerateAreasResponseBodyAreas {
	s.AreaId = &v
	return s
}

func (s *ListAccelerateAreasResponseBodyAreas) SetLocalName(v string) *ListAccelerateAreasResponseBodyAreas {
	s.LocalName = &v
	return s
}

func (s *ListAccelerateAreasResponseBodyAreas) SetRegionList(v []*ListAccelerateAreasResponseBodyAreasRegionList) *ListAccelerateAreasResponseBodyAreas {
	s.RegionList = v
	return s
}

type ListAccelerateAreasResponseBodyAreasRegionList struct {
	// The region name.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListAccelerateAreasResponseBodyAreasRegionList) String() string {
	return tea.Prettify(s)
}

func (s ListAccelerateAreasResponseBodyAreasRegionList) GoString() string {
	return s.String()
}

func (s *ListAccelerateAreasResponseBodyAreasRegionList) SetLocalName(v string) *ListAccelerateAreasResponseBodyAreasRegionList {
	s.LocalName = &v
	return s
}

func (s *ListAccelerateAreasResponseBodyAreasRegionList) SetRegionId(v string) *ListAccelerateAreasResponseBodyAreasRegionList {
	s.RegionId = &v
	return s
}

type ListAccelerateAreasResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAccelerateAreasResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAccelerateAreasResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAccelerateAreasResponse) GoString() string {
	return s.String()
}

func (s *ListAccelerateAreasResponse) SetHeaders(v map[string]*string) *ListAccelerateAreasResponse {
	s.Headers = v
	return s
}

func (s *ListAccelerateAreasResponse) SetStatusCode(v int32) *ListAccelerateAreasResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAccelerateAreasResponse) SetBody(v *ListAccelerateAreasResponseBody) *ListAccelerateAreasResponse {
	s.Body = v
	return s
}

type ListAcceleratorsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the GA instance. Valid values:
	//
	// *   **init**: The GA instance is being initialized.
	// *   **active**: The GA instance is available.
	// *   **configuring**: The GA instance is being configured.
	// *   **binding**: The GA instance is being associated.
	// *   **unbinding**: The GA instance is being disassociated.
	// *   **deleting**: The GA instance is being deleted.
	// *   **finacialLocked**: The GA instance is locked due to overdue payments.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags of the GA instance.
	Tag []*ListAcceleratorsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListAcceleratorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsRequest) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsRequest) SetAcceleratorId(v string) *ListAcceleratorsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListAcceleratorsRequest) SetPageNumber(v int32) *ListAcceleratorsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListAcceleratorsRequest) SetPageSize(v int32) *ListAcceleratorsRequest {
	s.PageSize = &v
	return s
}

func (s *ListAcceleratorsRequest) SetRegionId(v string) *ListAcceleratorsRequest {
	s.RegionId = &v
	return s
}

func (s *ListAcceleratorsRequest) SetResourceGroupId(v string) *ListAcceleratorsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListAcceleratorsRequest) SetState(v string) *ListAcceleratorsRequest {
	s.State = &v
	return s
}

func (s *ListAcceleratorsRequest) SetTag(v []*ListAcceleratorsRequestTag) *ListAcceleratorsRequest {
	s.Tag = v
	return s
}

type ListAcceleratorsRequestTag struct {
	// The tag key of the GA resource. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the GA resource. The tag value can be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListAcceleratorsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsRequestTag) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsRequestTag) SetKey(v string) *ListAcceleratorsRequestTag {
	s.Key = &v
	return s
}

func (s *ListAcceleratorsRequestTag) SetValue(v string) *ListAcceleratorsRequestTag {
	s.Value = &v
	return s
}

type ListAcceleratorsResponseBody struct {
	// Details about the GA instances.
	Accelerators []*ListAcceleratorsResponseBodyAccelerators `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAcceleratorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponseBody) SetAccelerators(v []*ListAcceleratorsResponseBodyAccelerators) *ListAcceleratorsResponseBody {
	s.Accelerators = v
	return s
}

func (s *ListAcceleratorsResponseBody) SetPageNumber(v int32) *ListAcceleratorsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListAcceleratorsResponseBody) SetPageSize(v int32) *ListAcceleratorsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListAcceleratorsResponseBody) SetRequestId(v string) *ListAcceleratorsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAcceleratorsResponseBody) SetTotalCount(v int32) *ListAcceleratorsResponseBody {
	s.TotalCount = &v
	return s
}

type ListAcceleratorsResponseBodyAccelerators struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth value of the GA instance. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The bandwidth metering method. Valid values:
	//
	// *   **BandwidthPackage:** metered based on bandwidth plans.
	// *   **CDT:** metered based on data transfers.
	BandwidthBillingType *string `json:"BandwidthBillingType,omitempty" xml:"BandwidthBillingType,omitempty"`
	// Details about the basic bandwidth plan that is associated with the GA instance.
	BasicBandwidthPackage *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage `json:"BasicBandwidthPackage,omitempty" xml:"BasicBandwidthPackage,omitempty" type:"Struct"`
	// The ID of the Cloud Enterprise Network (CEN) instance that is associated with the GA instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The timestamp that indicates when the GA instance is created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The type of cross-border acceleration. This parameter is returned for GA instances whose bandwidth metering method is pay-by-data-transfer (CDT).
	//
	// Only **bpgPro** is returned, which indicates BGP (Multi-ISP) Pro lines.
	CrossBorderMode *string `json:"CrossBorderMode,omitempty" xml:"CrossBorderMode,omitempty"`
	// Indicates whether cross-border acceleration is enabled for the GA instance. Valid values:
	//
	// *   **true**
	// *   **false**
	CrossBorderStatus *bool `json:"CrossBorderStatus,omitempty" xml:"CrossBorderStatus,omitempty"`
	// Details about the cross-border acceleration bandwidth plan that is associated with the GA instance.
	//
	// This array is returned only for GA instances that are created on the International site (alibabacloud.com).
	CrossDomainBandwidthPackage *ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage `json:"CrossDomainBandwidthPackage,omitempty" xml:"CrossDomainBandwidthPackage,omitempty" type:"Struct"`
	// The ID of the Anti-DDoS Pro/Premium instance that is associated with the GA instance.
	DdosId *string `json:"DdosId,omitempty" xml:"DdosId,omitempty"`
	// The description of the GA instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The canonical name (CNAME) that is assigned to the GA instance.
	DnsName *string `json:"DnsName,omitempty" xml:"DnsName,omitempty"`
	// The timestamp that indicates when the GA instance expires.
	ExpiredTime *int64 `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The billing method of the GA instance. Only **PREPAY** is returned. This value indicates the subscription billing method.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The configurations of the acceleration area.
	IpSetConfig *ListAcceleratorsResponseBodyAcceleratorsIpSetConfig `json:"IpSetConfig,omitempty" xml:"IpSetConfig,omitempty" type:"Struct"`
	// The name of the GA instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID to which the GA instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The CNAME that is used to associate the GA instance with an Anti-DDoS Pro/Premium instance.
	SecondDnsName *string `json:"SecondDnsName,omitempty" xml:"SecondDnsName,omitempty"`
	// 托管实例所属的服务方ID。
	// > 仅在**ServiceManaged**参数为**True**时有效。
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// 是否为托管实例。取值：
	// - **true**：是托管资实例。
	// - **false**：不是托管实例。
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// 用户在此托管实例下可执行的动作策略列表。
	// > 仅在**ServiceManaged**参数为**True**时有效。
	// > - 当实例处于托管状态时，用户对实例的操作会受到限制，某些操作行为会被禁止。
	ServiceManagedInfos []*ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The specification of the GA instance. Valid values:
	//
	// *   **1:** Small Ⅰ.
	// *   **2:** Small Ⅱ.
	// *   **3:** Small Ⅲ.
	// *   **5:** Medium Ⅰ.
	// *   **8:** Medium Ⅱ.
	// *   **10:** Medium Ⅲ.
	// *   **20:** Large Ⅰ.
	// *   **30:** Large Ⅱ.
	// *   **40:** Large Ⅲ.
	// *   **50:** Large Ⅳ.
	// *   **60:** Large Ⅴ.
	// *   **70:** Large Ⅵ.
	// *   **80:** Large VⅡ.
	// *   **90:** Large VⅢ.
	// *   **100:** Super Large Ⅰ.
	// *   **200:** Super Large Ⅱ.
	//
	// >  GA instances Large III and above are not available by default. To use these specifications, contact your Alibaba Cloud account manager.
	//
	// Each instance specification provides different capabilities. For more information, see [Instance specifications](~~153127~~).
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The status of the GA instance. Valid values:
	//
	// *   **init:** The GA instance is being initialized.
	// *   **active:** The GA instance is available.
	// *   **configuring**: The GA instance is being configured.
	// *   **binding:** The GA instance is being associated.
	// *   **unbinding:** The GA instance is being disassociated.
	// *   **deleting:** The GA instance is being deleted.
	// *   **finacialLocked:** The GA instance is locked due to overdue payments.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags that are added to the resource.
	Tags []*ListAcceleratorsResponseBodyAcceleratorsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// An invalid parameter.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// Indicates whether the GA instance can be upgraded. Valid values:
	//
	// *   **notUpgradable:** The GA instance does not need to be upgraded.
	// *   **upgradable:** The GA instance can be upgraded to the latest version.
	// *   **upgradeFailed:** The GA instance failed to be upgraded.
	UpgradableStatus *string `json:"UpgradableStatus,omitempty" xml:"UpgradableStatus,omitempty"`
}

func (s ListAcceleratorsResponseBodyAccelerators) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponseBodyAccelerators) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetAcceleratorId(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.AcceleratorId = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetBandwidth(v int32) *ListAcceleratorsResponseBodyAccelerators {
	s.Bandwidth = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetBandwidthBillingType(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.BandwidthBillingType = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetBasicBandwidthPackage(v *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) *ListAcceleratorsResponseBodyAccelerators {
	s.BasicBandwidthPackage = v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetCenId(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.CenId = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetCreateTime(v int64) *ListAcceleratorsResponseBodyAccelerators {
	s.CreateTime = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetCrossBorderMode(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.CrossBorderMode = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetCrossBorderStatus(v bool) *ListAcceleratorsResponseBodyAccelerators {
	s.CrossBorderStatus = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetCrossDomainBandwidthPackage(v *ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) *ListAcceleratorsResponseBodyAccelerators {
	s.CrossDomainBandwidthPackage = v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetDdosId(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.DdosId = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetDescription(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.Description = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetDnsName(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.DnsName = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetExpiredTime(v int64) *ListAcceleratorsResponseBodyAccelerators {
	s.ExpiredTime = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetInstanceChargeType(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.InstanceChargeType = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetIpSetConfig(v *ListAcceleratorsResponseBodyAcceleratorsIpSetConfig) *ListAcceleratorsResponseBodyAccelerators {
	s.IpSetConfig = v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetName(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.Name = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetRegionId(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.RegionId = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetResourceGroupId(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.ResourceGroupId = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetSecondDnsName(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.SecondDnsName = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetServiceId(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.ServiceId = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetServiceManaged(v bool) *ListAcceleratorsResponseBodyAccelerators {
	s.ServiceManaged = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetServiceManagedInfos(v []*ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos) *ListAcceleratorsResponseBodyAccelerators {
	s.ServiceManagedInfos = v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetSpec(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.Spec = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetState(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.State = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetTags(v []*ListAcceleratorsResponseBodyAcceleratorsTags) *ListAcceleratorsResponseBodyAccelerators {
	s.Tags = v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetType(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.Type = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAccelerators) SetUpgradableStatus(v string) *ListAcceleratorsResponseBodyAccelerators {
	s.UpgradableStatus = &v
	return s
}

type ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage struct {
	// The bandwidth value of the basic bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The bandwidth type that is provided by the basic bandwidth plan. Valid values:
	//
	// *   **Basic:** standard.
	// *   **Enhanced:** enhanced.
	// *   **Advanced:**: premium.
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the basic bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) SetBandwidth(v int32) *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) SetBandwidthType(v string) *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage {
	s.BandwidthType = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) SetInstanceId(v string) *ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage {
	s.InstanceId = &v
	return s
}

type ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage struct {
	// The bandwidth value of the cross-border acceleration bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the cross-border acceleration bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) SetBandwidth(v int32) *ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) SetInstanceId(v string) *ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage {
	s.InstanceId = &v
	return s
}

type ListAcceleratorsResponseBodyAcceleratorsIpSetConfig struct {
	// The access mode of the acceleration area. Valid values:
	//
	// *   **UserDefine:** custom nearby access mode. You can select acceleration areas and regions based on your business requirements. GA allocates a separate EIP to each acceleration region.
	// *   **Anycast:** automatic nearby access mode. You do not need to specify an acceleration area. GA allocates an Anycast EIP to multiple regions across the globe. Users can connect to the nearest access point of the Alibaba Cloud global transmission network by sending requests to the Anycast EIP.
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
}

func (s ListAcceleratorsResponseBodyAcceleratorsIpSetConfig) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponseBodyAcceleratorsIpSetConfig) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponseBodyAcceleratorsIpSetConfig) SetAccessMode(v string) *ListAcceleratorsResponseBodyAcceleratorsIpSetConfig {
	s.AccessMode = &v
	return s
}

type ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos struct {
	// 托管策略动作名称，取值：
	//
	// - **Create**：创建实例。
	//
	// - **Update**：更新当前实例。
	//
	// - **Delete**：删除当前实例。
	//
	// - **Associate**：引用/被引用当前实例。
	//
	// - **UserUnmanaged**：用户解托管实例
	//
	// - **CreateChild**：在当前实例下创建子资源
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// 子资源类型，取值：
	//
	// - **Listener**：监听资源。
	//
	// - **IpSet**：加速地域资源。
	//
	// - **EndpointGroup**：终端节点组资源。
	//
	// - **ForwardingRule**：转发策略资源。
	//
	// - **Endpoint**：终端节点资源。
	//
	// - **EndpointGroupDestination**：自定义路由监听下的终端节点组协议映射资源。
	//
	// - **EndpointPolicy**：自定义路由监听下的终端节点通行策略资源。
	//
	// > 仅在**Action**参数为**CreateChild**时有效
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// 托管策略动作是否被托管，取值：
	//
	// - **true**：托管策略动作被托管，用户无权在托管实例下执行Action指定的操作。
	//
	// - **false**：托管策略动作未被托管，用户可在托管实例下执行Action指定的操作。
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos) SetAction(v string) *ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos) SetChildType(v string) *ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos) SetIsManaged(v bool) *ListAcceleratorsResponseBodyAcceleratorsServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListAcceleratorsResponseBodyAcceleratorsTags struct {
	// The key of tag N that is added to the resource.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N that is added to the resource.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListAcceleratorsResponseBodyAcceleratorsTags) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponseBodyAcceleratorsTags) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponseBodyAcceleratorsTags) SetKey(v string) *ListAcceleratorsResponseBodyAcceleratorsTags {
	s.Key = &v
	return s
}

func (s *ListAcceleratorsResponseBodyAcceleratorsTags) SetValue(v string) *ListAcceleratorsResponseBodyAcceleratorsTags {
	s.Value = &v
	return s
}

type ListAcceleratorsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAcceleratorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAcceleratorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAcceleratorsResponse) GoString() string {
	return s.String()
}

func (s *ListAcceleratorsResponse) SetHeaders(v map[string]*string) *ListAcceleratorsResponse {
	s.Headers = v
	return s
}

func (s *ListAcceleratorsResponse) SetStatusCode(v int32) *ListAcceleratorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAcceleratorsResponse) SetBody(v *ListAcceleratorsResponseBody) *ListAcceleratorsResponse {
	s.Body = v
	return s
}

type ListAclsRequest struct {
	// The ID of the network ACL. You can specify up to 20 network ACL IDs in each request.
	AclIds []*string `json:"AclIds,omitempty" xml:"AclIds,omitempty" type:"Repeated"`
	// The name of the network ACL. You can specify up to 10 network ACL names in each request.
	//
	// The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first and only query, ignore this parameter.
	// *   If a subsequent query is to be performed, set the parameter to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags of the resource.
	Tag []*ListAclsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListAclsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAclsRequest) GoString() string {
	return s.String()
}

func (s *ListAclsRequest) SetAclIds(v []*string) *ListAclsRequest {
	s.AclIds = v
	return s
}

func (s *ListAclsRequest) SetAclName(v string) *ListAclsRequest {
	s.AclName = &v
	return s
}

func (s *ListAclsRequest) SetClientToken(v string) *ListAclsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListAclsRequest) SetMaxResults(v int32) *ListAclsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListAclsRequest) SetNextToken(v string) *ListAclsRequest {
	s.NextToken = &v
	return s
}

func (s *ListAclsRequest) SetRegionId(v string) *ListAclsRequest {
	s.RegionId = &v
	return s
}

func (s *ListAclsRequest) SetResourceGroupId(v string) *ListAclsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListAclsRequest) SetTag(v []*ListAclsRequestTag) *ListAclsRequest {
	s.Tag = v
	return s
}

type ListAclsRequestTag struct {
	// The tag key of the network ACL. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the network ACL. The tag value can be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListAclsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListAclsRequestTag) GoString() string {
	return s.String()
}

func (s *ListAclsRequestTag) SetKey(v string) *ListAclsRequestTag {
	s.Key = &v
	return s
}

func (s *ListAclsRequestTag) SetValue(v string) *ListAclsRequestTag {
	s.Value = &v
	return s
}

type ListAclsResponseBody struct {
	// The network ACLs.
	Acls []*ListAclsResponseBodyAcls `json:"Acls,omitempty" xml:"Acls,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If **NextToken** is returned, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAclsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAclsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAclsResponseBody) SetAcls(v []*ListAclsResponseBodyAcls) *ListAclsResponseBody {
	s.Acls = v
	return s
}

func (s *ListAclsResponseBody) SetMaxResults(v int32) *ListAclsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListAclsResponseBody) SetNextToken(v string) *ListAclsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListAclsResponseBody) SetRequestId(v string) *ListAclsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAclsResponseBody) SetTotalCount(v int32) *ListAclsResponseBody {
	s.TotalCount = &v
	return s
}

type ListAclsResponseBodyAcls struct {
	// The ID of the network ACL.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The name of the network ACL.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The status of the network ACL. Valid values:
	//
	// *   **init**: The network ACL is being initialized.
	// *   **active**: The network ACL is available.
	// *   **configuring**: The network ACL is being configured.
	// *   **updating**: The network ACL is being updated.
	// *   **deleting:** The network ACL is being deleted.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The IP version of the network ACL. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags of the network ACL.
	Tags []*ListAclsResponseBodyAclsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListAclsResponseBodyAcls) String() string {
	return tea.Prettify(s)
}

func (s ListAclsResponseBodyAcls) GoString() string {
	return s.String()
}

func (s *ListAclsResponseBodyAcls) SetAclId(v string) *ListAclsResponseBodyAcls {
	s.AclId = &v
	return s
}

func (s *ListAclsResponseBodyAcls) SetAclName(v string) *ListAclsResponseBodyAcls {
	s.AclName = &v
	return s
}

func (s *ListAclsResponseBodyAcls) SetAclStatus(v string) *ListAclsResponseBodyAcls {
	s.AclStatus = &v
	return s
}

func (s *ListAclsResponseBodyAcls) SetAddressIPVersion(v string) *ListAclsResponseBodyAcls {
	s.AddressIPVersion = &v
	return s
}

func (s *ListAclsResponseBodyAcls) SetResourceGroupId(v string) *ListAclsResponseBodyAcls {
	s.ResourceGroupId = &v
	return s
}

func (s *ListAclsResponseBodyAcls) SetTags(v []*ListAclsResponseBodyAclsTags) *ListAclsResponseBodyAcls {
	s.Tags = v
	return s
}

type ListAclsResponseBodyAclsTags struct {
	// The tag key of the network ACL.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the network ACL.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListAclsResponseBodyAclsTags) String() string {
	return tea.Prettify(s)
}

func (s ListAclsResponseBodyAclsTags) GoString() string {
	return s.String()
}

func (s *ListAclsResponseBodyAclsTags) SetKey(v string) *ListAclsResponseBodyAclsTags {
	s.Key = &v
	return s
}

func (s *ListAclsResponseBodyAclsTags) SetValue(v string) *ListAclsResponseBodyAclsTags {
	s.Value = &v
	return s
}

type ListAclsResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAclsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAclsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAclsResponse) GoString() string {
	return s.String()
}

func (s *ListAclsResponse) SetHeaders(v map[string]*string) *ListAclsResponse {
	s.Headers = v
	return s
}

func (s *ListAclsResponse) SetStatusCode(v int32) *ListAclsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAclsResponse) SetBody(v *ListAclsResponseBody) *ListAclsResponse {
	s.Body = v
	return s
}

type ListApplicationMonitorRequest struct {
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The keyword that is used to search for origin probing tasks. You can enter a URL, an IP address, a GA instance ID, or a listener ID to perform a fuzzy match.
	SearchValue *string `json:"SearchValue,omitempty" xml:"SearchValue,omitempty"`
}

func (s ListApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorRequest) SetPageNumber(v int32) *ListApplicationMonitorRequest {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationMonitorRequest) SetPageSize(v int32) *ListApplicationMonitorRequest {
	s.PageSize = &v
	return s
}

func (s *ListApplicationMonitorRequest) SetRegionId(v string) *ListApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *ListApplicationMonitorRequest) SetSearchValue(v string) *ListApplicationMonitorRequest {
	s.SearchValue = &v
	return s
}

type ListApplicationMonitorResponseBody struct {
	// The list of origin probing tasks.
	ApplicationMonitors []*ListApplicationMonitorResponseBodyApplicationMonitors `json:"ApplicationMonitors,omitempty" xml:"ApplicationMonitors,omitempty" type:"Repeated"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorResponseBody) SetApplicationMonitors(v []*ListApplicationMonitorResponseBodyApplicationMonitors) *ListApplicationMonitorResponseBody {
	s.ApplicationMonitors = v
	return s
}

func (s *ListApplicationMonitorResponseBody) SetPageNumber(v int32) *ListApplicationMonitorResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationMonitorResponseBody) SetPageSize(v int32) *ListApplicationMonitorResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListApplicationMonitorResponseBody) SetRequestId(v string) *ListApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListApplicationMonitorResponseBody) SetTotalCount(v int32) *ListApplicationMonitorResponseBody {
	s.TotalCount = &v
	return s
}

type ListApplicationMonitorResponseBodyApplicationMonitors struct {
	// The ID of the GA instance on which the origin probing task runs.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The URL or IP address that was probed.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// Indicates whether the automatic diagnostics feature is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	DetectEnable *bool `json:"DetectEnable,omitempty" xml:"DetectEnable,omitempty"`
	// The threshold that is used to trigger the automatic diagnostics feature.
	DetectThreshold *int32 `json:"DetectThreshold,omitempty" xml:"DetectThreshold,omitempty"`
	// The number of times that are required to reach the threshold before the automatic diagnostics feature can be triggered.
	DetectTimes *int32 `json:"DetectTimes,omitempty" xml:"DetectTimes,omitempty"`
	// The ID of the listener on which the origin probing task runs.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The extended options of the listener protocol that is used by the origin probing task. The options vary based on the listener protocol.
	OptionsJson *string `json:"OptionsJson,omitempty" xml:"OptionsJson,omitempty"`
	// The silence period of the automatic diagnostics feature. This parameter indicates the interval at which the automatic diagnostics feature is triggered. If the availability rate does not return to normal after GA triggers an automatic diagnostic task, GA must wait until the silence period ends before GA can trigger another automatic diagnostic task.
	//
	// If the number of consecutive times that the availability rate drops below the threshold of automatic diagnostics reaches the value of **DetectTimes** , the automatic diagnostics feature is triggered. The automatic diagnostics feature is not triggered again within the silence period even if the availability rate stays below the threshold. If the availability rate does not return to normal after the silence period ends, the automatic diagnostics feature is triggered again.
	//
	// Unit: seconds.
	SilenceTime *int32 `json:"SilenceTime,omitempty" xml:"SilenceTime,omitempty"`
	// The status of the origin probing task. Valid values:
	//
	// *   **active:** The origin probing task is running.
	// *   **inactive:** The origin probing task is stopped.
	// *   **init:** The origin probing task is being initialized.
	// *   **deleting:** The origin probing task is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The origin probing task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The origin probing task name.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s ListApplicationMonitorResponseBodyApplicationMonitors) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorResponseBodyApplicationMonitors) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetAcceleratorId(v string) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.AcceleratorId = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetAddress(v string) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.Address = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetDetectEnable(v bool) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.DetectEnable = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetDetectThreshold(v int32) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.DetectThreshold = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetDetectTimes(v int32) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.DetectTimes = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetListenerId(v string) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.ListenerId = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetOptionsJson(v string) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.OptionsJson = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetSilenceTime(v int32) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.SilenceTime = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetState(v string) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.State = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetTaskId(v string) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.TaskId = &v
	return s
}

func (s *ListApplicationMonitorResponseBodyApplicationMonitors) SetTaskName(v string) *ListApplicationMonitorResponseBodyApplicationMonitors {
	s.TaskName = &v
	return s
}

type ListApplicationMonitorResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorResponse) SetHeaders(v map[string]*string) *ListApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *ListApplicationMonitorResponse) SetStatusCode(v int32) *ListApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *ListApplicationMonitorResponse) SetBody(v *ListApplicationMonitorResponseBody) *ListApplicationMonitorResponse {
	s.Body = v
	return s
}

type ListApplicationMonitorDetectResultRequest struct {
	// The beginning of the time range to query. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	BeginTime *int64 `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The end of the time range to query. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The origin probing task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ListApplicationMonitorDetectResultRequest) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorDetectResultRequest) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorDetectResultRequest) SetBeginTime(v int64) *ListApplicationMonitorDetectResultRequest {
	s.BeginTime = &v
	return s
}

func (s *ListApplicationMonitorDetectResultRequest) SetEndTime(v int64) *ListApplicationMonitorDetectResultRequest {
	s.EndTime = &v
	return s
}

func (s *ListApplicationMonitorDetectResultRequest) SetPageNumber(v int32) *ListApplicationMonitorDetectResultRequest {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationMonitorDetectResultRequest) SetPageSize(v int32) *ListApplicationMonitorDetectResultRequest {
	s.PageSize = &v
	return s
}

func (s *ListApplicationMonitorDetectResultRequest) SetRegionId(v string) *ListApplicationMonitorDetectResultRequest {
	s.RegionId = &v
	return s
}

func (s *ListApplicationMonitorDetectResultRequest) SetTaskId(v string) *ListApplicationMonitorDetectResultRequest {
	s.TaskId = &v
	return s
}

type ListApplicationMonitorDetectResultResponseBody struct {
	// Details about the diagnostic result of the origin probing task.
	ApplicationMonitorDetectResultList []*ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList `json:"ApplicationMonitorDetectResultList,omitempty" xml:"ApplicationMonitorDetectResultList,omitempty" type:"Repeated"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListApplicationMonitorDetectResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorDetectResultResponseBody) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorDetectResultResponseBody) SetApplicationMonitorDetectResultList(v []*ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) *ListApplicationMonitorDetectResultResponseBody {
	s.ApplicationMonitorDetectResultList = v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBody) SetPageNumber(v int32) *ListApplicationMonitorDetectResultResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBody) SetPageSize(v int32) *ListApplicationMonitorDetectResultResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBody) SetRequestId(v string) *ListApplicationMonitorDetectResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBody) SetTotalCount(v int32) *ListApplicationMonitorDetectResultResponseBody {
	s.TotalCount = &v
	return s
}

type ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList struct {
	// The ID of the GA instance on which the origin probing task runs.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The response content returned by the origin probing task.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The description of the diagnostic result. Valid values:
	//
	// *   **All forward nodes work well.**: The origin server is normal.
	// *   **Endpoint network error.**: The origin server is abnormal. You must check whether the origin server is running as expected.
	// *   **Public network error.**: An Internet error occurred. This refers to a network error that occurred when the client connects to the acceleration region.
	// *   **Ga internal error.**: An internal error occurred. For example, an exception occurred when a request is processed by GA.
	// *   **Ga has been deleted.**: The current GA instance is deleted.
	// *   **Ga state is not stable**: The current GA instance is in an unstable state, such as the Configuring state.
	// *   **Ga has no listener configuration.**: No listener is configured for the current GA instance.
	// *   **Missing endpoint configuration.**: No endpoint is configured.
	// *   **Missing acceleration region configuration.**: No acceleration region is configured.
	// *   **Missing endpointgroup configuration.**: No endpoint group is configured.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The time when the diagnosis of the origin probing task ends.
	DetectTime *string `json:"DetectTime,omitempty" xml:"DetectTime,omitempty"`
	// The diagnostic result of the origin probing task. Valid values:
	//
	// *   **success:** The origin probing task succeeded.
	// *   **failed:** The origin probing task failed.
	DiagStatus *string `json:"DiagStatus,omitempty" xml:"DiagStatus,omitempty"`
	// The ID of the listener on which the origin probing task runs.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The listening port.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The network transmission protocol that is used by the listener. Valid values:
	//
	// *   **tcp:** TCP.
	// *   **udp:** UDP.
	// *   **http:** HTTP.
	// *   **https:** HTTPS.
	//
	// >  UDP listeners do not support probing.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The error code returned by the origin probing task.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
	// The origin probing task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetAcceleratorId(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.AcceleratorId = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetContent(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.Content = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetDetail(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.Detail = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetDetectTime(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.DetectTime = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetDiagStatus(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.DiagStatus = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetListenerId(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.ListenerId = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetPort(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.Port = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetProtocol(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.Protocol = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetStatusCode(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.StatusCode = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList) SetTaskId(v string) *ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList {
	s.TaskId = &v
	return s
}

type ListApplicationMonitorDetectResultResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListApplicationMonitorDetectResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListApplicationMonitorDetectResultResponse) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationMonitorDetectResultResponse) GoString() string {
	return s.String()
}

func (s *ListApplicationMonitorDetectResultResponse) SetHeaders(v map[string]*string) *ListApplicationMonitorDetectResultResponse {
	s.Headers = v
	return s
}

func (s *ListApplicationMonitorDetectResultResponse) SetStatusCode(v int32) *ListApplicationMonitorDetectResultResponse {
	s.StatusCode = &v
	return s
}

func (s *ListApplicationMonitorDetectResultResponse) SetBody(v *ListApplicationMonitorDetectResultResponseBody) *ListApplicationMonitorDetectResultResponse {
	s.Body = v
	return s
}

type ListAvailableAccelerateAreasRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListAvailableAccelerateAreasRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableAccelerateAreasRequest) GoString() string {
	return s.String()
}

func (s *ListAvailableAccelerateAreasRequest) SetAcceleratorId(v string) *ListAvailableAccelerateAreasRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListAvailableAccelerateAreasRequest) SetRegionId(v string) *ListAvailableAccelerateAreasRequest {
	s.RegionId = &v
	return s
}

type ListAvailableAccelerateAreasResponseBody struct {
	// The information about acceleration areas.
	Areas []*ListAvailableAccelerateAreasResponseBodyAreas `json:"Areas,omitempty" xml:"Areas,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAvailableAccelerateAreasResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableAccelerateAreasResponseBody) GoString() string {
	return s.String()
}

func (s *ListAvailableAccelerateAreasResponseBody) SetAreas(v []*ListAvailableAccelerateAreasResponseBodyAreas) *ListAvailableAccelerateAreasResponseBody {
	s.Areas = v
	return s
}

func (s *ListAvailableAccelerateAreasResponseBody) SetRequestId(v string) *ListAvailableAccelerateAreasResponseBody {
	s.RequestId = &v
	return s
}

type ListAvailableAccelerateAreasResponseBodyAreas struct {
	// The ID of the acceleration area.
	AreaId *string `json:"AreaId,omitempty" xml:"AreaId,omitempty"`
	// The name of the acceleration area.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The information about acceleration regions.
	RegionList []*ListAvailableAccelerateAreasResponseBodyAreasRegionList `json:"RegionList,omitempty" xml:"RegionList,omitempty" type:"Repeated"`
}

func (s ListAvailableAccelerateAreasResponseBodyAreas) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableAccelerateAreasResponseBodyAreas) GoString() string {
	return s.String()
}

func (s *ListAvailableAccelerateAreasResponseBodyAreas) SetAreaId(v string) *ListAvailableAccelerateAreasResponseBodyAreas {
	s.AreaId = &v
	return s
}

func (s *ListAvailableAccelerateAreasResponseBodyAreas) SetLocalName(v string) *ListAvailableAccelerateAreasResponseBodyAreas {
	s.LocalName = &v
	return s
}

func (s *ListAvailableAccelerateAreasResponseBodyAreas) SetRegionList(v []*ListAvailableAccelerateAreasResponseBodyAreasRegionList) *ListAvailableAccelerateAreasResponseBodyAreas {
	s.RegionList = v
	return s
}

type ListAvailableAccelerateAreasResponseBodyAreasRegionList struct {
	// Whether China Mainland.
	ChinaMainland *bool `json:"ChinaMainland,omitempty" xml:"ChinaMainland,omitempty"`
	// The line types of EIPs in the acceleration region.
	//
	// *   **BGP**: BGP (Multi-ISP) lines
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines
	//
	// If you have the permissions to use single-ISP bandwidth, one of the following values may be returned:
	//
	// *   **ChinaTelecom**: China Telecom (single ISP)
	// *   **ChinaUnicom**: China Unicom (single ISP)
	// *   **ChinaMobile**: China Mobile (single ISP)
	// *   **ChinaTelecom_L2**: China Telecom_L2 (single ISP)
	// *   **ChinaUnicom_L2**: China Unicom_L2 (single ISP)
	// *   **ChinaMobile_L2**: China Mobile_L2 (single ISP)
	//
	// > Different acceleration regions support different single-ISP BGP lines.
	IspTypeList []*string `json:"IspTypeList,omitempty" xml:"IspTypeList,omitempty" type:"Repeated"`
	// The name of the acceleration region.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The ID of the acceleration region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Ipv6 supported, Valid values:
	//
	// - true
	// - false
	SupportIpv6 *bool `json:"SupportIpv6,omitempty" xml:"SupportIpv6,omitempty"`
}

func (s ListAvailableAccelerateAreasResponseBodyAreasRegionList) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableAccelerateAreasResponseBodyAreasRegionList) GoString() string {
	return s.String()
}

func (s *ListAvailableAccelerateAreasResponseBodyAreasRegionList) SetChinaMainland(v bool) *ListAvailableAccelerateAreasResponseBodyAreasRegionList {
	s.ChinaMainland = &v
	return s
}

func (s *ListAvailableAccelerateAreasResponseBodyAreasRegionList) SetIspTypeList(v []*string) *ListAvailableAccelerateAreasResponseBodyAreasRegionList {
	s.IspTypeList = v
	return s
}

func (s *ListAvailableAccelerateAreasResponseBodyAreasRegionList) SetLocalName(v string) *ListAvailableAccelerateAreasResponseBodyAreasRegionList {
	s.LocalName = &v
	return s
}

func (s *ListAvailableAccelerateAreasResponseBodyAreasRegionList) SetRegionId(v string) *ListAvailableAccelerateAreasResponseBodyAreasRegionList {
	s.RegionId = &v
	return s
}

func (s *ListAvailableAccelerateAreasResponseBodyAreasRegionList) SetSupportIpv6(v bool) *ListAvailableAccelerateAreasResponseBodyAreasRegionList {
	s.SupportIpv6 = &v
	return s
}

type ListAvailableAccelerateAreasResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAvailableAccelerateAreasResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAvailableAccelerateAreasResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableAccelerateAreasResponse) GoString() string {
	return s.String()
}

func (s *ListAvailableAccelerateAreasResponse) SetHeaders(v map[string]*string) *ListAvailableAccelerateAreasResponse {
	s.Headers = v
	return s
}

func (s *ListAvailableAccelerateAreasResponse) SetStatusCode(v int32) *ListAvailableAccelerateAreasResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAvailableAccelerateAreasResponse) SetBody(v *ListAvailableAccelerateAreasResponseBody) *ListAvailableAccelerateAreasResponse {
	s.Body = v
	return s
}

type ListAvailableBusiRegionsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListAvailableBusiRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableBusiRegionsRequest) GoString() string {
	return s.String()
}

func (s *ListAvailableBusiRegionsRequest) SetAcceleratorId(v string) *ListAvailableBusiRegionsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListAvailableBusiRegionsRequest) SetRegionId(v string) *ListAvailableBusiRegionsRequest {
	s.RegionId = &v
	return s
}

type ListAvailableBusiRegionsResponseBody struct {
	// The information about the regions.
	Regions []*ListAvailableBusiRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAvailableBusiRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableBusiRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAvailableBusiRegionsResponseBody) SetRegions(v []*ListAvailableBusiRegionsResponseBodyRegions) *ListAvailableBusiRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *ListAvailableBusiRegionsResponseBody) SetRequestId(v string) *ListAvailableBusiRegionsResponseBody {
	s.RequestId = &v
	return s
}

type ListAvailableBusiRegionsResponseBodyRegions struct {
	// Whether China Mainland.
	ChinaMainland *bool `json:"ChinaMainland,omitempty" xml:"ChinaMainland,omitempty"`
	// The name of the region.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// Indicates whether the region is a point of presence (PoP). Valid values:
	//
	// *   **true**: The region is a PoP.
	// *   **false**: The region is not a PoP.
	Pop *bool `json:"Pop,omitempty" xml:"Pop,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListAvailableBusiRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableBusiRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *ListAvailableBusiRegionsResponseBodyRegions) SetChinaMainland(v bool) *ListAvailableBusiRegionsResponseBodyRegions {
	s.ChinaMainland = &v
	return s
}

func (s *ListAvailableBusiRegionsResponseBodyRegions) SetLocalName(v string) *ListAvailableBusiRegionsResponseBodyRegions {
	s.LocalName = &v
	return s
}

func (s *ListAvailableBusiRegionsResponseBodyRegions) SetPop(v bool) *ListAvailableBusiRegionsResponseBodyRegions {
	s.Pop = &v
	return s
}

func (s *ListAvailableBusiRegionsResponseBodyRegions) SetRegionId(v string) *ListAvailableBusiRegionsResponseBodyRegions {
	s.RegionId = &v
	return s
}

type ListAvailableBusiRegionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAvailableBusiRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAvailableBusiRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAvailableBusiRegionsResponse) GoString() string {
	return s.String()
}

func (s *ListAvailableBusiRegionsResponse) SetHeaders(v map[string]*string) *ListAvailableBusiRegionsResponse {
	s.Headers = v
	return s
}

func (s *ListAvailableBusiRegionsResponse) SetStatusCode(v int32) *ListAvailableBusiRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAvailableBusiRegionsResponse) SetBody(v *ListAvailableBusiRegionsResponseBody) *ListAvailableBusiRegionsResponse {
	s.Body = v
	return s
}

type ListBandwidthPackagesRequest struct {
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the bandwidth plan. Valid values:
	//
	// *   **init**: The bandwidth plan is being initialized.
	// *   **active**: The bandwidth plan is available.
	// *   **binded**: The bandwidth plan is associated.
	// *   **binding**: The bandwidth plan is being associated.
	// *   **unbinding**: The bandwidth plan is being disassociated.
	// *   **updating**: The bandwidth plan is being updated.
	// *   **finacialLocked**: The bandwidth plan is locked due to overdue payments.
	// *   **locked**: The bandwidth plan is locked.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tag of the bandwidth plan.
	Tag []*ListBandwidthPackagesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The type of the bandwidth plan. Valid values:
	//
	// *   **Basic**: a basic bandwidth plan
	// *   **CrossDomain**: a cross-border acceleration bandwidth plan
	//
	// If you call this operation on the China site (aliyun.com), you can set Type only to **Basic**.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListBandwidthPackagesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthPackagesRequest) GoString() string {
	return s.String()
}

func (s *ListBandwidthPackagesRequest) SetBandwidthPackageId(v string) *ListBandwidthPackagesRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *ListBandwidthPackagesRequest) SetPageNumber(v int32) *ListBandwidthPackagesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListBandwidthPackagesRequest) SetPageSize(v int32) *ListBandwidthPackagesRequest {
	s.PageSize = &v
	return s
}

func (s *ListBandwidthPackagesRequest) SetRegionId(v string) *ListBandwidthPackagesRequest {
	s.RegionId = &v
	return s
}

func (s *ListBandwidthPackagesRequest) SetResourceGroupId(v string) *ListBandwidthPackagesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListBandwidthPackagesRequest) SetState(v string) *ListBandwidthPackagesRequest {
	s.State = &v
	return s
}

func (s *ListBandwidthPackagesRequest) SetTag(v []*ListBandwidthPackagesRequestTag) *ListBandwidthPackagesRequest {
	s.Tag = v
	return s
}

func (s *ListBandwidthPackagesRequest) SetType(v string) *ListBandwidthPackagesRequest {
	s.Type = &v
	return s
}

type ListBandwidthPackagesRequestTag struct {
	// The tag key of the bandwidth plan. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the bandwidth plan. The tag value can be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListBandwidthPackagesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthPackagesRequestTag) GoString() string {
	return s.String()
}

func (s *ListBandwidthPackagesRequestTag) SetKey(v string) *ListBandwidthPackagesRequestTag {
	s.Key = &v
	return s
}

func (s *ListBandwidthPackagesRequestTag) SetValue(v string) *ListBandwidthPackagesRequestTag {
	s.Value = &v
	return s
}

type ListBandwidthPackagesResponseBody struct {
	// Details about the bandwidth plans.
	BandwidthPackages []*ListBandwidthPackagesResponseBodyBandwidthPackages `json:"BandwidthPackages,omitempty" xml:"BandwidthPackages,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBandwidthPackagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthPackagesResponseBody) GoString() string {
	return s.String()
}

func (s *ListBandwidthPackagesResponseBody) SetBandwidthPackages(v []*ListBandwidthPackagesResponseBodyBandwidthPackages) *ListBandwidthPackagesResponseBody {
	s.BandwidthPackages = v
	return s
}

func (s *ListBandwidthPackagesResponseBody) SetPageNumber(v int32) *ListBandwidthPackagesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListBandwidthPackagesResponseBody) SetPageSize(v int32) *ListBandwidthPackagesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListBandwidthPackagesResponseBody) SetRequestId(v string) *ListBandwidthPackagesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBandwidthPackagesResponseBody) SetTotalCount(v int32) *ListBandwidthPackagesResponseBody {
	s.TotalCount = &v
	return s
}

type ListBandwidthPackagesResponseBodyBandwidthPackages struct {
	// The ID of the GA instance that is associated with the bandwidth plan.
	Accelerators []*string `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The bandwidth value of the bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The type of the bandwidth. Valid values:
	//
	// *   **Basic**: standard
	// *   **Enhanced**: enhanced
	// *   **Advanced**: premium
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The metering method that is used when you use the pay-as-you-go billing method.
	//
	// *   **PayByTraffic**: pay-by-data-transfer
	// *   **PayBY95**: pay-by-95th-percentile
	BillingType *string `json:"BillingType,omitempty" xml:"BillingType,omitempty"`
	// Area A of the cross-border acceleration bandwidth plan. Only **China-mainland** (the Chinese mainland) is returned.
	//
	// This parameter is returned only if you call this operation on the international site (alibabacloud.com).
	CbnGeographicRegionIdA *string `json:"CbnGeographicRegionIdA,omitempty" xml:"CbnGeographicRegionIdA,omitempty"`
	// Area B of the cross-border acceleration bandwidth plan. Only **Global** (global) is returned.
	//
	// This parameter is returned only if you call this operation on the international site (alibabacloud.com).
	CbnGeographicRegionIdB *string `json:"CbnGeographicRegionIdB,omitempty" xml:"CbnGeographicRegionIdB,omitempty"`
	// The billing method of the bandwidth plan. Only **PREPAY** is returned, which indicates the subscription billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the bandwidth plan was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the bandwidth plan.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timestamp when the bandwidth plan expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The name of the bandwidth plan.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The percentage of the minimum bandwidth guaranteed if the pay-by-95th-percentile metering method is used.
	Ratio *int32 `json:"Ratio,omitempty" xml:"Ratio,omitempty"`
	// The ID of the region where the GA instance is deployed. **cn-hangzhou** is returned.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the bandwidth plan. Valid values:
	//
	// *   **init**: The bandwidth plan is being initialized.
	// *   **active**: The bandwidth plan is available.
	// *   **binded**: The bandwidth plan is associated.
	// *   **binding**: The bandwidth plan is being associated.
	// *   **unbinding**: The bandwidth plan is being disassociated.
	// *   **updating**: The bandwidth plan is being updated.
	// *   **finacialLocked**: The bandwidth plan is locked due to overdue payments.
	// *   **locked**: The bandwidth plan is locked.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tag of the bandwidth plan.
	Tags []*ListBandwidthPackagesResponseBodyBandwidthPackagesTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of the bandwidth plan. Valid values:
	//
	// *   **Basic**: a basic bandwidth plan
	// *   **CrossDomain**: a cross-border acceleration bandwidth plan
	//
	// If you call this operation on the China site (aliyun.com), only **Basic** is returned.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListBandwidthPackagesResponseBodyBandwidthPackages) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthPackagesResponseBodyBandwidthPackages) GoString() string {
	return s.String()
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetAccelerators(v []*string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.Accelerators = v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetBandwidth(v int32) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.Bandwidth = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetBandwidthPackageId(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.BandwidthPackageId = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetBandwidthType(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.BandwidthType = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetBillingType(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.BillingType = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetCbnGeographicRegionIdA(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.CbnGeographicRegionIdA = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetCbnGeographicRegionIdB(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.CbnGeographicRegionIdB = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetChargeType(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.ChargeType = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetCreateTime(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.CreateTime = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetDescription(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.Description = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetExpiredTime(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.ExpiredTime = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetName(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.Name = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetRatio(v int32) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.Ratio = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetRegionId(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.RegionId = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetResourceGroupId(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.ResourceGroupId = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetState(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.State = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetTags(v []*ListBandwidthPackagesResponseBodyBandwidthPackagesTags) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.Tags = v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackages) SetType(v string) *ListBandwidthPackagesResponseBodyBandwidthPackages {
	s.Type = &v
	return s
}

type ListBandwidthPackagesResponseBodyBandwidthPackagesTags struct {
	// The tag key of the bandwidth plan.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the bandwidth plan.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListBandwidthPackagesResponseBodyBandwidthPackagesTags) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthPackagesResponseBodyBandwidthPackagesTags) GoString() string {
	return s.String()
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackagesTags) SetKey(v string) *ListBandwidthPackagesResponseBodyBandwidthPackagesTags {
	s.Key = &v
	return s
}

func (s *ListBandwidthPackagesResponseBodyBandwidthPackagesTags) SetValue(v string) *ListBandwidthPackagesResponseBodyBandwidthPackagesTags {
	s.Value = &v
	return s
}

type ListBandwidthPackagesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBandwidthPackagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBandwidthPackagesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthPackagesResponse) GoString() string {
	return s.String()
}

func (s *ListBandwidthPackagesResponse) SetHeaders(v map[string]*string) *ListBandwidthPackagesResponse {
	s.Headers = v
	return s
}

func (s *ListBandwidthPackagesResponse) SetStatusCode(v int32) *ListBandwidthPackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBandwidthPackagesResponse) SetBody(v *ListBandwidthPackagesResponseBody) *ListBandwidthPackagesResponse {
	s.Body = v
	return s
}

type ListBandwidthackagesRequest struct {
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListBandwidthackagesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthackagesRequest) GoString() string {
	return s.String()
}

func (s *ListBandwidthackagesRequest) SetPageNumber(v int32) *ListBandwidthackagesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListBandwidthackagesRequest) SetPageSize(v int32) *ListBandwidthackagesRequest {
	s.PageSize = &v
	return s
}

func (s *ListBandwidthackagesRequest) SetRegionId(v string) *ListBandwidthackagesRequest {
	s.RegionId = &v
	return s
}

type ListBandwidthackagesResponseBody struct {
	// Details about the bandwidth plans.
	BandwidthPackages []*ListBandwidthackagesResponseBodyBandwidthPackages `json:"BandwidthPackages,omitempty" xml:"BandwidthPackages,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBandwidthackagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthackagesResponseBody) GoString() string {
	return s.String()
}

func (s *ListBandwidthackagesResponseBody) SetBandwidthPackages(v []*ListBandwidthackagesResponseBodyBandwidthPackages) *ListBandwidthackagesResponseBody {
	s.BandwidthPackages = v
	return s
}

func (s *ListBandwidthackagesResponseBody) SetPageNumber(v int32) *ListBandwidthackagesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListBandwidthackagesResponseBody) SetPageSize(v int32) *ListBandwidthackagesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListBandwidthackagesResponseBody) SetRequestId(v string) *ListBandwidthackagesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBandwidthackagesResponseBody) SetTotalCount(v int32) *ListBandwidthackagesResponseBody {
	s.TotalCount = &v
	return s
}

type ListBandwidthackagesResponseBodyBandwidthPackages struct {
	// The ID of the GA instance that is associated with the bandwidth plan.
	Accelerators []*string `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The bandwidth value of the bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The billing method of the bandwidth plan. Only **PREPAY** is returned, which indicates the subscription billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The timestamp when the bandwidth plan was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the bandwidth plan.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timestamp when the bandwidth plan expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The name of the GA instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The state of the bandwidth plan. Valid values:
	//
	// *   **init**: The bandwidth plan is being initialized.
	// *   **active**: The bandwidth plan is available.
	// *   **binded**: The bandwidth plan is associated with a GA instance.
	// *   **binding**: The bandwidth plan is being associated.
	// *   **unbinding**: The bandwidth plan is being disassociated.
	// *   **updating**: The bandwidth plan is being updated.
	// *   **finacialLocked**: The bandwidth plan is locked due to overdue payments.
	// *   **Locked**: The bandwidth plan is locked.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags of the bandwidth plans.
	Tags []*ListBandwidthackagesResponseBodyBandwidthPackagesTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListBandwidthackagesResponseBodyBandwidthPackages) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthackagesResponseBodyBandwidthPackages) GoString() string {
	return s.String()
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetAccelerators(v []*string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.Accelerators = v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetBandwidth(v int32) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.Bandwidth = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetBandwidthPackageId(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.BandwidthPackageId = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetChargeType(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.ChargeType = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetCreateTime(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.CreateTime = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetDescription(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.Description = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetExpiredTime(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.ExpiredTime = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetName(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.Name = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetRegionId(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.RegionId = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetResourceGroupId(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.ResourceGroupId = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetState(v string) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.State = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackages) SetTags(v []*ListBandwidthackagesResponseBodyBandwidthPackagesTags) *ListBandwidthackagesResponseBodyBandwidthPackages {
	s.Tags = v
	return s
}

type ListBandwidthackagesResponseBodyBandwidthPackagesTags struct {
	// The tag key of the bandwidth plan.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the bandwidth plan.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListBandwidthackagesResponseBodyBandwidthPackagesTags) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthackagesResponseBodyBandwidthPackagesTags) GoString() string {
	return s.String()
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackagesTags) SetKey(v string) *ListBandwidthackagesResponseBodyBandwidthPackagesTags {
	s.Key = &v
	return s
}

func (s *ListBandwidthackagesResponseBodyBandwidthPackagesTags) SetValue(v string) *ListBandwidthackagesResponseBodyBandwidthPackagesTags {
	s.Value = &v
	return s
}

type ListBandwidthackagesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBandwidthackagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBandwidthackagesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBandwidthackagesResponse) GoString() string {
	return s.String()
}

func (s *ListBandwidthackagesResponse) SetHeaders(v map[string]*string) *ListBandwidthackagesResponse {
	s.Headers = v
	return s
}

func (s *ListBandwidthackagesResponse) SetStatusCode(v int32) *ListBandwidthackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBandwidthackagesResponse) SetBody(v *ListBandwidthackagesResponseBody) *ListBandwidthackagesResponse {
	s.Body = v
	return s
}

type ListBasicAccelerateIpEndpointRelationsRequest struct {
	// The ID of the accelerated IP address.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListBasicAccelerateIpEndpointRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpEndpointRelationsRequest) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpEndpointRelationsRequest) SetAccelerateIpId(v string) *ListBasicAccelerateIpEndpointRelationsRequest {
	s.AccelerateIpId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsRequest) SetAcceleratorId(v string) *ListBasicAccelerateIpEndpointRelationsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsRequest) SetClientToken(v string) *ListBasicAccelerateIpEndpointRelationsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsRequest) SetEndpointId(v string) *ListBasicAccelerateIpEndpointRelationsRequest {
	s.EndpointId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsRequest) SetMaxResults(v int32) *ListBasicAccelerateIpEndpointRelationsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsRequest) SetNextToken(v string) *ListBasicAccelerateIpEndpointRelationsRequest {
	s.NextToken = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsRequest) SetRegionId(v string) *ListBasicAccelerateIpEndpointRelationsRequest {
	s.RegionId = &v
	return s
}

type ListBasicAccelerateIpEndpointRelationsResponseBody struct {
	// A list of accelerated IP addresses and the endpoints with which the accelerated IP addresses are associated.
	AccelerateIpEndpointRelations []*ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations `json:"AccelerateIpEndpointRelations,omitempty" xml:"AccelerateIpEndpointRelations,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	MaxResults *string `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If a value is returned for **NextToken**, the value is the token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBasicAccelerateIpEndpointRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpEndpointRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBody) SetAccelerateIpEndpointRelations(v []*ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) *ListBasicAccelerateIpEndpointRelationsResponseBody {
	s.AccelerateIpEndpointRelations = v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBody) SetMaxResults(v string) *ListBasicAccelerateIpEndpointRelationsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBody) SetNextToken(v string) *ListBasicAccelerateIpEndpointRelationsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBody) SetRequestId(v string) *ListBasicAccelerateIpEndpointRelationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBody) SetTotalCount(v string) *ListBasicAccelerateIpEndpointRelationsResponseBody {
	s.TotalCount = &v
	return s
}

type ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations struct {
	// The ID of the accelerated IP address.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the endpoint.
	EndpointName *string `json:"EndpointName,omitempty" xml:"EndpointName,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, **EndpointSubAddress** returns the primary or secondary private IP address of the primary ENI.
	// *   If the endpoint type is **ENI**, **EndpointSubAddress** returns the primary or secondary private IP address of the secondary ENI.
	// *   If the endpoint type is **NLB**, **EndpointSubAddress** returns the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of the secondary address of the endpoint.
	//
	// *   **primary**: a primary private IP address.
	// *   **secondary**: a secondary private IP address.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**. If the endpoint type is set to **NLB**, **primary** is returned.
	EndpointSubAddressType *string `json:"EndpointSubAddressType,omitempty" xml:"EndpointSubAddressType,omitempty"`
	// The type of endpoint. Valid values:
	//
	// *   **ENI**: elastic network interface (ENI).
	// *   **SLB**: Classic Load Balancer (CLB) instance.
	// *   **ECS**: Elastic Compute Service (ECS) instance.
	// *   **NLB**: Network Load Balancer (NLB) instance.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The ID of the zone where the endpoint is created.
	//
	// This parameter is returned only when the endpoint type is **NLB**.
	EndpointZoneId *string `json:"EndpointZoneId,omitempty" xml:"EndpointZoneId,omitempty"`
	// The accelerated IP address of the basic GA instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The association status between the accelerated IP address and endpoint.
	//
	// A value of **active** indicates that the accelerated IP address is associated with the endpoint.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetAccelerateIpId(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.AccelerateIpId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetAcceleratorId(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.AcceleratorId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetEndpointAddress(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.EndpointAddress = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetEndpointId(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.EndpointId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetEndpointName(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.EndpointName = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetEndpointSubAddress(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.EndpointSubAddress = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetEndpointSubAddressType(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.EndpointSubAddressType = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetEndpointType(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.EndpointType = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetEndpointZoneId(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.EndpointZoneId = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetIpAddress(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.IpAddress = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations) SetState(v string) *ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations {
	s.State = &v
	return s
}

type ListBasicAccelerateIpEndpointRelationsResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBasicAccelerateIpEndpointRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBasicAccelerateIpEndpointRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpEndpointRelationsResponse) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpEndpointRelationsResponse) SetHeaders(v map[string]*string) *ListBasicAccelerateIpEndpointRelationsResponse {
	s.Headers = v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponse) SetStatusCode(v int32) *ListBasicAccelerateIpEndpointRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBasicAccelerateIpEndpointRelationsResponse) SetBody(v *ListBasicAccelerateIpEndpointRelationsResponseBody) *ListBasicAccelerateIpEndpointRelationsResponse {
	s.Body = v
	return s
}

type ListBasicAccelerateIpsRequest struct {
	// The accelerated IP address of the basic GA instance.
	AccelerateIpAddress *string `json:"AccelerateIpAddress,omitempty" xml:"AccelerateIpAddress,omitempty"`
	// The ID of the accelerated IP address of the basic GA instance.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListBasicAccelerateIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpsRequest) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpsRequest) SetAccelerateIpAddress(v string) *ListBasicAccelerateIpsRequest {
	s.AccelerateIpAddress = &v
	return s
}

func (s *ListBasicAccelerateIpsRequest) SetAccelerateIpId(v string) *ListBasicAccelerateIpsRequest {
	s.AccelerateIpId = &v
	return s
}

func (s *ListBasicAccelerateIpsRequest) SetClientToken(v string) *ListBasicAccelerateIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListBasicAccelerateIpsRequest) SetIpSetId(v string) *ListBasicAccelerateIpsRequest {
	s.IpSetId = &v
	return s
}

func (s *ListBasicAccelerateIpsRequest) SetMaxResults(v int32) *ListBasicAccelerateIpsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListBasicAccelerateIpsRequest) SetNextToken(v string) *ListBasicAccelerateIpsRequest {
	s.NextToken = &v
	return s
}

func (s *ListBasicAccelerateIpsRequest) SetRegionId(v string) *ListBasicAccelerateIpsRequest {
	s.RegionId = &v
	return s
}

type ListBasicAccelerateIpsResponseBody struct {
	// The accelerated IP addresses of the basic GA instance.
	AccelerateIps []*ListBasicAccelerateIpsResponseBodyAccelerateIps `json:"AccelerateIps,omitempty" xml:"AccelerateIps,omitempty" type:"Repeated"`
	// The number of entries returned on each page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** was not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBasicAccelerateIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpsResponseBody) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpsResponseBody) SetAccelerateIps(v []*ListBasicAccelerateIpsResponseBodyAccelerateIps) *ListBasicAccelerateIpsResponseBody {
	s.AccelerateIps = v
	return s
}

func (s *ListBasicAccelerateIpsResponseBody) SetMaxResults(v int32) *ListBasicAccelerateIpsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListBasicAccelerateIpsResponseBody) SetNextToken(v string) *ListBasicAccelerateIpsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListBasicAccelerateIpsResponseBody) SetRequestId(v string) *ListBasicAccelerateIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBasicAccelerateIpsResponseBody) SetTotalCount(v int32) *ListBasicAccelerateIpsResponseBody {
	s.TotalCount = &v
	return s
}

type ListBasicAccelerateIpsResponseBodyAccelerateIps struct {
	// The accelerated IP address of the basic GA instance.
	AccelerateIpAddress *string `json:"AccelerateIpAddress,omitempty" xml:"AccelerateIpAddress,omitempty"`
	// The ID of the accelerated IP address of the basic GA instance.
	AccelerateIpId *string `json:"AccelerateIpId,omitempty" xml:"AccelerateIpId,omitempty"`
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the acceleration region.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The status of the accelerated IP address. Valid values:
	//
	// *   **active**: The accelerated IP address is available.
	// *   **binding**: The accelerated IP address is being associated.
	// *   **bound**: The accelerated IP address is associated.
	// *   **unbinding**: The accelerated IP address is being disassociated.
	// *   **deleting**: The accelerated IP address is being deleted.
	//
	// >  This parameter is unavailable when the accelerated IP address is being created.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListBasicAccelerateIpsResponseBodyAccelerateIps) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpsResponseBodyAccelerateIps) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpsResponseBodyAccelerateIps) SetAccelerateIpAddress(v string) *ListBasicAccelerateIpsResponseBodyAccelerateIps {
	s.AccelerateIpAddress = &v
	return s
}

func (s *ListBasicAccelerateIpsResponseBodyAccelerateIps) SetAccelerateIpId(v string) *ListBasicAccelerateIpsResponseBodyAccelerateIps {
	s.AccelerateIpId = &v
	return s
}

func (s *ListBasicAccelerateIpsResponseBodyAccelerateIps) SetAcceleratorId(v string) *ListBasicAccelerateIpsResponseBodyAccelerateIps {
	s.AcceleratorId = &v
	return s
}

func (s *ListBasicAccelerateIpsResponseBodyAccelerateIps) SetIpSetId(v string) *ListBasicAccelerateIpsResponseBodyAccelerateIps {
	s.IpSetId = &v
	return s
}

func (s *ListBasicAccelerateIpsResponseBodyAccelerateIps) SetState(v string) *ListBasicAccelerateIpsResponseBodyAccelerateIps {
	s.State = &v
	return s
}

type ListBasicAccelerateIpsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBasicAccelerateIpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBasicAccelerateIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAccelerateIpsResponse) GoString() string {
	return s.String()
}

func (s *ListBasicAccelerateIpsResponse) SetHeaders(v map[string]*string) *ListBasicAccelerateIpsResponse {
	s.Headers = v
	return s
}

func (s *ListBasicAccelerateIpsResponse) SetStatusCode(v int32) *ListBasicAccelerateIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBasicAccelerateIpsResponse) SetBody(v *ListBasicAccelerateIpsResponseBody) *ListBasicAccelerateIpsResponse {
	s.Body = v
	return s
}

type ListBasicAcceleratorsRequest struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region to which the basic GA instance belongs. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the basic GA instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The state of the basic GA instance. Valid values:
	//
	// *   **init**: The basic GA instance is being initialized.
	// *   **active**: The basic GA instance is available.
	// *   **configuring**: The basic GA instance is being configured.
	// *   **binding**: The basic GA instance is being associated.
	// *   **unbinding**: The basic GA instance is being disassociated.
	// *   **deleting**: The basic GA instance is being deleted.
	// *   **finacialLocked**: The basic GA instance is locked due to overdue payments.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags of the GA instance.
	Tag []*ListBasicAcceleratorsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListBasicAcceleratorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsRequest) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsRequest) SetAcceleratorId(v string) *ListBasicAcceleratorsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListBasicAcceleratorsRequest) SetPageNumber(v int32) *ListBasicAcceleratorsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListBasicAcceleratorsRequest) SetPageSize(v int32) *ListBasicAcceleratorsRequest {
	s.PageSize = &v
	return s
}

func (s *ListBasicAcceleratorsRequest) SetRegionId(v string) *ListBasicAcceleratorsRequest {
	s.RegionId = &v
	return s
}

func (s *ListBasicAcceleratorsRequest) SetResourceGroupId(v string) *ListBasicAcceleratorsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListBasicAcceleratorsRequest) SetState(v string) *ListBasicAcceleratorsRequest {
	s.State = &v
	return s
}

func (s *ListBasicAcceleratorsRequest) SetTag(v []*ListBasicAcceleratorsRequestTag) *ListBasicAcceleratorsRequest {
	s.Tag = v
	return s
}

type ListBasicAcceleratorsRequestTag struct {
	// The key of tag N of the basic GA instance. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N of the basic GA instance. The tag value can be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListBasicAcceleratorsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsRequestTag) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsRequestTag) SetKey(v string) *ListBasicAcceleratorsRequestTag {
	s.Key = &v
	return s
}

func (s *ListBasicAcceleratorsRequestTag) SetValue(v string) *ListBasicAcceleratorsRequestTag {
	s.Value = &v
	return s
}

type ListBasicAcceleratorsResponseBody struct {
	// The information about basic GA instances.
	Accelerators []*ListBasicAcceleratorsResponseBodyAccelerators `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of basic GA instances returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBasicAcceleratorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsResponseBody) SetAccelerators(v []*ListBasicAcceleratorsResponseBodyAccelerators) *ListBasicAcceleratorsResponseBody {
	s.Accelerators = v
	return s
}

func (s *ListBasicAcceleratorsResponseBody) SetPageNumber(v int32) *ListBasicAcceleratorsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBody) SetPageSize(v int32) *ListBasicAcceleratorsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBody) SetRequestId(v string) *ListBasicAcceleratorsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBody) SetTotalCount(v int32) *ListBasicAcceleratorsResponseBody {
	s.TotalCount = &v
	return s
}

type ListBasicAcceleratorsResponseBodyAccelerators struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The bandwidth billing method.
	//
	// *   **BandwidthPackage**: billed based on bandwidth plans.
	// *   **CDT**: billed through Cloud Data Transfer (CDT) and based on data transfer.
	// *   **CDT95**: billed through CDT and based on the 95th percentile bandwidth. This bandwidth billing method is available only for users that are included in the whitelist.
	BandwidthBillingType *string `json:"BandwidthBillingType,omitempty" xml:"BandwidthBillingType,omitempty"`
	// Details about the basic bandwidth plan that is associated with the basic GA instance.
	BasicBandwidthPackage *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage `json:"BasicBandwidthPackage,omitempty" xml:"BasicBandwidthPackage,omitempty" type:"Struct"`
	// The ID of the endpoint group that is associated with the basic GA instance.
	BasicEndpointGroupId *string `json:"BasicEndpointGroupId,omitempty" xml:"BasicEndpointGroupId,omitempty"`
	// The ID of the acceleration region where the basic GA instance is deployed.
	BasicIpSetId *string `json:"BasicIpSetId,omitempty" xml:"BasicIpSetId,omitempty"`
	// The timestamp that indicates when the basic GA instance was created.
	//
	// The time follows the UNIX time format. It is the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether cross-border acceleration is enabled for the GA instance. Valid values:
	//
	// *   **true**
	// *   **false**
	CrossBorderStatus *bool `json:"CrossBorderStatus,omitempty" xml:"CrossBorderStatus,omitempty"`
	// Details about the cross-region acceleration bandwidth plan that is associated with the GA instance.
	//
	// This parameter is returned only when you call this operation on the International site (alibabacloud.com).
	CrossDomainBandwidthPackage *ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage `json:"CrossDomainBandwidthPackage,omitempty" xml:"CrossDomainBandwidthPackage,omitempty" type:"Struct"`
	// The description of the basic GA instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timestamp that indicates when the basic GA instance expires.
	//
	// The time follows the UNIX time format. It is the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	ExpiredTime *int64 `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The billing method of the basic GA instance. Only **PREPAY** is returned, which indicates the subscription billing method.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The name of the basic GA instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the basic GA instance is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the basic GA instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The state of the basic GA instance.
	//
	// *   **init**: The basic GA instance is being initialized.
	// *   **active**: The basic GA instance is available.
	// *   **configuring**: The basic GA instance is being configured.
	// *   **binding**: The basic GA instance is being associated.
	// *   **unbinding**: The GA instance is being disassociated.
	// *   **deleting**: The basic GA instance is being deleted.
	// *   **finacialLocked**: The basic GA instance is locked due to overdue payments.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags of the basic GA instance.
	Tags []*ListBasicAcceleratorsResponseBodyAcceleratorsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// This parameter is invalid.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListBasicAcceleratorsResponseBodyAccelerators) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsResponseBodyAccelerators) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetAcceleratorId(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.AcceleratorId = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetBandwidthBillingType(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.BandwidthBillingType = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetBasicBandwidthPackage(v *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.BasicBandwidthPackage = v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetBasicEndpointGroupId(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.BasicEndpointGroupId = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetBasicIpSetId(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.BasicIpSetId = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetCreateTime(v int64) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.CreateTime = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetCrossBorderStatus(v bool) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.CrossBorderStatus = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetCrossDomainBandwidthPackage(v *ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.CrossDomainBandwidthPackage = v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetDescription(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.Description = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetExpiredTime(v int64) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.ExpiredTime = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetInstanceChargeType(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.InstanceChargeType = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetName(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.Name = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetRegionId(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.RegionId = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetResourceGroupId(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.ResourceGroupId = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetState(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.State = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetTags(v []*ListBasicAcceleratorsResponseBodyAcceleratorsTags) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.Tags = v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAccelerators) SetType(v string) *ListBasicAcceleratorsResponseBodyAccelerators {
	s.Type = &v
	return s
}

type ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage struct {
	// The bandwidth value of the basic bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The type of the bandwidth that is provided by the basic bandwidth plan.
	//
	// *   **Basic**: basic
	// *   **Enhanced**: enhanced
	// *   **Advanced**: premium
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the basic bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) SetBandwidth(v int32) *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) SetBandwidthType(v string) *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage {
	s.BandwidthType = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage) SetInstanceId(v string) *ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage {
	s.InstanceId = &v
	return s
}

type ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage struct {
	// The bandwidth value of the cross-region acceleration bandwidth plan. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the cross-region acceleration bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) SetBandwidth(v int32) *ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage) SetInstanceId(v string) *ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage {
	s.InstanceId = &v
	return s
}

type ListBasicAcceleratorsResponseBodyAcceleratorsTags struct {
	// The tag key of the basic GA instance.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the basic GA instance.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListBasicAcceleratorsResponseBodyAcceleratorsTags) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsResponseBodyAcceleratorsTags) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsResponseBodyAcceleratorsTags) SetKey(v string) *ListBasicAcceleratorsResponseBodyAcceleratorsTags {
	s.Key = &v
	return s
}

func (s *ListBasicAcceleratorsResponseBodyAcceleratorsTags) SetValue(v string) *ListBasicAcceleratorsResponseBodyAcceleratorsTags {
	s.Value = &v
	return s
}

type ListBasicAcceleratorsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBasicAcceleratorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBasicAcceleratorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBasicAcceleratorsResponse) GoString() string {
	return s.String()
}

func (s *ListBasicAcceleratorsResponse) SetHeaders(v map[string]*string) *ListBasicAcceleratorsResponse {
	s.Headers = v
	return s
}

func (s *ListBasicAcceleratorsResponse) SetStatusCode(v int32) *ListBasicAcceleratorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBasicAcceleratorsResponse) SetBody(v *ListBasicAcceleratorsResponseBody) *ListBasicAcceleratorsResponse {
	s.Body = v
	return s
}

type ListBasicEndpointsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group to which the endpoint that you want to query belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint that you want to query.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The type of endpoint that you want to query. Valid values:
	//
	// *   **ENI**: elastic network interface (ENI).
	// *   **SLB**: Classic Load Balancer (CLB) instance.
	// *   **ECS**: Elastic Compute Service (ECS) instance.
	// *   **NLB**: Network Load Balancer (NLB) instance.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The name of the endpoint that you want to query.
	//
	// The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListBasicEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBasicEndpointsRequest) GoString() string {
	return s.String()
}

func (s *ListBasicEndpointsRequest) SetClientToken(v string) *ListBasicEndpointsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListBasicEndpointsRequest) SetEndpointGroupId(v string) *ListBasicEndpointsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ListBasicEndpointsRequest) SetEndpointId(v string) *ListBasicEndpointsRequest {
	s.EndpointId = &v
	return s
}

func (s *ListBasicEndpointsRequest) SetEndpointType(v string) *ListBasicEndpointsRequest {
	s.EndpointType = &v
	return s
}

func (s *ListBasicEndpointsRequest) SetMaxResults(v int32) *ListBasicEndpointsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListBasicEndpointsRequest) SetName(v string) *ListBasicEndpointsRequest {
	s.Name = &v
	return s
}

func (s *ListBasicEndpointsRequest) SetNextToken(v string) *ListBasicEndpointsRequest {
	s.NextToken = &v
	return s
}

func (s *ListBasicEndpointsRequest) SetRegionId(v string) *ListBasicEndpointsRequest {
	s.RegionId = &v
	return s
}

type ListBasicEndpointsResponseBody struct {
	// The endpoints that are associated with the basic GA instance.
	Endpoints []*ListBasicEndpointsResponseBodyEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	MaxResults *string `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If a value is returned for **NextToken**, the value is the token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBasicEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBasicEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *ListBasicEndpointsResponseBody) SetEndpoints(v []*ListBasicEndpointsResponseBodyEndpoints) *ListBasicEndpointsResponseBody {
	s.Endpoints = v
	return s
}

func (s *ListBasicEndpointsResponseBody) SetMaxResults(v string) *ListBasicEndpointsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListBasicEndpointsResponseBody) SetNextToken(v string) *ListBasicEndpointsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListBasicEndpointsResponseBody) SetRequestId(v string) *ListBasicEndpointsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBasicEndpointsResponseBody) SetTotalCount(v string) *ListBasicEndpointsResponseBody {
	s.TotalCount = &v
	return s
}

type ListBasicEndpointsResponseBodyEndpoints struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint group to which the endpoint belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint that is associated with the basic GA instance.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is returned if the endpoint type is **ECS**, **ENI**, or **NLB**.
	//
	// *   If the endpoint type is **ECS**, **EndpointSubAddress** returns the primary or secondary private IP address of the primary ENI.
	// *   If the endpoint type is **ENI**, **EndpointSubAddress** returns the primary or secondary private IP address of the secondary ENI.
	// *   If the endpoint type is **NLB**, **EndpointSubAddress** returns the primary private IP address of the NLB backend server.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The secondary address type of the endpoint.
	//
	// *   **primary**: a primary private IP address.
	// *   **secondary**: a secondary private IP address.
	//
	// This parameter is returned if the type of the endpoint is set to **ECS**, **ENI**, or **NLB**. If the endpoint type is set to **NLB**, **primary** is returned.
	EndpointSubAddressType *string `json:"EndpointSubAddressType,omitempty" xml:"EndpointSubAddressType,omitempty"`
	// The type of endpoint. Valid values:
	//
	// *   **ENI**: ENI.
	// *   **SLB**: CLB instance.
	// *   **ECS**: ECS instance.
	// *   **NLB**: NLB instance.
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The zone ID of the endpoint.
	//
	// This parameter is returned only when the endpoint type is set to **NLB**.
	EndpointZoneId *string `json:"EndpointZoneId,omitempty" xml:"EndpointZoneId,omitempty"`
	// The name of the endpoint.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The status of the endpoint. Valid values:
	//
	// *   **init**: The endpoint is being initialized.
	// *   **active**: The endpoint is available.
	// *   **updating**: The endpoint is being configured.
	// *   **binding**: The endpoint is being associated.
	// *   **unbinding**: The endpoint is being disassociated.
	// *   **deleting**: The endpoint is being deleted.
	// *   **bound**: The endpoint is associated.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListBasicEndpointsResponseBodyEndpoints) String() string {
	return tea.Prettify(s)
}

func (s ListBasicEndpointsResponseBodyEndpoints) GoString() string {
	return s.String()
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetAcceleratorId(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.AcceleratorId = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetEndpointAddress(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.EndpointAddress = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetEndpointGroupId(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.EndpointGroupId = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetEndpointId(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.EndpointId = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetEndpointSubAddress(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.EndpointSubAddress = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetEndpointSubAddressType(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.EndpointSubAddressType = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetEndpointType(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.EndpointType = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetEndpointZoneId(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.EndpointZoneId = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetName(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.Name = &v
	return s
}

func (s *ListBasicEndpointsResponseBodyEndpoints) SetState(v string) *ListBasicEndpointsResponseBodyEndpoints {
	s.State = &v
	return s
}

type ListBasicEndpointsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBasicEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBasicEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBasicEndpointsResponse) GoString() string {
	return s.String()
}

func (s *ListBasicEndpointsResponse) SetHeaders(v map[string]*string) *ListBasicEndpointsResponse {
	s.Headers = v
	return s
}

func (s *ListBasicEndpointsResponse) SetStatusCode(v int32) *ListBasicEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBasicEndpointsResponse) SetBody(v *ListBasicEndpointsResponseBody) *ListBasicEndpointsResponse {
	s.Body = v
	return s
}

type ListBusiRegionsRequest struct {
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListBusiRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBusiRegionsRequest) GoString() string {
	return s.String()
}

func (s *ListBusiRegionsRequest) SetRegionId(v string) *ListBusiRegionsRequest {
	s.RegionId = &v
	return s
}

type ListBusiRegionsResponseBody struct {
	// The information of the regions.
	Regions []*ListBusiRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListBusiRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBusiRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListBusiRegionsResponseBody) SetRegions(v []*ListBusiRegionsResponseBodyRegions) *ListBusiRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *ListBusiRegionsResponseBody) SetRequestId(v string) *ListBusiRegionsResponseBody {
	s.RequestId = &v
	return s
}

type ListBusiRegionsResponseBodyRegions struct {
	// The name of the region.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The ID of the region where the GA instance is deployed. Only **cn-hangzhou** is returned.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListBusiRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s ListBusiRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *ListBusiRegionsResponseBodyRegions) SetLocalName(v string) *ListBusiRegionsResponseBodyRegions {
	s.LocalName = &v
	return s
}

func (s *ListBusiRegionsResponseBodyRegions) SetRegionId(v string) *ListBusiRegionsResponseBodyRegions {
	s.RegionId = &v
	return s
}

type ListBusiRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListBusiRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListBusiRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBusiRegionsResponse) GoString() string {
	return s.String()
}

func (s *ListBusiRegionsResponse) SetHeaders(v map[string]*string) *ListBusiRegionsResponse {
	s.Headers = v
	return s
}

func (s *ListBusiRegionsResponse) SetStatusCode(v int32) *ListBusiRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBusiRegionsResponse) SetBody(v *ListBusiRegionsResponseBody) *ListBusiRegionsResponse {
	s.Body = v
	return s
}

type ListCommonAreasRequest struct {
	// The IP version used to connect to the GA instance. Valid values:
	//
	// *   **IPv4** (default)
	// *   **IPv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// Specifies whether to query regions where endpoint groups of GA can be deployed. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	IsEpg *bool `json:"IsEpg,omitempty" xml:"IsEpg,omitempty"`
	// Specifies whether to query regions supported by GA. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	IsIpSet *bool `json:"IsIpSet,omitempty" xml:"IsIpSet,omitempty"`
}

func (s ListCommonAreasRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCommonAreasRequest) GoString() string {
	return s.String()
}

func (s *ListCommonAreasRequest) SetIpVersion(v string) *ListCommonAreasRequest {
	s.IpVersion = &v
	return s
}

func (s *ListCommonAreasRequest) SetIsEpg(v bool) *ListCommonAreasRequest {
	s.IsEpg = &v
	return s
}

func (s *ListCommonAreasRequest) SetIsIpSet(v bool) *ListCommonAreasRequest {
	s.IsIpSet = &v
	return s
}

type ListCommonAreasResponseBody struct {
	// The information about the areas.
	Areas []*ListCommonAreasResponseBodyAreas `json:"Areas,omitempty" xml:"Areas,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListCommonAreasResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCommonAreasResponseBody) GoString() string {
	return s.String()
}

func (s *ListCommonAreasResponseBody) SetAreas(v []*ListCommonAreasResponseBodyAreas) *ListCommonAreasResponseBody {
	s.Areas = v
	return s
}

func (s *ListCommonAreasResponseBody) SetRequestId(v string) *ListCommonAreasResponseBody {
	s.RequestId = &v
	return s
}

type ListCommonAreasResponseBodyAreas struct {
	// The area ID.
	AreaId *string `json:"AreaId,omitempty" xml:"AreaId,omitempty"`
	// The area name.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The information about the regions.
	RegionList []*ListCommonAreasResponseBodyAreasRegionList `json:"RegionList,omitempty" xml:"RegionList,omitempty" type:"Repeated"`
}

func (s ListCommonAreasResponseBodyAreas) String() string {
	return tea.Prettify(s)
}

func (s ListCommonAreasResponseBodyAreas) GoString() string {
	return s.String()
}

func (s *ListCommonAreasResponseBodyAreas) SetAreaId(v string) *ListCommonAreasResponseBodyAreas {
	s.AreaId = &v
	return s
}

func (s *ListCommonAreasResponseBodyAreas) SetLocalName(v string) *ListCommonAreasResponseBodyAreas {
	s.LocalName = &v
	return s
}

func (s *ListCommonAreasResponseBodyAreas) SetRegionList(v []*ListCommonAreasResponseBodyAreasRegionList) *ListCommonAreasResponseBodyAreas {
	s.RegionList = v
	return s
}

type ListCommonAreasResponseBodyAreasRegionList struct {
	// The region name.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListCommonAreasResponseBodyAreasRegionList) String() string {
	return tea.Prettify(s)
}

func (s ListCommonAreasResponseBodyAreasRegionList) GoString() string {
	return s.String()
}

func (s *ListCommonAreasResponseBodyAreasRegionList) SetLocalName(v string) *ListCommonAreasResponseBodyAreasRegionList {
	s.LocalName = &v
	return s
}

func (s *ListCommonAreasResponseBodyAreasRegionList) SetRegionId(v string) *ListCommonAreasResponseBodyAreasRegionList {
	s.RegionId = &v
	return s
}

type ListCommonAreasResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCommonAreasResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCommonAreasResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCommonAreasResponse) GoString() string {
	return s.String()
}

func (s *ListCommonAreasResponse) SetHeaders(v map[string]*string) *ListCommonAreasResponse {
	s.Headers = v
	return s
}

func (s *ListCommonAreasResponse) SetStatusCode(v int32) *ListCommonAreasResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCommonAreasResponse) SetBody(v *ListCommonAreasResponseBody) *ListCommonAreasResponse {
	s.Body = v
	return s
}

type ListCustomRoutingEndpointGroupDestinationsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The start port of the backend service port range of the endpoint group.
	//
	// Valid values: **1** to **65499**. The **FromPort** value must be smaller than or equal to the **ToPort** value.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The backend service protocols of the endpoint group. Valid values:
	//
	// - **TCP**: TCP.
	// - **UDP**: UDP.
	// - **TCP,UDP**: TCP and UDP.
	//
	// If this parameter is empty, all types of protocols are queried.
	//
	// You can specify up to 10 protocols.
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The end port of the backend service port range of the endpoint group.
	//
	// Valid values: **1** to **65499**. The **FromPort** value must be smaller than or equal to the **ToPort** value.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s ListCustomRoutingEndpointGroupDestinationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupDestinationsRequest) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetAcceleratorId(v string) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetEndpointGroupId(v string) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetFromPort(v int32) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.FromPort = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetListenerId(v string) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetPageNumber(v int32) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetPageSize(v int32) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetProtocols(v []*string) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.Protocols = v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetRegionId(v string) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.RegionId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsRequest) SetToPort(v int32) *ListCustomRoutingEndpointGroupDestinationsRequest {
	s.ToPort = &v
	return s
}

type ListCustomRoutingEndpointGroupDestinationsResponseBody struct {
	// The details about the endpoint group mapping configurations.
	Destinations []*ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations `json:"Destinations,omitempty" xml:"Destinations,omitempty" type:"Repeated"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCustomRoutingEndpointGroupDestinationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupDestinationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBody) SetDestinations(v []*ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) *ListCustomRoutingEndpointGroupDestinationsResponseBody {
	s.Destinations = v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBody) SetPageNumber(v int32) *ListCustomRoutingEndpointGroupDestinationsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBody) SetPageSize(v int32) *ListCustomRoutingEndpointGroupDestinationsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBody) SetRequestId(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBody) SetTotalCount(v int32) *ListCustomRoutingEndpointGroupDestinationsResponseBody {
	s.TotalCount = &v
	return s
}

type ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint group mapping configuration.
	DestinationId *string `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The start port of the backend service port range of the endpoint group.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The backend service protocol of the endpoint group.
	//
	// *   **TCP**: TCP
	// *   **UDP**: UDP
	// *   **TCP,UDP**: TCP and UDP
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - **true**
	//
	// - **false**
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The end port of the backend service port range of the endpoint group.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetAcceleratorId(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetDestinationId(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.DestinationId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetEndpointGroupId(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetFromPort(v int32) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.FromPort = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetListenerId(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetProtocols(v []*string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.Protocols = v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetServiceId(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.ServiceId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetServiceManaged(v bool) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.ServiceManaged = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetServiceManagedInfos(v []*ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.ServiceManagedInfos = v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations) SetToPort(v int32) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations {
	s.ToPort = &v
	return s
}

type ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	//
	// Create
	// Update
	// Delete
	// Associate
	// UserUnmanaged
	// CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// Listener
	// IpSet
	// EndpointGroup
	// ForwardingRule
	// Endpoint
	// EndpointGroupDestination
	// EndpointPolicy
	//
	// > Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - **true**: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - **false**: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos) SetAction(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos) SetChildType(v string) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos) SetIsManaged(v bool) *ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinationsServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListCustomRoutingEndpointGroupDestinationsResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCustomRoutingEndpointGroupDestinationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCustomRoutingEndpointGroupDestinationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupDestinationsResponse) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponse) SetHeaders(v map[string]*string) *ListCustomRoutingEndpointGroupDestinationsResponse {
	s.Headers = v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponse) SetStatusCode(v int32) *ListCustomRoutingEndpointGroupDestinationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupDestinationsResponse) SetBody(v *ListCustomRoutingEndpointGroupDestinationsResponseBody) *ListCustomRoutingEndpointGroupDestinationsResponse {
	s.Body = v
	return s
}

type ListCustomRoutingEndpointGroupsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the custom routing listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListCustomRoutingEndpointGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupsRequest) SetAcceleratorId(v string) *ListCustomRoutingEndpointGroupsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsRequest) SetEndpointGroupId(v string) *ListCustomRoutingEndpointGroupsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsRequest) SetListenerId(v string) *ListCustomRoutingEndpointGroupsRequest {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsRequest) SetPageNumber(v int32) *ListCustomRoutingEndpointGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsRequest) SetPageSize(v int32) *ListCustomRoutingEndpointGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsRequest) SetRegionId(v string) *ListCustomRoutingEndpointGroupsRequest {
	s.RegionId = &v
	return s
}

type ListCustomRoutingEndpointGroupsResponseBody struct {
	// The configuration information about the endpoint groups.
	EndpointGroups []*ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups `json:"EndpointGroups,omitempty" xml:"EndpointGroups,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCustomRoutingEndpointGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupsResponseBody) SetEndpointGroups(v []*ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) *ListCustomRoutingEndpointGroupsResponseBody {
	s.EndpointGroups = v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBody) SetPageNumber(v int32) *ListCustomRoutingEndpointGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBody) SetPageSize(v int32) *ListCustomRoutingEndpointGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBody) SetRequestId(v string) *ListCustomRoutingEndpointGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBody) SetTotalCount(v int32) *ListCustomRoutingEndpointGroupsResponseBody {
	s.TotalCount = &v
	return s
}

type ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The description of the endpoint group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The list of endpoint group IP addresses.
	EndpointGroupIpList []*string `json:"EndpointGroupIpList,omitempty" xml:"EndpointGroupIpList,omitempty" type:"Repeated"`
	// The ID of the region where the endpoint group is created.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The endpoint group IP addresses to be confirmed after the GA instance is upgraded.
	EndpointGroupUnconfirmedIpList []*string `json:"EndpointGroupUnconfirmedIpList,omitempty" xml:"EndpointGroupUnconfirmedIpList,omitempty" type:"Repeated"`
	// The ID of the custom routing listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the endpoint group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The status of the endpoint group.
	//
	// *   **init**: being initialized
	// *   **active**: running as expected
	// *   **updating**: being updated
	// *   **deleting**: being deleted
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetAcceleratorId(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetDescription(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.Description = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupId(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupIpList(v []*string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupIpList = v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupRegion(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupRegion = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupUnconfirmedIpList(v []*string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupUnconfirmedIpList = v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetListenerId(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetName(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.Name = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetServiceId(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.ServiceId = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetServiceManaged(v bool) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.ServiceManaged = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetServiceManagedInfos(v []*ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.ServiceManagedInfos = v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups) SetState(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups {
	s.State = &v
	return s
}

type ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) SetAction(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) SetChildType(v string) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) SetIsManaged(v bool) *ListCustomRoutingEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListCustomRoutingEndpointGroupsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCustomRoutingEndpointGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCustomRoutingEndpointGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointGroupsResponse) SetHeaders(v map[string]*string) *ListCustomRoutingEndpointGroupsResponse {
	s.Headers = v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponse) SetStatusCode(v int32) *ListCustomRoutingEndpointGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCustomRoutingEndpointGroupsResponse) SetBody(v *ListCustomRoutingEndpointGroupsResponseBody) *ListCustomRoutingEndpointGroupsResponse {
	s.Body = v
	return s
}

type ListCustomRoutingEndpointTrafficPoliciesRequest struct {
	// The ID of the GA instance to which the traffic policies belong.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The IP address of the traffic destination.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the endpoint group to which the traffic policies belong.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint to which the traffic policies belong.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the listener to which the traffic policies belong.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListCustomRoutingEndpointTrafficPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointTrafficPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetAcceleratorId(v string) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetAddress(v string) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.Address = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetEndpointGroupId(v string) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetEndpointId(v string) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.EndpointId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetListenerId(v string) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetPageNumber(v int32) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetPageSize(v int32) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesRequest) SetRegionId(v string) *ListCustomRoutingEndpointTrafficPoliciesRequest {
	s.RegionId = &v
	return s
}

type ListCustomRoutingEndpointTrafficPoliciesResponseBody struct {
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The list of traffic policies.
	Policies []*ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBody) SetPageNumber(v int32) *ListCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBody) SetPageSize(v int32) *ListCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBody) SetPolicies(v []*ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) *ListCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.Policies = v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBody) SetRequestId(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBody) SetTotalCount(v int32) *ListCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

type ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies struct {
	// The ID of the GA instance with which the endpoint is associated.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The IP address of the traffic destination.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the endpoint group to which the endpoint belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint to which the traffic destination belongs.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the custom routing listener with which the endpoint is associated.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The traffic policy ID.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The port range of the traffic policy.
	PortRanges []*ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
	// 托管实例所属的服务方ID。
	// > 仅在**ServiceManaged**参数为**True**时有效。
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// 是否为托管实例。取值：
	//
	// - true：是托管资实例。
	//
	// - false：不是托管实例。
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// 用户在此托管实例下可执行的动作策略列表。
	//
	// > 仅在**ServiceManaged**参数为**True**时有效。
	// > - 当实例处于托管状态时，用户对实例的操作会受到限制，某些操作行为会被禁止。
	ServiceManagedInfos []*ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetAcceleratorId(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetAddress(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.Address = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetEndpointGroupId(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetEndpointId(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.EndpointId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetListenerId(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetPolicyId(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.PolicyId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetPortRanges(v []*ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.PortRanges = v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetServiceId(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.ServiceId = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetServiceManaged(v bool) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.ServiceManaged = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies) SetServiceManagedInfos(v []*ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies {
	s.ServiceManagedInfos = v
	return s
}

type ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges struct {
	// The first port of the port range used by the traffic destination to process requests.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port of the port range used by the traffic destination to process requests.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges) SetFromPort(v int32) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges {
	s.FromPort = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges) SetToPort(v int32) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges {
	s.ToPort = &v
	return s
}

type ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos struct {
	// 托管策略动作名称，取值：
	// - **Create**：创建实例。
	// - **Update**：更新当前实例。
	// - **Delete**：删除当前实例。
	// - **Associate**：引用/被引用当前实例。
	// - **UserUnmanaged**：用户解托管实例。
	// - **CreateChild**：在当前实例下创建子资源。
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// 子资源类型，取值：
	//
	// - **Listener**：监听资源。
	//
	// - **IpSet**：加速地域资源。
	//
	// - **EndpointGroup**：终端节点组资源。
	//
	// - **ForwardingRule**：转发策略资源。
	//
	// - **Endpoint**：终端节点资源。
	//
	// - **EndpointGroupDestination**：自定义路由监听下的终端节点组协议映射资源。
	//
	// - **EndpointPolicy**：自定义路由监听下的终端节点通行策略资源。
	//
	// > 仅在**Action**参数为**CreateChild**时有效。
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// 托管策略动作是否被托管，取值：
	//
	// - **true**：托管策略动作被托管，用户无权在托管实例下执行Action指定的操作。
	//
	// - **false**：托管策略动作未被托管，用户可在托管实例下执行Action指定的操作。
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos) SetAction(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos) SetChildType(v string) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos) SetIsManaged(v bool) *ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListCustomRoutingEndpointTrafficPoliciesResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCustomRoutingEndpointTrafficPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointTrafficPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponse) SetHeaders(v map[string]*string) *ListCustomRoutingEndpointTrafficPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponse) SetStatusCode(v int32) *ListCustomRoutingEndpointTrafficPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCustomRoutingEndpointTrafficPoliciesResponse) SetBody(v *ListCustomRoutingEndpointTrafficPoliciesResponseBody) *ListCustomRoutingEndpointTrafficPoliciesResponse {
	s.Body = v
	return s
}

type ListCustomRoutingEndpointsRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The endpoint group ID.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The listener ID.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListCustomRoutingEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointsRequest) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointsRequest) SetAcceleratorId(v string) *ListCustomRoutingEndpointsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointsRequest) SetEndpointGroupId(v string) *ListCustomRoutingEndpointsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointsRequest) SetListenerId(v string) *ListCustomRoutingEndpointsRequest {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointsRequest) SetPageNumber(v int32) *ListCustomRoutingEndpointsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointsRequest) SetPageSize(v int32) *ListCustomRoutingEndpointsRequest {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointsRequest) SetRegionId(v string) *ListCustomRoutingEndpointsRequest {
	s.RegionId = &v
	return s
}

type ListCustomRoutingEndpointsResponseBody struct {
	// Information about the endpoints.
	Endpoints []*ListCustomRoutingEndpointsResponseBodyEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCustomRoutingEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointsResponseBody) SetEndpoints(v []*ListCustomRoutingEndpointsResponseBodyEndpoints) *ListCustomRoutingEndpointsResponseBody {
	s.Endpoints = v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBody) SetPageNumber(v int32) *ListCustomRoutingEndpointsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBody) SetPageSize(v int32) *ListCustomRoutingEndpointsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBody) SetRequestId(v string) *ListCustomRoutingEndpointsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBody) SetTotalCount(v int32) *ListCustomRoutingEndpointsResponseBody {
	s.TotalCount = &v
	return s
}

type ListCustomRoutingEndpointsResponseBodyEndpoints struct {
	// The ID of the GA instance with which the endpoint is associated.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The name of the vSwitch that is specified as an endpoint.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The ID of the endpoint group to which the endpoint belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The endpoint ID.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the listener to which the endpoint belongs.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// 托管实例所属的服务方ID。
	//
	// > 仅在**ServiceManaged**参数为**True**时有效。
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// 是否为托管实例。取值：
	//
	// - **true**：是托管资实例。
	//
	// - **false**：不是托管实例。
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// 用户在此托管实例下可执行的动作策略列表。
	//
	// > 仅在**ServiceManaged**参数为**True**时有效。
	// > - 当实例处于托管状态时，用户对实例的操作会受到限制，某些操作行为会被禁止。
	ServiceManagedInfos []*ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The access policy of traffic that is destinated for the endpoint. Valid values:
	//
	// *   **AllowAll:** allows all traffic to the endpoint.
	// *   **DenyAll:** denies all traffic to the endpoint.
	// *   **AllowCustom:** allows traffic only to specified destinations.
	TrafficToEndpointPolicy *string `json:"TrafficToEndpointPolicy,omitempty" xml:"TrafficToEndpointPolicy,omitempty"`
	// The backend service type of the endpoint.
	//
	// **PrivateSubNet** is returned, which indicates a private CIDR block.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListCustomRoutingEndpointsResponseBodyEndpoints) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointsResponseBodyEndpoints) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetAcceleratorId(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetEndpoint(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.Endpoint = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetEndpointGroupId(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetEndpointId(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.EndpointId = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetListenerId(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetServiceId(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.ServiceId = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetServiceManaged(v bool) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.ServiceManaged = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetServiceManagedInfos(v []*ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.ServiceManagedInfos = v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetTrafficToEndpointPolicy(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.TrafficToEndpointPolicy = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpoints) SetType(v string) *ListCustomRoutingEndpointsResponseBodyEndpoints {
	s.Type = &v
	return s
}

type ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos struct {
	// 托管策略动作名称，取值：
	// - **Create**：创建实例。
	// - **Update**：更新当前实例。
	// - **Delete**：删除当前实例。
	// - **Associate**：引用/被引用当前实例。
	// - **UserUnmanaged**：用户解托管实例。
	// - **CreateChild**：在当前实例下创建子资源。
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// 子资源类型，取值：
	//
	// - **Listener**：监听资源。
	//
	// - **IpSet**：加速地域资源。
	//
	// - **EndpointGroup**：终端节点组资源。
	//
	// - **ForwardingRule**：转发策略资源。
	//
	// - **Endpoint**：终端节点资源。
	//
	// - **EndpointGroupDestination**：自定义路由监听下的终端节点组协议映射资源。
	//
	// - **EndpointPolicy**：自定义路由监听下的终端节点通行策略资源。
	//
	// > 仅在**Action**参数为**CreateChild**时有效。
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// 托管策略动作是否被托管，取值：
	// - **true**：托管策略动作被托管，用户无权在托管实例下执行Action指定的操作。
	// - **false**：托管策略动作未被托管，用户可在托管实例下执行Action指定的操作。
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos) SetAction(v string) *ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos) SetChildType(v string) *ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos) SetIsManaged(v bool) *ListCustomRoutingEndpointsResponseBodyEndpointsServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListCustomRoutingEndpointsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCustomRoutingEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCustomRoutingEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingEndpointsResponse) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingEndpointsResponse) SetHeaders(v map[string]*string) *ListCustomRoutingEndpointsResponse {
	s.Headers = v
	return s
}

func (s *ListCustomRoutingEndpointsResponse) SetStatusCode(v int32) *ListCustomRoutingEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCustomRoutingEndpointsResponse) SetBody(v *ListCustomRoutingEndpointsResponseBody) *ListCustomRoutingEndpointsResponse {
	s.Body = v
	return s
}

type ListCustomRoutingPortMappingsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListCustomRoutingPortMappingsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsRequest) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsRequest) SetAcceleratorId(v string) *ListCustomRoutingPortMappingsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsRequest) SetEndpointGroupId(v string) *ListCustomRoutingPortMappingsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsRequest) SetListenerId(v string) *ListCustomRoutingPortMappingsRequest {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsRequest) SetPageNumber(v int32) *ListCustomRoutingPortMappingsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingPortMappingsRequest) SetPageSize(v int32) *ListCustomRoutingPortMappingsRequest {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingPortMappingsRequest) SetRegionId(v string) *ListCustomRoutingPortMappingsRequest {
	s.RegionId = &v
	return s
}

type ListCustomRoutingPortMappingsResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Details about the port mapping table.
	PortMappings []*ListCustomRoutingPortMappingsResponseBodyPortMappings `json:"PortMappings,omitempty" xml:"PortMappings,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCustomRoutingPortMappingsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsResponseBody) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsResponseBody) SetPageNumber(v int32) *ListCustomRoutingPortMappingsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBody) SetPageSize(v int32) *ListCustomRoutingPortMappingsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBody) SetPortMappings(v []*ListCustomRoutingPortMappingsResponseBodyPortMappings) *ListCustomRoutingPortMappingsResponseBody {
	s.PortMappings = v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBody) SetRequestId(v string) *ListCustomRoutingPortMappingsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBody) SetTotalCount(v int32) *ListCustomRoutingPortMappingsResponseBody {
	s.TotalCount = &v
	return s
}

type ListCustomRoutingPortMappingsResponseBodyPortMappings struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The acceleration port.
	AcceleratorPort *int32 `json:"AcceleratorPort,omitempty" xml:"AcceleratorPort,omitempty"`
	// The service IP address and port of the backend instance.
	DestinationSocketAddress *ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress `json:"DestinationSocketAddress,omitempty" xml:"DestinationSocketAddress,omitempty" type:"Struct"`
	// The access policy of traffic for the backend instance. Valid values:
	//
	// *   **allow**: allows traffic to the backend instance.
	// *   **deny**: denies traffic to the backend instance.
	DestinationTrafficState *string `json:"DestinationTrafficState,omitempty" xml:"DestinationTrafficState,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region in which the endpoint group resides.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The protocol of the backend service.
	//
	// *   **tcp**: TCP
	// *   **udp**: UDP
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The name of the endpoint (vSwitch).
	Vswitch *string `json:"Vswitch,omitempty" xml:"Vswitch,omitempty"`
}

func (s ListCustomRoutingPortMappingsResponseBodyPortMappings) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsResponseBodyPortMappings) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetAcceleratorId(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetAcceleratorPort(v int32) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.AcceleratorPort = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetDestinationSocketAddress(v *ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.DestinationSocketAddress = v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetDestinationTrafficState(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.DestinationTrafficState = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetEndpointGroupId(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetEndpointGroupRegion(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.EndpointGroupRegion = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetEndpointId(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.EndpointId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetListenerId(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetProtocols(v []*string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.Protocols = v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappings) SetVswitch(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappings {
	s.Vswitch = &v
	return s
}

type ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress struct {
	// The service IP address of the backend instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The service port of the backend instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress) SetIpAddress(v string) *ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress {
	s.IpAddress = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress) SetPort(v int32) *ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress {
	s.Port = &v
	return s
}

type ListCustomRoutingPortMappingsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCustomRoutingPortMappingsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCustomRoutingPortMappingsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsResponse) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsResponse) SetHeaders(v map[string]*string) *ListCustomRoutingPortMappingsResponse {
	s.Headers = v
	return s
}

func (s *ListCustomRoutingPortMappingsResponse) SetStatusCode(v int32) *ListCustomRoutingPortMappingsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCustomRoutingPortMappingsResponse) SetBody(v *ListCustomRoutingPortMappingsResponseBody) *ListCustomRoutingPortMappingsResponse {
	s.Body = v
	return s
}

type ListCustomRoutingPortMappingsByDestinationRequest struct {
	// The service IP address of the backend instance.
	DestinationAddress *string `json:"DestinationAddress,omitempty" xml:"DestinationAddress,omitempty"`
	// The ID of the endpoint to which the backend instance belongs.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListCustomRoutingPortMappingsByDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsByDestinationRequest) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsByDestinationRequest) SetDestinationAddress(v string) *ListCustomRoutingPortMappingsByDestinationRequest {
	s.DestinationAddress = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationRequest) SetEndpointId(v string) *ListCustomRoutingPortMappingsByDestinationRequest {
	s.EndpointId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationRequest) SetPageNumber(v int32) *ListCustomRoutingPortMappingsByDestinationRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationRequest) SetPageSize(v int32) *ListCustomRoutingPortMappingsByDestinationRequest {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationRequest) SetRegionId(v string) *ListCustomRoutingPortMappingsByDestinationRequest {
	s.RegionId = &v
	return s
}

type ListCustomRoutingPortMappingsByDestinationResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Details about the port mapping table.
	PortMappings []*ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings `json:"PortMappings,omitempty" xml:"PortMappings,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCustomRoutingPortMappingsByDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsByDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBody) SetPageNumber(v int32) *ListCustomRoutingPortMappingsByDestinationResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBody) SetPageSize(v int32) *ListCustomRoutingPortMappingsByDestinationResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBody) SetPortMappings(v []*ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) *ListCustomRoutingPortMappingsByDestinationResponseBody {
	s.PortMappings = v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBody) SetRequestId(v string) *ListCustomRoutingPortMappingsByDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBody) SetTotalCount(v int32) *ListCustomRoutingPortMappingsByDestinationResponseBody {
	s.TotalCount = &v
	return s
}

type ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The acceleration port.
	AcceleratorPort *int32 `json:"AcceleratorPort,omitempty" xml:"AcceleratorPort,omitempty"`
	// The service IP address and port of the backend instance.
	DestinationSocketAddress *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress `json:"DestinationSocketAddress,omitempty" xml:"DestinationSocketAddress,omitempty" type:"Struct"`
	// The access policy of traffic for the backend instance.
	//
	// *   **allow**: allows traffic to the backend instance.
	// *   **deny**: denies all traffic to the backend instance.
	DestinationTrafficState *string `json:"DestinationTrafficState,omitempty" xml:"DestinationTrafficState,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region in which the endpoint group resides.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The protocol of the backend service.
	//
	// *   **tcp**: TCP
	// *   **udp**: UDP
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The name of the endpoint (vSwitch).
	Vswitch *string `json:"Vswitch,omitempty" xml:"Vswitch,omitempty"`
}

func (s ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetAcceleratorId(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.AcceleratorId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetAcceleratorPort(v int32) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.AcceleratorPort = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetDestinationSocketAddress(v *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.DestinationSocketAddress = v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetDestinationTrafficState(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.DestinationTrafficState = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetEndpointGroupId(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.EndpointGroupId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetEndpointGroupRegion(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.EndpointGroupRegion = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetEndpointId(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.EndpointId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetListenerId(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.ListenerId = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetProtocols(v []*string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.Protocols = v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings) SetVswitch(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings {
	s.Vswitch = &v
	return s
}

type ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress struct {
	// The service IP address of the backend instance.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The service port of the backend instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress) SetIpAddress(v string) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress {
	s.IpAddress = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress) SetPort(v int32) *ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress {
	s.Port = &v
	return s
}

type ListCustomRoutingPortMappingsByDestinationResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCustomRoutingPortMappingsByDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCustomRoutingPortMappingsByDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCustomRoutingPortMappingsByDestinationResponse) GoString() string {
	return s.String()
}

func (s *ListCustomRoutingPortMappingsByDestinationResponse) SetHeaders(v map[string]*string) *ListCustomRoutingPortMappingsByDestinationResponse {
	s.Headers = v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponse) SetStatusCode(v int32) *ListCustomRoutingPortMappingsByDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCustomRoutingPortMappingsByDestinationResponse) SetBody(v *ListCustomRoutingPortMappingsByDestinationResponseBody) *ListCustomRoutingPortMappingsByDestinationResponse {
	s.Body = v
	return s
}

type ListDomainsRequest struct {
	// The ID of the GA instance that you want to query.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The accelerated domain name that you want to query.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ICP filing status of the accelerated domain name that you want to query. Valid values:
	//
	// *   **illegal:** The domain name is illegal.
	// *   **inactive:** The domain name has not completed ICP filing.
	// *   **active:** The domain name has a valid ICP filing.
	// *   **unknown:** The ICP filing status is unknown.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsRequest) GoString() string {
	return s.String()
}

func (s *ListDomainsRequest) SetAcceleratorId(v string) *ListDomainsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListDomainsRequest) SetDomain(v string) *ListDomainsRequest {
	s.Domain = &v
	return s
}

func (s *ListDomainsRequest) SetPageNumber(v int32) *ListDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDomainsRequest) SetPageSize(v int32) *ListDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *ListDomainsRequest) SetRegionId(v string) *ListDomainsRequest {
	s.RegionId = &v
	return s
}

func (s *ListDomainsRequest) SetState(v string) *ListDomainsRequest {
	s.State = &v
	return s
}

type ListDomainsResponseBody struct {
	// The list of accelerated domain names.
	Domains []*ListDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDomainsResponseBody) SetDomains(v []*ListDomainsResponseBodyDomains) *ListDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *ListDomainsResponseBody) SetPageNumber(v int32) *ListDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListDomainsResponseBody) SetPageSize(v int32) *ListDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListDomainsResponseBody) SetRequestId(v string) *ListDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDomainsResponseBody) SetTotalCount(v int32) *ListDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type ListDomainsResponseBodyDomains struct {
	// The list of GA instances.
	Accelerators []*ListDomainsResponseBodyDomainsAccelerators `json:"Accelerators,omitempty" xml:"Accelerators,omitempty" type:"Repeated"`
	// The accelerated domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ICP filing status of the accelerated domain name.
	//
	// *   **illegal:** The domain name is illegal.
	// *   **inactive:** The domain name has not completed ICP filing.
	// *   **active:** The domain name has a valid ICP filing.
	// *   **unknown:** The ICP filing status is unknown.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *ListDomainsResponseBodyDomains) SetAccelerators(v []*ListDomainsResponseBodyDomainsAccelerators) *ListDomainsResponseBodyDomains {
	s.Accelerators = v
	return s
}

func (s *ListDomainsResponseBodyDomains) SetDomain(v string) *ListDomainsResponseBodyDomains {
	s.Domain = &v
	return s
}

func (s *ListDomainsResponseBodyDomains) SetState(v string) *ListDomainsResponseBodyDomains {
	s.State = &v
	return s
}

type ListDomainsResponseBodyDomainsAccelerators struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The name of the GA instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// 托管实例所属的服务方ID。
	//
	// > 仅在**ServiceManaged**参数为**True**时有效。
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// 是否为托管实例。取值：
	//
	// - **true**：是托管资实例。
	//
	// - **false**：不是托管实例。
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// 用户在此托管实例下可执行的动作策略列表。
	// > 仅在**ServiceManaged**参数为**True**时有效。
	// > - 当实例处于托管状态时，用户对实例的操作会受到限制，某些操作行为会被禁止。
	ServiceManagedInfos []*ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
}

func (s ListDomainsResponseBodyDomainsAccelerators) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponseBodyDomainsAccelerators) GoString() string {
	return s.String()
}

func (s *ListDomainsResponseBodyDomainsAccelerators) SetAcceleratorId(v string) *ListDomainsResponseBodyDomainsAccelerators {
	s.AcceleratorId = &v
	return s
}

func (s *ListDomainsResponseBodyDomainsAccelerators) SetName(v string) *ListDomainsResponseBodyDomainsAccelerators {
	s.Name = &v
	return s
}

func (s *ListDomainsResponseBodyDomainsAccelerators) SetServiceId(v string) *ListDomainsResponseBodyDomainsAccelerators {
	s.ServiceId = &v
	return s
}

func (s *ListDomainsResponseBodyDomainsAccelerators) SetServiceManaged(v bool) *ListDomainsResponseBodyDomainsAccelerators {
	s.ServiceManaged = &v
	return s
}

func (s *ListDomainsResponseBodyDomainsAccelerators) SetServiceManagedInfos(v []*ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos) *ListDomainsResponseBodyDomainsAccelerators {
	s.ServiceManagedInfos = v
	return s
}

type ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos struct {
	// 托管策略动作名称，取值：
	// - **Create**：创建实例。
	// - **Update**：更新当前实例。
	// - **Delete**：删除当前实例。
	// - **Associate**：引用/被引用当前实例。
	// - **UserUnmanaged**：用户解托管实例。
	// - **CreateChild**：在当前实例下创建子资源。
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// 子资源类型，取值：
	//
	// - **Listener**：监听资源。
	//
	// - **IpSet**：加速地域资源。
	//
	// - **EndpointGroup**：终端节点组资源。
	//
	// - **ForwardingRule**：转发策略资源。
	//
	// - **Endpoint**：终端节点资源。
	//
	// - **EndpointGroupDestination**：自定义路由监听下的终端节点组协议映射资源。
	//
	// - **EndpointPolicy**：自定义路由监听下的终端节点通行策略资源。
	//
	// > 仅在**Action**参数为**CreateChild**时有效。
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// 托管策略动作是否被托管，取值：
	// - **true**：托管策略动作被托管，用户无权在托管实例下执行Action指定的操作。
	// - **false**：托管策略动作未被托管，用户可在托管实例下执行Action指定的操作。
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos) SetAction(v string) *ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos) SetChildType(v string) *ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos) SetIsManaged(v bool) *ListDomainsResponseBodyDomainsAcceleratorsServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListDomainsResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponse) GoString() string {
	return s.String()
}

func (s *ListDomainsResponse) SetHeaders(v map[string]*string) *ListDomainsResponse {
	s.Headers = v
	return s
}

func (s *ListDomainsResponse) SetStatusCode(v int32) *ListDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDomainsResponse) SetBody(v *ListDomainsResponseBody) *ListDomainsResponse {
	s.Body = v
	return s
}

type ListEndpointGroupIpAddressCidrBlocksRequest struct {
	// The region ID of the endpoint group.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListEndpointGroupIpAddressCidrBlocksRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupIpAddressCidrBlocksRequest) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupIpAddressCidrBlocksRequest) SetEndpointGroupRegion(v string) *ListEndpointGroupIpAddressCidrBlocksRequest {
	s.EndpointGroupRegion = &v
	return s
}

func (s *ListEndpointGroupIpAddressCidrBlocksRequest) SetRegionId(v string) *ListEndpointGroupIpAddressCidrBlocksRequest {
	s.RegionId = &v
	return s
}

type ListEndpointGroupIpAddressCidrBlocksResponseBody struct {
	// The region ID of the endpoint group.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The CIDR blocks.
	IpAddressCidrBlocks []*string `json:"IpAddressCidrBlocks,omitempty" xml:"IpAddressCidrBlocks,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the endpoint group belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the endpoint group.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListEndpointGroupIpAddressCidrBlocksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupIpAddressCidrBlocksResponseBody) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponseBody) SetEndpointGroupRegion(v string) *ListEndpointGroupIpAddressCidrBlocksResponseBody {
	s.EndpointGroupRegion = &v
	return s
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponseBody) SetIpAddressCidrBlocks(v []*string) *ListEndpointGroupIpAddressCidrBlocksResponseBody {
	s.IpAddressCidrBlocks = v
	return s
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponseBody) SetRequestId(v string) *ListEndpointGroupIpAddressCidrBlocksResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponseBody) SetResourceGroupId(v string) *ListEndpointGroupIpAddressCidrBlocksResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponseBody) SetState(v string) *ListEndpointGroupIpAddressCidrBlocksResponseBody {
	s.State = &v
	return s
}

type ListEndpointGroupIpAddressCidrBlocksResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEndpointGroupIpAddressCidrBlocksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEndpointGroupIpAddressCidrBlocksResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupIpAddressCidrBlocksResponse) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponse) SetHeaders(v map[string]*string) *ListEndpointGroupIpAddressCidrBlocksResponse {
	s.Headers = v
	return s
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponse) SetStatusCode(v int32) *ListEndpointGroupIpAddressCidrBlocksResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEndpointGroupIpAddressCidrBlocksResponse) SetBody(v *ListEndpointGroupIpAddressCidrBlocksResponseBody) *ListEndpointGroupIpAddressCidrBlocksResponse {
	s.Body = v
	return s
}

type ListEndpointGroupsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// Specifies whether the access logging feature is enabled. Default value: off. Valid values:
	//
	// *   **on**: The access logging feature is enabled.
	// *   **off**: The access logging feature is disabled.
	AccessLogSwitch *string `json:"AccessLogSwitch,omitempty" xml:"AccessLogSwitch,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The type of the endpoint group. Valid values:
	//
	// *   **default**: a default endpoint group
	// *   **virtual**: a virtual endpoint group
	// *   If you leave this parameter empty, all default and virtual endpoint groups are queried.
	EndpointGroupType *string `json:"EndpointGroupType,omitempty" xml:"EndpointGroupType,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the endpoint group.
	Tag []*ListEndpointGroupsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListEndpointGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsRequest) SetAcceleratorId(v string) *ListEndpointGroupsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetAccessLogSwitch(v string) *ListEndpointGroupsRequest {
	s.AccessLogSwitch = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetEndpointGroupId(v string) *ListEndpointGroupsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetEndpointGroupType(v string) *ListEndpointGroupsRequest {
	s.EndpointGroupType = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetListenerId(v string) *ListEndpointGroupsRequest {
	s.ListenerId = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetPageNumber(v int32) *ListEndpointGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetPageSize(v int32) *ListEndpointGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetRegionId(v string) *ListEndpointGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *ListEndpointGroupsRequest) SetTag(v []*ListEndpointGroupsRequestTag) *ListEndpointGroupsRequest {
	s.Tag = v
	return s
}

type ListEndpointGroupsRequestTag struct {
	// The tag key of the Endpoint Group. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the Endpoint Group. The tag value can be an empty string.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListEndpointGroupsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsRequestTag) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsRequestTag) SetKey(v string) *ListEndpointGroupsRequestTag {
	s.Key = &v
	return s
}

func (s *ListEndpointGroupsRequestTag) SetValue(v string) *ListEndpointGroupsRequestTag {
	s.Value = &v
	return s
}

type ListEndpointGroupsResponseBody struct {
	// The configurations of the endpoint group.
	EndpointGroups []*ListEndpointGroupsResponseBodyEndpointGroups `json:"EndpointGroups,omitempty" xml:"EndpointGroups,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListEndpointGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsResponseBody) SetEndpointGroups(v []*ListEndpointGroupsResponseBodyEndpointGroups) *ListEndpointGroupsResponseBody {
	s.EndpointGroups = v
	return s
}

func (s *ListEndpointGroupsResponseBody) SetPageNumber(v int32) *ListEndpointGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListEndpointGroupsResponseBody) SetPageSize(v int32) *ListEndpointGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListEndpointGroupsResponseBody) SetRequestId(v string) *ListEndpointGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEndpointGroupsResponseBody) SetTotalCount(v int32) *ListEndpointGroupsResponseBody {
	s.TotalCount = &v
	return s
}

type ListEndpointGroupsResponseBodyEndpointGroups struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The description of the endpoint group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configurations of the endpoint.
	EndpointConfigurations []*ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The ID of an endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The list of endpoint group IP addresses.
	EndpointGroupIpList []*string `json:"EndpointGroupIpList,omitempty" xml:"EndpointGroupIpList,omitempty" type:"Repeated"`
	// The ID of the region where the endpoint group is deployed.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The type of the endpoint group. Valid values:
	//
	// *   **default**: a default endpoint group
	// *   **virtual**: a virtual endpoint group
	EndpointGroupType *string `json:"EndpointGroupType,omitempty" xml:"EndpointGroupType,omitempty"`
	// The endpoint group IP addresses to be confirmed after the GA instance is upgraded.
	EndpointGroupUnconfirmedIpList []*string `json:"EndpointGroupUnconfirmedIpList,omitempty" xml:"EndpointGroupUnconfirmedIpList,omitempty" type:"Repeated"`
	// The protocol that is used by the backend service. Valid values:
	//
	// *   **HTTP**: HTTP
	// *   **HTTPS**: HTTPS
	EndpointRequestProtocol *string `json:"EndpointRequestProtocol,omitempty" xml:"EndpointRequestProtocol,omitempty"`
	// The ID of the forwarding rule that is associated with the endpoint group.
	ForwardingRuleIds []*string `json:"ForwardingRuleIds,omitempty" xml:"ForwardingRuleIds,omitempty" type:"Repeated"`
	// Indicates whether the health check feature is enabled. Valid values:
	//
	// *   **true**: The health check feature is enabled.
	// *   **false**: The health check feature is disabled.
	HealthCheckEnabled *bool `json:"HealthCheckEnabled,omitempty" xml:"HealthCheckEnabled,omitempty"`
	// The interval at which health checks are performed. Unit: seconds.
	HealthCheckIntervalSeconds *int32 `json:"HealthCheckIntervalSeconds,omitempty" xml:"HealthCheckIntervalSeconds,omitempty"`
	// The path to which health check requests are sent.
	HealthCheckPath *string `json:"HealthCheckPath,omitempty" xml:"HealthCheckPath,omitempty"`
	// The port that is used for health checks.
	HealthCheckPort *int32 `json:"HealthCheckPort,omitempty" xml:"HealthCheckPort,omitempty"`
	// The protocol over which health check requests are sent. Valid values:
	//
	// *   **tcp**: TCP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	HealthCheckProtocol *string `json:"HealthCheckProtocol,omitempty" xml:"HealthCheckProtocol,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the endpoint group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The mappings between ports.
	PortOverrides []*ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides `json:"PortOverrides,omitempty" xml:"PortOverrides,omitempty" type:"Repeated"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The state of the endpoint group. Valid values:
	//
	// *   **init**: The endpoint group is being initialized.
	// *   **active**: The endpoint group is running normally.
	// *   **updating**:The endpoint group is being updated.
	// *   **deleteing**: The endpoint group is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The tags of the endpoint groups.
	Tags []*ListEndpointGroupsResponseBodyEndpointGroupsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The number of consecutive failed health checks that must occur before an endpoint is considered unhealthy.
	ThresholdCount *int32 `json:"ThresholdCount,omitempty" xml:"ThresholdCount,omitempty"`
	// The weight of the endpoint group when the listener is associated with multiple endpoint groups.
	TrafficPercentage *int32 `json:"TrafficPercentage,omitempty" xml:"TrafficPercentage,omitempty"`
}

func (s ListEndpointGroupsResponseBodyEndpointGroups) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsResponseBodyEndpointGroups) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetAcceleratorId(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.AcceleratorId = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetDescription(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.Description = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetEndpointConfigurations(v []*ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointConfigurations = v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupId(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupId = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupIpList(v []*string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupIpList = v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupRegion(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupRegion = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupType(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupType = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetEndpointGroupUnconfirmedIpList(v []*string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointGroupUnconfirmedIpList = v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetEndpointRequestProtocol(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.EndpointRequestProtocol = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetForwardingRuleIds(v []*string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.ForwardingRuleIds = v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetHealthCheckEnabled(v bool) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.HealthCheckEnabled = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetHealthCheckIntervalSeconds(v int32) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.HealthCheckIntervalSeconds = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetHealthCheckPath(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.HealthCheckPath = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetHealthCheckPort(v int32) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.HealthCheckPort = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetHealthCheckProtocol(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.HealthCheckProtocol = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetListenerId(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.ListenerId = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetName(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.Name = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetPortOverrides(v []*ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.PortOverrides = v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetServiceId(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.ServiceId = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetServiceManaged(v bool) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.ServiceManaged = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetServiceManagedInfos(v []*ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.ServiceManagedInfos = v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetState(v string) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.State = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetTags(v []*ListEndpointGroupsResponseBodyEndpointGroupsTags) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.Tags = v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetThresholdCount(v int32) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.ThresholdCount = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroups) SetTrafficPercentage(v int32) *ListEndpointGroupsResponseBodyEndpointGroups {
	s.TrafficPercentage = &v
	return s
}

type ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations struct {
	// Indicates whether the client IP address preservation feature is enabled. Valid values:
	//
	// *   **true**: The client IP address preservation feature is enabled.
	// *   **false**: The client IP address preservation feature is disabled.
	EnableClientIPPreservation *bool `json:"EnableClientIPPreservation,omitempty" xml:"EnableClientIPPreservation,omitempty"`
	// The IP address or domain name of the endpoint.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The port that is used to monitor latency.
	ProbePort *int32 `json:"ProbePort,omitempty" xml:"ProbePort,omitempty"`
	// The protocol that is used to monitor latency. Valid values:
	//
	// *   **icmp**: ICMP
	// *   **tcp**: TCP
	ProbeProtocol *string `json:"ProbeProtocol,omitempty" xml:"ProbeProtocol,omitempty"`
	SubAddress    *string `json:"SubAddress,omitempty" xml:"SubAddress,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Domain**: a custom domain name
	// *   **Ip**: a custom IP address
	// *   **PublicIp**: a public IP address provided by Alibaba Cloud
	// *   **ECS**: an Elastic Compute Service (ECS) instance
	// *   **SLB**: a Server Load Balancer (SLB) instance
	// *   **ALB**: an Application Load Balancer (ALB) instance
	// *   **OSS**: an Object Storage Service (OSS) bucket
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the endpoint.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetEnableClientIPPreservation(v bool) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.EnableClientIPPreservation = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetEndpoint(v string) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetEndpointId(v string) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.EndpointId = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetProbePort(v int32) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.ProbePort = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetProbeProtocol(v string) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.ProbeProtocol = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetSubAddress(v string) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.SubAddress = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetType(v string) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.Type = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations) SetWeight(v int32) *ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations {
	s.Weight = &v
	return s
}

type ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides struct {
	// The endpoint port.
	EndpointPort *int32 `json:"EndpointPort,omitempty" xml:"EndpointPort,omitempty"`
	// The listener port.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides) SetEndpointPort(v int32) *ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides {
	s.EndpointPort = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides) SetListenerPort(v int32) *ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides {
	s.ListenerPort = &v
	return s
}

type ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) SetAction(v string) *ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) SetChildType(v string) *ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos) SetIsManaged(v bool) *ListEndpointGroupsResponseBodyEndpointGroupsServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListEndpointGroupsResponseBodyEndpointGroupsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsTags) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsResponseBodyEndpointGroupsTags) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsTags) SetKey(v string) *ListEndpointGroupsResponseBodyEndpointGroupsTags {
	s.Key = &v
	return s
}

func (s *ListEndpointGroupsResponseBodyEndpointGroupsTags) SetValue(v string) *ListEndpointGroupsResponseBodyEndpointGroupsTags {
	s.Value = &v
	return s
}

type ListEndpointGroupsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEndpointGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEndpointGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEndpointGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListEndpointGroupsResponse) SetHeaders(v map[string]*string) *ListEndpointGroupsResponse {
	s.Headers = v
	return s
}

func (s *ListEndpointGroupsResponse) SetStatusCode(v int32) *ListEndpointGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEndpointGroupsResponse) SetBody(v *ListEndpointGroupsResponseBody) *ListEndpointGroupsResponse {
	s.Body = v
	return s
}

type ListForwardingRulesRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The ClientToken value contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the forwarding rule.
	ForwardingRuleId *string `json:"ForwardingRuleId,omitempty" xml:"ForwardingRuleId,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListForwardingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesRequest) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesRequest) SetAcceleratorId(v string) *ListForwardingRulesRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListForwardingRulesRequest) SetClientToken(v string) *ListForwardingRulesRequest {
	s.ClientToken = &v
	return s
}

func (s *ListForwardingRulesRequest) SetForwardingRuleId(v string) *ListForwardingRulesRequest {
	s.ForwardingRuleId = &v
	return s
}

func (s *ListForwardingRulesRequest) SetListenerId(v string) *ListForwardingRulesRequest {
	s.ListenerId = &v
	return s
}

func (s *ListForwardingRulesRequest) SetMaxResults(v int32) *ListForwardingRulesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListForwardingRulesRequest) SetNextToken(v string) *ListForwardingRulesRequest {
	s.NextToken = &v
	return s
}

func (s *ListForwardingRulesRequest) SetRegionId(v string) *ListForwardingRulesRequest {
	s.RegionId = &v
	return s
}

type ListForwardingRulesResponseBody struct {
	// The information about the forwarding rules.
	ForwardingRules []*ListForwardingRulesResponseBodyForwardingRules `json:"ForwardingRules,omitempty" xml:"ForwardingRules,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If **NextToken** is returned, the value indicates the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListForwardingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBody) SetForwardingRules(v []*ListForwardingRulesResponseBodyForwardingRules) *ListForwardingRulesResponseBody {
	s.ForwardingRules = v
	return s
}

func (s *ListForwardingRulesResponseBody) SetMaxResults(v int32) *ListForwardingRulesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListForwardingRulesResponseBody) SetNextToken(v string) *ListForwardingRulesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListForwardingRulesResponseBody) SetRequestId(v string) *ListForwardingRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListForwardingRulesResponseBody) SetTotalCount(v int32) *ListForwardingRulesResponseBody {
	s.TotalCount = &v
	return s
}

type ListForwardingRulesResponseBodyForwardingRules struct {
	// The direction in which the forwarding rule takes effect.
	//
	// By default, **request** is returned, which indicates that the forwarding rule takes effect on requests.
	ForwardingRuleDirection *string `json:"ForwardingRuleDirection,omitempty" xml:"ForwardingRuleDirection,omitempty"`
	// The ID of the forwarding rule.
	ForwardingRuleId *string `json:"ForwardingRuleId,omitempty" xml:"ForwardingRuleId,omitempty"`
	// The name of the forwarding rule.
	ForwardingRuleName *string `json:"ForwardingRuleName,omitempty" xml:"ForwardingRuleName,omitempty"`
	// The status of the forwarding rule.
	//
	// *   **active**: The forwarding rule is normal.
	// *   **configuring**: The forwarding rule is being modified.
	// *   **deleting**: The forwarding rule is being deleted.
	ForwardingRuleStatus *string `json:"ForwardingRuleStatus,omitempty" xml:"ForwardingRuleStatus,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The priority of the forwarding rule.
	//
	// Valid values: **1** to **10000**. A lower value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The forwarding action.
	RuleActions []*ListForwardingRulesResponseBodyForwardingRulesRuleActions `json:"RuleActions,omitempty" xml:"RuleActions,omitempty" type:"Repeated"`
	// The forwarding conditions.
	RuleConditions []*ListForwardingRulesResponseBodyForwardingRulesRuleConditions `json:"RuleConditions,omitempty" xml:"RuleConditions,omitempty" type:"Repeated"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
}

func (s ListForwardingRulesResponseBodyForwardingRules) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRules) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetForwardingRuleDirection(v string) *ListForwardingRulesResponseBodyForwardingRules {
	s.ForwardingRuleDirection = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetForwardingRuleId(v string) *ListForwardingRulesResponseBodyForwardingRules {
	s.ForwardingRuleId = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetForwardingRuleName(v string) *ListForwardingRulesResponseBodyForwardingRules {
	s.ForwardingRuleName = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetForwardingRuleStatus(v string) *ListForwardingRulesResponseBodyForwardingRules {
	s.ForwardingRuleStatus = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetListenerId(v string) *ListForwardingRulesResponseBodyForwardingRules {
	s.ListenerId = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetPriority(v int32) *ListForwardingRulesResponseBodyForwardingRules {
	s.Priority = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetRuleActions(v []*ListForwardingRulesResponseBodyForwardingRulesRuleActions) *ListForwardingRulesResponseBodyForwardingRules {
	s.RuleActions = v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetRuleConditions(v []*ListForwardingRulesResponseBodyForwardingRulesRuleConditions) *ListForwardingRulesResponseBodyForwardingRules {
	s.RuleConditions = v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetServiceId(v string) *ListForwardingRulesResponseBodyForwardingRules {
	s.ServiceId = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetServiceManaged(v bool) *ListForwardingRulesResponseBodyForwardingRules {
	s.ServiceManaged = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRules) SetServiceManagedInfos(v []*ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos) *ListForwardingRulesResponseBodyForwardingRules {
	s.ServiceManagedInfos = v
	return s
}

type ListForwardingRulesResponseBodyForwardingRulesRuleActions struct {
	// The forwarding configurations.
	//
	// >  We recommend that you do not use this parameter. We recommend that you use the **RuleActionType** and **RuleActionValue** parameters to configure forwarding actions.
	ForwardGroupConfig *ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig `json:"ForwardGroupConfig,omitempty" xml:"ForwardGroupConfig,omitempty" type:"Struct"`
	// The forwarding priority.
	//
	// >  This parameter does not take effect. Ignore this parameter.
	Order *int32 `json:"Order,omitempty" xml:"Order,omitempty"`
	// The type of the forwarding action. Valid values:
	//
	// *   **ForwardGroup**: forwards a request.
	// *   **Redirect**: redirects a request.
	// *   **FixResponse**: returns a fixed response.
	// *   **Rewrite**: rewrites a request.
	// *   **AddHeader**: adds a header to a request.
	// *   **RemoveHeader**: deletes the header of a request.
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	// The value of the forwarding action type.
	//
	// You must specify different JSON strings based on the **RuleActionType** parameter.
	//
	// A forwarding rule can contain only one forwarding action whose type is **ForwardGroup**, **Redirect**, or **FixResponse**. You must specify a forwarding action whose type is **Rewrite**, **AddHeader**, or **RemoveHeader** before a forwarding action whose type is **ForwardGroup**.
	//
	// *   If **RuleActionType** is set to **ForwardGroup**, this parameter specifies the information of a virtual endpoint group. You can forward requests to only one virtual endpoint group. Example: `{"type":"endpointgroup", "value":"epg-bp1enpdcrqhl78g6r****"}`.
	//
	//     *   `type`: set this parameter to `endpointgroup`.
	//     *   `value`: set this parameter to the ID of a virtual endpoint group.
	//
	// *   If **RuleActionType** is set to **Redirect**, this parameter specifies redirecting configurations. You cannot leave all of the following parameters empty or configure all of these parameters to use the default values for a forwarding action whose type is **Redirect**: `protocol`, `domain`, `port`, `path`, and `query`. Example: `{"protocol":"HTTP", "domain":"www.example.com", "port":"80", "path":"/a","query":"value1", "code":"301" }`.
	//
	//     *   `protocol`: the protocol of requests after the requests are redirected. Valid values: `${protocol}` (default), `HTTP`, and `HTTPS`.
	//     *   `domain`: the domain name to which requests are redirected. Default value: `${host}`. You can also enter a domain name. The domain name must be 3 to 128 characters in length, and can contain only letters, digits, and the following special characters: `. - ? = ~ _ - + / ^ * ! $ &  ( ) [ ]`.
	//     *   `port`: the port to which requests are redirected. Default value: `${port}`. You can enter a port number that ranges from 1 to 63335.
	//     *   `path`: the path to which requests are redirected. Default value: `${path}`. The path must be 1 to 128 characters in length. To use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? ~ ^ * $ : ( ) [ ] + `. The path must start with a tilde (~). If you do not want to use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? :`. The path must start with a forward slash (/).
	//     *   `query`: the query string of the requests to be redirected. Default value: `${query}`. You can also specify a query string. The query string must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The query string cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > #  &`.
	//     *   `code`: the redirecting code. Valid values: `301`, `302`, `303`, `307`, and `308`.
	//
	// *   If **RuleActionType** is set to **FixResponse**, this parameter specifies a fixed response. Example: `{"code":"200", "type":"text/plain", "content":"dssacav" }`.
	//
	//     *   `code`: the HTTP status code to return. The response status code must be one of the following numeric strings: `2xx`, `4xx`, and `5xx`. The letter `x` indicates a number from 0 to 9.
	//     *   `type`: the type of the response content. Valid values: **text/plain**, **text/css**, **text/html**, **application/javascript**, and **application/json**.
	//     *   `content`: the response content. The response content cannot exceed 1,000 characters in length and does not support Chinese characters.
	//
	// *   If **RuleActionType** is set to **AddHeader**, this parameter specifies an HTTP header to be added. If a forwarding rule contains a forwarding action whose type is **AddHeader**, you must specify another forwarding action whose type is **ForwardGroup**. Example: `[{"name":"header1","type":"userdefined", "value":"value"}]`.
	//
	//     *   `name`: the name of the HTTP header. The name must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). The name of the HTTP header specified by **AddHeader** must be unique and cannot be the same as the name of the HTTP header specified by **RemoveHeader**.
	//     *   `type`: the content type of the HTTP header. Valid values: `user-defined`, `ref`, and `system-defined`.
	//     *   `value`: the content of the HTTP header. You cannot leave this parameter empty. If you set `type` to `user-defined`, the content must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The content can contain letters, digits, hyphens (-), and underscores (\_). The content cannot start or end with a space character. If you set `type` to `ref`, the content must be 1 to 128 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). The content cannot start or end with a space character. If you set `type` to `system-defined`, only `ClientSrcIp` is supported.
	//
	// *   If **RuleActionType** is set to **RemoveHeader**, this parameter specifies an HTTP header to be removed. If a forwarding rule contains a forwarding action whose type is **RemoveHeader**, you must specify another forwarding action whose type is **ForwardGroup**. The header must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). Example: `["header1"]`.
	//
	// *   If **RuleActionType** is set to **Rewrite**, this parameter specifies the rewriting configuration. If a forwarding rule contains a forwarding action whose type is **Rewrite**, you must specify another forwarding action whose type is **ForwardGroup**. Example: `{"domain":"value1", "path":"value2", "query":"value3"}`.
	//
	//     *   `domain`: the domain name to which requests are redirected. Default value: `${host}`. You can also enter a domain name. The domain name must be 3 to 128 characters in length, and can contain only lowercase letters, digits, and the following special characters: `. - ? = ~ _ - + / ^ * ! $ &  ( ) [ ]`.
	//     *   `path`: the path to which requests are redirected. Default value: `${path}`. The path must be 1 to 128 characters in length. To use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? ~ ^ * $ : ( ) [ ] + `. The path must start with a tilde (~). If you do not want to use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? :`. The path must start with a forward slash (/).
	//     *   `query`: the query string of the requests to be redirected. Default value: `${query}`. You can also specify a query string. The query string must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The query string cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > #  &`.
	RuleActionValue *string `json:"RuleActionValue,omitempty" xml:"RuleActionValue,omitempty"`
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleActions) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleActions) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleActions) SetForwardGroupConfig(v *ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig) *ListForwardingRulesResponseBodyForwardingRulesRuleActions {
	s.ForwardGroupConfig = v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleActions) SetOrder(v int32) *ListForwardingRulesResponseBodyForwardingRulesRuleActions {
	s.Order = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleActions) SetRuleActionType(v string) *ListForwardingRulesResponseBodyForwardingRulesRuleActions {
	s.RuleActionType = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleActions) SetRuleActionValue(v string) *ListForwardingRulesResponseBodyForwardingRulesRuleActions {
	s.RuleActionValue = &v
	return s
}

type ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig struct {
	// The information about the endpoint group.
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you call **RuleActionType** and **RuleActionValue** to query forwarding actions.
	ServerGroupTuples []*ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples `json:"ServerGroupTuples,omitempty" xml:"ServerGroupTuples,omitempty" type:"Repeated"`
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig) SetServerGroupTuples(v []*ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) *ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig {
	s.ServerGroupTuples = v
	return s
}

type ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples struct {
	// The ID of the endpoint group.
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you call **RuleActionType** and **RuleActionValue** to query forwarding actions.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) SetEndpointGroupId(v string) *ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples {
	s.EndpointGroupId = &v
	return s
}

type ListForwardingRulesResponseBodyForwardingRulesRuleConditions struct {
	// The configuration of the domain name.
	//
	// >  GA instances created after July 12, 2022 support all forwarding condition types and action types. We recommend that you query forwarding conditions by calling the **RuleConditionType** and **RuleConditionValue** operations.
	HostConfig *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig `json:"HostConfig,omitempty" xml:"HostConfig,omitempty" type:"Struct"`
	// The configuration of the path.
	//
	// >  GA instances created after July 12, 2022 support all forwarding condition types and action types. We recommend that you query forwarding conditions by calling the **RuleConditionType** and **RuleConditionValue** operations.
	PathConfig *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig `json:"PathConfig,omitempty" xml:"PathConfig,omitempty" type:"Struct"`
	// The type of the forwarding condition.
	//
	// *   **Host**: domain name
	// *   **Path**: path
	// *   **RequestHeader**: HTTP header
	// *   **Query**: query string
	// *   **Method**: HTTP method
	// *   **Cookie**: cookie
	// *   **SourceIP**: source IP address
	RuleConditionType *string `json:"RuleConditionType,omitempty" xml:"RuleConditionType,omitempty"`
	// The value of the forwarding condition type.
	//
	// Different JSON strings are returned based on the **RuleConditionType** parameter.
	//
	// *   If **RuleConditionType** is set to **Host**, a domain name condition is returned. If multiple domain names are returned in a forwarding condition, the relationship between the domain names is OR.
	// *   If **RuleConditionType** is set to **Path**, a path condition is returned. If multiple forwarding conditions whose types are path are returned in a forwarding rule, the relationship between the forwarding conditions is OR. If multiple paths are returned in a forwarding condition, the relationship between the paths is OR.
	// *   If **RuleConditionType** is set to **RequestHeader**, an HTTP header condition that consists of key-value pairs is returned.
	// *   If **RuleConditionType** is set to **Query**, a query string condition that consists of key-value pairs is returned.
	// *   If **RuleConditionType** is set to **Method**, an HTTP method condition is returned.
	// *   If **RuleConditionType** is set to **Cookie**, a cookie condition that consists of key-value pairs is returned.
	// *   If **RuleConditionType** is set to **SourceIP**, a source IP address condition is returned. If multiple source IP addresses are returned in a forwarding condition, the relationship between the source IP addresses is OR.
	RuleConditionValue *string `json:"RuleConditionValue,omitempty" xml:"RuleConditionValue,omitempty"`
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleConditions) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleConditions) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleConditions) SetHostConfig(v *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig) *ListForwardingRulesResponseBodyForwardingRulesRuleConditions {
	s.HostConfig = v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleConditions) SetPathConfig(v *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig) *ListForwardingRulesResponseBodyForwardingRulesRuleConditions {
	s.PathConfig = v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleConditions) SetRuleConditionType(v string) *ListForwardingRulesResponseBodyForwardingRulesRuleConditions {
	s.RuleConditionType = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleConditions) SetRuleConditionValue(v string) *ListForwardingRulesResponseBodyForwardingRulesRuleConditions {
	s.RuleConditionValue = &v
	return s
}

type ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig struct {
	// The domain name.
	//
	// The domain name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), and periods (.). Supported wildcard characters are asterisks (\*) and question marks (?).
	//
	// >  GA instances created after July 12, 2022 support all forwarding condition types and action types. We recommend that you query forwarding conditions by calling the **RuleConditionType** and **RuleConditionValue** operations.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig) SetValues(v []*string) *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig {
	s.Values = v
	return s
}

type ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig struct {
	// The path.
	//
	// The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain only letters, digits, and the following special characters: $ - \_ . + / & ~ @ : \". Supported wildcard characters are asterisks (\*) and question marks (?).
	//
	// >  GA instances created after July 12, 2022 support all forwarding condition types and action types. We recommend that you query forwarding conditions by calling the **RuleConditionType** and **RuleConditionValue** operations.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig) SetValues(v []*string) *ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig {
	s.Values = v
	return s
}

type ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos) SetAction(v string) *ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos) SetChildType(v string) *ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos) SetIsManaged(v bool) *ListForwardingRulesResponseBodyForwardingRulesServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListForwardingRulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListForwardingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListForwardingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListForwardingRulesResponse) GoString() string {
	return s.String()
}

func (s *ListForwardingRulesResponse) SetHeaders(v map[string]*string) *ListForwardingRulesResponse {
	s.Headers = v
	return s
}

func (s *ListForwardingRulesResponse) SetStatusCode(v int32) *ListForwardingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListForwardingRulesResponse) SetBody(v *ListForwardingRulesResponseBody) *ListForwardingRulesResponse {
	s.Body = v
	return s
}

type ListIpSetsRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListIpSetsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIpSetsRequest) GoString() string {
	return s.String()
}

func (s *ListIpSetsRequest) SetAcceleratorId(v string) *ListIpSetsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListIpSetsRequest) SetPageNumber(v int32) *ListIpSetsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListIpSetsRequest) SetPageSize(v int32) *ListIpSetsRequest {
	s.PageSize = &v
	return s
}

func (s *ListIpSetsRequest) SetRegionId(v string) *ListIpSetsRequest {
	s.RegionId = &v
	return s
}

type ListIpSetsResponseBody struct {
	// Details of the acceleration regions.
	IpSets []*ListIpSetsResponseBodyIpSets `json:"IpSets,omitempty" xml:"IpSets,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListIpSetsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIpSetsResponseBody) GoString() string {
	return s.String()
}

func (s *ListIpSetsResponseBody) SetIpSets(v []*ListIpSetsResponseBodyIpSets) *ListIpSetsResponseBody {
	s.IpSets = v
	return s
}

func (s *ListIpSetsResponseBody) SetPageNumber(v int32) *ListIpSetsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListIpSetsResponseBody) SetPageSize(v int32) *ListIpSetsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListIpSetsResponseBody) SetRequestId(v string) *ListIpSetsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListIpSetsResponseBody) SetTotalCount(v int32) *ListIpSetsResponseBody {
	s.TotalCount = &v
	return s
}

type ListIpSetsResponseBodyIpSets struct {
	// The ID of the acceleration region.
	AccelerateRegionId *string `json:"AccelerateRegionId,omitempty" xml:"AccelerateRegionId,omitempty"`
	// The bandwidth that is allocated to the acceleration region. Unit: **Mbit/s**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The list of accelerated IP addresses in the acceleration region.
	IpAddressList []*string `json:"IpAddressList,omitempty" xml:"IpAddressList,omitempty" type:"Repeated"`
	// The ID of the acceleration region.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The version of the IP protocol. Valid values:
	//
	// *   **IPv4**
	// *   **IPv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The line type of the elastic IP address (EIP) in the acceleration region. Valid values:
	//
	// *   **BGP**: BGP (Multi-ISP) lines.
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines If the acceleration region is China (Hong Kong) and a basic bandwidth plan whose bandwidth type is Premium is associated with the GA instance, the default value of IspType is BGP_PRO.
	//
	// If you are allowed to use single-ISP bandwidth, you can also specify one of the following values:
	//
	// *   **ChinaTelecom**: China Telecom (single ISP)
	// *   **ChinaUnicom**: China Unicom (single ISP)
	// *   **ChinaMobile**: China Mobile (single ISP)
	// *   **ChinaTelecom_L2**: China Telecom \_L2 (single ISP)
	// *   **ChinaUnicom_L2**: China Unicom \_L2 (single ISP)
	// *   **ChinaMobile_L2**: China Mobile \_L2 (single ISP)
	//
	// > Different acceleration regions support different single-ISP BGP lines.
	IspType *string `json:"IspType,omitempty" xml:"IspType,omitempty"`
	// 托管实例所属的服务方ID。
	//
	// > 仅在**ServiceManaged**参数为**True**时有效。
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// 是否为托管实例。取值：
	//
	// - **true**：是托管资实例。
	//
	// - **false**：不是托管实例。
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// 用户在此托管实例下可执行的动作策略列表。
	//
	// > 仅在**ServiceManaged**参数为**True**时有效。
	// > - 当实例处于托管状态时，用户对实例的操作会受到限制，某些操作行为会被禁止。
	ServiceManagedInfos []*ListIpSetsResponseBodyIpSetsServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The status of the acceleration region. Valid values:
	//
	// *   **init**: The acceleration region is being initialized.
	// *   **active**: The acceleration region is running.
	// *   **updating**: The acceleration region is being configured.
	// *   **deleting**: The acceleration region is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListIpSetsResponseBodyIpSets) String() string {
	return tea.Prettify(s)
}

func (s ListIpSetsResponseBodyIpSets) GoString() string {
	return s.String()
}

func (s *ListIpSetsResponseBodyIpSets) SetAccelerateRegionId(v string) *ListIpSetsResponseBodyIpSets {
	s.AccelerateRegionId = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetBandwidth(v int32) *ListIpSetsResponseBodyIpSets {
	s.Bandwidth = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetIpAddressList(v []*string) *ListIpSetsResponseBodyIpSets {
	s.IpAddressList = v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetIpSetId(v string) *ListIpSetsResponseBodyIpSets {
	s.IpSetId = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetIpVersion(v string) *ListIpSetsResponseBodyIpSets {
	s.IpVersion = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetIspType(v string) *ListIpSetsResponseBodyIpSets {
	s.IspType = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetServiceId(v string) *ListIpSetsResponseBodyIpSets {
	s.ServiceId = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetServiceManaged(v bool) *ListIpSetsResponseBodyIpSets {
	s.ServiceManaged = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetServiceManagedInfos(v []*ListIpSetsResponseBodyIpSetsServiceManagedInfos) *ListIpSetsResponseBodyIpSets {
	s.ServiceManagedInfos = v
	return s
}

func (s *ListIpSetsResponseBodyIpSets) SetState(v string) *ListIpSetsResponseBodyIpSets {
	s.State = &v
	return s
}

type ListIpSetsResponseBodyIpSetsServiceManagedInfos struct {
	// 托管策略动作名称，取值：
	// - **Create**：创建实例。
	// - **Update**：更新当前实例。
	// - **Delete**：删除当前实例。
	// - **Associate**：引用/被引用当前实例。
	// - **UserUnmanaged**：用户解托管实例。
	// - **CreateChild**：在当前实例下创建子资源。
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// 子资源类型，取值：
	// - **Listener**：监听资源。
	// - **IpSet**：加速地域资源。
	// - **EndpointGroup**：终端节点组资源。
	// - **ForwardingRule**：转发策略资源。
	// - **Endpoint**：终端节点资源。
	// - **EndpointGroupDestination**：自定义路由监听下的终端节点组协议映射资源。
	// - **EndpointPolicy**：自定义路由监听下的终端节点通行策略资源。
	// > 仅在**Action**参数为**CreateChild**时有效
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// 托管策略动作是否被托管，取值：
	// - **true**：托管策略动作被托管，用户无权在托管实例下执行Action指定的操作。
	// - **false**：托管策略动作未被托管，用户可在托管实例下执行Action指定的操作。
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListIpSetsResponseBodyIpSetsServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListIpSetsResponseBodyIpSetsServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListIpSetsResponseBodyIpSetsServiceManagedInfos) SetAction(v string) *ListIpSetsResponseBodyIpSetsServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSetsServiceManagedInfos) SetChildType(v string) *ListIpSetsResponseBodyIpSetsServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListIpSetsResponseBodyIpSetsServiceManagedInfos) SetIsManaged(v bool) *ListIpSetsResponseBodyIpSetsServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListIpSetsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIpSetsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIpSetsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIpSetsResponse) GoString() string {
	return s.String()
}

func (s *ListIpSetsResponse) SetHeaders(v map[string]*string) *ListIpSetsResponse {
	s.Headers = v
	return s
}

func (s *ListIpSetsResponse) SetStatusCode(v int32) *ListIpSetsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIpSetsResponse) SetBody(v *ListIpSetsResponseBody) *ListIpSetsResponse {
	s.Body = v
	return s
}

type ListIspTypesRequest struct {
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The type of the Global Accelerator (GA) instance to be queried. Valid values:
	//
	// *   **basic**: basic GA instance
	// *   **standard**: standard GA instance
	AcceleratorType *string `json:"AcceleratorType,omitempty" xml:"AcceleratorType,omitempty"`
	// The ID of the acceleration region to be queried.
	BusinessRegionId *string `json:"BusinessRegionId,omitempty" xml:"BusinessRegionId,omitempty"`
}

func (s ListIspTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIspTypesRequest) GoString() string {
	return s.String()
}

func (s *ListIspTypesRequest) SetAcceleratorId(v string) *ListIspTypesRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListIspTypesRequest) SetAcceleratorType(v string) *ListIspTypesRequest {
	s.AcceleratorType = &v
	return s
}

func (s *ListIspTypesRequest) SetBusinessRegionId(v string) *ListIspTypesRequest {
	s.BusinessRegionId = &v
	return s
}

type ListIspTypesResponseBody struct {
	// The line types of EIPs in the acceleration region.
	//
	// *   **BGP** (default): BGP (Multi-ISP) lines
	// *   **BGP_PRO**: BGP (Multi-ISP) Pro lines
	//
	// If you have the permissions to use single-ISP bandwidth, one of the following values may be returned:
	//
	// *   **ChinaTelecom**: China Telecom (single ISP)
	// *   **ChinaUnicom**: China Unicom (single ISP)
	// *   **ChinaMobile**: China Mobile (single ISP)
	// *   **ChinaTelecom_L2**: China Telecom_L2 (single ISP)
	// *   **ChinaUnicom_L2**: China Unicom_L2 (single ISP)
	// *   **ChinaMobile_L2**: China Mobile_L2 (single ISP)
	//
	// > Different acceleration regions support different single-ISP BGP lines.
	IspTypeList []*string `json:"IspTypeList,omitempty" xml:"IspTypeList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListIspTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIspTypesResponseBody) GoString() string {
	return s.String()
}

func (s *ListIspTypesResponseBody) SetIspTypeList(v []*string) *ListIspTypesResponseBody {
	s.IspTypeList = v
	return s
}

func (s *ListIspTypesResponseBody) SetRequestId(v string) *ListIspTypesResponseBody {
	s.RequestId = &v
	return s
}

type ListIspTypesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIspTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIspTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIspTypesResponse) GoString() string {
	return s.String()
}

func (s *ListIspTypesResponse) SetHeaders(v map[string]*string) *ListIspTypesResponse {
	s.Headers = v
	return s
}

func (s *ListIspTypesResponse) SetStatusCode(v int32) *ListIspTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIspTypesResponse) SetBody(v *ListIspTypesResponseBody) *ListIspTypesResponse {
	s.Body = v
	return s
}

type ListListenerCertificatesRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The number of entries to return.
	//
	// Valid values: **1** to **50**. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If this is your first and only query, ignore this parameter.
	// *   If a next query is to be performed, set the value to the NextToken value returned in the last call to the ListListenerCertificates operation.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the certificate. Valid values:
	//
	// *   **default**: a default certificate
	// *   **additional**: an additional certificate
	//
	// If you do not set this parameter, default and additional certificates are returned by default.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
}

func (s ListListenerCertificatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListListenerCertificatesRequest) GoString() string {
	return s.String()
}

func (s *ListListenerCertificatesRequest) SetAcceleratorId(v string) *ListListenerCertificatesRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListListenerCertificatesRequest) SetListenerId(v string) *ListListenerCertificatesRequest {
	s.ListenerId = &v
	return s
}

func (s *ListListenerCertificatesRequest) SetMaxResults(v int32) *ListListenerCertificatesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListListenerCertificatesRequest) SetNextToken(v string) *ListListenerCertificatesRequest {
	s.NextToken = &v
	return s
}

func (s *ListListenerCertificatesRequest) SetRegionId(v string) *ListListenerCertificatesRequest {
	s.RegionId = &v
	return s
}

func (s *ListListenerCertificatesRequest) SetRole(v string) *ListListenerCertificatesRequest {
	s.Role = &v
	return s
}

type ListListenerCertificatesResponseBody struct {
	// Details about the certificates.
	Certificates []*ListListenerCertificatesResponseBodyCertificates `json:"Certificates,omitempty" xml:"Certificates,omitempty" type:"Repeated"`
	// The maximum number of entries returned.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If **NextToken** is returned, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListListenerCertificatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListListenerCertificatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListListenerCertificatesResponseBody) SetCertificates(v []*ListListenerCertificatesResponseBodyCertificates) *ListListenerCertificatesResponseBody {
	s.Certificates = v
	return s
}

func (s *ListListenerCertificatesResponseBody) SetMaxResults(v int32) *ListListenerCertificatesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListListenerCertificatesResponseBody) SetNextToken(v string) *ListListenerCertificatesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListListenerCertificatesResponseBody) SetRequestId(v string) *ListListenerCertificatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListListenerCertificatesResponseBody) SetTotalCount(v int32) *ListListenerCertificatesResponseBody {
	s.TotalCount = &v
	return s
}

type ListListenerCertificatesResponseBodyCertificates struct {
	// The ID of the certificate.
	CertificateId *string `json:"CertificateId,omitempty" xml:"CertificateId,omitempty"`
	// The domain name associated with the additional certificate.
	//
	// This parameter is not returned if the certificate is a default one.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Indicates whether the certificate is a default one:
	//
	// *   **true**: a default certificate
	// *   **false**: an additional certificate
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The state of the certificate.
	//
	// *   **active**: The certificate is associated with a listener and takes effect.
	// *   **updating**: The additional certificate is being replaced.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListListenerCertificatesResponseBodyCertificates) String() string {
	return tea.Prettify(s)
}

func (s ListListenerCertificatesResponseBodyCertificates) GoString() string {
	return s.String()
}

func (s *ListListenerCertificatesResponseBodyCertificates) SetCertificateId(v string) *ListListenerCertificatesResponseBodyCertificates {
	s.CertificateId = &v
	return s
}

func (s *ListListenerCertificatesResponseBodyCertificates) SetDomain(v string) *ListListenerCertificatesResponseBodyCertificates {
	s.Domain = &v
	return s
}

func (s *ListListenerCertificatesResponseBodyCertificates) SetIsDefault(v bool) *ListListenerCertificatesResponseBodyCertificates {
	s.IsDefault = &v
	return s
}

func (s *ListListenerCertificatesResponseBodyCertificates) SetState(v string) *ListListenerCertificatesResponseBodyCertificates {
	s.State = &v
	return s
}

type ListListenerCertificatesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListListenerCertificatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListListenerCertificatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListListenerCertificatesResponse) GoString() string {
	return s.String()
}

func (s *ListListenerCertificatesResponse) SetHeaders(v map[string]*string) *ListListenerCertificatesResponse {
	s.Headers = v
	return s
}

func (s *ListListenerCertificatesResponse) SetStatusCode(v int32) *ListListenerCertificatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListListenerCertificatesResponse) SetBody(v *ListListenerCertificatesResponseBody) *ListListenerCertificatesResponse {
	s.Body = v
	return s
}

type ListListenersRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListListenersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListListenersRequest) GoString() string {
	return s.String()
}

func (s *ListListenersRequest) SetAcceleratorId(v string) *ListListenersRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListListenersRequest) SetPageNumber(v int32) *ListListenersRequest {
	s.PageNumber = &v
	return s
}

func (s *ListListenersRequest) SetPageSize(v int32) *ListListenersRequest {
	s.PageSize = &v
	return s
}

func (s *ListListenersRequest) SetRegionId(v string) *ListListenersRequest {
	s.RegionId = &v
	return s
}

type ListListenersResponseBody struct {
	// The information about the listeners.
	Listeners []*ListListenersResponseBodyListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListListenersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponseBody) GoString() string {
	return s.String()
}

func (s *ListListenersResponseBody) SetListeners(v []*ListListenersResponseBodyListeners) *ListListenersResponseBody {
	s.Listeners = v
	return s
}

func (s *ListListenersResponseBody) SetPageNumber(v int32) *ListListenersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListListenersResponseBody) SetPageSize(v int32) *ListListenersResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListListenersResponseBody) SetRequestId(v string) *ListListenersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListListenersResponseBody) SetTotalCount(v int32) *ListListenersResponseBody {
	s.TotalCount = &v
	return s
}

type ListListenersResponseBodyListeners struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// Details about the ports that can be used by the backend server.
	BackendPorts []*ListListenersResponseBodyListenersBackendPorts `json:"BackendPorts,omitempty" xml:"BackendPorts,omitempty" type:"Repeated"`
	// Details about the SSL certificates.
	Certificates []*ListListenersResponseBodyListenersCertificates `json:"Certificates,omitempty" xml:"Certificates,omitempty" type:"Repeated"`
	// Indicates whether client affinity is enabled for the listener.
	//
	// *   If **NONE** is returned, client affinity is disabled. In this case, requests from the same client may be forwarded to different endpoints.
	// *   If **SOURCE_IP** is returned, client affinity is enabled. In this case, when a client accesses stateful applications, requests from the same client are always forwarded to the same endpoint regardless of the source port or protocol.
	ClientAffinity *string `json:"ClientAffinity,omitempty" xml:"ClientAffinity,omitempty"`
	// The timestamp that indicates that the listener was created. Unit: milliseconds.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the listener.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the listener.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Details about the listener ports.
	PortRanges []*ListListenersResponseBodyListenersPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
	// The network transmission protocol that is used by the listener. Valid values:
	//
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// Indicates whether the client IP address preservation feature is enabled. Valid values:
	//
	// *   **true**: The client IP address preservation feature is enabled. After client IP addresses are reserved, you can view the source IP addresses of clients over the backend service.
	// *   **false**: The client IP address preservation feature is disabled.
	ProxyProtocol *bool `json:"ProxyProtocol,omitempty" xml:"ProxyProtocol,omitempty"`
	// The ID of the security policy.
	//
	// *   **tls_cipher_policy\_1\_0**
	//
	//     *   Supported Transport Layer Security (TLS) versions: TLS 1.0, TLS 1.1, and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_1**
	//
	//     *   Supported TLS versions: TLS 1.1 and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict_with\_1\_3**
	//
	//     *   Supported TLS versions: TLS 1.2 and TLS 1.3
	//     *   Supported cipher suites: TLS_AES\_128\_GCM_SHA256, TLS_AES\_256\_GCM_SHA384, TLS_CHACHA20\_POLY1305\_SHA256, TLS_AES\_128\_CCM_SHA256, TLS_AES\_128\_CCM\_8\_SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES128-SHA256, ECDHE-ECDSA-AES256-SHA384, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-ECDSA-AES128-SHA, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// >  This parameter is returned only for HTTPS listeners.
	SecurityPolicyId *string `json:"SecurityPolicyId,omitempty" xml:"SecurityPolicyId,omitempty"`
	// The service ID to which the managed instance belongs.
	//
	// >  Valid only when the ServiceManaged parameter is True.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// Is it a managed instance. Valid values:
	//
	// - true
	// - false
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
	// A list of action policies that users can execute on this managed instance.
	ServiceManagedInfos []*ListListenersResponseBodyListenersServiceManagedInfos `json:"ServiceManagedInfos,omitempty" xml:"ServiceManagedInfos,omitempty" type:"Repeated"`
	// The state of the listener. Valid values:
	//
	// *   **active**: The listener is normal.
	// *   **init**: The listener is being initialized.
	// *   **updating**: The listener is being configured.
	// *   **deleting**: The listener is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The routing type of the listener. Valid values:
	//
	// *   **Standard**: intelligent routing
	// *   **CustomRouting**: custom routing
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The configurations of the `XForward` headers.
	XForwardedForConfig *ListListenersResponseBodyListenersXForwardedForConfig `json:"XForwardedForConfig,omitempty" xml:"XForwardedForConfig,omitempty" type:"Struct"`
}

func (s ListListenersResponseBodyListeners) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponseBodyListeners) GoString() string {
	return s.String()
}

func (s *ListListenersResponseBodyListeners) SetAcceleratorId(v string) *ListListenersResponseBodyListeners {
	s.AcceleratorId = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetBackendPorts(v []*ListListenersResponseBodyListenersBackendPorts) *ListListenersResponseBodyListeners {
	s.BackendPorts = v
	return s
}

func (s *ListListenersResponseBodyListeners) SetCertificates(v []*ListListenersResponseBodyListenersCertificates) *ListListenersResponseBodyListeners {
	s.Certificates = v
	return s
}

func (s *ListListenersResponseBodyListeners) SetClientAffinity(v string) *ListListenersResponseBodyListeners {
	s.ClientAffinity = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetCreateTime(v int64) *ListListenersResponseBodyListeners {
	s.CreateTime = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetDescription(v string) *ListListenersResponseBodyListeners {
	s.Description = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetListenerId(v string) *ListListenersResponseBodyListeners {
	s.ListenerId = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetName(v string) *ListListenersResponseBodyListeners {
	s.Name = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetPortRanges(v []*ListListenersResponseBodyListenersPortRanges) *ListListenersResponseBodyListeners {
	s.PortRanges = v
	return s
}

func (s *ListListenersResponseBodyListeners) SetProtocol(v string) *ListListenersResponseBodyListeners {
	s.Protocol = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetProxyProtocol(v bool) *ListListenersResponseBodyListeners {
	s.ProxyProtocol = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetSecurityPolicyId(v string) *ListListenersResponseBodyListeners {
	s.SecurityPolicyId = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetServiceId(v string) *ListListenersResponseBodyListeners {
	s.ServiceId = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetServiceManaged(v bool) *ListListenersResponseBodyListeners {
	s.ServiceManaged = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetServiceManagedInfos(v []*ListListenersResponseBodyListenersServiceManagedInfos) *ListListenersResponseBodyListeners {
	s.ServiceManagedInfos = v
	return s
}

func (s *ListListenersResponseBodyListeners) SetState(v string) *ListListenersResponseBodyListeners {
	s.State = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetType(v string) *ListListenersResponseBodyListeners {
	s.Type = &v
	return s
}

func (s *ListListenersResponseBodyListeners) SetXForwardedForConfig(v *ListListenersResponseBodyListenersXForwardedForConfig) *ListListenersResponseBodyListeners {
	s.XForwardedForConfig = v
	return s
}

type ListListenersResponseBodyListenersBackendPorts struct {
	// The start port in the range of ports used by the backend server.
	FromPort *string `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The end port in the range of ports used by the backend server.
	ToPort *string `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s ListListenersResponseBodyListenersBackendPorts) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponseBodyListenersBackendPorts) GoString() string {
	return s.String()
}

func (s *ListListenersResponseBodyListenersBackendPorts) SetFromPort(v string) *ListListenersResponseBodyListenersBackendPorts {
	s.FromPort = &v
	return s
}

func (s *ListListenersResponseBodyListenersBackendPorts) SetToPort(v string) *ListListenersResponseBodyListenersBackendPorts {
	s.ToPort = &v
	return s
}

type ListListenersResponseBodyListenersCertificates struct {
	// The ID of the SSL certificate.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the certificate.
	//
	// Only **Server** can be returned, which indicates a server certificate.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListListenersResponseBodyListenersCertificates) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponseBodyListenersCertificates) GoString() string {
	return s.String()
}

func (s *ListListenersResponseBodyListenersCertificates) SetId(v string) *ListListenersResponseBodyListenersCertificates {
	s.Id = &v
	return s
}

func (s *ListListenersResponseBodyListenersCertificates) SetType(v string) *ListListenersResponseBodyListenersCertificates {
	s.Type = &v
	return s
}

type ListListenersResponseBodyListenersPortRanges struct {
	// The start port in the range of listener ports used to receive and forward requests to endpoints.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The start port in the range of listener ports used to receive and forward requests to endpoints.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s ListListenersResponseBodyListenersPortRanges) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponseBodyListenersPortRanges) GoString() string {
	return s.String()
}

func (s *ListListenersResponseBodyListenersPortRanges) SetFromPort(v int32) *ListListenersResponseBodyListenersPortRanges {
	s.FromPort = &v
	return s
}

func (s *ListListenersResponseBodyListenersPortRanges) SetToPort(v int32) *ListListenersResponseBodyListenersPortRanges {
	s.ToPort = &v
	return s
}

type ListListenersResponseBodyListenersServiceManagedInfos struct {
	// Managed policy action name, Valid values:
	// - Create
	// - Update
	// - Delete
	// - Associate
	// - UserUnmanaged
	// - CreateChild
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// Sub resource type, Valid values:
	//
	// - Listener
	// - IpSet
	// - EndpointGroup
	// - ForwardingRule
	// - Endpoint
	// - EndpointGroupDestination
	// - EndpointPolicy
	//
	// >Only valid when the Action parameter is CreateChild.
	ChildType *string `json:"ChildType,omitempty" xml:"ChildType,omitempty"`
	// Is the managed policy action managed, Valid values:
	//
	// - true: The managed policy action is managed, and users do not have permission to perform the operation specified in the Action on the managed instance.
	//
	// - false: The managed policy action is not managed, and users have permission to perform the operation specified in the Action on the managed instance.
	IsManaged *bool `json:"IsManaged,omitempty" xml:"IsManaged,omitempty"`
}

func (s ListListenersResponseBodyListenersServiceManagedInfos) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponseBodyListenersServiceManagedInfos) GoString() string {
	return s.String()
}

func (s *ListListenersResponseBodyListenersServiceManagedInfos) SetAction(v string) *ListListenersResponseBodyListenersServiceManagedInfos {
	s.Action = &v
	return s
}

func (s *ListListenersResponseBodyListenersServiceManagedInfos) SetChildType(v string) *ListListenersResponseBodyListenersServiceManagedInfos {
	s.ChildType = &v
	return s
}

func (s *ListListenersResponseBodyListenersServiceManagedInfos) SetIsManaged(v bool) *ListListenersResponseBodyListenersServiceManagedInfos {
	s.IsManaged = &v
	return s
}

type ListListenersResponseBodyListenersXForwardedForConfig struct {
	// Indicates whether the `GA-AP` header is used to retrieve the information about acceleration regions. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForGaApEnabled *bool `json:"XForwardedForGaApEnabled,omitempty" xml:"XForwardedForGaApEnabled,omitempty"`
	// Indicates whether the `GA-ID` header is used to retrieve the ID of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForGaIdEnabled *bool `json:"XForwardedForGaIdEnabled,omitempty" xml:"XForwardedForGaIdEnabled,omitempty"`
	// Indicates whether the `GA-X-Forward-Port` header is used to retrieve the listener ports of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForPortEnabled *bool `json:"XForwardedForPortEnabled,omitempty" xml:"XForwardedForPortEnabled,omitempty"`
	// Indicates whether the `GA-X-Forward-Proto` header is used to retrieve the listener protocol of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XForwardedForProtoEnabled *bool `json:"XForwardedForProtoEnabled,omitempty" xml:"XForwardedForProtoEnabled,omitempty"`
	// Indicates whether the `X-Real-IP` header is used to retrieve client IP addresses. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	//
	// >  This parameter is returned only for HTTP and HTTPS listeners.
	XRealIpEnabled *bool `json:"XRealIpEnabled,omitempty" xml:"XRealIpEnabled,omitempty"`
}

func (s ListListenersResponseBodyListenersXForwardedForConfig) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponseBodyListenersXForwardedForConfig) GoString() string {
	return s.String()
}

func (s *ListListenersResponseBodyListenersXForwardedForConfig) SetXForwardedForGaApEnabled(v bool) *ListListenersResponseBodyListenersXForwardedForConfig {
	s.XForwardedForGaApEnabled = &v
	return s
}

func (s *ListListenersResponseBodyListenersXForwardedForConfig) SetXForwardedForGaIdEnabled(v bool) *ListListenersResponseBodyListenersXForwardedForConfig {
	s.XForwardedForGaIdEnabled = &v
	return s
}

func (s *ListListenersResponseBodyListenersXForwardedForConfig) SetXForwardedForPortEnabled(v bool) *ListListenersResponseBodyListenersXForwardedForConfig {
	s.XForwardedForPortEnabled = &v
	return s
}

func (s *ListListenersResponseBodyListenersXForwardedForConfig) SetXForwardedForProtoEnabled(v bool) *ListListenersResponseBodyListenersXForwardedForConfig {
	s.XForwardedForProtoEnabled = &v
	return s
}

func (s *ListListenersResponseBodyListenersXForwardedForConfig) SetXRealIpEnabled(v bool) *ListListenersResponseBodyListenersXForwardedForConfig {
	s.XRealIpEnabled = &v
	return s
}

type ListListenersResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListListenersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListListenersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListListenersResponse) GoString() string {
	return s.String()
}

func (s *ListListenersResponse) SetHeaders(v map[string]*string) *ListListenersResponse {
	s.Headers = v
	return s
}

func (s *ListListenersResponse) SetStatusCode(v int32) *ListListenersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListListenersResponse) SetBody(v *ListListenersResponseBody) *ListListenersResponse {
	s.Body = v
	return s
}

type ListSpareIpsRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListSpareIpsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSpareIpsRequest) GoString() string {
	return s.String()
}

func (s *ListSpareIpsRequest) SetAcceleratorId(v string) *ListSpareIpsRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ListSpareIpsRequest) SetClientToken(v string) *ListSpareIpsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListSpareIpsRequest) SetDryRun(v bool) *ListSpareIpsRequest {
	s.DryRun = &v
	return s
}

func (s *ListSpareIpsRequest) SetRegionId(v string) *ListSpareIpsRequest {
	s.RegionId = &v
	return s
}

type ListSpareIpsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The secondary IP addresses that are associated with the CNAME.
	SpareIps []*ListSpareIpsResponseBodySpareIps `json:"SpareIps,omitempty" xml:"SpareIps,omitempty" type:"Repeated"`
}

func (s ListSpareIpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSpareIpsResponseBody) GoString() string {
	return s.String()
}

func (s *ListSpareIpsResponseBody) SetRequestId(v string) *ListSpareIpsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSpareIpsResponseBody) SetSpareIps(v []*ListSpareIpsResponseBodySpareIps) *ListSpareIpsResponseBody {
	s.SpareIps = v
	return s
}

type ListSpareIpsResponseBodySpareIps struct {
	// The secondary IP address that is associated with the CNAME. If the acceleration area becomes unavailable, GA redirects traffic to the secondary IP address.
	SpareIp *string `json:"SpareIp,omitempty" xml:"SpareIp,omitempty"`
	// The status of the secondary IP address. Valid values:
	//
	// *   **active:** The secondary IP address is available.
	// *   **inuse:** The secondary IP address is in use.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListSpareIpsResponseBodySpareIps) String() string {
	return tea.Prettify(s)
}

func (s ListSpareIpsResponseBodySpareIps) GoString() string {
	return s.String()
}

func (s *ListSpareIpsResponseBodySpareIps) SetSpareIp(v string) *ListSpareIpsResponseBodySpareIps {
	s.SpareIp = &v
	return s
}

func (s *ListSpareIpsResponseBodySpareIps) SetState(v string) *ListSpareIpsResponseBodySpareIps {
	s.State = &v
	return s
}

type ListSpareIpsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSpareIpsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSpareIpsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSpareIpsResponse) GoString() string {
	return s.String()
}

func (s *ListSpareIpsResponse) SetHeaders(v map[string]*string) *ListSpareIpsResponse {
	s.Headers = v
	return s
}

func (s *ListSpareIpsResponse) SetStatusCode(v int32) *ListSpareIpsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSpareIpsResponse) SetBody(v *ListSpareIpsResponseBody) *ListSpareIpsResponse {
	s.Body = v
	return s
}

type ListSystemSecurityPoliciesRequest struct {
	// The page number. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListSystemSecurityPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSystemSecurityPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListSystemSecurityPoliciesRequest) SetPageNumber(v int32) *ListSystemSecurityPoliciesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListSystemSecurityPoliciesRequest) SetPageSize(v int32) *ListSystemSecurityPoliciesRequest {
	s.PageSize = &v
	return s
}

func (s *ListSystemSecurityPoliciesRequest) SetRegionId(v string) *ListSystemSecurityPoliciesRequest {
	s.RegionId = &v
	return s
}

type ListSystemSecurityPoliciesResponseBody struct {
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of TLS security policies.
	SecurityPolicies []*ListSystemSecurityPoliciesResponseBodySecurityPolicies `json:"SecurityPolicies,omitempty" xml:"SecurityPolicies,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListSystemSecurityPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSystemSecurityPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListSystemSecurityPoliciesResponseBody) SetPageNumber(v int32) *ListSystemSecurityPoliciesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListSystemSecurityPoliciesResponseBody) SetPageSize(v int32) *ListSystemSecurityPoliciesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListSystemSecurityPoliciesResponseBody) SetRequestId(v string) *ListSystemSecurityPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSystemSecurityPoliciesResponseBody) SetSecurityPolicies(v []*ListSystemSecurityPoliciesResponseBodySecurityPolicies) *ListSystemSecurityPoliciesResponseBody {
	s.SecurityPolicies = v
	return s
}

func (s *ListSystemSecurityPoliciesResponseBody) SetTotalCount(v int32) *ListSystemSecurityPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

type ListSystemSecurityPoliciesResponseBodySecurityPolicies struct {
	// The supported cipher suites. The value of this parameter is determined by the value of **TLSVersions**.
	//
	// The specified cipher suites must be supported by at least one value of **TLSVersions**. For example, if you set TLSVersions to **TLSv1.3**, you must specify cipher suites that are supported by **TLSv1.3**.
	//
	// *   Valid values when TLSVersions is set to **TLSv1.0** or **TLSv1.1**:
	//
	//     *   ECDHE-ECDSA-AES128-SHA
	//     *   ECDHE-ECDSA-AES256-SHA
	//     *   ECDHE-RSA-AES128-SHA
	//     *   ECDHE-RSA-AES256-SHA
	//     *   AES128-SHA
	//     *   AES256-SHA
	//     *   DES-CBC3-SHA
	//
	// *   Valid values when TLSVersions is set to **TLSv1.2**:
	//
	// ECDHE-ECDSA-AES128-SHA ECDHE-ECDSA-AES256-SHA ECDHE-RSA-AES128-SHA ECDHE-RSA-AES256-SHA AES128-SHA AES256-SHA DES-CBC3-SHA ECDHE-ECDSA-AES128-GCM-SHA256 ECDHE-ECDSA-AES256-GCM-SHA384 ECDHE-ECDSA-AES128-SHA256 ECDHE-ECDSA-AES256-SHA384 ECDHE-RSA-AES128-GCM-SHA256 ECDHE-RSA-AES256-GCM-SHA384 ECDHE-RSA-AES128-SHA256 ECDHE-RSA-AES256-SHA384 AES128-GCM-SHA256 AES256-GCM-SHA384 AES128-SHA256 AES256-SHA256
	//
	// *   Valid values when TLSVersions is set to **TLSv1.3**:
	//
	// TLS_AES\_128\_GCM_SHA256 TLS_AES\_256\_GCM_SHA384 TLS_CHACHA20\_POLY1305\_SHA256 TLS_AES\_128\_CCM_SHA256 TLS_AES\_128\_CCM\_8\_SHA256
	Ciphers []*string `json:"Ciphers,omitempty" xml:"Ciphers,omitempty" type:"Repeated"`
	// The TLS security policy ID.
	SecurityPolicyId *string `json:"SecurityPolicyId,omitempty" xml:"SecurityPolicyId,omitempty"`
	// The supported TLS protocol versions. Valid values: **TLSv1.0**, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3**.
	TlsVersions []*string `json:"TlsVersions,omitempty" xml:"TlsVersions,omitempty" type:"Repeated"`
}

func (s ListSystemSecurityPoliciesResponseBodySecurityPolicies) String() string {
	return tea.Prettify(s)
}

func (s ListSystemSecurityPoliciesResponseBodySecurityPolicies) GoString() string {
	return s.String()
}

func (s *ListSystemSecurityPoliciesResponseBodySecurityPolicies) SetCiphers(v []*string) *ListSystemSecurityPoliciesResponseBodySecurityPolicies {
	s.Ciphers = v
	return s
}

func (s *ListSystemSecurityPoliciesResponseBodySecurityPolicies) SetSecurityPolicyId(v string) *ListSystemSecurityPoliciesResponseBodySecurityPolicies {
	s.SecurityPolicyId = &v
	return s
}

func (s *ListSystemSecurityPoliciesResponseBodySecurityPolicies) SetTlsVersions(v []*string) *ListSystemSecurityPoliciesResponseBodySecurityPolicies {
	s.TlsVersions = v
	return s
}

type ListSystemSecurityPoliciesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSystemSecurityPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSystemSecurityPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSystemSecurityPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListSystemSecurityPoliciesResponse) SetHeaders(v map[string]*string) *ListSystemSecurityPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListSystemSecurityPoliciesResponse) SetStatusCode(v int32) *ListSystemSecurityPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSystemSecurityPoliciesResponse) SetBody(v *ListSystemSecurityPoliciesResponseBody) *ListSystemSecurityPoliciesResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that the value is unique among all requests. The ClientToken value contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// An array of IDs of resources whose tag information you want to query.
	//
	// *   If you set the **ResourceType** parameter to **accelerator**, set the value of ResourceId to the ID of a standard GA instance.
	// *   If you set the **ResourceType** parameter to **basicaccelerator**, set the value of ResourceId to the ID of a basic GA instance.
	// *   If you set the **ResourceType** parameter to **bandwidthpackage**, set the value of ResourceId to the ID of a bandwidth plan.
	// *   If you set the **ResourceType** parameter to **acl**, set the value of ResourceId to the ID of an ACL.
	// *   If **ResourceType** is set to **endpointgroup**, set the value of ResourceId to the ID of an EndpointGroup.
	//
	// You can specify up to 50 GA resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource whose tag information you want to query. Valid values:
	//
	// *   **accelerator:** a standard GA instance.
	// *   **basicaccelerator:** a basic GA instance.
	// *   **bandwidthpackage:** a bandwidth plan.
	// *   **acl:** an access control list (ACL).
	// *   **endpointgroup:** an endpoint group (EndpointGroup).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// An array of tags of GA resources.
	//
	// You can specify up to 20 tags.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetClientToken(v string) *ListTagResourcesRequest {
	s.ClientToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The tag key of the GA resource. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the GA resource. The tag value can be an empty string.
	//
	// The tag value can be up to 128 characters in length and and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** is empty, it indicates that no subsequent query is to be sent.
	// *   If a value is returned for **NextToken**, the value is the token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array of information about the resources to which tags are added.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
	// The number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

func (s *ListTagResourcesResponseBody) SetTotalCount(v int32) *ListTagResourcesResponseBody {
	s.TotalCount = &v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// *   **accelerator:** a standard GA instance.
	// *   **basicaccelerator:** a basic GA instance.
	// *   **bandwidthpackage:** a bandwidth plan.
	// *   **acl:** an ACL.
	// *   **endpointgroup:** an EndpointGroup.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type OpenAcceleratorServiceRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s OpenAcceleratorServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenAcceleratorServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenAcceleratorServiceRequest) SetClientToken(v string) *OpenAcceleratorServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *OpenAcceleratorServiceRequest) SetRegionId(v string) *OpenAcceleratorServiceRequest {
	s.RegionId = &v
	return s
}

type OpenAcceleratorServiceResponseBody struct {
	// The response code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the order.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true:** The call was successful.
	// *   **false:** The call failed.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s OpenAcceleratorServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenAcceleratorServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenAcceleratorServiceResponseBody) SetCode(v string) *OpenAcceleratorServiceResponseBody {
	s.Code = &v
	return s
}

func (s *OpenAcceleratorServiceResponseBody) SetMessage(v string) *OpenAcceleratorServiceResponseBody {
	s.Message = &v
	return s
}

func (s *OpenAcceleratorServiceResponseBody) SetOrderId(v int64) *OpenAcceleratorServiceResponseBody {
	s.OrderId = &v
	return s
}

func (s *OpenAcceleratorServiceResponseBody) SetRequestId(v string) *OpenAcceleratorServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *OpenAcceleratorServiceResponseBody) SetSuccess(v string) *OpenAcceleratorServiceResponseBody {
	s.Success = &v
	return s
}

type OpenAcceleratorServiceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenAcceleratorServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenAcceleratorServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenAcceleratorServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenAcceleratorServiceResponse) SetHeaders(v map[string]*string) *OpenAcceleratorServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenAcceleratorServiceResponse) SetStatusCode(v int32) *OpenAcceleratorServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenAcceleratorServiceResponse) SetBody(v *OpenAcceleratorServiceResponseBody) *OpenAcceleratorServiceResponse {
	s.Body = v
	return s
}

type QueryCrossBorderApprovalStatusRequest struct {
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s QueryCrossBorderApprovalStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryCrossBorderApprovalStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryCrossBorderApprovalStatusRequest) SetRegionId(v string) *QueryCrossBorderApprovalStatusRequest {
	s.RegionId = &v
	return s
}

type QueryCrossBorderApprovalStatusResponseBody struct {
	// Cross border permissions of Alibaba Cloud account (main account).
	//
	// -  UNAPPLIED : No cross-border permission application has been submitted or application records cannot be found.
	// -  APPLIED : Cross-border permission review in progress.
	// -  REJECTED : Cross-border permission review failed.
	// -  PASSED : Cross-border permission review passed.
	ApprovalStatus *string `json:"ApprovalStatus,omitempty" xml:"ApprovalStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryCrossBorderApprovalStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryCrossBorderApprovalStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryCrossBorderApprovalStatusResponseBody) SetApprovalStatus(v string) *QueryCrossBorderApprovalStatusResponseBody {
	s.ApprovalStatus = &v
	return s
}

func (s *QueryCrossBorderApprovalStatusResponseBody) SetRequestId(v string) *QueryCrossBorderApprovalStatusResponseBody {
	s.RequestId = &v
	return s
}

type QueryCrossBorderApprovalStatusResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryCrossBorderApprovalStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryCrossBorderApprovalStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryCrossBorderApprovalStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryCrossBorderApprovalStatusResponse) SetHeaders(v map[string]*string) *QueryCrossBorderApprovalStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryCrossBorderApprovalStatusResponse) SetStatusCode(v int32) *QueryCrossBorderApprovalStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryCrossBorderApprovalStatusResponse) SetBody(v *QueryCrossBorderApprovalStatusResponseBody) *QueryCrossBorderApprovalStatusResponse {
	s.Body = v
	return s
}

type RemoveEntriesFromAclRequest struct {
	// The IP addresses or CIDR blocks that you want to delete from the ACL. You can delete up to 20 entries in each request.
	AclEntries []*RemoveEntriesFromAclRequestAclEntries `json:"AclEntries,omitempty" xml:"AclEntries,omitempty" type:"Repeated"`
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**(default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RemoveEntriesFromAclRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntriesFromAclRequest) GoString() string {
	return s.String()
}

func (s *RemoveEntriesFromAclRequest) SetAclEntries(v []*RemoveEntriesFromAclRequestAclEntries) *RemoveEntriesFromAclRequest {
	s.AclEntries = v
	return s
}

func (s *RemoveEntriesFromAclRequest) SetAclId(v string) *RemoveEntriesFromAclRequest {
	s.AclId = &v
	return s
}

func (s *RemoveEntriesFromAclRequest) SetClientToken(v string) *RemoveEntriesFromAclRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveEntriesFromAclRequest) SetDryRun(v bool) *RemoveEntriesFromAclRequest {
	s.DryRun = &v
	return s
}

func (s *RemoveEntriesFromAclRequest) SetRegionId(v string) *RemoveEntriesFromAclRequest {
	s.RegionId = &v
	return s
}

type RemoveEntriesFromAclRequestAclEntries struct {
	// The IP address (192.168.XX.XX) or CIDR block (10.0.XX.XX/24) that you want to delete from the ACL. You can delete up to 20 entries in each request.
	//
	// > This parameter is required.
	Entry *string `json:"Entry,omitempty" xml:"Entry,omitempty"`
}

func (s RemoveEntriesFromAclRequestAclEntries) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntriesFromAclRequestAclEntries) GoString() string {
	return s.String()
}

func (s *RemoveEntriesFromAclRequestAclEntries) SetEntry(v string) *RemoveEntriesFromAclRequestAclEntries {
	s.Entry = &v
	return s
}

type RemoveEntriesFromAclResponseBody struct {
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveEntriesFromAclResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntriesFromAclResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveEntriesFromAclResponseBody) SetAclId(v string) *RemoveEntriesFromAclResponseBody {
	s.AclId = &v
	return s
}

func (s *RemoveEntriesFromAclResponseBody) SetRequestId(v string) *RemoveEntriesFromAclResponseBody {
	s.RequestId = &v
	return s
}

type RemoveEntriesFromAclResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveEntriesFromAclResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveEntriesFromAclResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntriesFromAclResponse) GoString() string {
	return s.String()
}

func (s *RemoveEntriesFromAclResponse) SetHeaders(v map[string]*string) *RemoveEntriesFromAclResponse {
	s.Headers = v
	return s
}

func (s *RemoveEntriesFromAclResponse) SetStatusCode(v int32) *RemoveEntriesFromAclResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveEntriesFromAclResponse) SetBody(v *RemoveEntriesFromAclResponseBody) *RemoveEntriesFromAclResponse {
	s.Body = v
	return s
}

type ReplaceBandwidthPackageRequest struct {
	// The GA instance ID.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the required bandwidth plan. When you specify a replacement bandwidth plan, take note of the following items:
	//
	// *   Only a bandwidth plan that is not associated with a GA instance can be specified.
	// *   If you want to replace a basic bandwidth plan, make sure that the bandwidth provided by the replacement bandwidth plan is not less than the total bandwidth allocated to the acceleration area.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the bandwidth plan that you want to replace.
	TargetBandwidthPackageId *string `json:"TargetBandwidthPackageId,omitempty" xml:"TargetBandwidthPackageId,omitempty"`
}

func (s ReplaceBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s ReplaceBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *ReplaceBandwidthPackageRequest) SetAcceleratorId(v string) *ReplaceBandwidthPackageRequest {
	s.AcceleratorId = &v
	return s
}

func (s *ReplaceBandwidthPackageRequest) SetBandwidthPackageId(v string) *ReplaceBandwidthPackageRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *ReplaceBandwidthPackageRequest) SetRegionId(v string) *ReplaceBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

func (s *ReplaceBandwidthPackageRequest) SetTargetBandwidthPackageId(v string) *ReplaceBandwidthPackageRequest {
	s.TargetBandwidthPackageId = &v
	return s
}

type ReplaceBandwidthPackageResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReplaceBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReplaceBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *ReplaceBandwidthPackageResponseBody) SetRequestId(v string) *ReplaceBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type ReplaceBandwidthPackageResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReplaceBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReplaceBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s ReplaceBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *ReplaceBandwidthPackageResponse) SetHeaders(v map[string]*string) *ReplaceBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *ReplaceBandwidthPackageResponse) SetStatusCode(v int32) *ReplaceBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *ReplaceBandwidthPackageResponse) SetBody(v *ReplaceBandwidthPackageResponseBody) *ReplaceBandwidthPackageResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the GA resource.
	//
	// *   If you set the **ResourceType** parameter to **accelerator**, set the value of ResourceId to the ID of a standard GA instance.
	// *   If you set the **ResourceType** parameter to **basicaccelerator**, set the value of ResourceId to the ID of a basic GA instance.
	// *   If you set the **ResourceType** parameter to **bandwidthpackage**, set the value of ResourceId to the ID of a bandwidth plan.
	// *   If you set the **ResourceType** parameter to **acl**, set the value of ResourceId to the ID of an ACL.
	// *   If you set the **ResourceType** parameter to **endpointgroup**, set the value of ResourceId to the ID of an EndpointGroup.
	//
	// You can specify 1 to 50 GA resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the GA resource. Valid values:
	//
	// *   **accelerator:** a standard GA instance.
	// *   **basicaccelerator:** a basic GA instance.
	// *   **bandwidthpackage:** a bandwidth plan.
	// *   **acl:** an access control list (ACL).
	// *   **endpointgroup:** an endpoint group (EndpointGroup).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of GA resources.
	//
	// You can specify up to 20 tags.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetClientToken(v string) *TagResourcesRequest {
	s.ClientToken = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The tag key of the GA resource. The tag key cannot be an empty string.
	//
	// The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the GA resource. The tag value can be an empty string.
	//
	// The tag value can be up to 128 characters in length and and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
	//
	// You can specify up to 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to remove all tags of the specified resource. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource whose tags you want to remove.
	//
	// *   If **ResourceType** is set to **accelerator**, set the value of ResourceId to the ID of a standard GA instance.
	// *   If **ResourceType** is set to **basicaccelerator**, set the value of ResourceId to the ID of a basic GA instance.
	// *   If **ResourceType** is set to **bandwidthpackage**, set the value of ResourceId to the ID of a bandwidth plan.
	// *   If **ResourceType** is set to **acl**, set the value of ResourceId to the ID of an ACL.
	// *   If **ResourceType** is set to **endpointgroup**, set the value of ResourceId to the ID of an EndpointGroup.
	//
	// You can enter up to 50 resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource whose tags you want to remove. Valid values:
	//
	// *   **accelerator**: a standard GA instance.
	// *   **basicaccelerator**: a basic GA instance.
	// *   **bandwidthpackage**: a bandwidth plan.
	// *   **acl**: an access control list (ACL).
	// *   **endpointgroup**: an endpoint group (EndpointGroup).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag to be removed.
	//
	// The system removes all tags with this tag key.
	//
	// You can specify up to 20 tag keys.
	//
	// >  If the **All** parameter is set to **true**, this parameter does not take effect.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetClientToken(v string) *UntagResourcesRequest {
	s.ClientToken = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAcceleratorRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **false** (default): disables automatic payment. If you select this option, you must go to the Order Center to complete the payment after an order is generated.
	// *   **true**: enables automatic payment. Payments are automatically completed.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to automatically pay bills by using coupons. Default value: false. Valid values:
	//
	// *   **true**: automatically pays bills by using coupons.
	// *   **false**: does not automatically pay bills by using coupons.
	//
	// >  This parameter takes effect only if the **AutoPay** parameter is set to **true**.
	AutoUseCoupon *bool `json:"AutoUseCoupon,omitempty" xml:"AutoUseCoupon,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the GA instance. The description can be up to 200 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the GA instance.
	//
	// The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The specification of the GA instance. Valid values:
	//
	// *   **1**: Small Ⅰ
	// *   **2**: Small Ⅱ
	// *   **3**: Small Ⅲ
	// *   **5**: Medium Ⅰ
	// *   **8**: Medium Ⅱ
	// *   **10**: Medium Ⅲ
	// *   **20**: Large Ⅰ
	// *   **30**: Large Ⅱ
	// *   **40**: Large Ⅲ
	// *   **50**: Large Ⅳ
	// *   **60**: Large Ⅴ
	// *   **70**: Large Ⅵ
	// *   **80**: Large VⅡ
	// *   **90**: Large VⅢ
	// *   **100**: Super Large Ⅰ
	// *   **200**: Super Large Ⅱ
	//
	// >  The Large Ⅲ specification and higher specifications are available only for accounts that are added to the whitelist. To use these specifications, contact your Alibaba Cloud account manager.
	//
	// Different specifications provide different capabilities. For more information, see [Instance specifications](~~153127~~).
	Spec *string `json:"Spec,omitempty" xml:"Spec,omitempty"`
}

func (s UpdateAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorRequest) SetAcceleratorId(v string) *UpdateAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateAcceleratorRequest) SetAutoPay(v bool) *UpdateAcceleratorRequest {
	s.AutoPay = &v
	return s
}

func (s *UpdateAcceleratorRequest) SetAutoUseCoupon(v bool) *UpdateAcceleratorRequest {
	s.AutoUseCoupon = &v
	return s
}

func (s *UpdateAcceleratorRequest) SetClientToken(v string) *UpdateAcceleratorRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAcceleratorRequest) SetDescription(v string) *UpdateAcceleratorRequest {
	s.Description = &v
	return s
}

func (s *UpdateAcceleratorRequest) SetName(v string) *UpdateAcceleratorRequest {
	s.Name = &v
	return s
}

func (s *UpdateAcceleratorRequest) SetRegionId(v string) *UpdateAcceleratorRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateAcceleratorRequest) SetSpec(v string) *UpdateAcceleratorRequest {
	s.Spec = &v
	return s
}

type UpdateAcceleratorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorResponseBody) SetRequestId(v string) *UpdateAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAcceleratorResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorResponse) SetHeaders(v map[string]*string) *UpdateAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *UpdateAcceleratorResponse) SetStatusCode(v int32) *UpdateAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAcceleratorResponse) SetBody(v *UpdateAcceleratorResponseBody) *UpdateAcceleratorResponse {
	s.Body = v
	return s
}

type UpdateAcceleratorAutoRenewAttributeRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// Specifies whether to enable auto-renewal for the GA instance. Default value: false. Valid values:
	//
	// *   **true**: enables auto-renewal for the GA instance.
	// *   **false**: does not enable auto-renewal for the GA instance.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal period. Unit: months.
	//
	// Valid values: **1** to **12**.
	//
	// >  This parameter is required only if **AutoRenew** is set to **true**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate a token, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the GA instance.
	//
	// The name must be 2 to 128 characters in length and can contain digits, underscores (\_), and hyphens (-). It must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies how to renew the GA instance. Valid values:
	//
	// *   **AutoRenewal**: The GA instance is automatically renewed.
	// *   **Normal**: You must manually renew the GA instance.
	// *   **NotRenewal**: Choose this option if you do not want to renew the GA instance after the instance expires. The system sends only a non-renewal reminder three days before the expiration date. The system no longer sends notifications to remind you to renew the GA instance. You can change the value of this parameter from NotRenewal to **Normal** for a GA instance, and then manually renew the instance. You can also set the RenewalStatus parameter to **AutoRenewal**.
	//
	// >  **RenewalStatus** takes precedence over **AutoRenew**. If you do not specify **RenewalStatus**, the **AutoRenew** parameter is used by default.
	RenewalStatus *string `json:"RenewalStatus,omitempty" xml:"RenewalStatus,omitempty"`
}

func (s UpdateAcceleratorAutoRenewAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorAutoRenewAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorAutoRenewAttributeRequest) SetAcceleratorId(v string) *UpdateAcceleratorAutoRenewAttributeRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeRequest) SetAutoRenew(v bool) *UpdateAcceleratorAutoRenewAttributeRequest {
	s.AutoRenew = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeRequest) SetAutoRenewDuration(v int32) *UpdateAcceleratorAutoRenewAttributeRequest {
	s.AutoRenewDuration = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeRequest) SetClientToken(v string) *UpdateAcceleratorAutoRenewAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeRequest) SetName(v string) *UpdateAcceleratorAutoRenewAttributeRequest {
	s.Name = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeRequest) SetRegionId(v string) *UpdateAcceleratorAutoRenewAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeRequest) SetRenewalStatus(v string) *UpdateAcceleratorAutoRenewAttributeRequest {
	s.RenewalStatus = &v
	return s
}

type UpdateAcceleratorAutoRenewAttributeResponseBody struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAcceleratorAutoRenewAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorAutoRenewAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorAutoRenewAttributeResponseBody) SetAcceleratorId(v string) *UpdateAcceleratorAutoRenewAttributeResponseBody {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeResponseBody) SetRequestId(v string) *UpdateAcceleratorAutoRenewAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAcceleratorAutoRenewAttributeResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAcceleratorAutoRenewAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAcceleratorAutoRenewAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorAutoRenewAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorAutoRenewAttributeResponse) SetHeaders(v map[string]*string) *UpdateAcceleratorAutoRenewAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeResponse) SetStatusCode(v int32) *UpdateAcceleratorAutoRenewAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAcceleratorAutoRenewAttributeResponse) SetBody(v *UpdateAcceleratorAutoRenewAttributeResponseBody) *UpdateAcceleratorAutoRenewAttributeResponse {
	s.Body = v
	return s
}

type UpdateAcceleratorConfirmRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateAcceleratorConfirmRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorConfirmRequest) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorConfirmRequest) SetAcceleratorId(v string) *UpdateAcceleratorConfirmRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateAcceleratorConfirmRequest) SetRegionId(v string) *UpdateAcceleratorConfirmRequest {
	s.RegionId = &v
	return s
}

type UpdateAcceleratorConfirmResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAcceleratorConfirmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorConfirmResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorConfirmResponseBody) SetRequestId(v string) *UpdateAcceleratorConfirmResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAcceleratorConfirmResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAcceleratorConfirmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAcceleratorConfirmResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorConfirmResponse) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorConfirmResponse) SetHeaders(v map[string]*string) *UpdateAcceleratorConfirmResponse {
	s.Headers = v
	return s
}

func (s *UpdateAcceleratorConfirmResponse) SetStatusCode(v int32) *UpdateAcceleratorConfirmResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAcceleratorConfirmResponse) SetBody(v *UpdateAcceleratorConfirmResponseBody) *UpdateAcceleratorConfirmResponse {
	s.Body = v
	return s
}

type UpdateAcceleratorCrossBorderModeRequest struct {
	// The GA instance ID.
	//
	// > The bandwidth metering method of the GA instance must be pay-by-data-transfer.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The type of transmission network of the GA instance. Valid values:
	//
	// *   **bgpPro**: BGP (Multi-ISP) Pro. BGP (Multi-ISP) Pro lines are used for cross-border acceleration. You do not need to perform real-name verification.
	// *   **private**: cross-border Express Connect circuit. Cross-border Express Connect circuits provide better acceleration performance but require real-name verification.
	CrossBorderMode *string `json:"CrossBorderMode,omitempty" xml:"CrossBorderMode,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateAcceleratorCrossBorderModeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorCrossBorderModeRequest) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorCrossBorderModeRequest) SetAcceleratorId(v string) *UpdateAcceleratorCrossBorderModeRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderModeRequest) SetClientToken(v string) *UpdateAcceleratorCrossBorderModeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderModeRequest) SetCrossBorderMode(v string) *UpdateAcceleratorCrossBorderModeRequest {
	s.CrossBorderMode = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderModeRequest) SetRegionId(v string) *UpdateAcceleratorCrossBorderModeRequest {
	s.RegionId = &v
	return s
}

type UpdateAcceleratorCrossBorderModeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAcceleratorCrossBorderModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorCrossBorderModeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorCrossBorderModeResponseBody) SetRequestId(v string) *UpdateAcceleratorCrossBorderModeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAcceleratorCrossBorderModeResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAcceleratorCrossBorderModeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAcceleratorCrossBorderModeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorCrossBorderModeResponse) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorCrossBorderModeResponse) SetHeaders(v map[string]*string) *UpdateAcceleratorCrossBorderModeResponse {
	s.Headers = v
	return s
}

func (s *UpdateAcceleratorCrossBorderModeResponse) SetStatusCode(v int32) *UpdateAcceleratorCrossBorderModeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderModeResponse) SetBody(v *UpdateAcceleratorCrossBorderModeResponseBody) *UpdateAcceleratorCrossBorderModeResponse {
	s.Body = v
	return s
}

type UpdateAcceleratorCrossBorderStatusRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable the cross-border acceleration feature for the GA instance. Valid values:
	//
	// - **true**
	// - **false**
	CrossBorderStatus *bool `json:"CrossBorderStatus,omitempty" xml:"CrossBorderStatus,omitempty"`
	// The region ID of the GA instance. Set the value to cn-hangzhou.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateAcceleratorCrossBorderStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorCrossBorderStatusRequest) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorCrossBorderStatusRequest) SetAcceleratorId(v string) *UpdateAcceleratorCrossBorderStatusRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderStatusRequest) SetClientToken(v string) *UpdateAcceleratorCrossBorderStatusRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderStatusRequest) SetCrossBorderStatus(v bool) *UpdateAcceleratorCrossBorderStatusRequest {
	s.CrossBorderStatus = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderStatusRequest) SetRegionId(v string) *UpdateAcceleratorCrossBorderStatusRequest {
	s.RegionId = &v
	return s
}

type UpdateAcceleratorCrossBorderStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAcceleratorCrossBorderStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorCrossBorderStatusResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorCrossBorderStatusResponseBody) SetRequestId(v string) *UpdateAcceleratorCrossBorderStatusResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAcceleratorCrossBorderStatusResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAcceleratorCrossBorderStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAcceleratorCrossBorderStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAcceleratorCrossBorderStatusResponse) GoString() string {
	return s.String()
}

func (s *UpdateAcceleratorCrossBorderStatusResponse) SetHeaders(v map[string]*string) *UpdateAcceleratorCrossBorderStatusResponse {
	s.Headers = v
	return s
}

func (s *UpdateAcceleratorCrossBorderStatusResponse) SetStatusCode(v int32) *UpdateAcceleratorCrossBorderStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAcceleratorCrossBorderStatusResponse) SetBody(v *UpdateAcceleratorCrossBorderStatusResponseBody) *UpdateAcceleratorCrossBorderStatusResponse {
	s.Body = v
	return s
}

type UpdateAclAttributeRequest struct {
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ACL name.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true:** performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**(default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateAclAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateAclAttributeRequest) SetAclId(v string) *UpdateAclAttributeRequest {
	s.AclId = &v
	return s
}

func (s *UpdateAclAttributeRequest) SetAclName(v string) *UpdateAclAttributeRequest {
	s.AclName = &v
	return s
}

func (s *UpdateAclAttributeRequest) SetClientToken(v string) *UpdateAclAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAclAttributeRequest) SetDryRun(v bool) *UpdateAclAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateAclAttributeRequest) SetRegionId(v string) *UpdateAclAttributeRequest {
	s.RegionId = &v
	return s
}

type UpdateAclAttributeResponseBody struct {
	// The ACL ID.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAclAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAclAttributeResponseBody) SetAclId(v string) *UpdateAclAttributeResponseBody {
	s.AclId = &v
	return s
}

func (s *UpdateAclAttributeResponseBody) SetRequestId(v string) *UpdateAclAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAclAttributeResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAclAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAclAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAclAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateAclAttributeResponse) SetHeaders(v map[string]*string) *UpdateAclAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateAclAttributeResponse) SetStatusCode(v int32) *UpdateAclAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAclAttributeResponse) SetBody(v *UpdateAclAttributeResponseBody) *UpdateAclAttributeResponse {
	s.Body = v
	return s
}

type UpdateAdditionalCertificateWithListenerRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The ID of the replacement certificate.
	CertificateId *string `json:"CertificateId,omitempty" xml:"CertificateId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The domain name associated with the additional certificate that you want to replace.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false:** performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed. This is the default value.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the listener. Only HTTPS listeners are supported.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateAdditionalCertificateWithListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdditionalCertificateWithListenerRequest) GoString() string {
	return s.String()
}

func (s *UpdateAdditionalCertificateWithListenerRequest) SetAcceleratorId(v string) *UpdateAdditionalCertificateWithListenerRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerRequest) SetCertificateId(v string) *UpdateAdditionalCertificateWithListenerRequest {
	s.CertificateId = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerRequest) SetClientToken(v string) *UpdateAdditionalCertificateWithListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerRequest) SetDomain(v string) *UpdateAdditionalCertificateWithListenerRequest {
	s.Domain = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerRequest) SetDryRun(v bool) *UpdateAdditionalCertificateWithListenerRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerRequest) SetListenerId(v string) *UpdateAdditionalCertificateWithListenerRequest {
	s.ListenerId = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerRequest) SetRegionId(v string) *UpdateAdditionalCertificateWithListenerRequest {
	s.RegionId = &v
	return s
}

type UpdateAdditionalCertificateWithListenerResponseBody struct {
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAdditionalCertificateWithListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdditionalCertificateWithListenerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAdditionalCertificateWithListenerResponseBody) SetListenerId(v string) *UpdateAdditionalCertificateWithListenerResponseBody {
	s.ListenerId = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerResponseBody) SetRequestId(v string) *UpdateAdditionalCertificateWithListenerResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAdditionalCertificateWithListenerResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAdditionalCertificateWithListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAdditionalCertificateWithListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAdditionalCertificateWithListenerResponse) GoString() string {
	return s.String()
}

func (s *UpdateAdditionalCertificateWithListenerResponse) SetHeaders(v map[string]*string) *UpdateAdditionalCertificateWithListenerResponse {
	s.Headers = v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerResponse) SetStatusCode(v int32) *UpdateAdditionalCertificateWithListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAdditionalCertificateWithListenerResponse) SetBody(v *UpdateAdditionalCertificateWithListenerResponseBody) *UpdateAdditionalCertificateWithListenerResponse {
	s.Body = v
	return s
}

type UpdateApplicationMonitorRequest struct {
	// The URL or IP address that you want to probe.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable the automatic diagnostics feature. Default value: false. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	DetectEnable *bool `json:"DetectEnable,omitempty" xml:"DetectEnable,omitempty"`
	// Set the threshold that is used to trigger the automatic diagnostics feature. If the liveness of the origin in percentile drops below the specified threshold, the automatic diagnostics feature is triggered.
	//
	// Valid values: **0** to **100**.
	DetectThreshold *int32 `json:"DetectThreshold,omitempty" xml:"DetectThreshold,omitempty"`
	// The number of times that are required to reach the threshold before the automatic diagnostics feature can be triggered.
	//
	// Valid values: **1** to **20**.
	DetectTimes *int32 `json:"DetectTimes,omitempty" xml:"DetectTimes,omitempty"`
	// The ID of the listener that you want to modify. The listener runs the origin probing task.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The extended options of the listener protocol that is used by the origin probing task. The options vary based on the listener protocol.
	OptionsJson *string `json:"OptionsJson,omitempty" xml:"OptionsJson,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The silence period of the automatic diagnostics feature. This parameter specifies the interval at which the automatic diagnostics feature is triggered. If the availability rate does not return to normal after GA triggers an automatic diagnostic, GA must wait until the silence period ends before GA can trigger another automatic diagnostic.
	//
	// If the number of consecutive times that the availability rate drops below the threshold of automatic diagnostics reaches the value of the **DetectTimes** parameter, the automatic diagnostics feature is triggered. The automatic diagnostics feature is not triggered again within the silence period even if the availability rate stays below the threshold. If the availability rate does not return to normal after the silence period ends, the automatic diagnostics feature is triggered again.
	//
	// Unit: seconds. Valid values: **300** to **86400**.
	SilenceTime *int32 `json:"SilenceTime,omitempty" xml:"SilenceTime,omitempty"`
	// The ID of the origin probing task that you want to modify.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The name of the origin probing task.
	//
	// The name must be 4 to 100 characters in length, and can contain digits, underscores (\_), and hyphens (-). It must start with a letter.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s UpdateApplicationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationMonitorRequest) GoString() string {
	return s.String()
}

func (s *UpdateApplicationMonitorRequest) SetAddress(v string) *UpdateApplicationMonitorRequest {
	s.Address = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetClientToken(v string) *UpdateApplicationMonitorRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetDetectEnable(v bool) *UpdateApplicationMonitorRequest {
	s.DetectEnable = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetDetectThreshold(v int32) *UpdateApplicationMonitorRequest {
	s.DetectThreshold = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetDetectTimes(v int32) *UpdateApplicationMonitorRequest {
	s.DetectTimes = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetListenerId(v string) *UpdateApplicationMonitorRequest {
	s.ListenerId = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetOptionsJson(v string) *UpdateApplicationMonitorRequest {
	s.OptionsJson = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetRegionId(v string) *UpdateApplicationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetSilenceTime(v int32) *UpdateApplicationMonitorRequest {
	s.SilenceTime = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetTaskId(v string) *UpdateApplicationMonitorRequest {
	s.TaskId = &v
	return s
}

func (s *UpdateApplicationMonitorRequest) SetTaskName(v string) *UpdateApplicationMonitorRequest {
	s.TaskName = &v
	return s
}

type UpdateApplicationMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateApplicationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateApplicationMonitorResponseBody) SetRequestId(v string) *UpdateApplicationMonitorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateApplicationMonitorResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateApplicationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateApplicationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationMonitorResponse) GoString() string {
	return s.String()
}

func (s *UpdateApplicationMonitorResponse) SetHeaders(v map[string]*string) *UpdateApplicationMonitorResponse {
	s.Headers = v
	return s
}

func (s *UpdateApplicationMonitorResponse) SetStatusCode(v int32) *UpdateApplicationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateApplicationMonitorResponse) SetBody(v *UpdateApplicationMonitorResponseBody) *UpdateApplicationMonitorResponse {
	s.Body = v
	return s
}

type UpdateBandwidthPackagaAutoRenewAttributeRequest struct {
	// Specifies whether to enable auto-renewal for the bandwidth plan. Valid values:
	//
	// *   **true**: enables auto-renewal.
	// *   **false** (default): disables auto-renewal.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal duration. Unit: months. Valid values: **1** to **12**.
	//
	// > : This parameter takes effect only if **AutoRenew** is set to **true**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the bandwidth plan.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The auto-renewal status of the bandwidth plan. Valid values:
	//
	// *   **AutoRenewal**: The bandwidth plan is automatically renewed.
	// *   **Normal**: You must manually renew the bandwidth plan.
	// *   **NotRenewal**: Choose this option if you do not want to renew the bandwidth plan after it expires. The system sends only a non-renewal reminder three days before the expiration date. The system no longer sends notifications to remind you to renew the bandwidth plan. You can change the value of this parameter from NotRenewal to Normal for a bandwidth plan, and then manually renew the bandwidth plan. You can also set the RenewalStatus parameter to **AutoRenewal**.
	//
	// > The **RenewalStatus** parameter takes precedence over the **AutoRenew** parameter. If you do not set **RenewalStatus**, the **AutoRenew** parameter is used by default.
	RenewalStatus *string `json:"RenewalStatus,omitempty" xml:"RenewalStatus,omitempty"`
}

func (s UpdateBandwidthPackagaAutoRenewAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBandwidthPackagaAutoRenewAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeRequest) SetAutoRenew(v bool) *UpdateBandwidthPackagaAutoRenewAttributeRequest {
	s.AutoRenew = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeRequest) SetAutoRenewDuration(v int32) *UpdateBandwidthPackagaAutoRenewAttributeRequest {
	s.AutoRenewDuration = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeRequest) SetClientToken(v string) *UpdateBandwidthPackagaAutoRenewAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeRequest) SetInstanceId(v string) *UpdateBandwidthPackagaAutoRenewAttributeRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeRequest) SetName(v string) *UpdateBandwidthPackagaAutoRenewAttributeRequest {
	s.Name = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeRequest) SetRegionId(v string) *UpdateBandwidthPackagaAutoRenewAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeRequest) SetRenewalStatus(v string) *UpdateBandwidthPackagaAutoRenewAttributeRequest {
	s.RenewalStatus = &v
	return s
}

type UpdateBandwidthPackagaAutoRenewAttributeResponseBody struct {
	// The ID of the bandwidth plan.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateBandwidthPackagaAutoRenewAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBandwidthPackagaAutoRenewAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeResponseBody) SetInstanceId(v string) *UpdateBandwidthPackagaAutoRenewAttributeResponseBody {
	s.InstanceId = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeResponseBody) SetRequestId(v string) *UpdateBandwidthPackagaAutoRenewAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateBandwidthPackagaAutoRenewAttributeResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBandwidthPackagaAutoRenewAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBandwidthPackagaAutoRenewAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBandwidthPackagaAutoRenewAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeResponse) SetHeaders(v map[string]*string) *UpdateBandwidthPackagaAutoRenewAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeResponse) SetStatusCode(v int32) *UpdateBandwidthPackagaAutoRenewAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBandwidthPackagaAutoRenewAttributeResponse) SetBody(v *UpdateBandwidthPackagaAutoRenewAttributeResponseBody) *UpdateBandwidthPackagaAutoRenewAttributeResponse {
	s.Body = v
	return s
}

type UpdateBandwidthPackageRequest struct {
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **false** (default): disables automatic payment. If you select this option, you must go to Order Center to complete the payment after an order is generated.
	// *   **true**: enables automatic payment. Payments are automatically completed.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to use coupons. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	AutoUseCoupon *bool `json:"AutoUseCoupon,omitempty" xml:"AutoUseCoupon,omitempty"`
	// The bandwidth value of the bandwidth plan. Unit: Mbit/s.
	//
	// Valid values: **2** to **2000**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the bandwidth plan that you want to modify.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The type of bandwidth. Valid values:
	//
	// *   **Basic**
	// *   **Enhanced**
	// *   **Advanced**
	//
	// >  You can upgrade **Basic** bandwidth to **Enhanced** bandwidth. You cannot change **Enhanced** or **Advanced** bandwidth to another type of bandwidth.
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The description of the bandwidth plan.
	//
	// The description can be up to 256 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the bandwidth plan. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *UpdateBandwidthPackageRequest) SetAutoPay(v bool) *UpdateBandwidthPackageRequest {
	s.AutoPay = &v
	return s
}

func (s *UpdateBandwidthPackageRequest) SetAutoUseCoupon(v bool) *UpdateBandwidthPackageRequest {
	s.AutoUseCoupon = &v
	return s
}

func (s *UpdateBandwidthPackageRequest) SetBandwidth(v int32) *UpdateBandwidthPackageRequest {
	s.Bandwidth = &v
	return s
}

func (s *UpdateBandwidthPackageRequest) SetBandwidthPackageId(v string) *UpdateBandwidthPackageRequest {
	s.BandwidthPackageId = &v
	return s
}

func (s *UpdateBandwidthPackageRequest) SetBandwidthType(v string) *UpdateBandwidthPackageRequest {
	s.BandwidthType = &v
	return s
}

func (s *UpdateBandwidthPackageRequest) SetDescription(v string) *UpdateBandwidthPackageRequest {
	s.Description = &v
	return s
}

func (s *UpdateBandwidthPackageRequest) SetName(v string) *UpdateBandwidthPackageRequest {
	s.Name = &v
	return s
}

func (s *UpdateBandwidthPackageRequest) SetRegionId(v string) *UpdateBandwidthPackageRequest {
	s.RegionId = &v
	return s
}

type UpdateBandwidthPackageResponseBody struct {
	// The bandwidth plan ID.
	BandwidthPackage *string `json:"BandwidthPackage,omitempty" xml:"BandwidthPackage,omitempty"`
	// The description of the bandwidth plan.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the bandwidth plan.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBandwidthPackageResponseBody) SetBandwidthPackage(v string) *UpdateBandwidthPackageResponseBody {
	s.BandwidthPackage = &v
	return s
}

func (s *UpdateBandwidthPackageResponseBody) SetDescription(v string) *UpdateBandwidthPackageResponseBody {
	s.Description = &v
	return s
}

func (s *UpdateBandwidthPackageResponseBody) SetName(v string) *UpdateBandwidthPackageResponseBody {
	s.Name = &v
	return s
}

func (s *UpdateBandwidthPackageResponseBody) SetRequestId(v string) *UpdateBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type UpdateBandwidthPackageResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *UpdateBandwidthPackageResponse) SetHeaders(v map[string]*string) *UpdateBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *UpdateBandwidthPackageResponse) SetStatusCode(v int32) *UpdateBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBandwidthPackageResponse) SetBody(v *UpdateBandwidthPackageResponseBody) *UpdateBandwidthPackageResponse {
	s.Body = v
	return s
}

type UpdateBasicAcceleratorRequest struct {
	// The ID of the basic GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the basic GA instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the basic GA instance.
	//
	// The name must be 2 to 128 characters in length and can contain digits, underscores (\_), and hyphens (-). It must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region to which the basic GA instance belongs. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateBasicAcceleratorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicAcceleratorRequest) GoString() string {
	return s.String()
}

func (s *UpdateBasicAcceleratorRequest) SetAcceleratorId(v string) *UpdateBasicAcceleratorRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateBasicAcceleratorRequest) SetClientToken(v string) *UpdateBasicAcceleratorRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateBasicAcceleratorRequest) SetDescription(v string) *UpdateBasicAcceleratorRequest {
	s.Description = &v
	return s
}

func (s *UpdateBasicAcceleratorRequest) SetName(v string) *UpdateBasicAcceleratorRequest {
	s.Name = &v
	return s
}

func (s *UpdateBasicAcceleratorRequest) SetRegionId(v string) *UpdateBasicAcceleratorRequest {
	s.RegionId = &v
	return s
}

type UpdateBasicAcceleratorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateBasicAcceleratorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicAcceleratorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBasicAcceleratorResponseBody) SetRequestId(v string) *UpdateBasicAcceleratorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateBasicAcceleratorResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBasicAcceleratorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBasicAcceleratorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicAcceleratorResponse) GoString() string {
	return s.String()
}

func (s *UpdateBasicAcceleratorResponse) SetHeaders(v map[string]*string) *UpdateBasicAcceleratorResponse {
	s.Headers = v
	return s
}

func (s *UpdateBasicAcceleratorResponse) SetStatusCode(v int32) *UpdateBasicAcceleratorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBasicAcceleratorResponse) SetBody(v *UpdateBasicAcceleratorResponseBody) *UpdateBasicAcceleratorResponse {
	s.Body = v
	return s
}

type UpdateBasicEndpointRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint group to which the endpoint that you want to modify belongs.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint that you want to modify.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the endpoint.
	//
	// The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateBasicEndpointRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicEndpointRequest) GoString() string {
	return s.String()
}

func (s *UpdateBasicEndpointRequest) SetClientToken(v string) *UpdateBasicEndpointRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateBasicEndpointRequest) SetEndpointGroupId(v string) *UpdateBasicEndpointRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateBasicEndpointRequest) SetEndpointId(v string) *UpdateBasicEndpointRequest {
	s.EndpointId = &v
	return s
}

func (s *UpdateBasicEndpointRequest) SetName(v string) *UpdateBasicEndpointRequest {
	s.Name = &v
	return s
}

func (s *UpdateBasicEndpointRequest) SetRegionId(v string) *UpdateBasicEndpointRequest {
	s.RegionId = &v
	return s
}

type UpdateBasicEndpointResponseBody struct {
	// The ID of the endpoint group to which the endpoints belong.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the endpoint.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The name of the endpoint.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateBasicEndpointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicEndpointResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBasicEndpointResponseBody) SetEndpointGroupId(v string) *UpdateBasicEndpointResponseBody {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateBasicEndpointResponseBody) SetEndpointId(v string) *UpdateBasicEndpointResponseBody {
	s.EndpointId = &v
	return s
}

func (s *UpdateBasicEndpointResponseBody) SetName(v string) *UpdateBasicEndpointResponseBody {
	s.Name = &v
	return s
}

func (s *UpdateBasicEndpointResponseBody) SetRequestId(v string) *UpdateBasicEndpointResponseBody {
	s.RequestId = &v
	return s
}

type UpdateBasicEndpointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBasicEndpointResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBasicEndpointResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicEndpointResponse) GoString() string {
	return s.String()
}

func (s *UpdateBasicEndpointResponse) SetHeaders(v map[string]*string) *UpdateBasicEndpointResponse {
	s.Headers = v
	return s
}

func (s *UpdateBasicEndpointResponse) SetStatusCode(v int32) *UpdateBasicEndpointResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBasicEndpointResponse) SetBody(v *UpdateBasicEndpointResponseBody) *UpdateBasicEndpointResponse {
	s.Body = v
	return s
}

type UpdateBasicEndpointGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the endpoint group that is associated with the basic GA instance.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The address of the endpoint.
	EndpointAddress *string `json:"EndpointAddress,omitempty" xml:"EndpointAddress,omitempty"`
	// The ID of the endpoint group that is associated with the basic GA instance.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The secondary address of the endpoint.
	//
	// This parameter is required when the accelerated IP address is associated with the secondary private IP address of an ECS instance or an ENI.
	//
	// *   If the endpoint type is **ECS**, you can set the **EndpointSubAddress** parameter to the secondary private IP address of the primary ENI. If the parameter is left empty, the primary private IP address of the primary ENI is used.
	// *   If the endpoint type is **ENI**, you can set the **EndpointSubAddress** parameter to the secondary private IP address of the secondary ENI. If the parameter is left empty, the primary private IP address of the secondary ENI is used.
	EndpointSubAddress *string `json:"EndpointSubAddress,omitempty" xml:"EndpointSubAddress,omitempty"`
	// The type of endpoint. Valid values:
	//
	// *   **ENI**: elastic network interface (ENI)
	// *   **SLB**: Server Load Balancer (SLB) instance
	EndpointType *string `json:"EndpointType,omitempty" xml:"EndpointType,omitempty"`
	// The name of the endpoint group that is associated with the basic GA instance.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the basic GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateBasicEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateBasicEndpointGroupRequest) SetClientToken(v string) *UpdateBasicEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateBasicEndpointGroupRequest) SetDescription(v string) *UpdateBasicEndpointGroupRequest {
	s.Description = &v
	return s
}

func (s *UpdateBasicEndpointGroupRequest) SetEndpointAddress(v string) *UpdateBasicEndpointGroupRequest {
	s.EndpointAddress = &v
	return s
}

func (s *UpdateBasicEndpointGroupRequest) SetEndpointGroupId(v string) *UpdateBasicEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateBasicEndpointGroupRequest) SetEndpointSubAddress(v string) *UpdateBasicEndpointGroupRequest {
	s.EndpointSubAddress = &v
	return s
}

func (s *UpdateBasicEndpointGroupRequest) SetEndpointType(v string) *UpdateBasicEndpointGroupRequest {
	s.EndpointType = &v
	return s
}

func (s *UpdateBasicEndpointGroupRequest) SetName(v string) *UpdateBasicEndpointGroupRequest {
	s.Name = &v
	return s
}

func (s *UpdateBasicEndpointGroupRequest) SetRegionId(v string) *UpdateBasicEndpointGroupRequest {
	s.RegionId = &v
	return s
}

type UpdateBasicEndpointGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateBasicEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBasicEndpointGroupResponseBody) SetRequestId(v string) *UpdateBasicEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type UpdateBasicEndpointGroupResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBasicEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBasicEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateBasicEndpointGroupResponse) SetHeaders(v map[string]*string) *UpdateBasicEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateBasicEndpointGroupResponse) SetStatusCode(v int32) *UpdateBasicEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBasicEndpointGroupResponse) SetBody(v *UpdateBasicEndpointGroupResponseBody) *UpdateBasicEndpointGroupResponse {
	s.Body = v
	return s
}

type UpdateBasicIpSetRequest struct {
	// The bandwidth of the acceleration region. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region of the basic GA instance.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the region to which the basic GA instance belongs. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateBasicIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicIpSetRequest) GoString() string {
	return s.String()
}

func (s *UpdateBasicIpSetRequest) SetBandwidth(v int32) *UpdateBasicIpSetRequest {
	s.Bandwidth = &v
	return s
}

func (s *UpdateBasicIpSetRequest) SetClientToken(v string) *UpdateBasicIpSetRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateBasicIpSetRequest) SetIpSetId(v string) *UpdateBasicIpSetRequest {
	s.IpSetId = &v
	return s
}

func (s *UpdateBasicIpSetRequest) SetRegionId(v string) *UpdateBasicIpSetRequest {
	s.RegionId = &v
	return s
}

type UpdateBasicIpSetResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateBasicIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBasicIpSetResponseBody) SetRequestId(v string) *UpdateBasicIpSetResponseBody {
	s.RequestId = &v
	return s
}

type UpdateBasicIpSetResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateBasicIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateBasicIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBasicIpSetResponse) GoString() string {
	return s.String()
}

func (s *UpdateBasicIpSetResponse) SetHeaders(v map[string]*string) *UpdateBasicIpSetResponse {
	s.Headers = v
	return s
}

func (s *UpdateBasicIpSetResponse) SetStatusCode(v int32) *UpdateBasicIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBasicIpSetResponse) SetBody(v *UpdateBasicIpSetResponseBody) *UpdateBasicIpSetResponse {
	s.Body = v
	return s
}

type UpdateCustomRoutingEndpointGroupAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the endpoint group.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The name of the endpoint group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateCustomRoutingEndpointGroupAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointGroupAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointGroupAttributeRequest) SetClientToken(v string) *UpdateCustomRoutingEndpointGroupAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupAttributeRequest) SetDescription(v string) *UpdateCustomRoutingEndpointGroupAttributeRequest {
	s.Description = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupAttributeRequest) SetEndpointGroupId(v string) *UpdateCustomRoutingEndpointGroupAttributeRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupAttributeRequest) SetName(v string) *UpdateCustomRoutingEndpointGroupAttributeRequest {
	s.Name = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupAttributeRequest) SetRegionId(v string) *UpdateCustomRoutingEndpointGroupAttributeRequest {
	s.RegionId = &v
	return s
}

type UpdateCustomRoutingEndpointGroupAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCustomRoutingEndpointGroupAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointGroupAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointGroupAttributeResponseBody) SetRequestId(v string) *UpdateCustomRoutingEndpointGroupAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCustomRoutingEndpointGroupAttributeResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCustomRoutingEndpointGroupAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCustomRoutingEndpointGroupAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointGroupAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointGroupAttributeResponse) SetHeaders(v map[string]*string) *UpdateCustomRoutingEndpointGroupAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupAttributeResponse) SetStatusCode(v int32) *UpdateCustomRoutingEndpointGroupAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupAttributeResponse) SetBody(v *UpdateCustomRoutingEndpointGroupAttributeResponseBody) *UpdateCustomRoutingEndpointGroupAttributeResponse {
	s.Body = v
	return s
}

type UpdateCustomRoutingEndpointGroupDestinationsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must ensure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The mapping configurations of endpoint group.
	//
	// You must specify the backend service port range and protocol of the endpoint group. The specified information is used to map the port range of the associated listener.
	//
	// You can specify at most 20 mapping configurations, which include port ranges and protocol types.
	DestinationConfigurations []*UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations `json:"DestinationConfigurations,omitempty" xml:"DestinationConfigurations,omitempty" type:"Repeated"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false**: performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateCustomRoutingEndpointGroupDestinationsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointGroupDestinationsRequest) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequest) SetClientToken(v string) *UpdateCustomRoutingEndpointGroupDestinationsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequest) SetDestinationConfigurations(v []*UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) *UpdateCustomRoutingEndpointGroupDestinationsRequest {
	s.DestinationConfigurations = v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequest) SetDryRun(v bool) *UpdateCustomRoutingEndpointGroupDestinationsRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequest) SetEndpointGroupId(v string) *UpdateCustomRoutingEndpointGroupDestinationsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequest) SetRegionId(v string) *UpdateCustomRoutingEndpointGroupDestinationsRequest {
	s.RegionId = &v
	return s
}

type UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations struct {
	// The ID of the mapping configuration of the endpoint group.
	DestinationId *string `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	// The start port of the backend service port range of the endpoint group.
	//
	// Valid values: **1** to **65499**. The **FromPort** value must be smaller than or equal to the **ToPort** value.
	//
	// You can specify up to 20 start ports in each request.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The backend service protocol of the endpoint group. Valid values:
	//
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **tcp,udp**: TCP and UDP
	//
	// You can specify up to four backend service protocols in each configuration.
	Protocols []*string `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The end port of the backend service port range of the endpoint group.
	//
	// Valid values: **1** to **65499**. The **FromPort** value must be smaller than or equal to the **ToPort** value.
	//
	// You can specify up to 20 end ports in each request.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) SetDestinationId(v string) *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations {
	s.DestinationId = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) SetFromPort(v int32) *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations {
	s.FromPort = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) SetProtocols(v []*string) *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations {
	s.Protocols = v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations) SetToPort(v int32) *UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations {
	s.ToPort = &v
	return s
}

type UpdateCustomRoutingEndpointGroupDestinationsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCustomRoutingEndpointGroupDestinationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointGroupDestinationsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsResponseBody) SetRequestId(v string) *UpdateCustomRoutingEndpointGroupDestinationsResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCustomRoutingEndpointGroupDestinationsResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCustomRoutingEndpointGroupDestinationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCustomRoutingEndpointGroupDestinationsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointGroupDestinationsResponse) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsResponse) SetHeaders(v map[string]*string) *UpdateCustomRoutingEndpointGroupDestinationsResponse {
	s.Headers = v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsResponse) SetStatusCode(v int32) *UpdateCustomRoutingEndpointGroupDestinationsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCustomRoutingEndpointGroupDestinationsResponse) SetBody(v *UpdateCustomRoutingEndpointGroupDestinationsResponseBody) *UpdateCustomRoutingEndpointGroupDestinationsResponse {
	s.Body = v
	return s
}

type UpdateCustomRoutingEndpointTrafficPoliciesRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the endpoint for which you want to modify the traffic policies.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The traffic policies.
	//
	// You can specify up to 500 destination IP addresses for each endpoint.
	PolicyConfigurations []*UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations `json:"PolicyConfigurations,omitempty" xml:"PolicyConfigurations,omitempty" type:"Repeated"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesRequest) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequest) SetClientToken(v string) *UpdateCustomRoutingEndpointTrafficPoliciesRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequest) SetEndpointId(v string) *UpdateCustomRoutingEndpointTrafficPoliciesRequest {
	s.EndpointId = &v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequest) SetPolicyConfigurations(v []*UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) *UpdateCustomRoutingEndpointTrafficPoliciesRequest {
	s.PolicyConfigurations = v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequest) SetRegionId(v string) *UpdateCustomRoutingEndpointTrafficPoliciesRequest {
	s.RegionId = &v
	return s
}

type UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations struct {
	// The IP address of the destination to which traffic is allowed.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**. You can call the [DescribeCustomRoutingEndpoint](~~449386~~) operation to query the traffic policy for the specified endpoint.
	//
	// You can specify up to 500 destination IP addresses for each endpoint.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The ID of the traffic policy to modify.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The port range of the destination to which traffic is allowed. The value of this parameter must fall within the port range of the backend service.
	//
	// If you do not specify array, traffic is forwarded to all ports.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**. You can call the [DescribeCustomRoutingEndpoint](~~449386~~) operation to query the traffic policy for the specified endpoint.
	//
	// You can specify port ranges for up to 500 traffic destinations in each endpoint and specify up to 10 port ranges for each traffic destination.
	PortRanges []*UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) SetAddress(v string) *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations {
	s.Address = &v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) SetPolicyId(v string) *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations {
	s.PolicyId = &v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations) SetPortRanges(v []*UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations {
	s.PortRanges = v
	return s
}

type UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges struct {
	// The first port of the destination port range. The specified port must fall within the port range of the specified endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**. You can call the [DescribeCustomRoutingEndpoint](~~449386~~) operation to query the access policy of traffic for the specified endpoint.
	//
	// If you do not specify FromPort and ToPort, traffic is forwarded to all ports of the destination.
	//
	// You can specify port ranges for up to 500 destinations for each endpoint and specify up to 10 start ports for each destination.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port of the destination port range. The specified port must fall within the port range of the specified endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**. You can call the [DescribeCustomRoutingEndpoint](~~449386~~) operation to query the traffic policy for the specified endpoint.
	//
	// If you do not specify FromPort and ToPort, traffic is forwarded to all ports of the destination.
	//
	// You can specify port ranges for up to 500 destinations in each endpoint and specify up to 10 last ports for each destination.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) SetFromPort(v int32) *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges {
	s.FromPort = &v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges) SetToPort(v int32) *UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges {
	s.ToPort = &v
	return s
}

type UpdateCustomRoutingEndpointTrafficPoliciesResponseBody struct {
	// The IDs of the traffic destinations.
	PolicyIds []*string `json:"PolicyIds,omitempty" xml:"PolicyIds,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesResponseBody) SetPolicyIds(v []*string) *UpdateCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.PolicyIds = v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesResponseBody) SetRequestId(v string) *UpdateCustomRoutingEndpointTrafficPoliciesResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCustomRoutingEndpointTrafficPoliciesResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCustomRoutingEndpointTrafficPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointTrafficPoliciesResponse) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesResponse) SetHeaders(v map[string]*string) *UpdateCustomRoutingEndpointTrafficPoliciesResponse {
	s.Headers = v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesResponse) SetStatusCode(v int32) *UpdateCustomRoutingEndpointTrafficPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCustomRoutingEndpointTrafficPoliciesResponse) SetBody(v *UpdateCustomRoutingEndpointTrafficPoliciesResponseBody) *UpdateCustomRoutingEndpointTrafficPoliciesResponse {
	s.Body = v
	return s
}

type UpdateCustomRoutingEndpointsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The configurations of the endpoint.
	EndpointConfigurations []*UpdateCustomRoutingEndpointsRequestEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The ID of the endpoint group to which the endpoints that you want to modify belong.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateCustomRoutingEndpointsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointsRequest) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointsRequest) SetClientToken(v string) *UpdateCustomRoutingEndpointsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCustomRoutingEndpointsRequest) SetEndpointConfigurations(v []*UpdateCustomRoutingEndpointsRequestEndpointConfigurations) *UpdateCustomRoutingEndpointsRequest {
	s.EndpointConfigurations = v
	return s
}

func (s *UpdateCustomRoutingEndpointsRequest) SetEndpointGroupId(v string) *UpdateCustomRoutingEndpointsRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateCustomRoutingEndpointsRequest) SetRegionId(v string) *UpdateCustomRoutingEndpointsRequest {
	s.RegionId = &v
	return s
}

type UpdateCustomRoutingEndpointsRequestEndpointConfigurations struct {
	// The ID of the endpoint.
	//
	// You can specify up to 20 endpoint IDs.
	EndpointId *string `json:"EndpointId,omitempty" xml:"EndpointId,omitempty"`
	// The configurations of the policy.
	PolicyConfigurations []*UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations `json:"PolicyConfigurations,omitempty" xml:"PolicyConfigurations,omitempty" type:"Repeated"`
	// The access policy of traffic for the specified endpoint. Default value: DenyAll. Valid values:
	//
	// *   **DenyAll**: denies all traffic to the endpoint.
	//
	// *   **AllowAll**: allows all traffic to the endpoint.
	//
	// *   **AllowCustom**: allows traffic only to specified destinations.
	//
	//     If you set this parameter to AllowCustom, you must specify IP addresses and port ranges of destinations to which to allow traffic. If you specify only IP addresses and do not specify port ranges, GA can forward traffic to all ports and the specified IP addresses in the destinations.
	//
	// You can specify up to 20 access policies of traffic for the specified endpoint.
	TrafficToEndpointPolicy *string `json:"TrafficToEndpointPolicy,omitempty" xml:"TrafficToEndpointPolicy,omitempty"`
}

func (s UpdateCustomRoutingEndpointsRequestEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointsRequestEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointsRequestEndpointConfigurations) SetEndpointId(v string) *UpdateCustomRoutingEndpointsRequestEndpointConfigurations {
	s.EndpointId = &v
	return s
}

func (s *UpdateCustomRoutingEndpointsRequestEndpointConfigurations) SetPolicyConfigurations(v []*UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) *UpdateCustomRoutingEndpointsRequestEndpointConfigurations {
	s.PolicyConfigurations = v
	return s
}

func (s *UpdateCustomRoutingEndpointsRequestEndpointConfigurations) SetTrafficToEndpointPolicy(v string) *UpdateCustomRoutingEndpointsRequestEndpointConfigurations {
	s.TrafficToEndpointPolicy = &v
	return s
}

type UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations struct {
	// The IP address of the destination to which to allow traffic.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify up to 20 destination IP addresses for each endpoint.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The port range of the destination to which traffic is forwarded. The value of this parameter must fall within the port range of the endpoint group.
	//
	// If you leave this parameter empty, traffic is forwarded to all destination ports.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations for each endpoint and specify up to 20 port ranges for each destination.
	PortRanges []*UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
}

func (s UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) SetAddress(v string) *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations {
	s.Address = &v
	return s
}

func (s *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations) SetPortRanges(v []*UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations {
	s.PortRanges = v
	return s
}

type UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges struct {
	// The start port of the port range in the destination to which to allow traffic. The specified port must fall within the port range of the specified endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations for each endpoint and specify up to 20 start ports for each destination.
	FromPort *string `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The end port of the port range in the destination to which to allow traffic. The specified port must fall within the port range of the specified endpoint group.
	//
	// This parameter takes effect only when **TrafficToEndpointPolicy** is set to **AllowCustom**.
	//
	// You can specify port ranges for up to 20 destinations for each endpoint and specify up to 20 end ports for each destination.
	ToPort *string `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) SetFromPort(v string) *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.FromPort = &v
	return s
}

func (s *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges) SetToPort(v string) *UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges {
	s.ToPort = &v
	return s
}

type UpdateCustomRoutingEndpointsResponseBody struct {
	// The IDs of the endpoints.
	EndpointIds []*string `json:"EndpointIds,omitempty" xml:"EndpointIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCustomRoutingEndpointsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointsResponseBody) SetEndpointIds(v []*string) *UpdateCustomRoutingEndpointsResponseBody {
	s.EndpointIds = v
	return s
}

func (s *UpdateCustomRoutingEndpointsResponseBody) SetRequestId(v string) *UpdateCustomRoutingEndpointsResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCustomRoutingEndpointsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCustomRoutingEndpointsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCustomRoutingEndpointsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomRoutingEndpointsResponse) GoString() string {
	return s.String()
}

func (s *UpdateCustomRoutingEndpointsResponse) SetHeaders(v map[string]*string) *UpdateCustomRoutingEndpointsResponse {
	s.Headers = v
	return s
}

func (s *UpdateCustomRoutingEndpointsResponse) SetStatusCode(v int32) *UpdateCustomRoutingEndpointsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCustomRoutingEndpointsResponse) SetBody(v *UpdateCustomRoutingEndpointsResponseBody) *UpdateCustomRoutingEndpointsResponse {
	s.Body = v
	return s
}

type UpdateDomainRequest struct {
	// The new accelerated domain name.
	//
	// Only primary domain names are supported, such as `example.net`.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The accelerated domain name to be modified.
	TargetDomain *string `json:"TargetDomain,omitempty" xml:"TargetDomain,omitempty"`
}

func (s UpdateDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateDomainRequest) SetDomain(v string) *UpdateDomainRequest {
	s.Domain = &v
	return s
}

func (s *UpdateDomainRequest) SetRegionId(v string) *UpdateDomainRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateDomainRequest) SetTargetDomain(v string) *UpdateDomainRequest {
	s.TargetDomain = &v
	return s
}

type UpdateDomainResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDomainResponseBody) SetRequestId(v string) *UpdateDomainResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDomainResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateDomainResponse) SetHeaders(v map[string]*string) *UpdateDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateDomainResponse) SetStatusCode(v int32) *UpdateDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDomainResponse) SetBody(v *UpdateDomainResponseBody) *UpdateDomainResponse {
	s.Body = v
	return s
}

type UpdateDomainStateRequest struct {
	// The accelerated domain name whose ICP filing status you want to update.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateDomainStateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainStateRequest) GoString() string {
	return s.String()
}

func (s *UpdateDomainStateRequest) SetDomain(v string) *UpdateDomainStateRequest {
	s.Domain = &v
	return s
}

func (s *UpdateDomainStateRequest) SetRegionId(v string) *UpdateDomainStateRequest {
	s.RegionId = &v
	return s
}

type UpdateDomainStateResponseBody struct {
	// The accelerated domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ICP filing status of the accelerated domain name. Valid values:
	//
	// *   **illegal:** The domain name is illegal.
	// *   **inactive:** The domain name has not completed ICP filing.
	// *   **active:** The domain name has a valid ICP number.
	// *   **unknown:** The ICP filing status is unknown.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s UpdateDomainStateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainStateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDomainStateResponseBody) SetDomain(v string) *UpdateDomainStateResponseBody {
	s.Domain = &v
	return s
}

func (s *UpdateDomainStateResponseBody) SetRequestId(v string) *UpdateDomainStateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDomainStateResponseBody) SetState(v string) *UpdateDomainStateResponseBody {
	s.State = &v
	return s
}

type UpdateDomainStateResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDomainStateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDomainStateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainStateResponse) GoString() string {
	return s.String()
}

func (s *UpdateDomainStateResponse) SetHeaders(v map[string]*string) *UpdateDomainStateResponse {
	s.Headers = v
	return s
}

func (s *UpdateDomainStateResponse) SetStatusCode(v int32) *UpdateDomainStateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDomainStateResponse) SetBody(v *UpdateDomainStateResponseBody) *UpdateDomainStateResponse {
	s.Body = v
	return s
}

type UpdateEndpointGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the endpoint group.
	//
	// The description cannot exceed 256 characters in length and cannot contain `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The information about the endpoints.
	//
	// You can specify information for up to 20 endpoints.
	EndpointConfigurations []*UpdateEndpointGroupRequestEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The ID of the region where the endpoint group is created.
	EndpointGroupRegion *string `json:"EndpointGroupRegion,omitempty" xml:"EndpointGroupRegion,omitempty"`
	// The protocol that is used by the backend service. Valid values:
	//
	// *   **HTTP**
	// *   **HTTPS**
	//
	// > *   You can set this parameter only when the listener that is associated with the endpoint group uses the HTTP or HTTPS protocol.
	// > *   For an HTTP listener, the backend service protocol must be HTTP.
	EndpointRequestProtocol *string `json:"EndpointRequestProtocol,omitempty" xml:"EndpointRequestProtocol,omitempty"`
	// Specifies whether to enable the health check feature. Default value: true. Valid values:
	//
	// *   **true**: enables the health check feature.
	// *   **false**: disables the health check feature.
	HealthCheckEnabled *bool `json:"HealthCheckEnabled,omitempty" xml:"HealthCheckEnabled,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds. Valid values: **1** to **50**.
	HealthCheckIntervalSeconds *int32 `json:"HealthCheckIntervalSeconds,omitempty" xml:"HealthCheckIntervalSeconds,omitempty"`
	// The path to which health check requests are sent.
	HealthCheckPath *string `json:"HealthCheckPath,omitempty" xml:"HealthCheckPath,omitempty"`
	// The port that is used for health checks. Valid values: **1** to **65535**.
	HealthCheckPort *int32 `json:"HealthCheckPort,omitempty" xml:"HealthCheckPort,omitempty"`
	// The protocol over which health check requests are sent. Valid values:
	//
	// *   **tcp**: TCP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	HealthCheckProtocol *string `json:"HealthCheckProtocol,omitempty" xml:"HealthCheckProtocol,omitempty"`
	// The name of the endpoint group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The mappings between ports.
	PortOverrides []*UpdateEndpointGroupRequestPortOverrides `json:"PortOverrides,omitempty" xml:"PortOverrides,omitempty" type:"Repeated"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of consecutive health check failures that must occur before a healthy endpoint group is considered unhealthy, or the number of consecutive health check successes that must occur before an unhealthy endpoint group is considered healthy.
	//
	// Valid values: **2** to **10**.
	ThresholdCount *int32 `json:"ThresholdCount,omitempty" xml:"ThresholdCount,omitempty"`
	// The weight of the endpoint group when the listener is associated with multiple endpoint groups.
	TrafficPercentage *int32 `json:"TrafficPercentage,omitempty" xml:"TrafficPercentage,omitempty"`
}

func (s UpdateEndpointGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupRequest) SetClientToken(v string) *UpdateEndpointGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetDescription(v string) *UpdateEndpointGroupRequest {
	s.Description = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetEndpointConfigurations(v []*UpdateEndpointGroupRequestEndpointConfigurations) *UpdateEndpointGroupRequest {
	s.EndpointConfigurations = v
	return s
}

func (s *UpdateEndpointGroupRequest) SetEndpointGroupId(v string) *UpdateEndpointGroupRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetEndpointGroupRegion(v string) *UpdateEndpointGroupRequest {
	s.EndpointGroupRegion = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetEndpointRequestProtocol(v string) *UpdateEndpointGroupRequest {
	s.EndpointRequestProtocol = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetHealthCheckEnabled(v bool) *UpdateEndpointGroupRequest {
	s.HealthCheckEnabled = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetHealthCheckIntervalSeconds(v int32) *UpdateEndpointGroupRequest {
	s.HealthCheckIntervalSeconds = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetHealthCheckPath(v string) *UpdateEndpointGroupRequest {
	s.HealthCheckPath = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetHealthCheckPort(v int32) *UpdateEndpointGroupRequest {
	s.HealthCheckPort = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetHealthCheckProtocol(v string) *UpdateEndpointGroupRequest {
	s.HealthCheckProtocol = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetName(v string) *UpdateEndpointGroupRequest {
	s.Name = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetPortOverrides(v []*UpdateEndpointGroupRequestPortOverrides) *UpdateEndpointGroupRequest {
	s.PortOverrides = v
	return s
}

func (s *UpdateEndpointGroupRequest) SetRegionId(v string) *UpdateEndpointGroupRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetThresholdCount(v int32) *UpdateEndpointGroupRequest {
	s.ThresholdCount = &v
	return s
}

func (s *UpdateEndpointGroupRequest) SetTrafficPercentage(v int32) *UpdateEndpointGroupRequest {
	s.TrafficPercentage = &v
	return s
}

type UpdateEndpointGroupRequestEndpointConfigurations struct {
	// Specifies whether to reserve client IP addresses. Default value: false. Valid values:
	//
	// *   **true**: reserves client IP addresses.
	// *   **false**: does not reserve client IP addresses.
	EnableClientIPPreservation *bool `json:"EnableClientIPPreservation,omitempty" xml:"EnableClientIPPreservation,omitempty"`
	// Specifies whether to preserve client IP addresses by using the ProxyProtocol module. Default value: false. Valid values:
	//
	// *   **true**: preserves client IP addresses by using the ProxyProtocol module.
	// *   **false**: does not preserve client IP addresses by using the ProxyProtocol module.
	EnableProxyProtocol *bool `json:"EnableProxyProtocol,omitempty" xml:"EnableProxyProtocol,omitempty"`
	// The IP address or domain name of the endpoint.
	Endpoint   *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	SubAddress *string `json:"SubAddress,omitempty" xml:"SubAddress,omitempty"`
	// The type of the endpoint. Valid values:
	//
	// *   **Domain**: a custom domain name
	// *   **Ip**: a custom IP address
	// *   **PublicIp**: a public IP address provided by Alibaba Cloud
	// *   **ECS**: an Elastic Compute Service (ECS) instance
	// *   **SLB**: a Server Load Balancer (SLB) instance
	// *   **ALB**: an Application Load Balancer (ALB) instance
	// *   **OSS**: an Object Storage Service (OSS) bucket
	//
	// > *   If you set this parameter to **ECS** or **SLB** and the service-linked role AliyunServiceRoleForGaVpcEndpoint does not exist, the system automatically creates the service-linked role.
	// > *   If you set this parameter to **ALB** and the service-linked role AliyunServiceRoleForGaAlb does not exist, the system automatically creates the service-linked role.
	// > *   If you set this parameter to **OSS** and the service-linked role AliyunServiceRoleForGaOss does not exist, the system automatically creates the service-linked role.
	//
	// For more information, see [Service-linked roles](~~178360~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the endpoint.
	//
	// Valid values: **0** to **255**.
	//
	// >  If the weight of an endpoint is set to 0, GA stops distributing network traffic to the endpoint. Proceed with caution.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s UpdateEndpointGroupRequestEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupRequestEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupRequestEndpointConfigurations) SetEnableClientIPPreservation(v bool) *UpdateEndpointGroupRequestEndpointConfigurations {
	s.EnableClientIPPreservation = &v
	return s
}

func (s *UpdateEndpointGroupRequestEndpointConfigurations) SetEnableProxyProtocol(v bool) *UpdateEndpointGroupRequestEndpointConfigurations {
	s.EnableProxyProtocol = &v
	return s
}

func (s *UpdateEndpointGroupRequestEndpointConfigurations) SetEndpoint(v string) *UpdateEndpointGroupRequestEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *UpdateEndpointGroupRequestEndpointConfigurations) SetSubAddress(v string) *UpdateEndpointGroupRequestEndpointConfigurations {
	s.SubAddress = &v
	return s
}

func (s *UpdateEndpointGroupRequestEndpointConfigurations) SetType(v string) *UpdateEndpointGroupRequestEndpointConfigurations {
	s.Type = &v
	return s
}

func (s *UpdateEndpointGroupRequestEndpointConfigurations) SetWeight(v int32) *UpdateEndpointGroupRequestEndpointConfigurations {
	s.Weight = &v
	return s
}

type UpdateEndpointGroupRequestPortOverrides struct {
	// The endpoint port that is mapped to the listener port.
	EndpointPort *int32 `json:"EndpointPort,omitempty" xml:"EndpointPort,omitempty"`
	// The listener port that is mapped to the endpoint port.
	//
	// > *   Only HTTP and HTTPS listeners support port mappings.
	// > *   The listener port in a port mapping must be the one used by the current listener.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
}

func (s UpdateEndpointGroupRequestPortOverrides) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupRequestPortOverrides) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupRequestPortOverrides) SetEndpointPort(v int32) *UpdateEndpointGroupRequestPortOverrides {
	s.EndpointPort = &v
	return s
}

func (s *UpdateEndpointGroupRequestPortOverrides) SetListenerPort(v int32) *UpdateEndpointGroupRequestPortOverrides {
	s.ListenerPort = &v
	return s
}

type UpdateEndpointGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEndpointGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupResponseBody) SetRequestId(v string) *UpdateEndpointGroupResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEndpointGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEndpointGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEndpointGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupResponse) SetHeaders(v map[string]*string) *UpdateEndpointGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateEndpointGroupResponse) SetStatusCode(v int32) *UpdateEndpointGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEndpointGroupResponse) SetBody(v *UpdateEndpointGroupResponseBody) *UpdateEndpointGroupResponse {
	s.Body = v
	return s
}

type UpdateEndpointGroupAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the endpoint group that you want to modify.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the endpoint group.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The name of the endpoint group that you want to modify.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the Global Accelerator (GA) instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateEndpointGroupAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupAttributeRequest) SetClientToken(v string) *UpdateEndpointGroupAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateEndpointGroupAttributeRequest) SetDescription(v string) *UpdateEndpointGroupAttributeRequest {
	s.Description = &v
	return s
}

func (s *UpdateEndpointGroupAttributeRequest) SetEndpointGroupId(v string) *UpdateEndpointGroupAttributeRequest {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateEndpointGroupAttributeRequest) SetName(v string) *UpdateEndpointGroupAttributeRequest {
	s.Name = &v
	return s
}

func (s *UpdateEndpointGroupAttributeRequest) SetRegionId(v string) *UpdateEndpointGroupAttributeRequest {
	s.RegionId = &v
	return s
}

type UpdateEndpointGroupAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEndpointGroupAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupAttributeResponseBody) SetRequestId(v string) *UpdateEndpointGroupAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEndpointGroupAttributeResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEndpointGroupAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEndpointGroupAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupAttributeResponse) SetHeaders(v map[string]*string) *UpdateEndpointGroupAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateEndpointGroupAttributeResponse) SetStatusCode(v int32) *UpdateEndpointGroupAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEndpointGroupAttributeResponse) SetBody(v *UpdateEndpointGroupAttributeResponseBody) *UpdateEndpointGroupAttributeResponse {
	s.Body = v
	return s
}

type UpdateEndpointGroupsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **true:** performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The configurations of the endpoint group.
	EndpointGroupConfigurations []*UpdateEndpointGroupsRequestEndpointGroupConfigurations `json:"EndpointGroupConfigurations,omitempty" xml:"EndpointGroupConfigurations,omitempty" type:"Repeated"`
	// The listener ID.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateEndpointGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupsRequest) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupsRequest) SetClientToken(v string) *UpdateEndpointGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateEndpointGroupsRequest) SetDryRun(v bool) *UpdateEndpointGroupsRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateEndpointGroupsRequest) SetEndpointGroupConfigurations(v []*UpdateEndpointGroupsRequestEndpointGroupConfigurations) *UpdateEndpointGroupsRequest {
	s.EndpointGroupConfigurations = v
	return s
}

func (s *UpdateEndpointGroupsRequest) SetListenerId(v string) *UpdateEndpointGroupsRequest {
	s.ListenerId = &v
	return s
}

func (s *UpdateEndpointGroupsRequest) SetRegionId(v string) *UpdateEndpointGroupsRequest {
	s.RegionId = &v
	return s
}

type UpdateEndpointGroupsRequestEndpointGroupConfigurations struct {
	// Specifies whether to use the proxy protocol to preserve client IP addresses. Valid values:
	//
	// *   **true**
	// *   **false**
	EnableClientIPPreservationProxyProtocol *bool `json:"EnableClientIPPreservationProxyProtocol,omitempty" xml:"EnableClientIPPreservationProxyProtocol,omitempty"`
	// Specifies whether to preserve client IP addresses by using the TCP Option Address (TOA) module. Valid values:
	//
	// *   **true**
	// *   **false**
	EnableClientIPPreservationToa *bool `json:"EnableClientIPPreservationToa,omitempty" xml:"EnableClientIPPreservationToa,omitempty"`
	// The configurations of endpoints in the endpoint group.
	EndpointConfigurations []*UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations `json:"EndpointConfigurations,omitempty" xml:"EndpointConfigurations,omitempty" type:"Repeated"`
	// The description of the endpoint group.
	//
	// The description can be up to 256 characters in length and cannot contain `http://` or `https://`.
	EndpointGroupDescription *string `json:"EndpointGroupDescription,omitempty" xml:"EndpointGroupDescription,omitempty"`
	// The endpoint ID.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
	// The name of the endpoint group.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	EndpointGroupName *string `json:"EndpointGroupName,omitempty" xml:"EndpointGroupName,omitempty"`
	// The protocol that is used by the backend service. Valid values:
	//
	// *   **HTTP**
	// *   **HTTPS**
	//
	// >
	//
	// *   You can set this parameter only when the listener that is associated with the endpoint group uses the HTTP or HTTPS protocol.
	//
	// *   For an HTTP listener, the backend service protocol must be HTTP.
	EndpointRequestProtocol *string `json:"EndpointRequestProtocol,omitempty" xml:"EndpointRequestProtocol,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	HealthCheckEnabled *bool `json:"HealthCheckEnabled,omitempty" xml:"HealthCheckEnabled,omitempty"`
	// The interval at which health checks are performed. Unit: seconds. Valid values: **1** to **50**.
	HealthCheckIntervalSeconds *int64 `json:"HealthCheckIntervalSeconds,omitempty" xml:"HealthCheckIntervalSeconds,omitempty"`
	// The path to which health check requests are sent.
	HealthCheckPath *string `json:"HealthCheckPath,omitempty" xml:"HealthCheckPath,omitempty"`
	// The port that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	HealthCheckPort *int64 `json:"HealthCheckPort,omitempty" xml:"HealthCheckPort,omitempty"`
	// The protocol over which health check requests are sent. Valid values:
	//
	// *   **tcp:** TCP
	// *   **http:** HTTP
	// *   **https:** HTTPS
	HealthCheckProtocol *string `json:"HealthCheckProtocol,omitempty" xml:"HealthCheckProtocol,omitempty"`
	// The port mapping.
	PortOverrides []*UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides `json:"PortOverrides,omitempty" xml:"PortOverrides,omitempty" type:"Repeated"`
	// The number of consecutive health check failures that must occur before a healthy endpoint group is considered unhealthy, or the number of consecutive health check successes that must occur before an unhealthy endpoint group is considered healthy.
	//
	// Valid values: **2** to **10**.
	ThresholdCount *int64 `json:"ThresholdCount,omitempty" xml:"ThresholdCount,omitempty"`
	// The traffic ratio for the endpoint group when the specified listener is associated with multiple endpoint groups.
	//
	// Valid values: **1** to **100**.
	TrafficPercentage *int64 `json:"TrafficPercentage,omitempty" xml:"TrafficPercentage,omitempty"`
}

func (s UpdateEndpointGroupsRequestEndpointGroupConfigurations) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupsRequestEndpointGroupConfigurations) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetEnableClientIPPreservationProxyProtocol(v bool) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EnableClientIPPreservationProxyProtocol = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetEnableClientIPPreservationToa(v bool) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EnableClientIPPreservationToa = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointConfigurations(v []*UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointConfigurations = v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupDescription(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupDescription = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupId(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupId = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointGroupName(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointGroupName = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetEndpointRequestProtocol(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.EndpointRequestProtocol = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckEnabled(v bool) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckEnabled = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckIntervalSeconds(v int64) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckIntervalSeconds = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckPath(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckPath = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckPort(v int64) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckPort = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetHealthCheckProtocol(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.HealthCheckProtocol = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetPortOverrides(v []*UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.PortOverrides = v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetThresholdCount(v int64) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.ThresholdCount = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurations) SetTrafficPercentage(v int64) *UpdateEndpointGroupsRequestEndpointGroupConfigurations {
	s.TrafficPercentage = &v
	return s
}

type UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations struct {
	// The IP address or domain name of the endpoint.
	Endpoint   *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	SubAddress *string `json:"SubAddress,omitempty" xml:"SubAddress,omitempty"`
	// The type of the endpoint.
	//
	// *   **Domain:** a custom domain name.
	// *   **Ip:** a custom IP address.
	// *   **PublicIp:** a public IP address provided by Alibaba Cloud.
	// *   **ECS:** an Elastic Compute Service (ECS) instance.
	// *   **SLB:** a Server Load Balancer (SLB) instance.
	// *   **ALB:** an Application Load Balancer (ALB) instance.
	// *   **OSS:** an Object Storage Service (OSS) bucket.
	//
	// >
	//
	// *   If you set this parameter to **ECS** or **SLB** and the service-linked role AliyunServiceRoleForGaVpcEndpoint does not exist, the system automatically creates the service-linked role.
	//
	// *   If you set this parameter to **ALB** and the service-linked role AliyunServiceRoleForGaAlb does not exist, the system creates the service-linked role.
	// *   If you set this parameter to **OSS** and the service-linked role AliyunServiceRoleForGaOss does not exist, the system creates the service-linked role.
	//
	// For more information, see [Service-linked roles](~~178360~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the endpoint.
	//
	// Valid values: **0** to **255**.
	//
	// > If you set the weight of an endpoint to 0, GA does not route network traffic to the endpoint. Make sure that you are aware of the impact on your business before you set the endpoint weight to 0.
	Weight *int64 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetEndpoint(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Endpoint = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetSubAddress(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.SubAddress = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetType(v string) *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Type = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations) SetWeight(v int64) *UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations {
	s.Weight = &v
	return s
}

type UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides struct {
	// The endpoint port.
	//
	// Valid values: **1** to **65499**.
	EndpointPort *int64 `json:"EndpointPort,omitempty" xml:"EndpointPort,omitempty"`
	// The listener port of the instance.
	//
	// Valid values: **1** to **65499**.
	//
	// >
	//
	// *   Only HTTP and HTTPS listeners support port mappings.
	//
	// *   The listener port in a port mapping must be the one used by the current listener.
	ListenerPort *int64 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
}

func (s UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) SetEndpointPort(v int64) *UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides {
	s.EndpointPort = &v
	return s
}

func (s *UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides) SetListenerPort(v int64) *UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides {
	s.ListenerPort = &v
	return s
}

type UpdateEndpointGroupsResponseBody struct {
	// The IDs of the endpoint groups.
	EndpointGroupIds []*string `json:"EndpointGroupIds,omitempty" xml:"EndpointGroupIds,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEndpointGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupsResponseBody) SetEndpointGroupIds(v []*string) *UpdateEndpointGroupsResponseBody {
	s.EndpointGroupIds = v
	return s
}

func (s *UpdateEndpointGroupsResponseBody) SetRequestId(v string) *UpdateEndpointGroupsResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEndpointGroupsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEndpointGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEndpointGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEndpointGroupsResponse) GoString() string {
	return s.String()
}

func (s *UpdateEndpointGroupsResponse) SetHeaders(v map[string]*string) *UpdateEndpointGroupsResponse {
	s.Headers = v
	return s
}

func (s *UpdateEndpointGroupsResponse) SetStatusCode(v int32) *UpdateEndpointGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEndpointGroupsResponse) SetBody(v *UpdateEndpointGroupsResponseBody) *UpdateEndpointGroupsResponse {
	s.Body = v
	return s
}

type UpdateForwardingRulesRequest struct {
	// The ID of the GA instance.
	AcceleratorId *string `json:"AcceleratorId,omitempty" xml:"AcceleratorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The information about the forwarding rules.
	ForwardingRules []*UpdateForwardingRulesRequestForwardingRules `json:"ForwardingRules,omitempty" xml:"ForwardingRules,omitempty" type:"Repeated"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateForwardingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequest) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequest) SetAcceleratorId(v string) *UpdateForwardingRulesRequest {
	s.AcceleratorId = &v
	return s
}

func (s *UpdateForwardingRulesRequest) SetClientToken(v string) *UpdateForwardingRulesRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateForwardingRulesRequest) SetForwardingRules(v []*UpdateForwardingRulesRequestForwardingRules) *UpdateForwardingRulesRequest {
	s.ForwardingRules = v
	return s
}

func (s *UpdateForwardingRulesRequest) SetListenerId(v string) *UpdateForwardingRulesRequest {
	s.ListenerId = &v
	return s
}

func (s *UpdateForwardingRulesRequest) SetRegionId(v string) *UpdateForwardingRulesRequest {
	s.RegionId = &v
	return s
}

type UpdateForwardingRulesRequestForwardingRules struct {
	// The ID of the forwarding rule.
	ForwardingRuleId *string `json:"ForwardingRuleId,omitempty" xml:"ForwardingRuleId,omitempty"`
	// The name of the forwarding rule.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	ForwardingRuleName *string `json:"ForwardingRuleName,omitempty" xml:"ForwardingRuleName,omitempty"`
	// The priority of the forwarding rule. Valid values: **1** to **10000**. A lower value indicates a higher priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The forwarding action.
	RuleActions []*UpdateForwardingRulesRequestForwardingRulesRuleActions `json:"RuleActions,omitempty" xml:"RuleActions,omitempty" type:"Repeated"`
	// The forwarding conditions.
	RuleConditions []*UpdateForwardingRulesRequestForwardingRulesRuleConditions `json:"RuleConditions,omitempty" xml:"RuleConditions,omitempty" type:"Repeated"`
	// The direction in which the rule takes effect. You do not need to set this parameter.
	//
	// By default, this parameter is set to **request**, which indicates that the rule takes effect on requests.
	RuleDirection *string `json:"RuleDirection,omitempty" xml:"RuleDirection,omitempty"`
}

func (s UpdateForwardingRulesRequestForwardingRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequestForwardingRules) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequestForwardingRules) SetForwardingRuleId(v string) *UpdateForwardingRulesRequestForwardingRules {
	s.ForwardingRuleId = &v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRules) SetForwardingRuleName(v string) *UpdateForwardingRulesRequestForwardingRules {
	s.ForwardingRuleName = &v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRules) SetPriority(v int32) *UpdateForwardingRulesRequestForwardingRules {
	s.Priority = &v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRules) SetRuleActions(v []*UpdateForwardingRulesRequestForwardingRulesRuleActions) *UpdateForwardingRulesRequestForwardingRules {
	s.RuleActions = v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRules) SetRuleConditions(v []*UpdateForwardingRulesRequestForwardingRulesRuleConditions) *UpdateForwardingRulesRequestForwardingRules {
	s.RuleConditions = v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRules) SetRuleDirection(v string) *UpdateForwardingRulesRequestForwardingRules {
	s.RuleDirection = &v
	return s
}

type UpdateForwardingRulesRequestForwardingRulesRuleActions struct {
	// The forwarding configurations.
	//
	// >  We recommend that you do not use this parameter. We recommend that you use the **RuleActionType** and **RuleActionValue** parameters to configure forwarding actions.
	ForwardGroupConfig *UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig `json:"ForwardGroupConfig,omitempty" xml:"ForwardGroupConfig,omitempty" type:"Struct"`
	// The forwarding priority.
	//
	// >  This parameter does not take effect. Ignore this parameter.
	Order *int32 `json:"Order,omitempty" xml:"Order,omitempty"`
	// The type of the forwarding action. Valid values:
	//
	// *   **ForwardGroup**: forwards a request.
	// *   **Redirect**: redirects a request.
	// *   **FixResponse**: returns a fixed response.
	// *   **Rewrite**: rewrites a request.
	// *   **AddHeader**: adds a header to a request.
	// *   **RemoveHeader**: deletes the header of a request.
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	// The value of the forwarding action type.
	//
	// You must specify different JSON strings based on the **RuleActionType** parameter.
	//
	// A forwarding rule can contain only one forwarding action whose type is **ForwardGroup**, **Redirect**, or **FixResponse**. You must specify a forwarding action whose type is **Rewrite**, **AddHeader**, or **RemoveHeader** before a forwarding action whose type is **ForwardGroup**.
	//
	// *   If **RuleActionType** is set to **ForwardGroup**, this parameter specifies the information of a virtual endpoint group. You can forward requests to only one virtual endpoint group. Example: `{"type":"endpointgroup", "value":"epg-bp1enpdcrqhl78g6r****"}`.
	//
	//     *   `type`: set this parameter to `endpointgroup`.
	//     *   `value`: set this parameter to the ID of a virtual endpoint group.
	//
	// *   If **RuleActionType** is set to **Redirect**, this parameter specifies redirecting configurations. You cannot leave all of the following parameters empty or configure all of these parameters to use the default values for a forwarding action whose type is **Redirect**: `protocol`, `domain`, `port`, `path`, and `query`. Example: `{"protocol":"HTTP", "domain":"www.example.com", "port":"80", "path":"/a","query":"value1", "code":"301" }`.
	//
	//     *   `protocol`: the protocol of requests after the requests are redirected. Valid values: `${protocol}` (default), `HTTP`, and `HTTPS`.
	//     *   `domain`: the domain name to which requests are redirected. Default value: `${host}`. You can also enter a domain name. The domain name must be 3 to 128 characters in length, and can contain only letters, digits, and the following special characters: `. - ? = ~ _ - + / ^ * ! $ & | ( ) [ ]`.
	//     *   `port`: the port to which requests are redirected. Default value: `${port}`. You can enter a port number that ranges from 1 to 63335.
	//     *   `path`: the path to which requests are redirected. Default value: `${path}`. The path must be 1 to 128 characters in length. To use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? ~ ^ * $ : ( ) [ ] + |`. The path must start with a tilde (~). If you do not want to use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? :`. The path must start with a forward slash (/).
	//     *   `query`: the query string of the requests to be redirected. Default value: `${query}`. You can also specify a query string. The query string must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The query string cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > # | &`.
	//     *   `code`: the redirecting code. Valid values: `301`, `302`, `303`, `307`, and `308`.
	//
	// *   If **RuleActionType** is set to **FixResponse**, this parameter specifies a fixed response. Example: `{"code":"200", "type":"text/plain", "content":"dssacav" }`.
	//
	//     *   `code`: the HTTP response status code. The response status code must be one of the following numeric strings: `2xx`, `4xx`, and `5xx`. The letter `x` indicates a number from 0 to 9.
	//     *   `type`: the type of the response content. Valid values: **text/plain**, **text/css**, **text/html**, **application/javascript**, and **application/json**.
	//     *   `content`: the response content. The response content cannot exceed 1,000 characters in length and does not support Chinese characters.
	//
	// *   If **RuleActionType** is set to **AddHeader**, this parameter specifies an HTTP header to be added. If a forwarding rule contains a forwarding action whose type is **AddHeader**, you must specify another forwarding action whose type is **ForwardGroup**. Example: `[{"name":"header1","type":"userdefined", "value":"value"}]`.
	//
	//     *   `name`: the name of the HTTP header. The name must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). The name of the HTTP header specified by **AddHeader** must be unique and cannot be the same as the name of the HTTP header specified by **RemoveHeader**.
	//     *   `type`: the content type of the HTTP header. Valid values: `user-defined`, `ref`, and `system-defined`.
	//     *   `value`: the content of the HTTP header. You cannot leave this parameter empty. If you set `type` to `user-defined`, the content must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The content can contain letters, digits, hyphens (-), and underscores (\_). The content cannot start or end with a space character. If you set `type` to `ref`, the content must be 1 to 128 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). The content cannot start or end with a space character. If you set `type` to `system-defined`, only `ClientSrcIp` is supported.
	//
	// *   If **RuleActionType** is set to **RemoveHeader**, this parameter specifies an HTTP header to be removed. If a forwarding rule contains a forwarding action whose type is **RemoveHeader**, you must specify another forwarding action whose type is **ForwardGroup**. The header must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_). Example: `["header1"]`.
	//
	// *   If **RuleActionType** is set to **Rewrite**, this parameter specifies the rewriting configuration. If a forwarding rule contains a forwarding action whose type is **Rewrite**, you must specify another forwarding action whose type is **ForwardGroup**. Example: `{"domain":"value1", "path":"value2", "query":"value3"}`.
	//
	//     *   `domain`: the domain name to which requests are redirected. Default value: `${host}`. You can also enter a domain name. The domain name must be 3 to 128 characters in length, and can contain only lowercase letters, digits, and the following special characters: `. - ? = ~ _ - + / ^ * ! $ & | ( ) [ ]`.
	//     *   `path`: the path to which requests are redirected. Default value: `${path}`. The path must be 1 to 128 characters in length. To use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? ~ ^ * $ : ( ) [ ] + |`. The path must start with a tilde (~). If you do not want to use a regular expression, the path can contain letters, digits, and the following special characters: `. - _ / = ? :`. The path must start with a forward slash (/).
	//     *   `query`: the query string of the requests to be redirected. Default value: `${query}`. You can also specify a query string. The query string must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The query string cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > # | &`.
	RuleActionValue *string `json:"RuleActionValue,omitempty" xml:"RuleActionValue,omitempty"`
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleActions) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleActions) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleActions) SetForwardGroupConfig(v *UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) *UpdateForwardingRulesRequestForwardingRulesRuleActions {
	s.ForwardGroupConfig = v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleActions) SetOrder(v int32) *UpdateForwardingRulesRequestForwardingRulesRuleActions {
	s.Order = &v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleActions) SetRuleActionType(v string) *UpdateForwardingRulesRequestForwardingRulesRuleActions {
	s.RuleActionType = &v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleActions) SetRuleActionValue(v string) *UpdateForwardingRulesRequestForwardingRulesRuleActions {
	s.RuleActionValue = &v
	return s
}

type UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig struct {
	// The information about the endpoint group.
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you call **RuleActionType** and **RuleActionValue** to query forwarding actions.
	ServerGroupTuples []*UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples `json:"ServerGroupTuples,omitempty" xml:"ServerGroupTuples,omitempty" type:"Repeated"`
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig) SetServerGroupTuples(v []*UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) *UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig {
	s.ServerGroupTuples = v
	return s
}

type UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples struct {
	// The ID of the endpoint group.
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you call **RuleActionType** and **RuleActionValue** to query forwarding actions.
	EndpointGroupId *string `json:"EndpointGroupId,omitempty" xml:"EndpointGroupId,omitempty"`
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples) SetEndpointGroupId(v string) *UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples {
	s.EndpointGroupId = &v
	return s
}

type UpdateForwardingRulesRequestForwardingRulesRuleConditions struct {
	// The configuration of the domain name.
	//
	// >  We recommend that you do not use this parameter. We recommend that you use the **RuleConditionType** and **RuleConditionValue** parameters to configure forwarding conditions.
	HostConfig *UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig `json:"HostConfig,omitempty" xml:"HostConfig,omitempty" type:"Struct"`
	// The configuration of the path.
	//
	// >  We recommend that you do not use this parameter. We recommend that you use the **RuleConditionType** and **RuleConditionValue** parameters to configure forwarding conditions.
	PathConfig *UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig `json:"PathConfig,omitempty" xml:"PathConfig,omitempty" type:"Struct"`
	// The type of the forwarding conditions. Valid values:
	//
	// *   **Host**: domain name
	// *   **Path**: path
	// *   **RequestHeader**: HTTP header
	// *   **Query**: query string
	// *   **Method**: HTTP method
	// *   **Cookie**: cookie
	// *   **SourceIP**: source IP address
	RuleConditionType *string `json:"RuleConditionType,omitempty" xml:"RuleConditionType,omitempty"`
	// The value of the forwarding condition type.
	//
	// You must specify different JSON strings based on the **RuleConditionType** parameter.
	//
	// *   If **RuleConditionType** is set to **Host**, this parameter specifies a domain name condition. A forwarding rule can contain only one forwarding condition whose type is host. You can specify multiple domain names in a forwarding condition. The relationship between multiple domain names is OR. The domain name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), and periods (.). Supported wildcard characters are asterisks (\*) and question marks (?). Example: `["www.example.com", "www.aliyun.com"]`.
	//
	// *   If **RuleConditionType** is set to **Path**, this parameter specifies a path condition. A forwarding rule can contain multiple forwarding conditions whose types are path. The relationship between multiple path conditions is OR. You can specify multiple paths in a forwarding condition. The relationship between multiple paths is OR. The path must be 1 to 128 characters in length, and must start with a forward slash (/). The path can contain letters, digits, and the following special characters: $ - \_ . + / & ~ @ : \". Supported wildcard characters are asterisks (\*) and question marks (?). Example: `["/a", "/b/"]`.
	//
	// *   If **RuleConditionType** is set to **RequestHeader**, this parameter specifies an HTTP header condition that consists of key-value pairs. The header values in a forwarding condition must be unique. Example: `[{"header1":["value1","value2"]}]`.
	//
	//     *   Key: The key of an HTTP header must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\_).
	//     *   Value: The value of an HTTP header must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The value cannot start or end with a space character.
	//
	// *   If **RuleConditionType** is set to **Query**, this parameter specifies a query string condition that consists of key-value pairs. Example: `[{"query1":["value1"]}, {"query2":["value2"]}]`.
	//
	//     *   Key: The key of an HTTP header must be 1 to 100 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The key cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > \ ; / ? : @ & = + , $ % | " ^ ~`.
	//     *   Value: The value of an HTTP header must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The value cannot contain uppercase letters, space characters, or the following special characters: `[ ] { } < > \ ; / ? : @ & = + , $ % | " ^ ~`.
	//
	// *   If **RuleConditionType** is set to **Method**, this parameter specifies an HTTP method condition. Valid values: **HEAD**, **GET**, **POST**, **OPTIONS**, **PUT**, **PATCH**, and **DELETE**. Example: `["GET", "OPTIONS", "POST"]`.
	//
	// *   If **RuleConditionType** is set to **Cookie**, this parameter specifies a cookie condition that consists of key-value pairs. Example: `[{"cookie1":["value1"]}, {"cookie2":["value2"]}]`.
	//
	//     *   Key: The key of a cookie must be 1 to 100 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. The key cannot contain uppercase letters, space characters, or the following special characters: `# [ ] { } \ | < > &`.
	//     *   Value: The value of a cookie must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. The value cannot contain uppercase letters, space characters, or the following special characters: `# [ ] { } \ | < > &`.
	//
	// *   If **RuleConditionType** is set to **SourceIP**, this parameter specifies a source IP address condition. You can specify IP addresses, such as 1.1.XX.XX/32. You can also specify CIDR blocks, such as 2.2.XX.XX/24. A forwarding rule can contain only one forwarding condition whose type is source IP address. You can specify multiple source IP addresses in a forwarding condition. The relationship between multiple source IP addresses is OR. Example: `["1.1.XX.XX/32", "2.2.XX.XX/24"]`.
	RuleConditionValue *string `json:"RuleConditionValue,omitempty" xml:"RuleConditionValue,omitempty"`
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleConditions) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleConditions) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleConditions) SetHostConfig(v *UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) *UpdateForwardingRulesRequestForwardingRulesRuleConditions {
	s.HostConfig = v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleConditions) SetPathConfig(v *UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) *UpdateForwardingRulesRequestForwardingRulesRuleConditions {
	s.PathConfig = v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleConditions) SetRuleConditionType(v string) *UpdateForwardingRulesRequestForwardingRulesRuleConditions {
	s.RuleConditionType = &v
	return s
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleConditions) SetRuleConditionValue(v string) *UpdateForwardingRulesRequestForwardingRulesRuleConditions {
	s.RuleConditionValue = &v
	return s
}

type UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig struct {
	// The domain name.
	//
	// The domain name must be 3 to 128 characters in length, and can contain letters, digits, hyphens (-), and periods (.). Supported wildcard characters are asterisks (\*) and question marks (?).
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you use **RuleConditionType** and **RuleConditionValue** to query forwarding conditions.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig) SetValues(v []*string) *UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig {
	s.Values = v
	return s
}

type UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig struct {
	// The path.
	//
	// The path must be 1 to 128 characters in length and must start with a forward slash (/). The path can contain only letters, digits, and the following special characters: $ - \_ . + / & ~ @ : \". Supported wildcard characters are asterisks (\*) and question marks (?).
	//
	// >  For GA instances created after July 12, 2022, all forwarding condition types and forwarding action types are supported. We recommend that you use **RuleConditionType** and **RuleConditionValue** to query forwarding conditions.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig) SetValues(v []*string) *UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig {
	s.Values = v
	return s
}

type UpdateForwardingRulesResponseBody struct {
	// Details about the forwarding rules.
	ForwardingRules []*UpdateForwardingRulesResponseBodyForwardingRules `json:"ForwardingRules,omitempty" xml:"ForwardingRules,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateForwardingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesResponseBody) SetForwardingRules(v []*UpdateForwardingRulesResponseBodyForwardingRules) *UpdateForwardingRulesResponseBody {
	s.ForwardingRules = v
	return s
}

func (s *UpdateForwardingRulesResponseBody) SetRequestId(v string) *UpdateForwardingRulesResponseBody {
	s.RequestId = &v
	return s
}

type UpdateForwardingRulesResponseBodyForwardingRules struct {
	// The ID of the forwarding rule.
	ForwardingRuleId *string `json:"ForwardingRuleId,omitempty" xml:"ForwardingRuleId,omitempty"`
}

func (s UpdateForwardingRulesResponseBodyForwardingRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesResponseBodyForwardingRules) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesResponseBodyForwardingRules) SetForwardingRuleId(v string) *UpdateForwardingRulesResponseBodyForwardingRules {
	s.ForwardingRuleId = &v
	return s
}

type UpdateForwardingRulesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateForwardingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateForwardingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateForwardingRulesResponse) GoString() string {
	return s.String()
}

func (s *UpdateForwardingRulesResponse) SetHeaders(v map[string]*string) *UpdateForwardingRulesResponse {
	s.Headers = v
	return s
}

func (s *UpdateForwardingRulesResponse) SetStatusCode(v int32) *UpdateForwardingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateForwardingRulesResponse) SetBody(v *UpdateForwardingRulesResponseBody) *UpdateForwardingRulesResponse {
	s.Body = v
	return s
}

type UpdateIpSetRequest struct {
	// The new bandwidth to be allocated to the acceleration region. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the acceleration region that you want to modify.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
	// The ID of the region where the GA instance is deployed. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpSetRequest) GoString() string {
	return s.String()
}

func (s *UpdateIpSetRequest) SetBandwidth(v int32) *UpdateIpSetRequest {
	s.Bandwidth = &v
	return s
}

func (s *UpdateIpSetRequest) SetClientToken(v string) *UpdateIpSetRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateIpSetRequest) SetIpSetId(v string) *UpdateIpSetRequest {
	s.IpSetId = &v
	return s
}

func (s *UpdateIpSetRequest) SetRegionId(v string) *UpdateIpSetRequest {
	s.RegionId = &v
	return s
}

type UpdateIpSetResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIpSetResponseBody) SetRequestId(v string) *UpdateIpSetResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIpSetResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpSetResponse) GoString() string {
	return s.String()
}

func (s *UpdateIpSetResponse) SetHeaders(v map[string]*string) *UpdateIpSetResponse {
	s.Headers = v
	return s
}

func (s *UpdateIpSetResponse) SetStatusCode(v int32) *UpdateIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIpSetResponse) SetBody(v *UpdateIpSetResponseBody) *UpdateIpSetResponse {
	s.Body = v
	return s
}

type UpdateIpSetsRequest struct {
	// The acceleration regions.
	IpSets []*UpdateIpSetsRequestIpSets `json:"IpSets,omitempty" xml:"IpSets,omitempty" type:"Repeated"`
	// The region ID of the Global Accelerator (GA) instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateIpSetsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpSetsRequest) GoString() string {
	return s.String()
}

func (s *UpdateIpSetsRequest) SetIpSets(v []*UpdateIpSetsRequestIpSets) *UpdateIpSetsRequest {
	s.IpSets = v
	return s
}

func (s *UpdateIpSetsRequest) SetRegionId(v string) *UpdateIpSetsRequest {
	s.RegionId = &v
	return s
}

type UpdateIpSetsRequestIpSets struct {
	// The new bandwidth of the acceleration region. Unit: Mbit/s.
	//
	// You can specify the bandwidth for up to 100 acceleration regions.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the acceleration region that you want to modify.
	//
	// You can specify the IDs of up to 100 acceleration regions.
	IpSetId *string `json:"IpSetId,omitempty" xml:"IpSetId,omitempty"`
}

func (s UpdateIpSetsRequestIpSets) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpSetsRequestIpSets) GoString() string {
	return s.String()
}

func (s *UpdateIpSetsRequestIpSets) SetBandwidth(v int32) *UpdateIpSetsRequestIpSets {
	s.Bandwidth = &v
	return s
}

func (s *UpdateIpSetsRequestIpSets) SetIpSetId(v string) *UpdateIpSetsRequestIpSets {
	s.IpSetId = &v
	return s
}

type UpdateIpSetsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIpSetsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpSetsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIpSetsResponseBody) SetRequestId(v string) *UpdateIpSetsResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIpSetsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateIpSetsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIpSetsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIpSetsResponse) GoString() string {
	return s.String()
}

func (s *UpdateIpSetsResponse) SetHeaders(v map[string]*string) *UpdateIpSetsResponse {
	s.Headers = v
	return s
}

func (s *UpdateIpSetsResponse) SetStatusCode(v int32) *UpdateIpSetsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIpSetsResponse) SetBody(v *UpdateIpSetsResponseBody) *UpdateIpSetsResponse {
	s.Body = v
	return s
}

type UpdateListenerRequest struct {
	// The range of ports that are used by backend servers to receive requests.
	BackendPorts []*UpdateListenerRequestBackendPorts `json:"BackendPorts,omitempty" xml:"BackendPorts,omitempty" type:"Repeated"`
	// The SSL certificate.
	Certificates []*UpdateListenerRequestCertificates `json:"Certificates,omitempty" xml:"Certificates,omitempty" type:"Repeated"`
	// Specifies whether to enable client affinity for the listener.
	//
	// *   If this parameter is left empty, client affinity is disabled. After client affinity is disabled, requests from a specific client IP address may be forwarded to different endpoints.
	// *   To enable client affinity, set this parameter to **SOURCE_IP**. In this case, when a client accesses stateful applications, requests from the same client are always forwarded to the same endpoint regardless of the source port or protocol.
	ClientAffinity *string `json:"ClientAffinity,omitempty" xml:"ClientAffinity,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The ClientToken value can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the listener. The description can be at most 200 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the listener.
	ListenerId *string `json:"ListenerId,omitempty" xml:"ListenerId,omitempty"`
	// The name of the listener.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The listener ports that are used to receive requests and forward the requests to endpoints.
	//
	// Valid values: **1** to **65499**.
	//
	// The maximum number of ports that can be configured varies based on the routing type and protocol of the listener. For more information, see [Listener overview](~~153216~~).
	PortRanges []*UpdateListenerRequestPortRanges `json:"PortRanges,omitempty" xml:"PortRanges,omitempty" type:"Repeated"`
	// The network transmission protocol that is used by the listener. Valid values:
	//
	// *   **tcp**: TCP
	// *   **udp**: UDP
	// *   **http**: HTTP
	// *   **https**: HTTPS
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// Specifies whether to reserve client IP addresses. Default value: false. Valid values:
	//
	// *   **true**: enables client IP preservation. After client IP addresses are reserved, you can view client IP addresses on the endpoints.
	// *   **false** (default): disables client IP preservation.
	//
	// > This parameter will be deprecated in the API operations that are used to configure listeners. We recommend that you set this parameter when you call API operations to configure endpoint groups. For more information about the **ProxyProtocol** parameter, see [CreateEndpointGroup](~~153259~~) and [UpdateEndpointGroup](~~153262~~).
	ProxyProtocol *string `json:"ProxyProtocol,omitempty" xml:"ProxyProtocol,omitempty"`
	// The region ID of the GA instance. Set the value to **cn-hangzhou**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the security policy. Valid values:
	//
	// *   **tls_cipher_policy\_1\_0**
	//
	//     *   Supported Transport Layer Security (TLS) versions: TLS 1.0, TLS 1.1, and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_1**
	//
	//     *   Supported TLS versions: TLS 1.1 and TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict**
	//
	//     *   Supported TLS version: TLS 1.2
	//     *   Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict_with\_1\_3**
	//
	//     *   Supported TLS versions: TLS 1.2 and TLS 1.3
	//     *   Supported cipher suites: TLS_AES\_128\_GCM_SHA256, TLS_AES\_256\_GCM_SHA384, TLS_CHACHA20\_POLY1305\_SHA256, TLS_AES\_128\_CCM_SHA256, TLS_AES\_128\_CCM\_8\_SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES128-SHA256, ECDHE-ECDSA-AES256-SHA384, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-ECDSA-AES128-SHA, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// > This parameter is available only when you create an HTTPS listener.
	SecurityPolicyId *string `json:"SecurityPolicyId,omitempty" xml:"SecurityPolicyId,omitempty"`
	// The `XForward` headers.
	XForwardedForConfig *UpdateListenerRequestXForwardedForConfig `json:"XForwardedForConfig,omitempty" xml:"XForwardedForConfig,omitempty" type:"Struct"`
}

func (s UpdateListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateListenerRequest) GoString() string {
	return s.String()
}

func (s *UpdateListenerRequest) SetBackendPorts(v []*UpdateListenerRequestBackendPorts) *UpdateListenerRequest {
	s.BackendPorts = v
	return s
}

func (s *UpdateListenerRequest) SetCertificates(v []*UpdateListenerRequestCertificates) *UpdateListenerRequest {
	s.Certificates = v
	return s
}

func (s *UpdateListenerRequest) SetClientAffinity(v string) *UpdateListenerRequest {
	s.ClientAffinity = &v
	return s
}

func (s *UpdateListenerRequest) SetClientToken(v string) *UpdateListenerRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateListenerRequest) SetDescription(v string) *UpdateListenerRequest {
	s.Description = &v
	return s
}

func (s *UpdateListenerRequest) SetListenerId(v string) *UpdateListenerRequest {
	s.ListenerId = &v
	return s
}

func (s *UpdateListenerRequest) SetName(v string) *UpdateListenerRequest {
	s.Name = &v
	return s
}

func (s *UpdateListenerRequest) SetPortRanges(v []*UpdateListenerRequestPortRanges) *UpdateListenerRequest {
	s.PortRanges = v
	return s
}

func (s *UpdateListenerRequest) SetProtocol(v string) *UpdateListenerRequest {
	s.Protocol = &v
	return s
}

func (s *UpdateListenerRequest) SetProxyProtocol(v string) *UpdateListenerRequest {
	s.ProxyProtocol = &v
	return s
}

func (s *UpdateListenerRequest) SetRegionId(v string) *UpdateListenerRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateListenerRequest) SetSecurityPolicyId(v string) *UpdateListenerRequest {
	s.SecurityPolicyId = &v
	return s
}

func (s *UpdateListenerRequest) SetXForwardedForConfig(v *UpdateListenerRequestXForwardedForConfig) *UpdateListenerRequest {
	s.XForwardedForConfig = v
	return s
}

type UpdateListenerRequestBackendPorts struct {
	// The first port in the range of ports that are used by backend servers to receive requests.
	//
	// > This parameter is required only when you configure an HTTPS or HTTP listener and the listener port is different from the service port of the backend servers. In this case, the first port that is used by the backend servers to receive requests must be the same as the last port.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port in the range of ports that are used by backend servers to receive requests.
	//
	// > This parameter is required only when you configure an HTTPS or HTTP listener and the listener port is different from the service port of the backend servers. In this case, the first port that is used by the backend servers to receive requests must be the same as the last port.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s UpdateListenerRequestBackendPorts) String() string {
	return tea.Prettify(s)
}

func (s UpdateListenerRequestBackendPorts) GoString() string {
	return s.String()
}

func (s *UpdateListenerRequestBackendPorts) SetFromPort(v int32) *UpdateListenerRequestBackendPorts {
	s.FromPort = &v
	return s
}

func (s *UpdateListenerRequestBackendPorts) SetToPort(v int32) *UpdateListenerRequestBackendPorts {
	s.ToPort = &v
	return s
}

type UpdateListenerRequestCertificates struct {
	// The ID of the SSL certificate.
	//
	// > This parameter is required only when you configure an HTTPS listener.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s UpdateListenerRequestCertificates) String() string {
	return tea.Prettify(s)
}

func (s UpdateListenerRequestCertificates) GoString() string {
	return s.String()
}

func (s *UpdateListenerRequestCertificates) SetId(v string) *UpdateListenerRequestCertificates {
	s.Id = &v
	return s
}

type UpdateListenerRequestPortRanges struct {
	// The first port of the listener port range that is used to receive and forward requests to endpoints.
	//
	// Valid values: **1** to **65499**. The **FromPort** value must be smaller than or equal to the **ToPort** value.
	//
	// The maximum number of ports that can be configured varies based on the routing type and protocol of the listener. For more information, see [Listener overview](~~153216~~).
	//
	// > You can configure only one listener port for an HTTP or HTTPS listener. In this case, the first port is the same as the last port.
	FromPort *int32 `json:"FromPort,omitempty" xml:"FromPort,omitempty"`
	// The last port of the listener port range that is used to receive and forward requests to endpoints.
	//
	// Valid values: **1** to **65499**. The **FromPort** value must be smaller than or equal to the **ToPort** value.
	//
	// The maximum number of ports that can be configured varies based on the routing type and protocol of the listener. For more information, see [Listener overview](~~153216~~).
	//
	// > You can configure only one listener port for an HTTP or HTTPS listener. In this case, the first port is the same as the last port.
	ToPort *int32 `json:"ToPort,omitempty" xml:"ToPort,omitempty"`
}

func (s UpdateListenerRequestPortRanges) String() string {
	return tea.Prettify(s)
}

func (s UpdateListenerRequestPortRanges) GoString() string {
	return s.String()
}

func (s *UpdateListenerRequestPortRanges) SetFromPort(v int32) *UpdateListenerRequestPortRanges {
	s.FromPort = &v
	return s
}

func (s *UpdateListenerRequestPortRanges) SetToPort(v int32) *UpdateListenerRequestPortRanges {
	s.ToPort = &v
	return s
}

type UpdateListenerRequestXForwardedForConfig struct {
	// Specifies whether to use the `GA-AP` header to retrieve information about acceleration regions. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForGaApEnabled *bool `json:"XForwardedForGaApEnabled,omitempty" xml:"XForwardedForGaApEnabled,omitempty"`
	// Specifies whether to use the `GA-ID` header to retrieve the ID of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForGaIdEnabled *bool `json:"XForwardedForGaIdEnabled,omitempty" xml:"XForwardedForGaIdEnabled,omitempty"`
	// Specifies whether to use the `GA-X-Forward-Port` header to retrieve the listener ports of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForPortEnabled *bool `json:"XForwardedForPortEnabled,omitempty" xml:"XForwardedForPortEnabled,omitempty"`
	// Specifies whether to use the `GA-X-Forward-Proto` header to retrieve the listener protocol of the GA instance. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XForwardedForProtoEnabled *bool `json:"XForwardedForProtoEnabled,omitempty" xml:"XForwardedForProtoEnabled,omitempty"`
	// Specifies whether to use the `X-Real-IP` header to retrieve client IP addresses. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// > This parameter is available only when you create an HTTPS or HTTP listener.
	XRealIpEnabled *bool `json:"XRealIpEnabled,omitempty" xml:"XRealIpEnabled,omitempty"`
}

func (s UpdateListenerRequestXForwardedForConfig) String() string {
	return tea.Prettify(s)
}

func (s UpdateListenerRequestXForwardedForConfig) GoString() string {
	return s.String()
}

func (s *UpdateListenerRequestXForwardedForConfig) SetXForwardedForGaApEnabled(v bool) *UpdateListenerRequestXForwardedForConfig {
	s.XForwardedForGaApEnabled = &v
	return s
}

func (s *UpdateListenerRequestXForwardedForConfig) SetXForwardedForGaIdEnabled(v bool) *UpdateListenerRequestXForwardedForConfig {
	s.XForwardedForGaIdEnabled = &v
	return s
}

func (s *UpdateListenerRequestXForwardedForConfig) SetXForwardedForPortEnabled(v bool) *UpdateListenerRequestXForwardedForConfig {
	s.XForwardedForPortEnabled = &v
	return s
}

func (s *UpdateListenerRequestXForwardedForConfig) SetXForwardedForProtoEnabled(v bool) *UpdateListenerRequestXForwardedForConfig {
	s.XForwardedForProtoEnabled = &v
	return s
}

func (s *UpdateListenerRequestXForwardedForConfig) SetXRealIpEnabled(v bool) *UpdateListenerRequestXForwardedForConfig {
	s.XRealIpEnabled = &v
	return s
}

type UpdateListenerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateListenerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateListenerResponseBody) SetRequestId(v string) *UpdateListenerResponseBody {
	s.RequestId = &v
	return s
}

type UpdateListenerResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateListenerResponse) GoString() string {
	return s.String()
}

func (s *UpdateListenerResponse) SetHeaders(v map[string]*string) *UpdateListenerResponse {
	s.Headers = v
	return s
}

func (s *UpdateListenerResponse) SetStatusCode(v int32) *UpdateListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateListenerResponse) SetBody(v *UpdateListenerResponseBody) *UpdateListenerResponse {
	s.Body = v
	return s
}

type UpdateServiceManagedControlRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region ID of the GA instance. Set the value to cn-hangzhou.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource whose control mode you want to change.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource whose control mode you want to change. Valid value:
	//
	// *   **Accelerator**: standard GA instance.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Specifies the control mode of the resource. Valid value:
	//
	// *   false: changes the control mode of the resource from managed mode to unmanaged mode.
	//
	// >  You can change the control mode only from managed mode to unmanaged mode.
	ServiceManaged *bool `json:"ServiceManaged,omitempty" xml:"ServiceManaged,omitempty"`
}

func (s UpdateServiceManagedControlRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceManagedControlRequest) GoString() string {
	return s.String()
}

func (s *UpdateServiceManagedControlRequest) SetClientToken(v string) *UpdateServiceManagedControlRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateServiceManagedControlRequest) SetRegionId(v string) *UpdateServiceManagedControlRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateServiceManagedControlRequest) SetResourceId(v string) *UpdateServiceManagedControlRequest {
	s.ResourceId = &v
	return s
}

func (s *UpdateServiceManagedControlRequest) SetResourceType(v string) *UpdateServiceManagedControlRequest {
	s.ResourceType = &v
	return s
}

func (s *UpdateServiceManagedControlRequest) SetServiceManaged(v bool) *UpdateServiceManagedControlRequest {
	s.ServiceManaged = &v
	return s
}

type UpdateServiceManagedControlResponseBody struct {
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateServiceManagedControlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceManagedControlResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateServiceManagedControlResponseBody) SetRequestId(v string) *UpdateServiceManagedControlResponseBody {
	s.RequestId = &v
	return s
}

type UpdateServiceManagedControlResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateServiceManagedControlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateServiceManagedControlResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateServiceManagedControlResponse) GoString() string {
	return s.String()
}

func (s *UpdateServiceManagedControlResponse) SetHeaders(v map[string]*string) *UpdateServiceManagedControlResponse {
	s.Headers = v
	return s
}

func (s *UpdateServiceManagedControlResponse) SetStatusCode(v int32) *UpdateServiceManagedControlResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateServiceManagedControlResponse) SetBody(v *UpdateServiceManagedControlResponseBody) *UpdateServiceManagedControlResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("ga"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **AddEntriesToAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](~~258292~~) or [ListAcls](~~258291~~) operation to query the status of the ACL to which you want to add IP entries.
 *     *   If the ACL is in the **configuring** state, it indicates that IP entries are added to the ACL. In this case, you can perform only query operations.
 *     *   If the ACL is in the **active** state, it indicates that IP entries are added to the ACL.
 * *   The **AddEntriesToAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request AddEntriesToAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddEntriesToAclResponse
 */
func (client *Client) AddEntriesToAclWithOptions(request *AddEntriesToAclRequest, runtime *util.RuntimeOptions) (_result *AddEntriesToAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntries)) {
		query["AclEntries"] = request.AclEntries
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddEntriesToAcl"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddEntriesToAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **AddEntriesToAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](~~258292~~) or [ListAcls](~~258291~~) operation to query the status of the ACL to which you want to add IP entries.
 *     *   If the ACL is in the **configuring** state, it indicates that IP entries are added to the ACL. In this case, you can perform only query operations.
 *     *   If the ACL is in the **active** state, it indicates that IP entries are added to the ACL.
 * *   The **AddEntriesToAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request AddEntriesToAclRequest
 * @return AddEntriesToAclResponse
 */
func (client *Client) AddEntriesToAcl(request *AddEntriesToAclRequest) (_result *AddEntriesToAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddEntriesToAclResponse{}
	_body, _err := client.AddEntriesToAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * *   **AssociateAclsWithListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](~~153254~~) operation to query the state of the listener with which you attempt to associate an ACL.
 *     *   If the listener is in the **updating** state, it indicates that the ACL is being associated. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that the ACL is associated.
 * *   The **AssociateAclsWithListener** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request AssociateAclsWithListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateAclsWithListenerResponse
 */
func (client *Client) AssociateAclsWithListenerWithOptions(request *AssociateAclsWithListenerRequest, runtime *util.RuntimeOptions) (_result *AssociateAclsWithListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclIds)) {
		query["AclIds"] = request.AclIds
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateAclsWithListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateAclsWithListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * *   **AssociateAclsWithListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](~~153254~~) operation to query the state of the listener with which you attempt to associate an ACL.
 *     *   If the listener is in the **updating** state, it indicates that the ACL is being associated. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that the ACL is associated.
 * *   The **AssociateAclsWithListener** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request AssociateAclsWithListenerRequest
 * @return AssociateAclsWithListenerResponse
 */
func (client *Client) AssociateAclsWithListener(request *AssociateAclsWithListenerRequest) (_result *AssociateAclsWithListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateAclsWithListenerResponse{}
	_body, _err := client.AssociateAclsWithListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Only HTTPS listeners can be associated with additional certificates.
 * *   **AssociateAdditionalCertificatesWithListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the status of the listener with which you want to associate an additional certificate.
 *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being associated. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that the additional certificate is associated.
 * *   The **AssociateAdditionalCertificatesWithListener** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request AssociateAdditionalCertificatesWithListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateAdditionalCertificatesWithListenerResponse
 */
func (client *Client) AssociateAdditionalCertificatesWithListenerWithOptions(request *AssociateAdditionalCertificatesWithListenerRequest, runtime *util.RuntimeOptions) (_result *AssociateAdditionalCertificatesWithListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.Certificates)) {
		query["Certificates"] = request.Certificates
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateAdditionalCertificatesWithListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateAdditionalCertificatesWithListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Only HTTPS listeners can be associated with additional certificates.
 * *   **AssociateAdditionalCertificatesWithListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the status of the listener with which you want to associate an additional certificate.
 *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being associated. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that the additional certificate is associated.
 * *   The **AssociateAdditionalCertificatesWithListener** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request AssociateAdditionalCertificatesWithListenerRequest
 * @return AssociateAdditionalCertificatesWithListenerResponse
 */
func (client *Client) AssociateAdditionalCertificatesWithListener(request *AssociateAdditionalCertificatesWithListenerRequest) (_result *AssociateAdditionalCertificatesWithListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateAdditionalCertificatesWithListenerResponse{}
	_body, _err := client.AssociateAdditionalCertificatesWithListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   **AttachDdosToAccelerator** is an asynchronous operation. After you call the operation, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) or [ListAccelerators](~~153236~~) operation to query the status of the GA instance.
 *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro/Premium instance is being associated with the GA instance. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro/Premium instance is associated with the GA instance.
 * *   You cannot repeatedly call the **AttachDdosToAccelerator** operation for the same GA instance within a specific period of time.
 *
 * @param request AttachDdosToAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachDdosToAcceleratorResponse
 */
func (client *Client) AttachDdosToAcceleratorWithOptions(request *AttachDdosToAcceleratorRequest, runtime *util.RuntimeOptions) (_result *AttachDdosToAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.DdosId)) {
		query["DdosId"] = request.DdosId
	}

	if !tea.BoolValue(util.IsUnset(request.DdosRegionId)) {
		query["DdosRegionId"] = request.DdosRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachDdosToAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachDdosToAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   **AttachDdosToAccelerator** is an asynchronous operation. After you call the operation, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) or [ListAccelerators](~~153236~~) operation to query the status of the GA instance.
 *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro/Premium instance is being associated with the GA instance. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro/Premium instance is associated with the GA instance.
 * *   You cannot repeatedly call the **AttachDdosToAccelerator** operation for the same GA instance within a specific period of time.
 *
 * @param request AttachDdosToAcceleratorRequest
 * @return AttachDdosToAcceleratorResponse
 */
func (client *Client) AttachDdosToAccelerator(request *AttachDdosToAcceleratorRequest) (_result *AttachDdosToAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachDdosToAcceleratorResponse{}
	_body, _err := client.AttachDdosToAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **AttachLogStoreToEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, it indicates that a Logstore is being associated with the group. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that a Logstore is associated with the group.
 * *   The **AttachLogStoreToEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request AttachLogStoreToEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachLogStoreToEndpointGroupResponse
 */
func (client *Client) AttachLogStoreToEndpointGroupWithOptions(request *AttachLogStoreToEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *AttachLogStoreToEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupIds)) {
		query["EndpointGroupIds"] = request.EndpointGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SlsLogStoreName)) {
		query["SlsLogStoreName"] = request.SlsLogStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.SlsProjectName)) {
		query["SlsProjectName"] = request.SlsProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.SlsRegionId)) {
		query["SlsRegionId"] = request.SlsRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachLogStoreToEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachLogStoreToEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **AttachLogStoreToEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, it indicates that a Logstore is being associated with the group. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that a Logstore is associated with the group.
 * *   The **AttachLogStoreToEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request AttachLogStoreToEndpointGroupRequest
 * @return AttachLogStoreToEndpointGroupResponse
 */
func (client *Client) AttachLogStoreToEndpointGroup(request *AttachLogStoreToEndpointGroupRequest) (_result *AttachLogStoreToEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachLogStoreToEndpointGroupResponse{}
	_body, _err := client.AttachLogStoreToEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **BandwidthPackageAddAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the bandwidth plan that you want to associate.
 *     *   If the bandwidth plan is in the **binding** state, it indicates that the bandwidth plan is being associated. In this case, you can perform only query operations.
 *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is associated.
 * *   The **BandwidthPackageAddAccelerator** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request BandwidthPackageAddAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BandwidthPackageAddAcceleratorResponse
 */
func (client *Client) BandwidthPackageAddAcceleratorWithOptions(request *BandwidthPackageAddAcceleratorRequest, runtime *util.RuntimeOptions) (_result *BandwidthPackageAddAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BandwidthPackageAddAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BandwidthPackageAddAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **BandwidthPackageAddAccelerator** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the bandwidth plan that you want to associate.
 *     *   If the bandwidth plan is in the **binding** state, it indicates that the bandwidth plan is being associated. In this case, you can perform only query operations.
 *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is associated.
 * *   The **BandwidthPackageAddAccelerator** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request BandwidthPackageAddAcceleratorRequest
 * @return BandwidthPackageAddAcceleratorResponse
 */
func (client *Client) BandwidthPackageAddAccelerator(request *BandwidthPackageAddAcceleratorRequest) (_result *BandwidthPackageAddAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BandwidthPackageAddAcceleratorResponse{}
	_body, _err := client.BandwidthPackageAddAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **BandwidthPackageRemoveAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the bandwidth plan that you attempt to disassociate.
 *     *   If the bandwidth plan is in the **unbinding** state, it indicates that the bandwidth plan is being disassociated. In this case, you can perform only query operations.
 *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is disassociated.
 * *   The **BandwidthPackageRemoveAccelerator** cannot be called repeatedly for the same GA instance.
 *
 * @param request BandwidthPackageRemoveAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BandwidthPackageRemoveAcceleratorResponse
 */
func (client *Client) BandwidthPackageRemoveAcceleratorWithOptions(request *BandwidthPackageRemoveAcceleratorRequest, runtime *util.RuntimeOptions) (_result *BandwidthPackageRemoveAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BandwidthPackageRemoveAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BandwidthPackageRemoveAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **BandwidthPackageRemoveAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the bandwidth plan that you attempt to disassociate.
 *     *   If the bandwidth plan is in the **unbinding** state, it indicates that the bandwidth plan is being disassociated. In this case, you can perform only query operations.
 *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is disassociated.
 * *   The **BandwidthPackageRemoveAccelerator** cannot be called repeatedly for the same GA instance.
 *
 * @param request BandwidthPackageRemoveAcceleratorRequest
 * @return BandwidthPackageRemoveAcceleratorResponse
 */
func (client *Client) BandwidthPackageRemoveAccelerator(request *BandwidthPackageRemoveAcceleratorRequest) (_result *BandwidthPackageRemoveAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BandwidthPackageRemoveAcceleratorResponse{}
	_body, _err := client.BandwidthPackageRemoveAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot call the **ChangeResourceGroup** operation again on the same GA instance before the previous operation is complete.
 *
 * @param request ChangeResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot call the **ChangeResourceGroup** operation again on the same GA instance before the previous operation is complete.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **ConfigEndpointProbe** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the status of the endpoint group to which an endpoint belongs and determine whether latency monitoring is configured for the endpoint.
 *     *   If the endpoint group is in the **updating** state, it indicates that latency monitoring is being configured for the endpoint. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that latency monitoring is configured for the endpoint.
 * *   The **ConfigEndpointProbe** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request ConfigEndpointProbeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigEndpointProbeResponse
 */
func (client *Client) ConfigEndpointProbeWithOptions(request *ConfigEndpointProbeRequest, runtime *util.RuntimeOptions) (_result *ConfigEndpointProbeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.Endpoint)) {
		query["Endpoint"] = request.Endpoint
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointType)) {
		query["EndpointType"] = request.EndpointType
	}

	if !tea.BoolValue(util.IsUnset(request.ProbePort)) {
		query["ProbePort"] = request.ProbePort
	}

	if !tea.BoolValue(util.IsUnset(request.ProbeProtocol)) {
		query["ProbeProtocol"] = request.ProbeProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigEndpointProbe"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigEndpointProbeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **ConfigEndpointProbe** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the status of the endpoint group to which an endpoint belongs and determine whether latency monitoring is configured for the endpoint.
 *     *   If the endpoint group is in the **updating** state, it indicates that latency monitoring is being configured for the endpoint. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that latency monitoring is configured for the endpoint.
 * *   The **ConfigEndpointProbe** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request ConfigEndpointProbeRequest
 * @return ConfigEndpointProbeResponse
 */
func (client *Client) ConfigEndpointProbe(request *ConfigEndpointProbeRequest) (_result *ConfigEndpointProbeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigEndpointProbeResponse{}
	_body, _err := client.ConfigEndpointProbeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * **CreateAccelerator** is an asynchronous operation. After you send a request, the system returns the ID of a GA instance, but the operation is still being performed in the system background. You can call the [DescribeAccelerator](~~153235~~) operation to query the state of a GA instance.
 * *   If the GA instance is in the **init** state, it indicates that the GA instance is being created. In this case, you can perform only query operations.
 * *   If the GA instance is in the **active** state, it indicates that the GA instance is created.
 *
 * @param request CreateAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAcceleratorResponse
 */
func (client *Client) CreateAcceleratorWithOptions(request *CreateAcceleratorRequest, runtime *util.RuntimeOptions) (_result *CreateAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenewDuration)) {
		query["AutoRenewDuration"] = request.AutoRenewDuration
	}

	if !tea.BoolValue(util.IsUnset(request.AutoUseCoupon)) {
		query["AutoUseCoupon"] = request.AutoUseCoupon
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthBillingType)) {
		query["BandwidthBillingType"] = request.BandwidthBillingType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetConfig)) {
		query["IpSetConfig"] = request.IpSetConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionOptionNo)) {
		query["PromotionOptionNo"] = request.PromotionOptionNo
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * **CreateAccelerator** is an asynchronous operation. After you send a request, the system returns the ID of a GA instance, but the operation is still being performed in the system background. You can call the [DescribeAccelerator](~~153235~~) operation to query the state of a GA instance.
 * *   If the GA instance is in the **init** state, it indicates that the GA instance is being created. In this case, you can perform only query operations.
 * *   If the GA instance is in the **active** state, it indicates that the GA instance is created.
 *
 * @param request CreateAcceleratorRequest
 * @return CreateAcceleratorResponse
 */
func (client *Client) CreateAccelerator(request *CreateAcceleratorRequest) (_result *CreateAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAcceleratorResponse{}
	_body, _err := client.CreateAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **CreateAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](~~258292~~) or [ListAcls](~~258291~~) operation to query the state of an ACL.
 * *   If the ACL is in the **init** state, the ACL is being created. In this case, you can only perform only query operations.
 * *   If the ACL is in the **active** state, the ACL is created.
 *
 * @param request CreateAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAclResponse
 */
func (client *Client) CreateAclWithOptions(request *CreateAclRequest, runtime *util.RuntimeOptions) (_result *CreateAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntries)) {
		query["AclEntries"] = request.AclEntries
	}

	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.AddressIPVersion)) {
		query["AddressIPVersion"] = request.AddressIPVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAcl"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **CreateAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](~~258292~~) or [ListAcls](~~258291~~) operation to query the state of an ACL.
 * *   If the ACL is in the **init** state, the ACL is being created. In this case, you can only perform only query operations.
 * *   If the ACL is in the **active** state, the ACL is created.
 *
 * @param request CreateAclRequest
 * @return CreateAclResponse
 */
func (client *Client) CreateAcl(request *CreateAclRequest) (_result *CreateAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAclResponse{}
	_body, _err := client.CreateAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the **CreateApplicationMonitor** operation to create an origin probing task. An origin probing task monitors the network quality between the client and origin server and checks the availability of the origin.
 * Before you call this operation, take note of the following items:
 * *   **CreateApplicationMonitor** is an asynchronous operation. After you send a request, the system returns the ID of an origin probing task, but the origin probing task is still being created in the system background. You can call the [DescribeApplicationMonitor](~~408463~~) or [ListApplicationMonitor](~~408462~~) operation to query the state of the origin probing task.
 *     *   If the origin probing task is in the **init** state, it indicates that the task is being created. In this case, you can only perform query operations.
 *     *   If the origin probing task is in the **active** state, it indicates that the task is created.
 * *   The **CreateApplicationMonitor** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request CreateApplicationMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateApplicationMonitorResponse
 */
func (client *Client) CreateApplicationMonitorWithOptions(request *CreateApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *CreateApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DetectEnable)) {
		query["DetectEnable"] = request.DetectEnable
	}

	if !tea.BoolValue(util.IsUnset(request.DetectThreshold)) {
		query["DetectThreshold"] = request.DetectThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.DetectTimes)) {
		query["DetectTimes"] = request.DetectTimes
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.OptionsJson)) {
		query["OptionsJson"] = request.OptionsJson
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SilenceTime)) {
		query["SilenceTime"] = request.SilenceTime
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the **CreateApplicationMonitor** operation to create an origin probing task. An origin probing task monitors the network quality between the client and origin server and checks the availability of the origin.
 * Before you call this operation, take note of the following items:
 * *   **CreateApplicationMonitor** is an asynchronous operation. After you send a request, the system returns the ID of an origin probing task, but the origin probing task is still being created in the system background. You can call the [DescribeApplicationMonitor](~~408463~~) or [ListApplicationMonitor](~~408462~~) operation to query the state of the origin probing task.
 *     *   If the origin probing task is in the **init** state, it indicates that the task is being created. In this case, you can only perform query operations.
 *     *   If the origin probing task is in the **active** state, it indicates that the task is created.
 * *   The **CreateApplicationMonitor** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request CreateApplicationMonitorRequest
 * @return CreateApplicationMonitorResponse
 */
func (client *Client) CreateApplicationMonitor(request *CreateApplicationMonitorRequest) (_result *CreateApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateApplicationMonitorResponse{}
	_body, _err := client.CreateApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To use Global Accelerator (GA) for acceleration, you must purchase a basic bandwidth plan. A basic bandwidth plan supports the following bandwidth types:
 * *   **Basic**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service is deployed on Alibaba Cloud.
 * *   **Enhanced**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud.
 * *   **Premium**: Both the default acceleration region and the default service region are outside the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud. If you want to accelerate data transfer for clients in the Chinese mainland, you must select China (Hong Kong) as the acceleration region.
 * When you call this operation, take note of the following items:
 * *   **CreateBandwidthPackage** is an asynchronous operation. After you send a request, the system returns the ID of a bandwidth plan, but the bandwidth plan is still being created in the system background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the bandwidth plan.
 *     *   If the bandwidth plan is in the **init** state, it indicates that the bandwidth plan is being created. In this case, you can perform only query operations.
 *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is created.
 * *   The **CreateBandwidthPackage** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request CreateBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBandwidthPackageResponse
 */
func (client *Client) CreateBandwidthPackageWithOptions(request *CreateBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *CreateBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenewDuration)) {
		query["AutoRenewDuration"] = request.AutoRenewDuration
	}

	if !tea.BoolValue(util.IsUnset(request.AutoUseCoupon)) {
		query["AutoUseCoupon"] = request.AutoUseCoupon
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthType)) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !tea.BoolValue(util.IsUnset(request.BillingType)) {
		query["BillingType"] = request.BillingType
	}

	if !tea.BoolValue(util.IsUnset(request.CbnGeographicRegionIdA)) {
		query["CbnGeographicRegionIdA"] = request.CbnGeographicRegionIdA
	}

	if !tea.BoolValue(util.IsUnset(request.CbnGeographicRegionIdB)) {
		query["CbnGeographicRegionIdB"] = request.CbnGeographicRegionIdB
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionOptionNo)) {
		query["PromotionOptionNo"] = request.PromotionOptionNo
	}

	if !tea.BoolValue(util.IsUnset(request.Ratio)) {
		query["Ratio"] = request.Ratio
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBandwidthPackage"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To use Global Accelerator (GA) for acceleration, you must purchase a basic bandwidth plan. A basic bandwidth plan supports the following bandwidth types:
 * *   **Basic**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service is deployed on Alibaba Cloud.
 * *   **Enhanced**: Both the default acceleration region and the default service region are in the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud.
 * *   **Premium**: Both the default acceleration region and the default service region are outside the Chinese mainland. The accelerated service can be deployed on and off Alibaba Cloud. If you want to accelerate data transfer for clients in the Chinese mainland, you must select China (Hong Kong) as the acceleration region.
 * When you call this operation, take note of the following items:
 * *   **CreateBandwidthPackage** is an asynchronous operation. After you send a request, the system returns the ID of a bandwidth plan, but the bandwidth plan is still being created in the system background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the bandwidth plan.
 *     *   If the bandwidth plan is in the **init** state, it indicates that the bandwidth plan is being created. In this case, you can perform only query operations.
 *     *   If the bandwidth plan is in the **active** state, it indicates that the bandwidth plan is created.
 * *   The **CreateBandwidthPackage** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request CreateBandwidthPackageRequest
 * @return CreateBandwidthPackageResponse
 */
func (client *Client) CreateBandwidthPackage(request *CreateBandwidthPackageRequest) (_result *CreateBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBandwidthPackageResponse{}
	_body, _err := client.CreateBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateBasicAccelerateIp** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicAccelerateIp](~~466794~~) operation to query the status of an accelerated IP address:
 *     *   If no status information is returned, the accelerated IP address is being created. In this case, you can perform only query operations.
 *     *   If the accelerated IP address is in the **active** state, the accelerated IP address is created.
 * *   The **CreateBasicAccelerateIp** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request CreateBasicAccelerateIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicAccelerateIpResponse
 */
func (client *Client) CreateBasicAccelerateIpWithOptions(request *CreateBasicAccelerateIpRequest, runtime *util.RuntimeOptions) (_result *CreateBasicAccelerateIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicAccelerateIp"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicAccelerateIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateBasicAccelerateIp** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicAccelerateIp](~~466794~~) operation to query the status of an accelerated IP address:
 *     *   If no status information is returned, the accelerated IP address is being created. In this case, you can perform only query operations.
 *     *   If the accelerated IP address is in the **active** state, the accelerated IP address is created.
 * *   The **CreateBasicAccelerateIp** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request CreateBasicAccelerateIpRequest
 * @return CreateBasicAccelerateIpResponse
 */
func (client *Client) CreateBasicAccelerateIp(request *CreateBasicAccelerateIpRequest) (_result *CreateBasicAccelerateIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicAccelerateIpResponse{}
	_body, _err := client.CreateBasicAccelerateIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](~~466794~~) or [ListBasicEndpoints](~~466831~~) API operation to query the status of an accelerated IP address or an endpoint to determine the association status between the accelerated IP address and endpoint.
 *     *   If the status of the accelerated IP address and endpoint is **binding**, the accelerated IP address is being associated with the endpoint. In this case, you can query the accelerated IP address and endpoint but cannot perform other operations.
 *     *   If the status of the accelerated IP address and endpoint is **bound** and the status returned by the [ListBasicAccelerateIpEndpointRelations](~~466803~~) API operation is **active**, the accelerated IP address is associated with the endpoint.
 * *   The **CreateBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request CreateBasicAccelerateIpEndpointRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicAccelerateIpEndpointRelationResponse
 */
func (client *Client) CreateBasicAccelerateIpEndpointRelationWithOptions(request *CreateBasicAccelerateIpEndpointRelationRequest, runtime *util.RuntimeOptions) (_result *CreateBasicAccelerateIpEndpointRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpId)) {
		query["AccelerateIpId"] = request.AccelerateIpId
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicAccelerateIpEndpointRelation"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicAccelerateIpEndpointRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](~~466794~~) or [ListBasicEndpoints](~~466831~~) API operation to query the status of an accelerated IP address or an endpoint to determine the association status between the accelerated IP address and endpoint.
 *     *   If the status of the accelerated IP address and endpoint is **binding**, the accelerated IP address is being associated with the endpoint. In this case, you can query the accelerated IP address and endpoint but cannot perform other operations.
 *     *   If the status of the accelerated IP address and endpoint is **bound** and the status returned by the [ListBasicAccelerateIpEndpointRelations](~~466803~~) API operation is **active**, the accelerated IP address is associated with the endpoint.
 * *   The **CreateBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request CreateBasicAccelerateIpEndpointRelationRequest
 * @return CreateBasicAccelerateIpEndpointRelationResponse
 */
func (client *Client) CreateBasicAccelerateIpEndpointRelation(request *CreateBasicAccelerateIpEndpointRelationRequest) (_result *CreateBasicAccelerateIpEndpointRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicAccelerateIpEndpointRelationResponse{}
	_body, _err := client.CreateBasicAccelerateIpEndpointRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **CreateBasicAccelerateIpEndpointRelations** is asynchronous. After you send a request, the system returns a request ID and runs the task in the system background. You can call the [GetBasicAccelerateIp](~~466794~~) or [ListBasicEndpoints](~~466831~~) API operation to query the status of an accelerated IP address or an endpoint to determine the association status.
 *     *   If an accelerated IP address and the endpoint are in the **binding** state, the accelerated IP address is being associated with the endpoint. In this case, you can only query the accelerated IP address and endpoint, but cannot perform other operations.
 *     *   If all the accelerated IP addresses and the endpoint are in the **bound** state, and the association status returned by the [ListBasicAccelerateIpEndpointRelations](~~466803~~) API operation is **active**, the accelerated IP addresses are associated with the endpoints.
 * *   The **CreateBasicAccelerateIpEndpointRelations** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request CreateBasicAccelerateIpEndpointRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicAccelerateIpEndpointRelationsResponse
 */
func (client *Client) CreateBasicAccelerateIpEndpointRelationsWithOptions(request *CreateBasicAccelerateIpEndpointRelationsRequest, runtime *util.RuntimeOptions) (_result *CreateBasicAccelerateIpEndpointRelationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpEndpointRelations)) {
		query["AccelerateIpEndpointRelations"] = request.AccelerateIpEndpointRelations
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicAccelerateIpEndpointRelations"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicAccelerateIpEndpointRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **CreateBasicAccelerateIpEndpointRelations** is asynchronous. After you send a request, the system returns a request ID and runs the task in the system background. You can call the [GetBasicAccelerateIp](~~466794~~) or [ListBasicEndpoints](~~466831~~) API operation to query the status of an accelerated IP address or an endpoint to determine the association status.
 *     *   If an accelerated IP address and the endpoint are in the **binding** state, the accelerated IP address is being associated with the endpoint. In this case, you can only query the accelerated IP address and endpoint, but cannot perform other operations.
 *     *   If all the accelerated IP addresses and the endpoint are in the **bound** state, and the association status returned by the [ListBasicAccelerateIpEndpointRelations](~~466803~~) API operation is **active**, the accelerated IP addresses are associated with the endpoints.
 * *   The **CreateBasicAccelerateIpEndpointRelations** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request CreateBasicAccelerateIpEndpointRelationsRequest
 * @return CreateBasicAccelerateIpEndpointRelationsResponse
 */
func (client *Client) CreateBasicAccelerateIpEndpointRelations(request *CreateBasicAccelerateIpEndpointRelationsRequest) (_result *CreateBasicAccelerateIpEndpointRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicAccelerateIpEndpointRelationsResponse{}
	_body, _err := client.CreateBasicAccelerateIpEndpointRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Basic GA instances leverage the immense bandwidth of Alibaba Cloud\\"s high-quality global network to provide end-to-end acceleration services. You can use basic GA instances to accelerate content delivery at Layer 3 (IP). For more information, see [Overview of GA instances](~~153127~~).
 * **CreateBasicAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerator](~~353188~~) or [ListBasicAccelerators](~~353189~~) operation to query the status of a basic GA instance:
 * *   If the basic GA instance is in the **init** state, it indicates that the basic GA instance is being created. In this case, you can continue to perform query operations on the GA instance.
 * *   If the basic GA instance is in the **active** state, it indicates that the basic GA instance is created.
 *
 * @param request CreateBasicAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicAcceleratorResponse
 */
func (client *Client) CreateBasicAcceleratorWithOptions(request *CreateBasicAcceleratorRequest, runtime *util.RuntimeOptions) (_result *CreateBasicAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenewDuration)) {
		query["AutoRenewDuration"] = request.AutoRenewDuration
	}

	if !tea.BoolValue(util.IsUnset(request.AutoUseCoupon)) {
		query["AutoUseCoupon"] = request.AutoUseCoupon
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthBillingType)) {
		query["BandwidthBillingType"] = request.BandwidthBillingType
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionOptionNo)) {
		query["PromotionOptionNo"] = request.PromotionOptionNo
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Basic GA instances leverage the immense bandwidth of Alibaba Cloud\\"s high-quality global network to provide end-to-end acceleration services. You can use basic GA instances to accelerate content delivery at Layer 3 (IP). For more information, see [Overview of GA instances](~~153127~~).
 * **CreateBasicAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerator](~~353188~~) or [ListBasicAccelerators](~~353189~~) operation to query the status of a basic GA instance:
 * *   If the basic GA instance is in the **init** state, it indicates that the basic GA instance is being created. In this case, you can continue to perform query operations on the GA instance.
 * *   If the basic GA instance is in the **active** state, it indicates that the basic GA instance is created.
 *
 * @param request CreateBasicAcceleratorRequest
 * @return CreateBasicAcceleratorResponse
 */
func (client *Client) CreateBasicAccelerator(request *CreateBasicAcceleratorRequest) (_result *CreateBasicAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicAcceleratorResponse{}
	_body, _err := client.CreateBasicAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](~~466831~~) API operation to query the status of an endpoint.
 *     *   If the endpoint is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
 *     *   If the endpoint is in the **active** state, the endpoint is created.
 * *   The **CreateBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
 *
 * @param request CreateBasicEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicEndpointResponse
 */
func (client *Client) CreateBasicEndpointWithOptions(request *CreateBasicEndpointRequest, runtime *util.RuntimeOptions) (_result *CreateBasicEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointAddress)) {
		query["EndpointAddress"] = request.EndpointAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointSubAddress)) {
		query["EndpointSubAddress"] = request.EndpointSubAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointSubAddressType)) {
		query["EndpointSubAddressType"] = request.EndpointSubAddressType
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointType)) {
		query["EndpointType"] = request.EndpointType
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointZoneId)) {
		query["EndpointZoneId"] = request.EndpointZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicEndpoint"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](~~466831~~) API operation to query the status of an endpoint.
 *     *   If the endpoint is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
 *     *   If the endpoint is in the **active** state, the endpoint is created.
 * *   The **CreateBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a specific period of time.
 *
 * @param request CreateBasicEndpointRequest
 * @return CreateBasicEndpointResponse
 */
func (client *Client) CreateBasicEndpoint(request *CreateBasicEndpointRequest) (_result *CreateBasicEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicEndpointResponse{}
	_body, _err := client.CreateBasicEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns an endpoint group ID and runs the task in the background. You can call the [GetBasicEndpointGroup](~~362984~~) operation to query the status of the task.
 *     *   If the endpoint group is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, the endpoint group is created.
 * *   You cannot call the **CreateBasicEndpointGroup** operation again on the same GA instance before the previous request is completed.
 *
 * @param request CreateBasicEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicEndpointGroupResponse
 */
func (client *Client) CreateBasicEndpointGroupWithOptions(request *CreateBasicEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *CreateBasicEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointAddress)) {
		query["EndpointAddress"] = request.EndpointAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupRegion)) {
		query["EndpointGroupRegion"] = request.EndpointGroupRegion
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointSubAddress)) {
		query["EndpointSubAddress"] = request.EndpointSubAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointType)) {
		query["EndpointType"] = request.EndpointType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateBasicEndpointGroup** is an asynchronous operation. After a request is sent, the system returns an endpoint group ID and runs the task in the background. You can call the [GetBasicEndpointGroup](~~362984~~) operation to query the status of the task.
 *     *   If the endpoint group is in the **init** state, the endpoint is being created. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, the endpoint group is created.
 * *   You cannot call the **CreateBasicEndpointGroup** operation again on the same GA instance before the previous request is completed.
 *
 * @param request CreateBasicEndpointGroupRequest
 * @return CreateBasicEndpointGroupResponse
 */
func (client *Client) CreateBasicEndpointGroup(request *CreateBasicEndpointGroupRequest) (_result *CreateBasicEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicEndpointGroupResponse{}
	_body, _err := client.CreateBasicEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateBasicEndpoints** is an asynchronous operation. After you call this operation, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](~~466831~~) operation to query the status of endpoints. - If one or more endpoints are in the **init** state, it indicates that the endpoints are being created. In this case, you can continue to perform query operations on the endpoints. If all endpoints are in the **active** state, it indicates that the endpoints are created.
 * *   You cannot call the **CreateBasicEndpoints** operation again on the same GA instance before the previous operation is complete.
 *
 * @param request CreateBasicEndpointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicEndpointsResponse
 */
func (client *Client) CreateBasicEndpointsWithOptions(request *CreateBasicEndpointsRequest, runtime *util.RuntimeOptions) (_result *CreateBasicEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Endpoints)) {
		query["Endpoints"] = request.Endpoints
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicEndpoints"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateBasicEndpoints** is an asynchronous operation. After you call this operation, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](~~466831~~) operation to query the status of endpoints. - If one or more endpoints are in the **init** state, it indicates that the endpoints are being created. In this case, you can continue to perform query operations on the endpoints. If all endpoints are in the **active** state, it indicates that the endpoints are created.
 * *   You cannot call the **CreateBasicEndpoints** operation again on the same GA instance before the previous operation is complete.
 *
 * @param request CreateBasicEndpointsRequest
 * @return CreateBasicEndpointsResponse
 */
func (client *Client) CreateBasicEndpoints(request *CreateBasicEndpointsRequest) (_result *CreateBasicEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicEndpointsResponse{}
	_body, _err := client.CreateBasicEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Take note of the following limits:
 * *   You can specify only one acceleration region for each basic GA instance, and only IPv4 clients can connect to basic GA instances.
 * *   **CreateBasicIpSet** is an asynchronous operation. After you send a request, the system returns an acceleration region ID and runs the task in the background. You can call the [GetBasicIpSet](~~362987~~) operation to query the status of the task.
 *     *   If the acceleration region is in the **init** state, the acceleration region is being created. In this case, you can perform only query operations.
 *     *   If the acceleration region is in the **active** state, the acceleration region is created.
 * *   You cannot call the **CreateBasicIpSet** operation again on the same GA instance before the previous task is completed.
 *
 * @param request CreateBasicIpSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBasicIpSetResponse
 */
func (client *Client) CreateBasicIpSetWithOptions(request *CreateBasicIpSetRequest, runtime *util.RuntimeOptions) (_result *CreateBasicIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateRegionId)) {
		query["AccelerateRegionId"] = request.AccelerateRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IspType)) {
		query["IspType"] = request.IspType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBasicIpSet"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBasicIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Take note of the following limits:
 * *   You can specify only one acceleration region for each basic GA instance, and only IPv4 clients can connect to basic GA instances.
 * *   **CreateBasicIpSet** is an asynchronous operation. After you send a request, the system returns an acceleration region ID and runs the task in the background. You can call the [GetBasicIpSet](~~362987~~) operation to query the status of the task.
 *     *   If the acceleration region is in the **init** state, the acceleration region is being created. In this case, you can perform only query operations.
 *     *   If the acceleration region is in the **active** state, the acceleration region is created.
 * *   You cannot call the **CreateBasicIpSet** operation again on the same GA instance before the previous task is completed.
 *
 * @param request CreateBasicIpSetRequest
 * @return CreateBasicIpSetResponse
 */
func (client *Client) CreateBasicIpSet(request *CreateBasicIpSetRequest) (_result *CreateBasicIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBasicIpSetResponse{}
	_body, _err := client.CreateBasicIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * readAndWrite
 *
 * @param request CreateCustomRoutingEndpointGroupDestinationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomRoutingEndpointGroupDestinationsResponse
 */
func (client *Client) CreateCustomRoutingEndpointGroupDestinationsWithOptions(request *CreateCustomRoutingEndpointGroupDestinationsRequest, runtime *util.RuntimeOptions) (_result *CreateCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationConfigurations)) {
		query["DestinationConfigurations"] = request.DestinationConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCustomRoutingEndpointGroupDestinations"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * readAndWrite
 *
 * @param request CreateCustomRoutingEndpointGroupDestinationsRequest
 * @return CreateCustomRoutingEndpointGroupDestinationsResponse
 */
func (client *Client) CreateCustomRoutingEndpointGroupDestinations(request *CreateCustomRoutingEndpointGroupDestinationsRequest) (_result *CreateCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.CreateCustomRoutingEndpointGroupDestinationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Global Accelerator (GA) forwards client requests to endpoints in an endpoint group based on the routing type of the listener that is associated with the endpoint group.
 * *   After you configure an intelligent routing listener for a GA instance, the GA instance selects a nearby and healthy endpoint group and forwards client requests to a healthy endpoint in the endpoint group.
 * *   After you configure a custom routing listener for a GA instance, the instance generates a port mapping table based on the listener port range, protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches), and forwards client requests to specified IP addresses and ports in the vSwitches.
 * You can call this operation to create endpoint groups for custom routing listeners. For information about how to create endpoint groups for intelligent routing listeners, see [CreateEndpointGroup](~~153259~~).
 * When you call this operation, take note of the following items:
 * *   **CreateCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) or [ListCustomRoutingEndpointGroups](~~449374~~) operation to query the status of the endpoint groups that are associated with custom routing listeners.
 *     *   If one or more endpoint groups are in the **init** state, it indicates that the endpoint groups are being created. In this case, you can perform only query operations.
 *     *   If all endpoint groups are in the **active** state, it indicates that the endpoint groups are created.
 * *   The **CreateCustomRoutingEndpointGroups** operation cannot be called repeatedly for the same GA instance within a specific period of time.
 * ### Prerequisites
 * Make sure that the following requirements are met before you call this operation:
 * *   A standard GA instance is created. For more information, see [CreateAccelerator](~~206786~~).
 * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](~~153239~~).
 * *   An application is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
 * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](~~153253~~).
 *
 * @param request CreateCustomRoutingEndpointGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomRoutingEndpointGroupsResponse
 */
func (client *Client) CreateCustomRoutingEndpointGroupsWithOptions(request *CreateCustomRoutingEndpointGroupsRequest, runtime *util.RuntimeOptions) (_result *CreateCustomRoutingEndpointGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupConfigurations)) {
		query["EndpointGroupConfigurations"] = request.EndpointGroupConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCustomRoutingEndpointGroups"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCustomRoutingEndpointGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Global Accelerator (GA) forwards client requests to endpoints in an endpoint group based on the routing type of the listener that is associated with the endpoint group.
 * *   After you configure an intelligent routing listener for a GA instance, the GA instance selects a nearby and healthy endpoint group and forwards client requests to a healthy endpoint in the endpoint group.
 * *   After you configure a custom routing listener for a GA instance, the instance generates a port mapping table based on the listener port range, protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches), and forwards client requests to specified IP addresses and ports in the vSwitches.
 * You can call this operation to create endpoint groups for custom routing listeners. For information about how to create endpoint groups for intelligent routing listeners, see [CreateEndpointGroup](~~153259~~).
 * When you call this operation, take note of the following items:
 * *   **CreateCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) or [ListCustomRoutingEndpointGroups](~~449374~~) operation to query the status of the endpoint groups that are associated with custom routing listeners.
 *     *   If one or more endpoint groups are in the **init** state, it indicates that the endpoint groups are being created. In this case, you can perform only query operations.
 *     *   If all endpoint groups are in the **active** state, it indicates that the endpoint groups are created.
 * *   The **CreateCustomRoutingEndpointGroups** operation cannot be called repeatedly for the same GA instance within a specific period of time.
 * ### Prerequisites
 * Make sure that the following requirements are met before you call this operation:
 * *   A standard GA instance is created. For more information, see [CreateAccelerator](~~206786~~).
 * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](~~153239~~).
 * *   An application is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
 * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](~~153253~~).
 *
 * @param request CreateCustomRoutingEndpointGroupsRequest
 * @return CreateCustomRoutingEndpointGroupsResponse
 */
func (client *Client) CreateCustomRoutingEndpointGroups(request *CreateCustomRoutingEndpointGroupsRequest) (_result *CreateCustomRoutingEndpointGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCustomRoutingEndpointGroupsResponse{}
	_body, _err := client.CreateCustomRoutingEndpointGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation takes effect only when the traffic access policy of an endpoint allows traffic to specified destinations. You can call the [DescribeCustomRoutingEndpoint](~~449386~~) operation to query the traffic access policy of an endpoint. The CreateCustomRoutingEndpointTrafficPolicies operation takes effect only when **TrafficToEndpointPolicy** of an endpoint is set to **AllowCustom**.
 * When you call this operation, take note of the following items:
 * *   **CreateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of an endpoint group to check whether traffic destinations are created for an endpoint in the endpoint group.
 *     *   If the endpoint group is in the **updating** state, traffic destinations are being created. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, traffic destinations are created.
 * *   You cannot repeatedly call the **CreateCustomRoutingEndpointTrafficPolicies** operation for the same Global Accelerator (GA) instance within a specific period of time.
 * ### Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   A standard GA instance is created. For more information, see [CreateAccelerator](~~206786~~).
 * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](~~153239~~).
 * *   An application is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
 * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](~~153253~~).
 * *   An endpoint group is created for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](~~449363~~).
 * *   An endpoint is created for the custom routing listener. For more information, see [CreateCustomRoutingEndpoints](~~449382~~).
 *
 * @param request CreateCustomRoutingEndpointTrafficPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomRoutingEndpointTrafficPoliciesResponse
 */
func (client *Client) CreateCustomRoutingEndpointTrafficPoliciesWithOptions(request *CreateCustomRoutingEndpointTrafficPoliciesRequest, runtime *util.RuntimeOptions) (_result *CreateCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyConfigurations)) {
		query["PolicyConfigurations"] = request.PolicyConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCustomRoutingEndpointTrafficPolicies"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation takes effect only when the traffic access policy of an endpoint allows traffic to specified destinations. You can call the [DescribeCustomRoutingEndpoint](~~449386~~) operation to query the traffic access policy of an endpoint. The CreateCustomRoutingEndpointTrafficPolicies operation takes effect only when **TrafficToEndpointPolicy** of an endpoint is set to **AllowCustom**.
 * When you call this operation, take note of the following items:
 * *   **CreateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of an endpoint group to check whether traffic destinations are created for an endpoint in the endpoint group.
 *     *   If the endpoint group is in the **updating** state, traffic destinations are being created. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, traffic destinations are created.
 * *   You cannot repeatedly call the **CreateCustomRoutingEndpointTrafficPolicies** operation for the same Global Accelerator (GA) instance within a specific period of time.
 * ### Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   A standard GA instance is created. For more information, see [CreateAccelerator](~~206786~~).
 * *   A bandwidth plan is associated with the standard GA instance. For more information, see [BandwidthPackageAddAccelerator](~~153239~~).
 * *   An application is deployed to receive requests that are forwarded from GA. You can specify only vSwitches as endpoints for custom routing listeners.
 * *   The permissions to use custom routing listeners are acquired and a custom routing listener is created for the GA instance. Custom routing listeners are in invitational preview. To use custom routing listeners, contact your account manager. For more information about how to create a custom routing listener, see [CreateListener](~~153253~~).
 * *   An endpoint group is created for the custom routing listener. For more information, see [CreateCustomRoutingEndpointGroups](~~449363~~).
 * *   An endpoint is created for the custom routing listener. For more information, see [CreateCustomRoutingEndpoints](~~449382~~).
 *
 * @param request CreateCustomRoutingEndpointTrafficPoliciesRequest
 * @return CreateCustomRoutingEndpointTrafficPoliciesResponse
 */
func (client *Client) CreateCustomRoutingEndpointTrafficPolicies(request *CreateCustomRoutingEndpointTrafficPoliciesRequest) (_result *CreateCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.CreateCustomRoutingEndpointTrafficPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * readAndWrite
 *
 * @param request CreateCustomRoutingEndpointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomRoutingEndpointsResponse
 */
func (client *Client) CreateCustomRoutingEndpointsWithOptions(request *CreateCustomRoutingEndpointsRequest, runtime *util.RuntimeOptions) (_result *CreateCustomRoutingEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointConfigurations)) {
		query["EndpointConfigurations"] = request.EndpointConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCustomRoutingEndpoints"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCustomRoutingEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * readAndWrite
 *
 * @param request CreateCustomRoutingEndpointsRequest
 * @return CreateCustomRoutingEndpointsResponse
 */
func (client *Client) CreateCustomRoutingEndpoints(request *CreateCustomRoutingEndpointsRequest) (_result *CreateCustomRoutingEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCustomRoutingEndpointsResponse{}
	_body, _err := client.CreateCustomRoutingEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you associate an accelerated domain name that has obtained an ICP number with a Global Accelerator (GA) instance, you do not need to complete filing for the accelerated domain name or its subdomains on Alibaba Cloud.
 * You can call this operation to add an accelerated domain name and associate the accelerated domain name with GA instances. When you call this operation, take note of the following items:
 * *   If your accelerated domain name is hosted in the Chinese mainland, you must obtain an ICP number for the domain name.
 * *   The same accelerated domain name cannot be repeatedly associated with the same GA instance.
 * *   You cannot repeatedly call the **CreateDomain** operation by using the same Alibaba Cloud account within a specific period of time.
 *
 * @param request CreateDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDomainResponse
 */
func (client *Client) CreateDomainWithOptions(request *CreateDomainRequest, runtime *util.RuntimeOptions) (_result *CreateDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorIds)) {
		query["AcceleratorIds"] = request.AcceleratorIds
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDomain"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you associate an accelerated domain name that has obtained an ICP number with a Global Accelerator (GA) instance, you do not need to complete filing for the accelerated domain name or its subdomains on Alibaba Cloud.
 * You can call this operation to add an accelerated domain name and associate the accelerated domain name with GA instances. When you call this operation, take note of the following items:
 * *   If your accelerated domain name is hosted in the Chinese mainland, you must obtain an ICP number for the domain name.
 * *   The same accelerated domain name cannot be repeatedly associated with the same GA instance.
 * *   You cannot repeatedly call the **CreateDomain** operation by using the same Alibaba Cloud account within a specific period of time.
 *
 * @param request CreateDomainRequest
 * @return CreateDomainResponse
 */
func (client *Client) CreateDomain(request *CreateDomainRequest) (_result *CreateDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDomainResponse{}
	_body, _err := client.CreateDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateEndpointGroup** is an asynchronous operation. After you send a request, the system returns the ID of an endpoint group, but the endpoint group is still being created in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of the endpoint group.
 *     *   If the endpoint group is in the **init** state, it indicates that the endpoint group is being created. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that the endpoint group is created.
 * *   The **CreateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request CreateEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEndpointGroupResponse
 */
func (client *Client) CreateEndpointGroupWithOptions(request *CreateEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *CreateEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointConfigurations)) {
		query["EndpointConfigurations"] = request.EndpointConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupRegion)) {
		query["EndpointGroupRegion"] = request.EndpointGroupRegion
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupType)) {
		query["EndpointGroupType"] = request.EndpointGroupType
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointRequestProtocol)) {
		query["EndpointRequestProtocol"] = request.EndpointRequestProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckEnabled)) {
		query["HealthCheckEnabled"] = request.HealthCheckEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckIntervalSeconds)) {
		query["HealthCheckIntervalSeconds"] = request.HealthCheckIntervalSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckPath)) {
		query["HealthCheckPath"] = request.HealthCheckPath
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckPort)) {
		query["HealthCheckPort"] = request.HealthCheckPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckProtocol)) {
		query["HealthCheckProtocol"] = request.HealthCheckProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PortOverrides)) {
		query["PortOverrides"] = request.PortOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.ThresholdCount)) {
		query["ThresholdCount"] = request.ThresholdCount
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficPercentage)) {
		query["TrafficPercentage"] = request.TrafficPercentage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateEndpointGroup** is an asynchronous operation. After you send a request, the system returns the ID of an endpoint group, but the endpoint group is still being created in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of the endpoint group.
 *     *   If the endpoint group is in the **init** state, it indicates that the endpoint group is being created. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that the endpoint group is created.
 * *   The **CreateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request CreateEndpointGroupRequest
 * @return CreateEndpointGroupResponse
 */
func (client *Client) CreateEndpointGroup(request *CreateEndpointGroupRequest) (_result *CreateEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEndpointGroupResponse{}
	_body, _err := client.CreateEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) or [ListEndpointGroups](~~153261~~) to query the state of an endpoint group.
 *     *   If an endpoint group is in the **init** state, the endpoint group is being created. In this case, you can perform only query operations.
 *     *   If all endpoint groups are in the **active**, endpoint groups are created.
 * *   The **CreateEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request CreateEndpointGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEndpointGroupsResponse
 */
func (client *Client) CreateEndpointGroupsWithOptions(request *CreateEndpointGroupsRequest, runtime *util.RuntimeOptions) (_result *CreateEndpointGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupConfigurations)) {
		query["EndpointGroupConfigurations"] = request.EndpointGroupConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEndpointGroups"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEndpointGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) or [ListEndpointGroups](~~153261~~) to query the state of an endpoint group.
 *     *   If an endpoint group is in the **init** state, the endpoint group is being created. In this case, you can perform only query operations.
 *     *   If all endpoint groups are in the **active**, endpoint groups are created.
 * *   The **CreateEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request CreateEndpointGroupsRequest
 * @return CreateEndpointGroupsResponse
 */
func (client *Client) CreateEndpointGroups(request *CreateEndpointGroupsRequest) (_result *CreateEndpointGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEndpointGroupsResponse{}
	_body, _err := client.CreateEndpointGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * HTTP and HTTPS listeners of Global Accelerator (GA) support domain name-based and path-based forwarding rules. After an HTTP or HTTPS listener receives a request, the system matches the request against the forwarding conditions in a forwarding rule and then performs the corresponding forwarding action. For example, if you set **Host** to `www.example.com` as the forwarding condition and **Forward** to `epg-bp1enpdcrqhl78g6r****` as the forwarding action in a forwarding rule, requests to the `www.example.com` domain name match this forwarding rule and are forwarded to the `epg-bp1enpdcrqhl78g6r****` endpoint group. Before you call this API operation to create a forwarding rule, we recommend that you understand forwarding rules. For more information, see [Forwarding rules](~~204224~~).
 * When you call this operation, take note of the following items:
 * *   **CreateForwardingRules** is an asynchronous operation. After you send a request, the system returns the ID of a forwarding rule, but the forwarding rule is still being created in the system background. You can call the [ListForwardingRules](~~205817~~) operation to query the state of the forwarding rule.
 *     *   If the forwarding rule is in the **configuring** state, it indicates that the rule is being created. In this case, you can only perform query operations.
 *     *   If the forwarding rule is in the **active** state, it indicates that the rule is created.
 * *   The **CreateForwardingRules** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request CreateForwardingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateForwardingRulesResponse
 */
func (client *Client) CreateForwardingRulesWithOptions(request *CreateForwardingRulesRequest, runtime *util.RuntimeOptions) (_result *CreateForwardingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardingRules)) {
		query["ForwardingRules"] = request.ForwardingRules
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateForwardingRules"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateForwardingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * HTTP and HTTPS listeners of Global Accelerator (GA) support domain name-based and path-based forwarding rules. After an HTTP or HTTPS listener receives a request, the system matches the request against the forwarding conditions in a forwarding rule and then performs the corresponding forwarding action. For example, if you set **Host** to `www.example.com` as the forwarding condition and **Forward** to `epg-bp1enpdcrqhl78g6r****` as the forwarding action in a forwarding rule, requests to the `www.example.com` domain name match this forwarding rule and are forwarded to the `epg-bp1enpdcrqhl78g6r****` endpoint group. Before you call this API operation to create a forwarding rule, we recommend that you understand forwarding rules. For more information, see [Forwarding rules](~~204224~~).
 * When you call this operation, take note of the following items:
 * *   **CreateForwardingRules** is an asynchronous operation. After you send a request, the system returns the ID of a forwarding rule, but the forwarding rule is still being created in the system background. You can call the [ListForwardingRules](~~205817~~) operation to query the state of the forwarding rule.
 *     *   If the forwarding rule is in the **configuring** state, it indicates that the rule is being created. In this case, you can only perform query operations.
 *     *   If the forwarding rule is in the **active** state, it indicates that the rule is created.
 * *   The **CreateForwardingRules** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request CreateForwardingRulesRequest
 * @return CreateForwardingRulesResponse
 */
func (client *Client) CreateForwardingRules(request *CreateForwardingRulesRequest) (_result *CreateForwardingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateForwardingRulesResponse{}
	_body, _err := client.CreateForwardingRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateIpSets** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of the task.
 *     *   If acceleration regions are in the **init** state, it indicates that the acceleration regions are being created. In this case, you can perform only query operations.
 *     *   If acceleration regions are in the **active** state, it indicates that the acceleration regions are created.
 * *   You cannot call the **CreateIpSets** operation again on the same GA instance before the previous operation is completed.
 *
 * @param request CreateIpSetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIpSetsResponse
 */
func (client *Client) CreateIpSetsWithOptions(request *CreateIpSetsRequest, runtime *util.RuntimeOptions) (_result *CreateIpSetsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateRegion)) {
		query["AccelerateRegion"] = request.AccelerateRegion
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIpSets"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIpSetsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateIpSets** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of the task.
 *     *   If acceleration regions are in the **init** state, it indicates that the acceleration regions are being created. In this case, you can perform only query operations.
 *     *   If acceleration regions are in the **active** state, it indicates that the acceleration regions are created.
 * *   You cannot call the **CreateIpSets** operation again on the same GA instance before the previous operation is completed.
 *
 * @param request CreateIpSetsRequest
 * @return CreateIpSetsResponse
 */
func (client *Client) CreateIpSets(request *CreateIpSetsRequest) (_result *CreateIpSetsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIpSetsResponse{}
	_body, _err := client.CreateIpSetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A listener listens for connection requests and then distributes the requests to endpoints based on the forwarding rules that are defined by a specified scheduling algorithm. You can call this operation to create a listener for a standard GA instance.
 * Before you call this operation, take note of the following limits:
 * *   **CreateListener** is an asynchronous operation. After you send a request, the system returns a listener ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the status of a listener:
 *     *   If a listener is in the **init** state, the listener is being created. In this case, you can perform only query operations.
 *     *   If a listener is in the **active** state, the listener is created.
 * *   The **CreateListener** operation cannot be repeatedly called to create listeners for the same GA instance in a specific period of time.
 *
 * @param request CreateListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateListenerResponse
 */
func (client *Client) CreateListenerWithOptions(request *CreateListenerRequest, runtime *util.RuntimeOptions) (_result *CreateListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.Certificates)) {
		query["Certificates"] = request.Certificates
	}

	if !tea.BoolValue(util.IsUnset(request.ClientAffinity)) {
		query["ClientAffinity"] = request.ClientAffinity
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CustomRoutingEndpointGroupConfigurations)) {
		query["CustomRoutingEndpointGroupConfigurations"] = request.CustomRoutingEndpointGroupConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupConfigurations)) {
		query["EndpointGroupConfigurations"] = request.EndpointGroupConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PortRanges)) {
		query["PortRanges"] = request.PortRanges
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyProtocol)) {
		query["ProxyProtocol"] = request.ProxyProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityPolicyId)) {
		query["SecurityPolicyId"] = request.SecurityPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedForConfig)) {
		query["XForwardedForConfig"] = request.XForwardedForConfig
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A listener listens for connection requests and then distributes the requests to endpoints based on the forwarding rules that are defined by a specified scheduling algorithm. You can call this operation to create a listener for a standard GA instance.
 * Before you call this operation, take note of the following limits:
 * *   **CreateListener** is an asynchronous operation. After you send a request, the system returns a listener ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the status of a listener:
 *     *   If a listener is in the **init** state, the listener is being created. In this case, you can perform only query operations.
 *     *   If a listener is in the **active** state, the listener is created.
 * *   The **CreateListener** operation cannot be repeatedly called to create listeners for the same GA instance in a specific period of time.
 *
 * @param request CreateListenerRequest
 * @return CreateListenerResponse
 */
func (client *Client) CreateListener(request *CreateListenerRequest) (_result *CreateListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateListenerResponse{}
	_body, _err := client.CreateListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **CreateSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that secondary IP addresses are being created for the CNAME that is assigned to the GA instance. In this case, you can only perform query operations.
 *     *   If the GA instance is in the **active** state, it indicates that secondary IP addresses are created for the CNAME that is assigned to the GA instance.
 * *   The **CreateSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request CreateSpareIpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSpareIpsResponse
 */
func (client *Client) CreateSpareIpsWithOptions(request *CreateSpareIpsRequest, runtime *util.RuntimeOptions) (_result *CreateSpareIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SpareIps)) {
		query["SpareIps"] = request.SpareIps
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSpareIps"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSpareIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **CreateSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that secondary IP addresses are being created for the CNAME that is assigned to the GA instance. In this case, you can only perform query operations.
 *     *   If the GA instance is in the **active** state, it indicates that secondary IP addresses are created for the CNAME that is assigned to the GA instance.
 * *   The **CreateSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request CreateSpareIpsRequest
 * @return CreateSpareIpsResponse
 */
func (client *Client) CreateSpareIps(request *CreateSpareIpsRequest) (_result *CreateSpareIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSpareIpsResponse{}
	_body, _err := client.CreateSpareIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Subscription GA instances cannot be deleted.
 * *   GA instances that have bandwidth plans associated cannot be deleted. To delete such GA instances, disassociate the bandwidth plans first. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](~~153240~~).
 * *   **DeleteAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can use the [DescribeAccelerator](~~153235~~) operation to query the state of a GA instance.
 *     *   If the GA instance is in the **deleting** state, the GA instance is being deleted. In this case, you can perform only query operations.
 *     *   If the GA instance cannot be queried, it indicates that the GA instance is deleted.
 *
 * @param request DeleteAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAcceleratorResponse
 */
func (client *Client) DeleteAcceleratorWithOptions(request *DeleteAcceleratorRequest, runtime *util.RuntimeOptions) (_result *DeleteAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Subscription GA instances cannot be deleted.
 * *   GA instances that have bandwidth plans associated cannot be deleted. To delete such GA instances, disassociate the bandwidth plans first. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](~~153240~~).
 * *   **DeleteAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can use the [DescribeAccelerator](~~153235~~) operation to query the state of a GA instance.
 *     *   If the GA instance is in the **deleting** state, the GA instance is being deleted. In this case, you can perform only query operations.
 *     *   If the GA instance cannot be queried, it indicates that the GA instance is deleted.
 *
 * @param request DeleteAcceleratorRequest
 * @return DeleteAcceleratorResponse
 */
func (client *Client) DeleteAccelerator(request *DeleteAcceleratorRequest) (_result *DeleteAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAcceleratorResponse{}
	_body, _err := client.DeleteAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](~~258292~~) operation to query the state of a network ACL.
 * *   If the network ACL is in the **deleting** state, it indicates that the network ACL is being deleted. In this case, you can perform only query operations.
 * *   If the network ACL cannot be queried, it indicates that the network ACL is deleted.
 *
 * @param request DeleteAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAclResponse
 */
func (client *Client) DeleteAclWithOptions(request *DeleteAclRequest, runtime *util.RuntimeOptions) (_result *DeleteAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAcl"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteAcl** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetAcl](~~258292~~) operation to query the state of a network ACL.
 * *   If the network ACL is in the **deleting** state, it indicates that the network ACL is being deleted. In this case, you can perform only query operations.
 * *   If the network ACL cannot be queried, it indicates that the network ACL is deleted.
 *
 * @param request DeleteAclRequest
 * @return DeleteAclResponse
 */
func (client *Client) DeleteAcl(request *DeleteAclRequest) (_result *DeleteAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAclResponse{}
	_body, _err := client.DeleteAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteApplicationMonitor** is an asynchronous operation. After you call this operation, the system returns a request ID, but the operation is still being performed in the system background. You can call the [ListApplicationMonitor](~~408462~~) operation to query the state of an origin probing task.
 *     *   If the origin probing task is in the **deleting** state, it indicates that the task is being deleted. In this case, you can perform only query operations.
 *     <!---->
 *     *   If the origin probing task cannot be queried, it indicates that the task is deleted.
 * *   The **DeleteApplicationMonitor** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteApplicationMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteApplicationMonitorResponse
 */
func (client *Client) DeleteApplicationMonitorWithOptions(request *DeleteApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *DeleteApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteApplicationMonitor** is an asynchronous operation. After you call this operation, the system returns a request ID, but the operation is still being performed in the system background. You can call the [ListApplicationMonitor](~~408462~~) operation to query the state of an origin probing task.
 *     *   If the origin probing task is in the **deleting** state, it indicates that the task is being deleted. In this case, you can perform only query operations.
 *     <!---->
 *     *   If the origin probing task cannot be queried, it indicates that the task is deleted.
 * *   The **DeleteApplicationMonitor** operation cannot be called repeatedly for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteApplicationMonitorRequest
 * @return DeleteApplicationMonitorResponse
 */
func (client *Client) DeleteApplicationMonitor(request *DeleteApplicationMonitorRequest) (_result *DeleteApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteApplicationMonitorResponse{}
	_body, _err := client.DeleteApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   By default, subscription bandwidth plans cannot be deleted. If you want to delete subscription bandwidth plans, contact your account manager.
 * *   Bandwidth plans that are associated with Global Accelerator (GA) instances cannot be deleted. Before you can delete a bandwidth plan that is associated with a GA instance, you must disassociate the bandwidth plan from the GA instance. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](~~153240~~).
 * *   **DeleteBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the task.
 *     *   If the bandwidth plan is in the **deleting** state, it indicates that the bandwidth plan is being deleted. In this case, you can perform only query operations.
 *     *   If the bandwidth plan cannot be found, it indicates that the bandwidth plan is deleted.
 * *   The **DeleteBandwidthPackage** operation cannot be called repeatedly for the same bandwidth plan within a specific period of time.
 *
 * @param request DeleteBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBandwidthPackageResponse
 */
func (client *Client) DeleteBandwidthPackageWithOptions(request *DeleteBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *DeleteBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBandwidthPackage"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   By default, subscription bandwidth plans cannot be deleted. If you want to delete subscription bandwidth plans, contact your account manager.
 * *   Bandwidth plans that are associated with Global Accelerator (GA) instances cannot be deleted. Before you can delete a bandwidth plan that is associated with a GA instance, you must disassociate the bandwidth plan from the GA instance. For information about how to disassociate a bandwidth plan from a GA instance, see [BandwidthPackageRemoveAccelerator](~~153240~~).
 * *   **DeleteBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the task.
 *     *   If the bandwidth plan is in the **deleting** state, it indicates that the bandwidth plan is being deleted. In this case, you can perform only query operations.
 *     *   If the bandwidth plan cannot be found, it indicates that the bandwidth plan is deleted.
 * *   The **DeleteBandwidthPackage** operation cannot be called repeatedly for the same bandwidth plan within a specific period of time.
 *
 * @param request DeleteBandwidthPackageRequest
 * @return DeleteBandwidthPackageResponse
 */
func (client *Client) DeleteBandwidthPackage(request *DeleteBandwidthPackageRequest) (_result *DeleteBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBandwidthPackageResponse{}
	_body, _err := client.DeleteBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteBasicAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](~~466794~~) API operation to query the status of an accelerated IP address:
 *     *   If the accelerated IP address is in the **deleting** state, the accelerated IP address is being deleted. In this case, you can perform only query operations.
 *     *   If the system fails to return information about the accelerated IP address, the accelerated IP address is deleted.
 * *   The **DeleteBasicAccelerateIp** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request DeleteBasicAccelerateIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBasicAccelerateIpResponse
 */
func (client *Client) DeleteBasicAccelerateIpWithOptions(request *DeleteBasicAccelerateIpRequest, runtime *util.RuntimeOptions) (_result *DeleteBasicAccelerateIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpId)) {
		query["AccelerateIpId"] = request.AccelerateIpId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBasicAccelerateIp"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBasicAccelerateIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteBasicAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicAccelerateIp](~~466794~~) API operation to query the status of an accelerated IP address:
 *     *   If the accelerated IP address is in the **deleting** state, the accelerated IP address is being deleted. In this case, you can perform only query operations.
 *     *   If the system fails to return information about the accelerated IP address, the accelerated IP address is deleted.
 * *   The **DeleteBasicAccelerateIp** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request DeleteBasicAccelerateIpRequest
 * @return DeleteBasicAccelerateIpResponse
 */
func (client *Client) DeleteBasicAccelerateIp(request *DeleteBasicAccelerateIpRequest) (_result *DeleteBasicAccelerateIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBasicAccelerateIpResponse{}
	_body, _err := client.DeleteBasicAccelerateIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the following operations to check whether an accelerated IP address is disassociated from an endpoint:
 *     *   You can call the [GetBasicAccelerateIp](~~466794~~) and [ListBasicEndpoints](~~466831~~) operations to query the status of an accelerated IP address and an endpoint. If the accelerated IP address and the endpoint are in the **unbinding** state, the accelerated IP address is being disassociated from the endpoint. In this case, you can query the IP address and endpoint but cannot perform other operations.
 *     *   If the association status between the accelerated IP address and the endpoint cannot be queried by calling the [ListBasicAccelerateIpEndpointRelations](~~466803~~) operation, the accelerated IP address is disassociated from the endpoint.
 * *   The **DeleteBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request DeleteBasicAccelerateIpEndpointRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBasicAccelerateIpEndpointRelationResponse
 */
func (client *Client) DeleteBasicAccelerateIpEndpointRelationWithOptions(request *DeleteBasicAccelerateIpEndpointRelationRequest, runtime *util.RuntimeOptions) (_result *DeleteBasicAccelerateIpEndpointRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpId)) {
		query["AccelerateIpId"] = request.AccelerateIpId
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBasicAccelerateIpEndpointRelation"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBasicAccelerateIpEndpointRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteBasicAccelerateIpEndpointRelation** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the following operations to check whether an accelerated IP address is disassociated from an endpoint:
 *     *   You can call the [GetBasicAccelerateIp](~~466794~~) and [ListBasicEndpoints](~~466831~~) operations to query the status of an accelerated IP address and an endpoint. If the accelerated IP address and the endpoint are in the **unbinding** state, the accelerated IP address is being disassociated from the endpoint. In this case, you can query the IP address and endpoint but cannot perform other operations.
 *     *   If the association status between the accelerated IP address and the endpoint cannot be queried by calling the [ListBasicAccelerateIpEndpointRelations](~~466803~~) operation, the accelerated IP address is disassociated from the endpoint.
 * *   The **DeleteBasicAccelerateIpEndpointRelation** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request DeleteBasicAccelerateIpEndpointRelationRequest
 * @return DeleteBasicAccelerateIpEndpointRelationResponse
 */
func (client *Client) DeleteBasicAccelerateIpEndpointRelation(request *DeleteBasicAccelerateIpEndpointRelationRequest) (_result *DeleteBasicAccelerateIpEndpointRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBasicAccelerateIpEndpointRelationResponse{}
	_body, _err := client.DeleteBasicAccelerateIpEndpointRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteBasicAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicAccelerator](~~353188~~) operation to query the state of a basic GA instance.
 * *   If the basic GA instance is in the **deleting** state, it indicates that the instance is being deleted. In this case, you can perform only query operations.
 * *   If the information of the basic GA instance is not displayed in the response, it indicates that the instance is deleted.
 *
 * @param request DeleteBasicAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBasicAcceleratorResponse
 */
func (client *Client) DeleteBasicAcceleratorWithOptions(request *DeleteBasicAcceleratorRequest, runtime *util.RuntimeOptions) (_result *DeleteBasicAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBasicAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBasicAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteBasicAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicAccelerator](~~353188~~) operation to query the state of a basic GA instance.
 * *   If the basic GA instance is in the **deleting** state, it indicates that the instance is being deleted. In this case, you can perform only query operations.
 * *   If the information of the basic GA instance is not displayed in the response, it indicates that the instance is deleted.
 *
 * @param request DeleteBasicAcceleratorRequest
 * @return DeleteBasicAcceleratorResponse
 */
func (client *Client) DeleteBasicAccelerator(request *DeleteBasicAcceleratorRequest) (_result *DeleteBasicAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBasicAcceleratorResponse{}
	_body, _err := client.DeleteBasicAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](~~466831~~) operation to query the status of endpoints.
 *     *   If the endpoint is in the **deleting** state, it indicates that the endpoint is being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint cannot be found, it indicates that the endpoint is deleted.
 * *   The **DeleteBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request DeleteBasicEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBasicEndpointResponse
 */
func (client *Client) DeleteBasicEndpointWithOptions(request *DeleteBasicEndpointRequest, runtime *util.RuntimeOptions) (_result *DeleteBasicEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBasicEndpoint"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBasicEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteBasicEndpoint** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [ListBasicEndpoints](~~466831~~) operation to query the status of endpoints.
 *     *   If the endpoint is in the **deleting** state, it indicates that the endpoint is being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint cannot be found, it indicates that the endpoint is deleted.
 * *   The **DeleteBasicEndpoint** API operation cannot be repeatedly called for the same basic GA instance within a period of time.
 *
 * @param request DeleteBasicEndpointRequest
 * @return DeleteBasicEndpointResponse
 */
func (client *Client) DeleteBasicEndpoint(request *DeleteBasicEndpointRequest) (_result *DeleteBasicEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBasicEndpointResponse{}
	_body, _err := client.DeleteBasicEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteBasicEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicEndpointGroup](~~362984~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **deleting** state, it indicates that the endpoint group is being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint group cannot be queried, it indicates that the endpoint group is deleted.
 * *   The **DeleteBasicEndpointGroup** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request DeleteBasicEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBasicEndpointGroupResponse
 */
func (client *Client) DeleteBasicEndpointGroupWithOptions(request *DeleteBasicEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteBasicEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBasicEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBasicEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteBasicEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [GetBasicEndpointGroup](~~362984~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **deleting** state, it indicates that the endpoint group is being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint group cannot be queried, it indicates that the endpoint group is deleted.
 * *   The **DeleteBasicEndpointGroup** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request DeleteBasicEndpointGroupRequest
 * @return DeleteBasicEndpointGroupResponse
 */
func (client *Client) DeleteBasicEndpointGroup(request *DeleteBasicEndpointGroupRequest) (_result *DeleteBasicEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBasicEndpointGroupResponse{}
	_body, _err := client.DeleteBasicEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   \\*\\*DeleteBasicIpSet\\*\\* is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicIpSet](~~362987~~) operation to query the status of an acceleration region:
 *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
 *     *   If the information of the acceleration region is not displayed in the response, it indicates that the acceleration region is deleted.
 * *   The \\*\\*DeleteBasicIpSet\\*\\* operation cannot be called repeatedly for the same basic GA instance within a specific period of time.
 *
 * @param request DeleteBasicIpSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteBasicIpSetResponse
 */
func (client *Client) DeleteBasicIpSetWithOptions(request *DeleteBasicIpSetRequest, runtime *util.RuntimeOptions) (_result *DeleteBasicIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBasicIpSet"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBasicIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   \\*\\*DeleteBasicIpSet\\*\\* is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetBasicIpSet](~~362987~~) operation to query the status of an acceleration region:
 *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
 *     *   If the information of the acceleration region is not displayed in the response, it indicates that the acceleration region is deleted.
 * *   The \\*\\*DeleteBasicIpSet\\*\\* operation cannot be called repeatedly for the same basic GA instance within a specific period of time.
 *
 * @param request DeleteBasicIpSetRequest
 * @return DeleteBasicIpSetResponse
 */
func (client *Client) DeleteBasicIpSet(request *DeleteBasicIpSetRequest) (_result *DeleteBasicIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBasicIpSetResponse{}
	_body, _err := client.DeleteBasicIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) to query the status of the task.
 *     *   If the endpoint group is in the **updating** state, it indicates that mappings are being deleted from the endpoint group. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state and no information about the mappings that you want to delete is found in the response when you call the [DescribeCustomRoutingEndpointGroupDestinations](~~449378~~) operation, it indicates the mappings are deleted from the endpoint group.
 * *   You cannot call the **DeleteCustomRoutingEndpointGroupDestinations** operation again on the same Global Accelerator (GA) instance before the previous request is completed.
 *
 * @param request DeleteCustomRoutingEndpointGroupDestinationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomRoutingEndpointGroupDestinationsResponse
 */
func (client *Client) DeleteCustomRoutingEndpointGroupDestinationsWithOptions(request *DeleteCustomRoutingEndpointGroupDestinationsRequest, runtime *util.RuntimeOptions) (_result *DeleteCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationIds)) {
		query["DestinationIds"] = request.DestinationIds
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCustomRoutingEndpointGroupDestinations"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) to query the status of the task.
 *     *   If the endpoint group is in the **updating** state, it indicates that mappings are being deleted from the endpoint group. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state and no information about the mappings that you want to delete is found in the response when you call the [DescribeCustomRoutingEndpointGroupDestinations](~~449378~~) operation, it indicates the mappings are deleted from the endpoint group.
 * *   You cannot call the **DeleteCustomRoutingEndpointGroupDestinations** operation again on the same Global Accelerator (GA) instance before the previous request is completed.
 *
 * @param request DeleteCustomRoutingEndpointGroupDestinationsRequest
 * @return DeleteCustomRoutingEndpointGroupDestinationsResponse
 */
func (client *Client) DeleteCustomRoutingEndpointGroupDestinations(request *DeleteCustomRoutingEndpointGroupDestinationsRequest) (_result *DeleteCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.DeleteCustomRoutingEndpointGroupDestinationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the state of the endpoint groups associated with a custom routing listener that you attempt to delete.
 *     *   If the endpoint groups are in the **deleting** state, the endpoint groups are being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint groups cannot be queried, the endpoint groups are deleted.
 * *   You cannot use the **DeleteCustomRoutingEndpointGroups** operation on the same Global Accelerator (GA) instance before the previous operation is complete.
 *
 * @param request DeleteCustomRoutingEndpointGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomRoutingEndpointGroupsResponse
 */
func (client *Client) DeleteCustomRoutingEndpointGroupsWithOptions(request *DeleteCustomRoutingEndpointGroupsRequest, runtime *util.RuntimeOptions) (_result *DeleteCustomRoutingEndpointGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupIds)) {
		query["EndpointGroupIds"] = request.EndpointGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCustomRoutingEndpointGroups"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCustomRoutingEndpointGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpointGroups** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the state of the endpoint groups associated with a custom routing listener that you attempt to delete.
 *     *   If the endpoint groups are in the **deleting** state, the endpoint groups are being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint groups cannot be queried, the endpoint groups are deleted.
 * *   You cannot use the **DeleteCustomRoutingEndpointGroups** operation on the same Global Accelerator (GA) instance before the previous operation is complete.
 *
 * @param request DeleteCustomRoutingEndpointGroupsRequest
 * @return DeleteCustomRoutingEndpointGroupsResponse
 */
func (client *Client) DeleteCustomRoutingEndpointGroups(request *DeleteCustomRoutingEndpointGroupsRequest) (_result *DeleteCustomRoutingEndpointGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCustomRoutingEndpointGroupsResponse{}
	_body, _err := client.DeleteCustomRoutingEndpointGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of an endpoint group to check whether the traffic destinations are deleted.
 *     *   If the endpoint group is in the **updating** state, the traffic destinations are being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state and the traffic destinations that you want to delete cannot be queried by calling the [DescribeCustomRoutingEndPointTrafficPolicy](~~449392~~) operation, the traffic destinations are deleted.
 * *   The **DeleteCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteCustomRoutingEndpointTrafficPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomRoutingEndpointTrafficPoliciesResponse
 */
func (client *Client) DeleteCustomRoutingEndpointTrafficPoliciesWithOptions(request *DeleteCustomRoutingEndpointTrafficPoliciesRequest, runtime *util.RuntimeOptions) (_result *DeleteCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyIds)) {
		query["PolicyIds"] = request.PolicyIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCustomRoutingEndpointTrafficPolicies"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of an endpoint group to check whether the traffic destinations are deleted.
 *     *   If the endpoint group is in the **updating** state, the traffic destinations are being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state and the traffic destinations that you want to delete cannot be queried by calling the [DescribeCustomRoutingEndPointTrafficPolicy](~~449392~~) operation, the traffic destinations are deleted.
 * *   The **DeleteCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteCustomRoutingEndpointTrafficPoliciesRequest
 * @return DeleteCustomRoutingEndpointTrafficPoliciesResponse
 */
func (client *Client) DeleteCustomRoutingEndpointTrafficPolicies(request *DeleteCustomRoutingEndpointTrafficPoliciesRequest) (_result *DeleteCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.DeleteCustomRoutingEndpointTrafficPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpoints** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) to query the status of the task.
 *     *   If an endpoint group is in the **updating** state, the endpoint is being deleted. In this case, you can perform only query operations.
 *     *   If an endpoint group is in the **active** state and the endpoint cannot be found after you call the [DescribeCustomRoutingEndpoint](~~449386~~) operation, the endpoint is deleted.
 * *   You cannot call the **DeleteCustomRoutingEndpoints** operation again on the same Global Accelerator (GA) instance before the previous task is completed.
 *
 * @param request DeleteCustomRoutingEndpointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomRoutingEndpointsResponse
 */
func (client *Client) DeleteCustomRoutingEndpointsWithOptions(request *DeleteCustomRoutingEndpointsRequest, runtime *util.RuntimeOptions) (_result *DeleteCustomRoutingEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointIds)) {
		query["EndpointIds"] = request.EndpointIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCustomRoutingEndpoints"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCustomRoutingEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteCustomRoutingEndpoints** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) to query the status of the task.
 *     *   If an endpoint group is in the **updating** state, the endpoint is being deleted. In this case, you can perform only query operations.
 *     *   If an endpoint group is in the **active** state and the endpoint cannot be found after you call the [DescribeCustomRoutingEndpoint](~~449386~~) operation, the endpoint is deleted.
 * *   You cannot call the **DeleteCustomRoutingEndpoints** operation again on the same Global Accelerator (GA) instance before the previous task is completed.
 *
 * @param request DeleteCustomRoutingEndpointsRequest
 * @return DeleteCustomRoutingEndpointsResponse
 */
func (client *Client) DeleteCustomRoutingEndpoints(request *DeleteCustomRoutingEndpointsRequest) (_result *DeleteCustomRoutingEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCustomRoutingEndpointsResponse{}
	_body, _err := client.DeleteCustomRoutingEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot call the **DeleteDomainAcceleratorRelation** operation again by using the same Alibaba Cloud account before the previous operation is complete.
 *
 * @param request DeleteDomainAcceleratorRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainAcceleratorRelationResponse
 */
func (client *Client) DeleteDomainAcceleratorRelationWithOptions(request *DeleteDomainAcceleratorRelationRequest, runtime *util.RuntimeOptions) (_result *DeleteDomainAcceleratorRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorIds)) {
		query["AcceleratorIds"] = request.AcceleratorIds
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDomainAcceleratorRelation"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDomainAcceleratorRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot call the **DeleteDomainAcceleratorRelation** operation again by using the same Alibaba Cloud account before the previous operation is complete.
 *
 * @param request DeleteDomainAcceleratorRelationRequest
 * @return DeleteDomainAcceleratorRelationResponse
 */
func (client *Client) DeleteDomainAcceleratorRelation(request *DeleteDomainAcceleratorRelationRequest) (_result *DeleteDomainAcceleratorRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDomainAcceleratorRelationResponse{}
	_body, _err := client.DeleteDomainAcceleratorRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the status of the endpoint group.
 *     *   If the endpoint group is in the **deleting** state, it indicates that the endpoint group is being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint group cannot be queried, it indicates that the endpoint group is deleted.
 * *   The **DeleteEndpointGroup** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request DeleteEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEndpointGroupResponse
 */
func (client *Client) DeleteEndpointGroupWithOptions(request *DeleteEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteEndpointGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the status of the endpoint group.
 *     *   If the endpoint group is in the **deleting** state, it indicates that the endpoint group is being deleted. In this case, you can perform only query operations.
 *     *   If the endpoint group cannot be queried, it indicates that the endpoint group is deleted.
 * *   The **DeleteEndpointGroup** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request DeleteEndpointGroupRequest
 * @return DeleteEndpointGroupResponse
 */
func (client *Client) DeleteEndpointGroup(request *DeleteEndpointGroupRequest) (_result *DeleteEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEndpointGroupResponse{}
	_body, _err := client.DeleteEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the status of the task.
 *     *   If an endpoint group is in the **deleting** state, the endpoint group is being deleted. In this case, you can perform only query operations.
 *     *   If an endpoint group cannot be queried, the endpoint group is deleted.
 * *   The **DeleteEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteEndpointGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEndpointGroupsResponse
 */
func (client *Client) DeleteEndpointGroupsWithOptions(request *DeleteEndpointGroupsRequest, runtime *util.RuntimeOptions) (_result *DeleteEndpointGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupIds)) {
		query["EndpointGroupIds"] = request.EndpointGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEndpointGroups"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEndpointGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the status of the task.
 *     *   If an endpoint group is in the **deleting** state, the endpoint group is being deleted. In this case, you can perform only query operations.
 *     *   If an endpoint group cannot be queried, the endpoint group is deleted.
 * *   The **DeleteEndpointGroups** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteEndpointGroupsRequest
 * @return DeleteEndpointGroupsResponse
 */
func (client *Client) DeleteEndpointGroups(request *DeleteEndpointGroupsRequest) (_result *DeleteEndpointGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEndpointGroupsResponse{}
	_body, _err := client.DeleteEndpointGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteForwardingRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListForwardingRules](~~205817~~) operation to query the status of the task.
 *     *   If a forwarding rule is in the **deleting** state, the forwarding rule is being deleted. In this case, you can perform only query operations.
 *     *   If a forwarding rule cannot be queried, the forwarding rule is deleted.
 * *   The **DeleteForwardingRules** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteForwardingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteForwardingRulesResponse
 */
func (client *Client) DeleteForwardingRulesWithOptions(request *DeleteForwardingRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteForwardingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardingRuleIds)) {
		query["ForwardingRuleIds"] = request.ForwardingRuleIds
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteForwardingRules"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteForwardingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteForwardingRules** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListForwardingRules](~~205817~~) operation to query the status of the task.
 *     *   If a forwarding rule is in the **deleting** state, the forwarding rule is being deleted. In this case, you can perform only query operations.
 *     *   If a forwarding rule cannot be queried, the forwarding rule is deleted.
 * *   The **DeleteForwardingRules** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteForwardingRulesRequest
 * @return DeleteForwardingRulesResponse
 */
func (client *Client) DeleteForwardingRules(request *DeleteForwardingRulesRequest) (_result *DeleteForwardingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteForwardingRulesResponse{}
	_body, _err := client.DeleteForwardingRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of an acceleration region.
 *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
 *     *   If the acceleration region cannot be queried, it indicates that the acceleration region is deleted.
 * *   The **DeleteIpSet** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request DeleteIpSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpSetResponse
 */
func (client *Client) DeleteIpSetWithOptions(request *DeleteIpSetRequest, runtime *util.RuntimeOptions) (_result *DeleteIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIpSet"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of an acceleration region.
 *     *   If the acceleration region is in the **deleting** state, it indicates that the acceleration region is being deleted. In this case, you can perform only query operations.
 *     *   If the acceleration region cannot be queried, it indicates that the acceleration region is deleted.
 * *   The **DeleteIpSet** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request DeleteIpSetRequest
 * @return DeleteIpSetResponse
 */
func (client *Client) DeleteIpSet(request *DeleteIpSetRequest) (_result *DeleteIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIpSetResponse{}
	_body, _err := client.DeleteIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteIpSets** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeIpSet](~~153246~~) operation to query the state of an acceleration region.
 *     *   If the acceleration region is in the **deleting** state, the acceleration region is being deleted. In this case, you can perform only query operations.
 *     *   If the acceleration region cannot be queried, the acceleration region is deleted.
 * *   The **DeleteIpSets** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteIpSetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpSetsResponse
 */
func (client *Client) DeleteIpSetsWithOptions(request *DeleteIpSetsRequest, runtime *util.RuntimeOptions) (_result *DeleteIpSetsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpSetIds)) {
		query["IpSetIds"] = request.IpSetIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIpSets"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIpSetsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteIpSets** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeIpSet](~~153246~~) operation to query the state of an acceleration region.
 *     *   If the acceleration region is in the **deleting** state, the acceleration region is being deleted. In this case, you can perform only query operations.
 *     *   If the acceleration region cannot be queried, the acceleration region is deleted.
 * *   The **DeleteIpSets** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteIpSetsRequest
 * @return DeleteIpSetsResponse
 */
func (client *Client) DeleteIpSets(request *DeleteIpSetsRequest) (_result *DeleteIpSetsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIpSetsResponse{}
	_body, _err := client.DeleteIpSetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the state of the listener.
 *     *   If the listener is in the **deleting** state, it indicates that the listener is being deleted. In this case, you can continue to perform query operations on the listener.
 *     *   If the listener cannot be queried, it indicates that the listener is deleted.
 * *   The **DeleteListener** operation cannot be repeatedly called to delete listeners for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteListenerResponse
 */
func (client *Client) DeleteListenerWithOptions(request *DeleteListenerRequest, runtime *util.RuntimeOptions) (_result *DeleteListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the state of the listener.
 *     *   If the listener is in the **deleting** state, it indicates that the listener is being deleted. In this case, you can continue to perform query operations on the listener.
 *     *   If the listener cannot be queried, it indicates that the listener is deleted.
 * *   The **DeleteListener** operation cannot be repeatedly called to delete listeners for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DeleteListenerRequest
 * @return DeleteListenerResponse
 */
func (client *Client) DeleteListener(request *DeleteListenerRequest) (_result *DeleteListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteListenerResponse{}
	_body, _err := client.DeleteListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **DeleteSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that the secondary IP addresses for the CNAME are being deleted. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state and the secondary IP addresses for the CNAME cannot be queried by calling the [ListSpareIps](~~262121~~) operation, it indicates that the IP addresses are deleted.
 * *   The **DeleteSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request DeleteSpareIpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSpareIpsResponse
 */
func (client *Client) DeleteSpareIpsWithOptions(request *DeleteSpareIpsRequest, runtime *util.RuntimeOptions) (_result *DeleteSpareIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SpareIps)) {
		query["SpareIps"] = request.SpareIps
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSpareIps"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSpareIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **DeleteSpareIps** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that the secondary IP addresses for the CNAME are being deleted. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state and the secondary IP addresses for the CNAME cannot be queried by calling the [ListSpareIps](~~262121~~) operation, it indicates that the IP addresses are deleted.
 * *   The **DeleteSpareIps** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request DeleteSpareIpsRequest
 * @return DeleteSpareIpsResponse
 */
func (client *Client) DeleteSpareIps(request *DeleteSpareIpsRequest) (_result *DeleteSpareIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSpareIpsResponse{}
	_body, _err := client.DeleteSpareIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAcceleratorWithOptions(request *DescribeAcceleratorRequest, runtime *util.RuntimeOptions) (_result *DescribeAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAccelerator(request *DescribeAcceleratorRequest) (_result *DescribeAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAcceleratorResponse{}
	_body, _err := client.DescribeAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAcceleratorAutoRenewAttributeWithOptions(request *DescribeAcceleratorAutoRenewAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeAcceleratorAutoRenewAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAcceleratorAutoRenewAttribute"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAcceleratorAutoRenewAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAcceleratorAutoRenewAttribute(request *DescribeAcceleratorAutoRenewAttributeRequest) (_result *DescribeAcceleratorAutoRenewAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAcceleratorAutoRenewAttributeResponse{}
	_body, _err := client.DescribeAcceleratorAutoRenewAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAcceleratorServiceStatusWithOptions(request *DescribeAcceleratorServiceStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeAcceleratorServiceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAcceleratorServiceStatus"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAcceleratorServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAcceleratorServiceStatus(request *DescribeAcceleratorServiceStatusRequest) (_result *DescribeAcceleratorServiceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAcceleratorServiceStatusResponse{}
	_body, _err := client.DescribeAcceleratorServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeApplicationMonitorWithOptions(request *DescribeApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *DescribeApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeApplicationMonitor(request *DescribeApplicationMonitorRequest) (_result *DescribeApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeApplicationMonitorResponse{}
	_body, _err := client.DescribeApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBandwidthPackageWithOptions(request *DescribeBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *DescribeBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBandwidthPackage"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBandwidthPackage(request *DescribeBandwidthPackageRequest) (_result *DescribeBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBandwidthPackageResponse{}
	_body, _err := client.DescribeBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBandwidthPackageAutoRenewAttributeWithOptions(request *DescribeBandwidthPackageAutoRenewAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeBandwidthPackageAutoRenewAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBandwidthPackageAutoRenewAttribute"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBandwidthPackageAutoRenewAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBandwidthPackageAutoRenewAttribute(request *DescribeBandwidthPackageAutoRenewAttributeRequest) (_result *DescribeBandwidthPackageAutoRenewAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBandwidthPackageAutoRenewAttributeResponse{}
	_body, _err := client.DescribeBandwidthPackageAutoRenewAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCommodityWithOptions(request *DescribeCommodityRequest, runtime *util.RuntimeOptions) (_result *DescribeCommodityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCommodity"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCommodityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCommodity(request *DescribeCommodityRequest) (_result *DescribeCommodityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCommodityResponse{}
	_body, _err := client.DescribeCommodityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCommodityPriceWithOptions(request *DescribeCommodityPriceRequest, runtime *util.RuntimeOptions) (_result *DescribeCommodityPriceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Orders)) {
		query["Orders"] = request.Orders
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionOptionNo)) {
		query["PromotionOptionNo"] = request.PromotionOptionNo
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCommodityPrice"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCommodityPriceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCommodityPrice(request *DescribeCommodityPriceRequest) (_result *DescribeCommodityPriceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCommodityPriceResponse{}
	_body, _err := client.DescribeCommodityPriceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndPointTrafficPolicyWithOptions(request *DescribeCustomRoutingEndPointTrafficPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomRoutingEndPointTrafficPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomRoutingEndPointTrafficPolicy"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomRoutingEndPointTrafficPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndPointTrafficPolicy(request *DescribeCustomRoutingEndPointTrafficPolicyRequest) (_result *DescribeCustomRoutingEndPointTrafficPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomRoutingEndPointTrafficPolicyResponse{}
	_body, _err := client.DescribeCustomRoutingEndPointTrafficPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndpointWithOptions(request *DescribeCustomRoutingEndpointRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomRoutingEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointGroup)) {
		query["EndpointGroup"] = request.EndpointGroup
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomRoutingEndpoint"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomRoutingEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndpoint(request *DescribeCustomRoutingEndpointRequest) (_result *DescribeCustomRoutingEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomRoutingEndpointResponse{}
	_body, _err := client.DescribeCustomRoutingEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndpointGroupWithOptions(request *DescribeCustomRoutingEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomRoutingEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomRoutingEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomRoutingEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndpointGroup(request *DescribeCustomRoutingEndpointGroupRequest) (_result *DescribeCustomRoutingEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomRoutingEndpointGroupResponse{}
	_body, _err := client.DescribeCustomRoutingEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndpointGroupDestinationsWithOptions(request *DescribeCustomRoutingEndpointGroupDestinationsRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationId)) {
		query["DestinationId"] = request.DestinationId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomRoutingEndpointGroupDestinations"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomRoutingEndpointGroupDestinations(request *DescribeCustomRoutingEndpointGroupDestinationsRequest) (_result *DescribeCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.DescribeCustomRoutingEndpointGroupDestinationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEndpointGroupWithOptions(request *DescribeEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEndpointGroup(request *DescribeEndpointGroupRequest) (_result *DescribeEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEndpointGroupResponse{}
	_body, _err := client.DescribeEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=DescribeIpSet\\&type=RPC\\&version=2019-11-20)
 *
 * @param request DescribeIpSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIpSetResponse
 */
func (client *Client) DescribeIpSetWithOptions(request *DescribeIpSetRequest, runtime *util.RuntimeOptions) (_result *DescribeIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIpSet"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=DescribeIpSet\\&type=RPC\\&version=2019-11-20)
 *
 * @param request DescribeIpSetRequest
 * @return DescribeIpSetResponse
 */
func (client *Client) DescribeIpSet(request *DescribeIpSetRequest) (_result *DescribeIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIpSetResponse{}
	_body, _err := client.DescribeIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is used to query configuration information about a specified listener of a GA instance. The information includes the routing type of the listener, the state of the listener, the timestamp that indicates when the listener was created, and the listener ports.
 *
 * @param request DescribeListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeListenerResponse
 */
func (client *Client) DescribeListenerWithOptions(request *DescribeListenerRequest, runtime *util.RuntimeOptions) (_result *DescribeListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is used to query configuration information about a specified listener of a GA instance. The information includes the routing type of the listener, the state of the listener, the timestamp that indicates when the listener was created, and the listener ports.
 *
 * @param request DescribeListenerRequest
 * @return DescribeListenerResponse
 */
func (client *Client) DescribeListener(request *DescribeListenerRequest) (_result *DescribeListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeListenerResponse{}
	_body, _err := client.DescribeListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLogStoreOfEndpointGroupWithOptions(request *DescribeLogStoreOfEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeLogStoreOfEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLogStoreOfEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLogStoreOfEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLogStoreOfEndpointGroup(request *DescribeLogStoreOfEndpointGroupRequest) (_result *DescribeLogStoreOfEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLogStoreOfEndpointGroupResponse{}
	_body, _err := client.DescribeLogStoreOfEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DetachDdosFromAccelerator** operation is asynchronous. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) or [ListAccelerators](~~153236~~) operation to query the status of the GA instance.
 *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro/Premium instance is being disassociated from the GA instance. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro/Premium instance is disassociated from the GA instance.
 * *   **DetachDdosFromAccelerator** cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request DetachDdosFromAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachDdosFromAcceleratorResponse
 */
func (client *Client) DetachDdosFromAcceleratorWithOptions(request *DetachDdosFromAcceleratorRequest, runtime *util.RuntimeOptions) (_result *DetachDdosFromAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachDdosFromAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachDdosFromAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DetachDdosFromAccelerator** operation is asynchronous. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) or [ListAccelerators](~~153236~~) operation to query the status of the GA instance.
 *     *   If the GA instance is in the **configuring** state, the Anti-DDoS Pro/Premium instance is being disassociated from the GA instance. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the Anti-DDoS Pro/Premium instance is disassociated from the GA instance.
 * *   **DetachDdosFromAccelerator** cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request DetachDdosFromAcceleratorRequest
 * @return DetachDdosFromAcceleratorResponse
 */
func (client *Client) DetachDdosFromAccelerator(request *DetachDdosFromAcceleratorRequest) (_result *DetachDdosFromAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachDdosFromAcceleratorResponse{}
	_body, _err := client.DetachDdosFromAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * *   **DetachLogStoreFromEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, the Log Service Logstore is being disassociated from the endpoint group. In this case, you can perform only query operations.
 *     <!---->
 *     *   If the endpoint group is in the **active** state, the Log Service Logstore is disassociated from the endpoint group.
 * *   The **DetachLogStoreFromEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DetachLogStoreFromEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachLogStoreFromEndpointGroupResponse
 */
func (client *Client) DetachLogStoreFromEndpointGroupWithOptions(request *DetachLogStoreFromEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *DetachLogStoreFromEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupIds)) {
		query["EndpointGroupIds"] = request.EndpointGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachLogStoreFromEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachLogStoreFromEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * *   **DetachLogStoreFromEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, the Log Service Logstore is being disassociated from the endpoint group. In this case, you can perform only query operations.
 *     <!---->
 *     *   If the endpoint group is in the **active** state, the Log Service Logstore is disassociated from the endpoint group.
 * *   The **DetachLogStoreFromEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DetachLogStoreFromEndpointGroupRequest
 * @return DetachLogStoreFromEndpointGroupResponse
 */
func (client *Client) DetachLogStoreFromEndpointGroup(request *DetachLogStoreFromEndpointGroupRequest) (_result *DetachLogStoreFromEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachLogStoreFromEndpointGroupResponse{}
	_body, _err := client.DetachLogStoreFromEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetectApplicationMonitorWithOptions(request *DetectApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *DetectApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetectApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetectApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetectApplicationMonitor(request *DetectApplicationMonitorRequest) (_result *DetectApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetectApplicationMonitorResponse{}
	_body, _err := client.DetectApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableApplicationMonitorWithOptions(request *DisableApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *DisableApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableApplicationMonitor(request *DisableApplicationMonitorRequest) (_result *DisableApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableApplicationMonitorResponse{}
	_body, _err := client.DisableApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * *   **DissociateAclsFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](~~153254~~) operation to query the state of a listener:
 *     *   If the listener is in the **updating** state, ACLs are being disassociated from the listener. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, ACLs are disassociated from the listener.
 * *   The **DissociateAclsFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DissociateAclsFromListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DissociateAclsFromListenerResponse
 */
func (client *Client) DissociateAclsFromListenerWithOptions(request *DissociateAclsFromListenerRequest, runtime *util.RuntimeOptions) (_result *DissociateAclsFromListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclIds)) {
		query["AclIds"] = request.AclIds
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DissociateAclsFromListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DissociateAclsFromListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * *   **DissociateAclsFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeListener](~~153254~~) operation to query the state of a listener:
 *     *   If the listener is in the **updating** state, ACLs are being disassociated from the listener. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, ACLs are disassociated from the listener.
 * *   The **DissociateAclsFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request DissociateAclsFromListenerRequest
 * @return DissociateAclsFromListenerResponse
 */
func (client *Client) DissociateAclsFromListener(request *DissociateAclsFromListenerRequest) (_result *DissociateAclsFromListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DissociateAclsFromListenerResponse{}
	_body, _err := client.DissociateAclsFromListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * *   **DissociateAdditionalCertificatesFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeListener](~~153254~~) operation to query the state of an HTTPS listener.
 *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being dissociated from the listener. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that the additional certificate is dissociated from the listener.
 * *   The **DissociateAdditionalCertificatesFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance with a specific period of time.
 *
 * @param request DissociateAdditionalCertificatesFromListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DissociateAdditionalCertificatesFromListenerResponse
 */
func (client *Client) DissociateAdditionalCertificatesFromListenerWithOptions(request *DissociateAdditionalCertificatesFromListenerRequest, runtime *util.RuntimeOptions) (_result *DissociateAdditionalCertificatesFromListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DissociateAdditionalCertificatesFromListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DissociateAdditionalCertificatesFromListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * *   **DissociateAdditionalCertificatesFromListener** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeListener](~~153254~~) operation to query the state of an HTTPS listener.
 *     *   If the listener is in the **updating** state, it indicates that the additional certificate is being dissociated from the listener. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that the additional certificate is dissociated from the listener.
 * *   The **DissociateAdditionalCertificatesFromListener** operation cannot be repeatedly called for the same Global Accelerator (GA) instance with a specific period of time.
 *
 * @param request DissociateAdditionalCertificatesFromListenerRequest
 * @return DissociateAdditionalCertificatesFromListenerResponse
 */
func (client *Client) DissociateAdditionalCertificatesFromListener(request *DissociateAdditionalCertificatesFromListenerRequest) (_result *DissociateAdditionalCertificatesFromListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DissociateAdditionalCertificatesFromListenerResponse{}
	_body, _err := client.DissociateAdditionalCertificatesFromListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableApplicationMonitorWithOptions(request *EnableApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *EnableApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableApplicationMonitor(request *EnableApplicationMonitorRequest) (_result *EnableApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableApplicationMonitorResponse{}
	_body, _err := client.EnableApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAclWithOptions(request *GetAclRequest, runtime *util.RuntimeOptions) (_result *GetAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAcl"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAcl(request *GetAclRequest) (_result *GetAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAclResponse{}
	_body, _err := client.GetAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBasicAccelerateIpWithOptions(request *GetBasicAccelerateIpRequest, runtime *util.RuntimeOptions) (_result *GetBasicAccelerateIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpId)) {
		query["AccelerateIpId"] = request.AccelerateIpId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBasicAccelerateIp"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBasicAccelerateIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBasicAccelerateIp(request *GetBasicAccelerateIpRequest) (_result *GetBasicAccelerateIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBasicAccelerateIpResponse{}
	_body, _err := client.GetBasicAccelerateIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBasicAccelerateIpEndpointRelationWithOptions(request *GetBasicAccelerateIpEndpointRelationRequest, runtime *util.RuntimeOptions) (_result *GetBasicAccelerateIpEndpointRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpId)) {
		query["AccelerateIpId"] = request.AccelerateIpId
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBasicAccelerateIpEndpointRelation"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBasicAccelerateIpEndpointRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBasicAccelerateIpEndpointRelation(request *GetBasicAccelerateIpEndpointRelationRequest) (_result *GetBasicAccelerateIpEndpointRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBasicAccelerateIpEndpointRelationResponse{}
	_body, _err := client.GetBasicAccelerateIpEndpointRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBasicAccelerateIpIdleCountWithOptions(request *GetBasicAccelerateIpIdleCountRequest, runtime *util.RuntimeOptions) (_result *GetBasicAccelerateIpIdleCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBasicAccelerateIpIdleCount"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBasicAccelerateIpIdleCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBasicAccelerateIpIdleCount(request *GetBasicAccelerateIpIdleCountRequest) (_result *GetBasicAccelerateIpIdleCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBasicAccelerateIpIdleCountResponse{}
	_body, _err := client.GetBasicAccelerateIpIdleCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBasicAcceleratorWithOptions(request *GetBasicAcceleratorRequest, runtime *util.RuntimeOptions) (_result *GetBasicAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBasicAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBasicAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBasicAccelerator(request *GetBasicAcceleratorRequest) (_result *GetBasicAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBasicAcceleratorResponse{}
	_body, _err := client.GetBasicAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBasicEndpointWithOptions(request *GetBasicEndpointRequest, runtime *util.RuntimeOptions) (_result *GetBasicEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBasicEndpoint"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBasicEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBasicEndpoint(request *GetBasicEndpointRequest) (_result *GetBasicEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBasicEndpointResponse{}
	_body, _err := client.GetBasicEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBasicEndpointGroupWithOptions(request *GetBasicEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *GetBasicEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBasicEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBasicEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBasicEndpointGroup(request *GetBasicEndpointGroupRequest) (_result *GetBasicEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBasicEndpointGroupResponse{}
	_body, _err := client.GetBasicEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBasicIpSetWithOptions(request *GetBasicIpSetRequest, runtime *util.RuntimeOptions) (_result *GetBasicIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBasicIpSet"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBasicIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBasicIpSet(request *GetBasicIpSetRequest) (_result *GetBasicIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBasicIpSetResponse{}
	_body, _err := client.GetBasicIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetHealthStatusWithOptions(request *GetHealthStatusRequest, runtime *util.RuntimeOptions) (_result *GetHealthStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetHealthStatus"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetHealthStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetHealthStatus(request *GetHealthStatusRequest) (_result *GetHealthStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetHealthStatusResponse{}
	_body, _err := client.GetHealthStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetInvalidDomainCountWithOptions(request *GetInvalidDomainCountRequest, runtime *util.RuntimeOptions) (_result *GetInvalidDomainCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInvalidDomainCount"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInvalidDomainCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetInvalidDomainCount(request *GetInvalidDomainCountRequest) (_result *GetInvalidDomainCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInvalidDomainCountResponse{}
	_body, _err := client.GetInvalidDomainCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetIpsetsBandwidthLimitWithOptions(request *GetIpsetsBandwidthLimitRequest, runtime *util.RuntimeOptions) (_result *GetIpsetsBandwidthLimitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetIpsetsBandwidthLimit"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIpsetsBandwidthLimitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetIpsetsBandwidthLimit(request *GetIpsetsBandwidthLimitRequest) (_result *GetIpsetsBandwidthLimitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetIpsetsBandwidthLimitResponse{}
	_body, _err := client.GetIpsetsBandwidthLimitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSpareIpWithOptions(request *GetSpareIpRequest, runtime *util.RuntimeOptions) (_result *GetSpareIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SpareIp)) {
		query["SpareIp"] = request.SpareIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSpareIp"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSpareIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSpareIp(request *GetSpareIpRequest) (_result *GetSpareIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSpareIpResponse{}
	_body, _err := client.GetSpareIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAccelerateAreasWithOptions(request *ListAccelerateAreasRequest, runtime *util.RuntimeOptions) (_result *ListAccelerateAreasResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAccelerateAreas"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAccelerateAreasResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAccelerateAreas(request *ListAccelerateAreasRequest) (_result *ListAccelerateAreasResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAccelerateAreasResponse{}
	_body, _err := client.ListAccelerateAreasWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAcceleratorsWithOptions(request *ListAcceleratorsRequest, runtime *util.RuntimeOptions) (_result *ListAcceleratorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAccelerators"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAcceleratorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAccelerators(request *ListAcceleratorsRequest) (_result *ListAcceleratorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAcceleratorsResponse{}
	_body, _err := client.ListAcceleratorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAclsWithOptions(request *ListAclsRequest, runtime *util.RuntimeOptions) (_result *ListAclsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclIds)) {
		query["AclIds"] = request.AclIds
	}

	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAcls"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAclsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAcls(request *ListAclsRequest) (_result *ListAclsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAclsResponse{}
	_body, _err := client.ListAclsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListApplicationMonitorWithOptions(request *ListApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *ListApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchValue)) {
		query["SearchValue"] = request.SearchValue
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListApplicationMonitor(request *ListApplicationMonitorRequest) (_result *ListApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListApplicationMonitorResponse{}
	_body, _err := client.ListApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListApplicationMonitorDetectResultWithOptions(request *ListApplicationMonitorDetectResultRequest, runtime *util.RuntimeOptions) (_result *ListApplicationMonitorDetectResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginTime)) {
		query["BeginTime"] = request.BeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListApplicationMonitorDetectResult"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListApplicationMonitorDetectResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListApplicationMonitorDetectResult(request *ListApplicationMonitorDetectResultRequest) (_result *ListApplicationMonitorDetectResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListApplicationMonitorDetectResultResponse{}
	_body, _err := client.ListApplicationMonitorDetectResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAvailableAccelerateAreasWithOptions(request *ListAvailableAccelerateAreasRequest, runtime *util.RuntimeOptions) (_result *ListAvailableAccelerateAreasResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAvailableAccelerateAreas"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAvailableAccelerateAreasResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAvailableAccelerateAreas(request *ListAvailableAccelerateAreasRequest) (_result *ListAvailableAccelerateAreasResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAvailableAccelerateAreasResponse{}
	_body, _err := client.ListAvailableAccelerateAreasWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAvailableBusiRegionsWithOptions(request *ListAvailableBusiRegionsRequest, runtime *util.RuntimeOptions) (_result *ListAvailableBusiRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAvailableBusiRegions"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAvailableBusiRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAvailableBusiRegions(request *ListAvailableBusiRegionsRequest) (_result *ListAvailableBusiRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAvailableBusiRegionsResponse{}
	_body, _err := client.ListAvailableBusiRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBandwidthPackagesWithOptions(request *ListBandwidthPackagesRequest, runtime *util.RuntimeOptions) (_result *ListBandwidthPackagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBandwidthPackages"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBandwidthPackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBandwidthPackages(request *ListBandwidthPackagesRequest) (_result *ListBandwidthPackagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBandwidthPackagesResponse{}
	_body, _err := client.ListBandwidthPackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBandwidthackagesWithOptions(request *ListBandwidthackagesRequest, runtime *util.RuntimeOptions) (_result *ListBandwidthackagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBandwidthackages"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBandwidthackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBandwidthackages(request *ListBandwidthackagesRequest) (_result *ListBandwidthackagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBandwidthackagesResponse{}
	_body, _err := client.ListBandwidthackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBasicAccelerateIpEndpointRelationsWithOptions(request *ListBasicAccelerateIpEndpointRelationsRequest, runtime *util.RuntimeOptions) (_result *ListBasicAccelerateIpEndpointRelationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpId)) {
		query["AccelerateIpId"] = request.AccelerateIpId
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBasicAccelerateIpEndpointRelations"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBasicAccelerateIpEndpointRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBasicAccelerateIpEndpointRelations(request *ListBasicAccelerateIpEndpointRelationsRequest) (_result *ListBasicAccelerateIpEndpointRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBasicAccelerateIpEndpointRelationsResponse{}
	_body, _err := client.ListBasicAccelerateIpEndpointRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBasicAccelerateIpsWithOptions(request *ListBasicAccelerateIpsRequest, runtime *util.RuntimeOptions) (_result *ListBasicAccelerateIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccelerateIpAddress)) {
		query["AccelerateIpAddress"] = request.AccelerateIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.AccelerateIpId)) {
		query["AccelerateIpId"] = request.AccelerateIpId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBasicAccelerateIps"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBasicAccelerateIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBasicAccelerateIps(request *ListBasicAccelerateIpsRequest) (_result *ListBasicAccelerateIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBasicAccelerateIpsResponse{}
	_body, _err := client.ListBasicAccelerateIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBasicAcceleratorsWithOptions(request *ListBasicAcceleratorsRequest, runtime *util.RuntimeOptions) (_result *ListBasicAcceleratorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBasicAccelerators"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBasicAcceleratorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBasicAccelerators(request *ListBasicAcceleratorsRequest) (_result *ListBasicAcceleratorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBasicAcceleratorsResponse{}
	_body, _err := client.ListBasicAcceleratorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBasicEndpointsWithOptions(request *ListBasicEndpointsRequest, runtime *util.RuntimeOptions) (_result *ListBasicEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointType)) {
		query["EndpointType"] = request.EndpointType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBasicEndpoints"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBasicEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBasicEndpoints(request *ListBasicEndpointsRequest) (_result *ListBasicEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBasicEndpointsResponse{}
	_body, _err := client.ListBasicEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBusiRegionsWithOptions(request *ListBusiRegionsRequest, runtime *util.RuntimeOptions) (_result *ListBusiRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBusiRegions"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBusiRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBusiRegions(request *ListBusiRegionsRequest) (_result *ListBusiRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBusiRegionsResponse{}
	_body, _err := client.ListBusiRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query the acceleration areas and regions that you can specify on the wizard page of Global Accelerator (GA) and for free-trial GA instances. You can filter acceleration areas and regions based on specified conditions.
 *
 * @param request ListCommonAreasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCommonAreasResponse
 */
func (client *Client) ListCommonAreasWithOptions(request *ListCommonAreasRequest, runtime *util.RuntimeOptions) (_result *ListCommonAreasResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IsEpg)) {
		query["IsEpg"] = request.IsEpg
	}

	if !tea.BoolValue(util.IsUnset(request.IsIpSet)) {
		query["IsIpSet"] = request.IsIpSet
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCommonAreas"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCommonAreasResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query the acceleration areas and regions that you can specify on the wizard page of Global Accelerator (GA) and for free-trial GA instances. You can filter acceleration areas and regions based on specified conditions.
 *
 * @param request ListCommonAreasRequest
 * @return ListCommonAreasResponse
 */
func (client *Client) ListCommonAreas(request *ListCommonAreasRequest) (_result *ListCommonAreasResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCommonAreasResponse{}
	_body, _err := client.ListCommonAreasWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCustomRoutingEndpointGroupDestinationsWithOptions(request *ListCustomRoutingEndpointGroupDestinationsRequest, runtime *util.RuntimeOptions) (_result *ListCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.FromPort)) {
		query["FromPort"] = request.FromPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Protocols)) {
		query["Protocols"] = request.Protocols
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ToPort)) {
		query["ToPort"] = request.ToPort
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCustomRoutingEndpointGroupDestinations"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCustomRoutingEndpointGroupDestinations(request *ListCustomRoutingEndpointGroupDestinationsRequest) (_result *ListCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.ListCustomRoutingEndpointGroupDestinationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=ListCustomRoutingEndpointGroups\\&type=RPC\\&version=2019-11-20)
 *
 * @param request ListCustomRoutingEndpointGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCustomRoutingEndpointGroupsResponse
 */
func (client *Client) ListCustomRoutingEndpointGroupsWithOptions(request *ListCustomRoutingEndpointGroupsRequest, runtime *util.RuntimeOptions) (_result *ListCustomRoutingEndpointGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCustomRoutingEndpointGroups"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCustomRoutingEndpointGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=ListCustomRoutingEndpointGroups\\&type=RPC\\&version=2019-11-20)
 *
 * @param request ListCustomRoutingEndpointGroupsRequest
 * @return ListCustomRoutingEndpointGroupsResponse
 */
func (client *Client) ListCustomRoutingEndpointGroups(request *ListCustomRoutingEndpointGroupsRequest) (_result *ListCustomRoutingEndpointGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCustomRoutingEndpointGroupsResponse{}
	_body, _err := client.ListCustomRoutingEndpointGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCustomRoutingEndpointTrafficPoliciesWithOptions(request *ListCustomRoutingEndpointTrafficPoliciesRequest, runtime *util.RuntimeOptions) (_result *ListCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCustomRoutingEndpointTrafficPolicies"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCustomRoutingEndpointTrafficPolicies(request *ListCustomRoutingEndpointTrafficPoliciesRequest) (_result *ListCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.ListCustomRoutingEndpointTrafficPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCustomRoutingEndpointsWithOptions(request *ListCustomRoutingEndpointsRequest, runtime *util.RuntimeOptions) (_result *ListCustomRoutingEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCustomRoutingEndpoints"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCustomRoutingEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCustomRoutingEndpoints(request *ListCustomRoutingEndpointsRequest) (_result *ListCustomRoutingEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCustomRoutingEndpointsResponse{}
	_body, _err := client.ListCustomRoutingEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you configure a custom routing listener for a Global Accelerator (GA) instance, the instance generates a port mapping table based on the listener port range, backend service protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches). The custom routing listener forwards client requests to specified IP addresses and ports in the vSwitches based on the port mapping table. This operation is used to query the generated port mapping table.
 *
 * @param request ListCustomRoutingPortMappingsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCustomRoutingPortMappingsResponse
 */
func (client *Client) ListCustomRoutingPortMappingsWithOptions(request *ListCustomRoutingPortMappingsRequest, runtime *util.RuntimeOptions) (_result *ListCustomRoutingPortMappingsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCustomRoutingPortMappings"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCustomRoutingPortMappingsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you configure a custom routing listener for a Global Accelerator (GA) instance, the instance generates a port mapping table based on the listener port range, backend service protocols and port ranges of the associated endpoint groups, and IP addresses of endpoints (vSwitches). The custom routing listener forwards client requests to specified IP addresses and ports in the vSwitches based on the port mapping table. This operation is used to query the generated port mapping table.
 *
 * @param request ListCustomRoutingPortMappingsRequest
 * @return ListCustomRoutingPortMappingsResponse
 */
func (client *Client) ListCustomRoutingPortMappings(request *ListCustomRoutingPortMappingsRequest) (_result *ListCustomRoutingPortMappingsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCustomRoutingPortMappingsResponse{}
	_body, _err := client.ListCustomRoutingPortMappingsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCustomRoutingPortMappingsByDestinationWithOptions(request *ListCustomRoutingPortMappingsByDestinationRequest, runtime *util.RuntimeOptions) (_result *ListCustomRoutingPortMappingsByDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationAddress)) {
		query["DestinationAddress"] = request.DestinationAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCustomRoutingPortMappingsByDestination"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCustomRoutingPortMappingsByDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCustomRoutingPortMappingsByDestination(request *ListCustomRoutingPortMappingsByDestinationRequest) (_result *ListCustomRoutingPortMappingsByDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCustomRoutingPortMappingsByDestinationResponse{}
	_body, _err := client.ListCustomRoutingPortMappingsByDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDomainsWithOptions(request *ListDomainsRequest, runtime *util.RuntimeOptions) (_result *ListDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDomains"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDomains(request *ListDomainsRequest) (_result *ListDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDomainsResponse{}
	_body, _err := client.ListDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEndpointGroupIpAddressCidrBlocksWithOptions(request *ListEndpointGroupIpAddressCidrBlocksRequest, runtime *util.RuntimeOptions) (_result *ListEndpointGroupIpAddressCidrBlocksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndpointGroupRegion)) {
		query["EndpointGroupRegion"] = request.EndpointGroupRegion
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEndpointGroupIpAddressCidrBlocks"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEndpointGroupIpAddressCidrBlocksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEndpointGroupIpAddressCidrBlocks(request *ListEndpointGroupIpAddressCidrBlocksRequest) (_result *ListEndpointGroupIpAddressCidrBlocksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEndpointGroupIpAddressCidrBlocksResponse{}
	_body, _err := client.ListEndpointGroupIpAddressCidrBlocksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=ListEndpointGroups\\&type=RPC\\&version=2019-11-20)
 *
 * @param request ListEndpointGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEndpointGroupsResponse
 */
func (client *Client) ListEndpointGroupsWithOptions(request *ListEndpointGroupsRequest, runtime *util.RuntimeOptions) (_result *ListEndpointGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.AccessLogSwitch)) {
		query["AccessLogSwitch"] = request.AccessLogSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupType)) {
		query["EndpointGroupType"] = request.EndpointGroupType
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEndpointGroups"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEndpointGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=Ga\\&api=ListEndpointGroups\\&type=RPC\\&version=2019-11-20)
 *
 * @param request ListEndpointGroupsRequest
 * @return ListEndpointGroupsResponse
 */
func (client *Client) ListEndpointGroups(request *ListEndpointGroupsRequest) (_result *ListEndpointGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEndpointGroupsResponse{}
	_body, _err := client.ListEndpointGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  This operation is used to query only custom forwarding rules, not the default forwarding rule.
 *
 * @param request ListForwardingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListForwardingRulesResponse
 */
func (client *Client) ListForwardingRulesWithOptions(request *ListForwardingRulesRequest, runtime *util.RuntimeOptions) (_result *ListForwardingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardingRuleId)) {
		query["ForwardingRuleId"] = request.ForwardingRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListForwardingRules"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListForwardingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  This operation is used to query only custom forwarding rules, not the default forwarding rule.
 *
 * @param request ListForwardingRulesRequest
 * @return ListForwardingRulesResponse
 */
func (client *Client) ListForwardingRules(request *ListForwardingRulesRequest) (_result *ListForwardingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListForwardingRulesResponse{}
	_body, _err := client.ListForwardingRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIpSetsWithOptions(request *ListIpSetsRequest, runtime *util.RuntimeOptions) (_result *ListIpSetsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIpSets"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIpSetsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIpSets(request *ListIpSetsRequest) (_result *ListIpSetsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIpSetsResponse{}
	_body, _err := client.ListIpSetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIspTypesWithOptions(request *ListIspTypesRequest, runtime *util.RuntimeOptions) (_result *ListIspTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.AcceleratorType)) {
		query["AcceleratorType"] = request.AcceleratorType
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessRegionId)) {
		query["BusinessRegionId"] = request.BusinessRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIspTypes"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIspTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIspTypes(request *ListIspTypesRequest) (_result *ListIspTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIspTypesResponse{}
	_body, _err := client.ListIspTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListListenerCertificatesWithOptions(request *ListListenerCertificatesRequest, runtime *util.RuntimeOptions) (_result *ListListenerCertificatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Role)) {
		query["Role"] = request.Role
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListListenerCertificates"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListListenerCertificatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListListenerCertificates(request *ListListenerCertificatesRequest) (_result *ListListenerCertificatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListListenerCertificatesResponse{}
	_body, _err := client.ListListenerCertificatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is used to query information about the listeners of a GA instance, including the state of each listener, the timestamp that indicates when each listener was created, and the listener ports.
 *
 * @param request ListListenersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListListenersResponse
 */
func (client *Client) ListListenersWithOptions(request *ListListenersRequest, runtime *util.RuntimeOptions) (_result *ListListenersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListListeners"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListListenersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is used to query information about the listeners of a GA instance, including the state of each listener, the timestamp that indicates when each listener was created, and the listener ports.
 *
 * @param request ListListenersRequest
 * @return ListListenersResponse
 */
func (client *Client) ListListeners(request *ListListenersRequest) (_result *ListListenersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListListenersResponse{}
	_body, _err := client.ListListenersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSpareIpsWithOptions(request *ListSpareIpsRequest, runtime *util.RuntimeOptions) (_result *ListSpareIpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSpareIps"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSpareIpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSpareIps(request *ListSpareIpsRequest) (_result *ListSpareIpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSpareIpsResponse{}
	_body, _err := client.ListSpareIpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can select a TLS security policy when you create an HTTPS listener. This API operation is used to query the TLS security policies that are supported by HTTPS listeners.
 *
 * @param request ListSystemSecurityPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSystemSecurityPoliciesResponse
 */
func (client *Client) ListSystemSecurityPoliciesWithOptions(request *ListSystemSecurityPoliciesRequest, runtime *util.RuntimeOptions) (_result *ListSystemSecurityPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSystemSecurityPolicies"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSystemSecurityPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can select a TLS security policy when you create an HTTPS listener. This API operation is used to query the TLS security policies that are supported by HTTPS listeners.
 *
 * @param request ListSystemSecurityPoliciesRequest
 * @return ListSystemSecurityPoliciesResponse
 */
func (client *Client) ListSystemSecurityPolicies(request *ListSystemSecurityPoliciesRequest) (_result *ListSystemSecurityPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSystemSecurityPoliciesResponse{}
	_body, _err := client.ListSystemSecurityPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You must specify **ResourceId.N** or **Tag.N** in the request to specify the object that you want to query.********
 * *   **Tag.N** is a resource tag that consists of a key-value pair (Tag.N.Key and Tag.N.Value). If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You must specify **ResourceId.N** or **Tag.N** in the request to specify the object that you want to query.********
 * *   **Tag.N** is a resource tag that consists of a key-value pair (Tag.N.Key and Tag.N.Value). If you specify only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you specify only **Tag.N.Value**, an error message is returned.
 * *   If you specify **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OpenAcceleratorServiceWithOptions(request *OpenAcceleratorServiceRequest, runtime *util.RuntimeOptions) (_result *OpenAcceleratorServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenAcceleratorService"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenAcceleratorServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OpenAcceleratorService(request *OpenAcceleratorServiceRequest) (_result *OpenAcceleratorServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenAcceleratorServiceResponse{}
	_body, _err := client.OpenAcceleratorServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryCrossBorderApprovalStatusWithOptions(request *QueryCrossBorderApprovalStatusRequest, runtime *util.RuntimeOptions) (_result *QueryCrossBorderApprovalStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryCrossBorderApprovalStatus"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryCrossBorderApprovalStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryCrossBorderApprovalStatus(request *QueryCrossBorderApprovalStatusRequest) (_result *QueryCrossBorderApprovalStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryCrossBorderApprovalStatusResponse{}
	_body, _err := client.QueryCrossBorderApprovalStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **RemoveEntriesFromAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](~~258292~~) or [ListAcls](~~258291~~) operation to query the status of the ACL from which you want to delete IP entries.
 *     *   If the ACL is in the **configuring** state, it indicates that the IP entries are being deleted. In this case, you can perform only query operations.
 *     *   If the ACL is in the **active** state, it indicates that the IP entries are deleted.
 * *   The **RemoveEntriesFromAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request RemoveEntriesFromAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveEntriesFromAclResponse
 */
func (client *Client) RemoveEntriesFromAclWithOptions(request *RemoveEntriesFromAclRequest, runtime *util.RuntimeOptions) (_result *RemoveEntriesFromAclResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntries)) {
		query["AclEntries"] = request.AclEntries
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveEntriesFromAcl"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveEntriesFromAclResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **RemoveEntriesFromAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetAcl](~~258292~~) or [ListAcls](~~258291~~) operation to query the status of the ACL from which you want to delete IP entries.
 *     *   If the ACL is in the **configuring** state, it indicates that the IP entries are being deleted. In this case, you can perform only query operations.
 *     *   If the ACL is in the **active** state, it indicates that the IP entries are deleted.
 * *   The **RemoveEntriesFromAcl** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request RemoveEntriesFromAclRequest
 * @return RemoveEntriesFromAclResponse
 */
func (client *Client) RemoveEntriesFromAcl(request *RemoveEntriesFromAclRequest) (_result *RemoveEntriesFromAclResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveEntriesFromAclResponse{}
	_body, _err := client.RemoveEntriesFromAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   The GA instance continues to forward network traffic.
 * *   **ReplaceBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) or [ListAccelerators](~~153236~~) operation to query the status of the GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that the associated bandwidth plan is being replaced. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, it indicates that the associated bandwidth plan is replaced.
 * *   The **ReplaceBandwidthPackage** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request ReplaceBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceBandwidthPackageResponse
 */
func (client *Client) ReplaceBandwidthPackageWithOptions(request *ReplaceBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *ReplaceBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetBandwidthPackageId)) {
		query["TargetBandwidthPackageId"] = request.TargetBandwidthPackageId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReplaceBandwidthPackage"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReplaceBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   The GA instance continues to forward network traffic.
 * *   **ReplaceBandwidthPackage** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) or [ListAccelerators](~~153236~~) operation to query the status of the GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that the associated bandwidth plan is being replaced. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, it indicates that the associated bandwidth plan is replaced.
 * *   The **ReplaceBandwidthPackage** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request ReplaceBandwidthPackageRequest
 * @return ReplaceBandwidthPackageResponse
 */
func (client *Client) ReplaceBandwidthPackage(request *ReplaceBandwidthPackageRequest) (_result *ReplaceBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReplaceBandwidthPackageResponse{}
	_body, _err := client.ReplaceBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Description
 * You can add up to 20 tags to each GA resource. When you call this operation, Alibaba Cloud first checks the number of existing tags attached to the resource. If the quota is reached, an error message is returned.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Description
 * You can add up to 20 tags to each GA resource. When you call this operation, Alibaba Cloud first checks the number of existing tags attached to the resource. If the quota is reached, an error message is returned.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, the GA instance is being modified. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the GA instance is modified.
 * *   The **UpdateAccelerator** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request UpdateAcceleratorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAcceleratorResponse
 */
func (client *Client) UpdateAcceleratorWithOptions(request *UpdateAcceleratorRequest, runtime *util.RuntimeOptions) (_result *UpdateAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoUseCoupon)) {
		query["AutoUseCoupon"] = request.AutoUseCoupon
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateAccelerator** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, the GA instance is being modified. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the GA instance is modified.
 * *   The **UpdateAccelerator** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request UpdateAcceleratorRequest
 * @return UpdateAcceleratorResponse
 */
func (client *Client) UpdateAccelerator(request *UpdateAcceleratorRequest) (_result *UpdateAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAcceleratorResponse{}
	_body, _err := client.UpdateAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The **UpdateAcceleratorAutoRenewAttribute** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request UpdateAcceleratorAutoRenewAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAcceleratorAutoRenewAttributeResponse
 */
func (client *Client) UpdateAcceleratorAutoRenewAttributeWithOptions(request *UpdateAcceleratorAutoRenewAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateAcceleratorAutoRenewAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenewDuration)) {
		query["AutoRenewDuration"] = request.AutoRenewDuration
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RenewalStatus)) {
		query["RenewalStatus"] = request.RenewalStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAcceleratorAutoRenewAttribute"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAcceleratorAutoRenewAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The **UpdateAcceleratorAutoRenewAttribute** operation cannot be repeatedly called for the same GA instance within a specific period of time.
 *
 * @param request UpdateAcceleratorAutoRenewAttributeRequest
 * @return UpdateAcceleratorAutoRenewAttributeResponse
 */
func (client *Client) UpdateAcceleratorAutoRenewAttribute(request *UpdateAcceleratorAutoRenewAttributeRequest) (_result *UpdateAcceleratorAutoRenewAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAcceleratorAutoRenewAttributeResponse{}
	_body, _err := client.UpdateAcceleratorAutoRenewAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you modify the specification of a GA instance, you must confirm the modification. The **UpdateAcceleratorConfirm** operation is used to confirm the specification of a GA instance that is modified. When you call this operation to confirm the specification of a GA instance, take note of the following items:
 * *   **UpdateAcceleratorConfirm** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that the specification of the instance is being modified. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, it indicates that the specification of the instance is modified.
 * *   The **UpdateAcceleratorConfirm** operation cannot be called repeatedly for the same GA instance within a specific period of time.
 *
 * @param request UpdateAcceleratorConfirmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAcceleratorConfirmResponse
 */
func (client *Client) UpdateAcceleratorConfirmWithOptions(request *UpdateAcceleratorConfirmRequest, runtime *util.RuntimeOptions) (_result *UpdateAcceleratorConfirmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAcceleratorConfirm"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAcceleratorConfirmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you modify the specification of a GA instance, you must confirm the modification. The **UpdateAcceleratorConfirm** operation is used to confirm the specification of a GA instance that is modified. When you call this operation to confirm the specification of a GA instance, take note of the following items:
 * *   **UpdateAcceleratorConfirm** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of a GA instance.
 *     *   If the GA instance is in the **configuring** state, it indicates that the specification of the instance is being modified. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, it indicates that the specification of the instance is modified.
 * *   The **UpdateAcceleratorConfirm** operation cannot be called repeatedly for the same GA instance within a specific period of time.
 *
 * @param request UpdateAcceleratorConfirmRequest
 * @return UpdateAcceleratorConfirmResponse
 */
func (client *Client) UpdateAcceleratorConfirm(request *UpdateAcceleratorConfirmRequest) (_result *UpdateAcceleratorConfirmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAcceleratorConfirmResponse{}
	_body, _err := client.UpdateAcceleratorConfirmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Prerequisites
 * You can call this operation to change the type of transmission network for a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**. Before you call this operation, make sure that the following requirements are met:
 * *   Cloud Data Transfer (CDT) is activated. When you call the [CreateAccelerator](~~206786~~) operation and set **BandwidthBillingType** to **CDT** to create a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**, CDT is automatically activated. The data transfer fees are managed by CDT.
 * *   If you want to set **CrossBorderMode** to **private**, which specifies cross-border Express Connect circuit as the type of transmission network, make sure that your enterprise account completed real-name verification. For more information, see [Real-name verification](~~52595~~).
 *
 * @param request UpdateAcceleratorCrossBorderModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAcceleratorCrossBorderModeResponse
 */
func (client *Client) UpdateAcceleratorCrossBorderModeWithOptions(request *UpdateAcceleratorCrossBorderModeRequest, runtime *util.RuntimeOptions) (_result *UpdateAcceleratorCrossBorderModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CrossBorderMode)) {
		query["CrossBorderMode"] = request.CrossBorderMode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAcceleratorCrossBorderMode"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAcceleratorCrossBorderModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Prerequisites
 * You can call this operation to change the type of transmission network for a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**. Before you call this operation, make sure that the following requirements are met:
 * *   Cloud Data Transfer (CDT) is activated. When you call the [CreateAccelerator](~~206786~~) operation and set **BandwidthBillingType** to **CDT** to create a **standard** GA instance whose bandwidth metering method is **pay-by-data-transfer**, CDT is automatically activated. The data transfer fees are managed by CDT.
 * *   If you want to set **CrossBorderMode** to **private**, which specifies cross-border Express Connect circuit as the type of transmission network, make sure that your enterprise account completed real-name verification. For more information, see [Real-name verification](~~52595~~).
 *
 * @param request UpdateAcceleratorCrossBorderModeRequest
 * @return UpdateAcceleratorCrossBorderModeResponse
 */
func (client *Client) UpdateAcceleratorCrossBorderMode(request *UpdateAcceleratorCrossBorderModeRequest) (_result *UpdateAcceleratorCrossBorderModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAcceleratorCrossBorderModeResponse{}
	_body, _err := client.UpdateAcceleratorCrossBorderModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use this operation to enable or disable the cross-border data transmission feature for a GA instance. Before you enable the cross-border data transmission feature, make sure that the following requirements are met:
 * - **Basic GA instances**:
 * Cloud Data Transfer (CDT) is activated. When you call the CreateBasicAccelerator operation to create a basic GA instance, set BandwidthBillingType to CDT. Then, the system automatically activates CDT. The data transfer fees are managed by CDT.
 * If you want to enable the cross-border data transmission feature, make sure that the current account has completed enterprise real-name registration. For more information, see Real-name registration FAQs.
 * - **Standard GA instances**:
 * CDT is activated. When you call the CreateAccelerator operation to create a standard GA instance, set BandwidthBillingType to CDT. Then, the system automatically activates CDT. The data transfer fees are managed by CDT.
 *
 * @param request UpdateAcceleratorCrossBorderStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAcceleratorCrossBorderStatusResponse
 */
func (client *Client) UpdateAcceleratorCrossBorderStatusWithOptions(request *UpdateAcceleratorCrossBorderStatusRequest, runtime *util.RuntimeOptions) (_result *UpdateAcceleratorCrossBorderStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CrossBorderStatus)) {
		query["CrossBorderStatus"] = request.CrossBorderStatus
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAcceleratorCrossBorderStatus"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAcceleratorCrossBorderStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use this operation to enable or disable the cross-border data transmission feature for a GA instance. Before you enable the cross-border data transmission feature, make sure that the following requirements are met:
 * - **Basic GA instances**:
 * Cloud Data Transfer (CDT) is activated. When you call the CreateBasicAccelerator operation to create a basic GA instance, set BandwidthBillingType to CDT. Then, the system automatically activates CDT. The data transfer fees are managed by CDT.
 * If you want to enable the cross-border data transmission feature, make sure that the current account has completed enterprise real-name registration. For more information, see Real-name registration FAQs.
 * - **Standard GA instances**:
 * CDT is activated. When you call the CreateAccelerator operation to create a standard GA instance, set BandwidthBillingType to CDT. Then, the system automatically activates CDT. The data transfer fees are managed by CDT.
 *
 * @param request UpdateAcceleratorCrossBorderStatusRequest
 * @return UpdateAcceleratorCrossBorderStatusResponse
 */
func (client *Client) UpdateAcceleratorCrossBorderStatus(request *UpdateAcceleratorCrossBorderStatusRequest) (_result *UpdateAcceleratorCrossBorderStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAcceleratorCrossBorderStatusResponse{}
	_body, _err := client.UpdateAcceleratorCrossBorderStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAclAttributeWithOptions(request *UpdateAclAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateAclAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAclAttribute"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAclAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAclAttribute(request *UpdateAclAttributeRequest) (_result *UpdateAclAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAclAttributeResponse{}
	_body, _err := client.UpdateAclAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The UpdateAdditionalCertificateWithListener operation is used to replace an additional certificate. You can use this operation when you want to replace an expired additional certificate with a new additional certificate without changing the associated domain name.
 * *   **UpdateAdditionalCertificateWithListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can use the [ListListenerCertificates](~~307743~~) operation to query the state of the additional certificate that is associated with an HTTP listener:
 *     *   If the certificate that you want to replace is in the **updating** state, it is being replaced for the HTTP listener. In this case, you can perform only query operations.
 *     *   If the replacement certificate is in the **active** state, it indicates that the replacement operation is complete and the replacement certificate is associated with the HTTP listener.
 * *   You cannot perform the **UpdateAdditionalCertificateWithListener** operation again on the same Global Accelerator (GA) instance before the previous operation is complete.
 *
 * @param request UpdateAdditionalCertificateWithListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAdditionalCertificateWithListenerResponse
 */
func (client *Client) UpdateAdditionalCertificateWithListenerWithOptions(request *UpdateAdditionalCertificateWithListenerRequest, runtime *util.RuntimeOptions) (_result *UpdateAdditionalCertificateWithListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.CertificateId)) {
		query["CertificateId"] = request.CertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAdditionalCertificateWithListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAdditionalCertificateWithListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The UpdateAdditionalCertificateWithListener operation is used to replace an additional certificate. You can use this operation when you want to replace an expired additional certificate with a new additional certificate without changing the associated domain name.
 * *   **UpdateAdditionalCertificateWithListener** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can use the [ListListenerCertificates](~~307743~~) operation to query the state of the additional certificate that is associated with an HTTP listener:
 *     *   If the certificate that you want to replace is in the **updating** state, it is being replaced for the HTTP listener. In this case, you can perform only query operations.
 *     *   If the replacement certificate is in the **active** state, it indicates that the replacement operation is complete and the replacement certificate is associated with the HTTP listener.
 * *   You cannot perform the **UpdateAdditionalCertificateWithListener** operation again on the same Global Accelerator (GA) instance before the previous operation is complete.
 *
 * @param request UpdateAdditionalCertificateWithListenerRequest
 * @return UpdateAdditionalCertificateWithListenerResponse
 */
func (client *Client) UpdateAdditionalCertificateWithListener(request *UpdateAdditionalCertificateWithListenerRequest) (_result *UpdateAdditionalCertificateWithListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAdditionalCertificateWithListenerResponse{}
	_body, _err := client.UpdateAdditionalCertificateWithListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **UpdateApplicationMonitor** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeApplicationMonitor](~~408463~~) or [ListApplicationMonitor](~~408462~~) operation to check whether the configurations of an origin probing task are modified.
 * *   If the values of modified parameters remain unchanged, it indicates that the origin probing task is being modified. In this case, you can perform only query operations.
 * *   If the values of modified parameters change, it indicates that the origin probing task is modified.
 *
 * @param request UpdateApplicationMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateApplicationMonitorResponse
 */
func (client *Client) UpdateApplicationMonitorWithOptions(request *UpdateApplicationMonitorRequest, runtime *util.RuntimeOptions) (_result *UpdateApplicationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DetectEnable)) {
		query["DetectEnable"] = request.DetectEnable
	}

	if !tea.BoolValue(util.IsUnset(request.DetectThreshold)) {
		query["DetectThreshold"] = request.DetectThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.DetectTimes)) {
		query["DetectTimes"] = request.DetectTimes
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.OptionsJson)) {
		query["OptionsJson"] = request.OptionsJson
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SilenceTime)) {
		query["SilenceTime"] = request.SilenceTime
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateApplicationMonitor"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateApplicationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **UpdateApplicationMonitor** is an asynchronous operation. After you send a request, the system returns a request ID, but this operation is still being performed in the system background. You can call the [DescribeApplicationMonitor](~~408463~~) or [ListApplicationMonitor](~~408462~~) operation to check whether the configurations of an origin probing task are modified.
 * *   If the values of modified parameters remain unchanged, it indicates that the origin probing task is being modified. In this case, you can perform only query operations.
 * *   If the values of modified parameters change, it indicates that the origin probing task is modified.
 *
 * @param request UpdateApplicationMonitorRequest
 * @return UpdateApplicationMonitorResponse
 */
func (client *Client) UpdateApplicationMonitor(request *UpdateApplicationMonitorRequest) (_result *UpdateApplicationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateApplicationMonitorResponse{}
	_body, _err := client.UpdateApplicationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdateBandwidthPackagaAutoRenewAttribute** operation to modify the auto-renewal settings of a bandwidth plan.
 *
 * @param request UpdateBandwidthPackagaAutoRenewAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBandwidthPackagaAutoRenewAttributeResponse
 */
func (client *Client) UpdateBandwidthPackagaAutoRenewAttributeWithOptions(request *UpdateBandwidthPackagaAutoRenewAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateBandwidthPackagaAutoRenewAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenewDuration)) {
		query["AutoRenewDuration"] = request.AutoRenewDuration
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RenewalStatus)) {
		query["RenewalStatus"] = request.RenewalStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBandwidthPackagaAutoRenewAttribute"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBandwidthPackagaAutoRenewAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot repeatedly call the **UpdateBandwidthPackagaAutoRenewAttribute** operation to modify the auto-renewal settings of a bandwidth plan.
 *
 * @param request UpdateBandwidthPackagaAutoRenewAttributeRequest
 * @return UpdateBandwidthPackagaAutoRenewAttributeResponse
 */
func (client *Client) UpdateBandwidthPackagaAutoRenewAttribute(request *UpdateBandwidthPackagaAutoRenewAttributeRequest) (_result *UpdateBandwidthPackagaAutoRenewAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBandwidthPackagaAutoRenewAttributeResponse{}
	_body, _err := client.UpdateBandwidthPackagaAutoRenewAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Take note of the following items:
 * *   **UpdateBandwidthPackage** is a synchronous operation when you call the operation to modify the configuration excluding the bandwidth value of a bandwidth plan. The new configuration immediately takes effect after the operation is performed.
 * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is not associated with a Global Accelerator (GA) instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the task.
 *     *   If the parameter values of the bandwidth plan remain unchanged, the bandwidth plan is being modified. In this case, you can perform only query operations.
 *     *   If the parameter values of the bandwidth plan are changed, the bandwidth plan is modified.
 * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is associated with a GA instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of the task.
 *     *   If the GA instance is in the **configuring** state, the bandwidth plan is being modified. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the bandwidth plan is modified.
 * *   You cannot repeatedly call the **UpdateBandwidthPackage** operation for the same bandwidth plan within a specific period of time.
 *
 * @param request UpdateBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBandwidthPackageResponse
 */
func (client *Client) UpdateBandwidthPackageWithOptions(request *UpdateBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *UpdateBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoUseCoupon)) {
		query["AutoUseCoupon"] = request.AutoUseCoupon
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageId)) {
		query["BandwidthPackageId"] = request.BandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthType)) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBandwidthPackage"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Take note of the following items:
 * *   **UpdateBandwidthPackage** is a synchronous operation when you call the operation to modify the configuration excluding the bandwidth value of a bandwidth plan. The new configuration immediately takes effect after the operation is performed.
 * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is not associated with a Global Accelerator (GA) instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeBandwidthPackage](~~153241~~) operation to query the status of the task.
 *     *   If the parameter values of the bandwidth plan remain unchanged, the bandwidth plan is being modified. In this case, you can perform only query operations.
 *     *   If the parameter values of the bandwidth plan are changed, the bandwidth plan is modified.
 * *   **UpdateBandwidthPackage** is an asynchronous operation when you call the operation to modify the configuration including the bandwidth value of a bandwidth plan that is associated with a GA instance. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeAccelerator](~~153235~~) operation to query the status of the task.
 *     *   If the GA instance is in the **configuring** state, the bandwidth plan is being modified. In this case, you can perform only query operations.
 *     *   If the GA instance is in the **active** state, the bandwidth plan is modified.
 * *   You cannot repeatedly call the **UpdateBandwidthPackage** operation for the same bandwidth plan within a specific period of time.
 *
 * @param request UpdateBandwidthPackageRequest
 * @return UpdateBandwidthPackageResponse
 */
func (client *Client) UpdateBandwidthPackage(request *UpdateBandwidthPackageRequest) (_result *UpdateBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBandwidthPackageResponse{}
	_body, _err := client.UpdateBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateBasicAcceleratorWithOptions(request *UpdateBasicAcceleratorRequest, runtime *util.RuntimeOptions) (_result *UpdateBasicAcceleratorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBasicAccelerator"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBasicAcceleratorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateBasicAccelerator(request *UpdateBasicAcceleratorRequest) (_result *UpdateBasicAcceleratorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBasicAcceleratorResponse{}
	_body, _err := client.UpdateBasicAcceleratorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateBasicEndpointWithOptions(request *UpdateBasicEndpointRequest, runtime *util.RuntimeOptions) (_result *UpdateBasicEndpointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBasicEndpoint"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBasicEndpointResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateBasicEndpoint(request *UpdateBasicEndpointRequest) (_result *UpdateBasicEndpointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBasicEndpointResponse{}
	_body, _err := client.UpdateBasicEndpointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateBasicEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. After you call this operation to modify an endpoint group that is associated with a basic GA instance, the system deletes the endpoint group and creates another endpoint group in the background for the basic GA instance. You can call the [GetBasicAccelerator](~~353188~~) operation to query the state of the basic GA instance.
 *     *   If the basic GA instance is in the **configuring** state, it indicates that the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If the basic GA instance is in the **active** state, it indicates that the configurations of the endpoint group are modified.
 * *   The **UpdateBasicEndpointGroup** operation cannot be called repeatedly for the same basic GA instance within a specific period of time.
 *
 * @param request UpdateBasicEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBasicEndpointGroupResponse
 */
func (client *Client) UpdateBasicEndpointGroupWithOptions(request *UpdateBasicEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateBasicEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointAddress)) {
		query["EndpointAddress"] = request.EndpointAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointSubAddress)) {
		query["EndpointSubAddress"] = request.EndpointSubAddress
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointType)) {
		query["EndpointType"] = request.EndpointType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBasicEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBasicEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateBasicEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. After you call this operation to modify an endpoint group that is associated with a basic GA instance, the system deletes the endpoint group and creates another endpoint group in the background for the basic GA instance. You can call the [GetBasicAccelerator](~~353188~~) operation to query the state of the basic GA instance.
 *     *   If the basic GA instance is in the **configuring** state, it indicates that the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If the basic GA instance is in the **active** state, it indicates that the configurations of the endpoint group are modified.
 * *   The **UpdateBasicEndpointGroup** operation cannot be called repeatedly for the same basic GA instance within a specific period of time.
 *
 * @param request UpdateBasicEndpointGroupRequest
 * @return UpdateBasicEndpointGroupResponse
 */
func (client *Client) UpdateBasicEndpointGroup(request *UpdateBasicEndpointGroupRequest) (_result *UpdateBasicEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBasicEndpointGroupResponse{}
	_body, _err := client.UpdateBasicEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   You can call this operation for only basic GA instances whose bandwidth is billed by Cloud Data Transfer (CDT).
 * *   The **UpdateBasicIpSet** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the background. You can call the [GetBasicIpSet](~~362987~~) operation to query the status of an acceleration region:
 *     *   If an acceleration region is in the **updating** state, the bandwidth of the acceleration region is being modified. In this state, you can perform only query operations.
 *     *   If an acceleration region is in the **active** state, the bandwidth of the acceleration region is modified.
 * *   You cannot repeatedly call the **UpdateBasicIpSet** operation for the same basic GA instance within the specified period of time.
 *
 * @param request UpdateBasicIpSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBasicIpSetResponse
 */
func (client *Client) UpdateBasicIpSetWithOptions(request *UpdateBasicIpSetRequest, runtime *util.RuntimeOptions) (_result *UpdateBasicIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBasicIpSet"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBasicIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following limits:
 * *   You can call this operation for only basic GA instances whose bandwidth is billed by Cloud Data Transfer (CDT).
 * *   The **UpdateBasicIpSet** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the background. You can call the [GetBasicIpSet](~~362987~~) operation to query the status of an acceleration region:
 *     *   If an acceleration region is in the **updating** state, the bandwidth of the acceleration region is being modified. In this state, you can perform only query operations.
 *     *   If an acceleration region is in the **active** state, the bandwidth of the acceleration region is modified.
 * *   You cannot repeatedly call the **UpdateBasicIpSet** operation for the same basic GA instance within the specified period of time.
 *
 * @param request UpdateBasicIpSetRequest
 * @return UpdateBasicIpSetResponse
 */
func (client *Client) UpdateBasicIpSet(request *UpdateBasicIpSetRequest) (_result *UpdateBasicIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBasicIpSetResponse{}
	_body, _err := client.UpdateBasicIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateCustomRoutingEndpointGroupAttributeWithOptions(request *UpdateCustomRoutingEndpointGroupAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateCustomRoutingEndpointGroupAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCustomRoutingEndpointGroupAttribute"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCustomRoutingEndpointGroupAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateCustomRoutingEndpointGroupAttribute(request *UpdateCustomRoutingEndpointGroupAttributeRequest) (_result *UpdateCustomRoutingEndpointGroupAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCustomRoutingEndpointGroupAttributeResponse{}
	_body, _err := client.UpdateCustomRoutingEndpointGroupAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of an endpoint group associated with a custom routing listener to check whether the mapping configurations of the endpoint group are modified.
 *     *   If the endpoint group is in the **updating** state, the mapping configurations of the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, the mapping configurations of the endpoint group are modified.
 * *   The **UpdateCustomRoutingEndpointGroupDestinations** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateCustomRoutingEndpointGroupDestinationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomRoutingEndpointGroupDestinationsResponse
 */
func (client *Client) UpdateCustomRoutingEndpointGroupDestinationsWithOptions(request *UpdateCustomRoutingEndpointGroupDestinationsRequest, runtime *util.RuntimeOptions) (_result *UpdateCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationConfigurations)) {
		query["DestinationConfigurations"] = request.DestinationConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCustomRoutingEndpointGroupDestinations"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateCustomRoutingEndpointGroupDestinations** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of an endpoint group associated with a custom routing listener to check whether the mapping configurations of the endpoint group are modified.
 *     *   If the endpoint group is in the **updating** state, the mapping configurations of the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, the mapping configurations of the endpoint group are modified.
 * *   The **UpdateCustomRoutingEndpointGroupDestinations** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateCustomRoutingEndpointGroupDestinationsRequest
 * @return UpdateCustomRoutingEndpointGroupDestinationsResponse
 */
func (client *Client) UpdateCustomRoutingEndpointGroupDestinations(request *UpdateCustomRoutingEndpointGroupDestinationsRequest) (_result *UpdateCustomRoutingEndpointGroupDestinationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCustomRoutingEndpointGroupDestinationsResponse{}
	_body, _err := client.UpdateCustomRoutingEndpointGroupDestinationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of the task.
 *     *   If the endpoint group is in the **updating** state, traffic policies are being modified for endpoints in the endpoint group. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, traffic policies are modified for endpoints in the endpoint group.
 * *   The **UpdateCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateCustomRoutingEndpointTrafficPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomRoutingEndpointTrafficPoliciesResponse
 */
func (client *Client) UpdateCustomRoutingEndpointTrafficPoliciesWithOptions(request *UpdateCustomRoutingEndpointTrafficPoliciesRequest, runtime *util.RuntimeOptions) (_result *UpdateCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointId)) {
		query["EndpointId"] = request.EndpointId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyConfigurations)) {
		query["PolicyConfigurations"] = request.PolicyConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCustomRoutingEndpointTrafficPolicies"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateCustomRoutingEndpointTrafficPolicies** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the status of the task.
 *     *   If the endpoint group is in the **updating** state, traffic policies are being modified for endpoints in the endpoint group. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, traffic policies are modified for endpoints in the endpoint group.
 * *   The **UpdateCustomRoutingEndpointTrafficPolicies** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateCustomRoutingEndpointTrafficPoliciesRequest
 * @return UpdateCustomRoutingEndpointTrafficPoliciesResponse
 */
func (client *Client) UpdateCustomRoutingEndpointTrafficPolicies(request *UpdateCustomRoutingEndpointTrafficPoliciesRequest) (_result *UpdateCustomRoutingEndpointTrafficPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCustomRoutingEndpointTrafficPoliciesResponse{}
	_body, _err := client.UpdateCustomRoutingEndpointTrafficPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * *   **UpdateCustomRoutingEndpoints** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the state of the endpoint groups associated with a custom routing listener to check whether the endpoints in the endpoint groups are modified.
 *     *   If an endpoint group is in the **updating** state, the endpoints in the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If an endpoint group is in the **active** state, the endpoints in the endpoint group are modified.
 * *   The **UpdateCustomRoutingEndpoints** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateCustomRoutingEndpointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomRoutingEndpointsResponse
 */
func (client *Client) UpdateCustomRoutingEndpointsWithOptions(request *UpdateCustomRoutingEndpointsRequest, runtime *util.RuntimeOptions) (_result *UpdateCustomRoutingEndpointsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointConfigurations)) {
		query["EndpointConfigurations"] = request.EndpointConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCustomRoutingEndpoints"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCustomRoutingEndpointsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * *   **UpdateCustomRoutingEndpoints** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeCustomRoutingEndpointGroup](~~449373~~) operation to query the state of the endpoint groups associated with a custom routing listener to check whether the endpoints in the endpoint groups are modified.
 *     *   If an endpoint group is in the **updating** state, the endpoints in the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If an endpoint group is in the **active** state, the endpoints in the endpoint group are modified.
 * *   The **UpdateCustomRoutingEndpoints** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateCustomRoutingEndpointsRequest
 * @return UpdateCustomRoutingEndpointsResponse
 */
func (client *Client) UpdateCustomRoutingEndpoints(request *UpdateCustomRoutingEndpointsRequest) (_result *UpdateCustomRoutingEndpointsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCustomRoutingEndpointsResponse{}
	_body, _err := client.UpdateCustomRoutingEndpointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to modify an accelerated domain name. If the new accelerated domain name is hosted in the Chinese mainland, you must obtain an Internet content provider (ICP) number for the domain name.
 * You cannot call the **UpdateDomain** operation again by using the same Alibaba Cloud account before the previous request is completed.
 *
 * @param request UpdateDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainResponse
 */
func (client *Client) UpdateDomainWithOptions(request *UpdateDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDomain)) {
		query["TargetDomain"] = request.TargetDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDomain"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to modify an accelerated domain name. If the new accelerated domain name is hosted in the Chinese mainland, you must obtain an Internet content provider (ICP) number for the domain name.
 * You cannot call the **UpdateDomain** operation again by using the same Alibaba Cloud account before the previous request is completed.
 *
 * @param request UpdateDomainRequest
 * @return UpdateDomainResponse
 */
func (client *Client) UpdateDomain(request *UpdateDomainRequest) (_result *UpdateDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDomainResponse{}
	_body, _err := client.UpdateDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query and update the ICP filing status of an accelerated domain name.
 * The **UpdateDomainState** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation with the same Alibaba Cloud account.
 *
 * @param request UpdateDomainStateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainStateResponse
 */
func (client *Client) UpdateDomainStateWithOptions(request *UpdateDomainStateRequest, runtime *util.RuntimeOptions) (_result *UpdateDomainStateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDomainState"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDomainStateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query and update the ICP filing status of an accelerated domain name.
 * The **UpdateDomainState** operation holds an exclusive lock on the GA instance. While the operation is in progress, you cannot call the same operation with the same Alibaba Cloud account.
 *
 * @param request UpdateDomainStateRequest
 * @return UpdateDomainStateResponse
 */
func (client *Client) UpdateDomainState(request *UpdateDomainStateRequest) (_result *UpdateDomainStateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDomainStateResponse{}
	_body, _err := client.UpdateDomainStateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, it indicates that the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that the configurations of the endpoint group are modified.
 * *   The **UpdateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateEndpointGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEndpointGroupResponse
 */
func (client *Client) UpdateEndpointGroupWithOptions(request *UpdateEndpointGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateEndpointGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointConfigurations)) {
		query["EndpointConfigurations"] = request.EndpointConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupRegion)) {
		query["EndpointGroupRegion"] = request.EndpointGroupRegion
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointRequestProtocol)) {
		query["EndpointRequestProtocol"] = request.EndpointRequestProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckEnabled)) {
		query["HealthCheckEnabled"] = request.HealthCheckEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckIntervalSeconds)) {
		query["HealthCheckIntervalSeconds"] = request.HealthCheckIntervalSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckPath)) {
		query["HealthCheckPath"] = request.HealthCheckPath
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckPort)) {
		query["HealthCheckPort"] = request.HealthCheckPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckProtocol)) {
		query["HealthCheckProtocol"] = request.HealthCheckProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PortOverrides)) {
		query["PortOverrides"] = request.PortOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ThresholdCount)) {
		query["ThresholdCount"] = request.ThresholdCount
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficPercentage)) {
		query["TrafficPercentage"] = request.TrafficPercentage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEndpointGroup"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEndpointGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateEndpointGroup** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [DescribeEndpointGroup](~~153260~~) operation to query the state of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, it indicates that the configurations of the endpoint group are being modified. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that the configurations of the endpoint group are modified.
 * *   The **UpdateEndpointGroup** operation cannot be repeatedly called for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateEndpointGroupRequest
 * @return UpdateEndpointGroupResponse
 */
func (client *Client) UpdateEndpointGroup(request *UpdateEndpointGroupRequest) (_result *UpdateEndpointGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEndpointGroupResponse{}
	_body, _err := client.UpdateEndpointGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEndpointGroupAttributeWithOptions(request *UpdateEndpointGroupAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateEndpointGroupAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupId)) {
		query["EndpointGroupId"] = request.EndpointGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEndpointGroupAttribute"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEndpointGroupAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEndpointGroupAttribute(request *UpdateEndpointGroupAttributeRequest) (_result *UpdateEndpointGroupAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEndpointGroupAttributeResponse{}
	_body, _err := client.UpdateEndpointGroupAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Description
 * *   **UpdateEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) or [ListEndpointGroups](~~153261~~) operation to query the status of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, it indicates that the configuration of the endpoint group is being modified. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that the configuration of the endpoint group is modified.
 * *   The **UpdateEndpointGroups** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request UpdateEndpointGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEndpointGroupsResponse
 */
func (client *Client) UpdateEndpointGroupsWithOptions(request *UpdateEndpointGroupsRequest, runtime *util.RuntimeOptions) (_result *UpdateEndpointGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EndpointGroupConfigurations)) {
		query["EndpointGroupConfigurations"] = request.EndpointGroupConfigurations
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEndpointGroups"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEndpointGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Description
 * *   **UpdateEndpointGroups** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeEndpointGroup](~~153260~~) or [ListEndpointGroups](~~153261~~) operation to query the status of an endpoint group.
 *     *   If the endpoint group is in the **updating** state, it indicates that the configuration of the endpoint group is being modified. In this case, you can perform only query operations.
 *     *   If the endpoint group is in the **active** state, it indicates that the configuration of the endpoint group is modified.
 * *   The **UpdateEndpointGroups** operation holds an exclusive lock on the Global Accelerator (GA) instance. While the operation is in progress, you cannot call the same operation in the same Alibaba Cloud account.
 *
 * @param request UpdateEndpointGroupsRequest
 * @return UpdateEndpointGroupsResponse
 */
func (client *Client) UpdateEndpointGroups(request *UpdateEndpointGroupsRequest) (_result *UpdateEndpointGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEndpointGroupsResponse{}
	_body, _err := client.UpdateEndpointGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateForwardingRules** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [ListForwardingRules](~~205817~~) operation to query the state of a forwarding rule.
 *     *   If the forwarding rule is in the **configuring** state, it indicates that the forwarding rule is being modified. In this case, you can perform only query operations.
 *     *   If the forwarding rule is in the **active** state, it indicates that the forwarding rule is modified.
 * *   The **UpdateForwardingRules** operation cannot be repeatedly called to modify forwarding rules for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateForwardingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateForwardingRulesResponse
 */
func (client *Client) UpdateForwardingRulesWithOptions(request *UpdateForwardingRulesRequest, runtime *util.RuntimeOptions) (_result *UpdateForwardingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceleratorId)) {
		query["AcceleratorId"] = request.AcceleratorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardingRules)) {
		query["ForwardingRules"] = request.ForwardingRules
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateForwardingRules"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateForwardingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateForwardingRules** is an asynchronous operation. After you send a request, the system returns a request ID, but the operation is still being performed in the system background. You can call the [ListForwardingRules](~~205817~~) operation to query the state of a forwarding rule.
 *     *   If the forwarding rule is in the **configuring** state, it indicates that the forwarding rule is being modified. In this case, you can perform only query operations.
 *     *   If the forwarding rule is in the **active** state, it indicates that the forwarding rule is modified.
 * *   The **UpdateForwardingRules** operation cannot be repeatedly called to modify forwarding rules for the same Global Accelerator (GA) instance within a specific period of time.
 *
 * @param request UpdateForwardingRulesRequest
 * @return UpdateForwardingRulesResponse
 */
func (client *Client) UpdateForwardingRules(request *UpdateForwardingRulesRequest) (_result *UpdateForwardingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateForwardingRulesResponse{}
	_body, _err := client.UpdateForwardingRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateIpSet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of an acceleration region.
 *     *   If the acceleration region is in the **updating** state, it indicates that the acceleration region is being modified. In this case, you can continue to perform query operations on the acceleration regions.
 *     *   If the acceleration region is in the **active** state, it indicates that the acceleration region is modified.
 * *   You cannot call the **UpdateIpSet** operation again on the same GA instance before the previous operation is complete.
 *
 * @param request UpdateIpSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIpSetResponse
 */
func (client *Client) UpdateIpSetWithOptions(request *UpdateIpSetRequest, runtime *util.RuntimeOptions) (_result *UpdateIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.IpSetId)) {
		query["IpSetId"] = request.IpSetId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIpSet"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateIpSet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of an acceleration region.
 *     *   If the acceleration region is in the **updating** state, it indicates that the acceleration region is being modified. In this case, you can continue to perform query operations on the acceleration regions.
 *     *   If the acceleration region is in the **active** state, it indicates that the acceleration region is modified.
 * *   You cannot call the **UpdateIpSet** operation again on the same GA instance before the previous operation is complete.
 *
 * @param request UpdateIpSetRequest
 * @return UpdateIpSetResponse
 */
func (client *Client) UpdateIpSet(request *UpdateIpSetRequest) (_result *UpdateIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIpSetResponse{}
	_body, _err := client.UpdateIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   **UpdateIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of the task.
 *     *   If an acceleration region is in the **updating** state, the acceleration region is being modified. In this case, you can perform only query operations.
 *     *   If an acceleration region is in the **active** state, the acceleration region is modified.
 * *   You cannot repeatedly call the **UpdateIpSet** operation for the same GA instance within a specific period of time.
 *
 * @param request UpdateIpSetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIpSetsResponse
 */
func (client *Client) UpdateIpSetsWithOptions(request *UpdateIpSetsRequest, runtime *util.RuntimeOptions) (_result *UpdateIpSetsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpSets)) {
		query["IpSets"] = request.IpSets
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIpSets"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIpSetsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   **UpdateIpSet** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [DescribeIpSet](~~153246~~) operation to query the status of the task.
 *     *   If an acceleration region is in the **updating** state, the acceleration region is being modified. In this case, you can perform only query operations.
 *     *   If an acceleration region is in the **active** state, the acceleration region is modified.
 * *   You cannot repeatedly call the **UpdateIpSet** operation for the same GA instance within a specific period of time.
 *
 * @param request UpdateIpSetsRequest
 * @return UpdateIpSetsResponse
 */
func (client *Client) UpdateIpSets(request *UpdateIpSetsRequest) (_result *UpdateIpSetsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIpSetsResponse{}
	_body, _err := client.UpdateIpSetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation can be called to modify the configurations such as the protocol and ports of a listener to meet your business requirements.
 * When you call this operation, take note of the following items:
 * *   **UpdateListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the status of a listener.
 *     *   If the listener is in the **updating** state, it indicates that its configurations are being modified. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that its configurations are modified.
 * *   The **UpdateListener** operation cannot be repeatedly called to modify listener configurations for the same GA instance within a specific period of time.
 *
 * @param request UpdateListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateListenerResponse
 */
func (client *Client) UpdateListenerWithOptions(request *UpdateListenerRequest, runtime *util.RuntimeOptions) (_result *UpdateListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendPorts)) {
		query["BackendPorts"] = request.BackendPorts
	}

	if !tea.BoolValue(util.IsUnset(request.Certificates)) {
		query["Certificates"] = request.Certificates
	}

	if !tea.BoolValue(util.IsUnset(request.ClientAffinity)) {
		query["ClientAffinity"] = request.ClientAffinity
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerId)) {
		query["ListenerId"] = request.ListenerId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PortRanges)) {
		query["PortRanges"] = request.PortRanges
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		query["Protocol"] = request.Protocol
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyProtocol)) {
		query["ProxyProtocol"] = request.ProxyProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityPolicyId)) {
		query["SecurityPolicyId"] = request.SecurityPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedForConfig)) {
		query["XForwardedForConfig"] = request.XForwardedForConfig
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateListener"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation can be called to modify the configurations such as the protocol and ports of a listener to meet your business requirements.
 * When you call this operation, take note of the following items:
 * *   **UpdateListener** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [DescribeListener](~~153254~~) operation to query the status of a listener.
 *     *   If the listener is in the **updating** state, it indicates that its configurations are being modified. In this case, you can perform only query operations.
 *     *   If the listener is in the **active** state, it indicates that its configurations are modified.
 * *   The **UpdateListener** operation cannot be repeatedly called to modify listener configurations for the same GA instance within a specific period of time.
 *
 * @param request UpdateListenerRequest
 * @return UpdateListenerResponse
 */
func (client *Client) UpdateListener(request *UpdateListenerRequest) (_result *UpdateListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateListenerResponse{}
	_body, _err := client.UpdateListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation is applicable only to **managed** Global Accelerator (GA) instances.
 * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you cannot change the mode of the instance to managed mode.
 * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you can obtain all operation permissions on the instance.
 *     **
 *     **Warning** If you change or delete a configuration of a GA instance whose control mode is changed from managed mode to unmanaged mode, the cloud services that depend on the instance may not work as expected. Proceed with caution.
 *
 * @param request UpdateServiceManagedControlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServiceManagedControlResponse
 */
func (client *Client) UpdateServiceManagedControlWithOptions(request *UpdateServiceManagedControlRequest, runtime *util.RuntimeOptions) (_result *UpdateServiceManagedControlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceManaged)) {
		query["ServiceManaged"] = request.ServiceManaged
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateServiceManagedControl"),
		Version:     tea.String("2019-11-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateServiceManagedControlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation is applicable only to **managed** Global Accelerator (GA) instances.
 * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you cannot change the mode of the instance to managed mode.
 * *   After you change the control mode of a GA instance from managed mode to unmanaged mode, you can obtain all operation permissions on the instance.
 *     **
 *     **Warning** If you change or delete a configuration of a GA instance whose control mode is changed from managed mode to unmanaged mode, the cloud services that depend on the instance may not work as expected. Proceed with caution.
 *
 * @param request UpdateServiceManagedControlRequest
 * @return UpdateServiceManagedControlResponse
 */
func (client *Client) UpdateServiceManagedControl(request *UpdateServiceManagedControlRequest) (_result *UpdateServiceManagedControlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateServiceManagedControlResponse{}
	_body, _err := client.UpdateServiceManagedControlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
